import __buffer_polyfill from 'vite-plugin-node-polyfills/shims/buffer'
globalThis.Buffer = globalThis.Buffer || __buffer_polyfill
import __global_polyfill from 'vite-plugin-node-polyfills/shims/global'
globalThis.global = globalThis.global || __global_polyfill
import __process_polyfill from 'vite-plugin-node-polyfills/shims/process'
globalThis.process = globalThis.process || __process_polyfill

import {
  require_toInteger
} from "./chunk-LPGHV4NL.js";
import {
  require_has,
  require_toString
} from "./chunk-PYQODTGJ.js";
import {
  require_i18n
} from "./chunk-SFZFMFKO.js";
import {
  require_isIterateeCall
} from "./chunk-RQTG6R3C.js";
import {
  require_toNumber
} from "./chunk-CTKMSYPV.js";
import {
  require_isObjectLike
} from "./chunk-YCW3LPUS.js";
import {
  require_baseGetTag,
  require_root
} from "./chunk-ONA6R2CQ.js";
import {
  __commonJS,
  __toESM,
  require_dist,
  require_dist2,
  require_dist3
} from "./chunk-2RF6DQJU.js";

// node_modules/lodash/isNumber.js
var require_isNumber = __commonJS({
  "node_modules/lodash/isNumber.js"(exports, module) {
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    var baseGetTag = require_baseGetTag();
    var isObjectLike = require_isObjectLike();
    var numberTag = "[object Number]";
    function isNumber(value) {
      return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
    }
    module.exports = isNumber;
  }
});

// node_modules/lodash/_createRound.js
var require_createRound = __commonJS({
  "node_modules/lodash/_createRound.js"(exports, module) {
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    var root = require_root();
    var toInteger = require_toInteger();
    var toNumber = require_toNumber();
    var toString = require_toString();
    var nativeIsFinite = root.isFinite;
    var nativeMin = Math.min;
    function createRound(methodName) {
      var func = Math[methodName];
      return function(number, precision) {
        number = toNumber(number);
        precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
        if (precision && nativeIsFinite(number)) {
          var pair = (toString(number) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
          pair = (toString(value) + "e").split("e");
          return +(pair[0] + "e" + (+pair[1] - precision));
        }
        return func(number);
      };
    }
    module.exports = createRound;
  }
});

// node_modules/lodash/round.js
var require_round = __commonJS({
  "node_modules/lodash/round.js"(exports, module) {
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    var createRound = require_createRound();
    var round = createRound("round");
    module.exports = round;
  }
});

// node_modules/@splunk/ui-utils/math.js
var require_math = __commonJS({
  "node_modules/@splunk/ui-utils/math.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.strictParseFloat = strictParseFloat;
    exports.roundToDecimal = roundToDecimal;
    exports.floorPowerOfTen = floorPowerOfTen;
    exports.isLessThanMinSafeInt = isLessThanMinSafeInt;
    exports.isGreaterThanMaxSafeInt = isGreaterThanMaxSafeInt;
    var _isNumber = _interopRequireDefault(require_isNumber());
    var _round = _interopRequireDefault(require_round());
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    var decimalOrScientificRegex = /(^[-+]?[0-9]*[.]?[0-9]*$)|(^[-+]?[0-9][.]?[0-9]*e[-+]?[0-9][0-9]*$)/i;
    var minSafeInteger = -9007199254740991;
    var maxSafeInteger = 9007199254740991;
    function strictParseFloat(string) {
      return !decimalOrScientificRegex.test(string) ? NaN : parseFloat(string);
    }
    function roundToDecimal(value) {
      var exp = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      return (0, _round["default"])(value, exp * -1);
    }
    function floorPowerOfTen(number) {
      return Math.pow(10, Math.floor(Math.log(number) / Math.LN10));
    }
    function isLessThanMinSafeInt(number) {
      if (!(0, _isNumber["default"])(number)) {
        return false;
      }
      return number <= minSafeInteger;
    }
    function isGreaterThanMaxSafeInt(number) {
      if (!(0, _isNumber["default"])(number)) {
        return false;
      }
      return number >= maxSafeInteger;
    }
  }
});

// node_modules/lodash/_baseRepeat.js
var require_baseRepeat = __commonJS({
  "node_modules/lodash/_baseRepeat.js"(exports, module) {
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    var MAX_SAFE_INTEGER = 9007199254740991;
    var nativeFloor = Math.floor;
    function baseRepeat(string, n) {
      var result = "";
      if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
        return result;
      }
      do {
        if (n % 2) {
          result += string;
        }
        n = nativeFloor(n / 2);
        if (n) {
          string += string;
        }
      } while (n);
      return result;
    }
    module.exports = baseRepeat;
  }
});

// node_modules/lodash/repeat.js
var require_repeat = __commonJS({
  "node_modules/lodash/repeat.js"(exports, module) {
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    var baseRepeat = require_baseRepeat();
    var isIterateeCall = require_isIterateeCall();
    var toInteger = require_toInteger();
    var toString = require_toString();
    function repeat(string, n, guard) {
      if (guard ? isIterateeCall(string, n, guard) : n === void 0) {
        n = 1;
      } else {
        n = toInteger(n);
      }
      return baseRepeat(toString(string), n);
    }
    module.exports = repeat;
  }
});

// node_modules/@splunk/ui-utils/sprintf.js
var require_sprintf = __commonJS({
  "node_modules/@splunk/ui-utils/sprintf.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.sprintfFormat = sprintfFormat;
    exports.sprintfParse = sprintfParse;
    var _has = _interopRequireDefault(require_has());
    var _repeat = _interopRequireDefault(require_repeat());
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    var re = {
      notType: /[^T]/,
      notPrimitive: /[^v]/,
      number: /[diefg]/,
      numericArg: /[bcdiefguxX]/,
      json: /[j]/,
      text: /^[^\x25]+/,
      modulo: /^\x25{2}/,
      placeholder: /^\x25(?:([1-9]\d*)\$|\(([^)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-gijostTuvxX])/,
      key: /^([a-z_][a-z_\d]*)/i,
      keyAccess: /^\.([a-z_][a-z_\d]*)/i,
      indexAccess: /^\[(\d+)\]/,
      sign: /^[+-]/
    };
    function sprintf(key) {
      for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        rest[_key - 1] = arguments[_key];
      }
      return sprintfFormat(sprintfParse(key), [key].concat(rest));
    }
    function sprintfFormat(parseTree, argv) {
      var treeLength = parseTree.length;
      var cursor = 1;
      var arg;
      var output = "";
      var i;
      var k;
      var ph;
      var pad;
      var padCharacter;
      var padLength;
      var isPositive;
      var sign;
      for (i = 0; i < treeLength; i += 1) {
        if (typeof parseTree[i] === "string") {
          output += parseTree[i];
        } else if (_typeof(parseTree[i]) === "object") {
          ph = parseTree[i];
          if (ph.keys) {
            arg = argv[cursor];
            for (k = 0; k < ph.keys.length; k += 1) {
              if (!(0, _has["default"])(arg, ph.keys[k])) {
                throw new Error(sprintf('[sprintf] property "%s" does not exist', ph.keys[k]));
              }
              arg = arg[ph.keys[k]];
            }
          } else if (ph.paramNo) {
            arg = argv[ph.paramNo];
          } else {
            arg = argv[cursor];
            cursor += 1;
          }
          if (re.notType.test(ph.type) && re.notPrimitive.test(ph.type) && arg instanceof Function) {
            arg = arg();
          }
          if (re.numericArg.test(ph.type) && typeof arg !== "number" && Number.isNaN(Number(arg))) {
            throw new TypeError(sprintf("[sprintf] expecting number but found %T", arg));
          }
          if (re.number.test(ph.type)) {
            isPositive = arg >= 0;
          }
          switch (ph.type) {
            case "b":
              arg = parseInt(arg, 10).toString(2);
              break;
            case "c":
              arg = String.fromCharCode(parseInt(arg, 10));
              break;
            case "d":
            case "i":
              arg = parseInt(arg, 10);
              break;
            case "j":
              arg = JSON.stringify(arg, null, ph.width ? parseInt(ph.width, 10) : 0);
              break;
            case "e":
              arg = ph.precision ? parseFloat(arg).toExponential(ph.precision) : parseFloat(arg).toExponential();
              break;
            case "f":
              arg = ph.precision ? parseFloat(arg).toFixed(ph.precision) : parseFloat(arg);
              break;
            case "g":
              arg = ph.precision ? String(Number(arg.toPrecision(ph.precision))) : parseFloat(arg);
              break;
            case "o":
              arg = (parseInt(arg, 10) >>> 0).toString(8);
              break;
            case "s":
              arg = String(arg);
              arg = ph.precision ? arg.substring(0, ph.precision) : arg;
              break;
            case "t":
              arg = String(!!arg);
              arg = ph.precision ? arg.substring(0, ph.precision) : arg;
              break;
            case "T":
              arg = Object.prototype.toString.call(arg).slice(8, -1).toLowerCase();
              arg = ph.precision ? arg.substring(0, ph.precision) : arg;
              break;
            case "u":
              arg = parseInt(arg, 10) >>> 0;
              break;
            case "v":
              arg = arg.valueOf();
              arg = ph.precision ? arg.substring(0, ph.precision) : arg;
              break;
            case "x":
              arg = (parseInt(arg, 10) >>> 0).toString(16);
              break;
            case "X":
              arg = (parseInt(arg, 10) >>> 0).toString(16).toUpperCase();
              break;
          }
          if (re.json.test(ph.type)) {
            output += arg;
          } else {
            if (re.number.test(ph.type) && (!isPositive || ph.sign)) {
              sign = isPositive ? "+" : "-";
              arg = arg.toString().replace(re.sign, "");
            } else {
              sign = "";
            }
            padCharacter = ph.padChar ? ph.padChar === "0" ? "0" : ph.padChar.charAt(1) : " ";
            padLength = ph.width - (sign + arg).length;
            pad = ph.width ? padLength > 0 ? (0, _repeat["default"])(padCharacter, padLength) : "" : "";
            output += ph.align ? sign + arg + pad : padCharacter === "0" ? sign + pad + arg : pad + sign + arg;
          }
        }
      }
      return output;
    }
    var sprintfParseCache = /* @__PURE__ */ Object.create(null);
    function sprintfParse(fmt) {
      if (sprintfParseCache[fmt]) {
        return sprintfParseCache[fmt];
      }
      var current = fmt;
      var match;
      var argNames = 0;
      var parseTree = [];
      while (current) {
        if ((match = re.text.exec(current)) !== null) {
          parseTree.push(match[0]);
        } else if ((match = re.modulo.exec(current)) !== null) {
          parseTree.push("%");
        } else if ((match = re.placeholder.exec(current)) !== null) {
          if (match[2]) {
            argNames |= 1;
            var replacementField = match[2];
            var fieldMatch = [];
            var fieldList = [];
            if ((fieldMatch = re.key.exec(replacementField)) !== null) {
              fieldList.push(fieldMatch[1]);
              while ((replacementField = replacementField.substring(fieldMatch[0].length)) !== "") {
                if ((fieldMatch = re.keyAccess.exec(replacementField)) !== null) {
                  fieldList.push(fieldMatch[1]);
                } else if ((fieldMatch = re.indexAccess.exec(replacementField)) !== null) {
                  fieldList.push(fieldMatch[1]);
                } else {
                  throw new SyntaxError("[sprintf] failed to parse named argument key");
                }
              }
            } else {
              throw new SyntaxError("[sprintf] failed to parse named argument key");
            }
            match[2] = fieldList;
          } else {
            argNames |= 2;
          }
          if (argNames === 3) {
            throw new Error("[sprintf] mixing positional and named placeholders is not (yet) supported");
          }
          parseTree.push({
            placeholder: match[0],
            paramNo: match[1],
            keys: match[2],
            sign: match[3],
            padChar: match[4],
            align: match[5],
            width: match[6],
            precision: match[7],
            type: match[8]
          });
        } else {
          throw new SyntaxError("[sprintf] unexpected placeholder");
        }
        current = current.substring(match[0].length);
      }
      sprintfParseCache[fmt] = parseTree;
      return sprintfParseCache[fmt];
    }
  }
});

// node_modules/@splunk/ui-utils/format.js
var require_format = __commonJS({
  "node_modules/@splunk/ui-utils/format.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.sprintf = sprintf;
    exports.abbreviateNumber = abbreviateNumber;
    exports.bytesToFileSize = bytesToFileSize;
    exports.smartTrim = smartTrim;
    var _toNumber = _interopRequireDefault(require_toNumber());
    var _i18n = require_i18n();
    var _math = require_math();
    var _sprintf = require_sprintf();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function sprintf(key) {
      for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        rest[_key - 1] = arguments[_key];
      }
      return (0, _sprintf.sprintfFormat)((0, _sprintf.sprintfParse)(key), [key].concat(rest));
    }
    function abbreviateNumber(number) {
      var locale = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "en-us";
      var value = (0, _toNumber["default"])(number);
      if (value <= 1e3) {
        return value.toLocaleString(locale);
      }
      if (value < 1e4) {
        return sprintf((0, _i18n._)("%sK"), (0, _math.roundToDecimal)(value / 1e3, -2).toLocaleString(locale));
      }
      if (value < 1e5) {
        return sprintf((0, _i18n._)("%sK"), (0, _math.roundToDecimal)(value / 1e3, -1).toLocaleString(locale));
      }
      if (value < 999500) {
        return sprintf((0, _i18n._)("%sK"), (0, _math.roundToDecimal)(value / 1e3, 0).toLocaleString(locale));
      }
      if (value < 1e7) {
        return sprintf((0, _i18n._)("%sM"), (0, _math.roundToDecimal)(value / 1e6, -2).toLocaleString(locale));
      }
      if (value < 1e8) {
        return sprintf((0, _i18n._)("%sM"), (0, _math.roundToDecimal)(value / 1e6, -1).toLocaleString(locale));
      }
      if (value < 9995e5) {
        return sprintf((0, _i18n._)("%sM"), (0, _math.roundToDecimal)(value / 1e6, 0).toLocaleString(locale));
      }
      if (value < 1e10) {
        return sprintf((0, _i18n._)("%sB"), (0, _math.roundToDecimal)(value / 1e9, -2).toLocaleString(locale));
      }
      if (value < 1e11) {
        return sprintf((0, _i18n._)("%sB"), (0, _math.roundToDecimal)(value / 1e9, -1).toLocaleString(locale));
      }
      return sprintf((0, _i18n._)("%sB"), (0, _math.roundToDecimal)(value / 1e9, 0).toLocaleString(locale));
    }
    function bytesToFileSize(bytes) {
      var locale = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "en-us";
      var kbFileSize = (bytes || 0) / 1024;
      if (kbFileSize < 0) {
        throw new RangeError("bytes must be >= 0");
      }
      if (Math.floor(kbFileSize) === 0) {
        return sprintf((0, _i18n._)("%s B"), bytes.toLocaleString(locale));
      }
      var mbFileSize = kbFileSize / 1024;
      if (Math.floor(mbFileSize) === 0) {
        return sprintf((0, _i18n._)("%s KB"), (0, _math.roundToDecimal)(kbFileSize, -2).toLocaleString(locale));
      }
      var gbFileSize = mbFileSize / 1024;
      if (Math.floor(gbFileSize) === 0) {
        return sprintf((0, _i18n._)("%s MB"), (0, _math.roundToDecimal)(mbFileSize, -2).toLocaleString(locale));
      }
      var tbFileSize = gbFileSize / 1024;
      if (Math.floor(tbFileSize) === 0) {
        return sprintf((0, _i18n._)("%s GB"), (0, _math.roundToDecimal)(gbFileSize, -2).toLocaleString(locale));
      }
      return sprintf((0, _i18n._)("%s TB"), (0, _math.roundToDecimal)(tbFileSize, -2).toLocaleString(locale));
    }
    function smartTrim(string, maxCharsFromString) {
      var _ref = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, _ref$precomposed = _ref.precomposed, precomposed = _ref$precomposed === void 0 ? false : _ref$precomposed;
      if (!string || maxCharsFromString < 1 || string.length <= maxCharsFromString) {
        return string;
      }
      var ellipsis = precomposed ? "â€¦" : "...";
      if (maxCharsFromString === 1) {
        return "".concat(string[0]).concat(ellipsis);
      }
      var midpoint = Math.ceil(string.length / 2);
      var toRemove = string.length - maxCharsFromString;
      var lstrip = Math.ceil(toRemove / 2);
      var rstrip = toRemove - lstrip;
      return "".concat(string.substring(0, midpoint - lstrip)).concat(ellipsis).concat(string.substring(midpoint + rstrip));
    }
  }
});

export {
  require_isNumber,
  require_repeat,
  require_format
};
//# sourceMappingURL=chunk-6CXBXVKR.js.map
