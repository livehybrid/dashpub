import __buffer_polyfill from 'vite-plugin-node-polyfills/shims/buffer'
globalThis.Buffer = globalThis.Buffer || __buffer_polyfill
import __global_polyfill from 'vite-plugin-node-polyfills/shims/global'
globalThis.global = globalThis.global || __global_polyfill
import __process_polyfill from 'vite-plugin-node-polyfills/shims/process'
globalThis.process = globalThis.process || __process_polyfill

import {
  require_Rx,
  require_client,
  require_dashboard_definition,
  require_moment,
  require_search
} from "./chunk-AIIXJTVL.js";
import {
  require_datasource_utils
} from "./chunk-DMMSRVDK.js";
import {
  init_memoize_one_esm,
  memoize_one_esm_exports,
  require_dashboard_utils
} from "./chunk-XH2XD4WE.js";
import {
  require_i18n
} from "./chunk-SFZFMFKO.js";
import {
  require_lodash
} from "./chunk-FUC7W543.js";
import {
  __commonJS,
  __toCommonJS,
  __toESM,
  require_dist,
  require_dist2,
  require_dist3
} from "./chunk-2RF6DQJU.js";

// node_modules/@splunk/datasources/CloudSearch.js
var require_CloudSearch = __commonJS({
  "node_modules/@splunk/datasources/CloudSearch.js"(exports, module) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    var __create = Object.create;
    var __defProp = Object.defineProperty;
    var __defProps = Object.defineProperties;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __getOwnPropSymbols = Object.getOwnPropertySymbols;
    var __getProtoOf = Object.getPrototypeOf;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __propIsEnum = Object.prototype.propertyIsEnumerable;
    var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
    var __spreadValues = (a, b) => {
      for (var prop in b || (b = {}))
        if (__hasOwnProp.call(b, prop))
          __defNormalProp(a, prop, b[prop]);
      if (__getOwnPropSymbols)
        for (var prop of __getOwnPropSymbols(b)) {
          if (__propIsEnum.call(b, prop))
            __defNormalProp(a, prop, b[prop]);
        }
      return a;
    };
    var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
    var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
      // If the importer is in node compatibility mode or this is not an ESM
      // file that has been converted to a CommonJS file using a Babel-
      // compatible transform (i.e. "__esModule" has not been set), then set
      // "default" to the CommonJS "module.exports" for node compatibility.
      isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
      mod
    ));
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var __async = (__this, __arguments, generator) => {
      return new Promise((resolve, reject) => {
        var fulfilled = (value) => {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        };
        var rejected = (value) => {
          try {
            step(generator.throw(value));
          } catch (e) {
            reject(e);
          }
        };
        var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
        step((generator = generator.apply(__this, __arguments)).next());
      });
    };
    var CloudSearch_exports = {};
    __export(CloudSearch_exports, {
      default: () => CloudSearch_default,
      fetchData: () => fetchData,
      fetchMetaData: () => fetchMetaData,
      fetchPagedData: () => fetchPagedData,
      getStatusMessage: () => getStatusMessage,
      getWaitTimeInMs: () => getWaitTimeInMs,
      isJobCompleted: () => isJobCompleted,
      isJobDone: () => isJobDone,
      isJobFailed: () => isJobFailed,
      normalizeQueryParameters: () => normalizeQueryParameters,
      shouldFetch: () => shouldFetch,
      shouldUpdateJob: () => shouldUpdateJob
    });
    module.exports = __toCommonJS2(CloudSearch_exports);
    var rxjs_exports = {};
    __export(rxjs_exports, {
      default: () => rxjs_default
    });
    var defaultImport = __toESM2(require_Rx());
    __reExport(rxjs_exports, require_Rx());
    var rxjs_default = "default" in defaultImport ? defaultImport.default : defaultImport;
    var lodash_exports = {};
    __export(lodash_exports, {
      default: () => lodash_default
    });
    var defaultImport2 = __toESM2(require_lodash());
    __reExport(lodash_exports, require_lodash());
    var lodash_default = "default" in defaultImport2 ? defaultImport2.default : defaultImport2;
    var memoize_one_exports = {};
    __export(memoize_one_exports, {
      default: () => memoize_one_default
    });
    var defaultImport3 = __toESM2((init_memoize_one_esm(), __toCommonJS(memoize_one_esm_exports)));
    __reExport(memoize_one_exports, (init_memoize_one_esm(), __toCommonJS(memoize_one_esm_exports)));
    var memoize_one_default = "default" in defaultImport3 ? defaultImport3.default : defaultImport3;
    var moment_exports = {};
    __export(moment_exports, {
      default: () => moment_default
    });
    var defaultImport4 = __toESM2(require_moment());
    __reExport(moment_exports, require_moment());
    var moment_default = "default" in defaultImport4 ? defaultImport4.default : defaultImport4;
    var search_exports = {};
    __export(search_exports, {
      default: () => search_default
    });
    var defaultImport5 = __toESM2(require_search());
    __reExport(search_exports, require_search());
    var search_default = "default" in defaultImport5 ? defaultImport5.default : defaultImport5;
    var client_exports = {};
    __export(client_exports, {
      default: () => client_default
    });
    var defaultImport6 = __toESM2(require_client());
    __reExport(client_exports, require_client());
    var client_default = "default" in defaultImport6 ? defaultImport6.default : defaultImport6;
    var datasource_utils_exports = {};
    __export(datasource_utils_exports, {
      default: () => datasource_utils_default
    });
    var defaultImport7 = __toESM2(require_datasource_utils());
    __reExport(datasource_utils_exports, require_datasource_utils());
    var datasource_utils_default = "default" in defaultImport7 ? defaultImport7.default : defaultImport7;
    var i18n_exports = {};
    __export(i18n_exports, {
      default: () => i18n_default
    });
    var defaultImport8 = __toESM2(require_i18n());
    __reExport(i18n_exports, require_i18n());
    var i18n_default = "default" in defaultImport8 ? defaultImport8.default : defaultImport8;
    var dashboard_utils_exports = {};
    __export(dashboard_utils_exports, {
      default: () => dashboard_utils_default
    });
    var defaultImport9 = __toESM2(require_dashboard_utils());
    __reExport(dashboard_utils_exports, require_dashboard_utils());
    var dashboard_utils_default = "default" in defaultImport9 ? defaultImport9.default : defaultImport9;
    var DataSource = class {
      /**
       * Create a new DataSource instance
       * @param {Object} options DataSource options such as search string, earliest/latest time
       * @param {Object} context contextual information such as api key or scope
       * @param {Object} meta metadata of this datasource
       * @param {Object} baseChainModel base chain definition
       */
      constructor(options = {}, context = {}, meta = {}, baseChainModel = {}) {
        this.options = options;
        this.context = context;
        this.meta = meta;
        this.baseChainModel = baseChainModel;
      }
      /**
       * Setup the DataSource, create a connection or search job.
       * setup() will be called only once per DataSource.
       * Returns null by default; override to implement custom setup logic.
       *
       * @return {Promise}
       * @public
       */
      setup() {
        return Promise.resolve(null);
      }
      /**
       * Request a Data Stream represent by an Observable.
       * Once the Observable was created and returned,
       * it's the DataSource itself responsible for 'pushing' the data out via Observable.next() function.
       * Override this function to implement your own data fetching logic.
       *
       * @param {Object} [requestParams] RequestParams
       * @param {Number} [requestParams.offset] result offset
       * @param {Number} [requestParams.count] result count, use with offset to return data in pages
       * @param {Object} [requestParams.sort] result sorting, key indicate the sorting fields and value must be one of ['none', 'asc', 'desc']
       * @param {Boolean} [requestParams.requireTotalCount] true if TotalCount is required in meta
       * @param {Boolean} [requestParams.progress] true to emit progress data, false to only return data when search is finalized
       * @return {Observable}
       * @public
       */
      request(requestParams) {
        return (observer) => {
          if (observer) {
            observer.complete();
          }
          return () => {
          };
        };
      }
      /**
       * Halt updates to results, if supported
       * @return {Promise}
       * @public
       */
      pause() {
        return __async(this, null, function* () {
          return Promise.resolve(null);
        });
      }
      /**
       * Resume previously-halted updates to results, if supported
       * @return {Promise}
       * @public
       */
      resume() {
        return __async(this, null, function* () {
          return Promise.resolve(null);
        });
      }
      /**
       * Reports whether pause and resume controls are supported for the class instance
       * @return {Boolean} true if the DataSource supports pause and resume actions
       * @public
       */
      supportsControlActions() {
        return false;
      }
      /**
       * Teardown the DataSource, clean up the connection or other resources.
       * Returns null by default; override to implement custom teardown logic.
       *
       * @return {Promise}
       * @public
       */
      teardown() {
        return Promise.resolve(null);
      }
      /**
       * @param {DataSource} another another DataSource to compare with
       * @return {Boolean} true if the these two DataSources are considered equal.
       * @public
       */
      equals(another) {
        return this.constructor === another.constructor && (0, lodash_exports.isEqual)(this.options, another.options);
      }
      /**
       * Return an observer that can be used for chaining with other DataSources
       *
       * @return {Object}
       * @public
       */
      getObserver() {
        return {
          next({ requestParams, data, meta }) {
          },
          error({ level, message }) {
          },
          complete() {
          }
        };
      }
      /**
       * Flag used to indicate whether the subscription for this DataSource should be refreshed
       *
       * @return {Boolean}
       * @public
       */
      shouldRefreshSubscription() {
        return false;
      }
    };
    function addLeadingSearchCommand(search) {
      const trimmedSearch = search.trim();
      if (trimmedSearch.startsWith("|")) {
        return search;
      }
      if (trimmedSearch.startsWith("search ") && trimmedSearch.length > 7 || trimmedSearch.startsWith("from ") && trimmedSearch.length > 5) {
        return search;
      }
      return `search ${trimmedSearch}`;
    }
    var SimpleScheduler = class _SimpleScheduler {
      static createScheduler(tickFunc, options) {
        return new _SimpleScheduler(tickFunc, options);
      }
      /**
       *
       * @param {*} tickFunc a function that will be executed by scheduler, its return value will be used to schedule next execution.
       * return false from this function will stop the execution
       * @param {*} options
       */
      constructor(tickFunc = dashboard_utils_exports.noop, options = {}) {
        var _a;
        this.tickFunc = tickFunc;
        this.minDelay = (_a = options.minDelay) != null ? _a : 0;
        this.loop = this.loop.bind(this);
        this.t = null;
        this.stopped = false;
      }
      /**
       * execute tick function and stop next execution if error caught
       */
      tick() {
        return __async(this, null, function* () {
          try {
            return yield this.tickFunc(this);
          } catch (e) {
            return false;
          }
        });
      }
      /**
       * start scheduler
       */
      start() {
        return __async(this, null, function* () {
          this.stopped = false;
          yield this.loop();
        });
      }
      loop() {
        return __async(this, null, function* () {
          const delay = yield this.tick();
          if (!this.stopped && delay !== false && (0, lodash_exports.isNumber)(delay)) {
            this.t = setTimeout(this.loop, Math.max(this.minDelay, delay));
          }
        });
      }
      /**
       * stop scheduler
       */
      stop() {
        this.stopped = true;
        if (this.t) {
          clearTimeout(this.t);
          this.t = null;
        }
      }
    };
    var SimpleScheduler_default = SimpleScheduler;
    var CloudSearchOptionsSchema_default = {
      query: {
        type: "string",
        description: "An SPL search string."
      },
      queryParameters: {
        type: "object",
        properties: {
          earliest: {
            type: "string",
            description: "Specify the earliest time to search for events."
          },
          latest: {
            type: "string",
            description: "Specify the latest time to search for events."
          },
          timezone: {
            type: "string",
            description: "Specify the timezone."
          }
        },
        additionalProperties: false,
        description: "SPL query parameters."
      },
      refresh: {
        anyOf: [
          {
            type: "number",
            minimum: 0
          },
          {
            type: "string"
          }
        ],
        description: "Specify the refresh interval in seconds or with a time expression."
      },
      refreshType: {
        type: "string",
        enum: ["delay", "interval"],
        default: "delay",
        description: "Indicate the starting time for counting down to a refresh. Use delay to start counting when the search is done. Use interval to count down when the search is dispatched."
      },
      requiredFreshness: {
        type: "number",
        description: "Specify the freshness range in seconds to enable search job caching"
      },
      module: {
        type: "string",
        description: "Dataset module for search isolation"
      }
    };
    var dashboard_definition_exports = {};
    __export(dashboard_definition_exports, {
      default: () => dashboard_definition_default
    });
    var defaultImport10 = __toESM2(require_dashboard_definition());
    __reExport(dashboard_definition_exports, require_dashboard_definition());
    var dashboard_definition_default = "default" in defaultImport10 ? defaultImport10.default : defaultImport10;
    var getDefaultOptionsForSearchQuery = (0, lodash_exports.memoize)(
      (definition) => {
        const def = dashboard_definition_exports.DashboardDefinition.fromJSON(definition);
        const timeRange = def.getDefaultTimeRangeForNewSearch();
        if (timeRange.earliest || timeRange.latest) {
          return {
            queryParameters: __spreadValues({}, timeRange)
          };
        }
        return {};
      },
      // note: this is the resolver function that uses a dirty trick to avoid re-creating the object
      (definition) => {
        const def = dashboard_definition_exports.DashboardDefinition.fromJSON(definition);
        const timeRange = def.getDefaultTimeRangeForNewSearch();
        return JSON.stringify(timeRange);
      }
    );
    var getStatusMessage = ({
      status,
      totalCount
    }) => {
      if (status === datasource_utils_exports.DS_STATUS.RUNNING && totalCount === 0) {
        return (0, i18n_exports._)(
          "Search is running, but not enough data to render visualization"
        );
      }
      if (status === datasource_utils_exports.DS_STATUS.DONE && totalCount === 0) {
        return (0, i18n_exports._)("Search ran successfully, but no results were returned");
      }
      if (!status) {
        return (0, i18n_exports._)("Search is not yet running, queued on client");
      }
      return "";
    };
    var getSdkClient = ({
      cloudApiUrl,
      accessToken,
      authClient,
      tenantId,
      searchSubmitQueueParams = {},
      searchQueueParams = {}
    }) => {
      var _a, _b, _c, _d, _e, _f, _g, _h;
      const serviceClient = new client_exports.ServiceClient({
        urls: cloudApiUrl ? { api: cloudApiUrl } : void 0,
        tokenSource: () => __async(void 0, null, function* () {
          return accessToken || authClient.getAccessToken();
        }),
        defaultTenant: tenantId,
        requestQueueManagerParams: new client_exports.RequestQueueManagerParams(
          {
            // These are taken from overrides in DefaultQueueManagerParams (https://github.com/splunk/splunk-cloud-sdk-js) (src/client.ts)
            retries: 6,
            initialTimeout: 1e3,
            exponent: 1.6,
            maxInFlight: 3
          },
          // FYI 'search-submit' queue is to start search job while 'search' queue is for search status and results requests.
          /* @__PURE__ */ new Map([
            [
              "search-submit",
              // SEARCH_SUBMIT_QUEUE is not exported (https://github.com/splunk/splunk-cloud-sdk-js) (src/client.ts)
              {
                retries: (_a = searchSubmitQueueParams == null ? void 0 : searchSubmitQueueParams.retries) != null ? _a : 10,
                initialTimeout: (_b = searchSubmitQueueParams == null ? void 0 : searchSubmitQueueParams.initialTimeout) != null ? _b : 1e3,
                exponent: (_c = searchSubmitQueueParams == null ? void 0 : searchSubmitQueueParams.exponent) != null ? _c : 1.6,
                maxInFlight: (_d = searchSubmitQueueParams == null ? void 0 : searchSubmitQueueParams.maxInFlight) != null ? _d : 10
              }
            ],
            [
              "search",
              {
                retries: (_e = searchQueueParams == null ? void 0 : searchQueueParams.retries) != null ? _e : 10,
                initialTimeout: (_f = searchQueueParams == null ? void 0 : searchQueueParams.initialTimeout) != null ? _f : 500,
                exponent: (_g = searchQueueParams == null ? void 0 : searchQueueParams.exponent) != null ? _g : 2,
                maxInFlight: (_h = searchQueueParams == null ? void 0 : searchQueueParams.maxInFlight) != null ? _h : 10
              }
            ]
          ])
        )
      });
      return new search_exports.SearchService(serviceClient);
    };
    var getCachedSdkClient = memoize_one_default(getSdkClient, lodash_exports.isEqual);
    var JOB_POLLING_INTERVAL = 400;
    var RESULTS_POLLING_INTERVAL = 500;
    var OTHER_SEARCH_PARAMS = [
      "extractAllFields",
      "timeFormat",
      "maxTime",
      "timeOfSearch",
      "enablePreview",
      "requiredFreshness"
    ];
    var findMessages = (messages = [], type = "INFO") => messages.filter((m) => m.type === type);
    var extractErrorMessage = (messages = []) => findMessages(messages, "ERROR").map((m) => m.text).join(",");
    var isJobDone = (job) => (job == null ? void 0 : job.status) === datasource_utils_exports.DS_STATUS.DONE;
    var isJobFailed = (job) => (job == null ? void 0 : job.status) === datasource_utils_exports.DS_STATUS.FAILED;
    var isJobCompleted = (job) => !!job && (isJobDone(job) || isJobFailed(job));
    var shouldUpdateJob = (job) => !job || !isJobCompleted(job);
    var shouldFetch = (job, progress = true) => {
      return progress || isJobDone(job);
    };
    var normalizeEarliest = (queryParameters) => {
      let earliest = queryParameters.earliest || queryParameters.earliestTime || queryParameters.earliest_time || // another normalization to make both customers and search service API happy
      "0";
      if (moment_default(earliest, moment_default.ISO_8601, true).isValid() && !earliest.endsWith("Z")) {
        earliest = moment_default(earliest).toISOString();
      }
      return earliest;
    };
    var normalizeLatest = (queryParameters) => {
      let latest = queryParameters.latest || queryParameters.latestTime || queryParameters.latest_time || // This is to make sure current react time range picker works. Remove at your own peril!
      "now";
      if (moment_default(latest, moment_default.ISO_8601, true).isValid() && !latest.endsWith("Z")) {
        latest = moment_default(latest).toISOString();
      }
      return latest;
    };
    var normalizeTimezone = (queryParameters) => queryParameters.timezone || Intl.DateTimeFormat().resolvedOptions().timeZone;
    var normalizeQueryParameters = (queryParameters = {}) => ({
      earliest: normalizeEarliest(queryParameters),
      latest: normalizeLatest(queryParameters),
      timezone: normalizeTimezone(queryParameters)
    });
    var supportedTimeDurations = {
      ms: 1,
      s: 1e3,
      m: 6e4
    };
    var numberUnitRegex = /(\d+)(\w+)/;
    var getWaitTimeInMs = (waitStr) => {
      if (!waitStr) {
        return 0;
      }
      const matches = numberUnitRegex.exec(waitStr);
      if (!matches || matches.length !== 3) {
        return 0;
      }
      const unit = matches[2];
      const time = parseInt(matches[1], 10);
      if (supportedTimeDurations[unit]) {
        return time * supportedTimeDurations[unit];
      }
      return time;
    };
    var parseNextLink = (relativeUrl) => {
      if (!URL.canParse(relativeUrl)) {
        if (!relativeUrl.includes("?")) {
          return { url: relativeUrl, query: {} };
        }
        const [url, query] = relativeUrl.split("?", 2);
        const searchParams2 = new URLSearchParams(query);
        return { url, query: Object.fromEntries(searchParams2.entries()) };
      }
      const { origin, pathname, searchParams } = URL.parse(relativeUrl);
      return {
        url: pathname ? `${origin}${pathname}` : origin,
        query: Object.fromEntries(searchParams.entries())
      };
    };
    var fetchPagedData = (_0, _1, ..._2) => __async(void 0, [_0, _1, ..._2], function* (client, link, timeToWait = 0, queryData = {}) {
      if (timeToWait) {
        yield (0, dashboard_utils_exports.wait)(timeToWait);
      }
      const pageResponse = yield client.get("api", link, { query: queryData });
      const pageData = pageResponse.body;
      let { fields = [], results = [] } = pageData;
      if (pageData.nextLink) {
        const { url, query } = parseNextLink(pageData.nextLink);
        const nextPageData = yield fetchPagedData(
          client,
          url,
          getWaitTimeInMs(pageData.wait),
          query
        );
        results = results.concat(nextPageData.results);
        fields = fields || nextPageData.fields;
      }
      return {
        fields,
        results
      };
    });
    var fetchData = (searchServiceClient, requestParams, job) => __async(void 0, null, function* () {
      if (!(job == null ? void 0 : job.sid)) {
        return null;
      }
      let data = null;
      const fetchParams = (0, lodash_exports.pick)(requestParams, [
        "offset",
        "count",
        "field",
        "search"
      ]);
      const fetchResultFn = job.enablePreview ? searchServiceClient.listPreviewResults : searchServiceClient.listResults;
      const response = yield fetchResultFn(job.sid, fetchParams);
      let { fields = [], results = [] } = response;
      if (response.nextLink) {
        const { url, query } = parseNextLink(response.nextLink);
        const pageData = yield fetchPagedData(
          searchServiceClient.client,
          url,
          getWaitTimeInMs(response.wait),
          query
        );
        fields = fields.length ? fields : pageData.fields;
        results = results.concat(pageData.results);
      }
      if (isJobCompleted(job) || fields.length && results.length) {
        data = datasource_utils_exports.DataSet.fromJSONArray(fields, results);
      }
      return data;
    });
    var fetchMetaData = (job) => {
      var _a;
      const jobProperties = (0, lodash_exports.pick)(job, [
        "status",
        "sid",
        "percentComplete"
      ]);
      jobProperties.totalCount = (_a = job.resultsAvailable) != null ? _a : 0;
      jobProperties.isRealTimeSearch = false;
      jobProperties.statusMessage = getStatusMessage(
        (0, lodash_exports.pick)(jobProperties, ["status", "totalCount", "isRealTimeSearch"])
      );
      jobProperties.lastUpdated = (job == null ? void 0 : job.completionTime) || (job == null ? void 0 : job.dispatchTime);
      return jobProperties;
    };
    var CloudSearchConfig = {
      title: (0, i18n_exports._)("Search"),
      displayDataSourceItemListByDefault: true,
      canCreateDataSource: true,
      dataSourceRemoveVerb: "delete",
      isDataSourceNameEditable: true,
      getDataSourceName: dashboard_utils_exports.getDefaultDataSourceName,
      defaultOptions: ({ definition }) => getDefaultOptionsForSearchQuery(definition),
      editorConfig: [],
      optionsSchema: CloudSearchOptionsSchema_default
    };
    var CloudSearch = class extends DataSource {
      constructor(options = {}, context = {}) {
        super(options, context);
        this.client = null;
        this.updateJobScheduler = null;
        this.computeNextFetchDelay = () => {
          if (isJobCompleted(this.currentJob) || this.isTeardown) {
            return false;
          }
          return RESULTS_POLLING_INTERVAL;
        };
        this.currentJob = null;
        this.caughtError = null;
        this.isTeardown = false;
        this.updateJob = this.updateJob.bind(this);
        if (!this.options.query && !this.options.sid) {
          throw Error("search string or sid is required!");
        }
        if (!this.context.tenantId) {
          throw Error("tenantId is required");
        }
        if (this.context.accessToken == null && this.context.authClient == null) {
          throw Error("authClient or accessToken is required");
        }
      }
      /**
       * create a sdk client
       */
      getServiceClient() {
        if (this.client === null) {
          const {
            cloudApiUrl,
            accessToken,
            authClient,
            tenantId,
            cacheClient = true,
            searchQueueParams
          } = this.context;
          const searchSubmitQueueParams = this.context.searchSubmitQueueParams || this.context.requestQueueManagerParams;
          const getFn = cacheClient ? getCachedSdkClient : getSdkClient;
          this.client = getFn({
            cloudApiUrl,
            accessToken,
            authClient,
            tenantId,
            searchSubmitQueueParams,
            searchQueueParams
          });
        }
        return this.client;
      }
      /**
       * Creates a search job and returns a jobId.
       *
       * Examples:
       * ```js
       *      const datasource = new CloudSearch(options, context);
       *      const sid = await datasource.setup();
       *```
       * @throws {error} If request to sdk endpoint fails
       * @returns {Promise<string>} The SID of created search.
       * @public
       */
      setup() {
        return __async(this, null, function* () {
          var _a;
          const module2 = this.options.module === void 0 ? this.context.defaultModule : this.options.module;
          const jobParams = __spreadProps(__spreadValues({
            // we by default enable preview unless user set `enablePreview` to false in options
            enablePreview: true
          }, (0, lodash_exports.pick)(this.options, OTHER_SEARCH_PARAMS)), {
            module: module2,
            // When a sid is passed, it may not have a query
            query: this.options.query ? addLeadingSearchCommand(this.options.query) : this.options.query
          });
          if (this.options.queryParameters) {
            jobParams.queryParameters = normalizeQueryParameters(
              this.options.queryParameters
            );
          }
          try {
            const job = this.options.sid ? yield this.getServiceClient().getJob(this.options.sid) : yield this.getServiceClient().createJob(jobParams);
            if (!job) {
              throw new Error(
                this.options.sid ? "job not found" : "unknown error"
              );
            }
            this.jobId = job.sid;
            this.updateJobScheduler = SimpleScheduler_default.createScheduler(
              this.updateJob
            );
            this.updateJobScheduler.start();
          } catch (ex) {
            if (this.options.sid) {
              console.error("failed to retrieve search job:", ex);
            } else {
              console.error("failed to create search job:", ex);
            }
            this.caughtError = ex.message;
            return null;
          }
          return (_a = this.jobId) != null ? _a : null;
        });
      }
      /**
       * Update observer based on current job status. Has side-effects due to api fetch
       * @param {Subscriber<ObservableData>} obj.observer
       * @param {RequestParams} obj.requestParams
       */
      handleJobRequest(_0) {
        return __async(this, arguments, function* ({
          observer,
          requestParams
        }) {
          if (!this.currentJob) {
            return;
          }
          const params = __spreadValues({
            offset: 0,
            count: 0,
            progress: true
          }, requestParams);
          let data = null;
          switch (this.currentJob.status) {
            case datasource_utils_exports.DS_STATUS.FAILED:
              observer.error({
                level: "error",
                message: extractErrorMessage(this.currentJob.messages)
              });
              break;
            case datasource_utils_exports.DS_STATUS.RUNNING:
            case datasource_utils_exports.DS_STATUS.DONE:
              if (shouldFetch(this.currentJob, params.progress)) {
                data = yield fetchData(
                  this.getServiceClient(),
                  params,
                  this.currentJob
                );
                if (data) {
                  observer.next({
                    data,
                    meta: fetchMetaData(this.currentJob)
                  });
                }
              }
              break;
            default:
              break;
          }
          if (isJobDone(this.currentJob)) {
            observer.complete();
          }
        });
      }
      /**
       * Supports getResults as exposed
       * by [@splunk/cloud-sdk](https://github.com/splunk/splunk-cloud-sdk-js) (src/search.ts)
       *
       * Examples:
       * ```js
       *      const datasource = new CloudSearch(options, context);
       *      datasource.setup().then(() => {
       *          datasource.request().subscribe({
       *              complete() {
       *                 // search completed
       *              },
       *              next(obj) {
       *                  // Process results
       *              },
       *              error() {
       *                  // Handle error
       *              },
       *         });
       *     });
       * ```
       * @param {Object} requestParams search request parameters.
       * @param {Number} requestParams.offset data offset.
       * @param {Number} requestParams.count data count.
       * @param {String} requestParams.progress whether to return intermediate search result
       * @returns {function(*)}
       * @public
       */
      request(requestParams = {}) {
        return rxjs_exports.Observable.create((observer) => {
          let resultScheduler = null;
          if (this.caughtError) {
            observer.error({
              level: "error",
              message: this.caughtError
            });
          } else {
            resultScheduler = SimpleScheduler_default.createScheduler(() => __async(this, null, function* () {
              try {
                yield this.handleJobRequest({
                  observer,
                  requestParams
                });
                return this.computeNextFetchDelay();
              } catch (ex) {
                observer.error({
                  level: "error",
                  message: ex.message
                });
                return false;
              }
            }));
            resultScheduler.start();
          }
          return () => {
            if (resultScheduler) {
              resultScheduler.stop();
              resultScheduler = null;
            }
          };
        });
      }
      /**
       * This is how the search sdk expects delete to work,
       * but it is commented out on ssc-search spec which means that this method can't really be used right now.
       * When available to use, it will delete the search job with the given jobId
       *
       * Examples:
       * ```js
       *   const response = await datasource.teardown().then(
       *      value => {
       *          console.log(`Should have deleted the job: ${value}`);
       *          },
       *      reason => {
       *          console.log(`Failed to delete the job: ${reason}`);
       *         }
       *   );
       *```
       * @returns {Promise<*>}
       * @public
       */
      teardown() {
        return __async(this, null, function* () {
          if (this.updateJobScheduler) {
            this.updateJobScheduler.stop();
          }
          if (this.jobId && !isJobCompleted(this.currentJob)) {
            yield this.getServiceClient().updateJob(this.jobId, {
              status: datasource_utils_exports.DS_STATUS.CANCELED
            });
          }
          this.isTeardown = true;
          return null;
        });
      }
      /**
       * Given the job id, update the job stats and compute the next update delay
       */
      updateJob() {
        return __async(this, null, function* () {
          try {
            if (this.jobId && shouldUpdateJob(this.currentJob)) {
              this.currentJob = yield this.getServiceClient().getJob(
                this.jobId
              );
              return JOB_POLLING_INTERVAL;
            }
          } catch (ex) {
            this.caughtError = ex.message;
          }
          return false;
        });
      }
    };
    CloudSearch.schema = CloudSearchOptionsSchema_default;
    CloudSearch.config = CloudSearchConfig;
    var CloudSearch_default = CloudSearch;
  }
});

export {
  require_CloudSearch
};
//# sourceMappingURL=chunk-HBDGNXDJ.js.map
