{
  "version": 3,
  "sources": ["../../@splunk/react-icons/Plus.js", "../../@splunk/dashboard-layouts/src/index.ts", "../../@splunk/dashboard-layouts/react", "../../@splunk/dashboard-layouts/lodash", "../../@splunk/dashboard-layouts/@splunk/dashboard-context", "../../@splunk/dashboard-layouts/@splunk/dashboard-definition", "../../@splunk/dashboard-layouts/@splunk/dashboard-ui", "../../@splunk/dashboard-layouts/@splunk/dashboard-utils", "../../@splunk/dashboard-layouts/@splunk/dashboard-state", "../../@splunk/dashboard-layouts/styled-components", "../../@splunk/dashboard-layouts/@splunk/themes", "../../@splunk/dashboard-layouts/src/utils/imageUtils.ts", "../../@splunk/dashboard-layouts/src/utils/edgeUtils.ts", "../../@splunk/dashboard-layouts/src/AbsoluteLayoutConstants.ts", "../../@splunk/dashboard-layouts/src/utils/layoutUtils.ts", "../../@splunk/dashboard-layouts/src/hooks/absoluteLayoutZoom/useCanvasZoomCenter.ts", "../../@splunk/dashboard-layouts/src/hooks/absoluteLayoutZoom/useScaleOnDisplayChange.ts", "../../@splunk/dashboard-layouts/src/hooks/absoluteLayoutZoom/useScaleToFit.ts", "../../@splunk/dashboard-layouts/src/hooks/absoluteLayoutZoom/useScrollOnFitToWidth.ts", "../../@splunk/dashboard-layouts/src/hooks/absoluteLayoutZoom/useAbsoluteLayoutZoom.ts", "../../@splunk/dashboard-layouts/src/hooks/useBackgroundImage.ts", "../../@splunk/dashboard-layouts/src/hooks/useLayoutShowHide.ts", "../../@splunk/dashboard-layouts/src/hooks/useMouseDownWithHandleEventListeners.ts", "../../@splunk/dashboard-layouts/src/components/Canvas/BackgroundImage.tsx", "../../@splunk/dashboard-layouts/src/components/Canvas/CanvasBorder.tsx", "../../@splunk/dashboard-layouts/src/components/Canvas/CanvasGridlines.tsx", "../../@splunk/dashboard-layouts/src/components/Canvas/Background.tsx", "../../@splunk/dashboard-layouts/src/components/Canvas/Canvas.tsx", "../../@splunk/dashboard-layouts/prop-types", "../../@splunk/dashboard-layouts/src/components/SelectBox.jsx", "../../@splunk/dashboard-layouts/src/utils/findStatusIcon.ts", "../../@splunk/dashboard-layouts/src/components/AbsoluteCanvas.tsx", "../../@splunk/dashboard-layouts/src/components/AbsoluteItem.jsx", "../../@splunk/dashboard-layouts/src/components/ActionMenuPortal.ts", "../../@splunk/dashboard-layouts/src/components/Edge.tsx", "../../@splunk/dashboard-layouts/@splunk/ui-utils/i18n", "../../@splunk/dashboard-layouts/src/components/ErrorMessageOverlay.tsx", "../../@splunk/dashboard-layouts/src/components/GridCanvas.tsx", "../../@splunk/dashboard-layouts/src/components/GridItem.tsx", "../../@splunk/dashboard-layouts/src/components/ItemDragPlaceholder.tsx", "../../@splunk/dashboard-layouts/src/GridLayoutConstants.ts", "../../@splunk/dashboard-layouts/src/components/ItemDropTarget.jsx", "../../@splunk/dashboard-layouts/src/components/Layer.tsx", "../../@splunk/dashboard-layouts/@splunk/react-icons/Plus", "../../@splunk/dashboard-layouts/@splunk/ui-utils/format", "../../@splunk/dashboard-layouts/src/utils/outlineUtils.ts", "../../@splunk/dashboard-layouts/src/components/Port/Port.tsx", "../../@splunk/dashboard-layouts/src/components/PreviewPlaceholderItem.jsx", "../../@splunk/dashboard-layouts/src/components/ResizeHandle.tsx", "../../@splunk/dashboard-layouts/src/components/ResponsiveBox.tsx", "../../@splunk/dashboard-layouts/src/components/DragHandlePortal.tsx", "../../@splunk/dashboard-layouts/src/components/ResponsiveBlockItem.tsx", "../../@splunk/dashboard-layouts/src/components/ResponsiveBlockOutline.tsx", "../../@splunk/dashboard-layouts/src/components/ResponsiveLine.tsx", "../../@splunk/dashboard-layouts/src/DefaultOptions.ts", "../../@splunk/dashboard-layouts/src/utils/blockUtils.ts", "../../@splunk/dashboard-layouts/src/utils/lineUtils.ts", "../../@splunk/dashboard-layouts/src/utils/absoluteLayoutUtils.ts", "../../@splunk/dashboard-layouts/src/absoluteLayoutOptionsSchema.ts", "../../@splunk/dashboard-layouts/src/enhancers/withLayoutShowHide.tsx", "../../@splunk/dashboard-layouts/src/AbsoluteLayout.tsx", "../../@splunk/dashboard-layouts/src/AbsoluteLayoutViewer.tsx", "../../@splunk/dashboard-layouts/memoize-one", "../../@splunk/dashboard-layouts/@splunk/dashboard-telemetry", "../../@splunk/dashboard-layouts/src/gridLayoutOptionsSchema.ts", "../../@splunk/dashboard-layouts/src/utils/gridLayoutUtils.ts", "../../@splunk/dashboard-layouts/src/utils/gridOrderUtils.ts", "../../@splunk/dashboard-layouts/src/utils/gridUtils.ts", "../../@splunk/dashboard-layouts/src/utils/splitGridStructure.ts", "../../@splunk/dashboard-layouts/src/utils/getContainingRowColumn.ts", "../../@splunk/dashboard-layouts/src/utils/gridLayoutAutoResize.ts", "../../@splunk/dashboard-layouts/src/utils/gridLayoutShowHide.ts", "../../@splunk/dashboard-layouts/src/GridLayout.tsx", "../../@splunk/dashboard-layouts/src/utils/gridLayoutViewerUtils.ts", "../../@splunk/dashboard-layouts/src/GridLayoutViewer.tsx", "../../@splunk/dashboard-layouts/@dnd-kit/core", "../../@splunk/dashboard-layouts/@dnd-kit/sortable", "../../@splunk/dashboard-layouts/@dnd-kit/utilities", "../../@splunk/dashboard-layouts/src/InputLayoutViewer.tsx", "../../@splunk/dashboard-layouts/@splunk/react-icons/Line", "../../@splunk/dashboard-layouts/@splunk/visualization-encoding/Options", "../../@splunk/dashboard-layouts/@splunk/visualizations-shared/schemaUtils", "../../@splunk/dashboard-layouts/src/visualizations/ConnectedLineOptionsSchema.ts", "../../@splunk/dashboard-layouts/@splunk/visualization-color-palettes/editors/PresetPalettes", "../../@splunk/dashboard-layouts/@splunk/visualizations/common/utils/configUtils", "../../@splunk/dashboard-layouts/src/visualizations/ConnectedLineEditorConfig.ts", "../../@splunk/dashboard-layouts/src/visualizations/utils/lineUtils.ts", "../../@splunk/dashboard-layouts/src/visualizations/ConnectedLine.tsx", "../../@splunk/dashboard-layouts/src/commonLayoutOptionsSchema.ts", "../../@splunk/dashboard-layouts/src/apis/BaseLayoutApi.ts", "../../@splunk/dashboard-layouts/src/apis/AbsoluteLayoutApi.ts", "../../@splunk/dashboard-layouts/src/apis/GridLayoutApi.ts"],
  "sourcesContent": ["/******/ (() => {\n    // webpackBootstrap\n    /******/ \"use strict\";\n    /******/ // The require scope\n    /******/    var e = {};\n    /******/\n    /************************************************************************/\n    /******/ /* webpack/runtime/compat get default export */\n    /******/    (() => {\n        /******/ // getDefaultExport function for compatibility with non-harmony modules\n        /******/ e.n = r => {\n            /******/ var t = r && r.__esModule ? \n            /******/ () => r[\"default\"]\n            /******/ : () => r\n            /******/;\n            e.d(t, {\n                a: t\n            });\n            /******/            return t;\n            /******/        };\n        /******/    })();\n    /******/\n    /******/ /* webpack/runtime/define property getters */\n    /******/    (() => {\n        /******/ // define getter functions for harmony exports\n        /******/ e.d = (r, t) => {\n            /******/ for (var n in t) {\n                /******/ if (e.o(t, n) && !e.o(r, n)) {\n                    /******/ Object.defineProperty(r, n, {\n                        enumerable: true,\n                        get: t[n]\n                    });\n                    /******/                }\n                /******/            }\n            /******/        };\n        /******/    })();\n    /******/\n    /******/ /* webpack/runtime/hasOwnProperty shorthand */\n    /******/    (() => {\n        /******/ e.o = (e, r) => Object.prototype.hasOwnProperty.call(e, r)\n        /******/;\n    })();\n    /******/\n    /******/ /* webpack/runtime/make namespace object */\n    /******/    (() => {\n        /******/ // define __esModule on exports\n        /******/ e.r = e => {\n            /******/ if (typeof Symbol !== \"undefined\" && Symbol.toStringTag) {\n                /******/ Object.defineProperty(e, Symbol.toStringTag, {\n                    value: \"Module\"\n                });\n                /******/            }\n            /******/            Object.defineProperty(e, \"__esModule\", {\n                value: true\n            });\n            /******/        };\n        /******/    })();\n    /******/\n    /************************************************************************/    var r = {};\n    // ESM COMPAT FLAG\n        e.r(r);\n    // EXPORTS\n        e.d(r, {\n        default: () => /* binding */ p\n    });\n    // CONCATENATED MODULE: external \"react\"\n    const t = require(\"react\");\n    var n =  e.n(t);\n    // CONCATENATED MODULE: external \"@splunk/react-icons/IconProvider\"\n    const a = require(\"@splunk/react-icons/IconProvider\");\n    // CONCATENATED MODULE: external \"@splunk/react-icons/SVG\"\n    const o = require(\"@splunk/react-icons/SVG\");\n    var u =  e.n(o);\n    // CONCATENATED MODULE: ./src/icons/Plus.tsx\n    function l(e, r) {\n        if (null == e) return {};\n        var t, n, a = i(e, r);\n        if (Object.getOwnPropertySymbols) {\n            var o = Object.getOwnPropertySymbols(e);\n            for (n = 0; n < o.length; n++) {\n                t = o[n], -1 === r.indexOf(t) && {}.propertyIsEnumerable.call(e, t) && (a[t] = e[t]);\n            }\n        }\n        return a;\n    }\n    function i(e, r) {\n        if (null == e) return {};\n        var t = {};\n        for (var n in e) {\n            if ({}.hasOwnProperty.call(e, n)) {\n                if (-1 !== r.indexOf(n)) continue;\n                t[n] = e[n];\n            }\n        }\n        return t;\n    }\n    // This file is auto-generated.\n    // Do not edit this file manually. Changes will be lost upon regeneration.\n    // To modify the icon file template, update 'scripts/templates.ts'.\n        var c = new Map;\n    c.set(\"outlined\", (function() {\n        \n        return n().createElement(n().Fragment, null,  n().createElement(\"path\", {\n            d: \"M13 5C13 4.44772 12.5523 4 12 4C11.4477 4 11 4.44772 11 5V11H5C4.44772 11 4 11.4477 4 12C4 12.5523 4.44772 13 5 13H11V19C11 19.5523 11.4477 20 12 20C12.5523 20 13 19.5523 13 19V13H19C19.5523 13 20 12.5523 20 12C20 11.4477 19.5523 11 19 11H13V5Z\"\n        }));\n    }));\n    var f = [ \"default\", \"outlined\" ];\n    var d = function e(r) {\n        return f.indexOf(r) >= 0;\n    };\n    var v = function e(r) {\n        return r === \"default\" || r && !d(r) ? \"outlined\" : r;\n    };\n    /**\n * @description Add, Increase represents common action to add new object\n * @category Actions\n * @keywords increase/decrease, +\n * @variants outlined\n */    var s = function e(r) {\n        var o = r.children, i = r.variant, f = i === void 0 ? \"default\" : i, d = l(r, [ \"children\", \"variant\" ]);\n        var s = v(f);\n        var p = \"plus-\".concat(s);\n        var y = (0, t.useContext)(a.IconContext);\n        var b = c.get(s);\n        if (false) {}\n        if (y && b) {\n            var m = y.toRender, O = y.addIcon;\n            O(p, b());\n            if (!m) {\n                return null;\n            }\n        }\n        \n        return n().createElement(u(), d, o, y ?  n().createElement(\"use\", {\n            href: \"#\".concat(p)\n        }) : !!b && b());\n    };\n    /* harmony default export */    const p = s;\n    module.exports = r;\n    /******/})();", "export type { AbsoluteLayoutProps } from './AbsoluteLayout';\nexport { default as AbsoluteLayout } from './AbsoluteLayout';\nexport { default as AbsoluteLayoutOptionsSchema } from './absoluteLayoutOptionsSchema';\nexport type { AbsoluteLayoutViewerProps } from './AbsoluteLayoutViewer';\nexport { default as AbsoluteLayoutViewer } from './AbsoluteLayoutViewer';\nexport * from './DefaultOptions';\nexport type { GridLayoutProps } from './GridLayout';\nexport { default as GridLayout } from './GridLayout';\nexport * from './GridLayoutConstants';\nexport { default as GridLayoutOptionsSchema } from './gridLayoutOptionsSchema';\nexport type { GridLayoutViewerProps } from './GridLayoutViewer';\nexport { default as GridLayoutViewer } from './GridLayoutViewer';\nexport { default as InputLayout } from './InputLayoutViewer';\nexport * from './visualizations';\nexport { default as CommonLayoutOptionsSchema } from './commonLayoutOptionsSchema';\n\nexport * from './apis';\n", "\nimport * as defaultImport from \"react\";\nexport * from \"react\";\nexport default ('default' in defaultImport ? defaultImport.default : defaultImport);\n", "\nimport * as defaultImport from \"lodash\";\nexport * from \"lodash\";\nexport default ('default' in defaultImport ? defaultImport.default : defaultImport);\n", "\nimport * as defaultImport from \"@splunk/dashboard-context\";\nexport * from \"@splunk/dashboard-context\";\nexport default ('default' in defaultImport ? defaultImport.default : defaultImport);\n", "\nimport * as defaultImport from \"@splunk/dashboard-definition\";\nexport * from \"@splunk/dashboard-definition\";\nexport default ('default' in defaultImport ? defaultImport.default : defaultImport);\n", "\nimport * as defaultImport from \"@splunk/dashboard-ui\";\nexport * from \"@splunk/dashboard-ui\";\nexport default ('default' in defaultImport ? defaultImport.default : defaultImport);\n", "\nimport * as defaultImport from \"@splunk/dashboard-utils\";\nexport * from \"@splunk/dashboard-utils\";\nexport default ('default' in defaultImport ? defaultImport.default : defaultImport);\n", "\nimport * as defaultImport from \"@splunk/dashboard-state\";\nexport * from \"@splunk/dashboard-state\";\nexport default ('default' in defaultImport ? defaultImport.default : defaultImport);\n", "\nimport * as defaultImport from \"styled-components\";\nexport * from \"styled-components\";\nexport default ('default' in defaultImport ? defaultImport.default : defaultImport);\n", "\nimport * as defaultImport from \"@splunk/themes\";\nexport * from \"@splunk/themes\";\nexport default ('default' in defaultImport ? defaultImport.default : defaultImport);\n", "import { isEmpty, memoize } from 'lodash';\nimport { console } from '@splunk/dashboard-utils';\nimport type { BackgroundImageOptions } from '@splunk/dashboard-types';\n\n/**\n * check if an image is from Image Registry\n * @param {*} src\n */\nexport const isFromImageRegistry = (src = ''): boolean => {\n    const [type] = src.split('://');\n    return (\n        src.indexOf('://') > -1 &&\n        type !== 'http' &&\n        type !== 'https' &&\n        type !== 'ftp' &&\n        type !== 'file'\n    );\n};\n\ninterface ValidImagePosArgs {\n    x?: number;\n    y?: number;\n    canvasWidth: number;\n    canvasHeight: number;\n}\n\n/**\n * Check whether image position is valid or not\n * @method validImagePos\n * @param {Number} x\n * @param {Number} y\n * @param {Number} canvasWidth\n * @param {Number} canvasHeight\n * @returns {Boolean}\n */\nexport const validImagePos = ({\n    x,\n    y,\n    canvasWidth,\n    canvasHeight,\n}: ValidImagePosArgs): boolean =>\n    !!(\n        x != null &&\n        Number.isInteger(x) &&\n        y != null &&\n        Number.isInteger(y) &&\n        x <= canvasWidth &&\n        y <= canvasHeight &&\n        x >= 0 &&\n        y >= 0\n    );\n\n/**\n * Check whether image width and height is valid or not\n * @method validImageWidthHeight\n * @param {Number} imageWidth //Defaulted to 1 because w can't be undefined\n * @param {Number} imageHeight //Defaulted to 1 because h can't be undefined\n * @param {Number} canvasWidth\n * @param {Number} canvasHeight\n * @returns {Boolean}\n */\nexport const validImageWidthHeight = (\n    imageWidth = 1,\n    imageHeight = 1\n): boolean =>\n    !!(\n        Number.isInteger(imageWidth) &&\n        Number.isInteger(imageHeight) &&\n        imageWidth > 0 &&\n        imageHeight > 0\n    );\n\nconst sizeTypes = ['cover', 'contain', 'auto', undefined] as const;\ntype SizeType = (typeof sizeTypes)[number];\n\n/**\n * Check whether image size type is valid or not (cover/auto/contain/undefined)\n * @method invalidImageSizeType\n * @param {String} sizeType\n * @returns {Boolean}\n */\nexport const invalidImageSizeType = (sizeType?: string): boolean =>\n    !sizeTypes.includes(sizeType as SizeType);\n\n/**\n * Return the original width and height of a valid image\n * @method getImageWidthHeight\n * @param {String} imgSrc\n * @returns {Number. Number} Image width and height\n */\nexport const getImageDimension = memoize(\n    (imgSrc: string): { width: number; height: number } => {\n        const img = new Image();\n        try {\n            img.src = imgSrc;\n            img.style.position = 'absolute';\n            img.style.left = '-9999'; // Image width must not exceed 9999 pixels\n            img.style.visibility = 'hidden';\n            document.body.appendChild(img);\n            const height = img.naturalHeight;\n            const width = img.naturalWidth;\n            return { width, height };\n        } catch {\n            return { width: 0, height: 0 };\n        } finally {\n            if (document.body.contains(img)) {\n                document.body.removeChild(img); // Removes the image from the DOM\n            }\n        }\n    }\n);\n\n// normalize opacity to a number between 0 and 1\nexport const validateOpacity = (opacity: unknown) => {\n    if (typeof opacity !== 'number' || opacity > 1) {\n        return 1;\n    }\n    if (opacity < 0) {\n        return 0;\n    }\n    return opacity;\n};\n\nconst validateImageXY = ({\n    canvasWidth,\n    canvasHeight,\n    x,\n    y,\n}: {\n    canvasWidth: number;\n    canvasHeight: number;\n    x?: number;\n    y?: number;\n}) => {\n    // validImageSrc(src); make no sense to validate but not display errors.\n    if (!validImagePos({ x, y, canvasWidth, canvasHeight })) {\n        console.warn(\n            `Invalid background image position, x: ${x} y: ${y}. Defaulting to x: 0, y: 0`\n        );\n        return [0, 0];\n    }\n    return [x, y];\n};\n\nconst validateSizeType = ({\n    w,\n    h,\n    sizeType,\n}: {\n    w?: number;\n    h?: number;\n    sizeType?: string;\n}): SizeType => {\n    if (\n        typeof w !== 'number' &&\n        typeof h !== 'number' &&\n        (typeof sizeType !== 'string' || invalidImageSizeType(sizeType))\n    ) {\n        console.warn(\n            `Invalid background image sizeType, ${sizeType}. Defaulting to contain`\n        );\n        return 'contain';\n    }\n    return sizeType as SizeType;\n};\n\nconst validateImageWH = ({ w, h }: { w?: number; h?: number }) => {\n    // good to go\n    if (validImageWidthHeight(w, h)) {\n        return [w, h];\n    }\n\n    console.warn(\n        `Invalid background image width and height, w: ${w} h: ${h}. Defaulting to image original size`\n    );\n    return [w ?? 0, h ?? 0];\n};\n\ninterface ValidateBackgroundImageArgs {\n    backgroundImage?: BackgroundImageOptions;\n    canvasWidth: number;\n    canvasHeight: number;\n}\n\n/**\n * Check whether background image options are valid or not. Default to x:0, y:0, w:0, h:0 and sizeType:'auto'\n * @method validateBackgroundImage\n * @param {Object} backgroundImage\n * @param {String} backgroundImage.src\n * @param {Number} backgroundImage.x\n * @param {Number} backgroundImage.y\n * @param {Number} backgroundImage.w\n * @param {Number} backgroundImage.h\n * @param {String} backgroundImage.sizeType\n * @param {Number} [backgroundImage.opacity]\n * @param {Number} width\n * @param {Number} height\n * @returns {Object}\n */\nexport const validateBackgroundImage = ({\n    backgroundImage = {},\n    canvasWidth,\n    canvasHeight,\n}: ValidateBackgroundImageArgs): BackgroundImageOptions => {\n    if (isEmpty(backgroundImage) || !backgroundImage.src) {\n        // This is a little dumb, but its what the tests are expecting\n        return {\n            src: backgroundImage.src,\n            x: backgroundImage.x,\n            y: backgroundImage.y,\n            w: backgroundImage.w,\n            h: backgroundImage.h,\n            sizeType: backgroundImage.sizeType,\n            opacity: backgroundImage.opacity ?? 1,\n        };\n    }\n\n    const opacity = validateOpacity(backgroundImage.opacity);\n\n    const [x, y] = validateImageXY({\n        canvasWidth,\n        canvasHeight,\n        x: backgroundImage.x,\n        y: backgroundImage.y,\n    });\n\n    const sizeType = validateSizeType({\n        w: backgroundImage.w,\n        h: backgroundImage.h,\n        sizeType: backgroundImage.sizeType,\n    });\n\n    const [w, h] = validateImageWH({\n        w: backgroundImage.w,\n        h: backgroundImage.h,\n    });\n\n    return { src: backgroundImage.src, x, y, w, h, sizeType, opacity };\n};\n", "import { uniqueId } from '@splunk/dashboard-utils';\nimport type {\n    AbsoluteBlockItem,\n    AbsolutePosition,\n    Coordinate,\n} from '@splunk/dashboard-types';\nimport type {\n    EdgeItem,\n    VerticalBoundaries,\n    HorizontalBoundaries,\n    EdgeBoundaries,\n} from '../types';\n\nconst nextEdgeId = () => `edge_${uniqueId()}`;\n\n/**\n * generate edge id\n */\nconst getNextEdgeId = () => {\n    return nextEdgeId();\n};\n\nexport type Intersections = Record<number, Record<number, AbsoluteBlockItem[]>>;\n\n/**\n * Returns a 2D array of every viz corner, indicating which visualizations touch which node(corner)\n * @param {Object} layoutStructure - Array of visualizations from definition\n * @returns {Object[][]} - {x: { y: [vizList] } }\n */\nexport const getNodes = (\n    layoutStructure: AbsoluteBlockItem[]\n): Intersections | null => {\n    if (layoutStructure.length === 0) {\n        return null;\n    }\n\n    const nodes: Intersections = {};\n    layoutStructure.forEach((viz) => {\n        const { x, y, w, h } = viz.position;\n        const corners = [\n            { x, y },\n            { x: x + w, y },\n            { x, y: y + h },\n            { x: x + w, y: y + h },\n        ];\n        corners.forEach((corner) => {\n            if (nodes[corner.x] === undefined) {\n                nodes[corner.x] = {};\n            }\n            if (nodes[corner.x][corner.y] === undefined) {\n                nodes[corner.x][corner.y] = [];\n            }\n            nodes[corner.x][corner.y].push(viz);\n        });\n    });\n    return nodes;\n};\n\nconst isTopEdge = (edge: EdgeItem): boolean =>\n    edge.orientation === 'horizontal' && edge.edgeStart.y === 0;\n\nconst isBottomEdge = (edge: EdgeItem, canvasHeight: number) =>\n    edge.orientation === 'horizontal' && edge.edgeStart.y === canvasHeight;\n\nconst isLeftEdge = (edge: EdgeItem): boolean =>\n    edge.orientation === 'vertical' && edge.edgeStart.x === 0;\n\nconst isRightEdge = (edge: EdgeItem, canvasWidth: number): boolean =>\n    edge.orientation === 'vertical' && edge.edgeStart.x === canvasWidth;\n\n/**\n * Returns all the visualizations along a vertical edge\n * @param {Object} param - Param object needed to traverse along vertical edge\n * @param {num} param.x - x-coordinate of the edge\n * @param {num} param.yStart - y-coordinate of the edge start\n * @param {num} param.yEnd - y-coordinate of the edge end\n * @param {num} param.yCurrent - Current y in recursion\n * @param {num} param.nodes - The map of x,y coordinates to visualizations that touch that (x,y)\n * @param {num} param.visualizations - the list to add visualizations to, and then return\n * @returns {Set<Object>} - Set of unique visualizations along the edge\n */\nconst findVizAlongVerticalEdge = ({\n    x,\n    yStart,\n    yEnd,\n    yCurrent = yStart,\n    nodes,\n    visualizations = new Set(),\n}: {\n    x: number;\n    yStart: number;\n    yEnd: number;\n    yCurrent?: number;\n    nodes: Intersections;\n    visualizations?: Set<AbsoluteBlockItem>;\n}) => {\n    nodes[x][yCurrent].forEach((viz) => {\n        if (viz.position.w <= 0 || viz.position.h <= 0) {\n            // invalid size due to scale, do not process\n            return;\n        }\n\n        if (viz.position.y >= yStart && viz.position.y < yEnd) {\n            visualizations.add(viz);\n        }\n        if (viz.position.y >= yCurrent && yCurrent + viz.position.h <= yEnd) {\n            findVizAlongVerticalEdge({\n                x,\n                yStart,\n                yEnd,\n                yCurrent: yCurrent + viz.position.h,\n                nodes,\n                visualizations,\n            });\n        }\n    });\n    return visualizations;\n};\n\n/**\n * Returns all the visualizations along a horizontal edge\n * @param {Object} param - Param object needed to traverse along horizontal edge\n * @param {num} param.y - x-coordinate of the edge\n * @param {num} param.xStart - x-coordinate of the edge start\n * @param {num} param.xEnd - x-coordinate of the edge end\n * @param {num} param.xCurrent - Current x in recursion\n * @param {num} param.nodes - The map of x,y coordinates to visualizations that touch that (x,y)\n * @param {num} param.visualizations - the list to add visualizations to, and then return\n * @returns {Set<Object>} - Set of unique visualizations along the edge\n */\nconst findVizAlongHorizontalEdge = ({\n    y,\n    xStart,\n    xEnd,\n    xCurrent = xStart,\n    nodes,\n    visualizations = new Set(),\n}: {\n    y: number;\n    xStart: number;\n    xEnd: number;\n    xCurrent?: number;\n    nodes: Intersections;\n    visualizations?: Set<AbsoluteBlockItem>;\n}) => {\n    nodes[xCurrent]?.[y]?.forEach((viz) => {\n        if (viz.position.w <= 0 || viz.position.h <= 0) {\n            // invalid size due to scale, do not process\n            return;\n        }\n\n        if (viz.position.x >= xStart && viz.position.x < xEnd) {\n            visualizations.add(viz);\n        }\n        if (viz.position.x >= xCurrent && xCurrent + viz.position.w <= xEnd) {\n            findVizAlongHorizontalEdge({\n                y,\n                xStart,\n                xEnd,\n                xCurrent: xCurrent + viz.position.w,\n                nodes,\n                visualizations,\n            });\n        }\n    });\n    return visualizations;\n};\n\n/**\n * Add edge to the provided list\n * @param {Object} param - Params containing edge info\n * @param {num} param.edges - the list to add the edge to\n * @param {Object} param.edgeStart - the start of the edge\n * @param {Object} param.edgeEnd - the end of the edge\n * @param {Object[][]} param.nodes - The map of x,y coordinates to visualizations that touch that (x,y)\n */\nconst addEdge = ({\n    edges,\n    edgeStart,\n    edgeEnd,\n    nodes,\n}: {\n    edges: EdgeItem[];\n    edgeStart: Coordinate;\n    edgeEnd: Coordinate;\n    nodes: Intersections;\n}): void => {\n    const orientation = edgeStart.y === edgeEnd.y ? 'horizontal' : 'vertical';\n\n    // Find all visualizations that are affected by this edge\n    const visualizations =\n        orientation === 'vertical'\n            ? findVizAlongVerticalEdge({\n                  x: edgeStart.x,\n                  yStart: edgeStart.y,\n                  yEnd: edgeEnd.y,\n                  nodes,\n              })\n            : findVizAlongHorizontalEdge({\n                  y: edgeStart.y,\n                  xStart: edgeStart.x,\n                  xEnd: edgeEnd.x,\n                  nodes,\n              });\n\n    edges.push({\n        item: getNextEdgeId(),\n        edgeStart,\n        edgeEnd,\n        visualizations: Array.from(visualizations),\n        orientation,\n    });\n};\n\n/**\n * If there is no incoming edge from the top, return true\n * @param {num} y - Current y position to compare against\n * @param {Object[]} visualizations - Array of visualizations attached to the node at (x, y). Length will be 1 to 4.\n * @returns {boolean}\n */\nconst shouldTraverseDown = (\n    y: number,\n    visualizations: AbsoluteBlockItem[]\n): boolean => {\n    return visualizations.every((viz) => viz.position.y >= y);\n};\n\n/**\n * If there is no incoming edge from the left, return true\n * @param {num} x - Current x position to compare against\n * @param {Object[]} visualizations - Array of visualizations attached to the node at (x, y). Length will be 1 to 4.\n * @returns {boolean}\n */\nconst shouldTraverseRight = (\n    x: number,\n    visualizations: AbsoluteBlockItem[]\n): boolean => {\n    return visualizations.every((viz) => viz.position.x >= x);\n};\n\n/**\n * Find the offset to the next node.\n * @param {Object} param - Param object to find offset to next node\n * @param {Number} param.x - The x co-ordinate of the current position to find offset from\n * @param {Number} param.y - The y co-ordinate of the current position to find offset from\n * @param {Object[]} param.visualizations - Array of visualizations attached to the node at (x, y). Length will be 1 to 4.\n * @param {Object} param.visualizations[].position - Position information of the visualization\n * @param {String} param.type - The type of co-ordinate. One of 'w' or 'h'.\n * @returns {number}\n */\nconst findOffset = ({\n    x,\n    y,\n    visualizations,\n    type,\n}: {\n    x: number;\n    y: number;\n    visualizations: AbsoluteBlockItem[];\n    type: 'w' | 'h';\n}): number => {\n    const vizXY = visualizations.find(\n        ({ position }) => position.y === y && position.x === x\n    );\n\n    if (vizXY) {\n        return vizXY.position[type];\n    }\n\n    // This is only for finding the bottom canvas edge and the right canvas edge\n    const vizWH = visualizations.find(\n        ({ position }) =>\n            // horizontal canvas edge\n            (type === 'w' && position.x === x) ||\n            // vertical canvas edge\n            (type === 'h' && position.y === y)\n    );\n\n    if (vizWH) {\n        return vizWH.position[type];\n    }\n\n    return 0;\n};\n\n/**\n * Traverse right along nodes, creating or extending edges\n * @param {Object} param - Param object to traverse right along layout\n * @param {Object[][]} param.nodes - An object that maps {x, y} coord to an array of visualizations. Indexed as nodes[x][y].\n * @param {Object[]} param.edges - The resulting array of edges that gets mutated\n * @param {Number} param.x - x coordinate of current node\n * @param {Number} param.y - y coordinate of current node\n * @param {Object} param.edgeStart - The { x, y } coordinates of start of edge\n * @param {Boolean} param.canTraverseDown - Used to prevent loops during indirect recursion\n */\nfunction traverseRight({\n    x,\n    y,\n    nodes,\n    edges,\n    edgeStart,\n    canTraverseDown = true,\n}: {\n    x: number;\n    y: number;\n    nodes: Intersections;\n    edges: EdgeItem[];\n    edgeStart: Coordinate;\n    canTraverseDown?: boolean;\n}) {\n    // Check if we should traverse down (if there is no incoming edge)\n    // canTraverseRight must be false to avoid endless loop\n    if (canTraverseDown && shouldTraverseDown(y, nodes[x][y])) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        traverseDown({\n            x,\n            y,\n            nodes,\n            edges,\n            edgeStart: { x, y }, // Start new edge when changing directions\n            canTraverseRight: false,\n        });\n    }\n\n    // Check if horizontal edge ends here\n    // 'w' signifies we want width offset returned as opposed to height\n    const offset = findOffset({ x, y, visualizations: nodes[x][y], type: 'w' });\n\n    // Case 1 for ending edge: can't go right anymore (hit a viz OR end of dashboard), create edge up to this point.\n    if (!offset) {\n        addEdge({ edges, edgeStart, edgeEnd: { x, y }, nodes });\n        return;\n    }\n\n    // Case 2 for ending edge: reached window, need to create edge and start new one to avoid merging across window\n    const isWindow = nodes[x][y].length === 4; // 4-way intersection\n    if (isWindow) {\n        addEdge({ edges, edgeStart, edgeEnd: { x, y }, nodes });\n        // Continue traversing right, starting with a new edge from current position\n        traverseRight({\n            x: x + offset,\n            y,\n            nodes,\n            edges,\n            edgeStart: { x, y },\n        });\n        return;\n    }\n\n    // Continue traversing right, merging the past edge with the next\n    traverseRight({\n        x: x + offset,\n        y,\n        nodes,\n        edges,\n        edgeStart,\n    });\n}\n\n/**\n * Traverse right along nodes, creating or extending edges\n * @param {Object} param - Param object to traverse down along layout\n * @param {Object[][]} param.nodes - An object that maps {x, y} coord to an array of visualizations. Indexed as nodes[x][y].\n * @param {Object[]} param.edges - The resulting array of edges that gets mutated\n * @param {Number} param.x - x coordinate of current node\n * @param {Number} param.y - y coordinate of current node\n * @param {Object} param.edgeStart - The { x, y } coordinates of start of edge\n * @param {Boolean} param.canTraverseRight - Used to prevent loops during indirect recursion\n */\nfunction traverseDown({\n    x,\n    y,\n    nodes,\n    edges,\n    edgeStart,\n    canTraverseRight = true,\n}: {\n    x: number;\n    y: number;\n    nodes: Intersections;\n    edges: EdgeItem[];\n    edgeStart: Coordinate;\n    canTraverseRight?: boolean;\n}) {\n    if (canTraverseRight && shouldTraverseRight(x, nodes[x][y])) {\n        traverseRight({\n            x,\n            y,\n            nodes,\n            edges,\n            edgeStart: { x, y }, // Start new edge when changing directions\n            canTraverseDown: false,\n        });\n    }\n\n    // Check if vertical edge ends here\n    const offset = findOffset({ x, y, visualizations: nodes[x][y], type: 'h' });\n\n    // Case 1 for ending edge: can't go down anymore (hit a viz OR end of dashboard), create edge up to this point.\n    if (!offset) {\n        addEdge({ edges, edgeStart, edgeEnd: { x, y }, nodes });\n        return;\n    }\n\n    // Case 2 for ending edge: reached window, need to create edge and start new one to avoid merging across window\n    const isWindow = nodes[x][y].length === 4;\n    if (isWindow) {\n        addEdge({ edges, edgeStart, edgeEnd: { x, y }, nodes });\n        // Start a new edge from current position\n        traverseDown({\n            x,\n            y: y + offset,\n            nodes,\n            edges,\n            edgeStart: { x, y },\n        });\n        return;\n    }\n\n    // Continue traversing, thus \"merging\" edges\n    traverseDown({\n        x,\n        y: y + offset,\n        nodes,\n        edges,\n        edgeStart,\n    });\n}\n\n/**\n * Compute the vertical edges for every canvas row - a row that spans the entire width of the canvas\n * @param {Object} param\n * @param {AbsoluteBlockItem[]} param.layout - Layout structure\n * @param {EdgeItem[]} param.edges - The resulting array of edges that gets mutated\n * @param {Number} param.canvasWidth - Canvas width\n */\nconst computeVerticalCanvasEdges = ({\n    edges,\n    canvasWidth,\n    layout,\n}: {\n    edges: EdgeItem[];\n    canvasWidth: number;\n    layout: AbsoluteBlockItem[];\n}): void => {\n    const nodes = getNodes(layout);\n    if (nodes == null) {\n        return;\n    }\n    // get all the horizontal edges that span the entire canvas width\n    const sortedRowEdges = edges\n        .filter(\n            (edge) =>\n                edge.orientation === 'horizontal' &&\n                edge.edgeStart.x === 0 &&\n                edge.edgeEnd.x === canvasWidth\n        )\n        .sort((a, b) => a.edgeStart.y - b.edgeStart.y);\n\n    /**\n     * iterate through the sorted horizontal edges to get their start and end coordinates\n     * vertical edges between canvas row A and canvas row B will span from edgeStartA to edgeStartB and edgeEndA to edgeEndB\n     */\n    for (let i = 0; i < sortedRowEdges.length - 1; i += 1) {\n        const { edgeStart: edgeStartA, edgeEnd: edgeEndA } = sortedRowEdges[i];\n        const { edgeStart: edgeStartB, edgeEnd: edgeEndB } =\n            sortedRowEdges[i + 1];\n        addEdge({\n            edges,\n            edgeStart: edgeStartA,\n            edgeEnd: edgeStartB,\n            nodes,\n        });\n        addEdge({\n            edges,\n            edgeStart: edgeEndA,\n            edgeEnd: edgeEndB,\n            nodes,\n        });\n    }\n};\n\n/**\n * Gets all the edges given a layout of AbsoluteBlockItems\n * @param {AbsoluteBlockItem[]} layout - Array of AbsoluteBlockItems\n * @returns {EdgeItem[]} - Array of computed edges\n */\nexport const getAllEdges = (layout: AbsoluteBlockItem[]): EdgeItem[] => {\n    const edges: EdgeItem[] = [];\n    const nodes = getNodes(layout);\n\n    if (nodes === null || nodes[0] === undefined || nodes[0][0] === undefined) {\n        // When no visualizations in the layout structure\n        // OR when there is no visualization at (0,0), which this algorithm assumes\n        return [];\n    }\n    // run the algorithm\n    traverseRight({\n        x: 0,\n        y: 0,\n        nodes,\n        edges,\n        edgeStart: { x: 0, y: 0 },\n    });\n\n    return edges;\n};\n\n/**\n * Compute edges given a valid layout, canvasHeight, and canvasWidth\n * @param {Object} param - Param object containing layout, canvasHeight, canvasWidth\n * @param {Object[]} param.layout - Array of visualizations from the dashboard layout definition\n * @param {Number} param.canvasHeight - Canvas height\n * @param {Number} param.canvasWidth - Canvas width\n * @returns {Object[]} - Array of computed edges\n */\nexport const computeEdges = ({\n    layout,\n    canvasHeight,\n    canvasWidth,\n}: {\n    layout?: AbsoluteBlockItem[];\n    canvasHeight: number;\n    canvasWidth: number;\n}): EdgeItem[] => {\n    if (layout === undefined) {\n        return [];\n    }\n\n    let edges = getAllEdges(layout);\n\n    // remove the computed left and right vertical canvas edges as they span the entire height of the canvas\n    edges = edges.filter((edge) => {\n        return !(isLeftEdge(edge) || isRightEdge(edge, canvasWidth));\n    });\n\n    // recompute the vertical canvas edges for each canvas row where the row spans the entire width of the canvas\n    computeVerticalCanvasEdges({ edges, layout, canvasWidth });\n\n    // Additionally, the top and bottom edge are there, but set to hidden\n    edges = edges.map((edge) => {\n        let isCanvasEdge = false;\n        if (\n            isTopEdge(edge) ||\n            isRightEdge(edge, canvasWidth) ||\n            isBottomEdge(edge, canvasHeight) ||\n            isLeftEdge(edge)\n        ) {\n            isCanvasEdge = true;\n        }\n        return { ...edge, isCanvasEdge };\n    });\n\n    return edges;\n};\n\n/**\n * Format edge according to a given padding and edge thickness\n * @param {Object} param - Param object containing edge, padding, and edgeThickness\n * @param {Object} param.edge - Edge object\n * @param {Number} param.padding - Layout padding\n * @param {Number} param.edgeThickness - Thickness of edge\n * @returns {Object} - Returns formatted edge object\n */\nexport const formatEdge = ({\n    edge,\n    padding = 0,\n    edgeThickness = 0,\n}: {\n    edge: EdgeItem;\n    padding?: number;\n    edgeThickness?: number;\n}): EdgeItem => {\n    // Formatted edges are centered between visualizations and respect the padding (gutter-size) between them\n    const formattedEdgeStart = { ...edge.edgeStart };\n    const formattedEdgeEnd = { ...edge.edgeEnd };\n    if (edge.orientation === 'horizontal') {\n        formattedEdgeStart.x += padding;\n        formattedEdgeStart.y -= edgeThickness / 2;\n        formattedEdgeEnd.x -= padding;\n        formattedEdgeEnd.y -= edgeThickness / 2;\n    } else {\n        formattedEdgeStart.y += padding;\n        formattedEdgeStart.x -= edgeThickness / 2;\n        formattedEdgeEnd.y -= padding;\n        formattedEdgeEnd.x -= edgeThickness / 2;\n    }\n\n    return {\n        ...edge,\n        edgeStart: formattedEdgeStart,\n        edgeEnd: formattedEdgeEnd,\n    };\n};\n\n/**\n * Format visualization according to a given padding\n * @param {Object} param - Param object containing item and padding\n * @param {Object} param.item - Visualization object\n * @param {Number} param.padding - Layout padding\n * @returns {AbsoluteBlockItem} - Returns formatted edge object\n */\nexport const applyVizPadding = ({\n    item,\n    padding = 0,\n}: {\n    item: AbsoluteBlockItem;\n    padding?: number;\n}): AbsoluteBlockItem => {\n    const { x, y, w, h } = item.position;\n    return {\n        ...item,\n        position: {\n            x: x + padding,\n            y: y + padding,\n            w: w - 2 * padding,\n            h: h - 2 * padding,\n        },\n    };\n};\n\n/**\n * Determines Upper and Lower boundaries of an edge given its visualizations around it\n * @param {Object[]} visualizations - The visualizations surrounding the edge\n * @param {Number} y - The y position of the selected edge\n * @param {Number} minHeight - minimum Item Height Value\n * @param {Boolean} isFullWidthEdge - If the edge we are getting boundaries of is the size of canvas width\n * @returns {Object} - returns the boundaries in an object\n */\nexport const getVerticalBoundaries = ({\n    visualizations,\n    y,\n    minHeight,\n    isFullWidthEdge = false,\n}: {\n    visualizations: AbsoluteBlockItem[];\n    y: number;\n    minHeight: number;\n    isFullWidthEdge?: boolean;\n}): VerticalBoundaries => {\n    const boundaries = {\n        upperBoundary: Number.NEGATIVE_INFINITY,\n        lowerBoundary: Number.POSITIVE_INFINITY,\n    };\n\n    const comparePosition = (position: AbsolutePosition) => {\n        // If viz is below of the edge\n        // When the edge is a full width edge, there is no lower boundary\n        //  since dragging down increases canvas size\n        if (position.y >= y && !isFullWidthEdge) {\n            boundaries.lowerBoundary = Math.min(\n                boundaries.lowerBoundary,\n                position.y + position.h - minHeight\n            );\n        }\n        // If viz is above the edge\n        if (position.y < y) {\n            boundaries.upperBoundary = Math.max(\n                boundaries.upperBoundary,\n                position.y + minHeight\n            );\n        }\n    };\n\n    visualizations.forEach((viz) => comparePosition(viz.position));\n    return boundaries;\n};\n\n/**\n * Determines Left and Right boundaries of an edge given its visualizations around it\n * @param {Object[]} visualizations - The visualizations surrounding the edge\n * @param {Number} x - The x position of the selected edge\n * @param {Number} minWidth - minimum Item Width Value\n * @returns {Object} - returns the boundaries in an object\n */\nexport const getHorizontalBoundaries = ({\n    visualizations,\n    x,\n    minWidth,\n}: {\n    visualizations: AbsoluteBlockItem[];\n    x: number;\n    minWidth: number;\n}): HorizontalBoundaries => {\n    const boundaries = {\n        rightBoundary: Number.POSITIVE_INFINITY,\n        leftBoundary: Number.NEGATIVE_INFINITY,\n    };\n\n    const comparePosition = (position: AbsolutePosition) => {\n        if (position.x >= x) {\n            // If viz is to the right of the edge\n            boundaries.rightBoundary = Math.min(\n                boundaries.rightBoundary,\n                position.x + position.w - minWidth\n            );\n        }\n        if (position.x < x) {\n            // If viz is to the left of the edge\n            boundaries.leftBoundary = Math.max(\n                boundaries.leftBoundary,\n                position.x + minWidth\n            );\n        }\n    };\n\n    visualizations.forEach((viz) => comparePosition(viz.position));\n    return boundaries;\n};\n\n/**\n * Determines the next edge position for movement up and down of a horizontal edge\n * @param {Object} edge - the current moving edge\n * @param {Number} offset - offset to move edge\n * @param {Object} options.edgeBoundaries Object with lower/upper boundaries\n * @returns {Object} - returns edge with updated position\n */\nexport const moveHorizontalEdge = ({\n    edge,\n    offset,\n    edgeBoundaries: { upperBoundary, lowerBoundary },\n}: {\n    edge: EdgeItem;\n    offset: number;\n    edgeBoundaries: VerticalBoundaries;\n}): EdgeItem => {\n    // Update edge to either the offset value,\n    // or the defined maximum/minimum based on min viz height/width\n    const updatedY =\n        offset < 0\n            ? Math.max(upperBoundary, edge.edgeStart.y + offset)\n            : Math.min(lowerBoundary, edge.edgeStart.y + offset);\n\n    return {\n        ...edge,\n        edgeStart: {\n            x: edge.edgeStart.x,\n            y: updatedY,\n        },\n        edgeEnd: {\n            x: edge.edgeEnd.x,\n            y: updatedY,\n        },\n    };\n};\n\n/**\n * Determines the next edge position for movement left and right of a vertical edge\n * @param {Object} edge - the current moving edge\n * @param {Number} offset - offset to move edge\n * @param {Object} options.edgeBoundaries Object with left/right boundaries\n * @returns {Object} - returns edge with updated position\n */\nexport const moveVerticalEdge = ({\n    edge,\n    offset,\n    edgeBoundaries: { leftBoundary, rightBoundary },\n}: {\n    edge: EdgeItem;\n    offset: number;\n    edgeBoundaries: HorizontalBoundaries;\n}): EdgeItem => {\n    const updatedX =\n        offset < 0\n            ? Math.max(leftBoundary, edge.edgeStart.x + offset)\n            : Math.min(rightBoundary, edge.edgeStart.x + offset);\n\n    return {\n        ...edge,\n        edgeStart: {\n            x: updatedX,\n            y: edge.edgeStart.y,\n        },\n        edgeEnd: {\n            x: updatedX,\n            y: edge.edgeEnd.y,\n        },\n    };\n};\n\n/**\n * find edges that the given edge should snap to, according to the snap range\n * @param {Object} options\n * @param {Object} options.edge the edge being dragged, edge has the structure\n * @param {array}  options.edges all the edges that are parallel to target edge and within the boundary\n * @param {Number} options.snapRange the range within which that triggers snapping\n * @returns {Object} updatedEdge and snappableEdges\n */\nexport const findSnappableEdges = ({\n    edge,\n    edges,\n    snapRange,\n}: {\n    edge: EdgeItem;\n    edges: EdgeItem[];\n    snapRange: number;\n}): { updatedEdge: EdgeItem; snappableEdges: EdgeItem[] } => {\n    const coordinate = edge.orientation === 'horizontal' ? 'y' : 'x';\n\n    const snappableEdges = edges.reduce<EdgeItem[]>(\n        (currentSnappableEdges, nextEdge) => {\n            const nextEdgeDistance = Math.abs(\n                nextEdge.edgeStart[coordinate] - edge.edgeStart[coordinate]\n            );\n\n            // nextEdge is in range\n            if (nextEdgeDistance <= snapRange) {\n                if (currentSnappableEdges.length === 0) {\n                    return [nextEdge];\n                }\n\n                const lastEdge =\n                    currentSnappableEdges[currentSnappableEdges.length - 1];\n                const lastEdgeDistance = Math.abs(\n                    lastEdge.edgeStart[coordinate] - edge.edgeStart[coordinate]\n                );\n\n                // find new closest snappable edge\n                if (nextEdgeDistance < lastEdgeDistance) {\n                    return [nextEdge];\n                }\n\n                // it is possible there are several snappable edges having the same x or y value\n                if (nextEdgeDistance === lastEdgeDistance) {\n                    return [...currentSnappableEdges, nextEdge];\n                }\n            }\n\n            // nextEdge is out of range\n            return [...currentSnappableEdges];\n        },\n        []\n    );\n\n    // if no snappable edge, snap to itself\n    const firstSnappableEdge =\n        snappableEdges.length > 0 ? snappableEdges[0] : edge;\n\n    return {\n        updatedEdge: {\n            ...edge,\n            edgeStart: {\n                ...edge.edgeStart,\n                [coordinate]: firstSnappableEdge.edgeStart[coordinate],\n            },\n            edgeEnd: {\n                ...edge.edgeEnd,\n                [coordinate]: firstSnappableEdge.edgeEnd[coordinate],\n            },\n        },\n        snappableEdges,\n    };\n};\n\n/**\n * Find all the edges that could be snapped to, given the limitations enforced by the surrounding visualizations.\n * @param {Object} options\n * @param {Object} options.edge the edge being dragged\n * @param {array}  options.edges all the edges on canvas\n * @param {Object} options.edgeBoundaries Object with either lower/upper or left/right boundaries\n * @returns {array} the edges that are within the boundary of the edge being moved\n */\nexport const findEdgesInBoundary = ({\n    edge,\n    edges,\n    edgeBoundaries,\n}: {\n    edge: EdgeItem;\n    edges: EdgeItem[];\n    edgeBoundaries: EdgeBoundaries;\n}): EdgeItem[] => {\n    const { orientation } = edge;\n\n    if (orientation === 'horizontal') {\n        return edges.filter(\n            (e) =>\n                e.orientation === 'horizontal' &&\n                e.edgeStart.y >=\n                    (edgeBoundaries as VerticalBoundaries).upperBoundary &&\n                e.edgeStart.y <=\n                    (edgeBoundaries as VerticalBoundaries).lowerBoundary &&\n                e !== edge\n        );\n    }\n    if (orientation === 'vertical') {\n        return edges.filter(\n            (e) =>\n                e.orientation === 'vertical' &&\n                e.edgeStart.x >=\n                    (edgeBoundaries as HorizontalBoundaries).leftBoundary &&\n                e.edgeStart.x <=\n                    (edgeBoundaries as HorizontalBoundaries).rightBoundary &&\n                e !== edge\n        );\n    }\n    // can't match any edge because the orientation is invalid, this shouldn't happen.\n    return [];\n};\n", "export const GRID_SIZE = 10;\nexport const GRID_PADDING = 1;\nexport const MIN_WIDTH = GRID_SIZE * 2;\nexport const MIN_HEIGHT = GRID_SIZE * 2;\n\n/** given offsetMultiplier=1, place clone 2 grid cells offset */\nexport const OFFSET_SIZE = GRID_SIZE * 2;\n", "import type { MutableRefObject } from 'react';\nimport { cloneDeep, findLast, isNumber, pullAt, reduce, sortBy } from 'lodash';\nimport {\n    collides,\n    computeMaxHeight as utilsComputeMaxHeight,\n    console,\n} from '@splunk/dashboard-utils';\nimport type {\n    Coordinate,\n    ConnectedPosition,\n    AbsolutePosition,\n    Port,\n    ConnectedLineItem,\n    ConnectedLinePosition,\n    AbsoluteLayoutStructure,\n    AbsoluteBlockItem,\n    AbsoluteLayoutItem,\n    GridLayoutStructure,\n    HandleDirection,\n} from '@splunk/dashboard-types';\nimport { applyVizPadding, getAllEdges } from './edgeUtils';\nimport type { Offset, LineDirection } from '../types';\nimport { OFFSET_SIZE } from '../AbsoluteLayoutConstants';\n\n// export for gridLayout/legacyGridLayout\nexport const computeMaxHeight = utilsComputeMaxHeight;\n\n/**\n *  check if a position is valid\n * @param {Object} position\n */\nexport const isBlockPositionValid = (position: AbsolutePosition): boolean =>\n    !!(\n        position &&\n        Number.isInteger(position.x) &&\n        Number.isInteger(position.y) &&\n        Number.isInteger(position.w) &&\n        Number.isInteger(position.h)\n    );\n\nexport const isValidConnection = (\n    connection: Coordinate | ConnectedPosition\n): boolean => {\n    if (\n        'x' in connection &&\n        'y' in connection &&\n        Number.isInteger(connection.x) &&\n        Number.isInteger(connection.y)\n    ) {\n        return true;\n    }\n    if (\n        'item' in connection &&\n        'port' in connection &&\n        connection.item != null &&\n        connection.port != null\n    ) {\n        return true;\n    }\n    return false;\n};\n\n/**\n * a line should has from and to\n */\nexport const isLinePositionValid = (\n    position: ConnectedLinePosition\n): boolean => {\n    if (position.from != null && position.to != null) {\n        return (\n            isValidConnection(position.from) && isValidConnection(position.to)\n        );\n    }\n    return false;\n};\n\n/**\n * filter invalid position\n * @param {Object[]} layoutStructure - Array of items (viz, edges, lines)\n * @returns {Object[]} - Returns filtered array\n */\nexport const removeInvalidItems = (\n    layoutStructure: AbsoluteLayoutStructure = []\n): AbsoluteLayoutStructure =>\n    layoutStructure.filter((structure) => {\n        if (structure.type === 'line') {\n            return isLinePositionValid(structure.position);\n        }\n        return isBlockPositionValid(structure.position);\n    });\n\nexport interface PositionStyle {\n    width: string;\n    height: string;\n    transform: string;\n}\n\n/**\n * convert position to css object\n */\nexport const positionToStyle = (pos: AbsolutePosition): PositionStyle => ({\n    width: `${pos.w}px`,\n    height: `${pos.h}px`,\n    transform: `translate(${pos.x}px, ${pos.y}px)`,\n});\n\n/**\n * convert position to css string\n */\nexport const positionToStyleString = (pos: AbsolutePosition): string => {\n    const style = positionToStyle(pos);\n    return reduce(style, (result, v, k) => `${result} ${k}:${v};`, '');\n};\n\n/**\n * get client position for given event with scale factor\n */\nexport const getClientPosition = (\n    e: {\n        clientX: number;\n        clientY: number;\n    },\n    scaleFactor = 1\n): Coordinate => ({\n    x: Math.round(e.clientX / scaleFactor),\n    y: Math.round(e.clientY / scaleFactor),\n});\n\n/**\n * compute offset from 2 positions\n */\nexport const getOffset = (\n    currentPosition: Coordinate,\n    startPosition: Coordinate\n): Offset => ({\n    offsetX: currentPosition.x - startPosition.x,\n    offsetY: currentPosition.y - startPosition.y,\n});\n\n/**\n * check if a given offset can be considered as 'move'\n * @param {Object} config\n * @param {Number} config.offsetX\n * @param {Number} config.offsetY\n */\nexport const considerMoved = ({\n    offsetX,\n    offsetY,\n}: {\n    offsetX: number;\n    offsetY: number;\n}): boolean => offsetX !== 0 || offsetY !== 0;\n\n/**\n * return a boundary for 2 positions\n * @param {Coordinate} startPos\n * @param {Coordinate} endPos\n */\nexport const positionsToBoundary = (\n    startPos: Coordinate,\n    endPos: Coordinate\n): AbsolutePosition => ({\n    x: Math.min(startPos.x, endPos.x),\n    y: Math.min(startPos.y, endPos.y),\n    w: Math.abs(startPos.x - endPos.x),\n    h: Math.abs(startPos.y - endPos.y),\n});\n\n/**\n * filter abs items within a boundary\n * @param {Array} items\n * @param {Object} boundary\n */\nexport const filterBlockItemsByBoundary = (\n    items: AbsoluteBlockItem[],\n    boundary: AbsolutePosition\n): AbsoluteBlockItem[] =>\n    items.filter((item) => {\n        const itemPosition = item.position;\n        return !(\n            boundary.x > itemPosition.x + itemPosition.w ||\n            boundary.x + boundary.w < itemPosition.x ||\n            boundary.y > itemPosition.y + itemPosition.h ||\n            boundary.y + boundary.h < itemPosition.y\n        );\n    });\n\n/**\n * find the first item that contains the pos.\n */\nexport const findTopBlockItemByPosition = (\n    items: AbsoluteBlockItem[],\n    pos: Coordinate,\n    padding = 0\n): AbsoluteBlockItem | undefined =>\n    findLast(items, (item) => {\n        const itemPosition = padding\n            ? applyVizPadding({ item, padding }).position\n            : item.position;\n        return (\n            itemPosition.x <= pos.x &&\n            itemPosition.x + itemPosition.w >= pos.x &&\n            itemPosition.y <= pos.y &&\n            itemPosition.y + itemPosition.h >= pos.y\n        );\n    });\n\n/**\n * Compute the new offset so current + new offset will be the multiple of snapTo unit\n * For examples:\n * (5, 2, 5) => 0, user moved less than half of the snapTo unit, return 0 so 5 + 0 = 5\n * (5, 3, 5) => 5, user moved more than half of the snapTo unit, return 5 so 5 + 5 = 5 * 2\n * (5, 12, 5) => 10\n * (5, 13, 5) => 15\n * @param {Number} current\n * @param {Number} offset\n * @param {Number} snapTo\n */\nexport const snapOffset = (\n    current: number,\n    offset: number,\n    snapTo: number\n): number => {\n    // return a new offset\n    const remainder = (current + offset) % snapTo;\n    const newOffset =\n        remainder > snapTo / 2\n            ? offset + (snapTo - remainder)\n            : offset - remainder;\n    return newOffset;\n};\n\nexport interface SnapOffsetToXYArgs {\n    position: AbsolutePosition;\n    offset: Offset;\n    gridWidth: number;\n    gridHeight: number;\n    spacing?: number;\n    padding?: number;\n}\n\n/**\n * snap item with its top-left corner (represent by x, y)\n * @param {Object} position\n * @param {Object} offset\n * @param {Number} gridWidth\n * @param {Number} gridHeight\n * @param {Number} spacing\n */\nexport const snapOffsetToXY = ({\n    position,\n    offset,\n    gridWidth,\n    gridHeight,\n    spacing = 0,\n    padding = 0,\n}: SnapOffsetToXYArgs): Offset => {\n    let { offsetX, offsetY } = offset;\n    offsetX = snapOffset(position.x, offsetX, gridWidth + spacing) + padding;\n    offsetY = snapOffset(position.y, offsetY, gridHeight + spacing) + padding;\n    return {\n        offsetX,\n        offsetY,\n    };\n};\n\nexport type SnapOffsetToWHArgs = SnapOffsetToXYArgs;\n\n/**\n * snap item with its size (represent by w, h)\n * @param {Object} position\n * @param {Object} offset\n * @param {Number} gridWidth\n * @param {Number} gridHeight\n * @param {Number} spacing\n */\nexport const snapOffsetToWH = ({\n    position,\n    offset,\n    gridWidth,\n    gridHeight,\n    spacing = 0,\n    padding = 0,\n}: SnapOffsetToWHArgs): Offset => {\n    let { offsetX, offsetY } = offset;\n    offsetX =\n        snapOffset(position.x + position.w, offsetX, gridWidth + spacing) +\n        (padding - spacing);\n    offsetY =\n        snapOffset(position.y + position.h, offsetY, gridHeight + spacing) +\n        (padding - spacing);\n    return {\n        offsetX,\n        offsetY,\n    };\n};\n\nexport interface UpdateBlockItemSizeArgs {\n    item: AbsoluteBlockItem;\n    offset: Offset;\n    dir: HandleDirection;\n    options?: {\n        minWidth?: number;\n        minHeight?: number;\n    };\n}\n\n/**\n * Mutate item coordinates and/or dimensions.\n * This mutation's new dimensions and coordinates are bounded within the original block item real estate.\n * @param {Object} item\n * @param {Object} offset\n * @param {String} dir Cartesian direction to shift item towards.\n * @param {Object} options\n */\nexport const updateBlockItemSize = ({\n    item,\n    offset,\n    dir,\n    options: { minWidth = 0, minHeight = 0 } = {},\n}: UpdateBlockItemSizeArgs): AbsoluteBlockItem => {\n    const { w, h } = item.position;\n    const { offsetX, offsetY } = offset;\n    const updatedPosition = { ...item.position };\n\n    // resizing from north\n    if (['n', 'ne', 'nw'].includes(dir)) {\n        updatedPosition.y += Math.min(h - minHeight, offsetY);\n        updatedPosition.h -= offsetY;\n    }\n    // resizing from the south\n    if (['s', 'se', 'sw'].includes(dir)) {\n        updatedPosition.h += offsetY;\n    }\n    // resizing from the east\n    if (['e', 'ne', 'se'].includes(dir)) {\n        updatedPosition.w += offsetX;\n    }\n    // resizing from west\n    if (['w', 'nw', 'sw'].includes(dir)) {\n        updatedPosition.x += Math.min(w - minWidth, offsetX);\n        updatedPosition.w -= offsetX;\n    }\n\n    updatedPosition.w = Math.max(minWidth, updatedPosition.w);\n    updatedPosition.h = Math.max(minHeight, updatedPosition.h);\n    return {\n        ...item,\n        position: updatedPosition,\n    };\n};\n\nexport const updateBlockItemPosition = (\n    item: AbsoluteBlockItem,\n    offset: Offset\n): AbsoluteBlockItem => {\n    const { offsetX, offsetY } = offset;\n    return {\n        ...item,\n        position: {\n            ...item.position,\n            x: item.position.x + offsetX,\n            y: item.position.y + offsetY,\n        },\n    };\n};\n\n/**\n * create offset based on dir, x and y\n * @method createOffset\n * @param {String} dir\n * @param {Number} x\n * @param {Number} y\n * @returns {Object} offset\n */\nexport const createOffset = (\n    dir: HandleDirection,\n    x: number,\n    y: number\n): Offset => {\n    switch (dir) {\n        case 'n':\n            return {\n                offsetX: 0,\n                offsetY: -y,\n            };\n        case 's':\n            return {\n                offsetX: 0,\n                offsetY: y,\n            };\n        case 'w':\n            return {\n                offsetX: -x,\n                offsetY: 0,\n            };\n        case 'e':\n            return {\n                offsetX: x,\n                offsetY: 0,\n            };\n        default:\n            return {\n                offsetX: 0,\n                offsetY: 0,\n            };\n    }\n};\n\ninterface computeScaleToFitProps {\n    canvasWidth: number;\n    canvasHeight: number;\n    containerWidth: number;\n    containerHeight: number;\n    scrollbarWidth: number;\n    max?: number;\n    enableGridLayoutCssScaling?: boolean;\n}\n\n/**\n * compute scale factor\n * @param {Number} canvasWidth      width from the definition\n * @param {Number} canvasHeight     height from the definition\n * @param {Number} containerWidth   width from the size aware wrapper\n * @param {Number} containerHeight  height from the size aware wrrapper\n * @param {Number} scrollbarWidth   scrollbar width\n * @param {Number} max              max scale factor\n * @param {Boolean} enableGridLayoutCssScaling in grid layout, determines if scrollbar scale should always be returned\n */\n\nexport const computeScaleToFit = ({\n    canvasWidth,\n    canvasHeight,\n    containerWidth,\n    containerHeight,\n    scrollbarWidth,\n    max = Infinity,\n    enableGridLayoutCssScaling = true,\n}: computeScaleToFitProps): number => {\n    if (\n        !(\n            isNumber(containerWidth) &&\n            containerWidth > 0 &&\n            isNumber(canvasWidth) &&\n            canvasWidth > 0\n        )\n    ) {\n        console.warn(\n            `Failed to calculate layout scale: canvasWidth=${canvasWidth}, containerWidth=${containerWidth}; falling back to scale=1`\n        );\n        return 1;\n    }\n\n    const scale = Math.min(containerWidth / canvasWidth, max);\n    const scrollbarScale = Math.min(\n        (containerWidth - scrollbarWidth) / canvasWidth,\n        max\n    );\n\n    if (!enableGridLayoutCssScaling) {\n        return scrollbarScale;\n    }\n\n    if (canvasHeight * scale > containerHeight) {\n        return scrollbarScale;\n    }\n\n    return scale;\n};\n\n/**\n *\n * @param {Array} items\n * @param {Number} from  target item index\n * @param {Number} to    where does this item move to\n */\nexport const moveLayoutItem = (\n    items: AbsoluteLayoutItem[],\n    from: number,\n    to: number\n): AbsoluteLayoutItem[] => {\n    const structure = [...items];\n    const removed = pullAt(structure, [from]);\n    structure.splice(to, 0, removed[0]);\n    return structure;\n};\n\ninterface IsLineConnectedArgs {\n    line: ConnectedLineItem;\n    dir: LineDirection;\n}\n\n/**\n * check if a line is connected\n */\nexport const isLineConnected = ({ line, dir }: IsLineConnectedArgs): boolean =>\n    'item' in line.position[dir];\n\ninterface DisconnectLineArgs {\n    line: ConnectedLineItem;\n    dir: LineDirection;\n    absPos: Coordinate;\n}\n\n/**\n *  disconnect a line from item and set it to abs position\n */\nexport const disconnectLine = ({\n    line,\n    dir,\n    absPos,\n}: DisconnectLineArgs): ConnectedLineItem => {\n    const updatePosition = {\n        ...line.position,\n        [dir]: {\n            ...absPos,\n        },\n    };\n    return {\n        ...line,\n        position: updatePosition,\n    };\n};\n\ninterface ConnectLineArgs {\n    line: ConnectedLineItem;\n    dir: LineDirection;\n    itemId: string;\n    port: Port;\n}\n\n/**\n * connect a line with an item and port\n */\nexport const connectLine = ({\n    line,\n    dir,\n    itemId,\n    port,\n}: ConnectLineArgs): ConnectedLineItem => {\n    const { position } = line;\n    const updatedPosition = {\n        ...position,\n        [dir]: {\n            item: itemId,\n            port,\n        },\n    };\n    return {\n        ...line,\n        position: updatedPosition,\n    };\n};\n\ninterface UpdateLineAbsPositionArgs {\n    line: ConnectedLineItem;\n    dir: LineDirection;\n    offset: Offset;\n}\n\n/**\n * update line absolute position\n */\nexport const updateLineAbsPosition = ({\n    line,\n    dir,\n    offset,\n}: UpdateLineAbsPositionArgs): ConnectedLineItem => {\n    const { offsetX, offsetY } = offset;\n    const { position } = line;\n\n    if (!('x' in position[dir])) {\n        throw Error(\n            `line item ${line.item} does not have x value for its direction ${dir}`\n        );\n    }\n\n    if (!('y' in position[dir])) {\n        throw Error(\n            `line item ${line.item} does not have y value for its direction ${dir}`\n        );\n    }\n\n    const { x, y } = position[dir] as Coordinate;\n\n    return {\n        ...line,\n        position: {\n            ...position,\n            [dir]: {\n                x: x + offsetX,\n                y: y + offsetY,\n            },\n        },\n    };\n};\n\n/**\n *\n * @param {Object} from\n * @param {Object} to\n */\nexport const computeLineBoxPosition = (\n    from: Coordinate,\n    to: Coordinate\n): Coordinate => ({\n    x: Math.min(from.x, to.x),\n    y: Math.min(from.y, to.y),\n});\n\n/**\n *\n * @param {Object} from\n * @param {Object} to\n * @param {Object} box\n */\nexport const computeLineRelativePosition = (\n    from: Coordinate,\n    to: Coordinate,\n    box: Coordinate\n): {\n    from: {\n        x: number;\n        y: number;\n    };\n    to: {\n        x: number;\n        y: number;\n    };\n} => ({\n    from: {\n        x: from.x - box.x,\n        y: from.y - box.y,\n    },\n    to: {\n        x: to.x - box.x,\n        y: to.y - box.y,\n    },\n});\n\n/**\n * Return the bottom coordinate of the layout.\n *\n * @param  {Array} layout Layout array.\n * @return {Number}       Bottom coordinate.\n */\nexport const bottom = (layout: AbsoluteBlockItem[]): number => {\n    return layout.length > 0\n        ? Math.max(\n              ...layout.map(({ position }) => {\n                  return position.y + position.h;\n              })\n          )\n        : 1;\n};\n\n/**\n * Before moving item down, it will check if the movement will cause collisions\n * and move those items down before.\n * @method resolveCompactionCollision\n * @param {Array} layout\n * @param {Object} itemToMove current item which need to be moved to solve the collision\n * @param {Number} moveToCoord the destination coordination of y axis\n * @returns {Array} [newLayout, newItem]\n */\nexport const resolveCompactionCollision = (\n    layout: AbsoluteBlockItem[],\n    itemToMove: AbsoluteBlockItem,\n    moveToCoord: number\n): [AbsoluteBlockItem[], AbsoluteBlockItem] => {\n    let axisVal = itemToMove.position.y;\n    axisVal += 1;\n    let newLayout = cloneDeep(layout);\n    const itemIndex = newLayout.findIndex(\n        (layoutItem) => layoutItem.item === itemToMove.item\n    );\n    const newItem = cloneDeep(itemToMove);\n    newItem.position.y = axisVal;\n    // Go through each item we collide with.\n    // If there is a collision, we will move this collision down, otherwise set y = moveToCoord and return\n    for (let i = itemIndex + 1; i < layout.length; i += 1) {\n        // Optimization: we can break early if we know we're past this el\n        // We can do this b/c it's a sorted layout\n        if (newLayout[i].position.y > newItem.position.y + newItem.position.h) {\n            break;\n        }\n        if (collides(newItem, newLayout[i])) {\n            [newLayout, newLayout[i]] = resolveCompactionCollision(\n                layout,\n                layout[i],\n                moveToCoord + newItem.position.h\n            );\n        }\n    }\n\n    newItem.position.y = moveToCoord;\n    newLayout[itemIndex] = newItem;\n    return [newLayout, newItem];\n};\n\n/**\n * get all collisions given an item and current layout\n * @method getAllCollisions\n * @param {Array} layout\n * @param {Object} layoutItem\n * @returns {Array} sorted layout\n */\nexport const getAllCollisions = (\n    layout: AbsoluteBlockItem[],\n    layoutItem: AbsoluteBlockItem\n): AbsoluteBlockItem[] => {\n    return layout.filter((item) => collides(item, layoutItem));\n};\n\ninterface CloneBlockItemArgs {\n    id: string;\n    item: AbsoluteBlockItem;\n    offsetMultiplier: number;\n}\n\n/**\n * clone a block item\n * @param {Number} id\n * @param {Object} item\n * @param {Number} offsetMultiplier\n */\nexport const cloneBlockItem = ({\n    id,\n    item,\n    offsetMultiplier,\n}: CloneBlockItemArgs): AbsoluteBlockItem => {\n    const copiedPosition = item.position;\n    return {\n        ...item,\n        item: id,\n        position: {\n            x: copiedPosition.x + OFFSET_SIZE * offsetMultiplier,\n            y: copiedPosition.y + OFFSET_SIZE * offsetMultiplier,\n            w: copiedPosition.w,\n            h: copiedPosition.h,\n        },\n    };\n};\n\ninterface CloneLineArgs {\n    id: string;\n    item: ConnectedLineItem;\n    offsetMultiplier: number;\n}\n\n/**\n * clone an line, it assume the line is not connected\n * @param {Number} id\n * @param {Object} item\n * @param {Number} offsetMultiplier\n */\nexport const cloneLine = ({\n    id,\n    item,\n    offsetMultiplier,\n}: CloneLineArgs): ConnectedLineItem => {\n    const copiedPosition = item.position;\n    return {\n        ...item,\n        item: id,\n        position: {\n            from: {\n                x:\n                    (copiedPosition.from as Coordinate).x +\n                    OFFSET_SIZE * offsetMultiplier,\n                y:\n                    (copiedPosition.from as Coordinate).y +\n                    OFFSET_SIZE * offsetMultiplier,\n            },\n            to: {\n                x:\n                    (copiedPosition.to as Coordinate).x +\n                    OFFSET_SIZE * offsetMultiplier,\n                y:\n                    (copiedPosition.to as Coordinate).y +\n                    OFFSET_SIZE * offsetMultiplier,\n            },\n        },\n    };\n};\n\ninterface ShiftViewportOnZoomArgs {\n    scrollLeft: number;\n    scrollTop: number;\n    offsetWidth: number;\n    offsetHeight: number;\n    scaleRatio: number;\n}\n\n/**\n * Calculates new viewport position after a zoom event to keep the previous central point in the center of\n * the scaled canvas. See MR #2030 for algorithm details.\n * @param {Number} scrollLeft viewport left edge offset relative to canvas\n * @param {Number} scrollTop viewport top edge offset relative to canvas\n * @param {Number} offsetWidth viewport width\n * @param {Number} offsetHeight viewport height\n * @param {Number} scaleRatio new scale to old scale ratio\n * @returns {Object} object containing new scrollLeft and scrollTop values\n */\nexport const shiftViewportOnZoom = ({\n    scrollLeft,\n    scrollTop,\n    offsetWidth,\n    offsetHeight,\n    scaleRatio,\n}: ShiftViewportOnZoomArgs): {\n    scrollLeft: number;\n    scrollTop: number;\n} => {\n    const middleOffsetWidth = offsetWidth / 2;\n    const middleOffsetHeight = offsetHeight / 2;\n    return {\n        scrollLeft:\n            (scrollLeft + middleOffsetWidth) * scaleRatio - middleOffsetWidth,\n        scrollTop:\n            (scrollTop + middleOffsetHeight) * scaleRatio - middleOffsetHeight,\n    };\n};\n\n/**\n * return position relative to the canvas rect\n */\nexport const computeRelativePosition = (\n    e: {\n        clientX: number;\n        clientY: number;\n    },\n    canvasRef: unknown,\n    scale = 1\n): Coordinate => {\n    const pos = getClientPosition(e, scale);\n    const canvasDomNode = (canvasRef as MutableRefObject<Element> | undefined)\n        ?.current;\n    const rect = canvasDomNode?.getBoundingClientRect?.();\n    if (pos && rect) {\n        return {\n            x: pos.x - rect.left / scale,\n            y: pos.y - rect.top / scale,\n        };\n    }\n    return pos;\n};\n\n/**\n * Scales a GridLayout by stretching the width of each item by the scale factor\n * @param {AbsoluteBlockItem[]} items items to scale\n * @param {Number} scale how much to scale\n */\nexport const scaleGridLayoutStructureByWidth = ({\n    layout,\n    scale = 1,\n}: {\n    layout: GridLayoutStructure;\n    scale?: number;\n}): AbsoluteBlockItem[] => {\n    if (scale === 1) {\n        return layout;\n    }\n\n    // Compute the edges of the existing layout. Since we're scaling\n    // just the X and width we only care about vertical edges.\n    const edges = getAllEdges(layout);\n    const verticalEdges = sortBy(\n        edges.filter((edge) => edge.orientation === 'vertical'),\n        ['edgeStart.x']\n    );\n\n    // Scale the vertical edges and than align the\n    // left and right items to the scaled edge position\n    const newLayout: AbsoluteBlockItem[] = [];\n    verticalEdges.forEach((edge) => {\n        const {\n            visualizations,\n            edgeStart: { x },\n        } = edge;\n        const scaledEdgeX = Math.round(x * scale);\n        const left = visualizations.filter((viz) => viz.position.x < x);\n        const right = visualizations.filter((viz) => viz.position.x >= x);\n\n        // Update the Width of the layout items using the difference between the\n        // newly scaled edge and the existing x\n        left.forEach((layoutItem) => {\n            const newLayoutItem = newLayout.find(\n                ({ item: id }) => layoutItem.item === id\n            );\n\n            if (newLayoutItem) {\n                newLayoutItem.position.w =\n                    scaledEdgeX - newLayoutItem.position.x;\n            }\n        });\n\n        // Since we walk the edges from the left to the right we\n        // ALWAYS have to create the new layout item here but won't\n        // ever need to update it.\n        right.forEach((layoutItem) => {\n            newLayout.push({\n                ...layoutItem,\n                position: {\n                    ...layoutItem.position,\n                    x: scaledEdgeX,\n                },\n            });\n        });\n    });\n\n    return newLayout;\n};\n", "import { useLayoutEffect, useRef } from 'react';\nimport {\n    useCanvasRef,\n    useFeatureFlags,\n    usePrevious,\n    type LayoutZoomApi,\n} from '@splunk/dashboard-context';\nimport type { Coordinate } from '@splunk/dashboard-types';\nimport { shiftViewportOnZoom } from '../../utils/layoutUtils';\n\ninterface UseCanvasZoomCenterArgs\n    extends Pick<LayoutZoomApi, 'fitToWidth' | 'scale'> {\n    layoutId: string;\n}\n\nexport const useCanvasZoomCenter = ({\n    layoutId,\n    scale,\n    fitToWidth,\n}: UseCanvasZoomCenterArgs) => {\n    const { enableZoomCenter } = useFeatureFlags();\n\n    const canvasRef = useCanvasRef(layoutId);\n\n    const previousScale = usePrevious(scale);\n    const savedScroll = useRef<Coordinate | null>(null);\n\n    // We need to record the scroll position right before next DOM update,\n    // so that we can restore the scroll position later.\n    // Refer to the next useEffect() for the logic of restoring scroll position.\n    // Reference to the original implementation of this logic:\n    // https://cd.splunkdev.com/devplat/dashboard-framework/-/merge_requests/2356\n    if (\n        previousScale != null &&\n        previousScale >= 1 &&\n        scale < 1 &&\n        enableZoomCenter\n    ) {\n        const previousLayout = canvasRef.current?.parentElement;\n        if (previousLayout) {\n            savedScroll.current = {\n                x: previousLayout.scrollLeft + previousLayout.offsetWidth / 2,\n                y: previousLayout.scrollTop + previousLayout.offsetHeight / 2,\n            };\n        }\n    }\n\n    // center zoom\n    useLayoutEffect(() => {\n        if (fitToWidth || previousScale == null || previousScale === scale) {\n            return;\n        }\n\n        const layout = canvasRef.current?.parentElement;\n        if (!layout) {\n            return;\n        }\n\n        const { offsetWidth, offsetHeight, scrollTop, scrollLeft } = layout;\n\n        /* scale changed from scale = 0.25 or 0.5 to scale = 1, 1.5 or 2.0 then the scroll position is restored\n         * scale changed from scale >= 1 to scale = 0.5 or 0.25 then the scroll position is saved\n         * savedScroll.x and SavedScroll.y saves the horizontal and vertical scroll position\n         * The scroll position is calculated based on taking half of offsetWidth and offsetHeight\n         */\n\n        if (\n            previousScale < 1 &&\n            scale > 1 &&\n            savedScroll.current?.x != null &&\n            savedScroll.current?.y != null &&\n            enableZoomCenter\n        ) {\n            layout.scrollLeft = savedScroll.current.x - layout.offsetWidth / 2;\n            layout.scrollTop = savedScroll.current.y - layout.offsetHeight / 2;\n        } else {\n            const scaleRatio = scale / previousScale;\n            const newScroll = shiftViewportOnZoom({\n                offsetWidth,\n                offsetHeight,\n                scrollTop,\n                scrollLeft,\n                scaleRatio,\n            });\n            layout.scrollLeft = newScroll.scrollLeft;\n            layout.scrollTop = newScroll.scrollTop;\n        }\n    }, [canvasRef, enableZoomCenter, fitToWidth, previousScale, scale]);\n};\n", "import { useCallback, useEffect } from 'react';\nimport { useCanvasRef, type LayoutZoomApi } from '@splunk/dashboard-context';\nimport type { AbsoluteLayoutOptions } from '@splunk/dashboard-types';\n\nexport interface UseScaleOnDisplayChangeArgs\n    extends Pick<LayoutZoomApi, 'setScale' | 'setFitToWidth'> {\n    display: AbsoluteLayoutOptions['display'];\n    layoutId: string;\n}\n\nexport const useScaleOnDisplayChange = ({\n    display,\n    layoutId,\n    setFitToWidth,\n    setScale,\n}: UseScaleOnDisplayChangeArgs) => {\n    const canvasRef = useCanvasRef(layoutId);\n\n    const setFitToWidthAndScrollToTopLeft = useCallback(\n        (maxScale?: number | false) => {\n            setFitToWidth(maxScale);\n\n            const layoutEl = canvasRef.current?.parentElement;\n            if (layoutEl) {\n                layoutEl.scrollTop = 0;\n                layoutEl.scrollLeft = 0;\n            }\n        },\n        [canvasRef, setFitToWidth]\n    );\n\n    // apply display mode\n    useEffect(() => {\n        if (display === 'fit-to-width' || display === 'auto-scale') {\n            setFitToWidthAndScrollToTopLeft();\n        } else if (display === 'actual-size') {\n            setScale(1);\n        } else {\n            setFitToWidthAndScrollToTopLeft(1);\n        }\n    }, [display, setFitToWidthAndScrollToTopLeft, setScale]);\n};\n", "import { useEffect } from 'react';\nimport type { LayoutZoomApi } from '@splunk/dashboard-context';\nimport { getScrollbarWidth } from '@splunk/dashboard-utils';\nimport { computeScaleToFit } from '../../utils/layoutUtils';\n\nexport interface UseScaleToFitArgs\n    extends Pick<LayoutZoomApi, 'fitToWidth' | 'getZoomObserver'> {\n    width: number;\n    height: number;\n    containerWidth: number;\n    containerHeight: number;\n}\n\n/** Auto-scale to fit width to container */\nexport const useScaleToFit = ({\n    width,\n    height,\n    containerWidth,\n    containerHeight,\n    fitToWidth,\n    getZoomObserver,\n}: UseScaleToFitArgs) => {\n    useEffect(() => {\n        if (!fitToWidth) {\n            return;\n        }\n\n        const scrollbarWidth = getScrollbarWidth();\n        const newScale = computeScaleToFit({\n            canvasWidth: width,\n            canvasHeight: height,\n            containerWidth,\n            containerHeight,\n            max: fitToWidth,\n            scrollbarWidth,\n        });\n\n        getZoomObserver().next(newScale);\n    }, [\n        width,\n        height,\n        containerWidth,\n        containerHeight,\n        fitToWidth,\n        getZoomObserver,\n    ]);\n};\n", "import { useRef } from 'react';\nimport { useCanvasRef, type LayoutZoomApi } from '@splunk/dashboard-context';\n\nexport const useScrollOnFitToWidth = ({\n    layoutId,\n    fitToWidth,\n}: {\n    layoutId: string;\n    fitToWidth: LayoutZoomApi['fitToWidth'];\n}) => {\n    const canvasRef = useCanvasRef(layoutId);\n\n    const prevFitToWidth = useRef(fitToWidth);\n    if (fitToWidth !== prevFitToWidth.current) {\n        prevFitToWidth.current = fitToWidth;\n\n        if (!fitToWidth) {\n            return;\n        }\n\n        if (!canvasRef.current?.parentElement) {\n            return;\n        }\n\n        canvasRef.current.parentElement.scrollLeft = 0;\n        canvasRef.current.parentElement.scrollTop = 0;\n    }\n};\n", "import { useKeyboardZoom, useLayoutZoomApi } from '@splunk/dashboard-context';\nimport type { AbsoluteLayoutOptions } from '@splunk/dashboard-types';\nimport { useCanvasZoomCenter } from './useCanvasZoomCenter';\nimport { useScaleOnDisplayChange } from './useScaleOnDisplayChange';\nimport { useScaleToFit } from './useScaleToFit';\nimport { useScrollOnFitToWidth } from './useScrollOnFitToWidth';\n\ninterface UseAbsoluteLayoutZoomArgs {\n    layoutId: string;\n    display: AbsoluteLayoutOptions['display'];\n    width: number;\n    height: number;\n    containerWidth: number;\n    containerHeight: number;\n}\n\nexport const useAbsoluteLayoutZoom = ({\n    display,\n    layoutId,\n    width,\n    height,\n    containerWidth,\n    containerHeight,\n}: UseAbsoluteLayoutZoomArgs) => {\n    const { fitToWidth, scale, getZoomObserver, setFitToWidth, setScale } =\n        useLayoutZoomApi({ layoutId });\n\n    useKeyboardZoom({ layoutId });\n\n    useScrollOnFitToWidth({ layoutId, fitToWidth });\n\n    useScaleToFit({\n        width,\n        height,\n        containerWidth,\n        containerHeight,\n        fitToWidth,\n        getZoomObserver,\n    });\n\n    useScaleOnDisplayChange({ display, layoutId, setFitToWidth, setScale });\n\n    useCanvasZoomCenter({ layoutId, scale, fitToWidth });\n\n    return scale;\n};\n", "import { useEffect, useState } from 'react';\nimport { useImageRegistry } from '@splunk/dashboard-context';\nimport { console } from '@splunk/dashboard-utils';\n\n// temp until the ImageRegistry is typed\ninterface ImageRegistry {\n    getByURL: (url: string) => Promise<{ dataURI: string }>;\n    isResourceURL: (imgSrc: string) => boolean;\n}\n\nexport const useBackgroundImage = (backgroundImageSrc?: string): string => {\n    const [imageSrc, setImageSrc] = useState('');\n    const imageRegistry = useImageRegistry();\n\n    /**\n     * Check whether backgroundImage src is a remote image url or stored in the image registry. Fetch if its the latter\n     * @param string backgroundImageSrc\n     */\n    const fetchBackgroundImage = async (\n        registry: ImageRegistry,\n        bgImageSrc: string\n    ) => {\n        try {\n            // use imageRegistry to fetch the image if it's there\n            if (registry) {\n                if (registry.isResourceURL(bgImageSrc)) {\n                    const imageObject = await registry.getByURL(bgImageSrc);\n                    setImageSrc(imageObject.dataURI);\n                } else {\n                    setImageSrc(bgImageSrc);\n                }\n            } else {\n                setImageSrc(bgImageSrc);\n            }\n        } catch (error: unknown) {\n            if (error instanceof Error) {\n                console.error(error.message);\n            } else {\n                console.error('An unknown error occurred');\n            }\n        }\n    };\n\n    useEffect(() => {\n        if (backgroundImageSrc) {\n            fetchBackgroundImage(\n                imageRegistry as ImageRegistry,\n                backgroundImageSrc\n            );\n        } else {\n            // Reset to the original state value\n            setImageSrc('');\n        }\n    }, [imageRegistry, backgroundImageSrc]);\n\n    return imageSrc;\n};\n", "import { useMemo } from 'react';\nimport type {\n    AbsoluteBlockItem,\n    AbsoluteLayoutStructure,\n    GridLayoutStructure,\n    RootInputsDefinition,\n    RootVisualizationsDefinition,\n} from '@splunk/dashboard-types';\nimport {\n    selectInputs,\n    selectMode,\n    selectVisualizations,\n    selectConditionResults,\n    useSelector,\n} from '@splunk/dashboard-state';\nimport { shouldHideItem } from '@splunk/dashboard-utils';\nimport { useBatchSubscribeToSearches } from '@splunk/dashboard-ui';\nimport { useFeatureFlags } from '@splunk/dashboard-context';\n\ntype LayoutStructure = AbsoluteLayoutStructure | GridLayoutStructure;\n\nexport type ReflowFn = (\n    initialStructure: LayoutStructure,\n    itemsToRemove: LayoutStructure\n) => LayoutStructure;\n\ntype UseLayoutShowHideFn = (\n    layoutStructure: LayoutStructure,\n    handleReflow?: ReflowFn\n) => LayoutStructure;\n\nconst getCondIds = (\n    allItems: RootVisualizationsDefinition | RootInputsDefinition | undefined\n): string[] =>\n    allItems === undefined\n        ? []\n        : Object.values(allItems).flatMap((itemDef) => {\n              const {\n                  conditions = [],\n                  showConditions = [],\n                  hideConditions = [],\n              } = itemDef.containerOptions?.visibility ?? {};\n\n              return [...conditions, ...showConditions, ...hideConditions];\n          });\n\nexport const useLayoutShowHide: UseLayoutShowHideFn = (\n    layoutStructure,\n    handleReflow\n) => {\n    const allVizs = useSelector(selectVisualizations);\n    const allInputs = useSelector(selectInputs);\n    const mode = useSelector(selectMode);\n\n    const allConditionIds = useMemo(\n        () => new Set([...getCondIds(allVizs), ...getCondIds(allInputs)]),\n        [allInputs, allVizs]\n    );\n    const conditionResults = useSelector((state) =>\n        selectConditionResults(state, Array.from(allConditionIds))\n    );\n\n    const subscriptions = useBatchSubscribeToSearches({\n        consumerId: '<layout>',\n    });\n\n    const { enableShowHide } = useFeatureFlags();\n\n    return useMemo(() => {\n        if (!enableShowHide || mode === 'edit') {\n            return layoutStructure;\n        }\n\n        const itemsToRemove: LayoutStructure = [];\n        const filteredStructure = layoutStructure.filter((item) => {\n            if (\n                shouldHideItem({\n                    itemType: item.type,\n                    definition: allVizs[item.item] ?? allInputs?.[item.item],\n                    searchData: subscriptions[item.item],\n                    conditionResults,\n                })\n            ) {\n                itemsToRemove.push(item as AbsoluteBlockItem);\n                return false;\n            }\n            return true;\n        });\n\n        return itemsToRemove.length && handleReflow\n            ? handleReflow(layoutStructure, itemsToRemove)\n            : filteredStructure;\n    }, [\n        enableShowHide,\n        mode,\n        layoutStructure,\n        handleReflow,\n        allVizs,\n        allInputs,\n        subscriptions,\n        conditionResults,\n    ]);\n};\n", "import type { MutableRefObject, Ref, MouseEvent } from 'react';\nimport type {\n    Coordinate,\n    SelectedItem,\n    StructureItemType,\n} from '@splunk/dashboard-types';\nimport {\n    EVENT_MOUSE_DOWN_ON_HANDLE,\n    EVENT_MOUSE_DOWN_ON_VIZ_WITH_HANDLE,\n    useEventCallback,\n    useEventListener,\n    type DragHandleEvent,\n} from '@splunk/dashboard-ui';\nimport { computeRelativePosition } from '../utils/layoutUtils';\n\nexport interface MouseDownWithHandleProps {\n    handleMouseDownOnItem: (event: MouseEvent, blockItem: SelectedItem) => void;\n    canvasRef: Ref<HTMLDivElement>;\n    scale?: number;\n    setStartPosition: (positions: Coordinate) => void;\n    movable: boolean;\n    isMovingRef: MutableRefObject<boolean>;\n}\n\nexport const useMouseDownWithHandleEventListeners = ({\n    handleMouseDownOnItem,\n    canvasRef,\n    scale,\n    setStartPosition,\n    movable,\n    isMovingRef,\n}: MouseDownWithHandleProps) => {\n    // The two handle functions regarding handle are literally the same as\n    // handleMouseDown above but split up by moving logic vs selecting logic\n    const handleMouseDownOnVizWithHandle = useEventCallback(\n        (e: DragHandleEvent) => {\n            const { vizId, initialEvent, type } = e.detail;\n            const pos = computeRelativePosition(initialEvent, canvasRef, scale);\n            // always track start position\n            setStartPosition(pos);\n\n            const block = {\n                id: vizId,\n                type: type as StructureItemType,\n            };\n\n            handleMouseDownOnItem(initialEvent, block);\n        }\n    );\n\n    const handleMouseDownOnHandle = useEventCallback((e: DragHandleEvent) => {\n        const { vizId, initialEvent, type } = e.detail;\n        const pos = computeRelativePosition(initialEvent, canvasRef, scale);\n        // always track start position\n        setStartPosition(pos);\n\n        const block = {\n            id: vizId,\n            type: type as StructureItemType,\n        };\n\n        // mouse down on an item, set it to selected and start moving.\n        handleMouseDownOnItem(initialEvent, block);\n\n        if (movable) {\n            // eslint-disable-next-line no-param-reassign\n            isMovingRef.current = true;\n        }\n    });\n\n    useEventListener({\n        eventName: EVENT_MOUSE_DOWN_ON_VIZ_WITH_HANDLE,\n        target: document,\n        listener:\n            handleMouseDownOnVizWithHandle as EventListenerOrEventListenerObject,\n    });\n\n    useEventListener({\n        eventName: EVENT_MOUSE_DOWN_ON_HANDLE,\n        target: document,\n        listener: handleMouseDownOnHandle as EventListenerOrEventListenerObject,\n    });\n};\n", "import React from 'react';\nimport styled from 'styled-components';\nimport { toPx } from '@splunk/dashboard-utils';\nimport { mixins } from '@splunk/themes';\nimport { getImageDimension, validateOpacity } from '../../utils/imageUtils';\nimport { useBackgroundImage } from '../../hooks';\nimport type { BackgroundImageProps } from '../../types';\n\n/**\n * logic for background image size css.\n * @param {BackgroundProps} props\n */\nconst toBackgroundImageSize = ({\n    src,\n    imageHeight,\n    imageWidth,\n    sizeType,\n}: BackgroundImageProps) => {\n    const { width: w, height: h } = getImageDimension(src ?? '');\n    if (imageWidth && imageHeight) {\n        return `${toPx(imageWidth)} ${toPx(imageHeight)}`;\n    }\n    if (imageWidth || imageHeight) {\n        return `${toPx(imageWidth ?? w)} ${toPx(imageHeight ?? h)}`;\n    }\n\n    return sizeType ?? 'contain';\n};\n\n/**\n * A layer that renders canvas with background color/image\n */\nconst BackgroundImageDiv = styled.div.attrs(() => ({\n    'data-test': 'background-image',\n}))<BackgroundImageProps & { src: string }>`\n    ${mixins.reset('inline-block')};\n    width: 100%;\n    height: 100%;\n    position: relative;\n    background-repeat: no-repeat;\n    background-image: ${(props) => `url(\"${props.src}\")`};\n    background-size: ${(props) => toBackgroundImageSize(props)};\n    background-position: ${(props) =>\n        `${toPx(props.imageX)} ${toPx(props.imageY)}`};\n    opacity: ${(prop) => validateOpacity(prop.opacity)};\n`;\n\nexport const BackgroundImage = ({ src, ...rest }: BackgroundImageProps) => {\n    const imageSrc = useBackgroundImage(src);\n    if (!imageSrc) {\n        return null;\n    }\n    return <BackgroundImageDiv {...rest} src={imageSrc} />;\n};\n", "import React from 'react';\nimport styled from 'styled-components';\nimport { variables } from '@splunk/themes';\n\n/**\n * A layer that renders border\n */\nconst Border = styled.div.attrs(() => ({\n    'data-test': 'canvas-border',\n}))`\n    position: absolute;\n    box-sizing: border-box;\n    border: 2px dashed ${variables.interactiveColorBorder};\n    left: 0px;\n    top: 0px;\n    right: 0px;\n    bottom: 0px;\n    width: 100%;\n    height: 100%;\n`;\n\nexport const CanvasBorder = ({\n    showBorder = false,\n}: {\n    showBorder: boolean;\n}) => {\n    if (!showBorder) {\n        return null;\n    }\n\n    return <Border />;\n};\n", "import React from 'react';\nimport styled from 'styled-components';\nimport { variables } from '@splunk/themes';\nimport { toPx } from '@splunk/dashboard-utils';\n\nconst GRID_LINE_OPACITY = 0.1;\n\ninterface GridLinesProps {\n    showGrid: boolean;\n    gridWidth: number;\n    gridHeight: number;\n    gridPadding: number;\n    gridLineWidth: number;\n    gridLineColor?: string;\n    gridLineOpacity?: number;\n}\n\nconst getGridLineColor = (props: Pick<GridLinesProps, 'gridLineColor'>) =>\n    props.gridLineColor ?? variables.contentColorMuted;\n\n/**\n * A layer that renders grid\n */\nconst GridLines = styled.div<Omit<GridLinesProps, 'showGrid'>>`\n    position: absolute;\n    box-sizing: border-box;\n    left: 0px;\n    top: 0px;\n    right: 0px;\n    bottom: 0px;\n    width: 100%;\n    height: 100%;\n    opacity: ${(prop) => prop.gridLineOpacity ?? GRID_LINE_OPACITY};\n    background-size: ${(prop) => prop.gridWidth + prop.gridLineWidth}px\n        ${(prop) => prop.gridHeight + prop.gridLineWidth}px;\n    background-image: repeating-linear-gradient(\n            0deg,\n            ${getGridLineColor},\n            ${getGridLineColor} ${(prop) => toPx(prop.gridLineWidth)},\n            transparent ${(prop) => prop.gridLineWidth}px,\n            transparent ${(prop) => prop.gridHeight + prop.gridLineWidth}px\n        ),\n        repeating-linear-gradient(\n            -90deg,\n            ${getGridLineColor},\n            ${getGridLineColor} ${(prop) => toPx(prop.gridLineWidth)},\n            transparent ${(prop) => prop.gridLineWidth}px,\n            transparent ${(prop) => prop.gridWidth + prop.gridLineWidth}px\n        );\n`;\n\nexport const CanvasGridlines = ({ showGrid, ...rest }: GridLinesProps) => {\n    if (!showGrid) {\n        return null;\n    }\n    return <GridLines {...rest} data-test=\"gridlines\" />;\n};\n", "import type { CSSProperties } from 'react';\nimport styled from 'styled-components';\nimport { mixins } from '@splunk/themes';\nimport { customThemeVariables } from '@splunk/dashboard-ui';\n\ninterface BackgroundProps {\n    height: number;\n    scale?: number;\n    bgColor?: string | null;\n}\n\nconst toScale = (scale?: number): CSSProperties =>\n    scale\n        ? {\n              transform: `scale(${scale})`,\n              transformOrigin: '0 0',\n              width: `${100 / scale}%`,\n          }\n        : {\n              width: '100%',\n          };\n\n/**\n * A layer that renders canvas with background color\n */\nexport const Background = styled.div.attrs((props: BackgroundProps) => ({\n    style: {\n        height: props.height,\n        ...toScale(props.scale),\n    },\n}))<BackgroundProps>`\n    ${mixins.reset('inline-block')};\n    position: relative;\n    background: ${(prop) =>\n        prop.bgColor ||\n        // NOTE: this needs to match packages/dashboard-editors/src/layouts/AbsoluteLayoutEditor.tsx\n        customThemeVariables.dashboardBackgroundColor};\n`;\n", "import React, { forwardRef } from 'react';\nimport styled from 'styled-components';\nimport { mixins } from '@splunk/themes';\nimport { sanitizeColor } from '@splunk/dashboard-ui';\nimport type { CanvasProps } from '../../types';\nimport { BackgroundImage } from './BackgroundImage';\nimport { CanvasBorder } from './CanvasBorder';\nimport { CanvasGridlines } from './CanvasGridlines';\nimport { Background } from './Background';\n\ninterface CanvasContainerProps {\n    width: number;\n    height: number;\n    userSelect: boolean;\n    showOverflowContent: boolean;\n}\n\nconst CanvasContainer = styled.div.attrs((props: CanvasContainerProps) => ({\n    style: { width: props.width, height: props.height },\n}))<CanvasContainerProps>`\n    ${mixins.reset('block')};\n    overflow: ${(prop) => (prop.showOverflowContent ? 'visible' : 'hidden')};\n    user-select: ${(prop) => (prop.userSelect ? 'text' : 'none')};\n    position: relative;\n`;\n\n/**\n * Canvas is a component that render background for a layout.\n * All visualizations will be displayed on top of a canvas\n */\nconst Canvas = (\n    {\n        width,\n        height,\n        scale,\n        backgroundColor: unsanitizedBgColor = '',\n        backgroundImageSrc,\n        backgroundImageSizeType,\n        backgroundImageWidth,\n        backgroundImageHeight,\n        backgroundImagePositionX,\n        backgroundImagePositionY,\n        backgroundImageOpacity,\n        gridLineOpacity,\n        children,\n        showOverflowContent = false,\n        userSelect = false,\n        showGrid = false,\n        gridPadding = 0,\n        gridLineWidth = 1,\n        gridLineColor,\n        gridWidth = 9,\n        gridHeight = 9,\n        showBorder = false,\n        cssScaling = true,\n        ...others\n    }: CanvasProps,\n    canvasRef: React.Ref<HTMLDivElement>\n): JSX.Element => {\n    const containerWidth = scale != null ? width * scale : width;\n    const containerHeight =\n        scale != null && cssScaling ? height * scale : height;\n    const backgroundColor = sanitizeColor(unsanitizedBgColor);\n\n    return (\n        <CanvasContainer\n            data-test=\"canvas-container\"\n            data-width={containerWidth}\n            data-height={containerHeight}\n            width={cssScaling ? containerWidth : width}\n            height={containerHeight}\n            showOverflowContent={showOverflowContent}\n            userSelect={userSelect}\n            ref={canvasRef}\n            {...others}\n        >\n            <Background\n                data-test=\"canvas\"\n                data-width={width}\n                data-height={height}\n                data-scale={scale}\n                height={height}\n                scale={cssScaling ? scale : undefined}\n                bgColor={backgroundColor}\n            >\n                <BackgroundImage\n                    src={backgroundImageSrc}\n                    sizeType={backgroundImageSizeType}\n                    imageWidth={backgroundImageWidth}\n                    imageHeight={backgroundImageHeight}\n                    imageX={backgroundImagePositionX}\n                    imageY={backgroundImagePositionY}\n                    opacity={backgroundImageOpacity}\n                />\n                <CanvasBorder showBorder={showBorder} />\n                <CanvasGridlines\n                    showGrid={showGrid}\n                    gridLineOpacity={gridLineOpacity}\n                    gridPadding={gridPadding}\n                    gridLineWidth={gridLineWidth}\n                    gridLineColor={gridLineColor}\n                    gridWidth={gridWidth}\n                    gridHeight={gridHeight}\n                />\n                {children}\n            </Background>\n        </CanvasContainer>\n    );\n};\n\nexport default forwardRef(Canvas);\n", "\nimport * as defaultImport from \"prop-types\";\nexport * from \"prop-types\";\nexport default ('default' in defaultImport ? defaultImport.default : defaultImport);\n", "import React from 'react';\nimport T from 'prop-types';\nimport styled from 'styled-components';\nimport { mixins, variables } from '@splunk/themes';\n\nconst SelectDiv = styled.div.attrs(({ x, y, w, h }) => ({\n    style: {\n        width: w,\n        height: h,\n        transform: `translate(${x}px, ${y}px)`,\n    },\n}))`\n    ${mixins.reset('block')};\n    position: absolute;\n    background: transparent;\n    // the next line is important to avoid blocking the drilldowns, and it allows to select text from visualizations\n    pointer-events: none;\n    border: 1px solid ${variables.focusColor};\n    z-index: 1000;\n`;\n\nconst Wrapper = styled.div`\n    ${mixins.reset('block')};\n    background: transparent;\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n`;\n\nconst SelectBox = ({ start, end }) => (\n    <Wrapper>\n        <SelectDiv\n            w={Math.abs(start.x - end.x)}\n            h={Math.abs(start.y - end.y)}\n            x={Math.min(start.x, end.x)}\n            y={Math.min(start.y, end.y)}\n        />\n    </Wrapper>\n);\n\nSelectBox.propTypes = {\n    /**\n     * starting position\n     */\n    start: T.shape({\n        x: T.number,\n        y: T.number,\n    }),\n    /**\n     * end position\n     */\n    end: T.shape({\n        x: T.number,\n        y: T.number,\n    }),\n};\n\nexport default SelectBox;\n", "import type { Ref, RefObject } from 'react';\n\nexport const findStatusIcon = <TElement extends Element>({\n    canvasRef,\n    id,\n}: {\n    canvasRef?: Ref<TElement>;\n    id: string;\n}): HTMLElement | null => {\n    const canvas = (canvasRef as RefObject<TElement>)?.current;\n    if (!canvas) {\n        return null;\n    }\n\n    // TODO: if blocks are responsible for their own selection then canvas\n    // implementations no longer have to query the tree by test-id attributes...\n    return canvas.querySelector(\n        `[data-id=\"${id}\"] [data-test=\"simple-status-icon-container\"]`\n    );\n};\n", "import React, {\n    forwardRef,\n    type Ref,\n    useCallback,\n    useState,\n    type MouseEvent,\n    useMemo,\n    useEffect,\n    useRef,\n} from 'react';\nimport { last, uniqBy } from 'lodash';\nimport { useMouseEventsContext } from '@splunk/dashboard-context';\nimport { useEventCallback } from '@splunk/dashboard-ui';\nimport { isMac, noop } from '@splunk/dashboard-utils';\nimport type {\n    AbsoluteBlockItem,\n    Coordinate,\n    SelectedItem,\n    StructureItemType,\n} from '@splunk/dashboard-types';\nimport { blockItemMoving, useDispatch } from '@splunk/dashboard-state';\nimport Canvas from './Canvas';\nimport SelectBox from './SelectBox';\nimport { useMouseDownWithHandleEventListeners } from '../hooks';\nimport { findStatusIcon } from '../utils/findStatusIcon';\nimport {\n    getOffset,\n    considerMoved,\n    computeRelativePosition,\n    findTopBlockItemByPosition,\n    positionsToBoundary,\n    filterBlockItemsByBoundary,\n} from '../utils/layoutUtils';\nimport type { CanvasProps, Offset } from '../types';\n\ninterface AbsoluteCanvasState {\n    startPosition: Coordinate | null;\n    currentPosition: Coordinate | null;\n    isMoving: boolean;\n    isSelecting: boolean;\n}\n\n/**\n * default internal state\n */\nconst defaultState: AbsoluteCanvasState = {\n    startPosition: null,\n    currentPosition: null,\n    isMoving: false,\n    isSelecting: false,\n};\n\nexport interface Props extends CanvasProps {\n    initialState?: AbsoluteCanvasState;\n    movable?: boolean;\n    allowMultiselect: boolean;\n    selectedLayoutItems?: SelectedItem[];\n    blockItems: AbsoluteBlockItem[];\n    onItemSelected: (e: MouseEvent, items: SelectedItem[]) => void;\n    onItemMove?: (e: MouseEvent, offset: Offset) => void;\n    onItemMoved?: (e: MouseEvent, offset: Offset) => void;\n    children: JSX.Element | JSX.Element[];\n}\n\nconst DEFAULT_SELECTED_LAYOUT_ITEMS: SelectedItem[] = [];\n\nconst AbsoluteCanvas = (\n    props: Props & { canvasRef: Ref<HTMLDivElement> }\n): JSX.Element => {\n    const {\n        scale,\n        children,\n        canvasRef,\n        blockItems,\n        onItemMove = noop,\n        onItemMoved = noop,\n        onItemSelected,\n        movable = false,\n        allowMultiselect,\n        selectedLayoutItems = DEFAULT_SELECTED_LAYOUT_ITEMS,\n        initialState = defaultState,\n        onMouseDownCapture,\n        onMouseUpCapture,\n        ...canvasProps\n    } = props;\n\n    const dispatch = useDispatch();\n\n    // State management\n    const startPositionRef = useRef<Coordinate | null>(\n        initialState.startPosition\n    );\n\n    const [currentBoundary, setCurrentBoundary] = useState(() => ({\n        start: initialState.currentPosition,\n        end: initialState.currentPosition,\n    }));\n    const [isSelecting, setIsSelecting] = useState(initialState.isSelecting);\n    // a ref to track whether items are moving without triggering any effects\n    const isMovingRef = useRef(false);\n    const { isMouseDownOnItemWithHandle, setIsMouseDownOnItemWithHandle } =\n        useMouseEventsContext();\n    const isMetaKeyUsed = useRef(false);\n    const isSelectedWithMetaKey = useRef(false);\n    const isMacOS = isMac();\n\n    const resetState = useCallback(() => {\n        startPositionRef.current = defaultState.startPosition;\n        setCurrentBoundary({\n            start: defaultState.currentPosition,\n            end: defaultState.currentPosition,\n        });\n        setIsSelecting(defaultState.isSelecting);\n        isMovingRef.current = false;\n        isMetaKeyUsed.current = false;\n        isSelectedWithMetaKey.current = false;\n    }, []);\n\n    useEffect(() => {\n        // need ref here to avoid including `isMoving` state and thus\n        //  triggering the useEffect when the isMoving state updates\n        if (isMovingRef.current && blockItems) {\n            dispatch(blockItemMoving());\n        }\n\n        // IMPORTANT: we need blockItems as a hook dependency since we only\n        //  want to end measurement when an update was caused by blockItems changing\n    }, [blockItems, dispatch]);\n\n    const handleItemSelected = useCallback(\n        (e: MouseEvent, items: SelectedItem[] = []) => {\n            if (\n                items.some(\n                    ({ id, type }) =>\n                        type === 'input' &&\n                        findStatusIcon({ canvasRef, id })?.contains(\n                            e.target as Element\n                        )\n                )\n            ) {\n                // don't select anything if the click was in a status icon\n                return;\n            }\n\n            if ((isMacOS && e.metaKey) || (!isMacOS && e.ctrlKey)) {\n                // Only allow block and input types to be selected with meta+click\n                const selectedItems = selectedLayoutItems.filter(\n                    ({ type }: SelectedItem) =>\n                        type === 'block' || type === 'input'\n                );\n                isSelectedWithMetaKey.current = true;\n                onItemSelected(e, uniqBy([...selectedItems, ...items], 'id'));\n            } else {\n                onItemSelected(e, items);\n            }\n        },\n        [canvasRef, selectedLayoutItems, onItemSelected, isMacOS]\n    );\n\n    const handleMouseDownOnItem = useCallback(\n        (event: MouseEvent, blockItem: SelectedItem) => {\n            if ((isMacOS && event.metaKey) || (!isMacOS && event.ctrlKey)) {\n                isMetaKeyUsed.current = true;\n            }\n\n            const { id, type = 'block' } = blockItem;\n\n            // mouse down on an item, set it to selected and start moving.\n            // when clicking, don't select the block item if it's already selected\n            if (\n                selectedLayoutItems.find(\n                    ({ id: selectedId }) => selectedId === id\n                )\n            ) {\n                return;\n            }\n\n            handleItemSelected(event, [{ id, type }]);\n        },\n        [handleItemSelected, selectedLayoutItems, isMacOS]\n    );\n\n    // Update current position and trigger onItemMove\n    const handleMouseMove = useEventCallback((e) => {\n        if (!startPositionRef.current) {\n            return;\n        }\n\n        const newPosition = computeRelativePosition(e, canvasRef, scale);\n\n        const offset = getOffset(newPosition, startPositionRef.current);\n        if (isMovingRef.current && considerMoved(offset)) {\n            // this prevents the top visualization from receiving the event when the\n            // viz that's being moved is underneath\n            e.stopImmediatePropagation();\n            e.preventDefault();\n            onItemMove(e, offset);\n        }\n\n        setCurrentBoundary({\n            start: startPositionRef.current,\n            end: newPosition,\n        });\n    });\n\n    const handleMouseUpWithMetaKey = useCallback(\n        (event: React.MouseEvent, item?: AbsoluteBlockItem) => {\n            if (!item) {\n                return;\n            }\n\n            const { item: itemId } = item;\n            if (\n                itemId &&\n                isMetaKeyUsed.current &&\n                !isSelectedWithMetaKey.current\n            ) {\n                const selectedItems = selectedLayoutItems.filter(\n                    ({ type }: SelectedItem) =>\n                        type === 'block' || type === 'input'\n                );\n\n                const alreadySelected = selectedItems.some(\n                    (element) => element.id === itemId\n                );\n                if (alreadySelected) {\n                    const removedAlreadySelected = selectedItems.filter(\n                        (element) => element.id !== itemId\n                    );\n\n                    onItemSelected(event, removedAlreadySelected);\n                } else {\n                    // if we're mousing up on an item that is not selected, select it\n                    handleItemSelected(event, [\n                        { id: itemId, type: item?.type ?? 'block' },\n                    ]);\n                }\n            }\n        },\n        [handleItemSelected, onItemSelected, selectedLayoutItems]\n    );\n\n    // If moving an item we'll trigger onItemMoved otherwise we select the items within the boundary\n    const handleMouseUp = useEventCallback((e) => {\n        if (!startPositionRef.current) {\n            return;\n        }\n\n        e.preventDefault();\n\n        const curPosition = computeRelativePosition(e, canvasRef, scale);\n        const offset = getOffset(curPosition, startPositionRef.current);\n        const isMoved = considerMoved(offset);\n\n        if (isMovingRef.current && isMoved) {\n            isMovingRef.current = false;\n            onItemMoved(e, offset);\n        } else if (\n            allowMultiselect &&\n            !findTopBlockItemByPosition(blockItems, startPositionRef.current)\n        ) {\n            // if the mouse is moved between mousedown and mouseup, then we should find all the items covered by the select box\n            const boundary = positionsToBoundary(\n                startPositionRef.current,\n                curPosition\n            );\n            const selectedBlocks = filterBlockItemsByBoundary(\n                blockItems,\n                boundary\n            ).map(\n                ({ item, type = 'block' }): SelectedItem => ({\n                    id: item,\n                    type,\n                })\n            );\n\n            // Just select the top item if single clicking a stacked viz\n            let selectedBlockItems: SelectedItem[] = [];\n            if (!isMoved && selectedBlocks.length) {\n                selectedBlockItems.push(last(selectedBlocks) as SelectedItem);\n            } else {\n                selectedBlockItems = selectedBlocks;\n            }\n\n            // it could be an unselect or multiselect operation in edit mode. This\n            // will not happen in view mode because isSelecting = true occurs when\n            // allowMultiselect = true (mode-specific prop only set during edit)\n            handleItemSelected(e, selectedBlockItems);\n        } else {\n            // we're not moving nor selecting. There's three possibilities:\n            // (1) We have multiple items selected and we want to deselect all except for the item we're clicking\n            // (2) We have one item selected that is underneath the top most block, and we want to select the top most block on mouse up\n            // (3) We're in view mode and clicked the canvas, so we want to deselect any currently-selected item(s)\n            // (4) We deselect with meta key pressed\n            const item = findTopBlockItemByPosition(blockItems, curPosition);\n\n            const { item: itemId, type = 'block' } = item ?? {};\n\n            if (isMetaKeyUsed.current) {\n                handleMouseUpWithMetaKey(e, item);\n            } else if (\n                itemId &&\n                !(\n                    selectedLayoutItems.length === 1 &&\n                    selectedLayoutItems[0].id === itemId\n                ) &&\n                !isMoved &&\n                !isMetaKeyUsed.current\n            ) {\n                handleItemSelected(e, [{ id: itemId, type }]);\n            } else if (\n                !itemId &&\n                !findTopBlockItemByPosition(\n                    blockItems,\n                    startPositionRef.current\n                )\n            ) {\n                // The click began and ended on the canvas. Deselect everything.\n                handleItemSelected(e, []);\n            }\n        }\n\n        resetState();\n    });\n\n    // Handle starting the select box or selecting and moving and item\n    const handleMouseDown = useEventCallback(\n        (e: React.MouseEvent, selectedBlockItem?) => {\n            // skip handling the event if the click is on a viz with a drag handle. Avoid `stopPropagation` in order to let\n            //   other listeners continue to work (ie. dropdown close behavior)\n\n            if (isMouseDownOnItemWithHandle?.current) {\n                setIsMouseDownOnItemWithHandle(false);\n                return;\n            }\n\n            const pos = computeRelativePosition(e, canvasRef, scale);\n            // always track start position\n            startPositionRef.current = pos;\n\n            const block =\n                selectedBlockItem ??\n                findTopBlockItemByPosition(blockItems, pos);\n\n            if (!block) {\n                // if we didn't click on a viz, start selection\n                if (allowMultiselect) {\n                    setIsSelecting(true);\n                }\n                return;\n            }\n\n            const { item, type } = block;\n\n            // mouse down on an item, set it to selected and start moving.\n            handleMouseDownOnItem(e, {\n                id: item,\n                type: type as StructureItemType,\n            });\n\n            if (movable) {\n                isMovingRef.current = true;\n            }\n        }\n    );\n\n    const handleMouseDownCapture = useEventCallback((e) => {\n        // parent onMouseDownCapture\n        onMouseDownCapture?.(e);\n\n        const pos = computeRelativePosition(e, canvasRef, scale);\n        const selectedBlockItems = blockItems.filter((item) =>\n            selectedLayoutItems.some(\n                (selectedItem) => selectedItem.id === item.item\n            )\n        );\n\n        const topSelectedBlock = findTopBlockItemByPosition(\n            selectedBlockItems,\n            pos\n        );\n        const topBlock = findTopBlockItemByPosition(blockItems, pos);\n\n        // If the top selected block is underneath the top block, then mouse down\n        // as if the selected block was on top\n        if (topSelectedBlock && topSelectedBlock !== topBlock) {\n            handleMouseDown(e, topSelectedBlock);\n            e.stopPropagation();\n            e.preventDefault();\n        }\n    });\n\n    // we bind mouse move and mouse up on global so user move mouse out of canvas will still work\n    useEffect(() => {\n        document.addEventListener('mousemove', handleMouseMove, true);\n        return () => {\n            document.removeEventListener('mousemove', handleMouseMove, true);\n        };\n    }, [handleMouseMove]);\n\n    useEffect(() => {\n        document.addEventListener('mouseup', handleMouseUp);\n        return () => {\n            document.removeEventListener('mouseup', handleMouseUp);\n        };\n    }, [handleMouseUp]);\n\n    const setStartPositionRef = useCallback((position: Coordinate) => {\n        startPositionRef.current = position;\n    }, []);\n\n    useMouseDownWithHandleEventListeners({\n        handleMouseDownOnItem,\n        canvasRef,\n        scale,\n        setStartPosition: setStartPositionRef,\n        movable,\n        isMovingRef,\n    });\n\n    const selectBox = useMemo(() => {\n        if (\n            allowMultiselect &&\n            isSelecting &&\n            currentBoundary.start &&\n            currentBoundary.end\n        ) {\n            return (\n                <SelectBox\n                    start={currentBoundary.start}\n                    end={currentBoundary.end}\n                />\n            );\n        }\n        return null;\n    }, [\n        allowMultiselect,\n        isSelecting,\n        currentBoundary.start,\n        currentBoundary.end,\n    ]);\n\n    return (\n        <Canvas\n            ref={canvasRef}\n            {...canvasProps}\n            scale={scale}\n            onMouseDown={handleMouseDown}\n            onContextMenu={resetState}\n            onMouseDownCapture={handleMouseDownCapture}\n            onMouseUpCapture={onMouseUpCapture}\n        >\n            {selectBox}\n            {children}\n        </Canvas>\n    );\n};\n\nexport default forwardRef((props: Props, ref: React.Ref<HTMLDivElement>) => {\n    return <AbsoluteCanvas canvasRef={ref} {...props} />;\n});\n", "import React from 'react';\nimport styled from 'styled-components';\nimport T from 'prop-types';\n\nconst AbsoluteDiv = styled.div.attrs(({ x, y, w, h }) => ({\n    style: {\n        width: w,\n        height: h,\n        top: `${y}px`,\n        left: `${x}px`,\n    },\n}))`\n    display: block;\n    position: absolute;\n    background: transparent;\n`;\n\n/**\n * Absolute positioned item\n * @param {*} param0\n */\nconst AbsoluteItem = ({\n    itemId,\n    type = 'block',\n    x,\n    y,\n    w,\n    h,\n    renderLayoutItem,\n}) => (\n    <AbsoluteDiv\n        x={x}\n        y={y}\n        w={w}\n        h={h}\n        data-test=\"absolute-item\"\n        data-x={x}\n        data-y={y}\n        data-w={w}\n        data-h={h}\n    >\n        {renderLayoutItem(\n            itemId,\n            {\n                width: w,\n                height: h,\n            },\n            type\n        )}\n    </AbsoluteDiv>\n);\n\nAbsoluteItem.propTypes = {\n    itemId: T.string.isRequired,\n    type: T.string,\n    x: T.number.isRequired,\n    y: T.number.isRequired,\n    w: T.number.isRequired,\n    h: T.number.isRequired,\n    renderLayoutItem: T.func.isRequired,\n};\n\nexport default AbsoluteItem;\n", "import styled from 'styled-components';\n\nexport interface ActionMenuPortalProps {\n    x: number;\n    y: number;\n    w: number;\n    h: number;\n    zIndex?: number;\n}\n\nconst ActionMenuPortal = styled.div.attrs<ActionMenuPortalProps>((props) => ({\n    'data-test': 'action-menu-portal',\n    style: {\n        width: props.w,\n        top: props.y + props.h,\n        left: props.x,\n    },\n}))<ActionMenuPortalProps>`\n    display: block;\n    position: absolute;\n    background: transparent;\n    pointer-events: all;\n    box-sizing: border-box;\n    height: 0px;\n    z-index: ${(props) => props.zIndex};\n`;\n\nexport default ActionMenuPortal;\n", "import React, { useCallback } from 'react';\nimport styled from 'styled-components';\nimport { pickVariant, variables } from '@splunk/themes';\nimport { customThemeVariables } from '@splunk/dashboard-ui';\nimport type { AbsolutePosition } from '@splunk/dashboard-types';\nimport type { EdgeItem, EdgeAppearance } from '../types';\n\ninterface EdgeWrapperProps extends AbsolutePosition {\n    orientation: EdgeItem['orientation'];\n    appearance: EdgeAppearance;\n}\n\nexport const EdgeWrapper = styled.div.attrs<EdgeWrapperProps>(\n    ({ x, y, w, h }) => {\n        return {\n            style: {\n                width: w,\n                height: h,\n                transform: `translate(${x}px, ${y}px)`,\n            },\n        };\n    }\n)`\n    display: block;\n    position: absolute;\n    background: transparent;\n    box-sizing: border-box;\n\n    &:hover {\n        cursor: ${(props) =>\n            props.orientation === 'vertical' ? 'col-resize' : 'row-resize'};\n        background: ${pickVariant<EdgeWrapperProps>('appearance', {\n            invalid: variables.notificationColorNegative,\n            dropTarget: customThemeVariables.validDropTargetBackgroundColor,\n            normal: 'transparent',\n            hidden: 'transparent',\n        })};\n        border: ${pickVariant<EdgeWrapperProps>('appearance', {\n            invalid: `1px solid ${variables.severityColorAlert}`,\n            dropTarget: `1px solid ${customThemeVariables.validDropTargetBorderColor}`,\n            normal: 'none',\n            hidden: 'none',\n        })};\n        transition: background 0.2s ease-out;\n    }\n`;\n\ntype EdgeComponentProps = AbsolutePosition & { appearance: EdgeAppearance };\n\nexport const EdgeComponent = styled.div.attrs<EdgeComponentProps>(\n    ({ x, y, w, h }) => {\n        return {\n            style: {\n                width: w,\n                height: h,\n                transform: `translate(${x}px, ${y}px)`,\n            },\n        };\n    }\n)<EdgeComponentProps>`\n    display: block;\n    position: absolute;\n    opacity: 0.35;\n    pointer-events: none;\n    background-color: ${(props) =>\n        props.appearance === 'dropTarget'\n            ? customThemeVariables.validDropTargetBorderColor\n            : customThemeVariables.resizeHandleColor};\n    ${EdgeWrapper}:hover + & {\n        opacity: 0.7;\n    }\n`;\n\ninterface EdgeProps {\n    itemId: string;\n    x: number;\n    y: number;\n    w: number;\n    h: number;\n    orientation: EdgeItem['orientation'];\n    isCanvasEdge?: boolean;\n    padding?: number;\n    appearance: EdgeAppearance;\n    onMouseDown: (e: React.MouseEvent, { id }: { id: string }) => void;\n    'data-test-edge-position': string;\n}\n\nexport const Edge = ({\n    itemId,\n    x,\n    y,\n    h,\n    w,\n    orientation,\n    isCanvasEdge,\n    padding = 0,\n    appearance = 'normal',\n    onMouseDown,\n    'data-test-edge-position': edgePositionTestHook,\n}: EdgeProps): JSX.Element | null => {\n    const handleMouseDown = useCallback(\n        (e: React.MouseEvent) => {\n            e.preventDefault();\n            e.stopPropagation();\n            onMouseDown(e, { id: itemId });\n        },\n        [onMouseDown, itemId]\n    );\n\n    /**\n     * edges are not rendered if:\n     * 1. their appearance is hidden OR\n     * 2. edge is a canvas edge AND its appearance is not a dropTarget\n     * Exception to this case is the bottom canvas edge which is always visible. Other canvas edges (top, left, right) are visible only when a viz is moving\n     * TODO: Follow up with design to re-evaluate display condition for canvas edges as they are currently not discoverable\n     */\n    if (\n        appearance === 'hidden' ||\n        (isCanvasEdge &&\n            appearance !== 'dropTarget' &&\n            (orientation === 'vertical' || y + padding === 0))\n    ) {\n        return null;\n    }\n\n    const coord = { x, y, w, h };\n    const shift = padding / 2;\n\n    if (orientation === 'horizontal') {\n        coord.y += shift;\n        coord.h -= padding;\n    }\n\n    if (orientation === 'vertical') {\n        coord.x += shift;\n        coord.w -= padding;\n    }\n\n    return (\n        <>\n            <EdgeWrapper\n                x={x}\n                y={y}\n                w={w}\n                h={h}\n                orientation={orientation}\n                appearance={appearance}\n                onMouseDown={handleMouseDown}\n                data-test=\"edge\"\n                data-test-edge-position={edgePositionTestHook}\n            />\n            <EdgeComponent\n                x={coord.x}\n                y={coord.y}\n                w={coord.w}\n                h={coord.h}\n                appearance={appearance}\n            />\n        </>\n    );\n};\n", "\nimport * as defaultImport from \"@splunk/ui-utils/i18n\";\nexport * from \"@splunk/ui-utils/i18n\";\nexport default ('default' in defaultImport ? defaultImport.default : defaultImport);\n", "import React from 'react';\nimport styled from 'styled-components';\nimport { variables } from '@splunk/themes';\nimport { applyTranslucence } from '@splunk/dashboard-ui';\nimport { _ } from '@splunk/ui-utils/i18n';\n\nconst ErrorOverlay = styled.div`\n    position: absolute;\n    box-sizing: border-box;\n    top: 0;\n    left: 0;\n    height: 100%;\n    width: 100%;\n    pointer-events: none;\n    background-color: ${applyTranslucence(\n        variables.notificationColorNegativeWeak,\n        0.85\n    )};\n    color: ${variables.contentColorActive};\n    overflow: hidden;\n    padding: 8px;\n    z-index: 2;\n`;\n\nexport const MessageContainer = styled.div`\n    padding-top: 8px;\n`;\n\nconst OverlayTitle = styled.div`\n    font-weight: bold;\n`;\n\nexport const ErrorMessageOverlay = ({ messages }: { messages?: string[] }) => {\n    if (!Array.isArray(messages) || messages.length === 0) {\n        return null;\n    }\n    return (\n        <ErrorOverlay data-test=\"error-overlay\">\n            <OverlayTitle>{_('Layout Errors:')}</OverlayTitle>\n            {messages.map((message) => (\n                <MessageContainer\n                    data-test=\"error-overlay-message\"\n                    key={message}\n                >\n                    {message}\n                </MessageContainer>\n            ))}\n        </ErrorOverlay>\n    );\n};\n", "import React, {\n    useCallback,\n    type Ref,\n    forwardRef,\n    useEffect,\n    useRef,\n} from 'react';\nimport { uniqBy } from 'lodash';\nimport type {\n    Coordinate,\n    OnItemSelected,\n    SelectedItem,\n    StructureItemType,\n} from '@splunk/dashboard-types';\nimport {\n    useFeatureFlags,\n    useMouseEventsContext,\n} from '@splunk/dashboard-context';\nimport { useEventCallback, useMouseMoveHandler } from '@splunk/dashboard-ui';\nimport Canvas from './Canvas';\nimport type { GridCanvasState, GridCanvasProps } from '../types';\nimport {\n    getOffset,\n    considerMoved,\n    positionsToBoundary,\n    computeRelativePosition,\n    findTopBlockItemByPosition,\n    filterBlockItemsByBoundary,\n} from '../utils/layoutUtils';\nimport { findStatusIcon } from '../utils/findStatusIcon';\nimport { applyVizPadding } from '../utils/edgeUtils';\nimport { useMouseDownWithHandleEventListeners } from '../hooks';\n\nconst defaultState: GridCanvasState = {\n    startPosition: null,\n    isMoving: false,\n};\n\nconst DEFAULT_SELECTED_LAYOUT_ITEMS: SelectedItem[] = [];\nconst noop = () => undefined;\n\nexport type { GridCanvasProps } from '../types';\n\nconst GridCanvas = (\n    props: GridCanvasProps & { canvasRef: Ref<HTMLDivElement> }\n): JSX.Element => {\n    const {\n        movable = false,\n        selectable = false,\n        selectedLayoutItems = DEFAULT_SELECTED_LAYOUT_ITEMS,\n        panelPadding = 0,\n        scale = 1,\n        onItemMove = noop,\n        onItemMoved = noop,\n        onItemSelected,\n        children,\n        canvasRef,\n        blockItems,\n        ...canvasProps\n    } = props;\n\n    const { enableGridLayoutCssScaling } = useFeatureFlags();\n\n    const startPositionRef = useRef(defaultState.startPosition);\n    const isMovingRef = useRef(defaultState.isMoving);\n    const { isMouseDownOnItemWithHandle, setIsMouseDownOnItemWithHandle } =\n        useMouseEventsContext();\n\n    const resetState = useCallback(() => {\n        isMovingRef.current = defaultState.isMoving;\n        startPositionRef.current = defaultState.startPosition;\n    }, []);\n\n    const mouseScale = enableGridLayoutCssScaling ? scale : 1;\n\n    const handleItemSelected = useCallback<OnItemSelected>(\n        (e, itemIds = []) => {\n            if (\n                (itemIds as SelectedItem[]).some(\n                    ({ id, type }) =>\n                        type === 'input' &&\n                        findStatusIcon({ canvasRef, id })?.contains(\n                            e.target as Element\n                        )\n                )\n            ) {\n                // don't select anything if the click was in a status icon\n                return;\n            }\n\n            if ((e as React.KeyboardEvent).metaKey) {\n                // Do not allow selecting block item with meta+click\n                const selectedItems = selectedLayoutItems.filter(\n                    ({ type }) => type === 'block'\n                );\n                onItemSelected(e, uniqBy([...selectedItems, ...itemIds], 'id'));\n            } else {\n                onItemSelected(e, itemIds);\n            }\n        },\n        [canvasRef, selectedLayoutItems, onItemSelected]\n    );\n\n    const handleMouseDownOnItem = useCallback(\n        (event: React.MouseEvent, blockItem: SelectedItem) => {\n            const { id, type = 'block' } = blockItem;\n            // mouse down on an item, set it to selected and start moving.\n            if (\n                !selectedLayoutItems.find(\n                    ({ id: selectedId }) => selectedId === id\n                )\n            ) {\n                // select the block item right away if it's not selected.\n                handleItemSelected(event, [{ id, type }]);\n            }\n        },\n        [handleItemSelected, selectedLayoutItems]\n    );\n\n    // Track starting position of mouse down event and select blockItem if it's not selected\n    const handleMouseDown = useCallback<React.MouseEventHandler>(\n        (e) => {\n            // skip handling the event if the click is on a viz with a drag handle. Avoid `stopPropagation` in order to let\n            //   other listeners continue to work (ie. dropdown close behavior)\n            if (isMouseDownOnItemWithHandle?.current) {\n                setIsMouseDownOnItemWithHandle(false);\n                return;\n            }\n\n            const pos = computeRelativePosition(e, canvasRef, mouseScale);\n            const block = findTopBlockItemByPosition(\n                blockItems,\n                pos,\n                panelPadding\n            );\n            // always track start position\n            if (selectable) {\n                startPositionRef.current = pos;\n            }\n            if (block) {\n                // mouse down on an item, start moving.\n                handleMouseDownOnItem(e, {\n                    id: block.item,\n                    type: block.type as StructureItemType,\n                });\n                if (movable) {\n                    isMovingRef.current = true;\n                }\n            }\n        },\n        [\n            isMouseDownOnItemWithHandle,\n            canvasRef,\n            mouseScale,\n            blockItems,\n            panelPadding,\n            selectable,\n            setIsMouseDownOnItemWithHandle,\n            handleMouseDownOnItem,\n            movable,\n        ]\n    );\n\n    // Trigger onItemMove (callback) with move offset\n    const handleMouseMove = useEventCallback((e: MouseEvent) => {\n        if (startPositionRef.current) {\n            const currentPosition = computeRelativePosition(\n                e,\n                canvasRef,\n                mouseScale\n            );\n            if (currentPosition) {\n                const offset = getOffset(\n                    currentPosition,\n                    startPositionRef.current\n                );\n                if (isMovingRef.current && considerMoved(offset)) {\n                    e.preventDefault();\n                    onItemMove(e, { currentPosition });\n                }\n            }\n        }\n    });\n\n    // Trigger onItemMoved (callback) with final offset if an item was moved OR multiselect items within a boundary\n    const handleMouseUp = useEventCallback((e: MouseEvent) => {\n        if (startPositionRef.current) {\n            const currentPosition = computeRelativePosition(\n                e,\n                canvasRef,\n                mouseScale\n            );\n            if (currentPosition) {\n                // if will be either complete a move or a multi select\n                const offset = getOffset(\n                    currentPosition,\n                    startPositionRef.current\n                );\n                if (isMovingRef.current && considerMoved(offset)) {\n                    onItemMoved(e, offset);\n                } else {\n                    // todo: we shouldn't need to use absolute coordinates to figure out which item is clicked, given there's no overlapped visualizations in grid layout. Ideally, we should let the actual viz being clicked update the selectedItem state.\n                    let blocks = blockItems;\n                    if (panelPadding) {\n                        blocks = blocks.map((block) =>\n                            applyVizPadding({\n                                item: block,\n                                padding: panelPadding,\n                            })\n                        );\n                    }\n                    const boundary = positionsToBoundary(\n                        startPositionRef.current,\n                        currentPosition\n                    );\n                    const selectedBlocks = filterBlockItemsByBoundary(\n                        blocks,\n                        boundary\n                    ).map(({ item, type = 'block' }) => ({\n                        id: item,\n                        type,\n                    }));\n\n                    // select single item\n                    const topItem = selectedBlocks[selectedBlocks.length - 1];\n                    handleItemSelected(e, topItem ? [topItem] : []);\n                }\n                resetState();\n            }\n        }\n    });\n\n    const setStartPosition = useCallback((pos: Coordinate) => {\n        startPositionRef.current = pos;\n    }, []);\n\n    useMouseDownWithHandleEventListeners({\n        handleMouseDownOnItem,\n        canvasRef,\n        scale: mouseScale,\n        setStartPosition,\n        movable,\n        isMovingRef,\n    });\n\n    useEffect(() => {\n        document.addEventListener('mouseup', handleMouseUp);\n        return () => {\n            document.removeEventListener('mouseup', handleMouseUp);\n        };\n    }, [handleMouseUp]);\n\n    useMouseMoveHandler({ onMouseMove: handleMouseMove, isEnabled: movable });\n\n    return (\n        <Canvas\n            ref={canvasRef}\n            {...canvasProps}\n            scale={scale}\n            onMouseDown={handleMouseDown}\n            onContextMenu={resetState}\n            cssScaling={enableGridLayoutCssScaling}\n            showGrid={false}\n        >\n            {children}\n        </Canvas>\n    );\n};\n\nexport default forwardRef(\n    (props: GridCanvasProps, ref: React.Ref<HTMLDivElement>) => (\n        <GridCanvas canvasRef={ref} {...props} />\n    )\n);\n", "import React from 'react';\nimport styled from 'styled-components';\nimport T from 'prop-types';\nimport type { LayoutItemType, RenderLayoutItem } from '@splunk/dashboard-types';\n\ninterface GridDivProps {\n    id: string;\n}\n\nconst GridDiv = styled.div<GridDivProps>`\n    height: 100%;\n    width: 100%;\n    grid-row: ${(props) => props.id}-start / ${(props) => props.id}-end;\n    grid-column: ${(props) => props.id}-start / ${(props) => props.id}-end;\n    background: transparent;\n`;\n\ninterface GridItemProps {\n    /*\n     * The ID of the item being rendered.\n     */\n    itemId: string;\n    /*\n     * The type of the item being rendered.\n     */\n    type?: LayoutItemType;\n    /*\n     * A method to render the items in the layout structure.\n     */\n    renderLayoutItem: RenderLayoutItem;\n}\n\n/**\n * Item positioned on a grid.\n */\nconst GridItem = ({\n    itemId,\n    type = 'block',\n    renderLayoutItem,\n}: GridItemProps): JSX.Element => (\n    <GridDiv id={itemId} data-test=\"grid-item\">\n        {renderLayoutItem(itemId, { width: '100%', height: '100%' }, type)}\n    </GridDiv>\n);\n\nGridItem.propTypes = {\n    itemId: T.string.isRequired,\n    type: T.string,\n    renderLayoutItem: T.func.isRequired,\n};\n\nexport default GridItem;\n", "import React, { useMemo } from 'react';\nimport styled from 'styled-components';\nimport { variables } from '@splunk/themes';\nimport type { AbsolutePosition, Coordinate } from '@splunk/dashboard-types';\nimport { positionToStyle } from '../utils/layoutUtils';\n\ninterface PlaceholderProps {\n    position: AbsolutePosition;\n}\n\nexport const Placeholder = styled.div.attrs<PlaceholderProps>(\n    ({ position }) => ({\n        style: positionToStyle(position),\n    })\n)<PlaceholderProps>`\n    background-color: ${variables.interactiveColorOverlayDrag};\n    opacity: 0.75;\n    user-select: none;\n    position: absolute;\n    flex-direction: column;\n    top: 0;\n    left: 0;\n    cursor: move;\n`;\n\nexport const ItemDragPlaceholder = ({\n    position,\n    size = 128,\n}: {\n    position: Coordinate;\n    size?: number;\n}): JSX.Element => {\n    const placeHolderPosition = useMemo(() => {\n        return {\n            // update x and y to be the center of the placeholder\n            x: position.x - Math.round(size / 2),\n            y: position.y - Math.round(size / 2),\n            w: size,\n            h: size,\n        };\n    }, [position, size]);\n    return (\n        <Placeholder\n            data-test=\"item-drag-placeholder\"\n            position={placeHolderPosition}\n        />\n    );\n};\n", "import { _ } from '@splunk/ui-utils/i18n';\n\nexport const CLONE_LAYOUT_ITEMS_MSG_PANEL_TOO_SMALL = _(\n    'This panel is too small to be split into duplicates. Stretch or move the panel to make it bigger first.'\n);\nexport const EDGE_THICKNESS_PX = 4;\nexport const GRID_PADDING_PX = 1;\nexport const GRID_SIZE_PX = 10;\nexport const MIN_HEIGHT_PX = 64;\nexport const MIN_WIDTH_PX = 64;\nexport const SNAP_RANGE_PX = 8;\nexport const PLACEHOLDER_SIZE_PX = 128;\nexport const ITEM_DROP_TARGET_PX = 12;\nexport const VIZ_DEFAULT_HEIGHT_PX = 400;\nexport const VIZ_PREVIEW_DELAY_MS = 50;\nexport const EDGE_PREVIEW_DELAY_MS = 500;\n", "import React, { useMemo } from 'react';\nimport styled from 'styled-components';\nimport T from 'prop-types';\nimport { pickVariant, variables } from '@splunk/themes';\nimport { customThemeVariables } from '@splunk/dashboard-ui';\nimport { positionToStyle } from '../utils/layoutUtils';\nimport { ITEM_DROP_TARGET_PX } from '../GridLayoutConstants';\n\nexport const DropTarget = styled.div.attrs(({ position }) => ({\n    style: positionToStyle(position),\n}))`\n    background-color: ${pickVariant('validDropTarget', {\n        true: customThemeVariables.validDropTargetBackgroundColor,\n        false: variables.notificationColorNegative,\n    })};\n    border-width: '1px';\n    border-style: 'solid';\n    border-color: ${pickVariant('validDropTarget', {\n        true: customThemeVariables.validDropTargetBorderColor,\n        false: variables.severityColorAlert,\n    })};\n    user-select: none;\n    position: absolute;\n    pointer-events: none;\n`;\n\nexport const ItemDropTarget = ({ position, direction }) => {\n    const validDropTarget =\n        ((direction === 'e' || direction === 'w') && position.w >= 128) ||\n        ((direction === 'n' || direction === 's') && position.h >= 128);\n\n    const dropTargetPosition = useMemo(() => {\n        let updatedPosition = null;\n        switch (direction) {\n            case 'n':\n                updatedPosition = {\n                    ...position,\n                    h: ITEM_DROP_TARGET_PX,\n                };\n                break;\n            case 's':\n                updatedPosition = {\n                    ...position,\n                    y: position.y + position.h - ITEM_DROP_TARGET_PX,\n                    h: ITEM_DROP_TARGET_PX,\n                };\n                break;\n            case 'w':\n                updatedPosition = {\n                    ...position,\n                    w: ITEM_DROP_TARGET_PX,\n                };\n                break;\n            case 'e':\n                updatedPosition = {\n                    ...position,\n                    x: position.x + position.w - ITEM_DROP_TARGET_PX,\n                    w: ITEM_DROP_TARGET_PX,\n                };\n                break;\n            default:\n                updatedPosition = position;\n                break;\n        }\n        return updatedPosition;\n    }, [position, direction]);\n\n    // TO DO: currently with this if,\n    // we are only rendering the invalid drop target. Refactor file to only use invalid\n    if (validDropTarget) {\n        return null;\n    }\n\n    return (\n        <DropTarget\n            data-test=\"item-drop-target\"\n            position={dropTargetPosition}\n            validDropTarget={validDropTarget}\n        />\n    );\n};\n\nItemDropTarget.propTypes = {\n    position: T.shape({\n        x: T.number.isRequired,\n        y: T.number.isRequired,\n        w: T.number.isRequired,\n        h: T.number.isRequired,\n    }).isRequired,\n    direction: T.oneOf(['n', 's', 'w', 'e']).isRequired,\n};\n", "import styled from 'styled-components';\n\nexport interface LayerProps {\n    zIndex?: number;\n}\n\n/**\n * A layer that does not block events\n */\nconst Layer = styled.div<LayerProps>`\n    position: absolute;\n    top: 0px;\n    left: 0px;\n    right: 0px;\n    bottom: 0px;\n    pointer-events: none;\n    z-index: ${(props) => props.zIndex};\n`;\n\nexport default Layer;\n", "\nimport * as defaultImport from \"@splunk/react-icons/Plus\";\nexport * from \"@splunk/react-icons/Plus\";\nexport default ('default' in defaultImport ? defaultImport.default : defaultImport);\n", "\nimport * as defaultImport from \"@splunk/ui-utils/format\";\nexport * from \"@splunk/ui-utils/format\";\nexport default ('default' in defaultImport ? defaultImport.default : defaultImport);\n", "/**\n * Compute absolute horizontal position (top/bottom) based on dir\n * @param {String} dir\n * @param {Number} offset\n * @returns {String}\n */\nexport const getVerticalPosition = (dir: string, offset: number): string => {\n    if (dir[0] === 'n') {\n        return `top: -${offset}px`;\n    }\n    if (dir[0] === 's') {\n        return `bottom: -${offset}px`;\n    }\n    return `top: calc(50% - ${offset}px)`;\n};\n\n/**\n * Compute absolute vertical position (left/right) based on dir\n * @param {String} dir\n * @param {Number} offset\n * @returns {String}\n */\nexport const getHorizontalPosition = (dir: string, offset: number): string => {\n    if (dir.slice(-1) === 'w') {\n        return `left: -${offset}px`;\n    }\n    if (dir.slice(-1) === 'e') {\n        return `right: -${offset}px`;\n    }\n    return `left: calc(50% - ${offset}px)`;\n};\n", "import React from 'react';\nimport styled from 'styled-components';\nimport Plus from '@splunk/react-icons/Plus';\nimport { customThemeVariables } from '@splunk/dashboard-ui';\nimport { sprintf } from '@splunk/ui-utils/format';\nimport { _ } from '@splunk/ui-utils/i18n';\nimport {\n    getVerticalPosition,\n    getHorizontalPosition,\n} from '../../utils/outlineUtils';\n\nconst portOffset = 8;\nexport const PORT_DIRECTIONS = ['n', 'e', 's', 'w'] as const;\nexport type PortDirection = (typeof PORT_DIRECTIONS)[number];\n\nexport interface PortProps {\n    port: PortDirection;\n    onMouseEnter: React.MouseEventHandler<HTMLDivElement>;\n    onMouseLeave: React.MouseEventHandler<HTMLDivElement>;\n}\n\nconst PortContainer = styled.div.attrs<PortProps>(({ port }) => ({\n    'data-test': 'port',\n    'data-test-port': port,\n    'aria-label': sprintf(_('Port %s'), port),\n}))<PortProps & { children: React.ReactElement }>`\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    width: 16px;\n    height: 16px;\n    box-sizing: border-box;\n    border-radius: 50%;\n    position: absolute;\n    color: ${customThemeVariables.resizeHandleColor};\n    ${({ port }) => getVerticalPosition(port, portOffset)};\n    ${({ port }) => getHorizontalPosition(port, portOffset)};\n    z-index: 999;\n    pointer-events: auto;\n    user-select: none;\n    &:hover {\n        background-color: ${customThemeVariables.resizeHandleColor};\n    }\n`;\n\nexport const Port = ({\n    port,\n    onMouseEnter,\n    onMouseLeave,\n}: PortProps): JSX.Element => (\n    <PortContainer\n        port={port}\n        onMouseEnter={onMouseEnter}\n        onMouseLeave={onMouseLeave}\n    >\n        <Plus data-test=\"plus-glyph\" />\n    </PortContainer>\n);\n", "import React from 'react';\nimport styled from 'styled-components';\nimport T from 'prop-types';\nimport { customThemeVariables } from '@splunk/dashboard-ui';\n\nexport const PlaceholderComponent = styled.div.attrs(({ position }) => ({\n    style: {\n        width: position.w,\n        height: position.h,\n        transform: `translate(${position.x}px, ${position.y}px)`,\n    },\n}))`\n    display: block;\n    position: absolute;\n    pointer-events: none;\n    box-sizing: border-box;\n    border: 1px solid ${customThemeVariables.validDropTargetBorderColor};\n    background-color: ${customThemeVariables.validDropTargetBackgroundColor};\n`;\n\nexport const PreviewPlaceholderItem = ({ position }) => {\n    return (\n        <PlaceholderComponent\n            position={position}\n            data-test=\"preview-placeholder\"\n            data-test-preview-position={`${position.x},${position.y}-${position.w},${position.h}`}\n        />\n    );\n};\n\nPreviewPlaceholderItem.propTypes = {\n    position: T.shape({\n        x: T.number.isRequired,\n        y: T.number.isRequired,\n        w: T.number.isRequired,\n        h: T.number.isRequired,\n    }).isRequired,\n};\n", "import React, { useCallback } from 'react';\nimport styled from 'styled-components';\nimport type { HandleDirection } from '@splunk/dashboard-types';\nimport { _ } from '@splunk/ui-utils/i18n';\nimport { sprintf } from '@splunk/ui-utils/format';\nimport { customThemeVariables } from '@splunk/dashboard-ui';\nimport {\n    getVerticalPosition,\n    getHorizontalPosition,\n} from '../utils/outlineUtils';\n\nconst resizeHandleOffset = 7;\n/**\n * compute cursor base on resize dir\n * @param {String} dir\n */\nconst computeCursor = (dir: HandleDirection): string => {\n    switch (dir) {\n        case 'n':\n        case 's':\n            return 'ns-resize';\n        case 'e':\n        case 'w':\n            return 'ew-resize';\n        case 'ne':\n        case 'sw':\n            return 'nesw-resize';\n        case 'se':\n        case 'nw':\n        default:\n            return 'nwse-resize';\n    }\n};\n\nconst computeDirection = (dir: HandleDirection): string => {\n    switch (dir) {\n        case 'n':\n            return _('North');\n        case 's':\n            return _('South');\n        case 'e':\n            return _('East');\n        case 'w':\n            return _('West');\n        case 'ne':\n            return _('North-East');\n        case 'sw':\n            return _('South-West');\n        case 'se':\n            return _('South-East');\n        case 'nw':\n            return _('North-West');\n        default:\n            return '';\n    }\n};\n\ninterface ContainerProps {\n    direction: HandleDirection;\n    onMouseDown: React.MouseEventHandler<HTMLAnchorElement>;\n}\n\nconst Handle = styled.button.attrs<ContainerProps>(({ direction }) => ({\n    'data-test': 'handle',\n    'data-test-direction': direction,\n}))<ContainerProps>`\n    width: 10px;\n    height: 10px;\n    background-color: ${customThemeVariables.resizeHandleColor};\n    border: none;\n    border-radius: 20%;\n    padding: 0;\n    position: absolute;\n    ${({ direction }) => getVerticalPosition(direction, resizeHandleOffset)};\n    ${({ direction }) => getHorizontalPosition(direction, resizeHandleOffset)};\n    cursor: ${({ direction }) => computeCursor(direction)};\n    z-index: 999;\n    pointer-events: auto;\n    user-select: none;\n`;\n\nexport interface ResizeHandleProps {\n    direction: HandleDirection;\n    onMouseDown: (e: React.MouseEvent, dir: HandleDirection) => void;\n    onKeyDown: (e: React.KeyboardEvent, dir: HandleDirection) => void;\n}\n\nexport const ResizeHandle = ({\n    onMouseDown,\n    onKeyDown,\n    direction,\n}: ResizeHandleProps): JSX.Element => {\n    const handleMouseDown = useCallback(\n        (e: React.MouseEvent) => {\n            onMouseDown(e, direction);\n        },\n        [onMouseDown, direction]\n    );\n\n    const handleKeyDown = useCallback(\n        (e: React.KeyboardEvent) => {\n            onKeyDown(e, direction);\n        },\n        [onKeyDown, direction]\n    );\n\n    return (\n        <Handle\n            aria-label={sprintf(_('Move %(direction)s direction'), {\n                direction: computeDirection(direction),\n            })}\n            direction={direction}\n            onMouseDown={handleMouseDown}\n            onKeyDown={handleKeyDown}\n        />\n    );\n};\n", "import type { ReactNode } from 'react';\nimport styled from 'styled-components';\n\nexport type BorderType = 'hover' | 'select' | 'move' | 'none';\n// TODO: in the new implementation we want to let the parent calculate xywh based on the padding, i.e., call the applyVizPadding() in parent\nexport interface ResponsiveBoxProps {\n    itemId: string;\n    appearance?: 'hidden' | 'visible' | 'highlighted';\n    x: number;\n    y: number;\n    w: number;\n    h: number;\n    'data-test'?: string;\n    children: ReactNode;\n    zIndex?: number;\n}\n\nconst ResponsiveBox = styled.div.attrs<ResponsiveBoxProps>(\n    ({ itemId, x, y, w, h, 'data-test': dataTest, zIndex }) => {\n        const attributes = {\n            'data-test': dataTest ?? 'responsive-box',\n            'data-id': itemId,\n            'data-test-viz-item-position': `${x},${y},${w},${h}`,\n            style: {\n                width: `${w}px`,\n                height: `${h}px`,\n                top: `${y}px`,\n                left: `${x}px`,\n                zIndex,\n            },\n        };\n\n        if (!zIndex) {\n            delete attributes.style.zIndex;\n        }\n\n        return attributes;\n    }\n)<ResponsiveBoxProps>`\n    display: block;\n    position: absolute;\n    background: transparent;\n    pointer-events: none;\n    box-sizing: border-box;\n    visibility: ${(props) => {\n        return props.appearance === 'hidden' ? 'hidden' : 'visible';\n    }};\n    opacity: ${(props) => (props.appearance === 'highlighted' ? 1 : 0.5)};\n`;\n\nResponsiveBox.defaultProps = {\n    appearance: 'highlighted',\n};\n\nexport default ResponsiveBox;\n", "import styled from 'styled-components';\n\nexport interface DragHandlePortalProps {\n    x: number;\n    y: number;\n    w: number;\n    zIndex?: number;\n    isHidden?: boolean;\n}\n\nexport const DragHandlePortal = styled.div.attrs<DragHandlePortalProps>(\n    (props) => ({\n        'data-test': 'drag-handle-portal',\n        style: {\n            width: props.w,\n            top: props.y,\n            left: props.x,\n        },\n    })\n)<DragHandlePortalProps>`\n    display: block;\n    position: absolute;\n    background: transparent;\n    pointer-events: all;\n    box-sizing: border-box;\n    height: 0px;\n    z-index: ${(props) => props.zIndex};\n    visibility: ${({ isHidden }) => (isHidden ? 'hidden' : 'visible')};\n`;\n", "import React, { useCallback, useMemo, useState } from 'react';\nimport type { ReactElement } from 'react';\nimport { useLayoutLayers } from '@splunk/dashboard-context';\nimport type {\n    AbsoluteBlockItem,\n    OnItemSelected,\n    RenderLayoutItem,\n    StructureItemType,\n} from '@splunk/dashboard-types';\nimport { AbsoluteItemContainer } from '@splunk/dashboard-ui';\nimport {\n    makeSelectIsSelected,\n    selectMode,\n    useSelector,\n} from '@splunk/dashboard-state';\nimport ResponsiveBox from './ResponsiveBox';\nimport { ErrorMessageOverlay } from './ErrorMessageOverlay';\nimport ActionMenuPortal from './ActionMenuPortal';\nimport { applyVizPadding } from '../utils/edgeUtils';\nimport { DragHandlePortal } from './DragHandlePortal';\n\nexport interface ResponsiveBlockItemProps {\n    x: number;\n    y: number;\n    w: number;\n    h: number;\n    canvasHeight: number;\n    padding?: number;\n    itemId: string;\n    type?: StructureItemType;\n    renderLayoutItem: RenderLayoutItem;\n    onItemSelected: OnItemSelected;\n    appearance?: 'hidden' | 'visible' | 'highlighted';\n    errorMessages?: string[];\n    isMouseDownEventRef?: React.MutableRefObject<boolean>;\n}\n\ntype PortalState = React.MutableRefObject<HTMLDivElement | null>;\nconst defaultPortalState: PortalState = Object.freeze({\n    current: null,\n});\n\n/**\n * layout item that renders block element\n */\nconst ResponsiveBlockItem = ({\n    x: originalX,\n    y: originalY,\n    w: originalW,\n    h: originalH,\n    canvasHeight,\n    padding,\n    itemId,\n    type = 'block',\n    errorMessages,\n    onItemSelected,\n    renderLayoutItem,\n    appearance = 'highlighted',\n    isMouseDownEventRef,\n}: ResponsiveBlockItemProps): ReactElement => {\n    const selectIsSelected = useMemo(makeSelectIsSelected, []);\n    const mode = useSelector(selectMode);\n    const isSelected = useSelector((state) => selectIsSelected(state, itemId));\n    const [isClicked, setIsClicked] = useState(false);\n\n    // don't use a ref because on first render this needs to force a\n    // second render when the element changes and the menu can be mounted\n    const [actionMenuPortal, setActionMenuPortal] =\n        useState<PortalState>(defaultPortalState);\n\n    const [dragHandlePortal, setDragHandlePortal] =\n        useState<PortalState>(defaultPortalState);\n\n    const layerData = useLayoutLayers();\n    const {\n        layer: itemLayer,\n        actionMenu: actionMenuLayer,\n        dragHandle: dragHandleLayer,\n    } = layerData?.[itemId] ?? {};\n\n    // Only render action menu in ReactDOM portal when there's z-index layering\n    const renderActionMenuInPortal = typeof itemLayer === 'number';\n\n    const {\n        position: { x, y, w, h },\n    } = applyVizPadding({\n        item: {\n            position: {\n                x: originalX,\n                y: originalY,\n                w: originalW,\n                h: originalH,\n            },\n        } as AbsoluteBlockItem,\n        padding,\n    });\n\n    const layoutItem = useMemo(\n        () =>\n            renderLayoutItem(\n                itemId,\n                {\n                    width: w,\n                    height: h,\n                    y,\n                    canvasHeight,\n                    renderActionMenuInPortal,\n                    actionMenuPortal,\n                    dragHandlePortal,\n                },\n                type,\n                onItemSelected\n            ),\n        [\n            renderLayoutItem,\n            itemId,\n            type,\n            w,\n            h,\n            y,\n            canvasHeight,\n            onItemSelected,\n            renderActionMenuInPortal,\n            actionMenuPortal,\n            dragHandlePortal,\n        ]\n    );\n\n    // FocusEvent does not have any fields that indicate exactly what caused focus to occur, e.g. key, click, it must be inferred\n    const handleFocus = useCallback<React.FocusEventHandler>(\n        (event) => {\n            if (isMouseDownEventRef?.current) {\n                setIsClicked(true);\n                return;\n            }\n            // relatedTarget is set to the previously focused element when tabbing and is null when clicking.\n            // This test may result in the first tab press failing to change focus if there is no relatedTarget for it to add. A second tab press fixes it.\n            if (!event.relatedTarget) {\n                // The click handler will handle selection instead (but maybe it doesn't need to?)\n                return;\n            }\n            // If user clicks then uses tab, the isClicked state can remain true. This is to stop that\n            setIsClicked(false);\n            if (\n                // The tabindex was moved to the SelectableContainer (in renderLayoutItem), so we'll check that thats the target\n                event.target.getAttribute('data-test') === 'select-outline' &&\n                event.target.getAttribute('data-id') === itemId\n            ) {\n                onItemSelected(event, [{ id: itemId, type }]);\n            }\n        },\n        [isMouseDownEventRef, itemId, onItemSelected, type]\n    );\n\n    const trackActionMenuPortal = useCallback((element: HTMLDivElement) => {\n        setActionMenuPortal({ current: element });\n    }, []);\n\n    const trackDragHandlePortal = useCallback((element: HTMLDivElement) => {\n        setDragHandlePortal({ current: element });\n    }, []);\n\n    const isHidden = appearance === 'hidden';\n\n    return (\n        <AbsoluteItemContainer\n            data-id={itemId}\n            data-selected={`${isSelected}`}\n            data-click-focus={`${isClicked && isSelected && mode === 'view'}`}\n        >\n            <ResponsiveBox\n                data-test=\"absolute-item\"\n                itemId={itemId}\n                appearance={appearance}\n                x={x}\n                y={y}\n                w={w}\n                h={h}\n                onFocusCapture={handleFocus}\n            >\n                {layoutItem}\n                <ErrorMessageOverlay messages={errorMessages} />\n            </ResponsiveBox>\n            {renderActionMenuInPortal && (\n                <ActionMenuPortal\n                    x={x}\n                    y={y}\n                    w={w}\n                    h={h}\n                    ref={trackActionMenuPortal}\n                    zIndex={actionMenuLayer}\n                />\n            )}\n            <DragHandlePortal\n                x={x}\n                y={y}\n                w={w}\n                ref={trackDragHandlePortal}\n                zIndex={dragHandleLayer}\n                isHidden={isHidden}\n            />\n        </AbsoluteItemContainer>\n    );\n};\n\nexport default React.memo(ResponsiveBlockItem);\n", "import React, { useCallback, useMemo, useRef, useLayoutEffect } from 'react';\nimport type { HandleDirection } from '@splunk/dashboard-types';\nimport ResponsiveBox from './ResponsiveBox';\nimport { getClientPosition, getOffset } from '../utils/layoutUtils';\nimport { Port, PORT_DIRECTIONS, type PortDirection } from './Port';\nimport { ResizeHandle } from './ResizeHandle';\nimport { GRID_SIZE } from '../AbsoluteLayoutConstants';\n\nconst keyDirectionMap = {\n    ArrowUp: ['n', 'ne', 'se', 's', 'sw', 'nw'],\n    ArrowDown: ['n', 'ne', 'se', 's', 'sw', 'nw'],\n    ArrowLeft: ['ne', 'e', 'se', 'sw', 'w', 'nw'],\n    ArrowRight: ['ne', 'e', 'se', 'sw', 'w', 'nw'],\n};\n\nconst isKeyAllowedCheck = (key: string): key is keyof typeof keyDirectionMap =>\n    Object.keys(keyDirectionMap).includes(key);\n\nconst noop = (): void => undefined;\n\nexport interface ResponsiveBlockOutlineProps {\n    itemId: string;\n    x: number;\n    y: number;\n    w: number;\n    h: number;\n    scale?: number;\n    connectable?: boolean;\n    resizable?: boolean;\n    onResize?: (\n        e: MouseEvent | React.KeyboardEvent,\n        itemId: string,\n        offset: { offsetX: number; offsetY: number },\n        resizeDir: HandleDirection\n    ) => void;\n    onResized?: (\n        e: MouseEvent | KeyboardEvent,\n        itemId: string,\n        offset: { offsetX: number; offsetY: number },\n        resizeDir: HandleDirection\n    ) => void;\n    onLineConnect?: (itemId: string, port: PortDirection) => void;\n    onLineDisconnect?: (itemId: string, port: PortDirection) => void;\n    handleDirections: HandleDirection[];\n}\n\nconst ResponsiveBlockOutline = ({\n    itemId,\n    scale = 1,\n    connectable = false,\n    resizable = false,\n    onResize = noop,\n    onResized = noop,\n    onLineConnect = noop,\n    onLineDisconnect = noop,\n    handleDirections,\n    x,\n    y,\n    w,\n    h,\n}: ResponsiveBlockOutlineProps): JSX.Element => {\n    const startPosition = useRef<ReturnType<typeof getClientPosition> | null>(\n        null\n    );\n    const resizing = useRef(false);\n\n    const resizeDir = useRef<HandleDirection | null>(null);\n\n    const keyUpOffset = useRef({ offsetX: 0, offsetY: 0 });\n\n    // Setup start of resize operation\n    const handleResizeMouseDown = useCallback(\n        (e: React.MouseEvent, dir: HandleDirection) => {\n            e.preventDefault();\n            e.stopPropagation();\n            startPosition.current = getClientPosition(e, scale);\n            resizing.current = true;\n            resizeDir.current = dir;\n        },\n        [scale]\n    );\n\n    // Update size when resizing\n    const handleMouseMove = useCallback(\n        (e: MouseEvent) => {\n            if (\n                startPosition.current &&\n                resizing.current &&\n                resizeDir.current\n            ) {\n                e.preventDefault();\n                const currentPosition = getClientPosition(e, scale);\n                const offset = getOffset(\n                    currentPosition,\n                    startPosition.current\n                );\n                onResize(e, itemId, offset, resizeDir.current);\n            }\n        },\n        [scale, onResize, itemId]\n    );\n\n    // Update final position at end of resize\n    const handleMouseUp = useCallback(\n        (e: MouseEvent) => {\n            if (\n                startPosition.current &&\n                resizing.current &&\n                resizeDir.current\n            ) {\n                e.preventDefault();\n                const currentPosition = getClientPosition(e, scale);\n                const offset = getOffset(\n                    currentPosition,\n                    startPosition.current\n                );\n                startPosition.current = null;\n                resizing.current = false;\n                onResized(e, itemId, offset, resizeDir.current);\n                resizeDir.current = null;\n            }\n        },\n        [itemId, scale, onResized]\n    );\n\n    // Update size when keyboard resizing\n    const handleResizeKeyDown = useCallback(\n        (e: React.KeyboardEvent, dir: HandleDirection) => {\n            const { key } = e;\n            const isKeyAllowed = isKeyAllowedCheck(key);\n            const isDirectionAllowed =\n                isKeyAllowed && keyDirectionMap[key].includes(dir);\n\n            if (!isDirectionAllowed) {\n                return;\n            }\n\n            e.preventDefault();\n            e.stopPropagation();\n\n            resizeDir.current = dir;\n\n            if (e.key === 'ArrowUp') {\n                keyUpOffset.current.offsetY -= GRID_SIZE;\n            }\n            if (e.key === 'ArrowDown') {\n                keyUpOffset.current.offsetY += GRID_SIZE;\n            }\n            if (e.key === 'ArrowLeft') {\n                keyUpOffset.current.offsetX -= GRID_SIZE;\n            }\n            if (e.key === 'ArrowRight') {\n                keyUpOffset.current.offsetX += GRID_SIZE;\n            }\n\n            onResize(e, itemId, keyUpOffset.current, dir);\n        },\n        [itemId, onResize]\n    );\n\n    // Update final position at end of keyboard resize\n    const handleKeyUp = useCallback(\n        (e: KeyboardEvent) => {\n            if (keyUpOffset.current && resizeDir.current) {\n                onResized(e, itemId, keyUpOffset.current, resizeDir.current);\n\n                resizeDir.current = null;\n                keyUpOffset.current = { offsetX: 0, offsetY: 0 };\n            }\n        },\n        [itemId, onResized]\n    );\n\n    // Update line when connecting to port\n    const handlePortEnter = useCallback(\n        (port: PortDirection) => (e: React.MouseEvent) => {\n            e.preventDefault();\n            onLineConnect(itemId, port);\n        },\n        [itemId, onLineConnect]\n    );\n\n    // Update line when disconnecting from port\n    const handlePortLeave = useCallback(\n        (port: PortDirection) => (e: React.MouseEvent) => {\n            e.preventDefault();\n            onLineDisconnect(itemId, port);\n        },\n        [itemId, onLineDisconnect]\n    );\n\n    useLayoutEffect(() => {\n        if (resizable) {\n            document.addEventListener('mousemove', handleMouseMove);\n        }\n        return () => {\n            document.removeEventListener('mousemove', handleMouseMove);\n        };\n    }, [resizable, handleMouseMove]);\n\n    useLayoutEffect(() => {\n        if (resizable) {\n            document.addEventListener('mouseup', handleMouseUp);\n        }\n        return () => {\n            document.removeEventListener('mouseup', handleMouseUp);\n        };\n    }, [resizable, handleMouseUp]);\n\n    useLayoutEffect(() => {\n        if (resizable) {\n            document.addEventListener('keyup', handleKeyUp);\n        }\n        return () => {\n            document.removeEventListener('keyup', handleKeyUp);\n        };\n    }, [resizable, handleKeyUp]);\n\n    // Memoized resize handles\n    const ResizeHandles = useMemo(() => {\n        if (!resizable) {\n            return null;\n        }\n\n        return handleDirections.map((dir) => (\n            <ResizeHandle\n                key={`handle-${dir}`}\n                onMouseDown={handleResizeMouseDown}\n                onKeyDown={handleResizeKeyDown}\n                direction={dir}\n            />\n        ));\n    }, [\n        resizable,\n        handleDirections,\n        handleResizeMouseDown,\n        handleResizeKeyDown,\n    ]);\n\n    // Memoized connection ports\n    const Ports = useMemo(() => {\n        if (!connectable) {\n            return null;\n        }\n        return PORT_DIRECTIONS.map((port) => (\n            <Port\n                key={`port-${port}`}\n                port={port}\n                onMouseEnter={handlePortEnter(port)}\n                onMouseLeave={handlePortLeave(port)}\n            />\n        ));\n    }, [connectable, handlePortEnter, handlePortLeave]);\n\n    return (\n        <ResponsiveBox itemId={itemId} x={x} y={y} w={w} h={h}>\n            {ResizeHandles}\n            {Ports}\n        </ResponsiveBox>\n    );\n};\n\nexport default ResponsiveBlockOutline;\n", "import type { MouseEvent as ReactMouseEvent } from 'react';\nimport React, { useCallback, useMemo, useEffect, useRef } from 'react';\nimport styled from 'styled-components';\nimport { useLayoutLayers } from '@splunk/dashboard-context';\nimport { noop } from '@splunk/dashboard-utils';\nimport type {\n    Coordinate,\n    Port,\n    RenderLayoutItem,\n    SelectedItem,\n} from '@splunk/dashboard-types';\nimport { _ } from '@splunk/ui-utils/i18n';\nimport { customThemeVariables } from '@splunk/dashboard-ui';\nimport {\n    getOffset,\n    getClientPosition,\n    computeLineBoxPosition,\n    computeLineRelativePosition,\n} from '../utils/layoutUtils';\n\nconst allowedKeys = ['ArrowDown', 'ArrowUp', 'ArrowLeft', 'ArrowRight'];\n\ninterface LineBoxProps {\n    zIndex?: number;\n}\n\nconst LineBox = styled.div<LineBoxProps>`\n    position: absolute;\n    pointer-events: none;\n    z-index: ${(props) => props.zIndex};\n`;\n\ninterface AdjustHandleProps {\n    x: number;\n    y: number;\n}\n\nconst AdjustHandle = styled.button.attrs(({ x, y }: AdjustHandleProps) => ({\n    style: {\n        transform: `translate(${x}px, ${y}px)`,\n    },\n}))<AdjustHandleProps>`\n    width: 10px;\n    height: 10px;\n    left: -5px;\n    top: -5px;\n    background-color: ${customThemeVariables.resizeHandleColor};\n    border: none;\n    padding: 0;\n    border-radius: 50%;\n    position: absolute;\n    z-index: 999;\n    pointer-events: auto;\n    cursor: move;\n    user-select: none;\n`;\n\ntype HandleMove = (\n    e: MouseEvent | KeyboardEvent | React.KeyboardEvent,\n    offset: ReturnType<typeof getOffset>\n) => void;\n\nexport interface ResponsiveLineProps {\n    fromX: number;\n    fromY: number;\n    fromItem?: string;\n    fromPort?: Port;\n    toX: number;\n    toY: number;\n    toItem?: string;\n    toPort?: Port;\n    lineId: string;\n    scale?: number;\n    selectable?: boolean;\n    editable?: boolean;\n    renderLayoutItem: RenderLayoutItem;\n    onItemSelected?: (\n        e: ReactMouseEvent | React.KeyboardEvent,\n        items: SelectedItem[]\n    ) => void;\n    onLineDragStart?: (\n        e: ReactMouseEvent | React.KeyboardEvent,\n        dir: 'from' | 'to'\n    ) => void;\n    onLineMove?: HandleMove;\n    onLineMoved?: HandleMove;\n    onLineDrag?: HandleMove;\n    onLineDragged?: HandleMove;\n}\n\ntype Action = 'move' | 'drag';\n\nconst ResponsiveLine = ({\n    fromX,\n    fromY,\n    fromItem,\n    fromPort,\n    toX,\n    toY,\n    toItem,\n    toPort,\n    lineId,\n    scale = 1,\n    selectable = false,\n    editable = false,\n    renderLayoutItem,\n    onItemSelected = noop,\n    onLineDragStart = noop,\n    onLineMove = noop,\n    onLineMoved = noop,\n    onLineDrag = noop,\n    onLineDragged = noop,\n}: ResponsiveLineProps): JSX.Element => {\n    const startPositionRef = useRef<Coordinate | null>(null);\n    const actionRef = useRef<Action | null>(null);\n    const keyUpOffset = useRef({ offsetX: 0, offsetY: 0 });\n\n    const layerData = useLayoutLayers();\n    const lineLayer = useMemo<number | undefined>(() => {\n        const selectionLayer = Object.values(layerData ?? {})\n            .map((entry) => entry.selection)\n            .filter(Boolean)[0];\n\n        // Render lines just above selection outlines\n        return typeof selectionLayer === 'number'\n            ? selectionLayer + 1\n            : undefined;\n    }, [layerData]);\n\n    const handleLineSelected = useCallback(\n        (e: ReactMouseEvent) => {\n            e.stopPropagation();\n\n            startPositionRef.current = getClientPosition(e, scale);\n            actionRef.current = 'move';\n\n            onItemSelected(e, [{ id: lineId, type: 'line' }]);\n        },\n        [lineId, onItemSelected, scale]\n    );\n\n    const handleLineSelectedOnEnter = useCallback(\n        (e: React.KeyboardEvent) => {\n            if (e.key === 'Enter') {\n                onItemSelected(e, [{ id: lineId, type: 'line' }]);\n            }\n        },\n        [lineId, onItemSelected]\n    );\n\n    const handleKeyDown = useCallback(\n        (e: React.KeyboardEvent) => {\n            e.preventDefault();\n\n            if (e.key === 'ArrowUp') {\n                keyUpOffset.current.offsetY -= 1;\n            }\n            if (e.key === 'ArrowDown') {\n                keyUpOffset.current.offsetY += 1;\n            }\n            if (e.key === 'ArrowLeft') {\n                keyUpOffset.current.offsetX -= 1;\n            }\n            if (e.key === 'ArrowRight') {\n                keyUpOffset.current.offsetX += 1;\n            }\n            onLineDrag(e, keyUpOffset.current);\n        },\n        [onLineDrag]\n    );\n\n    const handleKeyDownFrom = useCallback(\n        (e: React.KeyboardEvent) => {\n            if (!allowedKeys.includes(e.key)) {\n                return;\n            }\n            if (\n                keyUpOffset.current.offsetX === 0 &&\n                keyUpOffset.current.offsetY === 0\n            ) {\n                onLineDragStart(e, 'from');\n            }\n            handleKeyDown(e);\n        },\n        [onLineDragStart, handleKeyDown]\n    );\n\n    const handleKeyDownTo = useCallback(\n        (e: React.KeyboardEvent) => {\n            if (!allowedKeys.includes(e.key)) {\n                return;\n            }\n            if (\n                keyUpOffset.current.offsetX === 0 &&\n                keyUpOffset.current.offsetY === 0\n            ) {\n                onLineDragStart(e, 'to');\n            }\n            handleKeyDown(e);\n        },\n        [onLineDragStart, handleKeyDown]\n    );\n\n    const handleKeyUp = useCallback(\n        (e: KeyboardEvent) => {\n            const isLineHandleFocused =\n                document.activeElement?.tagName === 'BUTTON' &&\n                document.activeElement\n                    ?.getAttribute('data-test')\n                    ?.startsWith('line-handle');\n            if (\n                !allowedKeys.includes(e.key) ||\n                (keyUpOffset.current.offsetX === 0 &&\n                    keyUpOffset.current.offsetY === 0) ||\n                !isLineHandleFocused\n            ) {\n                return;\n            }\n\n            onLineDragged(e, keyUpOffset.current);\n\n            keyUpOffset.current = { offsetX: 0, offsetY: 0 };\n        },\n        [onLineDragged]\n    );\n\n    const handleMouseDownFrom = useCallback(\n        (e: ReactMouseEvent) => {\n            e.stopPropagation();\n\n            startPositionRef.current = getClientPosition(e, scale);\n            actionRef.current = 'drag';\n\n            onLineDragStart(e, 'from');\n        },\n        [onLineDragStart, scale]\n    );\n\n    const handleMouseDownTo = useCallback(\n        (e: ReactMouseEvent) => {\n            e.stopPropagation();\n\n            startPositionRef.current = getClientPosition(e, scale);\n            actionRef.current = 'drag';\n\n            onLineDragStart(e, 'to');\n        },\n        [onLineDragStart, scale]\n    );\n\n    const handleMouseUp = useCallback(\n        (e: MouseEvent) => {\n            if (!startPositionRef.current || !actionRef.current) {\n                return;\n            }\n\n            const currentPosition = getClientPosition(e, scale);\n            const offset = getOffset(currentPosition, startPositionRef.current);\n\n            // reset the start position\n            startPositionRef.current = null;\n\n            // don't call any callbacks if the line hasn't actually moved\n            if ((!offset.offsetX && !offset.offsetY) || !editable) {\n                return;\n            }\n\n            switch (actionRef.current) {\n                case 'drag':\n                    onLineDragged(e, offset);\n                    break;\n                case 'move':\n                    onLineMoved(e, offset);\n                    break;\n                default:\n                    break;\n            }\n\n            actionRef.current = null;\n        },\n        [editable, onLineDragged, onLineMoved, scale]\n    );\n\n    const handleMouseMove = useCallback(\n        (e: MouseEvent) => {\n            if (startPositionRef.current == null || actionRef.current == null) {\n                return;\n            }\n\n            /**\n             * MouseEvent::buttons\n             * 0: No button or un-initialized\n             * 1: Primary button (usually the left button)\n             * 2: Secondary button (usually the right button)\n             * 4: Auxiliary button (usually the mouse wheel button or middle button)\n             * 8: 4th button (typically the \"Browser Back\" button)\n             * 16 : 5th button (typically the \"Browser Forward\" button)\n             *\n             * For more than one button pressed simultaneously, the values are combined (e.g., 3 is primary + secondary)\n             */\n            if (e.buttons <= 0 || e.buttons % 2 === 0) {\n                // Either buttons is 0 (no depression), or buttons is even (no left depression)\n                // In both cases run the mouseUp callback because the line is locked to the cursor\n                handleMouseUp(e);\n                return;\n            }\n\n            e.preventDefault();\n            const currentPosition = getClientPosition(e, scale);\n            const offset = getOffset(currentPosition, startPositionRef.current);\n            // don't call any callbacks if the line hasn't actually moved\n            if ((!offset.offsetX && !offset.offsetY) || !editable) {\n                return;\n            }\n            switch (actionRef.current) {\n                case 'drag':\n                    onLineDrag(e, offset);\n                    break;\n                case 'move':\n                    onLineMove(e, offset);\n                    break;\n                default:\n                    break;\n            }\n        },\n        [editable, handleMouseUp, onLineDrag, onLineMove, scale]\n    );\n\n    const from = { x: fromX, y: fromY };\n    const to = { x: toX, y: toY };\n    const boxPos = computeLineBoxPosition(from, to);\n    const relativePos = computeLineRelativePosition(from, to, boxPos);\n\n    const lineBoxStyle = useMemo(\n        () => ({\n            transform: `translate(${boxPos.x}px, ${boxPos.y}px)`,\n        }),\n        [boxPos.x, boxPos.y]\n    );\n\n    const fromHandleElement = useMemo(() => {\n        if (!editable) {\n            return null;\n        }\n\n        return (\n            <AdjustHandle\n                data-test=\"line-handle-from\"\n                data-test-item={fromItem}\n                data-test-port={fromPort}\n                x={relativePos.from.x}\n                y={relativePos.from.y}\n                onMouseDown={handleMouseDownFrom}\n                onKeyDown={handleKeyDownFrom}\n                aria-label={_('From line handle')}\n            />\n        );\n    }, [\n        editable,\n        fromItem,\n        fromPort,\n        relativePos.from.x,\n        relativePos.from.y,\n        handleMouseDownFrom,\n        handleKeyDownFrom,\n    ]);\n\n    const toHandleElement = useMemo(() => {\n        if (!editable) {\n            return null;\n        }\n\n        return (\n            <AdjustHandle\n                data-test=\"line-handle-to\"\n                data-test-item={toItem}\n                data-test-port={toPort}\n                x={relativePos.to.x}\n                y={relativePos.to.y}\n                onMouseDown={handleMouseDownTo}\n                onKeyDown={handleKeyDownTo}\n                aria-label={_('To line handle')}\n            />\n        );\n    }, [\n        editable,\n        toItem,\n        toPort,\n        relativePos.to.x,\n        relativePos.to.y,\n        handleMouseDownTo,\n        handleKeyDownTo,\n    ]);\n\n    const lineElement = useMemo(\n        () =>\n            renderLayoutItem(\n                lineId,\n                {\n                    from: {\n                        x: relativePos.from.x,\n                        y: relativePos.from.y,\n                    },\n                    to: {\n                        x: relativePos.to.x,\n                        y: relativePos.to.y,\n                    },\n                    // todo: this is inconsistent with the ResponsiveBlockItem which accepts the `onSelect` callback as the 4th argument of `renderLayoutItem`.\n                    onLineSelect: selectable ? handleLineSelected : noop,\n                },\n                'line'\n            ),\n        [\n            handleLineSelected,\n            lineId,\n            relativePos.from.x,\n            relativePos.from.y,\n            relativePos.to.x,\n            relativePos.to.y,\n            renderLayoutItem,\n            selectable,\n        ]\n    );\n\n    useEffect(() => {\n        document.addEventListener('mousemove', handleMouseMove);\n        document.addEventListener('mouseup', handleMouseUp);\n\n        return () => {\n            document.removeEventListener('mousemove', handleMouseMove);\n            document.removeEventListener('mouseup', handleMouseUp);\n        };\n    }, [handleMouseMove, handleMouseUp]);\n\n    useEffect(() => {\n        if (editable) {\n            document.addEventListener('keyup', handleKeyUp);\n        }\n        return () => {\n            document.removeEventListener('keyup', handleKeyUp);\n        };\n    }, [editable, handleKeyUp]);\n\n    return (\n        <LineBox\n            data-test=\"line-box\"\n            tabIndex={!editable ? 0 : undefined}\n            onKeyDown={handleLineSelectedOnEnter}\n            style={lineBoxStyle}\n            data-viz-type=\"abslayout.line\"\n            data-id={lineId}\n            data-test-line-position={`${from.x},${from.y}-${to.x},${to.y}`}\n            zIndex={lineLayer}\n        >\n            {fromHandleElement}\n            {toHandleElement}\n            {lineElement}\n        </LineBox>\n    );\n};\n\nexport default ResponsiveLine;\n", "import {\n    DEFAULT_CANVAS_WIDTH,\n    DEFAULT_CANVAS_HEIGHT,\n} from '@splunk/dashboard-utils';\nimport type {\n    AbsoluteLayoutOptions,\n    GridLayoutOptions,\n} from '@splunk/dashboard-types';\n\nexport const absoluteLayoutOptions: Required<\n    Pick<AbsoluteLayoutOptions, 'width' | 'height' | 'display'>\n> = {\n    width: DEFAULT_CANVAS_WIDTH,\n    height: DEFAULT_CANVAS_HEIGHT,\n    display: 'auto',\n};\n\nexport const gridLayoutOptions: Required<\n    Pick<GridLayoutOptions, 'width' | 'gutterSize'>\n> = {\n    width: DEFAULT_CANVAS_WIDTH,\n    gutterSize: 8,\n};\n", "import { _ } from '@splunk/ui-utils/i18n';\nimport type {\n    AbsoluteLayoutStructure,\n    SelectedItem,\n    AbsoluteBlockItem,\n    Port,\n    Coordinate,\n} from '@splunk/dashboard-types';\nimport { isBlockItem } from '@splunk/dashboard-utils';\nimport type { LayoutStructureState } from '../types';\n\ninterface FindSelectedBlockItemsArgs {\n    layoutStructure: AbsoluteLayoutStructure;\n    selectedItems: SelectedItem[];\n}\n\nexport const findSelectedBlockItems = ({\n    layoutStructure,\n    selectedItems,\n}: FindSelectedBlockItemsArgs): AbsoluteBlockItem[] =>\n    layoutStructure.filter(\n        (item) =>\n            selectedItems.findIndex(\n                ({ id }) => item.item === id && isBlockItem(item)\n            ) >= 0\n    ) as AbsoluteBlockItem[];\n\ninterface GetAllBlockItemsArgs {\n    layoutStructure: AbsoluteLayoutStructure;\n    layoutStructureState?: LayoutStructureState;\n}\n\nexport const getAllBlockItems = ({\n    layoutStructure,\n    layoutStructureState = {},\n}: GetAllBlockItemsArgs): AbsoluteBlockItem[] => {\n    return layoutStructure\n        .map((item) => layoutStructureState[item.item] ?? item)\n        .filter((item) => isBlockItem(item)) as AbsoluteBlockItem[];\n};\n\n/**\n * compute port position for a given block item\n * @param {Object} blockItem\n * @param {String} port\n */\nexport const computePortPosition = (\n    blockItem: AbsoluteBlockItem,\n    port: Port\n): Coordinate => {\n    const blockPosition = blockItem.position;\n    switch (port) {\n        case 'n':\n            return {\n                x: Math.round(blockPosition.x + blockPosition.w / 2),\n                y: blockPosition.y,\n            };\n        case 'w':\n            return {\n                x: blockPosition.x,\n                y: Math.round(blockPosition.y + blockPosition.h / 2),\n            };\n        case 'e':\n            return {\n                x: blockPosition.x + blockPosition.w,\n                y: Math.round(blockPosition.y + blockPosition.h / 2),\n            };\n        case 's':\n        default:\n            return {\n                x: Math.round(blockPosition.x + blockPosition.w / 2),\n                y: blockPosition.y + blockPosition.h,\n            };\n    }\n};\n\ninterface GetBlockItemArgs {\n    layoutStructure: AbsoluteLayoutStructure;\n    id: string;\n}\n\nexport const InvalidBlockItemError = 'refers to an invalid block item';\nconst InvalidBlockItemErrorMessage = _(`%s ${InvalidBlockItemError}`);\n\nexport const getBlockItem = ({\n    layoutStructure,\n    id,\n}: GetBlockItemArgs): AbsoluteBlockItem => {\n    const blockItem = layoutStructure.find(({ item }) => item === id);\n\n    if (!blockItem || blockItem.type === 'line') {\n        throw Error(InvalidBlockItemErrorMessage.replace('%s', id));\n    }\n\n    return blockItem;\n};\n", "import type {\n    AbsoluteLayoutStructure,\n    ConnectedLineItem,\n    Coordinate,\n    ConnectedLinePosition,\n    SelectedItem,\n} from '@splunk/dashboard-types';\nimport type { Offset, LineDirection, LayoutStructureState } from '../types';\nimport {\n    updateLineAbsPosition,\n    isLineConnected,\n    disconnectLine,\n} from './layoutUtils';\nimport { computePortPosition, getBlockItem } from './blockUtils';\n\ninterface ComputeLineAbsPositionArgs {\n    layoutStructure: AbsoluteLayoutStructure;\n    position: ConnectedLinePosition;\n}\n\nexport const computeLineAbsPosition = ({\n    layoutStructure,\n    position,\n}: ComputeLineAbsPositionArgs): {\n    from: Coordinate;\n    to: Coordinate;\n} => {\n    let { from, to } = position;\n\n    if ('item' in from && 'port' in from) {\n        const blockItem = getBlockItem({ layoutStructure, id: from.item });\n        from = computePortPosition(blockItem, from.port);\n    }\n    if ('item' in to && 'port' in to) {\n        const blockItem = getBlockItem({ layoutStructure, id: to.item });\n        to = computePortPosition(blockItem, to.port);\n    }\n    return {\n        from,\n        to,\n    };\n};\n\ninterface FindSelectedLineItemsArgs {\n    layoutStructure: AbsoluteLayoutStructure;\n    selectedItems: SelectedItem[];\n}\n\nexport const findSelectedLineItems = ({\n    layoutStructure,\n    selectedItems,\n}: FindSelectedLineItemsArgs): ConnectedLineItem[] =>\n    layoutStructure.filter(\n        ({ item, type }) =>\n            selectedItems.findIndex(\n                ({ id }) => item === id && type === 'line'\n            ) >= 0\n    ) as ConnectedLineItem[];\n\nexport interface HandleSingleLineMoveArgs {\n    offset: Offset;\n    lineId: string;\n    layoutStructure: AbsoluteLayoutStructure;\n}\n\nexport const handleSingleLineMove = ({\n    lineId,\n    offset,\n    layoutStructure,\n}: HandleSingleLineMoveArgs): ConnectedLineItem => {\n    let line = layoutStructure.find(\n        (item) => item.item === lineId\n    ) as ConnectedLineItem;\n\n    const linePosition = computeLineAbsPosition({\n        layoutStructure,\n        position: line.position,\n    });\n\n    if (isLineConnected({ line, dir: 'from' })) {\n        line = disconnectLine({\n            line,\n            dir: 'from',\n            absPos: linePosition.from,\n        });\n    }\n\n    if (isLineConnected({ line, dir: 'to' })) {\n        line = disconnectLine({\n            line,\n            dir: 'to',\n            absPos: linePosition.to,\n        });\n    }\n\n    line = updateLineAbsPosition({\n        line,\n        dir: 'from',\n        offset,\n    });\n\n    line = updateLineAbsPosition({\n        line,\n        dir: 'to',\n        offset,\n    });\n\n    return line;\n};\n\nexport interface HandleSingleLineDragStartArgs {\n    lineId: string;\n    layoutStructure: AbsoluteLayoutStructure;\n    lineDir: LineDirection;\n}\n\nexport const handleSingleLineDragStart = ({\n    lineId,\n    layoutStructure,\n    lineDir,\n}: HandleSingleLineDragStartArgs): ConnectedLineItem => {\n    let line = layoutStructure.find(\n        (item) => item.item === lineId\n    ) as ConnectedLineItem;\n\n    const linePosition = computeLineAbsPosition({\n        layoutStructure,\n        position: line.position,\n    });\n\n    if (\n        isLineConnected({\n            line,\n            dir: lineDir,\n        })\n    ) {\n        line = disconnectLine({\n            line,\n            dir: lineDir,\n            absPos: linePosition[lineDir],\n        });\n    }\n\n    return line;\n};\n\ninterface GetAllLineItemsArgs {\n    layoutStructure: AbsoluteLayoutStructure;\n    layoutStructureState?: LayoutStructureState;\n}\n\nexport const getAllLineItems = ({\n    layoutStructure,\n    layoutStructureState = {},\n}: GetAllLineItemsArgs): ConnectedLineItem[] => {\n    return layoutStructure\n        .map((item) => layoutStructureState[item.item] ?? item)\n        .filter(({ type }) => type === 'line') as ConnectedLineItem[];\n};\n", "import type {\n    AbsoluteLayoutStructure,\n    ConnectedLineItem,\n    Port,\n    AbsoluteBlockItem,\n    Coordinate,\n    HandleDirection,\n} from '@splunk/dashboard-types';\nimport type { LineDirection, LayoutStructureState } from '../types';\nimport {\n    updateBlockItemPosition,\n    snapOffsetToXY,\n    createOffset,\n    isLineConnected,\n    disconnectLine,\n    connectLine,\n} from './layoutUtils';\n\nimport { computeLineAbsPosition, handleSingleLineMove } from './lineUtils';\n\ntype Action =\n    | {\n          type: 'lineMove';\n          payload: ConnectedLineItem;\n      }\n    | {\n          type: 'lineDragStart';\n          payload: ConnectedLineItem;\n      }\n    | {\n          type: 'lineDrag';\n          payload: {\n              id: string;\n              dir: LineDirection;\n              absPos: Coordinate;\n          };\n      }\n    | {\n          type: 'lineConnect';\n          payload: {\n              lineId: string;\n              lineDir: LineDirection;\n              itemId: string;\n              port: Port;\n          };\n      }\n    | {\n          type: 'lineDisconnect';\n          payload: {\n              lineId: string;\n              lineDir: LineDirection;\n          };\n      }\n    | {\n          type: 'blockResize';\n          payload: AbsoluteBlockItem;\n      }\n    | {\n          type: 'blocksMove';\n          payload: AbsoluteBlockItem[];\n      }\n    | {\n          type: 'reset';\n          payload: AbsoluteLayoutStructure;\n      };\n\nexport const initializeLayoutStructureState = (\n    layoutStructure: AbsoluteLayoutStructure\n): LayoutStructureState =>\n    layoutStructure.reduce((obj, item) => {\n        // eslint-disable-next-line no-param-reassign\n        obj[item.item] = { ...item };\n        return obj;\n    }, {} as LayoutStructureState);\n\nexport const reducer = (\n    state: LayoutStructureState,\n    action: Action\n): LayoutStructureState => {\n    switch (action.type) {\n        case 'lineMove':\n            return {\n                ...state,\n                [action.payload.item]: action.payload,\n            };\n        case 'lineDragStart':\n            return {\n                ...state,\n                [action.payload.item]: action.payload,\n            };\n        case 'lineDrag': {\n            const lineToDrag = state[action.payload.id] as ConnectedLineItem;\n            return isLineConnected({\n                line: lineToDrag,\n                dir: action.payload.dir,\n            })\n                ? state\n                : {\n                      ...state,\n                      [action.payload.id]: {\n                          ...lineToDrag,\n                          position: {\n                              ...lineToDrag.position,\n                              [action.payload.dir]: action.payload.absPos,\n                          },\n                      },\n                  };\n        }\n        case 'lineConnect': {\n            const lineToConnect = state[\n                action.payload.lineId\n            ] as ConnectedLineItem;\n            return isLineConnected({\n                line: lineToConnect,\n                dir: action.payload.lineDir,\n            })\n                ? state\n                : {\n                      ...state,\n                      [action.payload.lineId]: connectLine({\n                          line: lineToConnect,\n                          dir: action.payload.lineDir,\n                          itemId: action.payload.itemId,\n                          port: action.payload.port,\n                      }),\n                  };\n        }\n        case 'lineDisconnect': {\n            const lineToDisconnect = state[\n                action.payload.lineId\n            ] as ConnectedLineItem;\n\n            return isLineConnected({\n                line: lineToDisconnect,\n                dir: action.payload.lineDir,\n            })\n                ? {\n                      ...state,\n                      [action.payload.lineId]: disconnectLine({\n                          line: lineToDisconnect,\n                          dir: action.payload.lineDir,\n                          absPos: computeLineAbsPosition({\n                              layoutStructure: Object.values(state),\n                              position: lineToDisconnect.position,\n                          })[action.payload.lineDir],\n                      }),\n                  }\n                : state;\n        }\n        case 'blockResize':\n            return {\n                ...state,\n                [action.payload.item]: action.payload,\n            };\n        case 'blocksMove':\n            return action.payload.reduce(\n                (s, blockItem) => ({\n                    ...s,\n                    [blockItem.item]: blockItem,\n                }),\n                { ...state }\n            );\n        case 'reset':\n            return initializeLayoutStructureState(action.payload);\n        default:\n            return state;\n    }\n};\n\ninterface UpdateLayoutStructureOnKeyboardMoveArgs {\n    selectedLineItems: ConnectedLineItem[];\n    selectedBlockItems: AbsoluteBlockItem[];\n    layoutStructure: AbsoluteLayoutStructure;\n    dir: HandleDirection;\n    snap: boolean;\n    gridSize: number;\n}\n\nexport const updateLayoutStructureOnKeyboardMove = ({\n    selectedLineItems,\n    selectedBlockItems,\n    layoutStructure,\n    dir,\n    snap,\n    gridSize,\n}: UpdateLayoutStructureOnKeyboardMoveArgs): AbsoluteLayoutStructure => {\n    const updatedLines = selectedLineItems.map(({ item }) => {\n        const offset = createOffset(dir, 1, 1);\n\n        return handleSingleLineMove({\n            layoutStructure,\n            lineId: item,\n            offset,\n        });\n    });\n\n    const updatedBlocks = selectedBlockItems.map((blockItem) => {\n        const { position } = blockItem;\n        const snapOffset = snap\n            ? snapOffsetToXY({\n                  position,\n                  offset: createOffset(dir, gridSize, gridSize),\n                  gridWidth: gridSize,\n                  gridHeight: gridSize,\n                  spacing: 0,\n                  padding: 0,\n              })\n            : createOffset(dir, 1, 1);\n        return updateBlockItemPosition(blockItem, snapOffset);\n    });\n\n    const updatedItems = [...updatedLines, ...updatedBlocks];\n\n    const updatedLayoutStructure = layoutStructure.map(\n        (item) => updatedItems.find((line) => line.item === item.item) ?? item\n    );\n\n    return updatedLayoutStructure;\n};\n", "import { COLOR_PATTERN_WITH_RGBA_AND_TOKEN } from '@splunk/dashboard-definition';\nimport { namedColors } from '@splunk/dashboard-ui';\nimport {\n    DEFAULT_CANVAS_WIDTH,\n    DEFAULT_CANVAS_HEIGHT,\n} from '@splunk/dashboard-utils';\n\nexport default {\n    backgroundColor: {\n        anyOf: [\n            {\n                pattern: COLOR_PATTERN_WITH_RGBA_AND_TOKEN,\n                type: 'string',\n                description: `Specify the color of the layout background color using using a hex code, rgb/rgba value, an HTML color name, or a token.\n\nThe default for light mode is \"#F2F4f5\". The default for dark mode is \"#3C444D\". The default for SCP mode is \"#15161B\"`,\n            },\n            {\n                type: 'string',\n                enum: namedColors,\n                description: `Specify the color of the layout background color using a valid web color such as 'blue'`,\n            },\n        ],\n    },\n    display: {\n        type: 'string',\n        default: 'auto',\n        enum: ['actual-size', 'fit-to-width', 'auto', 'auto-scale'],\n        description: `Specify the display behavior. Valid options are:\n\n\nactual-size: The dashboard will not change size when the browser is resized.\n\n\nfit-to-width: The dashboard will change in size as the browser is resized, always filling the available width of the browser.\n\n\nauto: The dashboard will change in size as the browser is resized, to a maximum zoom of 100%.`,\n    },\n    backgroundImage: {\n        type: 'object',\n        properties: {\n            w: {\n                type: 'number',\n                description: `Specify the image's h (height) and w (width) in pixels. These options should not be specified if you set the sizeType option. If they are, they will overrule that setting.`,\n            },\n            h: {\n                type: 'number',\n                description: `Specify the image's h (height) and w (width) in pixels. These options should not be specified if you set the sizeType option. If they are, they will overrule that setting.`,\n            },\n            x: {\n                type: 'number',\n                description:\n                    'Specify, in pixels, the position of the background image on the x-axis and y-axis. These options should not be specified if you set the sizeType option. If they are, they will overrule that setting.',\n            },\n            y: {\n                type: 'number',\n                description:\n                    'Specify, in pixels, the position of the background image on the x-axis and y-axis. These options should not be specified if you set the sizeType option. If they are, they will overrule that setting.',\n            },\n            src: {\n                type: 'string',\n                description: 'The url of background image.',\n            },\n            opacity: {\n                type: 'number',\n                minimum: 0,\n                maximum: 1,\n                description: 'The opacity of the image.',\n            },\n            sizeType: {\n                type: 'string',\n                enum: ['auto', 'contain', 'cover'],\n                default: 'contain',\n                description: `Specify one of the following:\n\n\nauto: Scales the image while maintaining the image proportion.\n\n\ncontain: Increases the size of the of the image as much as possible without cropping or stretching it.\n\n\ncover: Increases the size of the image without stretching it. The image may be cropped vertically and horizontally so that no empty space is shown.`,\n            },\n        },\n        description: `A background image must be one of the following types: jpg, jpeg, png, svg, or gif\n\nSpecify the location of a background image using the option src. For example: \"src\": \"https://www.myImageLocation.com/galleryX/image1.png`,\n        additionalProperties: false,\n    },\n    width: {\n        type: 'number',\n        default: DEFAULT_CANVAS_WIDTH,\n        description: 'Canvas width in pixels.',\n    },\n    height: {\n        type: 'number',\n        default: DEFAULT_CANVAS_HEIGHT,\n        description: 'Canvas height in pixels.',\n    },\n};\n", "import React from 'react';\nimport type {\n    AbsoluteLayoutStructure,\n    GridLayoutStructure,\n    SchemaObject,\n} from '@splunk/dashboard-types';\nimport { useLayoutShowHide, type ReflowFn } from '../hooks';\n\ntype GenericLayoutProps = {\n    layoutStructure?: AbsoluteLayoutStructure | GridLayoutStructure;\n};\n\nexport interface EnhancedLayout<P extends GenericLayoutProps> {\n    (props: P): JSX.Element;\n    schema: SchemaObject;\n}\n\nconst EmptyStructure = [] as Parameters<typeof useLayoutShowHide>[0];\n\nexport const withLayoutShowHide = <P extends GenericLayoutProps>(\n    Layout: React.ComponentType<P>,\n    { schema, reflowFn }: { schema: SchemaObject; reflowFn?: ReflowFn }\n): EnhancedLayout<P> => {\n    const EnhancedLayout = (props: P) => {\n        const layoutStructure = useLayoutShowHide(\n            props.layoutStructure ?? EmptyStructure,\n            reflowFn\n        );\n\n        return (\n            <Layout\n                {...props}\n                layoutStructure={layoutStructure}\n                rawLayoutStructure={props.layoutStructure}\n            />\n        );\n    };\n\n    (EnhancedLayout as EnhancedLayout<P>).schema = schema;\n    return EnhancedLayout as EnhancedLayout<P>;\n};\n", "import React, {\n    useMemo,\n    useCallback,\n    useRef,\n    useEffect,\n    useReducer,\n} from 'react';\nimport { isEqual } from 'lodash';\nimport {\n    useKeyboardListener,\n    usePreset,\n    useDashboardCoreApi,\n    useCanvasRef,\n} from '@splunk/dashboard-context';\nimport { DashboardDefinition } from '@splunk/dashboard-definition';\nimport { usePrevious } from '@splunk/dashboard-ui';\nimport {\n    allowKeyboardShortcut,\n    isBlockItem,\n    noop,\n} from '@splunk/dashboard-utils';\nimport type {\n    AbsoluteBlockItem,\n    AbsoluteLayoutOptions,\n    AbsoluteLayoutStructure,\n    BaseLayoutProps,\n    ConnectedLineItem,\n    HandleDirection,\n    Port,\n    SelectedItem,\n} from '@splunk/dashboard-types';\nimport {\n    useDispatch,\n    blockItemMove,\n    blockItemMoved,\n    blockItemResize,\n    blockItemResized,\n} from '@splunk/dashboard-state';\n\nimport {\n    AbsoluteCanvas,\n    Layer,\n    ResponsiveBlockItem,\n    ResponsiveLine,\n    ResponsiveBlockOutline,\n} from './components';\nimport { absoluteLayoutOptions } from './DefaultOptions';\nimport {\n    initializeLayoutStructureState,\n    reducer,\n    updateLayoutStructureOnKeyboardMove,\n} from './utils/absoluteLayoutUtils';\nimport {\n    findSelectedBlockItems,\n    getAllBlockItems,\n    InvalidBlockItemError,\n} from './utils/blockUtils';\nimport { validateBackgroundImage } from './utils/imageUtils';\nimport {\n    updateBlockItemSize,\n    updateBlockItemPosition,\n    snapOffsetToXY,\n    snapOffsetToWH,\n} from './utils/layoutUtils';\nimport {\n    computeLineAbsPosition,\n    findSelectedLineItems,\n    handleSingleLineMove,\n    handleSingleLineDragStart,\n} from './utils/lineUtils';\nimport {\n    GRID_SIZE,\n    GRID_PADDING,\n    MIN_WIDTH,\n    MIN_HEIGHT,\n} from './AbsoluteLayoutConstants';\nimport absoluteLayoutOptionsSchema from './absoluteLayoutOptionsSchema';\nimport type { Offset, LineDirection, LayoutStructureState } from './types';\nimport { withLayoutShowHide } from './enhancers';\nimport { useAbsoluteLayoutZoom } from './hooks';\n\nconst emptySelectedItems: SelectedItem[] = [];\n\nexport interface AbsoluteLayoutProps\n    extends BaseLayoutProps<AbsoluteLayoutStructure, AbsoluteLayoutOptions> {\n    showGrid?: boolean;\n    rawLayoutStructure?: AbsoluteLayoutStructure;\n}\n\nconst emptyLayoutStructure: AbsoluteLayoutStructure = [];\n\nconst AbsoluteLayout = (props: AbsoluteLayoutProps): JSX.Element => {\n    const {\n        layoutId,\n        mode = 'view',\n        showGrid = true,\n        options: {\n            width = absoluteLayoutOptions.width,\n            height = absoluteLayoutOptions.height,\n            display = absoluteLayoutOptions.display,\n            backgroundColor,\n            backgroundImage,\n        } = absoluteLayoutOptions as AbsoluteLayoutOptions,\n        layoutStructure = emptyLayoutStructure,\n        rawLayoutStructure = emptyLayoutStructure,\n        containerWidth,\n        containerHeight,\n        selectedItems = emptySelectedItems,\n        renderLayoutItem,\n        onLayoutItemsSelect = noop,\n        onLayoutStructureChange = noop,\n    } = props;\n\n    const activeLine = useRef<{\n        id: string;\n        dir: LineDirection;\n    } | null>(null);\n\n    const reduxDispatch = useDispatch();\n\n    const [layoutStructureState, dispatch] = useReducer(\n        reducer,\n        layoutStructure,\n        initializeLayoutStructureState\n    );\n\n    const canvasRef = useCanvasRef(layoutId);\n\n    const isMouseDownEventRef = useRef(false);\n\n    // have a ref to the latest layoutStructure, so that the AbsoluteLayoutApi can use it\n    const layoutStructureRef = useRef<AbsoluteLayoutStructure>(layoutStructure);\n    layoutStructureRef.current = layoutStructure;\n\n    const keyboardListener = useKeyboardListener();\n    const preset = usePreset();\n    const dashboardApi = useDashboardCoreApi();\n\n    const scale = useAbsoluteLayoutZoom({\n        layoutId,\n        display,\n        width,\n        height,\n        containerWidth,\n        containerHeight,\n    });\n\n    const previousLayoutStructure = usePrevious(layoutStructure);\n\n    /**\n     * Keyboard move updates the definition directly, no need to update state\n     */\n    const handleKeyboardMove = useCallback(\n        ({\n            dir,\n            snap,\n            preventDefault,\n        }: {\n            dir: HandleDirection;\n            snap: boolean;\n            preventDefault: () => void;\n        }) => {\n            if (!allowKeyboardShortcut()) {\n                return;\n            }\n\n            const selectedLineItems = findSelectedLineItems({\n                layoutStructure: layoutStructureRef.current,\n                selectedItems,\n            });\n            const selectedBlockItems = findSelectedBlockItems({\n                layoutStructure: layoutStructureRef.current,\n                selectedItems,\n            });\n\n            const isResizeHandleFocused =\n                document.activeElement?.tagName === 'BUTTON' &&\n                document.activeElement?.hasAttribute('direction');\n            const isLineHandleFocused =\n                document.activeElement?.tagName === 'BUTTON' &&\n                document.activeElement\n                    ?.getAttribute('data-test')\n                    ?.startsWith('line-handle');\n\n            if (\n                (selectedLineItems.length === 0 &&\n                    selectedBlockItems.length === 0) ||\n                mode !== 'edit' ||\n                isResizeHandleFocused ||\n                isLineHandleFocused\n            ) {\n                return;\n            }\n\n            const updatedLayoutStructure = updateLayoutStructureOnKeyboardMove({\n                selectedBlockItems,\n                selectedLineItems,\n                dir,\n                snap,\n                gridSize: GRID_SIZE,\n                layoutStructure: layoutStructureRef.current,\n            });\n\n            onLayoutStructureChange(updatedLayoutStructure);\n\n            preventDefault();\n        },\n        [mode, onLayoutStructureChange, selectedItems]\n    );\n\n    const handleLayoutStructureChange = useCallback(\n        (newLayoutStructure: LayoutStructureState) => {\n            const updatedLayoutStructure = layoutStructureRef.current.map(\n                (item) => newLayoutStructure[item.item] ?? item\n            );\n\n            onLayoutStructureChange(updatedLayoutStructure);\n        },\n        [onLayoutStructureChange]\n    );\n\n    const calculateLineMove = useCallback(\n        (offset: Offset) => {\n            const selectedLineItems = findSelectedLineItems({\n                layoutStructure: layoutStructureRef.current,\n                selectedItems,\n            });\n\n            if (selectedLineItems.length === 0) {\n                return undefined;\n            }\n\n            const lineId = selectedLineItems[0].item;\n\n            return handleSingleLineMove({\n                layoutStructure: layoutStructureRef.current,\n                lineId,\n                offset,\n            });\n        },\n        [selectedItems]\n    );\n\n    const handleLineMove = useCallback(\n        (_e: unknown, offset: Offset) => {\n            const lineItem = calculateLineMove(offset);\n\n            if (typeof lineItem === 'undefined') {\n                return;\n            }\n\n            dispatch({\n                type: 'lineMove',\n                payload: lineItem,\n            });\n        },\n        [calculateLineMove]\n    );\n\n    const handleLineMoved = useCallback(\n        (_e: unknown, offset: Offset) => {\n            const lineItem = calculateLineMove(offset);\n\n            if (typeof lineItem === 'undefined') {\n                handleLayoutStructureChange(layoutStructureState);\n                return;\n            }\n\n            const newLayoutStructure = reducer(layoutStructureState, {\n                type: 'lineMove',\n                payload: lineItem,\n            });\n\n            handleLayoutStructureChange(newLayoutStructure);\n        },\n        [calculateLineMove, handleLayoutStructureChange, layoutStructureState]\n    );\n\n    const handleLineDragStart = useCallback(\n        (_e: unknown, dir: LineDirection) => {\n            const selectedLineItems = findSelectedLineItems({\n                layoutStructure: layoutStructureRef.current,\n                selectedItems,\n            });\n\n            if (selectedLineItems.length !== 1) {\n                return;\n            }\n\n            const lineId = selectedLineItems[0].item;\n\n            const line = handleSingleLineDragStart({\n                lineId,\n                layoutStructure: layoutStructureRef.current,\n                lineDir: dir,\n            });\n\n            dispatch({\n                type: 'lineDragStart',\n                payload: line,\n            });\n\n            activeLine.current = { id: lineId, dir };\n        },\n        [selectedItems]\n    );\n\n    const calculateLineDrag = useCallback((offset: Offset) => {\n        if (!activeLine.current) {\n            return undefined;\n        }\n\n        const line = layoutStructureRef.current.find(\n            (item) => item.item === activeLine.current?.id\n        ) as ConnectedLineItem;\n\n        const absPos = computeLineAbsPosition({\n            layoutStructure: layoutStructureRef.current,\n            position: line.position,\n        })[activeLine.current.dir];\n\n        // line should already been disconnect in this case\n        return {\n            id: activeLine.current.id,\n            dir: activeLine.current.dir,\n            absPos: {\n                x: absPos.x + offset.offsetX,\n                y: absPos.y + offset.offsetY,\n            },\n        };\n    }, []);\n\n    const handleLineDrag = useCallback(\n        (_e: unknown, offset: Offset) => {\n            const lineItem = calculateLineDrag(offset);\n\n            if (typeof lineItem === 'undefined') {\n                return;\n            }\n\n            // line should already been disconnect in this case\n            dispatch({\n                type: 'lineDrag',\n                payload: lineItem,\n            });\n        },\n        [calculateLineDrag]\n    );\n\n    const handleLineDragged = useCallback(\n        (e: unknown, offset: Offset) => {\n            activeLine.current = null;\n\n            const lineItem = calculateLineDrag(offset);\n\n            if (typeof lineItem === 'undefined') {\n                handleLayoutStructureChange(layoutStructureState);\n                return;\n            }\n\n            const newLayoutStructure = reducer(layoutStructureState, {\n                type: 'lineDrag',\n                payload: lineItem,\n            });\n\n            handleLayoutStructureChange(newLayoutStructure);\n        },\n        [calculateLineDrag, handleLayoutStructureChange, layoutStructureState]\n    );\n\n    const handleLineConnected = useCallback((itemId: string, port: Port) => {\n        if (!activeLine.current) {\n            return;\n        }\n\n        const lineId = activeLine.current.id;\n\n        dispatch({\n            type: 'lineConnect',\n            payload: {\n                lineId,\n                lineDir: activeLine.current.dir,\n                itemId,\n                port,\n            },\n        });\n    }, []);\n\n    const handleLineDisconnected = useCallback(() => {\n        if (!activeLine.current) {\n            return;\n        }\n\n        dispatch({\n            type: 'lineDisconnect',\n            payload: {\n                lineId: activeLine.current.id,\n                lineDir: activeLine.current.dir,\n            },\n        });\n    }, []);\n\n    const handleItemSelected = useCallback(\n        (\n            _e: unknown,\n            newSelectedItems: SelectedItem[] = emptySelectedItems\n        ) => {\n            onLayoutItemsSelect(newSelectedItems);\n        },\n        [onLayoutItemsSelect]\n    );\n\n    const calculateBlockItemResize = useCallback(\n        (itemId: string, offset: Offset, dir: HandleDirection) => {\n            const item = layoutStructureRef.current.find(\n                (itm) => itm.item === itemId\n            ) as AbsoluteBlockItem;\n\n            const snapOffset = snapOffsetToWH({\n                position: item.position,\n                offset,\n                gridWidth: GRID_SIZE,\n                gridHeight: GRID_SIZE,\n                spacing: 0,\n                padding: 0,\n            });\n\n            const newItem = updateBlockItemSize({\n                item,\n                offset: snapOffset,\n                dir,\n                options: {\n                    minHeight: MIN_HEIGHT,\n                    minWidth: MIN_WIDTH,\n                },\n            });\n\n            // check if the item actually changed size\n            if (\n                isEqual(\n                    newItem.position,\n                    layoutStructureState[newItem.item].position\n                )\n            ) {\n                return undefined;\n            }\n\n            return newItem;\n        },\n        [layoutStructureState]\n    );\n\n    const handleBlockItemResize = useCallback(\n        (_e: unknown, itemId: string, offset: Offset, dir: HandleDirection) => {\n            // start measuring item resize\n            const newItem = calculateBlockItemResize(itemId, offset, dir);\n\n            if (typeof newItem === 'undefined') {\n                return;\n            }\n\n            reduxDispatch(blockItemResize());\n\n            dispatch({\n                type: 'blockResize',\n                payload: newItem,\n            });\n        },\n        [calculateBlockItemResize, reduxDispatch]\n    );\n\n    const handleBlockItemResized = useCallback(\n        (_e: unknown, itemId: string, offset: Offset, dir: HandleDirection) => {\n            reduxDispatch(blockItemResized());\n\n            const newItem = calculateBlockItemResize(itemId, offset, dir);\n\n            if (typeof newItem === 'undefined') {\n                handleLayoutStructureChange(layoutStructureState);\n                return;\n            }\n\n            const newLayoutStructure = reducer(layoutStructureState, {\n                type: 'blockResize',\n                payload: newItem,\n            });\n\n            // if we get to here, it means the mousemove and mouseup were handled in the same tick, thus\n            //   we need the new structure and not the stale `layoutStructureState`.\n            handleLayoutStructureChange(newLayoutStructure);\n        },\n        [\n            calculateBlockItemResize,\n            handleLayoutStructureChange,\n            layoutStructureState,\n            reduxDispatch,\n        ]\n    );\n\n    const calculateBlockItemMove = useCallback(\n        (offset: Offset) => {\n            const selectedBlockItems = findSelectedBlockItems({\n                layoutStructure: layoutStructureRef.current,\n                selectedItems,\n            });\n\n            if (selectedBlockItems.length === 0) {\n                return undefined;\n            }\n\n            // use any block item to calculate the moveOffset\n            const firstBlockItem = selectedBlockItems[0];\n\n            const moveOffset = snapOffsetToXY({\n                position: firstBlockItem.position,\n                offset,\n                gridWidth: GRID_SIZE,\n                gridHeight: GRID_SIZE,\n                spacing: 0,\n                padding: 0,\n            });\n\n            const updatedSelectedBlockItems = selectedBlockItems.map(\n                (blockItem) => updateBlockItemPosition(blockItem, moveOffset)\n            );\n\n            // check if the items actually changed position since the last moveOffset\n            const firstUpdatedBlockItem = updatedSelectedBlockItems[0];\n\n            if (\n                isEqual(\n                    firstUpdatedBlockItem.position,\n                    layoutStructureState[firstUpdatedBlockItem.item].position\n                )\n            ) {\n                return undefined;\n            }\n\n            return updatedSelectedBlockItems;\n        },\n        [layoutStructureState, selectedItems]\n    );\n\n    const handleBlockItemMove = useCallback(\n        (_e: unknown, offset: Offset) => {\n            const updatedSelectedBlockItems = calculateBlockItemMove(offset);\n\n            if (typeof updatedSelectedBlockItems === 'undefined') {\n                return;\n            }\n\n            reduxDispatch(blockItemMove());\n\n            dispatch({\n                type: 'blocksMove',\n                payload: updatedSelectedBlockItems,\n            });\n        },\n        [calculateBlockItemMove, reduxDispatch]\n    );\n\n    const handleBlockItemMoved = useCallback(\n        (_e: unknown, offset: Offset) => {\n            const numVisualizationsMoved = selectedItems.length;\n            reduxDispatch(blockItemMoved({ numVisualizationsMoved }));\n\n            const updatedSelectedBlockItems = calculateBlockItemMove(offset);\n\n            // if calculateBlockItemMove returns undefined, it likely means that\n            //   the last move was processed, and thus there is no offset from the last move,\n            //   meaning that there was no change. In that case, commit the last state because it's the latest\n            if (typeof updatedSelectedBlockItems === 'undefined') {\n                handleLayoutStructureChange(layoutStructureState);\n                return;\n            }\n\n            const newLayoutStructure = reducer(layoutStructureState, {\n                type: 'blocksMove',\n                payload: updatedSelectedBlockItems,\n            });\n\n            // if we get to here, it means the mousemove and mouseup were handled in the same tick, thus\n            //   we need the new structure and not the stale `layoutStructureState`.\n            handleLayoutStructureChange(newLayoutStructure);\n        },\n        [\n            calculateBlockItemMove,\n            handleLayoutStructureChange,\n            layoutStructureState,\n            reduxDispatch,\n            selectedItems.length,\n        ]\n    );\n\n    // todo: we should memoize the return value\n    const blockItems = useMemo(\n        () =>\n            layoutStructure\n                .filter((item) => isBlockItem(item))\n                .map(\n                    (block) => layoutStructureState[block.item] ?? block\n                ) as AbsoluteBlockItem[],\n        [layoutStructure, layoutStructureState]\n    );\n\n    const lineItems = useMemo(\n        () =>\n            layoutStructure\n                .filter(({ type }) => type === 'line')\n                .map(\n                    (line) => layoutStructureState[line.item] ?? line\n                ) as ConnectedLineItem[],\n        [layoutStructure, layoutStructureState]\n    );\n\n    const optionsRef = useRef(props.options);\n    optionsRef.current = props.options;\n\n    // reset the state when the layoutStructure changes, this handles the case like undo/redo\n    useEffect(() => {\n        if (!isEqual(layoutStructure, previousLayoutStructure)) {\n            dispatch({\n                type: 'reset',\n                payload: layoutStructure,\n            });\n        }\n    }, [layoutStructure, previousLayoutStructure]);\n\n    useEffect(() => {\n        if (!keyboardListener) {\n            return noop;\n        }\n\n        const unsubscribeMove = keyboardListener.subscribe(\n            'move',\n            handleKeyboardMove\n        );\n\n        return () => {\n            unsubscribeMove();\n        };\n    }, [handleKeyboardMove, keyboardListener]);\n\n    useEffect(() => {\n        if (!keyboardListener) {\n            return noop;\n        }\n\n        const unsubscribeCancel = keyboardListener.subscribe('cancel', () =>\n            handleItemSelected(null, [])\n        );\n\n        return () => {\n            unsubscribeCancel();\n        };\n    }, [handleItemSelected, keyboardListener]);\n\n    // update active line\n    useEffect(() => {\n        if (\n            activeLine.current &&\n            layoutStructureState[activeLine.current.id] == null\n        ) {\n            activeLine.current = null;\n        }\n    }, [layoutStructureState]);\n\n    const image = useMemo(\n        () =>\n            backgroundImage\n                ? validateBackgroundImage({\n                      backgroundImage,\n                      canvasWidth: width,\n                      canvasHeight: height,\n                  })\n                : {},\n        [backgroundImage, height, width]\n    );\n\n    const modeSpecificProps = useMemo(\n        () =>\n            mode === 'edit'\n                ? {\n                      movable: true,\n                      showOverflowContent: true,\n                      showGrid,\n                      showBorder: true,\n                      gridLineWidth: 1,\n                      gridPadding: GRID_PADDING,\n                      onItemMove: handleBlockItemMove,\n                      onItemMoved: handleBlockItemMoved,\n                      userSelect: false,\n                      allowMultiselect: true,\n                  }\n                : {\n                      movable: false,\n                      showOverflowContent: false,\n                      showGrid: false,\n                      showBorder: false,\n                      userSelect: true,\n                      allowMultiselect: false,\n                  },\n        [handleBlockItemMove, handleBlockItemMoved, mode, showGrid]\n    );\n\n    // Memoized block items\n    const allBlockItems = useMemo<AbsoluteBlockItem[]>(\n        () => getAllBlockItems({ layoutStructure, layoutStructureState }),\n        [layoutStructure, layoutStructureState]\n    );\n\n    const blockItemElements = useMemo(() => {\n        return allBlockItems.map(({ item, type, position: { x, y, w, h } }) => (\n            <ResponsiveBlockItem\n                key={item}\n                itemId={item}\n                type={type}\n                x={x}\n                y={y}\n                w={w}\n                h={h}\n                canvasHeight={height}\n                renderLayoutItem={renderLayoutItem}\n                onItemSelected={handleItemSelected}\n                isMouseDownEventRef={isMouseDownEventRef}\n            />\n        ));\n    }, [handleItemSelected, height, allBlockItems, renderLayoutItem]);\n\n    const lineElements = useMemo(() => {\n        const selectedLineItems = findSelectedLineItems({\n            layoutStructure,\n            selectedItems,\n        });\n        const selectable = mode === 'edit';\n\n        return lineItems.map((line) => {\n            // we don't support multiple select for line\n            const editable =\n                selectedLineItems.length === 1 &&\n                selectedLineItems[0].item === line.item &&\n                selectable;\n\n            let absPos = { from: { x: 0, y: 0 }, to: { x: 0, y: 0 } };\n            try {\n                absPos = computeLineAbsPosition({\n                    layoutStructure: Object.values(layoutStructureState),\n                    position: line.position,\n                });\n            } catch (err) {\n                // If computeLineAbsPosition threw an error due to a block item not\n                // existing then recompute with the layout structure as defined in\n                // the definition. This is possible if a line is anchored to a port\n                // on a block item which was hidden due to a show/hide configuration\n                if (\n                    err instanceof Error &&\n                    err.message.endsWith(InvalidBlockItemError)\n                ) {\n                    absPos = computeLineAbsPosition({\n                        layoutStructure: rawLayoutStructure,\n                        position: line.position,\n                    });\n                }\n            }\n\n            const fromTestHooks =\n                'item' in line.position.from && 'port' in line.position.from\n                    ? {\n                          fromItem: line.position.from.item,\n                          fromPort: line.position.from.port,\n                      }\n                    : {};\n            const toTestHooks =\n                'item' in line.position.to && 'port' in line.position.to\n                    ? {\n                          toItem: line.position.to.item,\n                          toPort: line.position.to.port,\n                      }\n                    : {};\n\n            return (\n                <ResponsiveLine\n                    key={line.item}\n                    lineId={line.item}\n                    scale={scale}\n                    selectable={selectable}\n                    editable={editable}\n                    renderLayoutItem={renderLayoutItem}\n                    onLineMove={handleLineMove}\n                    onLineMoved={handleLineMoved}\n                    onLineDragStart={handleLineDragStart}\n                    onLineDrag={handleLineDrag}\n                    onLineDragged={handleLineDragged}\n                    onItemSelected={handleItemSelected}\n                    fromX={absPos.from.x}\n                    fromY={absPos.from.y}\n                    toX={absPos.to.x}\n                    toY={absPos.to.y}\n                    {...fromTestHooks}\n                    {...toTestHooks}\n                />\n            );\n        });\n    }, [\n        handleItemSelected,\n        handleLineDrag,\n        handleLineDragStart,\n        handleLineDragged,\n        handleLineMove,\n        handleLineMoved,\n        rawLayoutStructure,\n        layoutStructure,\n        layoutStructureState,\n        lineItems,\n        mode,\n        renderLayoutItem,\n        scale,\n        selectedItems,\n    ]);\n\n    const outlineElements = useMemo(() => {\n        const selectedLineItems = findSelectedLineItems({\n            layoutStructure: Object.values(layoutStructureState),\n            selectedItems,\n        });\n        const selectedBlockItems = findSelectedBlockItems({\n            layoutStructure: Object.values(layoutStructureState),\n            selectedItems,\n        });\n\n        return allBlockItems.map((block) => {\n            // current outline has 3 state\n            // 1. If only one line is selected and actively been dragging, set outline to connectable\n            // outline will display connect port in this case and fire onLineConnect/onLineDisconnect callback\n            const connectable =\n                mode === 'edit' &&\n                selectedBlockItems.length === 0 &&\n                selectedLineItems.length === 1 &&\n                activeLine != null;\n\n            // 2. If this is the only block item been selected, set outline to resizable\n            // in this case outline will display resize handle and fire onResize/onResized callback\n            const resizable =\n                mode === 'edit' &&\n                selectedBlockItems.length === 1 &&\n                selectedBlockItems[0].item === block.item;\n\n            // 3. current block item is selected or active, just display the outline\n            const selected =\n                selectedBlockItems.findIndex((b) => b.item === block.item) >= 0;\n\n            if (!connectable && !resizable && !selected) {\n                return null;\n            }\n\n            const definition = DashboardDefinition.fromJSON(\n                dashboardApi?.getDefinition()\n            );\n\n            const itemPresetType = definition.getItemPresetType(block.item);\n\n            const handleDirections =\n                preset.getResizeHandleDirections(itemPresetType);\n\n            return (\n                <ResponsiveBlockOutline\n                    key={block.item}\n                    itemId={block.item}\n                    x={block.position.x}\n                    y={block.position.y}\n                    w={block.position.w}\n                    h={block.position.h}\n                    scale={scale}\n                    connectable={connectable}\n                    resizable={resizable}\n                    onResize={handleBlockItemResize}\n                    onResized={handleBlockItemResized}\n                    onLineConnect={handleLineConnected}\n                    onLineDisconnect={handleLineDisconnected}\n                    handleDirections={handleDirections}\n                />\n            );\n        });\n    }, [\n        layoutStructureState,\n        selectedItems,\n        allBlockItems,\n        mode,\n        activeLine,\n        dashboardApi,\n        preset,\n        scale,\n        handleBlockItemResize,\n        handleBlockItemResized,\n        handleLineConnected,\n        handleLineDisconnected,\n    ]);\n\n    // The following functions are used to capture click events in order to differentiate\n    //  between gaining focus via tab or click.\n    const handleMouseDownCapture = useCallback(() => {\n        isMouseDownEventRef.current = true;\n    }, []);\n    const handleMouseUpCapture = useCallback(() => {\n        isMouseDownEventRef.current = false;\n    }, []);\n\n    return (\n        <AbsoluteCanvas\n            data-test=\"absolute-layout\"\n            blockItems={blockItems}\n            width={width}\n            height={height}\n            scale={scale}\n            // can someone tell me why the original implementation had this magic number minus one?\n            gridWidth={GRID_SIZE - 1}\n            gridHeight={GRID_SIZE - 1}\n            backgroundColor={backgroundColor}\n            backgroundImageSrc={image.src}\n            backgroundImageSizeType={image.sizeType}\n            backgroundImageWidth={image.w}\n            backgroundImageHeight={image.h}\n            backgroundImagePositionX={image.x}\n            backgroundImagePositionY={image.y}\n            backgroundImageOpacity={image.opacity}\n            selectedLayoutItems={selectedItems}\n            onItemSelected={handleItemSelected}\n            ref={canvasRef}\n            onMouseDownCapture={handleMouseDownCapture}\n            onMouseUpCapture={handleMouseUpCapture}\n            {...modeSpecificProps}\n        >\n            <Layer\n                key=\"block-item-layer\"\n                data-test=\"block-item-layer\"\n                zIndex={0}\n            >\n                {/* render lines at the start of block-item-layer so they are correctly placed behind\n                action menus, even if they share the z-index with the back-most action menu */}\n                {lineElements}\n                {blockItemElements.map((el, i) => (\n                    <React.Fragment key={el.key}>\n                        {el}\n                        <Layer key=\"outline-layer\" data-test=\"outline-layer\">\n                            {outlineElements[i]}\n                        </Layer>\n                    </React.Fragment>\n                ))}\n            </Layer>\n        </AbsoluteCanvas>\n    );\n};\n\nexport default withLayoutShowHide(AbsoluteLayout, {\n    schema: absoluteLayoutOptionsSchema,\n});\n", "import React, { useMemo } from 'react';\nimport type {\n    ConnectedLineItem,\n    AbsoluteBlockItem,\n    AbsoluteLayoutOptions,\n    AbsoluteLayoutStructure,\n    BaseLayoutProps,\n} from '@splunk/dashboard-types';\nimport { getScrollbarWidth } from '@splunk/dashboard-utils';\nimport { AbsoluteItem, Canvas, ResponsiveLine } from './components';\nimport { absoluteLayoutOptions } from './DefaultOptions';\nimport { validateBackgroundImage } from './utils/imageUtils';\nimport { computeScaleToFit } from './utils/layoutUtils';\nimport { computeLineAbsPosition } from './utils/lineUtils';\n\nexport type AbsoluteLayoutViewerProps = Pick<\n    BaseLayoutProps<AbsoluteLayoutStructure, AbsoluteLayoutOptions>,\n    | 'containerWidth'\n    | 'containerHeight'\n    | 'renderLayoutItem'\n    | 'options'\n    | 'layoutStructure'\n>;\n\nconst defaultLayoutStructure: AbsoluteLayoutViewerProps['layoutStructure'] = [];\nconst defaultOptions: AbsoluteLayoutViewerProps['options'] =\n    absoluteLayoutOptions;\n\nconst AbsoluteLayoutViewer = ({\n    containerWidth,\n    containerHeight,\n    layoutStructure = defaultLayoutStructure,\n    renderLayoutItem,\n    options = defaultOptions,\n}: AbsoluteLayoutViewerProps): JSX.Element => {\n    const {\n        width,\n        height,\n        backgroundColor,\n        backgroundImage = {},\n        display,\n    } = {\n        ...absoluteLayoutOptions,\n        ...options,\n    };\n\n    const scrollbarWidth = useMemo(() => getScrollbarWidth(), []);\n\n    const scale = useMemo(() => {\n        switch (display) {\n            case 'fit-to-width':\n            case 'auto-scale':\n                return computeScaleToFit({\n                    canvasWidth: width,\n                    canvasHeight: height,\n                    containerWidth,\n                    containerHeight,\n                    scrollbarWidth,\n                });\n            case 'actual-size':\n                return 1;\n            default:\n                return computeScaleToFit({\n                    canvasWidth: width,\n                    canvasHeight: height,\n                    containerWidth,\n                    containerHeight,\n                    scrollbarWidth,\n                    max: 1,\n                });\n        }\n    }, [\n        display,\n        height,\n        width,\n        containerWidth,\n        containerHeight,\n        scrollbarWidth,\n    ]);\n    const image = useMemo(\n        () =>\n            backgroundImage\n                ? validateBackgroundImage({\n                      backgroundImage,\n                      canvasWidth: width,\n                      canvasHeight: height,\n                  })\n                : {},\n        [backgroundImage, height, width]\n    );\n\n    const renderLines = useMemo(() => {\n        // TODO: replace with getAllLineItems() from lineUtils after AbsLayout refactor is merged\n        const lineItems = layoutStructure.filter(\n            ({ type }) => type === 'line'\n        ) as ConnectedLineItem[];\n        return lineItems.map(({ item, position }) => {\n            const absPosition = computeLineAbsPosition({\n                layoutStructure,\n                position,\n            });\n            return (\n                <ResponsiveLine\n                    key={item}\n                    lineId={item}\n                    scale={scale}\n                    fromX={absPosition.from.x}\n                    toX={absPosition.to.x}\n                    fromY={absPosition.from.y}\n                    toY={absPosition.to.y}\n                    renderLayoutItem={renderLayoutItem}\n                />\n            );\n        });\n    }, [layoutStructure, scale, renderLayoutItem]);\n\n    const renderBlockItems = useMemo(() => {\n        // TODO: replace with getAllBlockItems() from lineUtils after AbsLayout refactor is merged\n        const blockItems = layoutStructure.filter(\n            ({ type }) => type !== 'line'\n        ) as AbsoluteBlockItem[];\n        return blockItems.map(({ item, type, position }) => {\n            const { x, y, w, h } = position;\n            return (\n                <AbsoluteItem\n                    itemId={item}\n                    type={type}\n                    key={item}\n                    x={x}\n                    y={y}\n                    w={w}\n                    h={h}\n                    renderLayoutItem={renderLayoutItem}\n                />\n            );\n        });\n    }, [renderLayoutItem, layoutStructure]);\n\n    return (\n        <Canvas\n            data-layout-type=\"absolute\"\n            width={width}\n            height={height}\n            scale={scale}\n            showGrid={false}\n            backgroundColor={backgroundColor}\n            backgroundImageSrc={image.src}\n            backgroundImageSizeType={image.sizeType}\n            backgroundImageWidth={image.w}\n            backgroundImageHeight={image.h}\n            backgroundImagePositionX={image.x}\n            backgroundImagePositionY={image.y}\n            backgroundImageOpacity={image.opacity}\n        >\n            {renderBlockItems}\n            {renderLines}\n        </Canvas>\n    );\n};\n\nexport default AbsoluteLayoutViewer;\n", "\nimport * as defaultImport from \"memoize-one\";\nexport * from \"memoize-one\";\nexport default ('default' in defaultImport ? defaultImport.default : defaultImport);\n", "\nimport * as defaultImport from \"@splunk/dashboard-telemetry\";\nexport * from \"@splunk/dashboard-telemetry\";\nexport default ('default' in defaultImport ? defaultImport.default : defaultImport);\n", "import { namedColors } from '@splunk/dashboard-ui';\nimport { COLOR_PATTERN_WITH_RGBA_AND_TOKEN } from '@splunk/dashboard-definition';\n\nexport default {\n    gutterSize: {\n        type: 'number',\n        default: 8,\n        minimum: 8,\n        maximum: 16,\n        description:\n            'A number that represents the size of the gutter between visualizations in pixels. The minimum value is 8 and maximum value is 16.',\n    },\n    backgroundColor: {\n        type: 'string',\n        description: `Specify the color of the layout background using a hex code, rgb/rgba value, an HTML color name, or a token`,\n        anyOf: [\n            { enum: namedColors },\n            { pattern: COLOR_PATTERN_WITH_RGBA_AND_TOKEN },\n        ],\n    },\n};\n", "import type {\n    AbsoluteBlockItem,\n    GridLayoutStructure,\n    SelectedItem,\n} from '@splunk/dashboard-types';\n\n// TODO: Possibly: { blockItems, edges, ... }\nexport type MappedGridLayout = Record<string, AbsoluteBlockItem>;\n\n// Seems expensive, needs multi-block update\ntype ResetStructureAction = {\n    type: 'structure/reset';\n    payload: GridLayoutStructure;\n};\n\ntype UpdateItemAction = {\n    type: 'structure/update';\n    payload: AbsoluteBlockItem;\n};\nexport const resetLayoutAction = (\n    payload: GridLayoutStructure\n): ResetStructureAction => ({\n    type: 'structure/reset',\n    payload,\n});\n\nexport const updateItemAction = (\n    payload: AbsoluteBlockItem\n): UpdateItemAction => ({\n    type: 'structure/update',\n    payload,\n});\n\nexport type GridActions = ResetStructureAction | UpdateItemAction;\n\nexport const getBlockItems = (state: MappedGridLayout): GridLayoutStructure =>\n    Object.values(state);\n\nexport const filterSelectedItems = (\n    state: GridLayoutStructure,\n    selectedItems: SelectedItem[] = []\n): SelectedItem[] => {\n    const itemKeys = state.map(({ item }) => item);\n    return selectedItems.filter(({ id }) => itemKeys.indexOf(id) >= 0);\n};\n\nexport const getItemKeys = (state: MappedGridLayout): string[] =>\n    Object.keys(state);\n\nexport const getStructureItem = (\n    state: GridLayoutStructure,\n    itemId: string\n): AbsoluteBlockItem =>\n    state.find(({ item }) => item === itemId) as AbsoluteBlockItem;\n\nexport const getItem = (\n    state: MappedGridLayout,\n    itemId: string\n): AbsoluteBlockItem => state[itemId];\n\nexport const hasPreviewItem = (\n    state: MappedGridLayout,\n    itemId = 'preview-old-item'\n): boolean => !!state[itemId];\n\n/**\n * Filter out any items not appearing in layoutStructure as they are currently unknown\n * Add any new items in layoutStructure, keep preview items\n * @param {MappedGridLayout} state reducer state\n * @param {GridLayoutStructure} layoutStructure current known state\n * @returns {GridLayoutStructure} filtered state\n */\nexport const getFilteredStructure = (\n    state: MappedGridLayout,\n    layoutStructure: GridLayoutStructure\n): GridLayoutStructure => {\n    const result: GridLayoutStructure = [];\n    layoutStructure.forEach((item) => {\n        result.push(state[item.item] || item);\n    });\n\n    if (hasPreviewItem(state)) {\n        result.push(state['preview-old-item']);\n    }\n\n    return result;\n};\n\n// Reducer\nexport const initializeGridReducer = (\n    layoutStructure: GridLayoutStructure = []\n): MappedGridLayout => {\n    const gridLayout: MappedGridLayout = {};\n    layoutStructure.forEach((item) => {\n        gridLayout[item.item] = item;\n    });\n    return gridLayout;\n};\n\n// TODO: reducer should probably intelligently handle other pieces of content (e.g. edges) and have additional dispatches to handle resize, move, etc\n// TODO: reducer should handle updating multiple items, instead of a complete replacement of state (structure/reset should be a last resort)\nexport const gridReducer = (\n    state: MappedGridLayout,\n    action: GridActions\n): MappedGridLayout => {\n    switch (action.type) {\n        // TODO: handle more actions (above), to further reduce size of grid code\n        // TODO: expand set of reduced state, to limit amount of non-layout data tracked in layout component\n        case 'structure/reset':\n            return initializeGridReducer(action.payload);\n        case 'structure/update':\n            return {\n                ...state,\n                [action.payload.item]: action.payload,\n            };\n        default:\n            return state;\n    }\n};\n", "import type { AbsoluteBlockItem, Coordinate } from '@splunk/dashboard-types';\n\nimport { getNodes } from './edgeUtils';\nimport type { Intersections } from './edgeUtils';\n\nexport type SplitGridEntry = {\n    // nodes provided as argument\n    nodes: Intersections;\n    // layout provided as argument\n    layout: AbsoluteBlockItem[];\n    // horizontal distance from origin.x to row/column right edge\n    gridWidth: number;\n    // vertical distance from origin.y to row/column bottom edge\n    gridHeight: number;\n    // (X, Y) of top-left corner of row/column\n    origin: Coordinate;\n    content: {\n        // width of just the row or column\n        width: number;\n        // height of just the row or column\n        height: number;\n        // items comprising the row or column\n        items: AbsoluteBlockItem[];\n    };\n};\n\nexport type SplitGrid = SplitGridEntry[];\n\ntype ItemXPos = number;\ntype ItemYPos = number;\nexport type ItemCoordinateMap = Record<\n    ItemYPos,\n    Record<ItemXPos, AbsoluteBlockItem>\n>;\n\nexport const trackItemsByCoordinate = (\n    layout: AbsoluteBlockItem[]\n): ItemCoordinateMap => {\n    const result: ItemCoordinateMap = {};\n\n    // Create a mapping which can be used to get block items given an X and/or Y coordinate\n    layout.forEach((item) => {\n        result[item.position.y] ??= {};\n        result[item.position.y][item.position.x] = item;\n    });\n\n    return result;\n};\n\nexport const getItemsInCoordinateRange = ({\n    itemCoordinateMap,\n    range,\n}: {\n    itemCoordinateMap: ItemCoordinateMap;\n    range?: {\n        from?: Partial<Coordinate>;\n        to?: Partial<Coordinate>;\n    };\n}): AbsoluteBlockItem[] => {\n    if (!range) {\n        return Object.values(itemCoordinateMap).flatMap(Object.values);\n    }\n\n    const { x: fromX = 0, y: fromY = 0 } = range.from || {};\n    const {\n        x: toX = Number.POSITIVE_INFINITY,\n        y: toY = Number.POSITIVE_INFINITY,\n    } = range.to || {};\n\n    return Object.keys(itemCoordinateMap)\n        .map((key) => parseInt(key, 10)) // Object.keys returns strings. Convert to numbers for comparisons\n        .filter((yPos) => yPos >= fromY && yPos < toY) // Filter to only [fromY..toY)\n        .reduce((acc, yPos) => {\n            Object.keys(itemCoordinateMap[yPos]).forEach((key) => {\n                const xPos = parseInt(key, 10); // Object.keys returns strings. Convert to numbers\n                if (xPos >= fromX && xPos < toX) {\n                    acc.push(itemCoordinateMap[yPos][xPos]); // Track if in range [fromX..toX)\n                }\n            });\n\n            return acc;\n        }, [] as AbsoluteBlockItem[]);\n};\n\nconst getVizAtCoord = ({\n    x,\n    y,\n    nodes,\n    prevVizId,\n}: {\n    x: number;\n    y: number;\n    nodes: Intersections;\n    prevVizId?: string;\n}) =>\n    nodes[x][y].find(\n        (viz) =>\n            viz.position.x === x &&\n            viz.position.y === y &&\n            prevVizId !== viz.item\n    );\n\nconst isFullEdge = ({\n    x,\n    y,\n    nodes,\n    gridWidth,\n    gridHeight,\n    type,\n}: {\n    x: number;\n    y: number;\n    nodes: Intersections;\n    gridWidth: number;\n    gridHeight: number;\n    type: 'horizontal' | 'vertical';\n}): boolean => {\n    // base case, we've reached the end of the edge and it spans across entire grid\n    //   or we're checking the EDGE of the grid, which by definition spans entire grid\n    if (x === gridWidth || y === gridHeight) {\n        return true;\n    }\n\n    const originViz = getVizAtCoord({ x, y, nodes });\n    // if no viz at the next X, it means we've hit dead end before reaching the gridWidth\n    if (!originViz) {\n        return false;\n    }\n\n    // keep traversing right OR down\n    return isFullEdge({\n        x: type === 'horizontal' ? x + originViz.position.w : x,\n        y: type === 'vertical' ? y + originViz.position.h : y,\n        nodes,\n        gridWidth,\n        gridHeight,\n        type,\n    });\n};\n\nexport const splitGridByRows = ({\n    nodes,\n    layout,\n    gridWidth,\n    gridHeight,\n    originViz,\n    alwaysIncludeLastRow = false,\n}: {\n    nodes: Intersections;\n    layout: AbsoluteBlockItem[];\n    gridWidth: number;\n    gridHeight: number;\n    originViz: AbsoluteBlockItem;\n    alwaysIncludeLastRow?: boolean;\n}): SplitGrid => {\n    const { x, y, h } = originViz.position;\n\n    const itemCoordinateMap = trackItemsByCoordinate(layout);\n\n    const newGrids: SplitGrid = [];\n    let lastHorizontalEdgeY = y;\n    let nextViz = getVizAtCoord({ x, y: y + h, nodes });\n    while (nextViz && nextViz.position.y < gridHeight) {\n        if (\n            isFullEdge({\n                x,\n                y: nextViz.position.y,\n                nodes,\n                gridWidth,\n                gridHeight,\n                type: 'horizontal',\n            })\n        ) {\n            // Given the top and bottom of the row split get the grid content within\n            // that range so the newGrids array entry also includes contained items\n            const rowItems = getItemsInCoordinateRange({\n                itemCoordinateMap,\n                range: {\n                    from: { y: lastHorizontalEdgeY },\n                    to: { y: nextViz.position.y },\n                },\n            });\n\n            newGrids.push({\n                nodes,\n                layout,\n                gridWidth,\n                gridHeight: nextViz.position.y,\n                origin: { x, y: lastHorizontalEdgeY },\n                content: {\n                    // the width of the split is the full grid width less the origin of the split\n                    width: gridWidth - x,\n                    // the height of the split is the top of the next split less the origin of the current split\n                    height: nextViz.position.y - lastHorizontalEdgeY,\n                    items: rowItems,\n                },\n            });\n\n            lastHorizontalEdgeY = nextViz.position.y;\n        }\n        nextViz = getVizAtCoord({\n            x,\n            y: nextViz.position.y + nextViz.position.h,\n            nodes,\n            prevVizId: nextViz.item,\n        });\n    }\n\n    // include the last row in order to capture the case when there is only one row in the current column\n    //   otherwise the row does not get included. This is needed for `getContainingRowColumn` which needs the row\n    //   included. Other parts of the code that call this function do not need it because their logic splits it into both rows and columns\n    //   and so if the items aren't captured in the \"row\" then they will be captured in the columns\n    if (newGrids.length === 0 && !alwaysIncludeLastRow) {\n        // if no grids have been added, don't add the special case, return instead.\n        return [];\n    }\n\n    // Get any remaining items for the last row of the split grid\n    const lastRowItems = getItemsInCoordinateRange({\n        itemCoordinateMap,\n        range: {\n            from: { y: lastHorizontalEdgeY },\n        },\n    });\n\n    // special case to handle the last row (the bottom grid edge)\n    newGrids.push({\n        nodes,\n        layout,\n        gridWidth,\n        gridHeight,\n        origin: { x, y: lastHorizontalEdgeY },\n        content: {\n            width: gridWidth - x,\n            height: gridHeight - lastHorizontalEdgeY,\n            items: lastRowItems,\n        },\n    });\n\n    return newGrids;\n};\n\nexport const splitGridByColumns = ({\n    nodes,\n    layout,\n    gridWidth,\n    gridHeight,\n    originViz,\n}: {\n    nodes: Intersections;\n    layout: AbsoluteBlockItem[];\n    gridWidth: number;\n    gridHeight: number;\n    originViz: AbsoluteBlockItem;\n}): SplitGrid => {\n    const { x, y, w } = originViz.position;\n\n    const itemCoordinateMap = trackItemsByCoordinate(layout);\n\n    const newGrids: SplitGrid = [];\n    let lastVerticalEdgeX = x;\n    // the next visualization to the right of origin\n    let nextViz = getVizAtCoord({ x: x + w, y, nodes });\n    while (nextViz && nextViz.position.x < gridWidth) {\n        // if the edge starting from the nextViz goes all the way down, it's a full grid edge\n        if (\n            isFullEdge({\n                x: nextViz.position.x,\n                y,\n                nodes,\n                gridWidth,\n                gridHeight,\n                type: 'vertical',\n            })\n        ) {\n            // Given the left and right of the column split get the grid content within\n            // that range so the newGrids array entry also includes contained items\n            const colItems = getItemsInCoordinateRange({\n                itemCoordinateMap,\n                range: {\n                    from: { x: lastVerticalEdgeX },\n                    to: { x: nextViz.position.x },\n                },\n            });\n\n            newGrids.push({\n                nodes,\n                layout,\n                gridWidth: nextViz.position.x,\n                gridHeight,\n                origin: { x: lastVerticalEdgeX, y },\n                content: {\n                    // the width of the split is the left-edge of the next column less the origin of the current column\n                    width: nextViz.position.x - lastVerticalEdgeX,\n                    // the height of the split is the height of the grid less the origin of the column\n                    height: gridHeight - y,\n                    items: colItems,\n                },\n            });\n            lastVerticalEdgeX = nextViz.position.x;\n        }\n        nextViz = getVizAtCoord({\n            x: nextViz.position.x + nextViz.position.w,\n            y,\n            nodes,\n            prevVizId: nextViz.item,\n        });\n    }\n\n    if (newGrids.length === 0) {\n        // if no grids have been added, don't add the special case, return instead.\n        return [];\n    }\n\n    // Get any remaining items for the last column of the split grid\n    const lastColumnItems = getItemsInCoordinateRange({\n        itemCoordinateMap,\n        range: {\n            from: { x: lastVerticalEdgeX },\n        },\n    });\n\n    // special case to handle the last column (the right-most grid edge)\n    newGrids.push({\n        nodes,\n        layout,\n        gridWidth,\n        gridHeight,\n        origin: { x: lastVerticalEdgeX, y },\n        content: {\n            width: gridWidth - lastVerticalEdgeX,\n            height: gridHeight - y,\n            items: lastColumnItems,\n        },\n    });\n\n    return newGrids;\n};\n\nconst splitGridByRowsAndColumns = ({\n    origin,\n    nodes,\n    layout,\n    newLayout,\n    gridWidth,\n    gridHeight,\n}: {\n    origin: { x: number; y: number };\n    nodes: Intersections;\n    layout: AbsoluteBlockItem[];\n    newLayout: AbsoluteBlockItem[];\n    gridWidth: number;\n    gridHeight: number;\n}) => {\n    // the viz that exists at exactly at the origin\n    const originViz = getVizAtCoord({ x: origin.x, y: origin.y, nodes });\n    if (!originViz) {\n        throw new Error('Getting grid layout order failed');\n    }\n\n    // base recursion case: if the visualization IS the entire grid\n    if (\n        originViz.position.x + originViz.position.w === gridWidth &&\n        originViz.position.y + originViz.position.h === gridHeight\n    ) {\n        newLayout.push(originViz);\n        return;\n    }\n\n    // split by rows first\n    let newGrids = splitGridByRows({\n        nodes,\n        layout,\n        originViz,\n        gridHeight,\n        gridWidth,\n    });\n    newGrids.forEach((gridInfo) =>\n        splitGridByRowsAndColumns({ ...gridInfo, newLayout })\n    );\n\n    // we either split into rows OR columns, not both\n    if (newGrids.length > 0) {\n        return;\n    }\n\n    // only if no splits were caused by the rows do we want to split by columns (due to window case)\n    newGrids = splitGridByColumns({\n        nodes,\n        layout,\n        originViz,\n        gridHeight,\n        gridWidth,\n    });\n    newGrids.forEach((gridInfo) =>\n        splitGridByRowsAndColumns({ ...gridInfo, newLayout })\n    );\n\n    // edge case: the grid is an irregular grid, aka has NO rows or columns and thus cannot split at all\n    if (newGrids.length === 0) {\n        const vizInCurrentGrid: AbsoluteBlockItem[] = [];\n        // get all the visualizations contained in the current grid\n        layout.forEach((viz) => {\n            const { x, y, w, h } = viz.position;\n            if (\n                x >= origin.x &&\n                x + w <= gridWidth &&\n                y >= origin.y &&\n                y + h <= gridHeight\n            ) {\n                vizInCurrentGrid.push(viz);\n            }\n        });\n\n        const sortedViz = vizInCurrentGrid.sort((viz1, viz2) => {\n            if (viz1.position.y < viz2.position.y) {\n                return -1;\n            }\n            if (viz1.position.y > viz2.position.y) {\n                return 1;\n            }\n            if (viz1.position.x < viz2.position.x) {\n                return -1;\n            }\n            if (viz1.position.x > viz2.position.x) {\n                return 1;\n            }\n            return 0;\n        });\n\n        // if the grid is irregular, sort by (x,y) instead\n        newLayout.push(...sortedViz);\n    }\n};\n\nexport const getGridLayoutOrder = ({\n    layout,\n    canvasWidth,\n    canvasHeight,\n}: {\n    layout: AbsoluteBlockItem[];\n    canvasWidth: number;\n    canvasHeight: number;\n}) => {\n    const nodes = getNodes(layout);\n    if (nodes === null || nodes[0] === undefined || nodes[0][0] === undefined) {\n        // When no visualizations in the layout structure\n        // OR when there is no visualization at (0,0), which this algorithm assumes\n        return layout;\n    }\n\n    const newLayout: AbsoluteBlockItem[] = [];\n\n    try {\n        splitGridByRowsAndColumns({\n            origin: { x: 0, y: 0 },\n            nodes,\n            layout,\n            newLayout,\n            gridWidth: canvasWidth,\n            gridHeight: canvasHeight,\n        });\n    } catch {\n        return layout;\n    }\n\n    if (newLayout.length !== layout.length) {\n        // an error occurred - return original layout\n        return layout;\n    }\n    return newLayout;\n};\n", "/**\n * This file is a central location for all shared utility functions related to Grid Layout.\n * If a certain function requires a dependency that lives in another utility file, then\n * that function should live here. If it does not have any dependencies, then it can live\n * in a separate utility file.\n */\n\nimport { isEmpty, isEqual } from 'lodash';\nimport { _ } from '@splunk/ui-utils/i18n';\nimport {\n    updateRemovedVizNeighbors,\n    isLeftNeighbor,\n    isRightNeighbor,\n    findHorizontalNeighbors,\n    isTopNeighbor,\n    isBottomNeighbor,\n} from '@splunk/dashboard-utils';\nimport type {\n    AbsoluteBlockItem,\n    Coordinate,\n    AbsolutePosition,\n} from '@splunk/dashboard-types';\n\nimport { updateBlockItemSize } from './layoutUtils';\nimport { MIN_WIDTH_PX, MIN_HEIGHT_PX } from '../GridLayoutConstants';\n\nimport type { EdgeItem, LayoutError, Quadrant } from '../types';\n\n/**\n * Return a wrapper for the edge, such that this wrapper fills the entire gutter between 2 viz\n * @param {Object} params\n * @param {EdgeItem} params.edge - The edge that this wrapper will go \"around\"\n * @param {Number} params.padding - The amount of padding between two visualizations\n * @returns {EdgeItem} - Formatted edge such that it fills the gutter space between two visualizations\n */\nexport const formatEdgeWrapper = ({\n    edge,\n    padding = 0,\n}: {\n    edge: EdgeItem;\n    padding?: number;\n}): EdgeItem => {\n    const wrapperStart: Coordinate = { ...edge.edgeStart };\n    const wrapperEnd: Coordinate = { ...edge.edgeEnd };\n    if (edge.orientation === 'horizontal') {\n        // Add padding to the ends of the edge, to make it line up with visualizations\n        wrapperStart.x += padding;\n        wrapperEnd.x -= padding;\n        // make edge y the top of the gutter (so that when thickness === 2*padding it will fill whole gutter)\n        wrapperStart.y -= padding;\n        wrapperEnd.y -= padding;\n    } else {\n        // Add padding to the ends of the edge, to make it line up with visualizations\n        wrapperStart.y += padding;\n        wrapperEnd.y -= padding;\n        // make edge x the left-most of the gutter (so that when thickness === 2*padding it will fill whole gutter)\n        wrapperStart.x -= padding;\n        wrapperEnd.x -= padding;\n    }\n\n    return { ...edge, edgeStart: wrapperStart, edgeEnd: wrapperEnd };\n};\n\nexport const getDimensions = ({\n    edge,\n    thickness,\n}: {\n    edge: EdgeItem;\n    thickness: number;\n}): { width: number; height: number } => {\n    return {\n        width:\n            edge.orientation === 'horizontal'\n                ? edge.edgeEnd.x - edge.edgeStart.x\n                : thickness,\n        height:\n            edge.orientation === 'vertical'\n                ? edge.edgeEnd.y - edge.edgeStart.y\n                : thickness,\n    };\n};\n\n/**\n * Check whether the mouse is on top of the edge\n * @param {Object} params\n * @param {EdgeItem} params.edge - The edge that is being checked\n * @param {Coordinate} params.mousePosition - The position of the mouse on the screen, scaled\n * @param {Number} params.padding - The amount of padding between two visualizations\n * @returns {boolean}\n */\nexport const isMouseOnEdge = ({\n    edge,\n    mousePosition,\n    padding = 0,\n}: {\n    edge: EdgeItem;\n    mousePosition: Coordinate;\n    padding?: number;\n}): boolean => {\n    const formattedEdge = formatEdgeWrapper({ edge, padding });\n    const { width, height } = getDimensions({\n        edge: formattedEdge,\n        thickness: 2 * padding,\n    });\n    return (\n        mousePosition.x <= formattedEdge.edgeStart.x + width &&\n        mousePosition.x >= formattedEdge.edgeStart.x &&\n        mousePosition.y <= formattedEdge.edgeStart.y + height &&\n        mousePosition.y >= formattedEdge.edgeStart.y\n    );\n};\n\n/**\n * When dropping a viz on a full-width edge, shift all the visualizations below that edge down\n * instead of taking size from the nearby visualizations\n * @param {Object}\n * @param {EdgeItem} params.edge - The edge that is being dropped on. Spans full width of canvas\n * @param {AbsoluteBlockItem} params.itemToMove - The item that is being removed\n * @param {AbsoluteBlockItem[]} params.items - All the items on the canvas\n * @returns {AbsoluteBlockItem[]} - Array of updated items, shifted down to create space for the added viz.\n */\nexport const computeNewVizPositionsGutterCase = ({\n    edge,\n    itemToMove,\n    items,\n}: {\n    edge: EdgeItem;\n    itemToMove: AbsoluteBlockItem;\n    items: AbsoluteBlockItem[];\n}): AbsoluteBlockItem[] => {\n    const updatedVisualizations: AbsoluteBlockItem[] = [];\n    items.forEach((item) => {\n        if (item.position.y >= edge.edgeStart.y) {\n            const viz =\n                item.item === itemToMove.item\n                    ? { ...item, item: 'itemToRemove' }\n                    : item;\n\n            updatedVisualizations.push({\n                ...viz,\n                position: {\n                    ...viz.position,\n                    y: viz.position.y + itemToMove.position.h,\n                },\n            });\n        }\n    });\n    // Now let's push the moved viz on the updatedVisualizations array\n    updatedVisualizations.push({\n        ...itemToMove,\n        position: {\n            ...itemToMove.position, // height is preserved\n            y: edge.edgeStart.y,\n            x: edge.edgeStart.x,\n            w: edge.edgeEnd.x - edge.edgeStart.x,\n        },\n    });\n\n    return updatedVisualizations;\n};\n\ntype AccumulatedSize = {\n    firstHalf: number[];\n    secondHalf: number[];\n} | null;\n\n/**\n * Determine the amount to take from each viz surrounding an edge that itemToMove is being dropped on\n * @param {Object}\n * @param {EdgeItem} params.edge - The edge that is being dropped on\n * @param {Number} params.amountToTake - The proportion of each viz to take. ex: 1/3\n * @param {Number} params.minWidth - Minimum width a viz can have\n * @param {Number} params.minHeight - Minimum height a viz can have\n * @returns {Object}\n */\nexport const sizeToTakeFromViz = ({\n    amountToTake,\n    edge,\n    minWidth,\n    minHeight,\n}: {\n    amountToTake: number;\n    edge: EdgeItem;\n    minWidth: number;\n    minHeight: number;\n}): {\n    firstHalf: number | null;\n    secondHalf: number | null;\n} => {\n    // When a visualization is dropped, it takes `amountToTake` from each visualization. Thus\n    //   it gets 1 size (firstHalf) from one side, and another (secondHalf) from the other side of the edge.\n    //    It's not entirely accurate to call them halves, as they are not typically equal.\n    const reduction = edge.visualizations.reduce<AccumulatedSize>(\n        (acc: AccumulatedSize, viz: AbsoluteBlockItem): AccumulatedSize => {\n            if (acc === null) {\n                return null;\n            }\n            if (edge.orientation === 'vertical') {\n                const widthToTake = Math.ceil(viz.position.w * amountToTake);\n                if (viz.position.w - widthToTake < minWidth) {\n                    return null; // if viz is too small, return null\n                }\n                if (viz.position.x < edge.edgeStart.x) {\n                    return {\n                        ...acc,\n                        firstHalf: [...acc.firstHalf, widthToTake],\n                    };\n                }\n                return {\n                    ...acc,\n                    secondHalf: [...acc.secondHalf, widthToTake],\n                };\n            }\n            // if edge.orientation === horizontal\n            const heightToTake = Math.ceil(viz.position.h * amountToTake);\n            if (viz.position.h - heightToTake < minHeight) {\n                return null;\n            }\n            if (viz.position.y < edge.edgeStart.y) {\n                return {\n                    ...acc,\n                    firstHalf: [...acc.firstHalf, heightToTake],\n                };\n            }\n            return {\n                ...acc,\n                secondHalf: [...acc.secondHalf, heightToTake],\n            };\n        },\n        { firstHalf: [], secondHalf: [] }\n    );\n\n    if (reduction === null) {\n        // then there was an invalid edge drop because a viz is too small to give its size\n        // return null to indicate invalid edge drop\n        return {\n            firstHalf: null,\n            secondHalf: null,\n        };\n    }\n\n    // If there were no viz on one of the sides, return 0 for the amount to take from that side\n    // Otherwise, return the minimum amount to take, to respect the smallest viz on that side\n    return {\n        firstHalf:\n            reduction.firstHalf.length === 0\n                ? 0\n                : Math.min(...reduction.firstHalf),\n        secondHalf:\n            reduction.secondHalf.length === 0\n                ? 0\n                : Math.min(...reduction.secondHalf),\n    };\n};\n\n/**\n * When dropping a viz on a normal edge (not full canvas width), take a proportion from each of the visualizations\n * around the edge, updating those items and inserting the moved viz in the space created\n * @param {Object}\n * @param {EdgeItem} params.edge - The edge that is being dropped on. Spans full width of canvas\n * @param {AbsoluteBlockItem} params.itemToMove - The item that is being moved\n * @param {Number} params.firstHalf - The amount of space moved viz will take up on the left/top sides\n * @param {Number} params.secondHalf - The amount of space moved viz will take up on the right/bottom sides\n * @returns {AbsoluteBlockItem[]} - Array of updated items after the moved viz was added\n */\nexport const computeNewVizPositions = ({\n    edge,\n    itemToMove,\n    firstHalf,\n    secondHalf,\n}: {\n    edge: EdgeItem;\n    itemToMove: AbsoluteBlockItem;\n    firstHalf: number;\n    secondHalf: number;\n}): AbsoluteBlockItem[] => {\n    // add width to the visualizations surrounding the edge\n    const updatedVisualizations = [];\n\n    // Update the visualizations touching the edge that is being dropped on\n    edge.visualizations.forEach((edgeViz) => {\n        // Check if the viz is the one that is being moved. This would be the old position of it,\n        // since we still need to update the \"placeholder\".\n        const viz =\n            edgeViz.item === itemToMove.item\n                ? { ...edgeViz, item: 'itemToRemove' }\n                : edgeViz;\n\n        if (edge.orientation === 'horizontal') {\n            if (viz.position.y < edge.edgeStart.y) {\n                updatedVisualizations.push(\n                    updateBlockItemSize({\n                        item: {\n                            ...viz,\n                        },\n                        offset: { offsetY: -1 * firstHalf, offsetX: 0 },\n                        dir: 's',\n                    })\n                );\n            }\n            if (viz.position.y >= edge.edgeStart.y) {\n                updatedVisualizations.push(\n                    updateBlockItemSize({\n                        item: {\n                            ...viz,\n                        },\n                        offset: { offsetY: secondHalf, offsetX: 0 },\n                        dir: 'n',\n                    })\n                );\n            }\n        } else {\n            if (viz.position.x < edge.edgeStart.x) {\n                updatedVisualizations.push(\n                    updateBlockItemSize({\n                        item: {\n                            ...viz,\n                        },\n                        offset: { offsetX: -1 * firstHalf, offsetY: 0 },\n                        dir: 'e',\n                    })\n                );\n            }\n            if (viz.position.x >= edge.edgeStart.x) {\n                updatedVisualizations.push(\n                    updateBlockItemSize({\n                        item: {\n                            ...viz,\n                        },\n                        offset: { offsetX: secondHalf, offsetY: 0 },\n                        dir: 'w',\n                    })\n                );\n            }\n        }\n    });\n\n    // update the moving viz to the new position\n    // The offsets represent how much to the left/right (same as up/down)\n    //  to offset the new viz from the EDGE position\n    updatedVisualizations.push({\n        ...itemToMove,\n        position: {\n            x:\n                edge.edgeStart.x -\n                (edge.orientation === 'vertical' ? firstHalf : 0),\n            y:\n                edge.edgeStart.y -\n                (edge.orientation === 'horizontal' ? firstHalf : 0),\n            w:\n                edge.orientation === 'vertical'\n                    ? firstHalf + secondHalf\n                    : edge.edgeEnd.x - edge.edgeStart.x,\n            h:\n                edge.orientation === 'horizontal'\n                    ? firstHalf + secondHalf\n                    : edge.edgeEnd.y - edge.edgeStart.y,\n        },\n    });\n    return updatedVisualizations;\n};\n\nconst isResultingVizSizeGreaterThanMin = ({\n    size,\n    edgeOrientation,\n}: {\n    size: number;\n    edgeOrientation: EdgeItem['orientation'];\n}): boolean => {\n    if (edgeOrientation === 'vertical') {\n        return size >= MIN_WIDTH_PX;\n    }\n    return size >= MIN_HEIGHT_PX;\n};\n\n/**\n * updates the Items into a valid Grid Layout Items List\n * @param {Object} params\n * @param {Object} params.updatedVisualizations visualizations that have been updated\n * @param {Object} params.itemToMove visualization that is being moved (removed)\n * @param {Array} params.items list of visualization items\n * @param {Number} params.canvasWidth width of canvas\n * @returns {Array{}} - returns a combined array of Viz Item Objects\n */\nexport const updateItems = ({\n    updatedVisualizations,\n    itemToMove,\n    items,\n    canvasWidth,\n}: {\n    updatedVisualizations: AbsoluteBlockItem[];\n    itemToMove: AbsoluteBlockItem;\n    items: AbsoluteBlockItem[];\n    canvasWidth: number;\n}): AbsoluteBlockItem[] => {\n    // make sure to use the up to date item instead of the old\n    const updatedItems = [\n        ...items.filter(\n            (item) =>\n                updatedVisualizations.find((viz) => viz.item === item.item) ===\n                undefined\n        ),\n        ...updatedVisualizations,\n    ];\n\n    const updatedNeighbors = updateRemovedVizNeighbors({\n        itemToRemove: itemToMove,\n        items: updatedItems,\n        width: canvasWidth,\n    });\n\n    // Now that we've updated the neighbors of the removed viz, we need\n    // to make sure we use the most up to date viz (since updatedVisualizations could potentially be stale)\n    const filteredUpdatedVisualizations = updatedVisualizations.filter(\n        (viz) =>\n            updatedNeighbors.find((neighbor) => neighbor.item === viz.item) ===\n                undefined && viz.item !== 'itemToRemove'\n    );\n\n    // items are all visualizations, filter out:\n    // 1. the visualizations we updated when we removed the viz from its initial position (updatedNeighbors)\n    // 2. the visualizations we updated when we inserted viz into its new position (filteredUpdatedVisualizations)\n    // 3. the visualization that was moved to its new position (itemToMove)\n    const filteredItems = items.filter(\n        (viz) =>\n            updatedNeighbors.find((neighbor) => neighbor.item === viz.item) ===\n                undefined &&\n            filteredUpdatedVisualizations.find(\n                (updatedViz) => updatedViz.item === viz.item\n            ) === undefined &&\n            viz.item !== itemToMove.item\n    );\n    return [\n        ...filteredItems,\n        ...filteredUpdatedVisualizations,\n        ...updatedNeighbors,\n    ];\n};\n\n/**\n * check if the moving item is dropping on its own edge and the edge has same width/height as item\n * @param {Object} params\n * @param {Object} edge edge being dropped onto\n * @param {Object} itemToMove visualization item being moved\n * @return {Boolean}\n */\nexport const isDropOnOwnEdge = ({\n    edge,\n    itemToMove,\n}: {\n    edge: EdgeItem;\n    itemToMove: AbsoluteBlockItem;\n}): boolean =>\n    edge.visualizations.find((viz) => viz.item === itemToMove.item) != null &&\n    ((edge.orientation === 'horizontal' &&\n        itemToMove.position.w === edge.edgeEnd.x - edge.edgeStart.x) ||\n        (edge.orientation === 'vertical' &&\n            itemToMove.position.h === edge.edgeEnd.y - edge.edgeStart.y));\n\n/**\n * Calculates new position values for visualizations being affected from a Visualization being dropped on an Edge\n * @param {Object} params\n * @param {Object} edge edge being dropped onto\n * @param {Object} itemToMove visualization Item being moved\n * @param {Object[]} items array of all visualization Items\n * @param {String} canvasWidth width of canvas\n * @return {Object[]} object of the list of updated visualizations items and updated itemToMove object\n */\nexport const updateDropOnEdge = ({\n    edge,\n    itemToMove,\n    items,\n    canvasWidth,\n}: {\n    edge: EdgeItem;\n    itemToMove: AbsoluteBlockItem;\n    items: AbsoluteBlockItem[];\n    canvasWidth: number;\n}): {\n    updatedVisualizations: AbsoluteBlockItem[];\n    updatedItemToMove: AbsoluteBlockItem;\n} | null => {\n    // Do not let user drop a viz on an edge it owns (exactly spans the width/height of that viz)\n    if (isDropOnOwnEdge({ edge, itemToMove })) {\n        return null;\n    }\n\n    // The amount to take from each surrounding visualization\n    const amountToTake = 1 / 3;\n\n    let updatedVisualizations = [];\n    if (\n        edge.orientation === 'horizontal' &&\n        edge.edgeEnd.x - edge.edgeStart.x === canvasWidth\n    ) {\n        // if we are dropping the visualization on an edge that spans the full width of\n        //  the canvas, then we have different behavior: shift all visualizations down\n        updatedVisualizations = computeNewVizPositionsGutterCase({\n            edge,\n            itemToMove,\n            items,\n        });\n    } else {\n        // Check if the visualizations surrounding the drop-target edge have enough space to give in order to insert the moving viz\n        // The moved viz gets one half of its size from the visualizations on one side of the edge, and the second half from the\n        //  visualizations on the other side of the edge\n        const { firstHalf, secondHalf } = sizeToTakeFromViz({\n            amountToTake,\n            edge,\n            minWidth: MIN_WIDTH_PX,\n            minHeight: MIN_HEIGHT_PX,\n        });\n        if (\n            firstHalf === null ||\n            secondHalf === null ||\n            // Check if the moved viz resulting size will be greater than the minimum width/height\n            // This particular case occurs when adding to the top and bottom canvas edge\n            !isResultingVizSizeGreaterThanMin({\n                size: firstHalf + secondHalf,\n                edgeOrientation: edge.orientation,\n            })\n        ) {\n            // invalid edge drop, one of the visualizations was too small to give up size\n            return null;\n        }\n        updatedVisualizations = computeNewVizPositions({\n            edge,\n            itemToMove,\n            firstHalf,\n            secondHalf,\n        });\n    }\n\n    // If the edge we move to caused an update to the old position of itemToMove, we need to update that\n    // position in order to correctly handle removing the viz in that old position.\n    const updatedItemToMove =\n        updatedVisualizations.find((viz) => viz.item === 'itemToRemove') ||\n        itemToMove;\n\n    return { updatedVisualizations, updatedItemToMove };\n};\n\n/**\n * Given a rectangular Item, determine whether the position is within bounds of the item\n * @param {Object} params\n * @param {Object} params.item visualization item being hovered over\n * @param {Object} params.position position of the mouse over the visualization\n * @returns {Boolean} whether the position is in bounds of the Item\n */\nexport const positionInItemBoundary = ({\n    item,\n    position,\n}: {\n    item: AbsoluteBlockItem;\n    position: Coordinate;\n}): boolean => {\n    return (\n        position.x >= item.position.x &&\n        position.x <= item.position.x + item.position.w &&\n        position.y >= item.position.y &&\n        position.y <= item.position.y + item.position.h\n    );\n};\n\n/**\n * Given a rectangular Item, find the quadrant where position is located on an item\n * where the quadrants are divided by diagonal lines creating four triangles\n * Dividing Line 1: (start: {top left corner}, end: {bottom right corner}) y = f(x) = slope * x\n * Dividing Line 2: (start: {bottom left corner}, end: {top right corner}) y = f(x) = -slope * x\n * @param {Object} params\n * @param {Object} params.item visualization item being hovered over\n * @param {Object} params.position position of the mouse over the visualization\n * @returns {String} returns the quadrant position is in Item oneOf('n', 's', 'w', 'e'), if not in quadrant it returns null\n */\nexport const findQuadrant = ({\n    item,\n    position,\n}: {\n    item: AbsoluteBlockItem;\n    position: Coordinate;\n}): Quadrant | null => {\n    if (positionInItemBoundary({ item, position })) {\n        let { x, y } = position;\n        x -= item.position.x;\n        y -= item.position.y;\n        const slope = item.position.h / item.position.w;\n        let quadrant: Quadrant[];\n        if (y > slope * x) {\n            quadrant = ['w', 's'];\n        } else {\n            quadrant = ['n', 'e'];\n        }\n        // If the slope of one diagonal is f(x) = (h/w) * x then the slope of the other (intersecting)\n        // diagonal is f(x) = -(h/w) * x + h, so we use the later to determine last quadrant\n        return y < -slope * x + item.position.h ? quadrant[0] : quadrant[1];\n    }\n    return null;\n};\n\n/**\n * Calculates the updated position values for the viz being moved and dropped onto\n * @param {Object} params\n * @param {Object} params.itemToMove item that is being moved\n * @param {Object} params.itemToDropOn item that the visualization is being dropped onto\n * @param {String} direction direction item is dropped on oneOf('n', 's', 'w', 'e')\n * @returns {Object[]} an Array containing updated itemToMove and itemToDropOn\n */\nexport const updateDropOnViz = ({\n    itemToMove,\n    itemToDropOn,\n    direction,\n}: {\n    itemToMove: AbsoluteBlockItem;\n    itemToDropOn: AbsoluteBlockItem;\n    direction: Quadrant;\n}): [AbsoluteBlockItem, AbsoluteBlockItem] | null => {\n    if (\n        ((direction === 'e' || direction === 'w') &&\n            itemToDropOn.position.w < MIN_WIDTH_PX * 2) ||\n        ((direction === 'n' || direction === 's') &&\n            itemToDropOn.position.h < MIN_WIDTH_PX * 2)\n    ) {\n        return null;\n    }\n    let vizToMove = {\n        ...itemToMove,\n        position: itemToDropOn.position,\n    };\n    let vizTarget = { ...itemToDropOn };\n    switch (direction) {\n        case 'n':\n            vizToMove = updateBlockItemSize({\n                item: vizToMove,\n                offset: {\n                    offsetY: -Math.floor(vizToMove.position.h / 2),\n                    offsetX: 0,\n                },\n                dir: 's',\n            });\n            vizTarget = updateBlockItemSize({\n                item: vizTarget,\n                offset: {\n                    offsetY: Math.ceil(vizTarget.position.h / 2),\n                    offsetX: 0,\n                },\n                dir: 'n',\n            });\n            break;\n        case 's':\n            vizToMove = updateBlockItemSize({\n                item: vizToMove,\n                offset: {\n                    offsetY: Math.floor(vizToMove.position.h / 2),\n                    offsetX: 0,\n                },\n                dir: 'n',\n            });\n            vizTarget = updateBlockItemSize({\n                item: vizTarget,\n                offset: {\n                    offsetY: -Math.ceil(vizTarget.position.h / 2),\n                    offsetX: 0,\n                },\n                dir: 's',\n            });\n            break;\n        case 'w':\n            vizToMove = updateBlockItemSize({\n                item: vizToMove,\n                offset: {\n                    offsetX: -Math.floor(vizToMove.position.w / 2),\n                    offsetY: 0,\n                },\n                dir: 'e',\n            });\n            vizTarget = updateBlockItemSize({\n                item: vizTarget,\n                offset: {\n                    offsetX: Math.ceil(vizTarget.position.w / 2),\n                    offsetY: 0,\n                },\n                dir: 'w',\n            });\n            break;\n        case 'e':\n            vizToMove = updateBlockItemSize({\n                item: vizToMove,\n                offset: {\n                    offsetX: Math.floor(vizToMove.position.w / 2),\n                    offsetY: 0,\n                },\n                dir: 'w',\n            });\n            vizTarget = updateBlockItemSize({\n                item: vizTarget,\n                offset: {\n                    offsetX: -Math.ceil(vizTarget.position.w / 2),\n                    offsetY: 0,\n                },\n                dir: 'e',\n            });\n            break;\n        default:\n            // reset viz to original state so nothing changes\n            vizToMove = itemToMove;\n            break;\n    }\n\n    return [vizToMove, vizTarget];\n};\n\n/**\n * Calculates new viz positions after the itemToMove viz is dropped on edge\n * @param {Object} params\n * @param {Object} params.edge edge being dropped onto\n * @param {Object} params.itemToMove visualization Item being moved\n * @param {Object[]} params.items array of all visualization Items\n * @param {String} params.canvasWidth width of canvas\n * @return {Object[]} object of the list of updated visualizations items, updated itemToMove object, and the old itemToMove\n */\nexport const previewDropOnEdge = ({\n    edge,\n    itemToMove,\n    items,\n    canvasWidth,\n}: {\n    edge: EdgeItem;\n    itemToMove: AbsoluteBlockItem;\n    items: AbsoluteBlockItem[];\n    canvasWidth: number;\n}): AbsoluteBlockItem[] | null => {\n    const updatedItems = updateDropOnEdge({\n        edge,\n        itemToMove,\n        items,\n        canvasWidth,\n    });\n\n    if (!updatedItems) {\n        // If it's an invalid drop, return null\n        return null;\n    }\n\n    let { updatedVisualizations } = updatedItems;\n    const { updatedItemToMove } = updatedItems;\n\n    // Take out the old visualization from the updated (if it was updated). This is so that\n    //  we can add it below with a unique id 'preview-old-item'\n    updatedVisualizations = updatedVisualizations.filter(\n        (viz) => !isEqual(viz, updatedItemToMove)\n    );\n\n    // preview-old-item is the position of the initial item before the move. This is so that we render\n    //   empty or a custom component in its place during the preview.\n    // For edges, we need this item to correctly re-compute edges around it in the preview.\n    return [\n        ...items.filter(\n            (item) =>\n                updatedVisualizations.find((viz) => viz.item === item.item) ===\n                undefined\n        ),\n        ...updatedVisualizations,\n        {\n            ...updatedItemToMove,\n            item: 'preview-old-item',\n        },\n    ];\n};\n\n/**\n * Calculates the updated position values for the viz being moved and dropped onto\n * @param {Object} params\n * @param {Object} params.itemToMove item that is being moved\n * @param {Object} params.itemToDropOn item that the visualization is being dropped onto\n * @param {String} direction direction item is dropped on oneOf('n', 's', 'w', 'e')\n * @param {Object[]} items list of all visualizations on canvas\n * @returns {Object[]} an Array containing updated itemToMove and itemToDropOn\n */\nexport const previewDropOnViz = ({\n    itemToDropOn,\n    itemToMove,\n    items,\n    direction,\n}: {\n    itemToDropOn: AbsoluteBlockItem;\n    itemToMove: AbsoluteBlockItem;\n    items: AbsoluteBlockItem[];\n    direction: Quadrant;\n}): AbsoluteBlockItem[] | null => {\n    const updatedItems = updateDropOnViz({\n        itemToMove,\n        itemToDropOn,\n        direction,\n    });\n\n    if (!updatedItems) {\n        // If it's an invalid drop, return null\n        return null;\n    }\n\n    // preview-old-item is the position of the initial item before the move. This is so that we render\n    //   empty or a custom component in its place during the preview\n    return [\n        ...items.filter(\n            (item) =>\n                updatedItems.find((viz) => viz.item === item.item) === undefined\n        ),\n        ...updatedItems,\n        {\n            ...itemToMove,\n            item: 'preview-old-item',\n        },\n    ];\n};\n\n/**\n * Finds items that live outside the canvas boundary, and returns an error message for each item.\n * @param {Object} params\n * @param {Object[]} params.items items in the layout structure of the dashboard\n * @param {Object} params.boundary canvas boundary { x, y, w, h }\n * @returns {Object[]} array of objects out of bounds\n */\nexport const findItemsOutsideBoundary = ({\n    items,\n    boundary,\n}: {\n    items: AbsoluteBlockItem[];\n    boundary: AbsolutePosition;\n}): LayoutError[] => {\n    const invalidItems: LayoutError[] = [];\n    const message = _('is outside of canvas bounds');\n    items.forEach((item) => {\n        if (\n            item.position.x < boundary.x ||\n            item.position.x + item.position.w > boundary.x + boundary.w ||\n            item.position.y < boundary.y ||\n            item.position.y + item.position.h > boundary.y + boundary.h\n        ) {\n            invalidItems.push({\n                itemId: item.item,\n                messages: [`\"${item.item}\" ${message}`],\n            });\n        }\n    });\n    return invalidItems;\n};\n\n// TODO: Should this be more aligned with EdgeItem?\ninterface EdgeValidationItem {\n    start: Coordinate;\n    end: Coordinate;\n    orientation: EdgeItem['orientation'];\n    type: 'above' | 'below' | 'left' | 'right';\n    belongsTo: AbsolutePosition;\n}\n\n/**\n * Gets the 4 edges of every item (top, bottom, left, and right)\n * @param {Object} params\n * @param {Object} params.item item positions { x, y, w, h }\n * @param {Object} [params.belongsTo={}] item to which these edges belong\n * @returns {Object[]} array of edges where edge = { start: { x, y }, end: { x, y } }\n */\nexport const getItemEdges = ({\n    item,\n    belongsTo = {} as AbsolutePosition,\n}: {\n    item: AbsolutePosition;\n    belongsTo?: AbsolutePosition;\n}): EdgeValidationItem[] => {\n    // create edges in the form: edge.start.{x,y} and edge.end.{x,y}\n    const topEdge: EdgeValidationItem = {\n        start: { x: item.x, y: item.y },\n        end: { x: item.x + item.w, y: item.y },\n        orientation: 'horizontal',\n        type: 'above',\n        belongsTo,\n    };\n    const bottomEdge: EdgeValidationItem = {\n        start: { x: item.x, y: item.y + item.h },\n        end: { x: item.x + item.w, y: item.y + item.h },\n        orientation: 'horizontal',\n        type: 'below',\n        belongsTo,\n    };\n    const leftEdge: EdgeValidationItem = {\n        start: { x: item.x, y: item.y },\n        end: { x: item.x, y: item.y + item.h },\n        orientation: 'vertical',\n        type: 'left',\n        belongsTo,\n    };\n    const rightEdge: EdgeValidationItem = {\n        start: { x: item.x + item.w, y: item.y },\n        end: { x: item.x + item.w, y: item.y + item.h },\n        orientation: 'vertical',\n        type: 'right',\n        belongsTo,\n    };\n\n    return [topEdge, bottomEdge, leftEdge, rightEdge];\n};\n\n/**\n * Create all necessary edges for every item in layout as well as for the canvas\n * @param {Object} params\n * @param {Object[]} params.items items in the layout structure of the dashboard\n * @param {Object} params.canvasBounds canvas boundary { x, y, w, h }\n * @returns {Object[]} an array of edge objects as returned from getItemEdges\n */\nconst createEdges = ({\n    items,\n    canvasBounds,\n}: {\n    items: AbsoluteBlockItem[];\n    canvasBounds: AbsolutePosition;\n}): EdgeValidationItem[] => {\n    const edges = [];\n\n    // first, add every item edge\n    items.forEach((item) => {\n        edges.push(\n            ...getItemEdges({ item: item.position, belongsTo: item.position })\n        );\n    });\n\n    // second, need to add canvas edges as well\n    edges.push(...getItemEdges({ item: canvasBounds }));\n\n    return edges;\n};\n\n/**\n * Find the provided item's invalid edges, which indicate there is a gap or overlap between visualizations\n * @param {Object} params\n * @param {Object} params.item item to find invalid edges for\n * @param {Object[]} params.edges all viz and canvas edges\n * @returns {String[]} an array of error message for each invalid edge\n */\nconst findInvalidItemEdges = ({\n    item,\n    edges,\n}: {\n    item: AbsoluteBlockItem;\n    edges: EdgeValidationItem[];\n}): string[] => {\n    const invalidEdges: string[] = [];\n    // the current edges of the item we're looking at\n    const curEdges = getItemEdges({\n        item: item.position,\n        belongsTo: item.position,\n    });\n    curEdges.forEach((curEdge) => {\n        // find one edge which it overlaps. The idea is as follows:\n        //   if there is an edge that it overlaps, it means that it is adjacent, and thus this edge is valid\n        //   if no adjacent edge is found, it means either there is extra space (gap) or the viz are overlapping\n        const overlappingEdge = edges.find((edge) => {\n            if (\n                curEdge.orientation !== edge.orientation ||\n                isEqual(curEdge.belongsTo, edge.belongsTo)\n            ) {\n                // if the edge is not the same orientation, it can't be overlapping\n                // or if the edge is the same, meaning it belongs to same item\n                // or if the two items are perfectly overlapping\n                return false;\n            }\n            // if the edges are horizontal and on the same y co-ordinate\n            if (\n                curEdge.orientation === 'horizontal' &&\n                curEdge.start.y === edge.start.y\n            ) {\n                // if the edges are not overlapping\n                if (\n                    curEdge.start.x >= edge.end.x ||\n                    edge.start.x >= curEdge.end.x\n                ) {\n                    return false;\n                }\n                // otherwise they are overlapping\n                return true;\n            }\n            // if the edges are vertical and on the same x co-ordinate\n            if (\n                curEdge.orientation === 'vertical' &&\n                curEdge.start.x === edge.start.x\n            ) {\n                // if the edges are not overlapping\n                if (\n                    curEdge.start.y >= edge.end.y ||\n                    edge.start.y >= curEdge.end.y\n                ) {\n                    return false;\n                }\n                return true;\n            }\n            // this means edge is not on the same co-ordinate/line, can't be overlapping\n            return false;\n        });\n        if (overlappingEdge === undefined) {\n            // If no edge was found, this means there is an error in the layout structure\n            const positionString =\n                curEdge.orientation === 'horizontal'\n                    ? `y=${curEdge.start.y}`\n                    : `x=${curEdge.start.x}`;\n            // differentiate between \"above/below\" and \"to its right/left\"\n            const positionType =\n                curEdge.type === 'below' || curEdge.type === 'above'\n                    ? curEdge.type\n                    : `to its ${curEdge.type}`;\n            invalidEdges.push(\n                _(\n                    `\"${item.item}\" expected a viz or canvas edge directly ${positionType} at ${positionString}`\n                )\n            );\n        }\n    });\n    return invalidEdges;\n};\n\n/**\n * Find items that have invalid edges indicating a gap/overlap between visualizations\n * @param {Object} params\n * @param {Object[]} params.items items in the layout structure of the dashboard\n * @param {Object} params.canvasBounds canvas boundary { x, y, w, h }\n * @returns {Object[]} Array of objects containing itemId and error messages\n */\nconst findInvalidItems = ({\n    items,\n    canvasBounds,\n}: {\n    items: AbsoluteBlockItem[];\n    canvasBounds: AbsolutePosition;\n}) => {\n    const invalidItems: LayoutError[] = [];\n    const edges = createEdges({ items, canvasBounds });\n    items.forEach((item) => {\n        const invalidEdges = findInvalidItemEdges({ item, edges });\n        if (invalidEdges.length > 0) {\n            invalidItems.push({\n                itemId: item.item,\n                messages: invalidEdges,\n            });\n        }\n    });\n    return invalidItems;\n};\n\n/**\n * validate if layout is valid and return the appropriate error object if it is not\n * @param {Object} params\n * @param {Object[]} params.layout layout structure of the dashboard\n * @param {Object} params.canvasBounds canvas boundary { x, y, w, h }\n * @returns {Object[]} Array of objects containing itemId and error messages\n */\nexport const validateLayoutStructure = ({\n    layout,\n    canvasBounds,\n}: {\n    layout?: AbsoluteBlockItem[];\n    canvasBounds: AbsolutePosition;\n}): LayoutError[] => {\n    if (!layout) {\n        return []; // maybe return object with bool false and message?\n    }\n\n    const res = findItemsOutsideBoundary({\n        items: layout,\n        boundary: canvasBounds,\n    });\n\n    // if items are out of boundary, return early\n    if (!isEmpty(res)) {\n        return res;\n    }\n\n    // if all items are in boundary, check which are invalid\n    return findInvalidItems({ items: layout, canvasBounds });\n};\n\nconst isVerticallyAligned = (\n    viz: AbsoluteBlockItem,\n    another: AbsoluteBlockItem\n) =>\n    viz.position.y === another.position.y &&\n    viz.position.h === another.position.h;\n\nconst isHorizontallyAligned = (\n    viz: AbsoluteBlockItem,\n    another: AbsoluteBlockItem\n) =>\n    viz.position.x === another.position.x &&\n    viz.position.w === another.position.w;\n\nexport const isInvalidAdjacentVizDrop = ({\n    itemToMove,\n    itemToDropOn,\n    direction,\n    visualizations,\n}: {\n    itemToMove: AbsoluteBlockItem;\n    itemToDropOn: AbsoluteBlockItem;\n    direction: Quadrant;\n    visualizations: AbsoluteBlockItem[];\n}): boolean => {\n    /* scenario 1: drop on left/right neighbor */\n\n    if (\n        direction === 'e' &&\n        isLeftNeighbor(itemToMove, itemToDropOn) &&\n        isVerticallyAligned(itemToMove, itemToDropOn)\n    ) {\n        return true;\n    }\n\n    if (\n        direction === 'w' &&\n        isRightNeighbor(itemToMove, itemToDropOn) &&\n        isVerticallyAligned(itemToMove, itemToDropOn)\n    ) {\n        return true;\n    }\n\n    if (direction === 'e' || direction === 'w') {\n        return false;\n    }\n\n    /* scenario 2: drop on top/bottom neighbor */\n\n    const { leftNeighbors, rightNeighbors } = findHorizontalNeighbors({\n        item: itemToMove,\n        visualizations,\n    });\n\n    // neighbors will occupy the vacant space, so it is valid to move the item\n    if (leftNeighbors.length > 0 || rightNeighbors.length > 0) {\n        return false;\n    }\n\n    if (\n        direction === 'n' &&\n        isBottomNeighbor(itemToMove, itemToDropOn) &&\n        isHorizontallyAligned(itemToMove, itemToDropOn)\n    ) {\n        return true;\n    }\n\n    if (\n        direction === 's' &&\n        isTopNeighbor(itemToMove, itemToDropOn) &&\n        isHorizontallyAligned(itemToMove, itemToDropOn)\n    ) {\n        return true;\n    }\n\n    return false;\n};\n", "import type {\n    AbsoluteBlockItem,\n    Coordinate,\n    GridLayoutStructure,\n} from '@splunk/dashboard-types';\nimport type { Intersections } from './edgeUtils';\nimport {\n    splitGridByRows,\n    splitGridByColumns,\n    type SplitGrid,\n    type SplitGridEntry,\n} from './gridOrderUtils';\n\nexport type GridInfo = {\n    width: number;\n    height: number;\n    originItem: AbsoluteBlockItem;\n    itemToRemove: AbsoluteBlockItem;\n    nodes: Intersections;\n    splitByRows: SplitGrid;\n    splitByColumns: SplitGrid;\n};\n\nexport const DEFAULT_BLOCK_ITEM: AbsoluteBlockItem = {\n    item: '',\n    position: { x: -1, y: -1, w: -1, h: -1 },\n};\n\n/**\n * Translate an AbsoluteBlockItem object by the provided X and Y values\n * @param {AbsoluteBlockItem} item An AbsoluteBlockItem object to be translated\n * @param {Coordinate} translation An X and Y delta by which to translate the item\n * @returns A cloned object with the position translated by the provided delta\n */\nexport const translateBlockItem = (\n    item: AbsoluteBlockItem,\n    translation: Coordinate\n): AbsoluteBlockItem => ({\n    ...item,\n    position: {\n        ...item.position,\n        x: item.position.x + translation.x,\n        y: item.position.y + translation.y,\n    },\n});\n\n/**\n * Translate an array of AbsoluteBlockItem objects by the provided X and Y values\n * @param {AbsoluteBlockItem[]} items Array of AbsoluteBlockItem objects to be translated\n * @param {Coordinate} translation An X and Y delta by which to translate the items\n * @returns A mapped array with each entry translated by the provided delta\n */\nexport const translateBlockItems = (\n    items: AbsoluteBlockItem[],\n    translation: Coordinate\n): AbsoluteBlockItem[] =>\n    items.map((item) => translateBlockItem(item, translation));\n\n/**\n * Translate a SplitGridEntry object by the provided X and Y values\n * @param {SplitGridEntry} gridSplit Grid split to be translated\n * @param {Coordinate} translation An X and Y delta by which to translate the split. Applied to all content and the split origin.\n * @returns The SplitGridEntry with an updated origin and content.items[].position values\n */\nexport const translateGridSplit = (\n    gridSplit: SplitGridEntry,\n    translation: Coordinate\n): SplitGridEntry => ({\n    ...gridSplit,\n    layout: translateBlockItems(gridSplit.layout, translation),\n    content: {\n        ...gridSplit.content,\n        items: translateBlockItems(gridSplit.content.items, translation),\n    },\n    origin: {\n        x: gridSplit.origin.x + translation.x,\n        y: gridSplit.origin.y + translation.y,\n    },\n});\n\n/**\n * Convert a grid structure into an object which contains the grid width, height,\n * origin block item, intersection nodes, and the result of splitGridByRows and/or\n * splitGridByColumns. If a value for `idToRemove` is provided then the AbsoluteBlockItem\n * with that ID will also be returned\n * @param {GridLayoutStructure} param0.layoutStructure The layout structure of a grid layout to be split\n * @param {String | undefined} param0.idToRemove The ID of a block item to be fetched from the grid structure\n * @param {\"both\" | \"none\" | \"rows\" | \"columns\"} param0.splitConfig If the grid should be split by rows, columns, both, or neither\n * @returns An object which describes how the grid structure can be split into rows and/or columns\n */\nexport const splitGrid = ({\n    layoutStructure,\n    idToRemove,\n    splitConfig = 'both',\n    alwaysIncludeLastRow = false,\n}: {\n    layoutStructure: GridLayoutStructure;\n    idToRemove?: string;\n    splitConfig?: 'both' | 'none' | 'rows' | 'columns';\n    alwaysIncludeLastRow?: boolean;\n}): GridInfo => {\n    // Create the result. It will be updated during execution\n    const gridInfo: GridInfo = {\n        width: 0,\n        height: 0,\n        originItem: DEFAULT_BLOCK_ITEM,\n        nodes: {},\n        splitByRows: [],\n        splitByColumns: [],\n        itemToRemove: DEFAULT_BLOCK_ITEM,\n    };\n\n    if (layoutStructure.length === 0) {\n        return gridInfo;\n    }\n\n    // Calculate the actual width/height of the structure and all block item nodes\n    let originX = Number.MAX_SAFE_INTEGER;\n    let originY = Number.MAX_SAFE_INTEGER;\n    layoutStructure.forEach((item) => {\n        const { x, y, w, h } = item.position;\n\n        // If the current item right or bottom edges exceed the grid width or\n        // height then use those edge positions for the new grid dimensions\n        gridInfo.width = Math.max(gridInfo.width, x + w);\n        gridInfo.height = Math.max(gridInfo.height, y + h);\n\n        if (x <= originX && y <= originY) {\n            originX = x;\n            originY = y;\n            gridInfo.originItem = item;\n        }\n\n        // Logic for getNodes but inline to prevent a second loop over layoutStructure\n        [\n            [x, y],\n            [x + w, y],\n            [x, y + h],\n            [x + w, y + h],\n        ].forEach(([cornerX, cornerY]) => {\n            gridInfo.nodes[cornerX] ??= {};\n            gridInfo.nodes[cornerX][cornerY] ??= [];\n            gridInfo.nodes[cornerX][cornerY].push(item);\n        });\n\n        // While iterating over layoutStructure try to find the up-to-date itemToRemove value\n        if (idToRemove === item.item) {\n            gridInfo.itemToRemove = item;\n        }\n    });\n\n    // Calculate the width and height with respect to the origin, but don't let the result be negative\n    gridInfo.width = Math.max(0, gridInfo.width - originX);\n    gridInfo.height = Math.max(0, gridInfo.height - originY);\n\n    // Only invoke the cost of splitGridByRows if the value is requested by the caller\n    if (splitConfig === 'both' || splitConfig === 'rows') {\n        gridInfo.splitByRows = splitGridByRows({\n            nodes: gridInfo.nodes,\n            layout: layoutStructure,\n            gridWidth: gridInfo.width,\n            gridHeight: gridInfo.height,\n            originViz: gridInfo.originItem,\n            alwaysIncludeLastRow,\n        });\n    }\n\n    // Only invoke the cost of splitGridByColumns if the value is requested by the caller\n    if (splitConfig === 'both' || splitConfig === 'columns') {\n        gridInfo.splitByColumns = splitGridByColumns({\n            nodes: gridInfo.nodes,\n            layout: layoutStructure,\n            gridWidth: gridInfo.width,\n            gridHeight: gridInfo.height,\n            originViz: gridInfo.originItem,\n        });\n    }\n\n    return gridInfo;\n};\n", "import type {\n    AbsoluteBlockItem,\n    AbsolutePosition,\n    GridLayoutStructure,\n} from '@splunk/dashboard-types';\nimport type { SplitGrid, SplitGridEntry } from './gridOrderUtils';\nimport { splitGrid, translateGridSplit } from './splitGridStructure';\n\ntype ContainingRowColumn = SplitGridEntry | undefined;\n\ntype FindContainerFn = (args: {\n    splits: SplitGrid;\n    itemPosition: AbsolutePosition;\n}) => ContainingRowColumn;\n\n/**\n * Internal utility for finding a row split which contains a given item\n * @param {SplitGrid} param0.splits A grid structure split by rows\n * @param {AbsolutePosition} param0.itemPosition A block item position describing what the target row should contain\n * @returns {ContainingRowColumn} Grid row which contains the target item\n */\nconst findContainingRow: FindContainerFn = ({ splits, itemPosition }) => {\n    const edgeTop = itemPosition.y;\n    const edgeBottom = itemPosition.y + itemPosition.h;\n\n    return splits.find(\n        ({ origin, content }) =>\n            // Find the first row split which starts above the item in question and ends below it\n            origin.y <= edgeTop && origin.y + content.height >= edgeBottom\n    );\n};\n\n/**\n * Internal utility for finding a column split which contains a given item\n * @param {SplitGrid} param0.splits A grid structure split by columns\n * @param {AbsolutePosition} param0.itemPosition A block item position describing what the target column should contain\n * @returns {ContainingRowColumn} Grid column which contains the target item\n */\nconst findContainingColumn: FindContainerFn = ({ splits, itemPosition }) => {\n    const edgeLeft = itemPosition.x;\n    const edgeRight = itemPosition.x + itemPosition.w;\n\n    return splits.find(\n        ({ origin, content }) =>\n            // Find the first column split which starts before the item in question and ends after it\n            origin.x <= edgeLeft && origin.x + content.width >= edgeRight\n    );\n};\n\n/**\n * Internal utility for recursively searching for the smallest row/column containing a target item\n * @param {FindContainerFn} param0.findContainerFn A function for filtering the split grid structure\n * @param {AbsoluteBlockItem} param0.itemToContain The block item which should be contained\n * @param {ContainingRowColumn} [param0.previousResult] The previous result. When the base case is reached (no container found, or the container contains a single item) then the previous value is returned\n * @param {GridLayoutStructure} param0.structure The layout structure to search. The structure origin must be (0, 0)\n * @returns {ContainingRowColumn} The smallest grid row or column which contains the target item, but is not just the target item\n */\nconst getContainingRowColumnRecursive = ({\n    findContainerFn,\n    itemToContain,\n    previousResult,\n    structure,\n}: {\n    findContainerFn: FindContainerFn;\n    itemToContain: AbsoluteBlockItem;\n    previousResult?: ContainingRowColumn;\n    structure: GridLayoutStructure;\n}): ContainingRowColumn => {\n    const splittingByRows = findContainerFn === findContainingRow;\n\n    const splitGridInfo = splitGrid({\n        layoutStructure: structure,\n        idToRemove: itemToContain.item,\n        splitConfig: splittingByRows ? 'rows' : 'columns',\n        alwaysIncludeLastRow: true,\n    });\n\n    // When finding the next container use the item position from splitGrid\n    // because the layout structure is translated and itemToContain.position\n    // can become outdated as recursion occurs.\n    const container = findContainerFn({\n        splits: splittingByRows\n            ? splitGridInfo.splitByRows\n            : splitGridInfo.splitByColumns,\n        itemPosition: splitGridInfo.itemToRemove.position,\n    });\n\n    if (!container || container.content.items.length <= 1) {\n        // If no container was found, or the container is only one element in size\n        // (it only contains the target item) then return the previous result\n        return previousResult;\n    }\n\n    // The methods called in splitGrid require the grid have (0, 0) for the origin\n    // so during processing the container will be translated to that origin and\n    // then restored in the final return statement\n    const containerTranslation = {\n        x: -container.origin.x,\n        y: -container.origin.y,\n    };\n\n    const translatedContainer = translateGridSplit(\n        container,\n        containerTranslation\n    );\n\n    // If the current recursion is looking for a containing row then the next\n    // call should look for a containing column. Else look for a containing row.\n    const nextFindContainerFn = splittingByRows\n        ? findContainingColumn\n        : findContainingRow;\n\n    // Recurse until the base case is reached and then revert the container translation\n    return translateGridSplit(\n        getContainingRowColumnRecursive({\n            structure: translatedContainer.content.items,\n            itemToContain,\n            findContainerFn: nextFindContainerFn,\n            previousResult: translatedContainer,\n        }) as SplitGridEntry, // NOSONAR\n        container.origin\n    );\n};\n\n/**\n * Get the smallest row or column (not necessarily full-width or full-height) which\n * contains a specified item, but is not solely the specified item. If no such container\n * is found then undefined is returned\n * @param {GridLayoutStructure} param0.structure The layout structure to be searched\n * @param {AbsoluteBlockItem} param0.itemToContain The block item to be contained by the resulting row/column\n * @returns The smallest row or column containing the target item and at least one other block item, or undefined\n */\nexport const getContainingRowColumn = ({\n    structure,\n    itemToContain,\n}: {\n    structure: GridLayoutStructure;\n    itemToContain: AbsoluteBlockItem;\n}): ContainingRowColumn =>\n    getContainingRowColumnRecursive({\n        structure,\n        itemToContain,\n        findContainerFn: findContainingRow,\n    });\n", "import type { AbsoluteBlockItem, Coordinate } from '@splunk/dashboard-types';\nimport type { SplitGridEntry } from './gridOrderUtils';\nimport {\n    splitGrid,\n    translateBlockItem,\n    translateBlockItems,\n} from './splitGridStructure';\n\n/**\n * Mapping of block item ID to block item which contains changes to be made to a\n * grid structure in order to apply the appropriate resize behavior\n */\nexport type ResizeChanges = Record<string, AbsoluteBlockItem>;\n\ntype RecursiveDirectionalResizeArgs = {\n    container: SplitGridEntry;\n    newSize: number;\n    position: number;\n    translation: Coordinate;\n};\n\ntype RecursiveDirectionalResizeFn = (\n    args: RecursiveDirectionalResizeArgs\n) => ResizeChanges;\n\n/**\n * Recursively apply horizontal resizing to a grid structure.\n * All row splits will remain at their original width, while column splits will be resized and repositioned\n * @param {RecursiveDirectionalResizeArgs} args configuration\n * @param {SplitGridEntry} args.container The result of `splitGrid`\n * @param {number} args.newSize The new container width\n * @param {number} args.position The X-pos of the container\n * @param {Coordinate} args.translation A translation to be applied to the results\n * @returns Required block item updates for container to be resized\n */\nconst recursivelyApplyHorizontalResize: RecursiveDirectionalResizeFn = ({\n    container: {\n        content: { items, width: totalWidth },\n        origin,\n    },\n    newSize,\n    position,\n    translation,\n}) => {\n    const changes: ResizeChanges = {};\n\n    const { splitByRows, splitByColumns } = splitGrid({\n        layoutStructure: translateBlockItems(items, {\n            x: -origin.x,\n            y: -origin.y,\n        }),\n    });\n\n    // Handle resizing of row splits if they exist\n    // When handling rows for a horizontal resize the width remains unchanged\n    splitByRows.forEach((container) => {\n        Object.assign(\n            changes,\n            recursivelyApplyHorizontalResize({\n                container,\n                newSize,\n                position,\n                translation: {\n                    x: translation.x + origin.x,\n                    y: translation.y + origin.y,\n                },\n            })\n        );\n    });\n\n    // Handle resizing of column splits if they exist\n    // When handling columns for a horizontal resize the width and X-pos should be updated\n    let colPosition = position;\n    splitByColumns.forEach((container, idx) => {\n        let newColWidth = Math.floor(\n            newSize * (container.content.width / totalWidth)\n        );\n\n        if (\n            // If resizing the last column\n            idx === splitByColumns.length - 1 &&\n            // and there's a fractional correction needed\n            colPosition + newColWidth !== position + newSize\n        ) {\n            // then override the calculated width to fill the would-be gap\n            newColWidth = position + newSize - colPosition;\n        }\n\n        Object.assign(\n            changes,\n            recursivelyApplyHorizontalResize({\n                container,\n                newSize: newColWidth,\n                position: colPosition,\n                translation: {\n                    x: translation.x + origin.x,\n                    y: translation.y + origin.y,\n                },\n            })\n        );\n\n        colPosition += newColWidth;\n    });\n\n    // Base case: there was nothing to split (single item in container)\n    if (splitByColumns.length === 0 && splitByRows.length === 0) {\n        items.forEach((item) => {\n            const { position: itemPos } = translateBlockItem(item, translation);\n\n            changes[item.item] = {\n                ...item,\n                position: {\n                    ...itemPos,\n                    x: position,\n                    w: newSize,\n                },\n            };\n        });\n    }\n\n    return changes;\n};\n\n/**\n * Recursively apply vertical resizing to a grid structure.\n * All column splits will remain at their original height, while row splits will be resized and repositioned\n * @param {RecursiveDirectionalResizeArgs} args configuration\n * @param {SplitGridEntry} args.container The result of `splitGrid`\n * @param {number} args.newSize The new container height\n * @param {number} args.position The Y-pos of the container\n * @param {Coordinate} args.translation A translation to be applied to the results\n * @returns Required block item updates for container to be resized\n */\nconst recursivelyApplyVerticalResize: RecursiveDirectionalResizeFn = ({\n    container: {\n        content: { items, height: totalHeight },\n        origin,\n    },\n    newSize,\n    position,\n    translation,\n}) => {\n    const changes: ResizeChanges = {};\n\n    const { splitByRows, splitByColumns } = splitGrid({\n        layoutStructure: translateBlockItems(items, {\n            x: -origin.x,\n            y: -origin.y,\n        }),\n    });\n\n    // Handle resizing of column splits if they exist\n    // When handling columns for a vertical resize the height remains unchanged\n    splitByColumns.forEach((container) => {\n        Object.assign(\n            changes,\n            recursivelyApplyVerticalResize({\n                container,\n                newSize,\n                position,\n                translation: {\n                    x: translation.x + origin.x,\n                    y: translation.y + origin.y,\n                },\n            })\n        );\n    });\n\n    // Handle resizing of row splits if they exist\n    // When handling rows for a vertical resize the height and Y-pos should be updated\n    let rowPosition = position;\n    splitByRows.forEach((container, idx) => {\n        let newRowHeight = Math.floor(\n            newSize * (container.content.height / totalHeight)\n        );\n\n        if (\n            // If resizing the last row\n            idx === splitByRows.length - 1 &&\n            // and there's a fractional correction needed\n            rowPosition + newRowHeight !== position + newSize\n        ) {\n            // then override the calculated height to fill the would-be gap\n            newRowHeight = position + newSize - rowPosition;\n        }\n\n        Object.assign(\n            changes,\n            recursivelyApplyVerticalResize({\n                container,\n                newSize: newRowHeight,\n                position: rowPosition,\n                translation: {\n                    x: translation.x + origin.x,\n                    y: translation.y + origin.y,\n                },\n            })\n        );\n\n        rowPosition += newRowHeight;\n    });\n\n    // Base case: there was nothing to split (single item in container)\n    if (splitByColumns.length === 0 && splitByRows.length === 0) {\n        items.forEach((item) => {\n            const { position: itemPos } = translateBlockItem(item, translation);\n\n            changes[item.item] = {\n                ...item,\n                position: {\n                    ...itemPos,\n                    y: position,\n                    h: newSize,\n                },\n            };\n        });\n    }\n\n    return changes;\n};\n\n// Configuration for horizontal resize. Calculations for vertical/horizontal logic are equal, albeit with different variables\nconst HorizontalResizeConfig = {\n    dimension: 'width',\n    blockSizeDimension: 'w',\n    blockPosDimension: 'x',\n    splitGridConfig: 'columns',\n    splitGridKey: 'splitByColumns',\n    recursiveResizeFn: recursivelyApplyHorizontalResize,\n} as const;\n\n// Configuration for vertical resize. Calculations for vertical/horizontal logic are equal, albeit with different variables\nconst VerticalResizeConfig = {\n    dimension: 'height',\n    blockSizeDimension: 'h',\n    blockPosDimension: 'y',\n    splitGridConfig: 'rows',\n    splitGridKey: 'splitByRows',\n    recursiveResizeFn: recursivelyApplyVerticalResize,\n} as const;\n\ntype HandleResizingArgs = {\n    container?: SplitGridEntry;\n    itemToRemove: AbsoluteBlockItem;\n    config: typeof HorizontalResizeConfig | typeof VerticalResizeConfig;\n};\n\n/**\n * Generate a set of block item changes for the given container which will fill the\n * horizontal or vertical space originally being consumed by the item to be removed\n * @param {HandleResizingArgs} param0\n * @param {SplitGridEntry} param0.container A grid split entry, returned from `getContainingRowColumn`\n * @param {AbsoluteBlockItem} param0.itemToRemove The item being removed from the structure, whose\n * width or height should be redistributed to the other items in the structure\n * @param {HorizontalResizeConfig | VerticalResizeConfig} param0.config Configuration object for resize calculations\n * @returns {ResizeChanges} Object detailing block item changes needed for the resize\n */\nconst handleResizing = ({\n    container,\n    itemToRemove,\n    config: {\n        dimension,\n        blockSizeDimension,\n        blockPosDimension,\n        splitGridConfig,\n        splitGridKey,\n        recursiveResizeFn,\n    },\n}: HandleResizingArgs): ResizeChanges => {\n    if (!container) {\n        return {};\n    }\n\n    const {\n        origin,\n        content: {\n            // Items in the container which are being resized\n            items: impactedItems,\n            // The important container dimension (width or height) being recalculated\n            [dimension]: containerSize,\n        },\n    } = container;\n\n    // The negated origin will be used for transposing the grid while calculating mutations\n    // so nested utilites can always assume an origin of (0, 0) in the received structure\n    const negatedOrigin = { x: -origin.x, y: -origin.y };\n\n    if (impactedItems.length < 2) {\n        // Ideally this shouldn't happen, but to be safe include a base case\n        return {};\n    }\n\n    if (impactedItems.length === 2) {\n        // If there are only two items in the container then we just need to take the\n        // one not being removed and make its size/position equal to the container\n        // dimensions and origin\n        const itemToUpdate =\n            impactedItems[0].item !== itemToRemove.item\n                ? impactedItems[0]\n                : impactedItems[1];\n\n        return {\n            [itemToUpdate.item]: {\n                ...itemToUpdate,\n                position: {\n                    ...itemToUpdate.position,\n                    [blockPosDimension]: origin[blockPosDimension],\n                    [blockSizeDimension]: containerSize,\n                },\n            },\n        };\n    }\n\n    const pendingChanges: ResizeChanges = {};\n\n    // When running vertical resize get the splitByRows, else get splitByColumns\n    // because the desired split should isolate the item being removed into a single\n    // split entry\n    const {\n        [splitGridKey]: splitByResizeDimension,\n        itemToRemove: {\n            position: { [blockSizeDimension]: itemToRemoveSize },\n        },\n    } = splitGrid({\n        layoutStructure: translateBlockItems(impactedItems, negatedOrigin),\n        splitConfig: splitGridConfig,\n        idToRemove: itemToRemove.item,\n    });\n\n    // Calculate the percentage of the container taken up by the item\n    // being removed and distribute that evenly to all other splits\n    const pctToDistribute =\n        itemToRemoveSize / (splitByResizeDimension.length - 1) / containerSize;\n\n    // Track the current working position for the block items being mutated. As sizes are updated, item positions need to shift accordingly\n    let itemPosition = origin[blockPosDimension];\n\n    // Track the terminus of the container. After the last resize calculation itemPosition should equal containerEdge\n    const containerEdge = origin[blockPosDimension] + containerSize;\n\n    // Start by assuming the item being removed is last in the split array. This means the last chance to account for fractional resize corrections (FRC)\n    // is the next-to-last split entry. If during processing the item being removed is found BEFORE the end of the array, then increment lastFRCIdx\n    // to indicate that the last split entry can now be used for fractional resize correction\n    let lastFRCIdx = splitByResizeDimension.length - 2;\n\n    splitByResizeDimension.forEach((split, idx) => {\n        // Skip the item being removed if it is found, and update lastFRCIdx per above\n        if (split.content.items[0].item === itemToRemove.item) {\n            lastFRCIdx += 1;\n            return;\n        }\n\n        // Calculate the new size for the split. This calculation may be updated if\n        // the resize calculations had to be floored and a fractional size remains\n        const splitSize = split.content[dimension] / containerSize;\n        let newSize = Math.floor(containerSize * (pctToDistribute + splitSize));\n\n        if (idx === lastFRCIdx && itemPosition + newSize !== containerEdge) {\n            // Adjust newSize as it wouldn't result in a correctly-dimensioned grid\n            newSize = containerEdge - itemPosition;\n        }\n\n        Object.values(\n            recursiveResizeFn({\n                container: split,\n                newSize,\n                position: itemPosition,\n                translation: origin,\n            })\n        ).forEach((change) => {\n            pendingChanges[change.item] = change;\n        });\n\n        // Increment the working item position (position of the next split to be resized)\n        itemPosition += newSize;\n    });\n\n    return pendingChanges;\n};\n\n/**\n * An object containing properties:\n *\n * `container` - the result of calling `getContainingRowColumn`\n *\n * `itemToRemove` - the {@link AbsoluteBlockItem block item} being removed from the grid, causing the resize\n */\nexport type HandleDirectionalResizingArgs = Pick<\n    HandleResizingArgs,\n    'container' | 'itemToRemove'\n>;\n\n/**\n * Handles horizontal resizing of a container.\n * The width of itemToRemove will be proportionally redistributed to all other column splits\n * in the container based upon the splits' width as a percentage of the total container width\n * @param {HandleDirectionalResizingArgs} args container and itemToRemove\n * @param {SplitGridEntry} args.container The result of `getContainingRowColumn`\n * @param {AbsoluteBlockItem} args.itemToRemove The block item being removed from the structure, causing the resize\n * @returns {ResizeChanges} Object detailing block item changes needed for the resize\n */\nexport const handleHorizontalResizing = (\n    args: HandleDirectionalResizingArgs\n): ResizeChanges => handleResizing({ ...args, config: HorizontalResizeConfig });\n\n/**\n * Handles vertical resizing of a container.\n * The height of itemToRemove will be proportionally redistributed to all other row splits in\n * the container based upon the splits' height as a percentage of the total container height\n * @param {HandleDirectionalResizingArgs} args container and itemToRemove\n * @param {SplitGridEntry} args.container The non-nullable result of `getContainingRowColumn`\n * @param {AbsoluteBlockItem} args.itemToRemove The block item being removed from the structure, causing the resize\n * @returns {ResizeChanges} Object detailing block item changes needed for the resize\n */\nexport const handleVerticalResizing = (\n    args: HandleDirectionalResizingArgs\n): ResizeChanges => handleResizing({ ...args, config: VerticalResizeConfig });\n", "import { cloneDeep } from 'lodash';\nimport { updateRemovedVizNeighbors } from '@splunk/dashboard-utils';\nimport type { AbsoluteBlockItem } from '@splunk/dashboard-types';\n\nimport { getContainingRowColumn } from './getContainingRowColumn';\nimport {\n    handleHorizontalResizing,\n    handleVerticalResizing,\n} from './gridLayoutAutoResize';\nimport type { ReflowFn } from '../hooks';\n\ntype ItemMap = Record<string, AbsoluteBlockItem>;\n\n/**\n * Create a deep clone of a source AbsoluteBlockItem array\n * @param {AbsoluteBlockItem[]} source source array to be cloned\n * @returns Deep-clone of source array\n */\nconst cloneLayoutStructure = (\n    source: AbsoluteBlockItem[]\n): AbsoluteBlockItem[] => {\n    if (!source.length) {\n        return [];\n    }\n\n    // This could be structuredClone to remove the lodash dep, but it would need a polyfill\n    return cloneDeep(source);\n};\n\n/**\n * Create an object which maps the structure using AbsoluteBlockItem['item'] as\n * the key and the corresponding AbsoluteBlockItem as the value. This makes it\n * possible to store, access, and update block item data without array iteration\n * @param {AbsoluteBlockItem[]} structure The array of AbsoluteBlockItem objects to process\n * @returns {ItemMap} The generated block item mapping\n */\nconst createStructureMap = (structure: AbsoluteBlockItem[]): ItemMap =>\n    Object.fromEntries(structure.map((item) => [item.item, item]));\n\n/**\n * Calculate the width of a layout structure by calculating the left and right extremes\n * of the block item positions\n * @param {AbsoluteBlockItem[]} structure The block items to process\n * @returns {Number} The calculated difference between the right-most and left-most edges of the structure entries\n */\nconst getWidthFromStructure = (structure: AbsoluteBlockItem[]): number => {\n    const [min, max] = structure.reduce(\n        ([minX, maxX], { position: { x, w } }) => [\n            // minX = either block item left or current minX (initial: MAX_SAFE_INTEGER)\n            Math.min(minX, x),\n            // maxX = either block item right or current maxX (initial: 0)\n            Math.max(maxX, x + w),\n        ],\n        [Number.MAX_SAFE_INTEGER, 0]\n    );\n\n    // Return max - min or 0, whichever is larger (if no structure to be reduced then\n    // max - min = MIN_SAFE_INTEGER which is not a desired return value, so use 0)\n    return Math.max(max - min, 0);\n};\n\n/**\n * Remove and return the AbsoluteBlockItem from itemsToRemove which is in most top-left position.\n *\n * \u26A0 This mutates the itemsToRemove argument \u26A0\n * @param {AbsoluteBlockItem[]} arg0.itemsToRemove Array of AbsoluteBlockItem objects being removed from the layout\n * @param {ItemMap} arg0.itemMap A map of AbsoluteBlockItem['item'] :: AbsoluteBlockItem which contains up-to-date block item properties\n * @returns {AbsoluteBlockItem} The top-left most AbsoluteBlockItem from itemsToRemove.\n */\nconst popTopLeftBlock = ({\n    itemsToRemove,\n    itemMap,\n}: {\n    itemsToRemove: AbsoluteBlockItem[];\n    itemMap: ItemMap;\n}) => {\n    let result = itemMap[itemsToRemove[0].item];\n    let resultIdx = 0;\n    itemsToRemove.forEach(({ item }, idx) => {\n        const itemMapItem = itemMap[item];\n        // Lower Y-Position = closer to top. Always take that.\n        if (result.position.y > itemMapItem.position.y) {\n            result = itemMapItem;\n            resultIdx = idx;\n            return;\n        }\n\n        // Equal Y-Position but lower X-Position = Closer to left. Take that.\n        if (\n            result.position.y === itemMapItem.position.y &&\n            result.position.x > itemMapItem.position.x\n        ) {\n            result = itemMapItem;\n            resultIdx = idx;\n        }\n    });\n\n    // Splice the array to remove the result and then return it (the result)\n    itemsToRemove.splice(resultIdx, 1);\n    return result;\n};\n\n/**\n * Apply the data stored in itemMap to the structure array and remove itemToRemove\n * from both the structure array and itemMap object.\n *\n * \u26A0 This mutates the structure and itemMap arguments \u26A0\n * @param {AbsoluteBlockItem[]} arg0.structure The layout structure array to be updated\n * @param {ItemMap} arg0.itemMap The mapping object for all entries of the layout structure array\n * @param {AbsoluteBlockItem} arg0.itemToRemove The AbsoluteBlockItem to be removed from the structure\n * @param {ItemMap} arg0.updatesMap The mapping object for any updates to be applied to the layout structure array\n */\nconst applyUpdatesToStructure = ({\n    structure,\n    itemMap,\n    itemToRemove,\n    updatesMap,\n}: {\n    structure: AbsoluteBlockItem[];\n    itemMap: ItemMap;\n    itemToRemove: AbsoluteBlockItem;\n    updatesMap: ItemMap;\n}) => {\n    let idxToRemove = -1;\n\n    // Iterate the structure. If itemToRemove is found, track its index.\n    // Else apply the update from updatesMap to both the structure and itemMap if defined.\n    structure.forEach((item, idx) => {\n        if (item.item === itemToRemove.item) {\n            idxToRemove = idx;\n        } else if (item.item in updatesMap) {\n            /* eslint-disable no-param-reassign */\n            structure[idx] = updatesMap[item.item];\n            itemMap[item.item] = updatesMap[item.item];\n            /* eslint-enable no-param-reassign */\n        }\n    });\n\n    // If itemToRemove is found in the structure (it should be), then delete it\n    if (idxToRemove >= 0) {\n        structure.splice(idxToRemove, 1);\n    }\n\n    // Remove itemToRemove from itemMap\n    // eslint-disable-next-line no-param-reassign\n    delete itemMap[itemToRemove.item];\n};\n\n/**\n * Handle the removal of a layout item which cannot be handled through recursive\n * resizing of neighbors. This occurs when removing a full-row item or if something\n * goes wrong during an earlier step of the reflow algorithm.\n *\n * \u26A0 This mutates the structure and itemMap arguments \u26A0\n * @param {AbsoluteBlockItem[]} arg0.structure The layout structure array to be updated\n * @param {ItemMap} arg0.itemMap The mapping object for all entries of the layout structure array\n * @param {AbsoluteBlockItem} arg0.itemToRemove The AbsoluteBlockItem to be removed from the structure\n * @param {Number} arg0.width The width of the layout structure\n */\nconst baseCaseRemoval = ({\n    structure,\n    itemMap,\n    itemToRemove,\n    width,\n}: {\n    structure: AbsoluteBlockItem[];\n    itemMap: ItemMap;\n    itemToRemove: AbsoluteBlockItem;\n    width: number;\n}) => {\n    // Get an array representing neighbor updates to be made\n    const updates = updateRemovedVizNeighbors({\n        items: structure,\n        itemToRemove,\n        width,\n    });\n\n    // Convert that array into an object to make processing easier\n    const updatesMap = createStructureMap(updates);\n\n    // Apply the updates from updateRemovedVizNeighbors onto the structure\n    // and remove itemToRemove from the structure array\n    applyUpdatesToStructure({\n        structure,\n        itemMap,\n        itemToRemove,\n        updatesMap,\n    });\n};\n\n/**\n * Handle the recursive removal of items from the layout structure until\n * itemsToRemove is an empty array.\n *\n * \u26A0 This mutates all received arguments \u26A0\n * @param {AbsoluteBlockItem[]} arg0.structure The layout structure array to be updated\n * @param {AbsoluteBlockItem[]} arg0.itemsToRemove The array of all AbsoluteBlockItem objects to be removed from the structure\n * @param {ItemMap} arg0.itemMap The mapping object for all entries of the layout structure array\n */\nconst handleRecursiveItemRemoval = ({\n    structure,\n    itemsToRemove,\n    itemMap,\n}: {\n    structure: AbsoluteBlockItem[];\n    itemsToRemove: AbsoluteBlockItem[];\n    itemMap: ItemMap;\n}) => {\n    if (itemsToRemove.length === 0) {\n        return;\n    }\n\n    const itemToRemove = popTopLeftBlock({ itemsToRemove, itemMap });\n    const container = getContainingRowColumn({\n        structure,\n        itemToContain: itemToRemove,\n    });\n\n    if (!container || container.content.items.length <= 1) {\n        baseCaseRemoval({\n            structure,\n            itemMap,\n            width: container?.gridWidth ?? getWidthFromStructure(structure),\n            itemToRemove,\n        });\n    } else {\n        const { width, height } = container.content;\n        let updatesMap: ItemMap | undefined;\n\n        if (itemToRemove.position.w === width) {\n            // Item to remove spans the full width of the container, so vertical resizing is needed\n            updatesMap = handleVerticalResizing({ container, itemToRemove });\n        } else if (itemToRemove.position.h === height) {\n            // Item to remove spans the full height of the container, so horizontal resizing is needed\n            updatesMap = handleHorizontalResizing({ container, itemToRemove });\n        } else {\n            // Something went wrong, but don't break the process\n            baseCaseRemoval({\n                structure,\n                width: container?.gridWidth ?? getWidthFromStructure(structure),\n                itemToRemove,\n                itemMap,\n            });\n        }\n\n        if (updatesMap) {\n            applyUpdatesToStructure({\n                structure,\n                itemMap,\n                itemToRemove,\n                updatesMap,\n            });\n        }\n    }\n\n    handleRecursiveItemRemoval({ structure, itemsToRemove, itemMap });\n};\n\n/**\n * Generate a new layout structure which has all itemsToRemove entries taken out\n * of the structure and any remaining content updated to fill the space originally\n * ued by the removed block items\n * @param {AbsoluteBlockItem[]} initialStructure The initial layout structure array to be processed\n * @param {AbsoluteBlockItem[]} itemsToRemove The array of all AbsoluteBlockItem objects to be removed from the structure\n * @returns {AbsoluteBlockItem[]} The updated layout structure with applied item removals\n */\nexport const gridLayoutShowHideReflow: ReflowFn = (\n    initialStructure,\n    itemsToRemove\n) => {\n    if (!itemsToRemove.length) {\n        return initialStructure;\n    }\n\n    // Clone the initialStructure array so the parameter mutated\n    const newStructure = cloneLayoutStructure(\n        initialStructure as AbsoluteBlockItem[]\n    );\n\n    // Clone the itemsToRemove array so the parameter isn't mutated\n    const clonedItemsToRemove = cloneLayoutStructure(\n        itemsToRemove as AbsoluteBlockItem[]\n    );\n\n    // Create a Record<string, AbsoluteBlockItem> to make indexing easier\n    const itemMap = createStructureMap(newStructure);\n\n    // Update the newStructure array\n    handleRecursiveItemRemoval({\n        structure: newStructure,\n        itemsToRemove: clonedItemsToRemove,\n        itemMap,\n    });\n\n    return newStructure;\n};\n", "import React, {\n    useState,\n    useEffect,\n    useLayoutEffect,\n    useRef,\n    useCallback,\n    useMemo,\n    useReducer,\n} from 'react';\nimport memoizeOne from 'memoize-one';\nimport { isEqual, omit } from 'lodash';\nimport {\n    useFeatureFlags,\n    useKeyboardListener,\n    useCanvasRef,\n} from '@splunk/dashboard-context';\nimport { useTelemetryApi } from '@splunk/dashboard-telemetry';\nimport {\n    usePrevious,\n    useEventCallback,\n    useMouseMoveHandler,\n} from '@splunk/dashboard-ui';\nimport { getScrollbarWidth } from '@splunk/dashboard-utils';\n\nimport type {\n    AbsoluteBlockItem,\n    AbsolutePosition,\n    BaseLayoutProps,\n    Coordinate,\n    GridLayoutOptions,\n    GridLayoutStructure,\n    HandleDirection,\n    Mode,\n    OnItemSelected,\n    RenderLayoutItem,\n    SelectedItem,\n} from '@splunk/dashboard-types';\nimport type { CountableEvent } from '@splunk/dashboard-telemetry';\n\nimport {\n    Edge,\n    GridCanvas,\n    ItemDragPlaceholder,\n    ItemDropTarget,\n    Layer,\n    PreviewPlaceholderItem,\n    ResponsiveBlockItem,\n    type ResponsiveBlockItemProps,\n    ResponsiveBlockOutline,\n} from './components';\nimport { gridLayoutOptions } from './DefaultOptions';\nimport {\n    GRID_PADDING_PX,\n    GRID_SIZE_PX,\n    MIN_HEIGHT_PX,\n    MIN_WIDTH_PX,\n    SNAP_RANGE_PX,\n    PLACEHOLDER_SIZE_PX,\n    VIZ_PREVIEW_DELAY_MS,\n    EDGE_PREVIEW_DELAY_MS,\n} from './GridLayoutConstants';\nimport gridLayoutOptionsSchema from './gridLayoutOptionsSchema';\nimport {\n    computeEdges,\n    findEdgesInBoundary,\n    findSnappableEdges,\n    moveVerticalEdge,\n    moveHorizontalEdge,\n    getVerticalBoundaries,\n    getHorizontalBoundaries,\n    applyVizPadding,\n} from './utils/edgeUtils';\nimport {\n    filterSelectedItems,\n    getBlockItems,\n    getFilteredStructure,\n    getItem,\n    getStructureItem,\n    gridReducer,\n    hasPreviewItem,\n    initializeGridReducer,\n    resetLayoutAction,\n    updateItemAction,\n} from './utils/gridLayoutUtils';\nimport { getGridLayoutOrder } from './utils/gridOrderUtils';\nimport {\n    isMouseOnEdge,\n    updateDropOnEdge,\n    findQuadrant,\n    updateDropOnViz,\n    updateItems,\n    previewDropOnEdge,\n    previewDropOnViz,\n    validateLayoutStructure,\n    getDimensions,\n    formatEdgeWrapper,\n    isInvalidAdjacentVizDrop,\n    isDropOnOwnEdge,\n} from './utils/gridUtils';\nimport {\n    computeScaleToFit,\n    computeMaxHeight,\n    updateBlockItemSize,\n    getOffset,\n    getClientPosition,\n    findTopBlockItemByPosition,\n    updateBlockItemPosition,\n    scaleGridLayoutStructureByWidth,\n} from './utils/layoutUtils';\nimport { gridLayoutShowHideReflow } from './utils/gridLayoutShowHide';\n\nimport type {\n    EdgeItem,\n    Quadrant,\n    LayoutError,\n    EdgeBoundaries,\n    VerticalBoundaries,\n    HorizontalBoundaries,\n    EdgeAppearance,\n    Offset,\n} from './types';\nimport { withLayoutShowHide } from './enhancers';\n\nexport type GridLayoutProps = BaseLayoutProps<\n    GridLayoutStructure,\n    GridLayoutOptions\n>;\n\nconst HANDLE_DIRECTIONS: HandleDirection[] = [];\n\ninterface RenderBlockItemsProps {\n    layoutStructure: GridLayoutStructure;\n    renderLayoutItem: RenderLayoutItem;\n    handleItemSelected: ResponsiveBlockItemProps['onItemSelected'];\n    isBlockItemMoving: boolean;\n    selectedItem: SelectedItem;\n    mode: Mode;\n    errors: { itemId: string; messages: string[] }[];\n    padding: number;\n    canvasHeight: number;\n}\n\nconst MemoizedBlockItem = React.memo(\n    ResponsiveBlockItem,\n    (prevProps, nextProps) => {\n        if (nextProps.y + nextProps.h === nextProps.canvasHeight) {\n            return isEqual(prevProps, nextProps);\n        }\n        const prevPropsWithoutCanvasHeight: Omit<\n            ResponsiveBlockItemProps,\n            'canvasHeight'\n        > = omit(prevProps, 'canvasHeight');\n        const nextPropsWithoutCanvasHeight: Omit<\n            ResponsiveBlockItemProps,\n            'canvasHeight'\n        > = omit(nextProps, 'canvasHeight');\n        return isEqual(\n            prevPropsWithoutCanvasHeight,\n            nextPropsWithoutCanvasHeight\n        );\n    }\n);\nconst MemoizedBlockOutline = React.memo(ResponsiveBlockOutline);\nconst MemoizedEdge = React.memo(Edge);\n\n/**\n * loop through structure to render each block. Memoized block rendering to prevent rerender of each block\n */\nconst renderBlockItems = memoizeOne(\n    ({\n        layoutStructure,\n        renderLayoutItem,\n        handleItemSelected,\n        isBlockItemMoving,\n        selectedItem,\n        mode,\n        errors,\n        padding,\n        canvasHeight,\n    }: RenderBlockItemsProps): React.ReactNode => {\n        return layoutStructure.map((item) => {\n            const key = item.item;\n            if (key === 'preview-old-item') {\n                return null;\n            }\n\n            const isSelected = selectedItem?.id === key;\n\n            // Highlight the item if:\n            // 1. in view mode\n            // 2. in edit mode and no item is selected\n            // 3. in edit mode and the item is selected\n            let appearance: ResponsiveBlockItemProps['appearance'] =\n                mode === 'view' || !selectedItem || isSelected\n                    ? 'highlighted'\n                    : 'visible';\n\n            // If the selected visualization is moving, then we want to hide the viz itself since the\n            //   preview placeholder will be rendered on top. The hiding is done using `visibility: hidden`, to avoid\n            //   causing the viz to unmount, which would re-run the search.\n            if (isSelected && isBlockItemMoving) {\n                appearance = 'hidden';\n            }\n\n            // find the error object belonging to this viz if the error exists\n            let errorMessages;\n            if (errors) {\n                const vizErrors = errors.find(({ itemId }) => itemId === key);\n                errorMessages = vizErrors?.messages;\n            }\n\n            return (\n                <MemoizedBlockItem\n                    key={key}\n                    itemId={key}\n                    type={item.type}\n                    x={item.position.x}\n                    y={item.position.y}\n                    h={item.position.h}\n                    w={item.position.w}\n                    padding={padding}\n                    canvasHeight={canvasHeight}\n                    renderLayoutItem={renderLayoutItem}\n                    onItemSelected={handleItemSelected}\n                    appearance={appearance}\n                    errorMessages={errorMessages}\n                />\n            );\n        });\n    },\n    isEqual\n);\n\nconst BOTTOM_EDGE_MIN_SPEED = 2;\nconst BOTTOM_EDGE_MAX_SPEED = 4;\nconst BOTTOM_RESIZING_SCROLL_SPEED = 50;\nconst CANVAS_BOTTOM_PADDING = 8;\n\nconst defaultLayoutStructure: GridLayoutStructure = [];\n\nconst BaseGridLayout = ({\n    layoutId,\n    onLayoutItemsSelect,\n    selectedItems: selectedLayoutItems,\n    layoutStructure = defaultLayoutStructure,\n    onLayoutStructureChange,\n    options = {},\n    renderLayoutItem,\n    mode,\n    scale,\n    setCanvasHeight,\n    canvasWidth,\n}: Omit<\n    GridLayoutProps & {\n        scale: number;\n        setCanvasHeight: React.Dispatch<number>;\n        canvasWidth: number;\n    },\n    'containerWidth'\n>): JSX.Element => {\n    const canvasRef = useCanvasRef(layoutId);\n    const keyboardListener = useKeyboardListener();\n    const telemetryAPI = useTelemetryApi();\n    const { enableGridLayoutErrors, enableGridLayoutCssScaling } =\n        useFeatureFlags();\n    const { backgroundColor, gutterSize = gridLayoutOptions.gutterSize } =\n        options;\n\n    // gutterSize is split between the two panels it shares\n    const panelPadding = gutterSize / 2;\n\n    const [gridState, dispatch] = useReducer(\n        gridReducer,\n        layoutStructure,\n        initializeGridReducer\n    );\n    const maxHeight = computeMaxHeight(getBlockItems(gridState));\n\n    useLayoutEffect(() => {\n        setCanvasHeight(maxHeight);\n    }, [setCanvasHeight, maxHeight]);\n\n    const [isBlockItemMoving, setIsBlockItemMoving] = useState(false);\n\n    const [edges, setEdges] = useState<EdgeItem[]>(\n        computeEdges({\n            layout: layoutStructure,\n            canvasWidth,\n            canvasHeight: computeMaxHeight(layoutStructure), // need to recompute height on layout change\n        })\n    );\n    const [snappableEdges, setSnappableEdges] = useState<EdgeItem[]>([]);\n    const [mousePosition, setMousePosition] = useState<Coordinate | null>(null);\n    const [edgesBeforeMove, setEdgesBeforeMove] = useState<EdgeItem[] | null>(\n        null\n    );\n    const [invalidEdgeId, setInvalidEdgeId] = useState<string | null>(null);\n    const [hoveredEdge, setHoveredEdge] = useState<EdgeItem | null>(null);\n\n    const [initialItemToMove, setInitialItemToMove] =\n        useState<AbsoluteBlockItem | null>(null);\n    const [hoveredBlock, setHoveredBlock] = useState<AbsoluteBlockItem | null>(\n        null\n    );\n    const [hoveredQuadrant, setHoveredQuadrant] = useState<Quadrant | null>(\n        null\n    );\n    // sonar doesn't like the that this is not [x, setX]\n    const [, setForceUpdate] = useState(0); // NOSONAR\n    const [selectedItemsForEdge, setSelectedItemsForEdge] = useState<string[]>(\n        []\n    );\n\n    const [isInvalidVizDrop, setIsInvalidVizDrop] = useState(false);\n    const [showPreviewPlaceholder, setShowPreviewPlaceholder] = useState(true);\n    const [layoutErrors, setLayoutErrors] = useState<LayoutError[]>([]);\n\n    const isDraggingEdge = useRef(false);\n    const delayPreviewEdge = useRef<NodeJS.Timeout | null>(null);\n    const delayPreviewViz = useRef<NodeJS.Timeout | null>(null);\n    /**\n     * the follow values are saved in refs instead of states for two reasons:\n     *     1. they don't affect rendering;\n     *     2. they should be updated synchronously in order to handle mouse events https://jira.splunk.com/browse/SCP-25610\n     */\n    // mouseDownEdge is tracking the initial edge state when mouse down event happens, it is a snapshot, it won't update when mouse moves\n    // the reason we need it is because we use the initial edge position and latest mouse position to calculate latest edge position\n    const mouseDownEdge = useRef<EdgeItem | null>(null);\n    const edgeMouseDownPosition = useRef<Coordinate | null>(null);\n    const edgeBoundaries = useRef<EdgeBoundaries | null>(null);\n    const edgesInBoundary = useRef<EdgeItem[] | null>(null);\n    const cumulativeScrollIncrease = useRef(0);\n    const edgeVelocity = useRef(0);\n\n    const containsPreviewItem = hasPreviewItem(gridState);\n\n    const sendTelemetry = useCallback(\n        (eventData: CountableEvent) => {\n            telemetryAPI.collect(eventData);\n        },\n        [telemetryAPI]\n    );\n\n    const firstSelectedItemStructure = useMemo(\n        () =>\n            selectedLayoutItems?.length\n                ? getItem(gridState, selectedLayoutItems[0].id)\n                : null,\n        [gridState, selectedLayoutItems]\n    );\n\n    const prevLayoutStructure = usePrevious(layoutStructure);\n\n    useEffect(() => {\n        // only show errors when we're in edit mode\n        if (mode === 'edit' && enableGridLayoutErrors) {\n            const errors = validateLayoutStructure({\n                layout: layoutStructure,\n                canvasBounds: { x: 0, y: 0, w: canvasWidth, h: maxHeight },\n            });\n            setLayoutErrors(errors);\n        } else if (mode === 'view') {\n            // in case we had errors in edit mode, remove them when going to view mode\n            setLayoutErrors([]);\n        }\n        // We only want this to run when we commit changes to item position/size.\n        //  For example, we want it to run after resizing (on mouse up), not during.\n        //  And also when we switch modes, since we only want to show errors in edit mode\n    }, [layoutStructure, mode, enableGridLayoutErrors, canvasWidth, maxHeight]);\n\n    // this ensures the layout reducer gets the latest layoutStructure\n    useEffect(() => {\n        // TODO: we should look into how to make `layoutStructure` not constantly change if the actual content of the layoutStructure did not change.\n        // Currently, we have to do a deep comparison, because `layoutStructure` as an object reference is always changing.\n        if (isEqual(prevLayoutStructure, layoutStructure)) {\n            return;\n        }\n        dispatch(resetLayoutAction(layoutStructure));\n\n        const canvasHeight = computeMaxHeight(layoutStructure);\n\n        setEdges(\n            computeEdges({\n                layout: layoutStructure,\n                canvasWidth,\n                canvasHeight, // need to recompute height on layout change\n            })\n        );\n    }, [layoutStructure, canvasWidth, prevLayoutStructure]);\n\n    // Not idempotent, but doesn't matter because this will only result in resetting a mouseup handler, not a rerender of any component\n    const handleLayoutStructureChange = useCallback(() => {\n        const layout = getBlockItems(gridState);\n        onLayoutStructureChange(layout);\n    }, [onLayoutStructureChange, gridState]);\n\n    /**\n     * return valid selected items, this needs to be a function because we cannot detect structureRegistry change.\n     */\n    const getSelectedItems = useMemo(() => {\n        let itemsCache: SelectedItem[];\n\n        return () => {\n            const filteredItems = filterSelectedItems(\n                layoutStructure,\n                selectedLayoutItems\n            );\n\n            if (!isEqual(itemsCache, filteredItems)) {\n                itemsCache = filteredItems;\n            }\n\n            return itemsCache;\n        };\n    }, [layoutStructure, selectedLayoutItems]);\n\n    /**\n     * set selected items\n     * @param {Object} e mouse event\n     * @param {Array} selectedItems list of selected Items\n     */\n    const handleItemSelected = useCallback<OnItemSelected>(\n        (_e, selectedItems = []) => {\n            // filter out other Items as we do not currently support multi selecting Items\n            const selectedItem =\n                selectedItems.length > 0\n                    ? [selectedItems[selectedItems.length - 1]]\n                    : [];\n            onLayoutItemsSelect(selectedItem);\n        },\n        [onLayoutItemsSelect]\n    );\n\n    // If we're not scaling the grid via CSS we don't need to scale the mouse position\n    const mouseScale = enableGridLayoutCssScaling ? scale : 1;\n\n    /**\n     * Handles scrolling in Canvas when a Viz is being dragged to the top or bottom of the visible Canvas\n     */\n    // TODO: something is a little odd here...when showing an edge preview on canvas bottom causes scrolling things break a little\n    useEffect(() => {\n        let delayed: NodeJS.Timeout;\n        const layoutContainer = canvasRef.current?.parentElement;\n        if (!isBlockItemMoving || !mousePosition || !layoutContainer) {\n            return () => undefined;\n        }\n        const visibleCanvasHeight = layoutContainer.clientHeight / mouseScale;\n\n        const hasScrolledToBottom =\n            layoutContainer.scrollTop / mouseScale + visibleCanvasHeight >=\n            maxHeight;\n\n        const isInBottomScrollArea =\n            layoutContainer.scrollTop / mouseScale +\n                visibleCanvasHeight -\n                mousePosition.y <\n            MIN_HEIGHT_PX;\n\n        const hasScrolledToTop = layoutContainer.scrollTop <= 0;\n\n        const isInTopScrollArea =\n            mousePosition.y - layoutContainer.scrollTop / mouseScale <\n            MIN_HEIGHT_PX;\n        if (!hasScrolledToBottom && isInBottomScrollArea) {\n            const increment = Math.min(\n                Math.abs(\n                    maxHeight -\n                        (layoutContainer.scrollTop / mouseScale +\n                            visibleCanvasHeight)\n                ),\n                10\n            );\n            delayed = setTimeout(() => {\n                layoutContainer.scrollTop += increment;\n                setMousePosition((pos) =>\n                    pos\n                        ? {\n                              ...pos,\n                              y: pos.y + increment / mouseScale,\n                          }\n                        : null\n                );\n            }, 32);\n        } else if (!hasScrolledToTop && isInTopScrollArea) {\n            const decrement = Math.min(layoutContainer.scrollTop, 10);\n            delayed = setTimeout(() => {\n                layoutContainer.scrollTop -= decrement;\n                setMousePosition((pos) =>\n                    pos\n                        ? {\n                              ...pos,\n                              y: pos.y - decrement / mouseScale,\n                          }\n                        : null\n                );\n            }, 32);\n        }\n\n        return () => {\n            clearTimeout(delayed);\n        };\n    }, [isBlockItemMoving, mousePosition, mouseScale, maxHeight, canvasRef]);\n\n    /*\n        Reset the preview states to original values for edge preview\n    */\n    const resetEdgePreviewState = useCallback(() => {\n        if (edgesBeforeMove) {\n            // If there was an update, stop it from happening\n            if (delayPreviewEdge.current) {\n                clearTimeout(delayPreviewEdge.current);\n            }\n            // Set edges back to original ones before the move happened\n            setEdges(edgesBeforeMove);\n            // Set visualizations to original\n            dispatch(resetLayoutAction(layoutStructure));\n        }\n    }, [edgesBeforeMove, layoutStructure]);\n\n    const showEdgeDropPreview = useCallback(\n        ({ mousePos }: { mousePos: Coordinate }) => {\n            if (edgesBeforeMove === null) {\n                // Only update the edges before move once, since it will always be the same\n                setEdgesBeforeMove(edges);\n            }\n            // Compute against the initial edges before we started moving, unless they haven't been set yet\n            const validEdges = edgesBeforeMove || edges;\n            // find if the mouse is on the edge\n            const edge = validEdges.find((edgeToFind) => {\n                return isMouseOnEdge({\n                    edge: edgeToFind,\n                    mousePosition: mousePos,\n                    padding: panelPadding,\n                });\n            });\n\n            if (!edge) {\n                /* If edge is undefined, there is no edge being hovered */\n                // If an edge was previously hovered, then undo the state changes made, and revert back to original\n                // This deals with hovering on an edge and then hovering off it\n                if (hoveredEdge) {\n                    setHoveredEdge(null);\n                    setInvalidEdgeId(null);\n                    resetEdgePreviewState();\n                }\n                return;\n            }\n\n            // Only compute preview if this is the first time we are hovering this particular edge\n            // which means either the edge is undefined or it's a different edge than the last one that was hovered\n            if (!hoveredEdge || hoveredEdge.item !== edge.item) {\n                let itemToMove = firstSelectedItemStructure;\n                if (!initialItemToMove) {\n                    // We need to keep the original item to move since the 'selectedItem' will change positions\n                    //  to the new position inserted in the preview\n                    setInitialItemToMove(itemToMove);\n                } else {\n                    // use the original item to move\n                    itemToMove = initialItemToMove;\n                }\n                // hide preview when an item is dropped on its own edge that has the same width/height as item\n                if (\n                    isDropOnOwnEdge({\n                        edge,\n                        itemToMove: itemToMove as AbsoluteBlockItem,\n                    })\n                ) {\n                    return;\n                }\n\n                // Compute the preview when hovering over the edge\n                const updatedItems = previewDropOnEdge({\n                    edge,\n                    itemToMove: itemToMove as AbsoluteBlockItem,\n                    items: layoutStructure,\n                    canvasWidth,\n                });\n                // If the move was valid, update state to render the preview\n                if (updatedItems) {\n                    // clear invalid edge if it exists\n                    setInvalidEdgeId(null);\n                    if (delayPreviewEdge.current) {\n                        clearTimeout(delayPreviewEdge.current);\n                    }\n                    // When we set timeout, it means it is a valid drop, thus hide preview placeholder until the preview is shown\n                    setShowPreviewPlaceholder(false);\n                    delayPreviewEdge.current = setTimeout(() => {\n                        // Update layout reducer with the new structure\n                        dispatch(resetLayoutAction(updatedItems));\n                        // render the new edges using the new updated layout structure\n                        setEdges(\n                            computeEdges({\n                                layout: updatedItems,\n                                canvasWidth,\n                                canvasHeight: computeMaxHeight(updatedItems),\n                            })\n                        );\n                        // When preview is computed and shown, bring back the placeholder\n                        setShowPreviewPlaceholder(true);\n                    }, EDGE_PREVIEW_DELAY_MS);\n                } else {\n                    // if the move was invalid, highlight the hovered edge to red\n                    setShowPreviewPlaceholder(true);\n                    setInvalidEdgeId(edge.item);\n                    // if user moved from a valid preview directly on an invalid edge, reset\n                    //  the currently shown preview\n                    resetEdgePreviewState();\n                }\n            }\n            // This state is used to keep track of which edge is being hovered, so that we can track\n            //  when we switch to a different edge (to re-compute preview)\n            setHoveredEdge(edge);\n        },\n        [\n            firstSelectedItemStructure,\n            edgesBeforeMove,\n            edges,\n            hoveredEdge,\n            panelPadding,\n            resetEdgePreviewState,\n            initialItemToMove,\n            layoutStructure,\n            canvasWidth,\n        ]\n    );\n\n    const showVizDropPreview = useCallback(\n        ({ mousePos }: { mousePos: Coordinate }) => {\n            // Find the viz that the Mouse is hovering over\n            const block = findTopBlockItemByPosition(\n                layoutStructure,\n                mousePos,\n                panelPadding\n            );\n\n            let itemToMove = firstSelectedItemStructure;\n            if (!initialItemToMove) {\n                // We need to keep the original item to move since the 'selectedItem' will change positions\n                //  to the new position inserted in the preview\n                setInitialItemToMove(itemToMove);\n            } else {\n                // use the original item to move\n                itemToMove = initialItemToMove;\n            }\n\n            if (block === undefined || block.item === itemToMove?.item) {\n                if (delayPreviewViz.current) {\n                    clearTimeout(delayPreviewViz.current);\n                }\n                setHoveredQuadrant(null);\n                setHoveredBlock(null);\n                setIsInvalidVizDrop(false);\n                if (hoveredBlock) {\n                    // only reset to original if there was a preview computed\n                    dispatch(resetLayoutAction(layoutStructure));\n                }\n                return;\n            }\n\n            const currentQuadrant = findQuadrant({\n                item: applyVizPadding({ item: block, padding: panelPadding }),\n                position: mousePos,\n            });\n\n            // Only compute (or re-compute) preview if either it's the first time user hovers a viz,\n            //   or if the quadrant changed, or if the viz that is being hovered changed.\n            if (\n                (!hoveredBlock && !hoveredQuadrant) ||\n                hoveredQuadrant !== currentQuadrant ||\n                hoveredBlock?.item !== block.item\n            ) {\n                if (\n                    isInvalidAdjacentVizDrop({\n                        itemToMove: itemToMove as AbsoluteBlockItem,\n                        itemToDropOn: block,\n                        visualizations: layoutStructure,\n                        direction: currentQuadrant as Quadrant,\n                    })\n                ) {\n                    return;\n                }\n\n                // get the updated position of the items that are changing as a result of the Viz drop on Viz\n                const updatedItems = previewDropOnViz({\n                    itemToDropOn: block,\n                    itemToMove: itemToMove as AbsoluteBlockItem,\n                    items: layoutStructure,\n                    direction: currentQuadrant as Quadrant,\n                });\n                // clear previous preview if it's queued up\n                if (delayPreviewViz.current) {\n                    clearTimeout(delayPreviewViz.current);\n                }\n                if (updatedItems) {\n                    setIsInvalidVizDrop(false);\n                    // The quadrant of the current visualization we are hovering while dragging a viz\n                    setHoveredQuadrant(currentQuadrant);\n                    // the visualization we are hovering over\n                    setHoveredBlock(block);\n                    // Same as with edge preview, hide the placeholder until the timeout has run to avoid 'flashing' of the green preview\n                    setShowPreviewPlaceholder(false);\n                    delayPreviewViz.current = setTimeout(() => {\n                        // If the move was valid, show preview of new layout\n                        dispatch(resetLayoutAction(updatedItems));\n                        // While structure registry exists, we need to force an update. This is a clear indication that it needs to be removed, asap!\n                        setForceUpdate(\n                            (prevForceUpdate) => prevForceUpdate + 1\n                        );\n                        setShowPreviewPlaceholder(true);\n                    }, VIZ_PREVIEW_DELAY_MS);\n                } else {\n                    setHoveredQuadrant(null);\n                    setHoveredBlock(null);\n                    setIsInvalidVizDrop(true);\n                    if (hoveredBlock) {\n                        // only reset to original if there was a preview computed\n                        dispatch(resetLayoutAction(layoutStructure));\n                    }\n                }\n            }\n        },\n        [\n            firstSelectedItemStructure,\n            panelPadding,\n            hoveredBlock,\n            hoveredQuadrant,\n            initialItemToMove,\n            layoutStructure,\n        ]\n    );\n\n    /**\n     * Renders the Item Drop Target\n     * @param {Object} params\n     * @param {Object} params.position position of Item being hovered over\n     * @param {String} params.direction direction of where Drop Target should be rendered\n     */\n    const renderItemDropTarget = memoizeOne(\n        ({\n            position,\n            direction,\n        }: {\n            position: AbsolutePosition;\n            direction: Quadrant;\n        }) => {\n            return <ItemDropTarget position={position} direction={direction} />;\n        }\n    );\n\n    /**\n     * Handles rendering for Item Drop Targets when an Item is being dragged and hovers on top of another Item\n     */\n    const handleRenderItemDropTarget = useCallback(() => {\n        let block = findTopBlockItemByPosition(\n            layoutStructure,\n            mousePosition as Coordinate,\n            panelPadding\n        );\n\n        const selectedItems = getSelectedItems();\n        if (\n            block !== undefined &&\n            selectedItems.length > 0 &&\n            block.item !== selectedItems[0].id &&\n            // disables drop targets when showing preview\n            !hoveredQuadrant\n        ) {\n            // apply padding to Viz to get accurate mouse hover\n            block = applyVizPadding({ item: block, padding: panelPadding });\n            return renderItemDropTarget({\n                position: block.position,\n                direction: findQuadrant({\n                    item: block,\n                    position: mousePosition as Coordinate,\n                }) as Quadrant,\n            });\n        }\n        return null;\n    }, [\n        layoutStructure,\n        panelPadding,\n        getSelectedItems,\n        hoveredQuadrant,\n        mousePosition,\n        renderItemDropTarget,\n    ]);\n\n    const handleShowPreviewPlaceholder = useCallback(\n        ({ mousePos }: { mousePos: Coordinate }) => {\n            const selectedItem = getSelectedItems()[0];\n            if (!selectedItem) {\n                setShowPreviewPlaceholder(false);\n                return;\n            }\n            // Find the viz that the Mouse is hovering over\n            const hoveredViz = findTopBlockItemByPosition(\n                layoutStructure,\n                mousePos,\n                panelPadding\n            );\n            // case 1 to show placeholder: mouse is on original viz\n            if (hoveredViz && hoveredViz.item === selectedItem.id) {\n                setShowPreviewPlaceholder(true);\n                return;\n            }\n            // case 2 to show placeholder: mouse is on an invalid drop zone\n            if (invalidEdgeId !== null || isInvalidVizDrop) {\n                setShowPreviewPlaceholder(true);\n                return;\n            }\n\n            // case 3 to show placeholder: preview has been computed\n            // Note: preview stays on screen as long as mouse hovers on the drop zone where it was created\n            //   so as soon as user moves mouse off, preview goes back to original position (case 1 or 2)\n            if (containsPreviewItem) {\n                setShowPreviewPlaceholder(true);\n                return;\n            }\n            // If neither of those three cases, hide preview placeholder\n            setShowPreviewPlaceholder(false);\n        },\n        [\n            containsPreviewItem,\n            panelPadding,\n            getSelectedItems,\n            invalidEdgeId,\n            isInvalidVizDrop,\n            layoutStructure,\n        ]\n    );\n\n    /**\n     * set isBlockItemMoving state to true for selected Items\n     */\n    const handleBlockItemMove = useCallback(\n        (\n            _e: MouseEvent,\n            { currentPosition }: { currentPosition: Coordinate }\n        ) => {\n            if (getSelectedItems().length > 0) {\n                handleShowPreviewPlaceholder({ mousePos: currentPosition });\n                setIsBlockItemMoving(true);\n                setMousePosition(currentPosition);\n                showEdgeDropPreview({ mousePos: currentPosition });\n                showVizDropPreview({ mousePos: currentPosition });\n            }\n        },\n        [\n            getSelectedItems,\n            showEdgeDropPreview,\n            showVizDropPreview,\n            handleShowPreviewPlaceholder,\n        ]\n    );\n\n    /**\n     * Handler to deal with when a Visualization that is being dragged gets dropped on mouseUp Event\n     */\n    const handleVizDrop = useCallback(() => {\n        const validEdges = edgesBeforeMove || edges;\n\n        const selectedItems = getSelectedItems();\n        // return early if there are no selected Items\n        if (selectedItems.length === 0) {\n            return;\n        }\n        // Find if the viz is being moved on an edge, return that edge\n        const edge = validEdges.find((e) => {\n            return isMouseOnEdge({\n                edge: e,\n                mousePosition: mousePosition as Coordinate,\n                padding: panelPadding,\n            });\n        });\n        // Find the viz that the Mouse is hovering over\n        const block = findTopBlockItemByPosition(\n            layoutStructure,\n            mousePosition as Coordinate,\n            panelPadding\n        );\n        const itemToMove = layoutStructure.find(\n            ({ item }) => item === selectedItems[0].id\n        ) as AbsoluteBlockItem;\n        // nothing changed as a result of the Viz drop on itself - return early\n        if (block === itemToMove) {\n            sendTelemetry({\n                source: 'canvas',\n                event: 'viz_drop_on_self_successful',\n            });\n            return;\n        }\n\n        const itemsSelected = layoutStructure;\n        let updatedItems = null;\n        if (edge !== undefined) {\n            // handle drop on Edge\n            // get the updated position of the items that are changing as a result of the Viz drop on Edge\n            updatedItems = updateDropOnEdge({\n                edge,\n                itemToMove,\n                items: itemsSelected,\n                canvasWidth,\n            });\n            // nothing changed as a result of the Viz drop on Edge - return early\n            if (updatedItems === null) {\n                sendTelemetry({\n                    source: 'canvas',\n                    event: 'viz_drop_on_edge_unsuccessful',\n                });\n                return;\n            }\n            // updated the entire definition with the updated Items\n            updatedItems = updateItems({\n                updatedVisualizations: updatedItems.updatedVisualizations,\n                itemToMove: updatedItems.updatedItemToMove,\n                items: itemsSelected,\n                canvasWidth,\n            });\n            sendTelemetry({\n                source: 'canvas',\n                event: 'viz_drop_on_edge_successful',\n            });\n        } else if (block !== undefined && block.item !== selectedItems[0].id) {\n            // handle drop on Viz\n            // apply padding to Viz to get accurate mouse hover position\n            const direction = findQuadrant({\n                item: applyVizPadding({ item: block, padding: panelPadding }),\n                position: mousePosition as Coordinate,\n            });\n\n            if (\n                isInvalidAdjacentVizDrop({\n                    itemToMove,\n                    itemToDropOn: block,\n                    direction: direction as Quadrant,\n                    visualizations: layoutStructure,\n                })\n            ) {\n                return;\n            }\n\n            // get the updated position of the items that are changing as a result of the Viz drop on Viz\n            const updatedVisualizations = updateDropOnViz({\n                itemToMove,\n                itemToDropOn: block,\n                direction: direction as Quadrant,\n            });\n            if (updatedVisualizations === null) {\n                sendTelemetry({\n                    source: 'canvas',\n                    event: 'viz_drop_on_viz_unsuccessful',\n                });\n                return;\n            }\n            // updated the entire definition with the updated Items\n            updatedItems = updateItems({\n                updatedVisualizations,\n                itemToMove,\n                items: itemsSelected,\n                canvasWidth,\n            });\n            sendTelemetry({\n                source: 'canvas',\n                event: 'viz_drop_on_viz_successful',\n            });\n        }\n        if (updatedItems != null) {\n            onLayoutStructureChange(updatedItems);\n        }\n    }, [\n        layoutStructure,\n        edgesBeforeMove,\n        edges,\n        getSelectedItems,\n        mousePosition,\n        panelPadding,\n        sendTelemetry,\n        canvasWidth,\n        onLayoutStructureChange,\n    ]);\n\n    /*\n        Clean up the state from the preview, and undo any changes by reverting to original state before the item move\n    */\n    const cleanupAfterPreview = useCallback(() => {\n        if (delayPreviewViz.current) {\n            clearTimeout(delayPreviewViz.current);\n        }\n        if (delayPreviewEdge.current) {\n            clearTimeout(delayPreviewEdge.current);\n        }\n        setInvalidEdgeId(null);\n        setIsInvalidVizDrop(false);\n        setInitialItemToMove(null);\n        setHoveredBlock(null);\n        setHoveredQuadrant(null);\n        if (edgesBeforeMove) {\n            // If a preview was shown, revert back to original\n            setEdges(edgesBeforeMove);\n            setEdgesBeforeMove(null);\n            dispatch(resetLayoutAction(layoutStructure));\n        }\n        if (hoveredBlock) {\n            dispatch(resetLayoutAction(layoutStructure));\n        }\n    }, [edgesBeforeMove, hoveredBlock, layoutStructure]);\n\n    /**\n     * update the blocks when it finished moving\n     */\n    const handleBlockItemMoved = useCallback(() => {\n        cleanupAfterPreview();\n        if (mousePosition !== null) {\n            // updates layout structure\n            handleVizDrop();\n        }\n        setIsBlockItemMoving(false);\n        setMousePosition(null);\n    }, [cleanupAfterPreview, mousePosition, handleVizDrop]);\n\n    const handleBlockItemPositionUpdate = useCallback(\n        ({ item, offset }: { item: AbsoluteBlockItem; offset: Offset }) => {\n            const newItem = updateBlockItemPosition(item, offset);\n\n            // update runtime structure\n            dispatch(updateItemAction(newItem));\n        },\n        []\n    );\n\n    /**\n     * Block Items resize and move Handler\n     * @param {Object} e mouse event\n     * @param {Object} options\n     * @param {Object} options.itemId itemId for selected Viz\n     * @param {Object} options.offset offset amount to move Viz\n     * @param {Object} options.dir direction to resize Viz\n     */\n    const handleBlockItemResize = useCallback(\n        (\n            _e: MouseEvent | Coordinate,\n            {\n                itemId,\n                offset,\n                dir,\n            }: { itemId: string; offset: Offset; dir: HandleDirection }\n        ) => {\n            // all computation is done against last committed items!\n            const item = getStructureItem(layoutStructure, itemId);\n            const newItem = updateBlockItemSize({\n                item,\n                offset,\n                dir,\n                options: {\n                    minHeight: MIN_HEIGHT_PX,\n                    minWidth: MIN_WIDTH_PX,\n                },\n            });\n\n            // update runtime structure\n            dispatch(updateItemAction(newItem));\n        },\n        [layoutStructure]\n    );\n\n    /**\n     * handler for when Block is finished Resizing\n     */\n    const handleBlockItemResized = useCallback(() => {\n        // resize completed\n        handleLayoutStructureChange();\n        sendTelemetry({\n            source: 'canvas',\n            event: 'edge_resize',\n        });\n    }, [handleLayoutStructureChange, sendTelemetry]);\n\n    const handleMouseDownOnEdge = useCallback(\n        (e: React.MouseEvent, { id }: { id: string }) => {\n            isDraggingEdge.current = true;\n\n            const edge = edges.find(({ item }) => item === id);\n\n            if (!edge) {\n                return;\n            }\n\n            // set selected visualizations\n            // select proper viz items and also proper edge orientation for viz\n            const visualizationIds = edge.visualizations.map((viz) => viz.item);\n\n            // find boundaries, either horizontal boundary - { leftBoundary, rightBoundary }\n            // or vertical boundary - { upperBoundary, lowerBoundary }\n            const newEdgeBoundaries =\n                edge.orientation === 'horizontal'\n                    ? getVerticalBoundaries({\n                          visualizations: edge.visualizations,\n                          y: edge.edgeStart.y,\n                          minHeight: MIN_HEIGHT_PX,\n                          isFullWidthEdge:\n                              edge.edgeEnd.x - edge.edgeStart.x === canvasWidth,\n                      })\n                    : getHorizontalBoundaries({\n                          visualizations: edge.visualizations,\n                          x: edge.edgeStart.x,\n                          minWidth: MIN_WIDTH_PX,\n                      });\n            // save new boundary\n            edgeBoundaries.current = newEdgeBoundaries;\n\n            // compute edges in boundary\n            edgesInBoundary.current = findEdgesInBoundary({\n                edge,\n                edges,\n                edgeBoundaries: newEdgeBoundaries,\n            });\n\n            edgeMouseDownPosition.current = getClientPosition(e, mouseScale);\n            mouseDownEdge.current = { ...edge };\n            setSelectedItemsForEdge(visualizationIds);\n        },\n        [edges, mouseScale, canvasWidth]\n    );\n\n    /**\n     * handle resizing for selected edge and visualizations\n     */\n    const handleEdgeMove = useEventCallback((e: MouseEvent) => {\n        e.preventDefault();\n        e.stopPropagation();\n\n        // update selected edge location\n        if (!isDraggingEdge.current || !mouseDownEdge.current) {\n            return;\n        }\n\n        const currentPosition = getClientPosition(e, mouseScale);\n        const offset = getOffset(\n            currentPosition,\n            edgeMouseDownPosition.current as Coordinate\n        );\n\n        offset.offsetY += cumulativeScrollIncrease.current;\n\n        let updatedEdge =\n            mouseDownEdge?.current?.orientation === 'vertical'\n                ? moveVerticalEdge({\n                      edge: mouseDownEdge.current,\n                      offset: offset.offsetX,\n                      edgeBoundaries:\n                          edgeBoundaries.current as HorizontalBoundaries,\n                  })\n                : moveHorizontalEdge({\n                      edge: mouseDownEdge.current,\n                      offset: offset.offsetY,\n                      edgeBoundaries:\n                          edgeBoundaries.current as VerticalBoundaries,\n                  });\n\n        let updatedSnappableEdges: EdgeItem[] = [];\n        if (!e.shiftKey) {\n            const { updatedEdge: ue, snappableEdges: se } = findSnappableEdges({\n                edge: updatedEdge,\n                edges: edgesInBoundary.current ?? [],\n                snapRange: SNAP_RANGE_PX,\n            });\n            updatedEdge = ue;\n            updatedSnappableEdges = se;\n        }\n\n        setEdges((prevEdges) =>\n            prevEdges.map((anEdge) => {\n                if (anEdge.item === updatedEdge.item) {\n                    return updatedEdge;\n                }\n\n                return anEdge;\n            })\n        );\n\n        // update visualizations locations\n        const vizOffset = {\n            offsetX:\n                updatedEdge.edgeStart.x - mouseDownEdge.current.edgeStart.x,\n            offsetY:\n                updatedEdge.edgeStart.y - mouseDownEdge.current.edgeStart.y,\n        };\n\n        const isFullWidthEdge =\n            mouseDownEdge.current.edgeEnd.x -\n                mouseDownEdge.current.edgeStart.x ===\n            canvasWidth;\n        if (isFullWidthEdge) {\n            // If user is dragging full width edge, update ALL the visualizations below the edge by\n            //  shifting them downwards/upwards, including the ones that are not directly touching the edge\n            // The block items need to be the committed versions\n            layoutStructure.forEach((item) => {\n                if (\n                    mouseDownEdge.current &&\n                    item.position.y >= mouseDownEdge.current.edgeStart.y\n                ) {\n                    handleBlockItemPositionUpdate({\n                        item,\n                        offset: vizOffset,\n                    });\n                }\n            });\n        }\n\n        if (selectedItemsForEdge.length > 0) {\n            selectedItemsForEdge.forEach((itemId) => {\n                const item = getStructureItem(layoutStructure, itemId);\n                if (\n                    !mouseDownEdge.current ||\n                    (isFullWidthEdge &&\n                        item.position.y >= mouseDownEdge.current.edgeStart.y)\n                ) {\n                    // if the moving edge is a full width edge, we already took care of the visualizations\n                    //   below that edge, thus ignore them here, and only resize the items above the edge\n                    return;\n                }\n                let resizeDir: HandleDirection;\n                if (mouseDownEdge.current?.orientation === 'horizontal') {\n                    resizeDir =\n                        item.position.y >= mouseDownEdge.current.edgeStart.y\n                            ? 'n'\n                            : 's';\n                } else {\n                    resizeDir =\n                        item.position.x >= mouseDownEdge.current.edgeStart.x\n                            ? 'w'\n                            : 'e';\n                }\n                handleBlockItemResize(e, {\n                    itemId,\n                    offset: vizOffset,\n                    dir: resizeDir,\n                });\n            });\n        }\n\n        // check for snappable edges\n        // highlight snappable edges\n        setSnappableEdges(updatedSnappableEdges);\n\n        // Start scrolling the bottom edge slightly before reaching the bottom of the screen at a reduced speed\n        if (\n            mouseDownEdge?.current?.orientation === 'horizontal' &&\n            mouseDownEdge?.current?.isCanvasEdge\n        ) {\n            const scrollVelocity =\n                e.clientY - window.innerHeight + CANVAS_BOTTOM_PADDING * 2;\n            edgeVelocity.current = scrollVelocity;\n            setMousePosition(getClientPosition(e, mouseScale));\n        }\n    });\n\n    useMouseMoveHandler({\n        onMouseMove: handleEdgeMove,\n        isEnabled: mode === 'edit',\n        throttledMs: 32,\n    });\n\n    useEffect(() => {\n        if (\n            mode !== 'edit' ||\n            edgeVelocity.current <= 0 ||\n            !mouseDownEdge.current ||\n            !edgeMouseDownPosition.current ||\n            !mousePosition\n        ) {\n            return undefined;\n        }\n        const currEdge = mouseDownEdge.current;\n\n        const isFullWidthEdge =\n            currEdge.edgeEnd.x - currEdge.edgeStart.x === canvasWidth;\n\n        if (!isFullWidthEdge) {\n            return undefined;\n        }\n\n        const offset =\n            edgeVelocity.current > 8\n                ? BOTTOM_EDGE_MAX_SPEED\n                : BOTTOM_EDGE_MIN_SPEED;\n        const edgeMousePos = edgeMouseDownPosition.current;\n\n        const interval = setInterval(() => {\n            cumulativeScrollIncrease.current += offset;\n\n            const mouseOffset = getOffset(mousePosition, edgeMousePos);\n\n            const updatedEdge = moveHorizontalEdge({\n                edge: currEdge,\n                offset: mouseOffset.offsetY + cumulativeScrollIncrease.current,\n                edgeBoundaries: edgeBoundaries.current as VerticalBoundaries,\n            });\n\n            setEdges((prevEdges) =>\n                prevEdges.map((anEdge) => {\n                    if (anEdge.item === currEdge.item) {\n                        return {\n                            ...anEdge,\n                            edgeStart: {\n                                x: anEdge.edgeStart.x,\n                                y: updatedEdge.edgeStart.y,\n                            },\n                            edgeEnd: {\n                                x: anEdge.edgeEnd.x,\n                                y: updatedEdge.edgeStart.y,\n                            },\n                        };\n                    }\n                    return anEdge;\n                })\n            );\n\n            const vizOffset = {\n                offsetX: 0,\n                offsetY: updatedEdge.edgeStart.y - currEdge.edgeStart.y,\n            };\n\n            // Handles increasing the size of the visualizations on the edge\n            if (selectedItemsForEdge.length > 0) {\n                selectedItemsForEdge.forEach((itemId) => {\n                    const resizeDir = 's';\n\n                    handleBlockItemResize(mousePosition, {\n                        itemId,\n                        offset: vizOffset,\n                        dir: resizeDir,\n                    });\n                });\n            }\n\n            if (canvasRef.current?.parentElement) {\n                canvasRef.current.parentElement.scrollTop +=\n                    BOTTOM_RESIZING_SCROLL_SPEED;\n            }\n        }, 32);\n\n        return () => {\n            clearInterval(interval);\n        };\n    }, [\n        mode,\n        edgeVelocity,\n        mousePosition,\n        cumulativeScrollIncrease,\n        canvasRef,\n        canvasWidth,\n        handleBlockItemResize,\n        layoutStructure,\n        selectedItemsForEdge,\n    ]);\n\n    /**\n     * handler for when Edge is finished Moving\n     */\n    const handleEdgeMoved = useEventCallback((e: MouseEvent) => {\n        // DO NOT stop propagation, because visualizations are listening to mouse up to tell\n        // whether it stopped moving. Refer to GridCanvas.jsx for the logic.\n        e.preventDefault();\n\n        // need to reset this before updating state\n        mouseDownEdge.current = null;\n        edgeMouseDownPosition.current = null;\n        edgeBoundaries.current = null;\n        edgesInBoundary.current = null;\n        cumulativeScrollIncrease.current = 0;\n        edgeVelocity.current = 0;\n\n        if (isDraggingEdge.current) {\n            isDraggingEdge.current = false;\n            // only unset select viz when resizing edge is done,\n            // not on clicking a viz.\n            setSelectedItemsForEdge([]);\n            handleBlockItemResized();\n        }\n\n        if (snappableEdges.length > 0) {\n            setSnappableEdges([]);\n        }\n    });\n\n    useEffect(() => {\n        if (mode !== 'edit') {\n            return undefined;\n        }\n\n        document.addEventListener('mouseup', handleEdgeMoved);\n\n        return () => {\n            document.removeEventListener('mouseup', handleEdgeMoved);\n        };\n    }, [handleEdgeMoved, mode]);\n\n    useEffect(() => {\n        if (!keyboardListener) {\n            return () => undefined;\n        }\n\n        const unsubscribeKeyboardListener = keyboardListener.subscribe(\n            'cancel',\n            () => {\n                if (isBlockItemMoving) {\n                    cleanupAfterPreview();\n                    setIsBlockItemMoving(false);\n                    setMousePosition(null);\n                } else {\n                    // deselect all selected items;\n                    onLayoutItemsSelect([]);\n                }\n            }\n        );\n\n        return () => {\n            unsubscribeKeyboardListener();\n        };\n    }, [\n        cleanupAfterPreview,\n        isBlockItemMoving,\n        onLayoutItemsSelect,\n        keyboardListener,\n    ]);\n\n    /**\n     * render outline for block items\n     * @param {Number} scale scale value\n     */\n    const renderOutline = () => {\n        const selectedItems =\n            selectedItemsForEdge.length > 0\n                ? selectedItemsForEdge\n                : getSelectedItems().map(({ id }) => id);\n        const blockItems = getBlockItems(gridState);\n        return blockItems.map((item) => {\n            // 1. item must be selected AND\n            // 2. either the item is not moving (user just selected it)\n            //   OR the item is moving and the preview is shown (to show green outline around preview placeholder)\n            const displayOutline =\n                selectedItems.includes(item.item) &&\n                (!isBlockItemMoving || showPreviewPlaceholder);\n            if (displayOutline) {\n                const paddedItem = applyVizPadding({\n                    item,\n                    padding: panelPadding,\n                });\n                return (\n                    <MemoizedBlockOutline\n                        handleDirections={HANDLE_DIRECTIONS}\n                        key={item.item}\n                        itemId={item.item}\n                        scale={mouseScale}\n                        x={paddedItem.position.x}\n                        y={paddedItem.position.y}\n                        w={paddedItem.position.w}\n                        h={paddedItem.position.h}\n                    />\n                );\n            }\n            // for all other block items, no outline will be displayed.\n            return null;\n        });\n    };\n\n    const getEdgeAppearance = useCallback(\n        ({ edge }: { edge: EdgeItem }): EdgeAppearance => {\n            const renderAllEdges = !mouseDownEdge.current;\n            let appearance: EdgeAppearance =\n                renderAllEdges ||\n                edge.item === mouseDownEdge.current?.item ||\n                snappableEdges.find((e) => e.item === edge.item)\n                    ? 'normal'\n                    : 'hidden';\n\n            if (isBlockItemMoving) {\n                const itemToMove = layoutStructure.find(\n                    ({ item }) => item === getSelectedItems()[0]?.id\n                );\n                // hide edge if it's adjacent to the moving item and has the same width/height as item\n                if (itemToMove && isDropOnOwnEdge({ edge, itemToMove })) {\n                    appearance = 'hidden';\n                } else {\n                    appearance = 'dropTarget';\n                }\n            }\n            if (invalidEdgeId === edge.item) {\n                appearance = 'invalid';\n            }\n            return appearance;\n        },\n        [\n            invalidEdgeId,\n            isBlockItemMoving,\n            mouseDownEdge,\n            snappableEdges,\n            getSelectedItems,\n            layoutStructure,\n        ]\n    );\n\n    /**\n     * Renders the Edges\n     * @param {Object} options\n     * @param {Number} options.edgeThickness edgeThickness\n     * @param {Number} options.scale scale value\n     * @returns {Object} returns edge with updated position\n     */\n    const edgeItems = useMemo(() => {\n        if (mode !== 'edit') {\n            return null;\n        }\n\n        // if no edge is selected, render all edges\n        return edges.map((edge) => {\n            const formattedEdge = formatEdgeWrapper({\n                edge,\n                padding: panelPadding,\n            });\n            const { width, height } = getDimensions({\n                edge: formattedEdge,\n                thickness: 2 * panelPadding,\n            });\n            const { x, y } = formattedEdge.edgeStart;\n\n            return (\n                <MemoizedEdge\n                    key={edge.item}\n                    itemId={edge.item}\n                    x={x}\n                    y={y}\n                    w={width}\n                    h={height}\n                    padding={panelPadding}\n                    orientation={edge.orientation}\n                    isCanvasEdge={edge.isCanvasEdge}\n                    appearance={getEdgeAppearance({ edge })}\n                    onMouseDown={handleMouseDownOnEdge}\n                    // use the raw coordinates as test hook, so that it is easier to triage and is compatible with the previous implementation\n                    data-test-edge-position={`${edge.edgeStart.x},${edge.edgeStart.y}-${edge.edgeEnd.x},${edge.edgeEnd.y}`}\n                />\n            );\n        });\n    }, [mode, edges, getEdgeAppearance, panelPadding, handleMouseDownOnEdge]);\n\n    const handleRenderPreviewPlaceholderItem = useCallback(() => {\n        if (!firstSelectedItemStructure || !showPreviewPlaceholder) {\n            return null;\n        }\n\n        const item = applyVizPadding({\n            item: firstSelectedItemStructure,\n            padding: panelPadding,\n        });\n        return (\n            <PreviewPlaceholderItem\n                key={`${firstSelectedItemStructure.item}-preview`}\n                position={item.position}\n            />\n        );\n    }, [firstSelectedItemStructure, panelPadding, showPreviewPlaceholder]);\n\n    // TODO: this is an ugly hack to make deleting a viz not break the layout\n    /**\n     * History:\n     * layoutStructure prop changes will cause a rerender.\n     * The renderBlockItems method needs to receive the modified structure (e.g. from dragging) stored in the reducer state.\n     * Removing a viz will result in a layoutStructure change and render before the reducer updates, referencing a viz that no longer exists.\n     * This will throw an error when trying to resolve tokens in the unknown viz config.\n     * An undo operation after a delete will restore a viz that does not exist in gridState, so a filtered structure must account for this case.\n     */\n    const filteredState = useMemo(\n        () => getFilteredStructure(gridState, layoutStructure),\n        [gridState, layoutStructure]\n    );\n\n    const items = getSelectedItems();\n\n    // no need to memoize because it is destructured before passing to GridCanvas\n    const commonProps = {\n        width: canvasWidth,\n        height: maxHeight,\n        scale,\n        selectable: true,\n        selectedLayoutItems: items,\n        onItemSelected: handleItemSelected,\n        panelPadding,\n        ref: canvasRef,\n    };\n    const modeSpecificProps =\n        mode === 'edit'\n            ? {\n                  movable: true,\n                  showOverflowContent: false,\n                  showBorder: true,\n                  gridWidth: GRID_SIZE_PX - 1,\n                  gridHeight: GRID_SIZE_PX - 1,\n                  gridLineWidth: 1,\n                  gridPadding: GRID_PADDING_PX,\n                  onItemMove: handleBlockItemMove,\n                  onItemMoved: handleBlockItemMoved,\n                  userSelect: false,\n              }\n            : {\n                  movable: false,\n                  showOverflowContent: false,\n                  showBorder: false,\n                  userSelect: true,\n              };\n\n    return (\n        <GridCanvas\n            data-test=\"grid-layout\"\n            blockItems={filteredState}\n            data-test-scale={scale}\n            backgroundColor={backgroundColor}\n            {...commonProps}\n            {...modeSpecificProps}\n        >\n            <Layer key=\"block-item-layer\" data-test=\"block-item-layer\">\n                {renderBlockItems({\n                    layoutStructure: filteredState,\n                    renderLayoutItem,\n                    handleItemSelected,\n                    isBlockItemMoving,\n                    selectedItem: getSelectedItems()[0],\n                    mode,\n                    errors: layoutErrors,\n                    padding: panelPadding,\n                    canvasHeight: maxHeight,\n                })}\n            </Layer>\n            {edgeItems}\n            <Layer key=\"outline-layer\" data-test=\"outline-layer\">\n                {renderOutline()}\n            </Layer>\n            {mousePosition && isBlockItemMoving && handleRenderItemDropTarget()}\n            {mousePosition &&\n                isBlockItemMoving &&\n                handleRenderPreviewPlaceholderItem()}\n            {mousePosition && isBlockItemMoving && (\n                <ItemDragPlaceholder\n                    position={mousePosition}\n                    size={PLACEHOLDER_SIZE_PX}\n                />\n            )}\n        </GridCanvas>\n    );\n};\n\n// Wrapper function that primarily handles the enableGridLayoutCssScaling functionality.\nconst GridLayout = (props: GridLayoutProps): JSX.Element => {\n    const {\n        containerWidth,\n        containerHeight,\n        options: {\n            width: canvasWidth = gridLayoutOptions.width,\n        } = gridLayoutOptions,\n        onLayoutStructureChange,\n        layoutStructure = defaultLayoutStructure,\n    } = props;\n    const { enableGridLayoutCssScaling } = useFeatureFlags();\n    const scrollbarWidth = getScrollbarWidth();\n\n    const [canvasHeight, setCanvasHeight] = useState(() =>\n        computeMaxHeight(layoutStructure)\n    );\n\n    // When css scaling is disabled there needs to be a consistent scale for handleLayoutStructureChange\n    const scale = useMemo(\n        () =>\n            computeScaleToFit({\n                canvasWidth,\n                canvasHeight,\n                containerWidth,\n                containerHeight,\n                scrollbarWidth,\n                enableGridLayoutCssScaling,\n            }),\n\n        [\n            enableGridLayoutCssScaling,\n            canvasWidth,\n            canvasHeight,\n            containerWidth,\n            containerHeight,\n            scrollbarWidth,\n        ]\n    );\n\n    // Undo the scaling when we change the layoutStructure. With the enableGridLayoutCssScaling\n    // flag we're now modifying the actual width of the BlockItem so we want to ensure\n    // we are using the original unscaled values (1 / scale)\n    const handleLayoutStructureChange = useCallback(\n        (layout: GridLayoutStructure) => {\n            onLayoutStructureChange(\n                scaleGridLayoutStructureByWidth({\n                    layout,\n                    scale: 1 / scale,\n                })\n            );\n        },\n        [scale, onLayoutStructureChange]\n    );\n\n    // If we're not scaling the layout we have to scale each blockItem\n    const scaledLayoutStructure = useMemo(\n        () =>\n            !enableGridLayoutCssScaling\n                ? scaleGridLayoutStructureByWidth({\n                      layout: layoutStructure,\n                      scale,\n                  })\n                : layoutStructure,\n        [enableGridLayoutCssScaling, layoutStructure, scale]\n    );\n\n    const sortedLayoutStructure = useMemo(\n        () =>\n            getGridLayoutOrder({\n                layout: scaledLayoutStructure,\n                canvasWidth,\n                canvasHeight: computeMaxHeight(scaledLayoutStructure),\n            }),\n        [canvasWidth, scaledLayoutStructure]\n    );\n    return (\n        <BaseGridLayout\n            {...props}\n            scale={scale}\n            canvasWidth={canvasWidth}\n            layoutStructure={sortedLayoutStructure}\n            setCanvasHeight={setCanvasHeight}\n            {...(!enableGridLayoutCssScaling\n                ? {\n                      canvasWidth: Math.round(containerWidth - scrollbarWidth),\n                      onLayoutStructureChange: handleLayoutStructureChange,\n                  }\n                : null)}\n        />\n    );\n};\n\nexport default withLayoutShowHide(GridLayout, {\n    schema: gridLayoutOptionsSchema,\n    reflowFn: gridLayoutShowHideReflow,\n});\n", "import type { GridLayoutStructure } from '@splunk/dashboard-types';\n\ninterface GridLine {\n    pos: number;\n    names: string[];\n}\n\n/**\n * Returns a template for the rows/columns of a CSS grid given a list of grid lines along an axis\n * with range [0, axisLength].\n */\nconst getTemplateItems = (\n    [currGridLine, nextGridLine, ...rest]: GridLine[],\n    axisLength: number,\n    templateItems: string[] = []\n): string => {\n    // add the names for the current grid line\n    templateItems.push(`[${currGridLine.names.join(' ')}]`);\n\n    if (!nextGridLine) {\n        return templateItems.join(' ');\n    }\n\n    // add the space between the current grid line and the next grid line\n    const gridTrackWidth = Math.round(\n        ((nextGridLine.pos - currGridLine.pos) / axisLength) * 100\n    );\n    templateItems.push(`minmax(0, ${gridTrackWidth}fr)`);\n\n    return getTemplateItems([nextGridLine, ...rest], axisLength, templateItems);\n};\n\n/**\n * Wrapper function for getTemplateItems.\n */\nconst getTemplateItemsFromGridLines = (\n    gridLines: GridLine[],\n    axisLength: number\n): string => {\n    if (gridLines.length === 0) {\n        return '';\n    }\n    return getTemplateItems(gridLines, axisLength);\n};\n\ninterface GetCSSGridTemplateArgs {\n    layoutStructure: GridLayoutStructure;\n    width: number;\n    height: number;\n}\n\n/**\n * Returns strings to be used as the `grid-template-columns` and `grid-layout-rows` properties of\n * a CSS Grid. Derived from the layout structure.\n */\nexport const getCSSGridTemplate = ({\n    layoutStructure,\n    width,\n    height,\n}: GetCSSGridTemplateArgs): {\n    gridRowTemplate: string;\n    gridColTemplate: string;\n} => {\n    const xCoords: string[][] = [];\n    const yCoords: string[][] = [];\n\n    layoutStructure.forEach(({ position: { x, y, w, h }, item }) => {\n        // create an empty list of breakpoints for a given point if it does not exist\n        xCoords[x] = xCoords[x] ?? [];\n        xCoords[x + w] = xCoords[x + w] ?? [];\n        yCoords[y] = yCoords[y] ?? [];\n        yCoords[y + h] = yCoords[y + h] ?? [];\n\n        // add breakpoint to the list of breakpoints for a given point\n        xCoords[x].push(`${item}-start`);\n        xCoords[x + w].push(`${item}-end`);\n        yCoords[y].push(`${item}-start`);\n        yCoords[y + h].push(`${item}-end`);\n    });\n\n    const xGridLines = Object.entries(xCoords).map(([pos, names]) => ({\n        pos: Number(pos),\n        names,\n    }));\n    const yGridLines = Object.entries(yCoords).map(([pos, names]) => ({\n        pos: Number(pos),\n        names,\n    }));\n\n    const gridRowTemplate = getTemplateItemsFromGridLines(yGridLines, height);\n    const gridColTemplate = getTemplateItemsFromGridLines(xGridLines, width);\n\n    return { gridRowTemplate, gridColTemplate };\n};\n", "import React, { useMemo } from 'react';\nimport styled from 'styled-components';\nimport { mixins } from '@splunk/themes';\nimport { customThemeVariables } from '@splunk/dashboard-ui';\nimport { noop } from '@splunk/dashboard-utils';\nimport type {\n    GridLayoutStructure,\n    GridLayoutOptions,\n    BaseLayoutProps,\n} from '@splunk/dashboard-types';\n\nimport { GridItem } from './components';\nimport { gridLayoutOptions } from './DefaultOptions';\nimport { getCSSGridTemplate } from './utils/gridLayoutViewerUtils';\nimport { removeInvalidItems, computeMaxHeight } from './utils/layoutUtils';\n\ninterface GridCanvasProps {\n    height: number;\n    gutterSize: number;\n    colTemplate: string;\n    rowTemplate: string;\n}\n\nconst GridCanvas = styled.div<GridCanvasProps>`\n    ${mixins.reset('grid')};\n    height: ${(props) => props.height}px;\n    width: 100%;\n    padding: ${(props) => props.gutterSize / 2}px;\n    box-sizing: border-box;\n    grid-template-columns: ${(props) => props.colTemplate};\n    grid-template-rows: ${(props) => props.rowTemplate};\n    gap: ${(props) => props.gutterSize}px;\n    background: ${customThemeVariables.dashboardBackgroundColor};\n`;\nGridCanvas.displayName = 'GridCanvas';\n\nexport type GridLayoutViewerProps = Pick<\n    BaseLayoutProps<GridLayoutStructure, GridLayoutOptions>,\n    'layoutStructure' | 'renderLayoutItem' | 'options'\n>;\n\nconst defaultLayoutStructure: GridLayoutStructure = [];\n\nconst GridLayoutViewer = ({\n    layoutStructure = defaultLayoutStructure,\n    renderLayoutItem = noop,\n    options = gridLayoutOptions,\n}: GridLayoutViewerProps): JSX.Element => {\n    const { width, gutterSize } = {\n        ...gridLayoutOptions,\n        ...options,\n    };\n\n    const { height, gridItems, rowTemplate, colTemplate } = useMemo(() => {\n        const filteredStructure = removeInvalidItems(\n            layoutStructure\n        ) as GridLayoutStructure;\n        const structureHeight = computeMaxHeight(filteredStructure);\n\n        const { gridRowTemplate, gridColTemplate } = getCSSGridTemplate({\n            layoutStructure: filteredStructure,\n            width,\n            height: structureHeight,\n        });\n\n        const items = filteredStructure.map(({ item: itemId, type }) => (\n            <GridItem\n                itemId={itemId}\n                type={type}\n                key={itemId}\n                renderLayoutItem={renderLayoutItem}\n            />\n        ));\n\n        return {\n            height: structureHeight,\n            gridItems: items,\n            rowTemplate: gridRowTemplate,\n            colTemplate: gridColTemplate,\n        };\n    }, [layoutStructure, width, renderLayoutItem]);\n\n    return (\n        <GridCanvas\n            data-test=\"grid-layout-canvas\"\n            data-layout-type=\"grid\"\n            height={height}\n            gutterSize={gutterSize}\n            rowTemplate={rowTemplate}\n            colTemplate={colTemplate}\n        >\n            {gridItems}\n        </GridCanvas>\n    );\n};\n\nexport default GridLayoutViewer;\n", "\nimport * as defaultImport from \"@dnd-kit/core\";\nexport * from \"@dnd-kit/core\";\nexport default ('default' in defaultImport ? defaultImport.default : defaultImport);\n", "\nimport * as defaultImport from \"@dnd-kit/sortable\";\nexport * from \"@dnd-kit/sortable\";\nexport default ('default' in defaultImport ? defaultImport.default : defaultImport);\n", "\nimport * as defaultImport from \"@dnd-kit/utilities\";\nexport * from \"@dnd-kit/utilities\";\nexport default ('default' in defaultImport ? defaultImport.default : defaultImport);\n", "import React, { forwardRef, useCallback, useMemo } from 'react';\nimport styled from 'styled-components';\nimport { useDroppable } from '@dnd-kit/core';\nimport { useSortable } from '@dnd-kit/sortable';\nimport { CSS } from '@dnd-kit/utilities';\nimport { mixins, variables } from '@splunk/themes';\nimport {\n    GlobalInputDropzoneId,\n    GlobalInputSubmitDraggableId,\n} from '@splunk/dashboard-context';\nimport { noop } from '@splunk/dashboard-utils';\nimport {\n    customThemeVariables,\n    SubmitButton,\n    type SubmitButtonProps,\n} from '@splunk/dashboard-ui';\n\ninterface InputContainerProps {\n    backgroundColor?: string;\n}\n\nconst InputContainer = styled.div<InputContainerProps>`\n    ${mixins.reset('block')};\n    padding: ${variables.spacingSmall} 0 0 0;\n    background: ${(prop) =>\n        prop.backgroundColor || customThemeVariables.dashboardBackgroundColor};\n    display: flex;\n    flex-wrap: wrap;\n\n    &:empty {\n        padding: 0;\n    }\n`;\n\ninterface InputLayoutProps {\n    submitButton?: boolean;\n    submitButtonDisabled?: boolean;\n    inputStructure?: string[];\n    renderInput?: (arg: { inputId: string; index: number }) => React.ReactNode;\n    onSubmitButtonClick?: () => void;\n}\n\nconst defaultInputRender = () => null;\nconst defaultStructure: string[] = [];\n\n/** Wrapper for the SubmitButton which adds @dnd-kit/sortable metadata */\nconst InputSubmitButton = ({\n    disabled,\n    onClick,\n}: Pick<SubmitButtonProps, 'disabled' | 'onClick'>) => {\n    const { setNodeRef, transform } = useSortable({\n        id: GlobalInputSubmitDraggableId,\n        disabled: true,\n    });\n\n    const containerStyle = useMemo(\n        () => ({ transform: CSS.Translate.toString(transform) }),\n        [transform]\n    );\n\n    return (\n        <SubmitButton\n            key=\"submit_button\"\n            data-test=\"input-item-submit-button\"\n            ref={setNodeRef}\n            containerStyle={containerStyle}\n            disabled={disabled}\n            onClick={onClick}\n        />\n    );\n};\n\n/**\n * Simple Input Layout\n * @param {*} param0\n */\nconst InputLayout = forwardRef<HTMLDivElement, InputLayoutProps>(\n    (\n        {\n            submitButton = false,\n            submitButtonDisabled = false,\n            inputStructure = defaultStructure,\n            renderInput = defaultInputRender,\n            onSubmitButtonClick = noop,\n        },\n        ref\n    ) => {\n        const { setNodeRef } = useDroppable({ id: GlobalInputDropzoneId });\n\n        const composedRef = useCallback(\n            (element: HTMLDivElement | null) => {\n                if (ref) {\n                    if (typeof ref === 'function') {\n                        ref(element);\n                    } else {\n                        // eslint-disable-next-line no-param-reassign\n                        ref.current = element;\n                    }\n                }\n\n                setNodeRef(element);\n            },\n            [ref, setNodeRef]\n        );\n\n        if (inputStructure.length === 0) {\n            return null;\n        }\n\n        const renderSubmitButton = !!(inputStructure.length && submitButton);\n        return (\n            <InputContainer\n                ref={composedRef}\n                data-test=\"input-layout-container\"\n            >\n                {inputStructure.map((inputId, index) =>\n                    renderInput({ inputId, index })\n                )}\n                {renderSubmitButton && (\n                    <InputSubmitButton\n                        disabled={submitButtonDisabled}\n                        onClick={onSubmitButtonClick}\n                    />\n                )}\n            </InputContainer>\n        );\n    }\n);\n\nexport default InputLayout;\n", "\nimport * as defaultImport from \"@splunk/react-icons/Line\";\nexport * from \"@splunk/react-icons/Line\";\nexport default ('default' in defaultImport ? defaultImport.default : defaultImport);\n", "\nimport * as defaultImport from \"@splunk/visualization-encoding/Options\";\nexport * from \"@splunk/visualization-encoding/Options\";\nexport default ('default' in defaultImport ? defaultImport.default : defaultImport);\n", "\nimport * as defaultImport from \"@splunk/visualizations-shared/schemaUtils\";\nexport * from \"@splunk/visualizations-shared/schemaUtils\";\nexport default ('default' in defaultImport ? defaultImport.default : defaultImport);\n", "import { COLOR_OR_TOKEN_PATTERN } from '@splunk/visualizations-shared/schemaUtils';\n\nexport default {\n    toArrow: {\n        type: 'boolean',\n        default: false,\n        description: 'Specify whether the line begins with an arrow.',\n    },\n    fromArrow: {\n        type: 'boolean',\n        default: false,\n        description: 'Specify whether the line ends in an arrow.',\n    },\n    strokeColor: {\n        anyOf: [\n            {\n                type: 'string',\n                pattern: COLOR_OR_TOKEN_PATTERN,\n                description:\n                    'Specify the color of the line. The default for light mode is \"#000000\". The default for dark mode is \"#FFFFFF\"',\n            },\n            {\n                type: 'string',\n                pattern: '^>.*',\n            },\n        ],\n    },\n    strokeDataSeries: {\n        type: 'string',\n        pattern: '^>.*',\n        description: 'Data series for dynamic line coloring.',\n        default: '> primary | seriesByType(\"number\")',\n    },\n    strokeDataPoint: {\n        type: 'string',\n        pattern: '^>.*',\n        description: 'Data point that will map to the line color.',\n        default: '> strokeDataSeries | lastPoint()',\n    },\n    strokeDasharray: {\n        type: 'number',\n        default: 0,\n        description:\n            'Specify the length, in pixels, of both the line segments and the spaces between the line segments when you choose break up a line so that it is not solid.',\n    },\n    strokeWidth: {\n        type: 'number',\n        default: 1,\n        description: 'Specify the thickness, in pixels, of the line.',\n    },\n    strokeOpacity: {\n        type: 'number',\n        default: 1,\n        description:\n            'Specify a number less than one to increase the opacity of the line. For example, if you specify 0.50, the line will have an opacity that is half that of no opacity.',\n    },\n};\n", "\nimport * as defaultImport from \"@splunk/visualization-color-palettes/editors/PresetPalettes\";\nexport * from \"@splunk/visualization-color-palettes/editors/PresetPalettes\";\nexport default ('default' in defaultImport ? defaultImport.default : defaultImport);\n", "\nimport * as defaultImport from \"@splunk/visualizations/common/utils/configUtils\";\nexport * from \"@splunk/visualizations/common/utils/configUtils\";\nexport default ('default' in defaultImport ? defaultImport.default : defaultImport);\n", "import { _ } from '@splunk/ui-utils/i18n';\nimport { defaultPalettesConfig } from '@splunk/visualization-color-palettes/editors/PresetPalettes';\nimport {\n    isDynamicOption,\n    getInitialPreset,\n} from '@splunk/visualizations/common/utils/configUtils';\nimport type { ConnectedLineProps, ConnectedLineOptions } from './types';\n\nconst defaultContext = {\n    defaultRangeValue: [\n        { to: 20, value: '#D41F1F' },\n        { from: 20, to: 40, value: '#D94E17' },\n        { from: 40, to: 60, value: '#CBA700' },\n        { from: 60, to: 80, value: '#669922' },\n        { from: 80, value: '#118832' },\n    ],\n};\n\nconst basePresetContext = {\n    strokeColorEditorConfig: undefined,\n};\n\nconst basePresetOptions = {\n    strokeColor: undefined,\n};\n\nexport const presets = [\n    {\n        label: _('Static'),\n        name: 'lineColor.static',\n        value: {\n            context: { ...basePresetContext },\n            options: { ...basePresetOptions },\n        },\n    },\n    {\n        label: _('Dynamic'),\n        name: 'lineColor.dynamic',\n        value: {\n            context: {\n                ...basePresetContext,\n                strokeColorEditorConfig: defaultContext.defaultRangeValue,\n            },\n            options: {\n                ...basePresetOptions,\n                strokeColor:\n                    '> strokeDataPoint | rangeValue(strokeColorEditorConfig)',\n            },\n        },\n    },\n];\n\nconst StaticColorEditor = {\n    label: _('Color value'),\n    option: 'strokeColor',\n    editor: 'editor.color',\n    showEditor: ({ options }: ConnectedLineProps) =>\n        !isDynamicOption(options?.strokeColor),\n    editorProps: {\n        labelPosition: 'top',\n        themeVariable: '@splunk/dashboard-layouts/ConnectedLine.strokeColor',\n    },\n};\n\nconst DynamicColorEditor = {\n    label: _('Color range'),\n    option: 'strokeColor',\n    context: 'defaultContext',\n    editor: 'editor.dynamicColor',\n    showEditor: ({ options }: ConnectedLineProps) =>\n        isDynamicOption(options?.strokeColor),\n    editorProps: {\n        labelPosition: 'top',\n        flyoutTitle: _('Dynamic line color'),\n        formatters: [\n            {\n                label: _('Ranges'),\n                value: 'rangeValue',\n                isDefault: true, // show it by default when open dynamic color flyout\n                defaults: {\n                    strokeDataPoint: defaultContext.defaultRangeValue,\n                },\n            },\n        ],\n        dataSelectors: [\n            {\n                label: _('Color field'),\n                value: 'strokeDataPoint',\n            },\n        ],\n        defaultPalettesConfig,\n    },\n};\n\nexport interface Editor {\n    label: string;\n    option?: string;\n    editor: string;\n    context?: string;\n    key?: string;\n    editorProps?: Record<string, unknown>;\n    showEditor?: (args: ConnectedLineProps) => boolean;\n}\n\nexport interface EditorSection {\n    label: string;\n    layout: Editor[][];\n}\n\nconst editorConfig: EditorSection[] = [\n    {\n        label: _('Selected data field'),\n        layout: [\n            [\n                {\n                    label: _('Data field'),\n                    editor: 'editor.columnSelector',\n                    option: 'strokeDataSeries',\n                    context: 'strokeDataContext',\n                    editorProps: {\n                        dataSourceKey: 'primary',\n                        prepareValue: (definition: {\n                            options: ConnectedLineOptions;\n                        }) => {\n                            const {\n                                options: { strokeDataSeries },\n                            } = definition;\n                            return {\n                                context: {},\n                                options: {\n                                    strokeDataPoint: `> strokeDataSeries | lastPoint()`,\n                                    strokeDataSeries,\n                                },\n                            };\n                        },\n                    },\n                },\n            ],\n        ],\n    },\n    {\n        label: _('Color and style'),\n        layout: [\n            [\n                {\n                    label: _('Mode'),\n                    key: 'presetSelector',\n                    editor: 'editor.presetSelector',\n                    editorProps: {\n                        presets,\n                        value: ({\n                            context,\n                            options,\n                        }: {\n                            context: Record<string, unknown>;\n                            options: ConnectedLineOptions;\n                        }) => {\n                            const initialPreset = getInitialPreset(\n                                context,\n                                options,\n                                presets\n                            );\n                            return initialPreset?.label || null;\n                        },\n                    },\n                },\n            ],\n            [\n                {\n                    ...StaticColorEditor,\n                },\n            ],\n            [\n                {\n                    ...DynamicColorEditor,\n                },\n            ],\n            [\n                {\n                    label: _('Stroke opacity'),\n                    option: 'strokeOpacity',\n                    editor: 'editor.percent',\n                },\n            ],\n            [\n                {\n                    label: _('Stroke thickness (px)'),\n                    option: 'strokeWidth',\n                    editor: 'editor.number',\n                    editorProps: {\n                        min: 1,\n                    },\n                },\n            ],\n            [\n                {\n                    label: _('Stroke dash style'),\n                    option: 'strokeDasharray',\n                    editor: 'editor.number',\n                    editorProps: {\n                        min: 0,\n                    },\n                },\n            ],\n            [\n                {\n                    label: _('Starting arrow point'),\n                    option: 'fromArrow',\n                    editor: 'editor.toggle',\n                    editorProps: {\n                        labelPosition: 'right',\n                    },\n                },\n            ],\n            [\n                {\n                    label: _('Ending arrow point'),\n                    option: 'toArrow',\n                    editor: 'editor.toggle',\n                    editorProps: {\n                        labelPosition: 'right',\n                    },\n                },\n            ],\n        ],\n    },\n];\n\nexport default editorConfig;\n", "import type { Coordinate } from '@splunk/dashboard-types';\n\n/**\n * Computes the Arrow's triangle dimensions\n * @param {Number} w line width\n * @param {Number} h line height\n * @param {Number} l line length\n * @param {Number} L arrow length\n */\nexport const computeArrowTriangle = (\n    w: number,\n    h: number,\n    l: number,\n    L: number\n) => {\n    if (l === 0) {\n        return { arrowW: 0, arrowH: 0, arrowL: 0 };\n    }\n    const arrowW = (w * L) / l;\n    const arrowH = (h * L) / l;\n    return { arrowW, arrowH, arrowL: L };\n};\n\n/**\n * Computes the To Arrow Angle to place at the From position of the line that is drawn\n * @param {Object} from x and y coordinate\n * @param {Object} to x and y coordinate\n */\nexport const computeFromArrowAngle = (from: Coordinate, to: Coordinate) => {\n    if (to.x - from.x === 0) {\n        return from.y > to.y ? 90 : 270;\n    }\n    const angle =\n        Math.atan((to.y - from.y) / (to.x - from.x)) * (180 / Math.PI);\n    return from.x > to.x ? angle : 180 + angle;\n};\n\n/**\n * Computes the To Arrow Angle to place at the To position of the line that is drawn\n * @param {Object} from x and y coordinate\n * @param {Object} to x and y coordinate\n */\nexport const computeToArrowAngle = (from: Coordinate, to: Coordinate) => {\n    if (to.x - from.x === 0) {\n        return from.y > to.y ? 270 : 90;\n    }\n    const angle =\n        Math.atan((to.y - from.y) / (to.x - from.x)) * (180 / Math.PI);\n    return from.x > to.x ? 180 + angle : angle;\n};\n\n/**\n * Computes the modified From coordinates depending on whether an arrow is present or not\n * @param {Object} from x and y coordinate\n * @param {Object} to x and y coordinate\n * @param {Number} arrowW the width of the drawn arrow, adjusted to the angle\n * @param {Number} arrowH the height of the drawn arrow, adjusted to the angle\n * @param {Boolean} fromArrow whether the From Arrow is present or not\n */\nexport const getNewFrom = (\n    from: Coordinate,\n    to: Coordinate,\n    arrowW: number,\n    arrowH: number,\n    fromArrow: boolean\n) => {\n    let newFromX;\n    let newFromY;\n    if (fromArrow) {\n        newFromX = from.x > to.x ? from.x - arrowW : from.x + arrowW;\n        newFromY = from.y > to.y ? from.y - arrowH : from.y + arrowH;\n    } else {\n        newFromX = from.x;\n        newFromY = from.y;\n    }\n    return { newFrom: { x: newFromX, y: newFromY } };\n};\n\n/**\n * Computes the modified To coordinates depending on whether an arrow is present or not\n * @param {Object} from x and y coordinate\n * @param {Object} to x and y coordinate\n * @param {Number} arrowW the width of the drawn arrow, adjusted to the angle\n * @param {Number} arrowH the height of the drawn arrow, adjusted to the angle\n * @param {Boolean} toArrow whether the To Arrow is present or not\n */\nexport const getNewTo = (\n    from: Coordinate,\n    to: Coordinate,\n    arrowW: number,\n    arrowH: number,\n    toArrow: boolean\n) => {\n    let newToX;\n    let newToY;\n    if (toArrow) {\n        newToX = from.x > to.x ? to.x + arrowW : to.x - arrowW;\n        newToY = from.y > to.y ? to.y + arrowH : to.y - arrowH;\n    } else {\n        newToX = to.x;\n        newToY = to.y;\n    }\n    return { newTo: { x: newToX, y: newToY } };\n};\n\n/**\n * Computes the Path's (Line drawn) triangle dimensions\n * @param {Object} from x and y coordinate\n * @param {Object} to x and y coordinate\n */\nexport const computePathTriangle = (from: Coordinate, to: Coordinate) => {\n    const w = Math.abs(from.x - to.x);\n    const h = Math.abs(from.y - to.y);\n    const l = Math.sqrt(w * w + h * h);\n    return { w, h, l };\n};\n", "import React, { useMemo } from 'react';\nimport { _ } from '@splunk/ui-utils/i18n';\nimport LineIcon from '@splunk/react-icons/Line';\nimport { Options as Opts } from '@splunk/visualization-encoding/Options';\nimport { vizCategories as categories } from '@splunk/dashboard-context';\nimport { noop, console, uniqueId } from '@splunk/dashboard-utils';\nimport { useSplunkTheme } from '@splunk/themes';\nimport type { Coordinate } from '@splunk/dashboard-types';\nimport optionsSchema from './ConnectedLineOptionsSchema';\nimport editorConfig from './ConnectedLineEditorConfig';\nimport {\n    computeArrowTriangle,\n    computeFromArrowAngle,\n    computeToArrowAngle,\n    getNewFrom,\n    getNewTo,\n    computePathTriangle,\n} from './utils/lineUtils';\nimport type { ConnectedLineOptions, ConnectedLineProps } from './types';\n\nconst rootSvgStyle: React.CSSProperties = {\n    pointerEvents: 'none',\n    overflow: 'visible',\n};\n\nconst lineStyle: React.CSSProperties = {\n    pointerEvents: 'auto',\n};\n\nconst dataContract = {\n    requiredDataSources: ['primary'],\n    initialRequestParams: {},\n};\n\nconst vizConfig = {\n    optionsSchema,\n    editorConfig,\n    dataContract,\n    key: 'abslayout.line',\n    name: _('Connected Line'),\n    category: categories.get('shapes'),\n    icon: LineIcon,\n    events: {}, // no onEventTrigger called by connected line\n    supports: ['dynamic-options'], // what capabilities are supported?\n    requiredProps: [],\n};\n\nconst defaultOptions: ConnectedLineOptions = {\n    strokeOpacity: 1,\n    strokeWidth: 1,\n    strokeDasharray: 0,\n    strokeDataSeries: '> primary | seriesByType(\"number\")',\n    strokeDataPoint: '> strokeDataSeries | lastPoint()',\n    fromArrow: false,\n    toArrow: false,\n};\n\nconst defaultFrom: Coordinate = {\n    x: 0,\n    y: 0,\n};\n\nconst defaultTo: Coordinate = {\n    x: 150,\n    y: 0,\n};\n\nconst empty = {};\n\nconst ConnectedLine = ({\n    from = defaultFrom,\n    to = defaultTo,\n    onLineSelect = noop,\n    options = defaultOptions,\n    dataSources = empty,\n    context = empty,\n}: ConnectedLineProps) => {\n    const { backgroundColorFloating } = useSplunkTheme();\n    const renderOptions = useMemo<Required<ConnectedLineOptions>>(() => {\n        try {\n            return Opts.evaluate(\n                {\n                    context,\n                    options: {\n                        ...defaultOptions,\n                        ...options,\n                    },\n                },\n                dataSources\n            );\n        } catch (e) {\n            if (e instanceof Error) {\n                console.error(\n                    `Unexpected error evaluating line options: ${e.message}`\n                );\n            }\n        }\n\n        return defaultOptions;\n    }, [context, options, dataSources]);\n\n    const { w, h, l } = computePathTriangle(from, to);\n\n    const arrowL = 5 * renderOptions.strokeWidth;\n    const { arrowW, arrowH } = computeArrowTriangle(w, h, l, arrowL);\n    const squashedArrows =\n        arrowL > l && renderOptions.fromArrow && renderOptions.toArrow;\n\n    const fromArrowAngle = computeFromArrowAngle(from, to);\n    const toArrowAngle = computeToArrowAngle(from, to);\n\n    const fromArrowId = uniqueId();\n    const toArrowId = uniqueId();\n\n    const newW = w + arrowL;\n    const newH = h + 2 * arrowL + 10;\n\n    const { newFrom } = getNewFrom(\n        from,\n        to,\n        arrowW,\n        arrowH,\n        renderOptions.fromArrow\n    );\n    const { newTo } = getNewTo(from, to, arrowW, arrowH, renderOptions.toArrow);\n\n    return (\n        <svg width={newW} height={newH} style={rootSvgStyle}>\n            <path\n                data-test=\"arrows\"\n                d={\n                    squashedArrows\n                        ? `M${newTo.x} ${newTo.y} L${newFrom.x} ${newFrom.y}`\n                        : `M${newFrom.x} ${newFrom.y} L${newTo.x} ${newTo.y}`\n                }\n                stroke={renderOptions.strokeColor || backgroundColorFloating}\n                strokeOpacity={`${renderOptions.strokeOpacity}`}\n                strokeWidth={`${renderOptions.strokeWidth}`}\n                strokeDasharray={`${renderOptions.strokeDasharray}`}\n                fill=\"none\"\n                markerStart={\n                    renderOptions.fromArrow ? `url(#${fromArrowId})` : ''\n                }\n                markerEnd={renderOptions.toArrow ? `url(#${toArrowId})` : ''}\n            />\n            <path\n                data-test=\"line\"\n                onMouseDown={onLineSelect}\n                d={`M${from.x} ${from.y} L${to.x} ${to.y}`}\n                strokeWidth={`${renderOptions.strokeWidth + 20}`}\n                fill=\"none\"\n                stroke=\"white\"\n                strokeOpacity={0}\n                style={lineStyle}\n            />\n            <defs>\n                <marker\n                    id={`${fromArrowId}`}\n                    markerWidth=\"10\"\n                    markerHeight=\"10\"\n                    refX={squashedArrows ? '5' : '0'}\n                    refY=\"2\"\n                    orient={`${fromArrowAngle}deg`}\n                    markerUnits=\"strokeWidth\"\n                >\n                    <path\n                        d=\"M0,0 L0,4 L5,2 z\"\n                        fill={\n                            renderOptions.strokeColor || backgroundColorFloating\n                        }\n                        fillOpacity={`${renderOptions.strokeOpacity}`}\n                    />\n                </marker>\n                <marker\n                    id={`${toArrowId}`}\n                    markerWidth=\"10\"\n                    markerHeight=\"10\"\n                    refX={squashedArrows ? '5' : '0'}\n                    refY=\"2\"\n                    orient={`${toArrowAngle}deg`}\n                    markerUnits=\"strokeWidth\"\n                >\n                    <path\n                        d=\"M0,0 L0,4 L5,2 z\"\n                        fill={\n                            renderOptions.strokeColor || backgroundColorFloating\n                        }\n                        fillOpacity={`${renderOptions.strokeOpacity}`}\n                    />\n                </marker>\n            </defs>\n        </svg>\n    );\n};\n\nConnectedLine.config = vizConfig;\nexport default ConnectedLine;\n", "export default {\n    showTitleAndDescription: {\n        type: 'boolean',\n        default: true,\n        description:\n            'A Boolean value to determine whether to display the Canvas Title and Description or not.',\n    },\n    submitButton: {\n        type: 'boolean',\n        description:\n            'You can also specify the layout option \"submitButton\". When set to true, a user must click a Submit button in order for the change in input selection to take effect (e.g. rerun searches with new dropdown values). If set to false, or if not specified at all, the dashboard will immediately refresh when a user makes a change in input selection.',\n        default: false,\n    },\n    submitOnDashboardLoad: {\n        type: 'boolean',\n        default: false,\n        description:\n            'A Boolean value to determine whether inputs should submit their default values (if they exist) on initial dashboard load in order to allow searches to run once before requiring submit button to be used. To be used when `submitButton` is set to true.',\n    },\n};\n", "import type { EmittableEvent } from '@splunk/dashboard-telemetry';\nimport type {\n    LayoutApi,\n    LayoutApiConstructorArgs,\n    LayoutDefinitionItem,\n    TelemetryAPI,\n    UserMessageFn,\n} from '@splunk/dashboard-types';\n\n/**\n * An abstract base for a layout API.\n *\n * @template {any} [TLayoutStructure=unknown] The type which represents the layout structure to be handled\n * @template {string} [TItemType=string] Allowed values for the optional `type` property\n * @template {object} [TOptions=object] The type of the layout `options` property\n */\nexport abstract class BaseLayoutApi<\n    TLayoutStructure = unknown,\n    TItemType extends string = string,\n    TOptions extends object = Record<string, unknown>\n> implements LayoutApi<TLayoutStructure, TItemType, TOptions>\n{\n    bgImageSrc?: string;\n\n    readonly layoutId: string;\n\n    protected readonly telemetry?: TelemetryAPI;\n\n    protected readonly getDefinition: () => LayoutDefinitionItem<\n        TLayoutStructure,\n        TOptions\n    >;\n\n    protected readonly userMessage: UserMessageFn;\n\n    constructor(arg0: LayoutApiConstructorArgs) {\n        this.layoutId = arg0.layoutId;\n        this.telemetry = arg0.telemetry;\n        this.getDefinition = arg0.getDefinition as () => LayoutDefinitionItem<\n            TLayoutStructure,\n            TOptions\n        >;\n        this.userMessage = arg0.userMessage;\n    }\n\n    emitTelemetry(payload: EmittableEvent): boolean {\n        if (!this.telemetry) {\n            return false;\n        }\n\n        this.telemetry.emit({ source: 'layoutApi', ...payload });\n        return true;\n    }\n\n    /**\n     * get all items in use by the layout\n     */\n    abstract getLayoutItems(): ReturnType<\n        LayoutApi<TLayoutStructure, TItemType, TOptions>['getLayoutItems']\n    >;\n\n    /**\n     * add one or more new layout items\n     */\n    abstract addLayoutItems(\n        ...args: Parameters<\n            LayoutApi<TLayoutStructure, TItemType, TOptions>['addLayoutItems']\n        >\n    ): ReturnType<\n        LayoutApi<TLayoutStructure, TItemType, TOptions>['addLayoutItems']\n    >;\n\n    /**\n     * copies item w/h and position with an offset\n     */\n    abstract cloneLayoutItems(\n        ...args: Parameters<\n            LayoutApi<TLayoutStructure, TItemType, TOptions>['cloneLayoutItems']\n        >\n    ): ReturnType<\n        LayoutApi<TLayoutStructure, TItemType, TOptions>['cloneLayoutItems']\n    >;\n\n    /**\n     * remove an item from layout\n     */\n    abstract removeLayoutItems(\n        ...args: Parameters<\n            LayoutApi<\n                TLayoutStructure,\n                TItemType,\n                TOptions\n            >['removeLayoutItems']\n        >\n    ): ReturnType<\n        LayoutApi<TLayoutStructure, TItemType, TOptions>['removeLayoutItems']\n    >;\n\n    /**\n     * compute snapshot of this layout\n     */\n    abstract snapshot(\n        ...args: Parameters<\n            LayoutApi<TLayoutStructure, TItemType, TOptions>['snapshot']\n        >\n    ): ReturnType<LayoutApi<TLayoutStructure, TItemType, TOptions>['snapshot']>;\n\n    [key: string]: unknown;\n}\n", "import { _ } from '@splunk/ui-utils/i18n';\nimport type { EmittableEvent } from '@splunk/dashboard-telemetry';\nimport type {\n    AbsoluteLayoutItem,\n    AbsoluteLayoutOptions,\n    AbsoluteLayoutStructure,\n    AddLayoutItemsArgs,\n    CloneLayoutItemsArgs,\n    StructureItemType,\n    VizConfig,\n    RemoveLayoutItemsArgs,\n    StructureItem,\n} from '@splunk/dashboard-types';\nimport {\n    computeNewAbsoluteStructureItem,\n    isBlockItem,\n} from '@splunk/dashboard-utils';\n\nimport { absoluteLayoutOptions } from '../DefaultOptions';\nimport {\n    cloneBlockItem,\n    cloneLine,\n    computeLineAbsPosition,\n    disconnectLine,\n    getAllBlockItems,\n    getAllLineItems,\n    moveLayoutItem,\n} from '../utils';\n\nimport { BaseLayoutApi } from './BaseLayoutApi';\n\nconst { width: DEFAULT_WIDTH, height: DEFAULT_HEIGHT } = absoluteLayoutOptions;\n\ntype CloneAbsoluteLayoutItemsArgs = CloneLayoutItemsArgs & {\n    offsetMultiplier?: number;\n};\n\nconst copyStructureItem = ({\n    item,\n    toId,\n    offsetMultiplier,\n    initialStructure,\n    updatedStructure,\n}: {\n    item?: AbsoluteLayoutItem;\n    toId: string;\n    offsetMultiplier: number;\n    initialStructure: AbsoluteLayoutStructure;\n    updatedStructure: AbsoluteLayoutStructure;\n}) => {\n    if (!item) {\n        return;\n    }\n\n    if (isBlockItem(item)) {\n        const clonedBlockItem = cloneBlockItem({\n            id: toId,\n            item,\n            offsetMultiplier,\n        });\n        updatedStructure.push(clonedBlockItem);\n    } else if (item.type === 'line') {\n        // line is a bit complicated as we need to clone based on absolute position\n        const linePosition = computeLineAbsPosition({\n            layoutStructure: initialStructure,\n            position: item.position,\n        });\n\n        const clonedLine = cloneLine({\n            id: toId,\n            item: {\n                item: item.item,\n                type: 'line',\n                position: linePosition,\n            },\n            offsetMultiplier,\n        });\n        updatedStructure.push(clonedLine);\n    }\n};\n\nexport class AbsoluteLayoutApi extends BaseLayoutApi<\n    AbsoluteLayoutStructure,\n    StructureItemType,\n    AbsoluteLayoutOptions\n> {\n    get #options(): AbsoluteLayoutOptions {\n        return this.getDefinition().options ?? absoluteLayoutOptions;\n    }\n\n    get #structure(): AbsoluteLayoutStructure {\n        return this.getDefinition().structure ?? [];\n    }\n\n    /**\n     * Get layout items in order\n     * @method\n     * @returns {String} ordered item ids\n     * @public\n     */\n    getLayoutItemOrder(): string[] {\n        const layoutStructure = this.#structure;\n        return getAllBlockItems({ layoutStructure }).map(({ item }) => item);\n    }\n\n    /**\n     * Adjust layout item order\n     * @method\n     * @param {Number} currentOrder\n     * @param {Number} newOrder\n     * @param {Object} [arg0.metadata] Optional telemetry metadata to be emitted as part of the **adjustLayoutItemOrder** page action event\n     * @returns {AbsoluteLayoutStructure} updated layout structure\n     * @public\n     */\n    adjustLayoutItemOrder(\n        currentOrder: number,\n        newOrder: number,\n        metadata?: EmittableEvent['metadata']\n    ): AbsoluteLayoutStructure {\n        this.emitTelemetry({ pageAction: 'adjustLayoutItemOrder', metadata });\n\n        const layoutStructure = this.#structure;\n        const blockItems = getAllBlockItems({ layoutStructure });\n        const lineItems = getAllLineItems({ layoutStructure });\n\n        const updatedBlockItems = moveLayoutItem(\n            blockItems,\n            currentOrder,\n            Math.min(newOrder, blockItems.length)\n        );\n\n        // an lazy way of rearrange block item orders. lol\n        return [...lineItems, ...updatedBlockItems];\n    }\n\n    /**\n     * Get an array of all items owned by the layout\n     * @returns {StructureItem[]} An unordered array of items in the structure\n     * @public\n     */\n    getLayoutItems() {\n        return [...this.#structure] as unknown as StructureItem[];\n    }\n\n    /**\n     * Generate a new layout structure with one one or more items added\n     * @method addLayoutItems\n     * @param {Object[]} arg0.items An array of items to be added to the structure\n     * @param {Object} [arg0.metadata] Optional telemetry metadata to be emitted as part of the **addLayoutItems** page action event\n     * @returns {AbsoluteLayoutStructure} A new layout structure\n     * @public\n     */\n    addLayoutItems({ items, metadata }: AddLayoutItemsArgs<StructureItemType>) {\n        this.emitTelemetry({ pageAction: 'addLayoutItems', metadata });\n\n        const { width = DEFAULT_WIDTH, height = DEFAULT_HEIGHT } =\n            this.#options;\n\n        const structure = this.#structure;\n\n        // generate a proposed layout structure\n        // it's up to the consumer to apply this structure via setting layoutStructure prop\n        return items.reduce<AbsoluteLayoutStructure>(\n            (proposedStructure, item) => {\n                const newStructureItem = computeNewAbsoluteStructureItem({\n                    ...item,\n                    config: item.config as VizConfig,\n                    type: item.type ?? 'block',\n                    canvasWidth: width,\n                    canvasHeight: height,\n                    layoutItems: proposedStructure,\n                });\n\n                proposedStructure.push(newStructureItem);\n                return proposedStructure;\n            },\n            [...structure]\n        );\n    }\n\n    /**\n     * Generate a new layout structure with one or more items removed by their ID\n     * @method removeLayoutItems\n     * @param {Object[]} arg0.itemIds An array of item IDs to be removed from the structure\n     * @param {Object} [arg0.metadata] Optional telemetry metadata to be emitted as part of the **removeLayoutItems** page action event\n     * @returns {AbsoluteLayoutStructure} A new layout structure\n     * @public\n     */\n    removeLayoutItems({\n        itemIds = [],\n        metadata,\n    }: RemoveLayoutItemsArgs): AbsoluteLayoutStructure {\n        this.emitTelemetry({ pageAction: 'removeLayoutItems', metadata });\n\n        const updatedItems: AbsoluteLayoutStructure = [];\n        const layoutStructure = this.#structure;\n        layoutStructure.forEach((item) => {\n            let iterItem = item;\n            if (item.type === 'line') {\n                let updatedLine = item;\n                // disconnect line if necessary\n                const absPos = computeLineAbsPosition({\n                    layoutStructure,\n                    position: updatedLine.position,\n                });\n                if (\n                    'item' in updatedLine.position.from &&\n                    itemIds.indexOf(updatedLine.position.from.item) >= 0\n                ) {\n                    updatedLine = disconnectLine({\n                        line: updatedLine,\n                        dir: 'from',\n                        absPos: absPos.from,\n                    });\n                }\n                if (\n                    'item' in updatedLine.position.to &&\n                    itemIds.indexOf(updatedLine.position.to.item) >= 0\n                ) {\n                    updatedLine = disconnectLine({\n                        line: updatedLine,\n                        dir: 'to',\n                        absPos: absPos.to,\n                    });\n                }\n\n                iterItem = updatedLine;\n            }\n            if (itemIds.indexOf(iterItem.item) < 0) {\n                // push into array if it's not been removed\n                updatedItems.push(iterItem);\n            }\n        });\n        return updatedItems;\n    }\n\n    /**\n     * Generates a new layout structure with copies of item(s) specified in the `from` array, having new IDs specified in the `to` array, with positions offset by `offsetMultiplier * OFFSET_SIZE`\n     * @method cloneLayoutItems\n     * @param {Array} arg0.from List of original item IDs\n     * @param {Array} arg0.to List of new item IDs\n     * @param {Number} [arg0.offsetMultiplier=1] The multiple of `OFFSET_SIZE` by which to offset the cloned item(s)\n     * @param {Object} [arg0.metadata] Optional telemetry metadata to be emitted as part of the **cloneLayoutItems** page action event\n     * @returns {AbsoluteLayoutStructure} Layout structure of all known items\n     * @public\n     * @throws {Error} Will error if `from` or `to` is not an array, or `from.length` != `to.length`\n     */\n    cloneLayoutItems = ({\n        from,\n        to,\n        offsetMultiplier = 1,\n        metadata,\n    }: CloneAbsoluteLayoutItemsArgs): AbsoluteLayoutStructure => {\n        if (\n            !Array.isArray(from) ||\n            !Array.isArray(to) ||\n            from.length !== to.length\n        ) {\n            throw new Error(_('Cannot clone item(s), incorrect inputs'), {\n                cause: { from, to },\n            });\n        }\n\n        this.emitTelemetry({ pageAction: 'cloneLayoutItems', metadata });\n\n        const layoutStructure = this.#structure;\n\n        // Precompute the itemId::layoutItem mapping so no iteration has to run through the layout structure\n        const currentStructure = new Map<string, AbsoluteLayoutItem>();\n        layoutStructure.forEach((item) => {\n            currentStructure.set(item.item, item);\n        });\n\n        // generate a proposed layout structure\n        // it's up to the consumer to apply this structure via setting layoutStructure prop\n        const updatedStructure: AbsoluteLayoutStructure = [...layoutStructure];\n        from.forEach((copyItemId, idx) => {\n            copyStructureItem({\n                item: currentStructure.get(copyItemId),\n                toId: to[idx],\n                offsetMultiplier,\n                initialStructure: layoutStructure,\n                updatedStructure,\n            });\n        });\n\n        return updatedStructure;\n    };\n\n    /**\n     * Return snapshot of the layout options which includes the inlined background image\n     * @method snapshot\n     * @returns {Object} Updated Layout options with encoded background image\n     * @public\n     */\n    snapshot(): AbsoluteLayoutOptions {\n        const options =\n            this.#options === absoluteLayoutOptions ? {} : this.#options;\n\n        if (!options.backgroundImage?.src) {\n            // no background image to be inlined\n\n            const clonedOptions = { ...options };\n            if (clonedOptions.backgroundImage) {\n                // also clone the backgroundImage options\n                clonedOptions.backgroundImage = { ...options.backgroundImage };\n            }\n\n            return clonedOptions;\n        }\n\n        return {\n            ...options,\n            backgroundImage: {\n                ...options.backgroundImage,\n                src: this.bgImageSrc ?? options.backgroundImage.src,\n            },\n        };\n    }\n}\n", "import { _ } from '@splunk/ui-utils/i18n';\nimport {\n    computeNewGridStructureItem,\n    updateRemovedVizNeighbors,\n} from '@splunk/dashboard-utils';\nimport type {\n    AddLayoutItemsArgs,\n    CloneLayoutItemsArgs,\n    GridLayoutOptions,\n    GridLayoutStructure,\n    LayoutItemType,\n    RemoveLayoutItemsArgs,\n    StructureItem,\n} from '@splunk/dashboard-types';\nimport { gridLayoutOptions } from '../DefaultOptions';\nimport {\n    CLONE_LAYOUT_ITEMS_MSG_PANEL_TOO_SMALL,\n    MIN_WIDTH_PX,\n} from '../GridLayoutConstants';\nimport { getBlockItem, updateBlockItemSize } from '../utils';\nimport { BaseLayoutApi } from './BaseLayoutApi';\n\nconst { width: DEFAULT_WIDTH } = gridLayoutOptions;\n\n/**\n * Return a new layout structure which removes the item with the provided ID and reallocates its space to neighboring elements\n * @throws if `id` is not an item id in `layoutStructure`, or if `id` is associated with a line item\n */\nconst removeGridItem = ({\n    layoutStructure,\n    id,\n    width,\n}: {\n    layoutStructure: GridLayoutStructure;\n    id: string;\n    width: number;\n}) => {\n    const itemToRemove = getBlockItem({ layoutStructure, id });\n    const updatedItems = updateRemovedVizNeighbors({\n        itemToRemove,\n        items: layoutStructure,\n        width,\n    });\n\n    const updatedItemIds = new Set(updatedItems.map(({ item }) => item));\n\n    return [\n        // anything in the structure which was updated to fill the hole in the grid\n        ...updatedItems,\n        // and anything which was left unchanged and is not the item being removed\n        ...layoutStructure.filter(\n            ({ item }) => item !== id && !updatedItemIds.has(item)\n        ),\n    ];\n};\n\nexport class GridLayoutApi extends BaseLayoutApi<\n    GridLayoutStructure,\n    LayoutItemType,\n    GridLayoutOptions\n> {\n    get #options(): GridLayoutOptions {\n        return this.getDefinition().options ?? gridLayoutOptions;\n    }\n\n    get #structure(): GridLayoutStructure {\n        return this.getDefinition().structure ?? [];\n    }\n\n    /**\n     * Get an array of all items owned by the layout\n     * @returns {StructureItem[]} An unordered array of items in the structure\n     * @public\n     */\n    getLayoutItems() {\n        return [...this.#structure] as unknown as StructureItem[];\n    }\n\n    /**\n     * Generate a new layout structure with one one or more items added\n     * @method addLayoutItems\n     * @param {Object[]} arg0.items An array of items to be added to the structure\n     * @param {Object} [arg0.metadata] Optional telemetry metadata to be emitted as part of the **addLayoutItems** page action event\n     * @returns {GridLayoutStructure} A new layout structure\n     * @public\n     */\n    addLayoutItems({ items, metadata }: AddLayoutItemsArgs<LayoutItemType>) {\n        this.emitTelemetry({ pageAction: 'addLayoutItems', metadata });\n\n        const { width = DEFAULT_WIDTH } = this.#options ?? gridLayoutOptions;\n\n        const proposedLayoutStructure = items.reduce(\n            (structure, { itemId, type }) => {\n                const newStructureItem = computeNewGridStructureItem({\n                    itemId,\n                    type: type ?? 'block',\n                    canvasWidth: width,\n                    layoutItems: structure,\n                });\n\n                structure.push(newStructureItem);\n                return structure;\n            },\n            [...this.#structure]\n        );\n\n        return proposedLayoutStructure;\n    }\n\n    /**\n     * Generates a new layout structure with copies of item(s) specified in the `from` array, having new IDs specified in the `to` array.\n     * @method cloneLayoutItems\n     * @param {Array} arg0.from List of original item IDs\n     * @param {Array} arg0.to List of new item IDs\n     * @param {Object} [arg0.metadata] Optional telemetry metadata to be emitted as part of the **cloneLayoutItems** page action event\n     * @returns {GridLayoutStructure} Layout structure of all known items\n     * @public\n     * @throws {Error} Will error if `from` or `to` is not an array, or `from.length` != `to.length`\n     */\n    cloneLayoutItems({ from, to, metadata }: CloneLayoutItemsArgs) {\n        if (\n            !Array.isArray(from) ||\n            !Array.isArray(to) ||\n            from.length !== to.length\n        ) {\n            throw new Error(_('Cannot clone item(s), incorrect inputs'), {\n                cause: { from, to },\n            });\n        }\n\n        this.emitTelemetry({ pageAction: 'cloneLayoutItems', metadata });\n\n        return from.reduce(\n            (layoutStructure, fromId, idx) => {\n                const ancestor = getBlockItem({ layoutStructure, id: fromId });\n                if (ancestor.position.w < MIN_WIDTH_PX * 2) {\n                    this.userMessage({\n                        message: CLONE_LAYOUT_ITEMS_MSG_PANEL_TOO_SMALL,\n                        level: 'warning',\n                        sender: 'GridLayoutApi',\n                    });\n\n                    return layoutStructure;\n                }\n\n                // update left-side (item being cloned) to have half its original width\n                const offsetLS = -1 * Math.floor(ancestor.position.w / 2);\n                const lsDescendant = updateBlockItemSize({\n                    item: { ...ancestor },\n                    offset: { offsetX: offsetLS, offsetY: 0 },\n                    dir: 'e',\n                });\n\n                // update right-side (clone of item) to have the remaining width\n                const offsetRS = Math.ceil(ancestor.position.w / 2);\n                const rsDescendant = updateBlockItemSize({\n                    item: { ...ancestor, item: to[idx] },\n                    offset: { offsetX: offsetRS, offsetY: 0 },\n                    dir: 'w',\n                });\n\n                return [\n                    ...layoutStructure.filter(({ item }) => item !== fromId),\n                    lsDescendant,\n                    rsDescendant,\n                ];\n            },\n            [...this.#structure]\n        );\n    }\n\n    /**\n     * Generate a new layout structure with one or more items removed by their ID. The space occupied by the removed item(s) will be reallocated to the closest neighboring panel.\n     *\n     * **Note:** Changing the order of the values of `itemIds` can change the generated structure. Items are removed sequentially with the dimensions of neighbors of the item being updated between each removal.\n     * @method removeLayoutItems\n     * @param {Object[]} arg0.itemIds An array of item IDs to be removed from the structure\n     * @param {Object} [arg0.metadata] Optional telemetry metadata to be emitted as part of the **removeLayoutItems** page action event\n     * @returns {GridLayoutStructure} A new layout structure\n     * @public\n     */\n    removeLayoutItems({ itemIds, metadata }: RemoveLayoutItemsArgs) {\n        this.emitTelemetry({ pageAction: 'removeLayoutItems', metadata });\n\n        const { width = DEFAULT_WIDTH } = this.#options;\n\n        return itemIds.reduce<GridLayoutStructure>(\n            (layoutStructure, id) => {\n                try {\n                    return removeGridItem({ width, layoutStructure, id });\n                } catch {\n                    // item does not exist, or its type is \"line\" -- ignore it\n                    return layoutStructure;\n                }\n            },\n            [...this.#structure]\n        );\n    }\n\n    /**\n     * Return snapshot as a clone of the layout options\n     * @method snapshot\n     * @returns {Object} Cloned layout options\n     * @public\n     */\n    snapshot(): GridLayoutOptions {\n        // if #options coalesces then return an empty object (no options defined)\n        return this.#options === gridLayoutOptions ? {} : { ...this.#options };\n    }\n}\n"],
  "mappings": "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",
  "names": ["import_dist", "r", "t", "n", "e", "a", "o", "i", "f", "d", "s", "p", "__toCommonJS", "__toESM", "defaultImport", "utilsComputeMaxHeight", "_a", "defaultState", "DEFAULT_SELECTED_LAYOUT_ITEMS", "noop", "snapOffset", "renderBlockItems", "defaultLayoutStructure", "GridCanvas", "categories", "defaultOptions", "Opts", "DEFAULT_WIDTH", "options_get", "structure_get"]
}
