import __buffer_polyfill from 'vite-plugin-node-polyfills/shims/buffer'
globalThis.Buffer = globalThis.Buffer || __buffer_polyfill
import __global_polyfill from 'vite-plugin-node-polyfills/shims/global'
globalThis.global = globalThis.global || __global_polyfill
import __process_polyfill from 'vite-plugin-node-polyfills/shims/process'
globalThis.process = globalThis.process || __process_polyfill

import {
  require_lodash
} from "./chunk-FUC7W543.js";
import {
  __commonJS,
  __toESM,
  require_dist,
  require_dist2,
  require_dist3
} from "./chunk-2RF6DQJU.js";

// node_modules/@splunk/datasources/DataSource.js
var require_DataSource = __commonJS({
  "node_modules/@splunk/datasources/DataSource.js"(exports, module) {
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    var __create = Object.create;
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __getProtoOf = Object.getPrototypeOf;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
    var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
      // If the importer is in node compatibility mode or this is not an ESM
      // file that has been converted to a CommonJS file using a Babel-
      // compatible transform (i.e. "__esModule" has not been set), then set
      // "default" to the CommonJS "module.exports" for node compatibility.
      isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
      mod
    ));
    var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var __async = (__this, __arguments, generator) => {
      return new Promise((resolve, reject) => {
        var fulfilled = (value) => {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        };
        var rejected = (value) => {
          try {
            step(generator.throw(value));
          } catch (e) {
            reject(e);
          }
        };
        var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
        step((generator = generator.apply(__this, __arguments)).next());
      });
    };
    var DataSource_exports = {};
    __export(DataSource_exports, {
      default: () => DataSource
    });
    module.exports = __toCommonJS(DataSource_exports);
    var lodash_exports = {};
    __export(lodash_exports, {
      default: () => lodash_default
    });
    var defaultImport = __toESM2(require_lodash());
    __reExport(lodash_exports, require_lodash());
    var lodash_default = "default" in defaultImport ? defaultImport.default : defaultImport;
    var DataSource = class {
      /**
       * Create a new DataSource instance
       * @param {Object} options DataSource options such as search string, earliest/latest time
       * @param {Object} context contextual information such as api key or scope
       * @param {Object} meta metadata of this datasource
       * @param {Object} baseChainModel base chain definition
       */
      constructor(options = {}, context = {}, meta = {}, baseChainModel = {}) {
        this.options = options;
        this.context = context;
        this.meta = meta;
        this.baseChainModel = baseChainModel;
      }
      /**
       * Setup the DataSource, create a connection or search job.
       * setup() will be called only once per DataSource.
       * Returns null by default; override to implement custom setup logic.
       *
       * @return {Promise}
       * @public
       */
      setup() {
        return Promise.resolve(null);
      }
      /**
       * Request a Data Stream represent by an Observable.
       * Once the Observable was created and returned,
       * it's the DataSource itself responsible for 'pushing' the data out via Observable.next() function.
       * Override this function to implement your own data fetching logic.
       *
       * @param {Object} [requestParams] RequestParams
       * @param {Number} [requestParams.offset] result offset
       * @param {Number} [requestParams.count] result count, use with offset to return data in pages
       * @param {Object} [requestParams.sort] result sorting, key indicate the sorting fields and value must be one of ['none', 'asc', 'desc']
       * @param {Boolean} [requestParams.requireTotalCount] true if TotalCount is required in meta
       * @param {Boolean} [requestParams.progress] true to emit progress data, false to only return data when search is finalized
       * @return {Observable}
       * @public
       */
      request(requestParams) {
        return (observer) => {
          if (observer) {
            observer.complete();
          }
          return () => {
          };
        };
      }
      /**
       * Halt updates to results, if supported
       * @return {Promise}
       * @public
       */
      pause() {
        return __async(this, null, function* () {
          return Promise.resolve(null);
        });
      }
      /**
       * Resume previously-halted updates to results, if supported
       * @return {Promise}
       * @public
       */
      resume() {
        return __async(this, null, function* () {
          return Promise.resolve(null);
        });
      }
      /**
       * Reports whether pause and resume controls are supported for the class instance
       * @return {Boolean} true if the DataSource supports pause and resume actions
       * @public
       */
      supportsControlActions() {
        return false;
      }
      /**
       * Teardown the DataSource, clean up the connection or other resources.
       * Returns null by default; override to implement custom teardown logic.
       *
       * @return {Promise}
       * @public
       */
      teardown() {
        return Promise.resolve(null);
      }
      /**
       * @param {DataSource} another another DataSource to compare with
       * @return {Boolean} true if the these two DataSources are considered equal.
       * @public
       */
      equals(another) {
        return this.constructor === another.constructor && (0, lodash_exports.isEqual)(this.options, another.options);
      }
      /**
       * Return an observer that can be used for chaining with other DataSources
       *
       * @return {Object}
       * @public
       */
      getObserver() {
        return {
          next({ requestParams, data, meta }) {
          },
          error({ level, message }) {
          },
          complete() {
          }
        };
      }
      /**
       * Flag used to indicate whether the subscription for this DataSource should be refreshed
       *
       * @return {Boolean}
       * @public
       */
      shouldRefreshSubscription() {
        return false;
      }
    };
  }
});
export default require_DataSource();
//# sourceMappingURL=@splunk_datasources_DataSource.js.map
