{
  "version": 3,
  "sources": ["../../@splunk/dashboard-event-handlers/src/index.ts", "../../@splunk/dashboard-event-handlers/src/utils/events.ts", "../../@splunk/dashboard-event-handlers/src/utils/coalesceOptionsArray.ts", "../../@splunk/dashboard-event-handlers/src/CustomUrlDrilldown.ts", "../../@splunk/dashboard-event-handlers/@splunk/dashboard-utils", "../../@splunk/dashboard-event-handlers/src/SetToken.ts", "../../@splunk/dashboard-event-handlers/src/ResetTokens.ts", "../../@splunk/dashboard-event-handlers/src/SwitchToTab.ts", "../../@splunk/dashboard-event-handlers/src/SetTimeRange.ts"],
  "sourcesContent": ["export { default as CustomUrlDrilldown } from './CustomUrlDrilldown';\nexport { default as SetToken } from './SetToken';\nexport { default as ResetTokens } from './ResetTokens';\nexport { default as SwitchToTab } from './SwitchToTab';\nexport { default as SetTimeRange } from './SetTimeRange';\nexport * from './utils/events';\n", "// allow range.select events\nexport const isRangeEventAllowed = (event: { type: string }): boolean =>\n    event.type === 'range.select';\n\n// filter out non-click based events\n// every viz has a different prefix for their click events, some viz may have multiple click events\nexport const isEventAllowed = (event: { type: string }): boolean =>\n    event.type.endsWith('.click') || event.type === 'input.change';\n\n/**\n * Check if a string value is supported\n * @param {string} [param0.value] A string value to check\n * @param {string} param0.supported An array of supported string values.\n * If this array contains `'any'` then the result will always be `true`\n * @returns `true` if any of the following scenarios are encountered:\n * - `supported` contains `'any'`\n * - `value` exists in `supported`\n */\nexport const isAcceptedEvent = ({\n    value = '',\n    supported,\n}: {\n    value?: string;\n    supported: string[];\n}) => supported.includes('any') || supported.includes(value);\n", "export const coalesceOptionsArray = (array?: string[]): string[] =>\n    Array.isArray(array) && array.length > 0 ? array : ['any'];\n", "import type {\n    EHRequired,\n    EventCanHandle,\n    EventHandle,\n    LinkToEvent,\n} from '@splunk/dashboard-types';\n\nimport { isAcceptedEvent, isEventAllowed } from './utils/events';\nimport { coalesceOptionsArray } from './utils/coalesceOptionsArray';\n\ninterface CustomUrlDrilldownOptions {\n    url?: string;\n    newTab?: boolean;\n    events?: string[];\n    fields?: string[];\n}\n\nclass CustomUrlDrilldown\n    implements EHRequired<Record<string, never>, LinkToEvent[]>\n{\n    private readonly options: CustomUrlDrilldownOptions;\n\n    private readonly events: string[];\n\n    private readonly fields: string[];\n\n    /**\n     * A configuration object is passed to the handler\n     * @constructor\n     * @param {Object} options\n     */\n    constructor(options: CustomUrlDrilldownOptions = {}) {\n        this.options = options;\n        this.events = coalesceOptionsArray(options.events);\n        this.fields = coalesceOptionsArray(options.fields);\n    }\n\n    /**\n     * Determines if the custom event handler is designed to convert the event\n     * @method canHandle\n     * @param {VisualizationEvent} event\n     * @returns {Boolean} true if the event handler will convert the event\n     */\n    canHandle: EventCanHandle = (event) => {\n        const fieldName = (event.payload as Record<string, string>)?.name;\n        return (\n            event &&\n            isEventAllowed(event) &&\n            this.options &&\n            !!this.options.url &&\n            // check for type support\n            isAcceptedEvent({ value: event.type, supported: this.events }) &&\n            // check for field support\n            isAcceptedEvent({ value: fieldName, supported: this.fields })\n        );\n    };\n\n    /**\n     * Convert the event payload into a list of actionable tasks\n     * @method handle\n     * @param {VisualizationEvent} event\n     * @returns {Array} List of action(s)\n     */\n    handle: EventHandle<Record<string, never>, LinkToEvent[]> = () => {\n        // TODO: verify url token updates happen external to the handler eventSaga:findEventHandler\n        return Promise.resolve([\n            {\n                type: 'linkTo',\n                payload: {\n                    url: this.options.url,\n                    newTab: this.options.newTab,\n                },\n            },\n        ]);\n    };\n}\n\nexport default CustomUrlDrilldown;\n", "\nimport * as defaultImport from \"@splunk/dashboard-utils\";\nexport * from \"@splunk/dashboard-utils\";\nexport default ('default' in defaultImport ? defaultImport.default : defaultImport);\n", "import type {\n    SetTokenEvent,\n    Token,\n    Tokens,\n    SetTokenOptions,\n    TokenRecord,\n    EventCanHandle,\n    EventHandle,\n    EHRequired,\n} from '@splunk/dashboard-types';\nimport { DEFAULT_TOKEN_NAMESPACE, deprecated } from '@splunk/dashboard-utils';\n\nimport { isAcceptedEvent, isEventAllowed } from './utils/events';\nimport { coalesceOptionsArray } from './utils/coalesceOptionsArray';\n\ntype Payload = Record<string, unknown>;\n\nclass SetToken implements EHRequired<{ payload: Payload }, SetTokenEvent[]> {\n    private readonly options: SetTokenOptions;\n\n    private readonly events: string[];\n\n    private readonly fields: string[];\n\n    private readonly tokens: Tokens;\n\n    /**\n     * A configuration object is passed to the handler\n     * @constructor\n     * @param {Object} options\n     */\n    constructor(options: SetTokenOptions) {\n        this.options = options;\n        this.events = coalesceOptionsArray(options.events);\n        this.fields = coalesceOptionsArray(options.fields);\n        const { key, token } = options;\n        if (key && token) {\n            deprecated(\n                'Using a single token option is deprecated. Please use the tokens option. `tokens: [{ key, token }]`'\n            );\n            this.tokens = [\n                {\n                    key,\n                    token,\n                },\n            ];\n        } else {\n            this.tokens = options.tokens ?? [];\n        }\n    }\n\n    /**\n     * Determines if the custom event handler is designed to convert the event\n     * @method canHandle\n     * @param {VisualizationEvent} event\n     * @returns {Boolean} true if the event handler will convert the event\n     */\n    canHandle: EventCanHandle<{ payload: Payload }> = (event) => {\n        const fieldName = (event.payload as Record<string, string>)?.name;\n        return (\n            isEventAllowed(event) &&\n            this.areTokensValid(event.payload) &&\n            // check for type support\n            isAcceptedEvent({ value: event.type, supported: this.events }) &&\n            // check for field support\n            isAcceptedEvent({ value: fieldName, supported: this.fields })\n        );\n    };\n\n    // a token is valid if there is a non undefined value in its payload[key] or value\n    areTokensValid(payload: Payload): boolean {\n        if (this.tokens.length < 1) {\n            return false;\n        }\n\n        return Object.values(this.getTokenValuesFromPayload(payload)).some(\n            (val) => val !== undefined\n        );\n    }\n\n    getTokenValuesFromPayload(payload: Payload): TokenRecord {\n        const tokenValuesMap: TokenRecord = {};\n        this.tokens.forEach(({ token, key, value }: Token) => {\n            if (key !== undefined && payload[key] !== undefined) {\n                tokenValuesMap[token] = payload[key] as string;\n            } else if (value !== undefined) {\n                // If there is no payload value but there is a static value use it\n                tokenValuesMap[token] = value;\n            }\n        });\n\n        return tokenValuesMap;\n    }\n\n    /**\n     * Convert the event payload into a list of actionable tasks\n     * @method handle\n     * @param {VisualizationEvent} event\n     * @returns {EventAction[]} List of action(s)\n     */\n    handle: EventHandle<Payload, SetTokenEvent[]> = (event) => {\n        return Promise.resolve([\n            {\n                type: 'setToken',\n                payload: {\n                    namespace:\n                        this.options.tokenNamespace || DEFAULT_TOKEN_NAMESPACE,\n                    tokens: this.getTokenValuesFromPayload(event.payload),\n                    submit: true,\n                },\n            },\n        ]);\n    };\n}\n\nexport default SetToken;\n", "import type {\n    ResetTokensEvent,\n    TokenName,\n    ResetTokensOptions,\n    TokenNamespace,\n    EventCanHandle,\n    EventHandle,\n    EHRequired,\n} from '@splunk/dashboard-types';\n\nimport { isEventAllowed, isRangeEventAllowed } from './utils/events';\n\ntype Payload = Record<string, unknown>;\n\nclass ResetTokens\n    implements EHRequired<{ payload: Payload }, ResetTokensEvent[]>\n{\n    private readonly tokenNames: TokenName[];\n\n    private readonly tokenNamespaces: TokenNamespace[];\n\n    /**\n     * A configuration object is passed to the handler\n     * @constructor\n     * @param {Object} options\n     */\n    constructor(options?: ResetTokensOptions) {\n        this.tokenNames = options?.tokenNames ?? [];\n        this.tokenNamespaces = options?.tokenNamespaces ?? [];\n    }\n\n    /**\n     * Determines if the custom event handler is designed to convert the event\n     * @method canHandle\n     * @param {VisualizationEvent} event\n     * @returns {Boolean} true if the event handler will convert the event\n     */\n    // eslint-disable-next-line class-methods-use-this\n    canHandle: EventCanHandle<{ payload: Payload }> = (event) => {\n        return isEventAllowed(event) || isRangeEventAllowed(event);\n    };\n\n    /**\n     * Convert the event payload into a list of actionable tasks\n     * @method handle\n     * @param {VisualizationEvent} event\n     * @returns {EventAction[]} List of action(s)\n     */\n    handle: EventHandle<Payload, ResetTokensEvent[]> = () => {\n        return Promise.resolve([\n            {\n                type: 'resetTokens',\n                payload: {\n                    namespaces: this.tokenNamespaces,\n                    tokens: this.tokenNames,\n                },\n            },\n        ]);\n    };\n}\n\nexport default ResetTokens;\n", "import type {\n    EHRequired,\n    EventCanHandle,\n    EventHandle,\n    SwitchToTabEvent,\n    SwitchToTabOptions,\n} from '@splunk/dashboard-types';\n\nimport { isAcceptedEvent, isEventAllowed } from './utils/events';\nimport { coalesceOptionsArray } from './utils/coalesceOptionsArray';\n\nclass SwitchToTab\n    implements EHRequired<Record<string, never>, SwitchToTabEvent[]>\n{\n    private readonly options: SwitchToTabOptions;\n\n    private readonly events: string[];\n\n    private readonly fields: string[];\n\n    /**\n     * A configuration object is passed to the handler\n     * @constructor\n     * @param {Object} options\n     */\n    constructor(options: SwitchToTabOptions = {}) {\n        this.options = options;\n        this.events = coalesceOptionsArray(options.events);\n        this.fields = coalesceOptionsArray(options.fields);\n    }\n\n    /**\n     * Determines if the custom event handler is designed to convert the event\n     * @method canHandle\n     * @param {VisualizationEvent} event\n     * @returns {Boolean} true if the event handler will convert the event\n     */\n    canHandle: EventCanHandle = (event) => {\n        const fieldName = (event.payload as Record<string, string>)?.name;\n        return (\n            event &&\n            isEventAllowed(event) &&\n            this.options &&\n            !!this.options.tabId &&\n            // check for type support\n            isAcceptedEvent({ value: event.type, supported: this.events }) &&\n            // check for field support\n            isAcceptedEvent({ value: fieldName, supported: this.fields })\n        );\n    };\n\n    /**\n     * Convert the event payload into a list of actionable tasks\n     * @method handle\n     * @param {VisualizationEvent} event\n     * @returns {Array} List of action(s)\n     */\n    handle: EventHandle<Record<string, never>, SwitchToTabEvent[]> = () => {\n        return Promise.resolve([\n            {\n                type: 'switchToTab',\n                payload: {\n                    tabId: this.options.tabId,\n                },\n            },\n        ]);\n    };\n}\n\nexport default SwitchToTab;\n", "import type {\n    EHRequired,\n    EventCanHandle,\n    EventHandle,\n    SetTokenEvent,\n    SetTimeRangeOptions,\n} from '@splunk/dashboard-types';\nimport { DEFAULT_TOKEN_NAMESPACE } from '@splunk/dashboard-utils';\nimport { isRangeEventAllowed } from './utils/events';\n\ntype Payload = Record<string, unknown>;\n\n/**\n * Event handler which reuses the existing setToken logic to set time range tokens given an interaction\n */\nclass SetTimeRange\n    implements EHRequired<{ payload: Payload }, SetTokenEvent[]>\n{\n    private readonly options: Partial<SetTimeRangeOptions>;\n\n    private readonly namespace: string;\n\n    /**\n     * A configuration object is passed to the handler\n     * @constructor\n     * @param {Object} options\n     */\n    constructor(options: Partial<SetTimeRangeOptions>) {\n        this.options = options;\n        this.namespace = options.tokenNamespace ?? DEFAULT_TOKEN_NAMESPACE;\n    }\n\n    /**\n     * Determines if the custom event handler is designed to convert the event\n     * @method canHandle\n     * @param {VisualizationEvent} event\n     * @returns {Boolean} true if the event handler will convert the event\n     */\n    canHandle: EventCanHandle<{ payload: Payload }> = (event) => {\n        if (!this.options.token) {\n            return false;\n        }\n\n        const { startXValue, endXValue } = event.payload ?? {};\n        return (\n            isRangeEventAllowed(event) &&\n            typeof startXValue !== 'undefined' &&\n            typeof endXValue !== 'undefined'\n        );\n    };\n\n    /**\n     * Convert the event payload into a list of actionable tasks\n     * @method handle\n     * @param {VisualizationEvent} event\n     * @returns {SetTokenEvent[]} List of action(s)\n     */\n    handle: EventHandle<Payload, SetTokenEvent[]> = (event) => {\n        const { startXValue, endXValue } = event.payload;\n        return Promise.resolve([\n            {\n                type: 'setToken',\n                payload: {\n                    namespace: this.namespace,\n                    tokens: {\n                        [`${this.options.token}.earliest`]: String(startXValue),\n                        [`${this.options.token}.latest`]: String(endXValue),\n                    },\n                    submit: true,\n                },\n            },\n        ]);\n    };\n}\n\nexport default SetTimeRange;\n"],
  "mappings": "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",
  "names": ["__toESM", "_a"]
}
