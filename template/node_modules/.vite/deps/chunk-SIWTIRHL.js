import __buffer_polyfill from 'vite-plugin-node-polyfills/shims/buffer'
globalThis.Buffer = globalThis.Buffer || __buffer_polyfill
import __global_polyfill from 'vite-plugin-node-polyfills/shims/global'
globalThis.global = globalThis.global || __global_polyfill
import __process_polyfill from 'vite-plugin-node-polyfills/shims/process'
globalThis.process = globalThis.process || __process_polyfill

import {
  require_dashboard_utils
} from "./chunk-XH2XD4WE.js";
import {
  __commonJS,
  __toESM,
  require_dist,
  require_dist2,
  require_dist3
} from "./chunk-2RF6DQJU.js";

// node_modules/@splunk/dashboard-event-handlers/index.js
var require_dashboard_event_handlers = __commonJS({
  "node_modules/@splunk/dashboard-event-handlers/index.js"(exports, module) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    var __create = Object.create;
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __getProtoOf = Object.getPrototypeOf;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
    var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
      // If the importer is in node compatibility mode or this is not an ESM
      // file that has been converted to a CommonJS file using a Babel-
      // compatible transform (i.e. "__esModule" has not been set), then set
      // "default" to the CommonJS "module.exports" for node compatibility.
      isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
      mod
    ));
    var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export(src_exports, {
      CustomUrlDrilldown: () => CustomUrlDrilldown_default,
      ResetTokens: () => ResetTokens_default,
      SetTimeRange: () => SetTimeRange_default,
      SetToken: () => SetToken_default,
      SwitchToTab: () => SwitchToTab_default,
      isAcceptedEvent: () => isAcceptedEvent,
      isEventAllowed: () => isEventAllowed,
      isRangeEventAllowed: () => isRangeEventAllowed
    });
    module.exports = __toCommonJS(src_exports);
    var isRangeEventAllowed = (event) => event.type === "range.select";
    var isEventAllowed = (event) => event.type.endsWith(".click") || event.type === "input.change";
    var isAcceptedEvent = ({
      value = "",
      supported
    }) => supported.includes("any") || supported.includes(value);
    var coalesceOptionsArray = (array) => Array.isArray(array) && array.length > 0 ? array : ["any"];
    var CustomUrlDrilldown = class {
      /**
       * A configuration object is passed to the handler
       * @constructor
       * @param {Object} options
       */
      constructor(options = {}) {
        this.canHandle = (event) => {
          var _a;
          const fieldName = (_a = event.payload) == null ? void 0 : _a.name;
          return event && isEventAllowed(event) && this.options && !!this.options.url && // check for type support
          isAcceptedEvent({ value: event.type, supported: this.events }) && // check for field support
          isAcceptedEvent({ value: fieldName, supported: this.fields });
        };
        this.handle = () => {
          return Promise.resolve([
            {
              type: "linkTo",
              payload: {
                url: this.options.url,
                newTab: this.options.newTab
              }
            }
          ]);
        };
        this.options = options;
        this.events = coalesceOptionsArray(options.events);
        this.fields = coalesceOptionsArray(options.fields);
      }
    };
    var CustomUrlDrilldown_default = CustomUrlDrilldown;
    var dashboard_utils_exports = {};
    __export(dashboard_utils_exports, {
      default: () => dashboard_utils_default
    });
    var defaultImport = __toESM2(require_dashboard_utils());
    __reExport(dashboard_utils_exports, require_dashboard_utils());
    var dashboard_utils_default = "default" in defaultImport ? defaultImport.default : defaultImport;
    var SetToken = class {
      /**
       * A configuration object is passed to the handler
       * @constructor
       * @param {Object} options
       */
      constructor(options) {
        this.canHandle = (event) => {
          var _a2;
          const fieldName = (_a2 = event.payload) == null ? void 0 : _a2.name;
          return isEventAllowed(event) && this.areTokensValid(event.payload) && // check for type support
          isAcceptedEvent({ value: event.type, supported: this.events }) && // check for field support
          isAcceptedEvent({ value: fieldName, supported: this.fields });
        };
        this.handle = (event) => {
          return Promise.resolve([
            {
              type: "setToken",
              payload: {
                namespace: this.options.tokenNamespace || dashboard_utils_exports.DEFAULT_TOKEN_NAMESPACE,
                tokens: this.getTokenValuesFromPayload(event.payload),
                submit: true
              }
            }
          ]);
        };
        var _a;
        this.options = options;
        this.events = coalesceOptionsArray(options.events);
        this.fields = coalesceOptionsArray(options.fields);
        const { key, token } = options;
        if (key && token) {
          (0, dashboard_utils_exports.deprecated)(
            "Using a single token option is deprecated. Please use the tokens option. `tokens: [{ key, token }]`"
          );
          this.tokens = [
            {
              key,
              token
            }
          ];
        } else {
          this.tokens = (_a = options.tokens) != null ? _a : [];
        }
      }
      // a token is valid if there is a non undefined value in its payload[key] or value
      areTokensValid(payload) {
        if (this.tokens.length < 1) {
          return false;
        }
        return Object.values(this.getTokenValuesFromPayload(payload)).some(
          (val) => val !== void 0
        );
      }
      getTokenValuesFromPayload(payload) {
        const tokenValuesMap = {};
        this.tokens.forEach(({ token, key, value }) => {
          if (key !== void 0 && payload[key] !== void 0) {
            tokenValuesMap[token] = payload[key];
          } else if (value !== void 0) {
            tokenValuesMap[token] = value;
          }
        });
        return tokenValuesMap;
      }
    };
    var SetToken_default = SetToken;
    var ResetTokens = class {
      /**
       * A configuration object is passed to the handler
       * @constructor
       * @param {Object} options
       */
      constructor(options) {
        this.canHandle = (event) => {
          return isEventAllowed(event) || isRangeEventAllowed(event);
        };
        this.handle = () => {
          return Promise.resolve([
            {
              type: "resetTokens",
              payload: {
                namespaces: this.tokenNamespaces,
                tokens: this.tokenNames
              }
            }
          ]);
        };
        var _a, _b;
        this.tokenNames = (_a = options == null ? void 0 : options.tokenNames) != null ? _a : [];
        this.tokenNamespaces = (_b = options == null ? void 0 : options.tokenNamespaces) != null ? _b : [];
      }
    };
    var ResetTokens_default = ResetTokens;
    var SwitchToTab = class {
      /**
       * A configuration object is passed to the handler
       * @constructor
       * @param {Object} options
       */
      constructor(options = {}) {
        this.canHandle = (event) => {
          var _a;
          const fieldName = (_a = event.payload) == null ? void 0 : _a.name;
          return event && isEventAllowed(event) && this.options && !!this.options.tabId && // check for type support
          isAcceptedEvent({ value: event.type, supported: this.events }) && // check for field support
          isAcceptedEvent({ value: fieldName, supported: this.fields });
        };
        this.handle = () => {
          return Promise.resolve([
            {
              type: "switchToTab",
              payload: {
                tabId: this.options.tabId
              }
            }
          ]);
        };
        this.options = options;
        this.events = coalesceOptionsArray(options.events);
        this.fields = coalesceOptionsArray(options.fields);
      }
    };
    var SwitchToTab_default = SwitchToTab;
    var SetTimeRange = class {
      /**
       * A configuration object is passed to the handler
       * @constructor
       * @param {Object} options
       */
      constructor(options) {
        this.canHandle = (event) => {
          var _a2;
          if (!this.options.token) {
            return false;
          }
          const { startXValue, endXValue } = (_a2 = event.payload) != null ? _a2 : {};
          return isRangeEventAllowed(event) && typeof startXValue !== "undefined" && typeof endXValue !== "undefined";
        };
        this.handle = (event) => {
          const { startXValue, endXValue } = event.payload;
          return Promise.resolve([
            {
              type: "setToken",
              payload: {
                namespace: this.namespace,
                tokens: {
                  [`${this.options.token}.earliest`]: String(startXValue),
                  [`${this.options.token}.latest`]: String(endXValue)
                },
                submit: true
              }
            }
          ]);
        };
        var _a;
        this.options = options;
        this.namespace = (_a = options.tokenNamespace) != null ? _a : dashboard_utils_exports.DEFAULT_TOKEN_NAMESPACE;
      }
    };
    var SetTimeRange_default = SetTimeRange;
  }
});

export {
  require_dashboard_event_handlers
};
//# sourceMappingURL=chunk-SIWTIRHL.js.map
