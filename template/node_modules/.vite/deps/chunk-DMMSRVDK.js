import __buffer_polyfill from 'vite-plugin-node-polyfills/shims/buffer'
globalThis.Buffer = globalThis.Buffer || __buffer_polyfill
import __global_polyfill from 'vite-plugin-node-polyfills/shims/global'
globalThis.global = globalThis.global || __global_polyfill
import __process_polyfill from 'vite-plugin-node-polyfills/shims/process'
globalThis.process = globalThis.process || __process_polyfill

import {
  require_dashboard_utils
} from "./chunk-XH2XD4WE.js";
import {
  require_i18n
} from "./chunk-SFZFMFKO.js";
import {
  require_lodash
} from "./chunk-FUC7W543.js";
import {
  __commonJS,
  __toESM,
  require_dist,
  require_dist2,
  require_dist3
} from "./chunk-2RF6DQJU.js";

// node_modules/@splunk/datasource-utils/index.js
var require_datasource_utils = __commonJS({
  "node_modules/@splunk/datasource-utils/index.js"(exports, module) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    var __create = Object.create;
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __getOwnPropSymbols = Object.getOwnPropertySymbols;
    var __getProtoOf = Object.getPrototypeOf;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __propIsEnum = Object.prototype.propertyIsEnumerable;
    var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
    var __spreadValues = (a, b) => {
      for (var prop in b || (b = {}))
        if (__hasOwnProp.call(b, prop))
          __defNormalProp(a, prop, b[prop]);
      if (__getOwnPropSymbols)
        for (var prop of __getOwnPropSymbols(b)) {
          if (__propIsEnum.call(b, prop))
            __defNormalProp(a, prop, b[prop]);
        }
      return a;
    };
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
    var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
      // If the importer is in node compatibility mode or this is not an ESM
      // file that has been converted to a CommonJS file using a Babel-
      // compatible transform (i.e. "__esModule" has not been set), then set
      // "default" to the CommonJS "module.exports" for node compatibility.
      isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
      mod
    ));
    var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export(src_exports, {
      DS_STATUS: () => DS_STATUS,
      DataSet: () => DataSet,
      createBaseChainModel: () => createBaseChainModel,
      createPostSearchQueryArray: () => createPostSearchQueryArray,
      extractMetadata: () => extractMetadata,
      findInitialRequestParams: () => findInitialRequestParams,
      formatData: () => formatData,
      generateSPL2ViewQuery: () => generateSPL2ViewQuery,
      getAppFromNamespace: () => getAppFromNamespace,
      getBaseDataSourceId: () => getBaseDataSourceId,
      getBaseTime: () => getBaseTime,
      getChainDataSources: () => getChainDataSources,
      getCompleteSearchQuery: () => getCompleteSearchQuery,
      getCompleteSearchQueryAndParameters: () => getCompleteSearchQueryAndParameters,
      getDataSet: () => getDataSet,
      getMeta: () => getMeta,
      getParentDataSource: () => getParentDataSource,
      getPrimaryDataSet: () => getPrimaryDataSet,
      getPrimaryMeta: () => getPrimaryMeta,
      getPrimaryRequestParams: () => getPrimaryRequestParams,
      getRequestParams: () => getRequestParams,
      getSharingFromNamespace: () => getSharingFromNamespace,
      isBaseDataSource: () => isBaseDataSource,
      isChainDataSource: () => isChainDataSource,
      mergeSearches: () => mergeSearches,
      stripPostProcessRequestParams: () => stripPostProcessRequestParams
    });
    module.exports = __toCommonJS(src_exports);
    var lodash_exports = {};
    __export(lodash_exports, {
      default: () => lodash_default
    });
    var defaultImport = __toESM2(require_lodash());
    __reExport(lodash_exports, require_lodash());
    var lodash_default = "default" in defaultImport ? defaultImport.default : defaultImport;
    var DataSet = class _DataSet {
      /**
       * @constructor
       * @param {Field[]} [fields= []] List of field name or field objects
       * @param {ColumnValue[][]} [columns=[]] List of column values related to fields
       * @returns DataSet
       */
      constructor(fields = [], columns = []) {
        this.fields = fields.map((field) => {
          if ((0, lodash_exports.isString)(field)) {
            return {
              name: field
            };
          }
          return field;
        });
        this.columns = columns;
      }
      /**
       * Returns a empty Dataset
       *
       * Examples:
       * ```js
       * const empty = DataSet.empty();
       * ```
       * @returns {DataSet} DataSet
       * @public
       */
      static empty() {
        return new _DataSet();
      }
      /**
       * Construct a Dataset with data in json array format
       *
       * Examples:
       * ```js
       *  const dataset = DataSet.fromJSONArray(
       *     [{ name: 'x' }, { name: 'y' }, { name: 'z' }],
       *     [{ x: 'a', y: 4, z: 70 }, { x: 'b', y: 5, z: 80 }, { x: 'c', y: 6, z: 90 }]
       *  );
       * ```
       * @param {FieldObj[]} [fields=[]] List of objects containing field names
       * @param {RowItem[]} [results=[]] List of objects containing results for each field
       * @returns {DataSet}
       * @public
       */
      static fromJSONArray(fields = [], results = []) {
        let fieldList = fields;
        if (fieldList == null || fieldList.length === 0) {
          if (results.length > 0) {
            const rowSample = results[0];
            fieldList = Object.keys(rowSample).map((field) => ({
              name: field
            }));
          } else {
            fieldList = [];
          }
        }
        const columns = fieldList.map(
          ({ name }) => results.reduce((col, row) => {
            col.push(row[name] === void 0 ? null : row[name]);
            return col;
          }, [])
        );
        return new _DataSet(fieldList, columns);
      }
      /**
       * Construct a Dataset with data in json columns format
       *
       * Examples:
       * ```js
       *  const dataset = DataSet.fromJSONCols(
       *     [{ name: 'x' }, { name: 'y' }, { name: 'z' }],
       *     [['a', 'b', 'c'], [4, 5, 6], [70, 80, 90]];
       *  );
       * ```
       * @param {Field[]} [fields=[]] List of fields
       * @param {ColumnValue[][]} [columns=[]] list of column values
       * @returns {DataSet}
       * @public
       */
      static fromJSONCols(fields = [], columns = []) {
        return new _DataSet(fields, columns);
      }
      /**
       * Construct a Dataset with data in json rows format
       *
       * Examples:
       * ```js
       *  const dataset = DataSet.fromJSONRows(
       *     [{ name: 'x' }, { name: 'y' }, { name: 'z' }],
       *     [['a', 4, 70], ['b', 5, 80], ['c', 6, 90]];
       *  );
       * ```
       * @param {Field[]} [fields=[]] List of fields
       * @param {ColumnValue[][]} [columns=[]] list of column values
       * @returns {DataSet}
       * @public
       */
      static fromJSONRows(fields = [], rows = []) {
        return new _DataSet(fields, (0, lodash_exports.zip)(...rows));
      }
      /**
       * Convert data to json array
       * @return {JSONArray} data in json array format
       * @public
       */
      toJSONArray() {
        return {
          fields: this.fields,
          results: (0, lodash_exports.zip)(...this.columns).map(
            (row) => (0, lodash_exports.zipObject)(
              this.fields.map((field) => field.name),
              row
            )
          )
        };
      }
      /**
       * Convert data to json columns
       * @return {JSONCols} data in json columns format
       * @public
       */
      toJSONCols() {
        const { fields, columns } = this;
        return { fields, columns };
      }
      /**
       * Convert data to json rows
       * @return {JSONRows} data in json rows format
       * @public
       */
      toJSONRows() {
        return {
          fields: this.fields,
          rows: (0, lodash_exports.zip)(...this.columns)
        };
      }
      /**
       * List all fields
       * @return {FieldObj[]} fields array
       * @public
       */
      getFields() {
        return this.fields;
      }
      /**
       * List data columns
       * @return {Object} columns array
       * @public
       */
      getColumns() {
        return this.columns;
      }
      /**
       *
       * @param {String} fieldName
       * @return {ColumnValue[]} column data
       * @public
       */
      getColumnByField(fieldName) {
        const index = (0, lodash_exports.findIndex)(this.fields, ({ name }) => name === fieldName);
        return this.columns[index];
      }
      /**
       *
       * @param {String} fieldName
       * @return {Boolean}
       * @public
       */
      hasField(fieldName) {
        return (0, lodash_exports.findIndex)(this.fields, ({ name }) => name === fieldName) !== -1;
      }
      /**
       * @return {Boolean} true if DataSet has no data
       * @public
       */
      isEmpty() {
        return this.columns.length === 0;
      }
      /**
       *
       * @param {DataSet} dataSet DataSet to compare
       * @return {Boolean} true if another dataset is equals to current one
       * @public
       */
      equals(dataSet) {
        return (0, lodash_exports.isEqual)(this.fields, dataSet.fields) && (0, lodash_exports.isEqual)(this.columns, dataSet.columns);
      }
      /**
       * Returns a slice of the dataset, useful for pagination.
       * @param options {Object}
       * @param options.count {Number} number of rows
       * @param options.offset {Number} starting row index
       * @returns {DataSet}
       * @public
       */
      getPage({
        count = 0,
        offset = 0
      }) {
        const end = count <= 0 ? void 0 : offset + count;
        return _DataSet.fromJSONCols(
          this.getFields(),
          this.getColumns().map((column) => column.slice(offset, end))
        );
      }
      /**
       * Get total number of rows. Note this is not affected by the pagination.
       * @public
       */
      getTotalCount() {
        var _a, _b;
        return (_b = (_a = this.columns[0]) == null ? void 0 : _a.length) != null ? _b : 0;
      }
    };
    var dashboard_utils_exports = {};
    __export(dashboard_utils_exports, {
      default: () => dashboard_utils_default
    });
    var defaultImport2 = __toESM2(require_dashboard_utils());
    __reExport(dashboard_utils_exports, require_dashboard_utils());
    var dashboard_utils_default = "default" in defaultImport2 ? defaultImport2.default : defaultImport2;
    var isBaseDataSource = (dataSourceId, definition = {}) => {
      const dataSourceDef = definition[dataSourceId];
      if (!dataSourceDef || (0, lodash_exports.get)(dataSourceDef, ["options", "extend"])) {
        return false;
      }
      return (0, lodash_exports.some)(
        Object.values(definition),
        (dsDef) => (0, lodash_exports.get)(dsDef, ["options", "extend"]) === dataSourceId
      );
    };
    var isChainDataSource = (dataSourceId, definition = {}) => {
      const dataSourceDef = definition[dataSourceId];
      if (!dataSourceDef) {
        return false;
      }
      return !!(0, lodash_exports.get)(dataSourceDef, ["options", "extend"]);
    };
    var getChainDataSources = (dataSourceId, definition = {}) => {
      return (0, lodash_exports.pickBy)(
        definition,
        (dataSourceDef) => (0, lodash_exports.get)(dataSourceDef, ["options", "extend"]) === dataSourceId
      );
    };
    var getParentDataSource = (dataSourceId, definition = {}) => {
      const extend = (0, lodash_exports.get)(definition, [
        dataSourceId,
        "options",
        "extend"
      ]);
      return definition[extend];
    };
    var mergeSearches = (base = "", sub = "") => [base.replace(/\s*\|\s*$/g, ""), sub.replace(/^\s*\|\s*/g, "")].join(" | ");
    var createPostSearchQueryArray = (baseDataSourceId, definition = {}, parentQuery = "", {
      shouldPreRunChainSearchesWithTokens = true
    } = {}) => {
      const baseDataSourceDef = definition[baseDataSourceId];
      if (!baseDataSourceDef) {
        return [];
      }
      const results = [];
      const chainDataSources = getChainDataSources(baseDataSourceId, definition);
      (0, lodash_exports.each)(chainDataSources, (chainDataSourceDef, chainDataSourceId) => {
        var _a;
        const query = (0, lodash_exports.get)(chainDataSourceDef, ["options", "query"]);
        if (!shouldPreRunChainSearchesWithTokens && ((_a = chainDataSourceDef.usageMeta) == null ? void 0 : _a.usesTokens)) {
          return;
        }
        const fullQuery = parentQuery ? mergeSearches(parentQuery, query) : query;
        results.push(
          fullQuery,
          ...createPostSearchQueryArray(
            chainDataSourceId,
            definition,
            fullQuery,
            { shouldPreRunChainSearchesWithTokens }
          )
        );
      });
      return (0, lodash_exports.uniq)(results);
    };
    var createBaseChainModel = (baseDataSourceId, definition = {}, result = {}) => {
      result[baseDataSourceId] = definition[baseDataSourceId];
      const chainDataSources = getChainDataSources(baseDataSourceId, definition);
      Object.keys(chainDataSources).forEach(
        (chainDataSourceId) => createBaseChainModel(chainDataSourceId, definition, result)
      );
      return result;
    };
    var getBaseDataSourceId = (dataSourceId, definition = {}) => {
      if (isBaseDataSource(dataSourceId, definition)) {
        return dataSourceId;
      }
      const extend = (0, lodash_exports.get)(definition, [dataSourceId, "options", "extend"]);
      return extend ? getBaseDataSourceId(extend, definition) : null;
    };
    var getCompleteSearchQuery = ({
      definition,
      dataSourceId,
      getMetaData,
      count = 0,
      submittedTokens
    }) => {
      const ds = definition.getDataSource(dataSourceId);
      const rawQuery = (0, lodash_exports.get)(ds, "type", "") === "ds.savedSearch" && getMetaData ? (0, lodash_exports.get)(getMetaData(dataSourceId), "savedSearchQuery", "") : (0, lodash_exports.get)(ds, "options.query", "");
      const query = submittedTokens ? (0, dashboard_utils_exports.replaceTokens)({
        value: rawQuery,
        tokens: submittedTokens
      }) : rawQuery;
      const parentDsId = (0, lodash_exports.get)(ds, "options.extend", "");
      return parentDsId && count < dashboard_utils_exports.MAX_CHAIN_LENGTH ? `${getCompleteSearchQuery({
        definition,
        dataSourceId: parentDsId,
        getMetaData,
        count: count + 1,
        submittedTokens
      })} 
| ${query.trim().replace(/^\|\s*/g, "")}` : query;
    };
    var getBaseTime = ({
      definition,
      dataSourceId,
      getMetaData
    }) => {
      var _a, _b, _c, _d, _e, _f, _g, _h;
      const defaultEarliest = "-24h@h";
      const defaultLatest = "now";
      if (!dataSourceId) {
        return {
          earliest: defaultEarliest,
          latest: defaultLatest
        };
      }
      let parentDsId = dataSourceId;
      let highestAncestorDsId = dataSourceId;
      let count = 0;
      while (parentDsId && count <= dashboard_utils_exports.MAX_CHAIN_LENGTH) {
        highestAncestorDsId = parentDsId;
        parentDsId = (0, lodash_exports.get)(
          definition.getDataSource(parentDsId),
          "options.extend",
          ""
        );
        count += 1;
      }
      const highestAncestorDs = definition.getDataSource(highestAncestorDsId);
      if (highestAncestorDs && highestAncestorDs.type === "ds.savedSearch" && getMetaData) {
        const { earliestTime, latestTime } = getMetaData(highestAncestorDsId);
        return {
          earliest: earliestTime || defaultEarliest,
          latest: latestTime || defaultLatest
        };
      }
      const baseSearchDefaultQueryParameters = (_b = (_a = definition.getDataSourceDefaultOptions(highestAncestorDsId)) == null ? void 0 : _a.queryParameters) != null ? _b : {};
      const baseSearchQueryParameters = (_d = (_c = highestAncestorDs == null ? void 0 : highestAncestorDs.options) == null ? void 0 : _c.queryParameters) != null ? _d : {};
      return {
        earliest: (_f = (_e = baseSearchQueryParameters.earliest) != null ? _e : baseSearchDefaultQueryParameters.earliest) != null ? _f : defaultEarliest,
        latest: (_h = (_g = baseSearchQueryParameters.latest) != null ? _g : baseSearchDefaultQueryParameters.latest) != null ? _h : defaultLatest
      };
    };
    var getCompleteSearchQueryAndParameters = ({
      definition,
      dataSourceId,
      getMetaData,
      submittedTokens
    }) => {
      if (!dataSourceId) {
        return {};
      }
      const queryParameters = getBaseTime({
        definition,
        dataSourceId,
        getMetaData
      });
      return {
        query: getCompleteSearchQuery({
          definition,
          dataSourceId,
          getMetaData,
          submittedTokens
        }),
        queryParameters: submittedTokens ? (0, dashboard_utils_exports.replaceTokensForObject)({
          value: queryParameters,
          tokens: submittedTokens
        }) : queryParameters
      };
    };
    var emptyInitialRequestParams = {};
    var normalizeRequestParamsFromConsumerModule = (bindingType, consumerModule) => {
      var _a, _b, _c;
      if (consumerModule == null) {
        return emptyInitialRequestParams;
      }
      let initialRequestParams = (_c = (_b = (_a = consumerModule.config) == null ? void 0 : _a.dataContract) == null ? void 0 : _b.initialRequestParams) == null ? void 0 : _c[bindingType];
      if (!initialRequestParams) {
        initialRequestParams = consumerModule.initialRequestParams || emptyInitialRequestParams;
      }
      return initialRequestParams;
    };
    var findInitialRequestParams = ({
      bindingType = "primary",
      consumerModule,
      options = {}
    } = {}) => {
      const initialRequestParams = normalizeRequestParamsFromConsumerModule(
        bindingType,
        consumerModule
      );
      if (typeof initialRequestParams === "function") {
        return initialRequestParams(options);
      }
      return initialRequestParams;
    };
    var formatData = (data) => {
      if (data == null) {
        return DataSet.empty().toJSONCols();
      }
      if (data.constructor === DataSet) {
        return data.toJSONCols();
      }
      if ((data == null ? void 0 : data.fields) && (data == null ? void 0 : data.columns)) {
        return data;
      }
      return null;
    };
    function getDataSet(vizProps, dataSourceType = "primary") {
      var _a, _b;
      const data = (_b = (_a = vizProps.dataSources) == null ? void 0 : _a[dataSourceType]) == null ? void 0 : _b.data;
      return data ? DataSet.fromJSONCols(data.fields, data.columns) : null;
    }
    function getPrimaryDataSet(vizProps) {
      return getDataSet(vizProps, "primary");
    }
    function getRequestParams(vizProps, dataSourceType = "primary") {
      var _a, _b;
      return (_b = (_a = vizProps.dataSources) == null ? void 0 : _a[dataSourceType]) == null ? void 0 : _b.requestParams;
    }
    function getPrimaryRequestParams(vizProps) {
      return getRequestParams(vizProps, "primary");
    }
    var emptyMeta = {};
    function getMeta(vizProps, dataSourceType = "primary") {
      var _a, _b, _c;
      return (_c = (_b = (_a = vizProps.dataSources) == null ? void 0 : _a[dataSourceType]) == null ? void 0 : _b.meta) != null ? _c : emptyMeta;
    }
    function getPrimaryMeta(vizProps) {
      return getMeta(vizProps, "primary");
    }
    var extractMetadata = (entry) => {
      var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
      return {
        author: entry == null ? void 0 : entry.author,
        updated: entry == null ? void 0 : entry.updated,
        app: (_a = entry == null ? void 0 : entry.acl) == null ? void 0 : _a.app,
        sharing: (_b = entry == null ? void 0 : entry.acl) == null ? void 0 : _b.sharing,
        isScheduled: (_c = entry == null ? void 0 : entry.content) == null ? void 0 : _c.is_scheduled,
        nextScheduledTime: (_d = entry == null ? void 0 : entry.content) == null ? void 0 : _d.next_scheduled_time,
        savedSearchQuery: (_e = entry == null ? void 0 : entry.content) == null ? void 0 : _e.search,
        earliestTime: (_f = entry == null ? void 0 : entry.content) == null ? void 0 : _f["dispatch.earliest_time"],
        latestTime: (_g = entry == null ? void 0 : entry.content) == null ? void 0 : _g["dispatch.latest_time"],
        alertType: (_h = entry == null ? void 0 : entry.content) == null ? void 0 : _h.alert_type,
        alertTrack: (_i = entry == null ? void 0 : entry.content) == null ? void 0 : _i["alert.track"],
        actions: (_j = entry == null ? void 0 : entry.content) == null ? void 0 : _j.actions
      };
    };
    var DS_STATUS = {
      QUEUED: "queued",
      PARSING: "parsing",
      RUNNING: "running",
      PAUSE: "pause",
      FINALIZING: "finalizing",
      FAILED: "failed",
      STOPPED: "stopped",
      DONE: "done",
      CANCELED: "canceled",
      REFRESHING: "refreshing"
    };
    var i18n_exports = {};
    __export(i18n_exports, {
      default: () => i18n_default
    });
    var defaultImport3 = __toESM2(require_i18n());
    __reExport(i18n_exports, require_i18n());
    var i18n_default = "default" in defaultImport3 ? defaultImport3.default : defaultImport3;
    var APPS_REGEX = /^(~\.|(\w+\.)+)apps(\.[\w-]+){1,2}$/;
    var PRIVATE_REGEX = /^(~\.|(\w+\.)+)users\.[\w-]+\.apps(\.[\w-]+){1,2}$/;
    var generateSPL2ViewQuery = (view, namespace) => {
      const trimmedView = view.trim();
      const trimmedNamespace = namespace == null ? void 0 : namespace.trim();
      if (!trimmedNamespace) {
        return `| @spl2 | from ${trimmedView}`;
      }
      return `| @spl2 | from ${trimmedNamespace}.${trimmedView}`;
    };
    var stripPostProcessRequestParams = (requestParams) => {
      const requestParamsWithoutPostprocess = __spreadValues({}, requestParams);
      delete requestParamsWithoutPostprocess.search;
      return requestParamsWithoutPostprocess;
    };
    var getSharingFromNamespace = (namespace) => {
      if (PRIVATE_REGEX.test(namespace)) {
        return (0, i18n_exports._)("Private");
      }
      if (APPS_REGEX.test(namespace)) {
        return (0, i18n_exports._)("App");
      }
      return (0, i18n_exports._)("Custom");
    };
    var getAppFromNamespace = (namespace) => {
      if (APPS_REGEX.test(namespace) || PRIVATE_REGEX.test(namespace)) {
        const namespaceArray = namespace.split(".apps.");
        return namespaceArray[namespaceArray.length - 1].split(".")[0];
      }
      return null;
    };
  }
});

export {
  require_datasource_utils
};
//# sourceMappingURL=chunk-DMMSRVDK.js.map
