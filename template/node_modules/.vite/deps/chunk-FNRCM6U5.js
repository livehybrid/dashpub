import __buffer_polyfill from 'vite-plugin-node-polyfills/shims/buffer'
globalThis.Buffer = globalThis.Buffer || __buffer_polyfill
import __global_polyfill from 'vite-plugin-node-polyfills/shims/global'
globalThis.global = globalThis.global || __global_polyfill
import __process_polyfill from 'vite-plugin-node-polyfills/shims/process'
globalThis.process = globalThis.process || __process_polyfill

import {
  require_dashboard_ui
} from "./chunk-PKQHJYV2.js";
import {
  require_Line,
  require_PresetPalettes,
  require_configUtils2 as require_configUtils
} from "./chunk-EZMYLMZB.js";
import {
  require_Options,
  require_schemaUtils
} from "./chunk-A5UOW6LZ.js";
import {
  core_esm_exports,
  init_core_esm,
  init_sortable_esm,
  init_utilities_esm,
  require_dashboard_definition,
  require_dashboard_telemetry,
  require_dist as require_dist4,
  require_dist2 as require_dist5,
  sortable_esm_exports,
  utilities_esm_exports
} from "./chunk-AIIXJTVL.js";
import {
  require_IconProvider,
  require_SVG
} from "./chunk-2FMSEQJ6.js";
import {
  require_themes
} from "./chunk-CHFSHVDX.js";
import {
  init_styled_components_esm,
  styled_components_esm_exports
} from "./chunk-3A7H6U64.js";
import {
  require_prop_types
} from "./chunk-QNBKYQLU.js";
import {
  init_memoize_one_esm,
  memoize_one_esm_exports,
  require_dashboard_utils
} from "./chunk-XH2XD4WE.js";
import {
  require_format
} from "./chunk-6CXBXVKR.js";
import {
  require_i18n
} from "./chunk-SFZFMFKO.js";
import {
  require_lodash
} from "./chunk-FUC7W543.js";
import {
  require_react
} from "./chunk-ACNULIE3.js";
import {
  __commonJS,
  __toCommonJS,
  __toESM,
  require_dist,
  require_dist2,
  require_dist3
} from "./chunk-2RF6DQJU.js";

// node_modules/@splunk/react-icons/Plus.js
var require_Plus = __commonJS({
  "node_modules/@splunk/react-icons/Plus.js"(exports, module) {
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    (() => {
      "use strict";
      var e = {};
      (() => {
        e.n = (r2) => {
          var t2 = r2 && r2.__esModule ? (
            /******/
            () => r2["default"]
          ) : () => r2;
          e.d(t2, {
            a: t2
          });
          return t2;
        };
      })();
      (() => {
        e.d = (r2, t2) => {
          for (var n2 in t2) {
            if (e.o(t2, n2) && !e.o(r2, n2)) {
              Object.defineProperty(r2, n2, {
                enumerable: true,
                get: t2[n2]
              });
            }
          }
        };
      })();
      (() => {
        e.o = (e2, r2) => Object.prototype.hasOwnProperty.call(e2, r2);
      })();
      (() => {
        e.r = (e2) => {
          if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
            Object.defineProperty(e2, Symbol.toStringTag, {
              value: "Module"
            });
          }
          Object.defineProperty(e2, "__esModule", {
            value: true
          });
        };
      })();
      var r = {};
      e.r(r);
      e.d(r, {
        default: () => (
          /* binding */
          p
        )
      });
      const t = require_react();
      var n = e.n(t);
      const a = require_IconProvider();
      const o = require_SVG();
      var u = e.n(o);
      function l(e2, r2) {
        if (null == e2) return {};
        var t2, n2, a2 = i(e2, r2);
        if (Object.getOwnPropertySymbols) {
          var o2 = Object.getOwnPropertySymbols(e2);
          for (n2 = 0; n2 < o2.length; n2++) {
            t2 = o2[n2], -1 === r2.indexOf(t2) && {}.propertyIsEnumerable.call(e2, t2) && (a2[t2] = e2[t2]);
          }
        }
        return a2;
      }
      function i(e2, r2) {
        if (null == e2) return {};
        var t2 = {};
        for (var n2 in e2) {
          if ({}.hasOwnProperty.call(e2, n2)) {
            if (-1 !== r2.indexOf(n2)) continue;
            t2[n2] = e2[n2];
          }
        }
        return t2;
      }
      var c = /* @__PURE__ */ new Map();
      c.set("outlined", (function() {
        return n().createElement(n().Fragment, null, n().createElement("path", {
          d: "M13 5C13 4.44772 12.5523 4 12 4C11.4477 4 11 4.44772 11 5V11H5C4.44772 11 4 11.4477 4 12C4 12.5523 4.44772 13 5 13H11V19C11 19.5523 11.4477 20 12 20C12.5523 20 13 19.5523 13 19V13H19C19.5523 13 20 12.5523 20 12C20 11.4477 19.5523 11 19 11H13V5Z"
        }));
      }));
      var f = ["default", "outlined"];
      var d = function e2(r2) {
        return f.indexOf(r2) >= 0;
      };
      var v = function e2(r2) {
        return r2 === "default" || r2 && !d(r2) ? "outlined" : r2;
      };
      var s = function e2(r2) {
        var o2 = r2.children, i2 = r2.variant, f2 = i2 === void 0 ? "default" : i2, d2 = l(r2, ["children", "variant"]);
        var s2 = v(f2);
        var p2 = "plus-".concat(s2);
        var y = (0, t.useContext)(a.IconContext);
        var b = c.get(s2);
        if (false) {
        }
        if (y && b) {
          var m = y.toRender, O = y.addIcon;
          O(p2, b());
          if (!m) {
            return null;
          }
        }
        return n().createElement(u(), d2, o2, y ? n().createElement("use", {
          href: "#".concat(p2)
        }) : !!b && b());
      };
      const p = s;
      module.exports = r;
    })();
  }
});

// node_modules/@splunk/dashboard-layouts/index.js
var require_dashboard_layouts = __commonJS({
  "node_modules/@splunk/dashboard-layouts/index.js"(exports, module) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    var __create = Object.create;
    var __defProp = Object.defineProperty;
    var __defProps = Object.defineProperties;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __getOwnPropSymbols = Object.getOwnPropertySymbols;
    var __getProtoOf = Object.getPrototypeOf;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __propIsEnum = Object.prototype.propertyIsEnumerable;
    var __typeError = (msg) => {
      throw TypeError(msg);
    };
    var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
    var __spreadValues = (a, b) => {
      for (var prop in b || (b = {}))
        if (__hasOwnProp.call(b, prop))
          __defNormalProp(a, prop, b[prop]);
      if (__getOwnPropSymbols)
        for (var prop of __getOwnPropSymbols(b)) {
          if (__propIsEnum.call(b, prop))
            __defNormalProp(a, prop, b[prop]);
        }
      return a;
    };
    var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
    var __objRest = (source, exclude) => {
      var target = {};
      for (var prop in source)
        if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
          target[prop] = source[prop];
      if (source != null && __getOwnPropSymbols)
        for (var prop of __getOwnPropSymbols(source)) {
          if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
            target[prop] = source[prop];
        }
      return target;
    };
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
    var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
      // If the importer is in node compatibility mode or this is not an ESM
      // file that has been converted to a CommonJS file using a Babel-
      // compatible transform (i.e. "__esModule" has not been set), then set
      // "default" to the CommonJS "module.exports" for node compatibility.
      isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
      mod
    ));
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
    var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
    var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
    var __async = (__this, __arguments, generator) => {
      return new Promise((resolve, reject) => {
        var fulfilled = (value) => {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        };
        var rejected = (value) => {
          try {
            step(generator.throw(value));
          } catch (e) {
            reject(e);
          }
        };
        var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
        step((generator = generator.apply(__this, __arguments)).next());
      });
    };
    var src_exports = {};
    __export(src_exports, {
      AbsoluteLayout: () => AbsoluteLayout_default,
      AbsoluteLayoutApi: () => AbsoluteLayoutApi,
      AbsoluteLayoutOptionsSchema: () => absoluteLayoutOptionsSchema_default,
      AbsoluteLayoutViewer: () => AbsoluteLayoutViewer_default,
      BaseLayoutApi: () => BaseLayoutApi,
      CLONE_LAYOUT_ITEMS_MSG_PANEL_TOO_SMALL: () => CLONE_LAYOUT_ITEMS_MSG_PANEL_TOO_SMALL,
      CommonLayoutOptionsSchema: () => commonLayoutOptionsSchema_default,
      ConnectedLine: () => ConnectedLine_default,
      ConnectedLineOptionsSchema: () => ConnectedLineOptionsSchema_default,
      EDGE_PREVIEW_DELAY_MS: () => EDGE_PREVIEW_DELAY_MS,
      EDGE_THICKNESS_PX: () => EDGE_THICKNESS_PX,
      GRID_PADDING_PX: () => GRID_PADDING_PX,
      GRID_SIZE_PX: () => GRID_SIZE_PX,
      GridLayout: () => GridLayout_default,
      GridLayoutApi: () => GridLayoutApi,
      GridLayoutOptionsSchema: () => gridLayoutOptionsSchema_default,
      GridLayoutViewer: () => GridLayoutViewer_default,
      ITEM_DROP_TARGET_PX: () => ITEM_DROP_TARGET_PX,
      InputLayout: () => InputLayoutViewer_default,
      MIN_HEIGHT_PX: () => MIN_HEIGHT_PX,
      MIN_WIDTH_PX: () => MIN_WIDTH_PX,
      PLACEHOLDER_SIZE_PX: () => PLACEHOLDER_SIZE_PX,
      SNAP_RANGE_PX: () => SNAP_RANGE_PX,
      VIZ_DEFAULT_HEIGHT_PX: () => VIZ_DEFAULT_HEIGHT_PX,
      VIZ_PREVIEW_DELAY_MS: () => VIZ_PREVIEW_DELAY_MS,
      absoluteLayoutOptions: () => absoluteLayoutOptions,
      gridLayoutOptions: () => gridLayoutOptions
    });
    module.exports = __toCommonJS2(src_exports);
    var react_exports = {};
    __export(react_exports, {
      default: () => react_default
    });
    var defaultImport = __toESM2(require_react());
    __reExport(react_exports, require_react());
    var react_default = "default" in defaultImport ? defaultImport.default : defaultImport;
    var lodash_exports = {};
    __export(lodash_exports, {
      default: () => lodash_default
    });
    var defaultImport2 = __toESM2(require_lodash());
    __reExport(lodash_exports, require_lodash());
    var lodash_default = "default" in defaultImport2 ? defaultImport2.default : defaultImport2;
    var dashboard_context_exports = {};
    __export(dashboard_context_exports, {
      default: () => dashboard_context_default
    });
    var defaultImport3 = __toESM2(require_dist5());
    __reExport(dashboard_context_exports, require_dist5());
    var dashboard_context_default = "default" in defaultImport3 ? defaultImport3.default : defaultImport3;
    var dashboard_definition_exports = {};
    __export(dashboard_definition_exports, {
      default: () => dashboard_definition_default
    });
    var defaultImport4 = __toESM2(require_dashboard_definition());
    __reExport(dashboard_definition_exports, require_dashboard_definition());
    var dashboard_definition_default = "default" in defaultImport4 ? defaultImport4.default : defaultImport4;
    var dashboard_ui_exports = {};
    __export(dashboard_ui_exports, {
      default: () => dashboard_ui_default
    });
    var defaultImport5 = __toESM2(require_dashboard_ui());
    __reExport(dashboard_ui_exports, require_dashboard_ui());
    var dashboard_ui_default = "default" in defaultImport5 ? defaultImport5.default : defaultImport5;
    var dashboard_utils_exports = {};
    __export(dashboard_utils_exports, {
      default: () => dashboard_utils_default
    });
    var defaultImport6 = __toESM2(require_dashboard_utils());
    __reExport(dashboard_utils_exports, require_dashboard_utils());
    var dashboard_utils_default = "default" in defaultImport6 ? defaultImport6.default : defaultImport6;
    var dashboard_state_exports = {};
    __export(dashboard_state_exports, {
      default: () => dashboard_state_default
    });
    var defaultImport7 = __toESM2(require_dist4());
    __reExport(dashboard_state_exports, require_dist4());
    var dashboard_state_default = "default" in defaultImport7 ? defaultImport7.default : defaultImport7;
    var styled_components_exports = {};
    __export(styled_components_exports, {
      default: () => styled_components_default
    });
    var defaultImport8 = __toESM2((init_styled_components_esm(), __toCommonJS(styled_components_esm_exports)));
    __reExport(styled_components_exports, (init_styled_components_esm(), __toCommonJS(styled_components_esm_exports)));
    var styled_components_default = "default" in defaultImport8 ? defaultImport8.default : defaultImport8;
    var themes_exports = {};
    __export(themes_exports, {
      default: () => themes_default
    });
    var defaultImport9 = __toESM2(require_themes());
    __reExport(themes_exports, require_themes());
    var themes_default = "default" in defaultImport9 ? defaultImport9.default : defaultImport9;
    var validImagePos = ({
      x,
      y,
      canvasWidth,
      canvasHeight
    }) => !!(x != null && Number.isInteger(x) && y != null && Number.isInteger(y) && x <= canvasWidth && y <= canvasHeight && x >= 0 && y >= 0);
    var validImageWidthHeight = (imageWidth = 1, imageHeight = 1) => !!(Number.isInteger(imageWidth) && Number.isInteger(imageHeight) && imageWidth > 0 && imageHeight > 0);
    var sizeTypes = ["cover", "contain", "auto", void 0];
    var invalidImageSizeType = (sizeType) => !sizeTypes.includes(sizeType);
    var getImageDimension = (0, lodash_exports.memoize)(
      (imgSrc) => {
        const img = new Image();
        try {
          img.src = imgSrc;
          img.style.position = "absolute";
          img.style.left = "-9999";
          img.style.visibility = "hidden";
          document.body.appendChild(img);
          const height = img.naturalHeight;
          const width = img.naturalWidth;
          return { width, height };
        } catch (e) {
          return { width: 0, height: 0 };
        } finally {
          if (document.body.contains(img)) {
            document.body.removeChild(img);
          }
        }
      }
    );
    var validateOpacity = (opacity) => {
      if (typeof opacity !== "number" || opacity > 1) {
        return 1;
      }
      if (opacity < 0) {
        return 0;
      }
      return opacity;
    };
    var validateImageXY = ({
      canvasWidth,
      canvasHeight,
      x,
      y
    }) => {
      if (!validImagePos({ x, y, canvasWidth, canvasHeight })) {
        dashboard_utils_exports.console.warn(
          `Invalid background image position, x: ${x} y: ${y}. Defaulting to x: 0, y: 0`
        );
        return [0, 0];
      }
      return [x, y];
    };
    var validateSizeType = ({
      w,
      h,
      sizeType
    }) => {
      if (typeof w !== "number" && typeof h !== "number" && (typeof sizeType !== "string" || invalidImageSizeType(sizeType))) {
        dashboard_utils_exports.console.warn(
          `Invalid background image sizeType, ${sizeType}. Defaulting to contain`
        );
        return "contain";
      }
      return sizeType;
    };
    var validateImageWH = ({ w, h }) => {
      if (validImageWidthHeight(w, h)) {
        return [w, h];
      }
      dashboard_utils_exports.console.warn(
        `Invalid background image width and height, w: ${w} h: ${h}. Defaulting to image original size`
      );
      return [w != null ? w : 0, h != null ? h : 0];
    };
    var validateBackgroundImage = ({
      backgroundImage = {},
      canvasWidth,
      canvasHeight
    }) => {
      var _a;
      if ((0, lodash_exports.isEmpty)(backgroundImage) || !backgroundImage.src) {
        return {
          src: backgroundImage.src,
          x: backgroundImage.x,
          y: backgroundImage.y,
          w: backgroundImage.w,
          h: backgroundImage.h,
          sizeType: backgroundImage.sizeType,
          opacity: (_a = backgroundImage.opacity) != null ? _a : 1
        };
      }
      const opacity = validateOpacity(backgroundImage.opacity);
      const [x, y] = validateImageXY({
        canvasWidth,
        canvasHeight,
        x: backgroundImage.x,
        y: backgroundImage.y
      });
      const sizeType = validateSizeType({
        w: backgroundImage.w,
        h: backgroundImage.h,
        sizeType: backgroundImage.sizeType
      });
      const [w, h] = validateImageWH({
        w: backgroundImage.w,
        h: backgroundImage.h
      });
      return { src: backgroundImage.src, x, y, w, h, sizeType, opacity };
    };
    var nextEdgeId = () => `edge_${(0, dashboard_utils_exports.uniqueId)()}`;
    var getNextEdgeId = () => {
      return nextEdgeId();
    };
    var getNodes = (layoutStructure) => {
      if (layoutStructure.length === 0) {
        return null;
      }
      const nodes = {};
      layoutStructure.forEach((viz) => {
        const { x, y, w, h } = viz.position;
        const corners = [
          { x, y },
          { x: x + w, y },
          { x, y: y + h },
          { x: x + w, y: y + h }
        ];
        corners.forEach((corner) => {
          if (nodes[corner.x] === void 0) {
            nodes[corner.x] = {};
          }
          if (nodes[corner.x][corner.y] === void 0) {
            nodes[corner.x][corner.y] = [];
          }
          nodes[corner.x][corner.y].push(viz);
        });
      });
      return nodes;
    };
    var isTopEdge = (edge) => edge.orientation === "horizontal" && edge.edgeStart.y === 0;
    var isBottomEdge = (edge, canvasHeight) => edge.orientation === "horizontal" && edge.edgeStart.y === canvasHeight;
    var isLeftEdge = (edge) => edge.orientation === "vertical" && edge.edgeStart.x === 0;
    var isRightEdge = (edge, canvasWidth) => edge.orientation === "vertical" && edge.edgeStart.x === canvasWidth;
    var findVizAlongVerticalEdge = ({
      x,
      yStart,
      yEnd,
      yCurrent = yStart,
      nodes,
      visualizations = /* @__PURE__ */ new Set()
    }) => {
      nodes[x][yCurrent].forEach((viz) => {
        if (viz.position.w <= 0 || viz.position.h <= 0) {
          return;
        }
        if (viz.position.y >= yStart && viz.position.y < yEnd) {
          visualizations.add(viz);
        }
        if (viz.position.y >= yCurrent && yCurrent + viz.position.h <= yEnd) {
          findVizAlongVerticalEdge({
            x,
            yStart,
            yEnd,
            yCurrent: yCurrent + viz.position.h,
            nodes,
            visualizations
          });
        }
      });
      return visualizations;
    };
    var findVizAlongHorizontalEdge = ({
      y,
      xStart,
      xEnd,
      xCurrent = xStart,
      nodes,
      visualizations = /* @__PURE__ */ new Set()
    }) => {
      var _a, _b;
      (_b = (_a = nodes[xCurrent]) == null ? void 0 : _a[y]) == null ? void 0 : _b.forEach((viz) => {
        if (viz.position.w <= 0 || viz.position.h <= 0) {
          return;
        }
        if (viz.position.x >= xStart && viz.position.x < xEnd) {
          visualizations.add(viz);
        }
        if (viz.position.x >= xCurrent && xCurrent + viz.position.w <= xEnd) {
          findVizAlongHorizontalEdge({
            y,
            xStart,
            xEnd,
            xCurrent: xCurrent + viz.position.w,
            nodes,
            visualizations
          });
        }
      });
      return visualizations;
    };
    var addEdge = ({
      edges,
      edgeStart,
      edgeEnd,
      nodes
    }) => {
      const orientation = edgeStart.y === edgeEnd.y ? "horizontal" : "vertical";
      const visualizations = orientation === "vertical" ? findVizAlongVerticalEdge({
        x: edgeStart.x,
        yStart: edgeStart.y,
        yEnd: edgeEnd.y,
        nodes
      }) : findVizAlongHorizontalEdge({
        y: edgeStart.y,
        xStart: edgeStart.x,
        xEnd: edgeEnd.x,
        nodes
      });
      edges.push({
        item: getNextEdgeId(),
        edgeStart,
        edgeEnd,
        visualizations: Array.from(visualizations),
        orientation
      });
    };
    var shouldTraverseDown = (y, visualizations) => {
      return visualizations.every((viz) => viz.position.y >= y);
    };
    var shouldTraverseRight = (x, visualizations) => {
      return visualizations.every((viz) => viz.position.x >= x);
    };
    var findOffset = ({
      x,
      y,
      visualizations,
      type
    }) => {
      const vizXY = visualizations.find(
        ({ position }) => position.y === y && position.x === x
      );
      if (vizXY) {
        return vizXY.position[type];
      }
      const vizWH = visualizations.find(
        ({ position }) => (
          // horizontal canvas edge
          type === "w" && position.x === x || // vertical canvas edge
          type === "h" && position.y === y
        )
      );
      if (vizWH) {
        return vizWH.position[type];
      }
      return 0;
    };
    function traverseRight({
      x,
      y,
      nodes,
      edges,
      edgeStart,
      canTraverseDown = true
    }) {
      if (canTraverseDown && shouldTraverseDown(y, nodes[x][y])) {
        traverseDown({
          x,
          y,
          nodes,
          edges,
          edgeStart: { x, y },
          // Start new edge when changing directions
          canTraverseRight: false
        });
      }
      const offset = findOffset({ x, y, visualizations: nodes[x][y], type: "w" });
      if (!offset) {
        addEdge({ edges, edgeStart, edgeEnd: { x, y }, nodes });
        return;
      }
      const isWindow = nodes[x][y].length === 4;
      if (isWindow) {
        addEdge({ edges, edgeStart, edgeEnd: { x, y }, nodes });
        traverseRight({
          x: x + offset,
          y,
          nodes,
          edges,
          edgeStart: { x, y }
        });
        return;
      }
      traverseRight({
        x: x + offset,
        y,
        nodes,
        edges,
        edgeStart
      });
    }
    function traverseDown({
      x,
      y,
      nodes,
      edges,
      edgeStart,
      canTraverseRight = true
    }) {
      if (canTraverseRight && shouldTraverseRight(x, nodes[x][y])) {
        traverseRight({
          x,
          y,
          nodes,
          edges,
          edgeStart: { x, y },
          // Start new edge when changing directions
          canTraverseDown: false
        });
      }
      const offset = findOffset({ x, y, visualizations: nodes[x][y], type: "h" });
      if (!offset) {
        addEdge({ edges, edgeStart, edgeEnd: { x, y }, nodes });
        return;
      }
      const isWindow = nodes[x][y].length === 4;
      if (isWindow) {
        addEdge({ edges, edgeStart, edgeEnd: { x, y }, nodes });
        traverseDown({
          x,
          y: y + offset,
          nodes,
          edges,
          edgeStart: { x, y }
        });
        return;
      }
      traverseDown({
        x,
        y: y + offset,
        nodes,
        edges,
        edgeStart
      });
    }
    var computeVerticalCanvasEdges = ({
      edges,
      canvasWidth,
      layout
    }) => {
      const nodes = getNodes(layout);
      if (nodes == null) {
        return;
      }
      const sortedRowEdges = edges.filter(
        (edge) => edge.orientation === "horizontal" && edge.edgeStart.x === 0 && edge.edgeEnd.x === canvasWidth
      ).sort((a, b) => a.edgeStart.y - b.edgeStart.y);
      for (let i = 0; i < sortedRowEdges.length - 1; i += 1) {
        const { edgeStart: edgeStartA, edgeEnd: edgeEndA } = sortedRowEdges[i];
        const { edgeStart: edgeStartB, edgeEnd: edgeEndB } = sortedRowEdges[i + 1];
        addEdge({
          edges,
          edgeStart: edgeStartA,
          edgeEnd: edgeStartB,
          nodes
        });
        addEdge({
          edges,
          edgeStart: edgeEndA,
          edgeEnd: edgeEndB,
          nodes
        });
      }
    };
    var getAllEdges = (layout) => {
      const edges = [];
      const nodes = getNodes(layout);
      if (nodes === null || nodes[0] === void 0 || nodes[0][0] === void 0) {
        return [];
      }
      traverseRight({
        x: 0,
        y: 0,
        nodes,
        edges,
        edgeStart: { x: 0, y: 0 }
      });
      return edges;
    };
    var computeEdges = ({
      layout,
      canvasHeight,
      canvasWidth
    }) => {
      if (layout === void 0) {
        return [];
      }
      let edges = getAllEdges(layout);
      edges = edges.filter((edge) => {
        return !(isLeftEdge(edge) || isRightEdge(edge, canvasWidth));
      });
      computeVerticalCanvasEdges({ edges, layout, canvasWidth });
      edges = edges.map((edge) => {
        let isCanvasEdge = false;
        if (isTopEdge(edge) || isRightEdge(edge, canvasWidth) || isBottomEdge(edge, canvasHeight) || isLeftEdge(edge)) {
          isCanvasEdge = true;
        }
        return __spreadProps(__spreadValues({}, edge), { isCanvasEdge });
      });
      return edges;
    };
    var applyVizPadding = ({
      item,
      padding = 0
    }) => {
      const { x, y, w, h } = item.position;
      return __spreadProps(__spreadValues({}, item), {
        position: {
          x: x + padding,
          y: y + padding,
          w: w - 2 * padding,
          h: h - 2 * padding
        }
      });
    };
    var getVerticalBoundaries = ({
      visualizations,
      y,
      minHeight,
      isFullWidthEdge = false
    }) => {
      const boundaries = {
        upperBoundary: Number.NEGATIVE_INFINITY,
        lowerBoundary: Number.POSITIVE_INFINITY
      };
      const comparePosition = (position) => {
        if (position.y >= y && !isFullWidthEdge) {
          boundaries.lowerBoundary = Math.min(
            boundaries.lowerBoundary,
            position.y + position.h - minHeight
          );
        }
        if (position.y < y) {
          boundaries.upperBoundary = Math.max(
            boundaries.upperBoundary,
            position.y + minHeight
          );
        }
      };
      visualizations.forEach((viz) => comparePosition(viz.position));
      return boundaries;
    };
    var getHorizontalBoundaries = ({
      visualizations,
      x,
      minWidth
    }) => {
      const boundaries = {
        rightBoundary: Number.POSITIVE_INFINITY,
        leftBoundary: Number.NEGATIVE_INFINITY
      };
      const comparePosition = (position) => {
        if (position.x >= x) {
          boundaries.rightBoundary = Math.min(
            boundaries.rightBoundary,
            position.x + position.w - minWidth
          );
        }
        if (position.x < x) {
          boundaries.leftBoundary = Math.max(
            boundaries.leftBoundary,
            position.x + minWidth
          );
        }
      };
      visualizations.forEach((viz) => comparePosition(viz.position));
      return boundaries;
    };
    var moveHorizontalEdge = ({
      edge,
      offset,
      edgeBoundaries: { upperBoundary, lowerBoundary }
    }) => {
      const updatedY = offset < 0 ? Math.max(upperBoundary, edge.edgeStart.y + offset) : Math.min(lowerBoundary, edge.edgeStart.y + offset);
      return __spreadProps(__spreadValues({}, edge), {
        edgeStart: {
          x: edge.edgeStart.x,
          y: updatedY
        },
        edgeEnd: {
          x: edge.edgeEnd.x,
          y: updatedY
        }
      });
    };
    var moveVerticalEdge = ({
      edge,
      offset,
      edgeBoundaries: { leftBoundary, rightBoundary }
    }) => {
      const updatedX = offset < 0 ? Math.max(leftBoundary, edge.edgeStart.x + offset) : Math.min(rightBoundary, edge.edgeStart.x + offset);
      return __spreadProps(__spreadValues({}, edge), {
        edgeStart: {
          x: updatedX,
          y: edge.edgeStart.y
        },
        edgeEnd: {
          x: updatedX,
          y: edge.edgeEnd.y
        }
      });
    };
    var findSnappableEdges = ({
      edge,
      edges,
      snapRange
    }) => {
      const coordinate = edge.orientation === "horizontal" ? "y" : "x";
      const snappableEdges = edges.reduce(
        (currentSnappableEdges, nextEdge) => {
          const nextEdgeDistance = Math.abs(
            nextEdge.edgeStart[coordinate] - edge.edgeStart[coordinate]
          );
          if (nextEdgeDistance <= snapRange) {
            if (currentSnappableEdges.length === 0) {
              return [nextEdge];
            }
            const lastEdge = currentSnappableEdges[currentSnappableEdges.length - 1];
            const lastEdgeDistance = Math.abs(
              lastEdge.edgeStart[coordinate] - edge.edgeStart[coordinate]
            );
            if (nextEdgeDistance < lastEdgeDistance) {
              return [nextEdge];
            }
            if (nextEdgeDistance === lastEdgeDistance) {
              return [...currentSnappableEdges, nextEdge];
            }
          }
          return [...currentSnappableEdges];
        },
        []
      );
      const firstSnappableEdge = snappableEdges.length > 0 ? snappableEdges[0] : edge;
      return {
        updatedEdge: __spreadProps(__spreadValues({}, edge), {
          edgeStart: __spreadProps(__spreadValues({}, edge.edgeStart), {
            [coordinate]: firstSnappableEdge.edgeStart[coordinate]
          }),
          edgeEnd: __spreadProps(__spreadValues({}, edge.edgeEnd), {
            [coordinate]: firstSnappableEdge.edgeEnd[coordinate]
          })
        }),
        snappableEdges
      };
    };
    var findEdgesInBoundary = ({
      edge,
      edges,
      edgeBoundaries
    }) => {
      const { orientation } = edge;
      if (orientation === "horizontal") {
        return edges.filter(
          (e) => e.orientation === "horizontal" && e.edgeStart.y >= edgeBoundaries.upperBoundary && e.edgeStart.y <= edgeBoundaries.lowerBoundary && e !== edge
        );
      }
      if (orientation === "vertical") {
        return edges.filter(
          (e) => e.orientation === "vertical" && e.edgeStart.x >= edgeBoundaries.leftBoundary && e.edgeStart.x <= edgeBoundaries.rightBoundary && e !== edge
        );
      }
      return [];
    };
    var GRID_SIZE = 10;
    var GRID_PADDING = 1;
    var MIN_WIDTH = GRID_SIZE * 2;
    var MIN_HEIGHT = GRID_SIZE * 2;
    var OFFSET_SIZE = GRID_SIZE * 2;
    var computeMaxHeight = dashboard_utils_exports.computeMaxHeight;
    var isBlockPositionValid = (position) => !!(position && Number.isInteger(position.x) && Number.isInteger(position.y) && Number.isInteger(position.w) && Number.isInteger(position.h));
    var isValidConnection = (connection) => {
      if ("x" in connection && "y" in connection && Number.isInteger(connection.x) && Number.isInteger(connection.y)) {
        return true;
      }
      if ("item" in connection && "port" in connection && connection.item != null && connection.port != null) {
        return true;
      }
      return false;
    };
    var isLinePositionValid = (position) => {
      if (position.from != null && position.to != null) {
        return isValidConnection(position.from) && isValidConnection(position.to);
      }
      return false;
    };
    var removeInvalidItems = (layoutStructure = []) => layoutStructure.filter((structure) => {
      if (structure.type === "line") {
        return isLinePositionValid(structure.position);
      }
      return isBlockPositionValid(structure.position);
    });
    var positionToStyle = (pos) => ({
      width: `${pos.w}px`,
      height: `${pos.h}px`,
      transform: `translate(${pos.x}px, ${pos.y}px)`
    });
    var getClientPosition = (e, scaleFactor = 1) => ({
      x: Math.round(e.clientX / scaleFactor),
      y: Math.round(e.clientY / scaleFactor)
    });
    var getOffset = (currentPosition, startPosition) => ({
      offsetX: currentPosition.x - startPosition.x,
      offsetY: currentPosition.y - startPosition.y
    });
    var considerMoved = ({
      offsetX,
      offsetY
    }) => offsetX !== 0 || offsetY !== 0;
    var positionsToBoundary = (startPos, endPos) => ({
      x: Math.min(startPos.x, endPos.x),
      y: Math.min(startPos.y, endPos.y),
      w: Math.abs(startPos.x - endPos.x),
      h: Math.abs(startPos.y - endPos.y)
    });
    var filterBlockItemsByBoundary = (items, boundary) => items.filter((item) => {
      const itemPosition = item.position;
      return !(boundary.x > itemPosition.x + itemPosition.w || boundary.x + boundary.w < itemPosition.x || boundary.y > itemPosition.y + itemPosition.h || boundary.y + boundary.h < itemPosition.y);
    });
    var findTopBlockItemByPosition = (items, pos, padding = 0) => (0, lodash_exports.findLast)(items, (item) => {
      const itemPosition = padding ? applyVizPadding({ item, padding }).position : item.position;
      return itemPosition.x <= pos.x && itemPosition.x + itemPosition.w >= pos.x && itemPosition.y <= pos.y && itemPosition.y + itemPosition.h >= pos.y;
    });
    var snapOffset = (current, offset, snapTo) => {
      const remainder = (current + offset) % snapTo;
      const newOffset = remainder > snapTo / 2 ? offset + (snapTo - remainder) : offset - remainder;
      return newOffset;
    };
    var snapOffsetToXY = ({
      position,
      offset,
      gridWidth,
      gridHeight,
      spacing = 0,
      padding = 0
    }) => {
      let { offsetX, offsetY } = offset;
      offsetX = snapOffset(position.x, offsetX, gridWidth + spacing) + padding;
      offsetY = snapOffset(position.y, offsetY, gridHeight + spacing) + padding;
      return {
        offsetX,
        offsetY
      };
    };
    var snapOffsetToWH = ({
      position,
      offset,
      gridWidth,
      gridHeight,
      spacing = 0,
      padding = 0
    }) => {
      let { offsetX, offsetY } = offset;
      offsetX = snapOffset(position.x + position.w, offsetX, gridWidth + spacing) + (padding - spacing);
      offsetY = snapOffset(position.y + position.h, offsetY, gridHeight + spacing) + (padding - spacing);
      return {
        offsetX,
        offsetY
      };
    };
    var updateBlockItemSize = ({
      item,
      offset,
      dir,
      options: { minWidth = 0, minHeight = 0 } = {}
    }) => {
      const { w, h } = item.position;
      const { offsetX, offsetY } = offset;
      const updatedPosition = __spreadValues({}, item.position);
      if (["n", "ne", "nw"].includes(dir)) {
        updatedPosition.y += Math.min(h - minHeight, offsetY);
        updatedPosition.h -= offsetY;
      }
      if (["s", "se", "sw"].includes(dir)) {
        updatedPosition.h += offsetY;
      }
      if (["e", "ne", "se"].includes(dir)) {
        updatedPosition.w += offsetX;
      }
      if (["w", "nw", "sw"].includes(dir)) {
        updatedPosition.x += Math.min(w - minWidth, offsetX);
        updatedPosition.w -= offsetX;
      }
      updatedPosition.w = Math.max(minWidth, updatedPosition.w);
      updatedPosition.h = Math.max(minHeight, updatedPosition.h);
      return __spreadProps(__spreadValues({}, item), {
        position: updatedPosition
      });
    };
    var updateBlockItemPosition = (item, offset) => {
      const { offsetX, offsetY } = offset;
      return __spreadProps(__spreadValues({}, item), {
        position: __spreadProps(__spreadValues({}, item.position), {
          x: item.position.x + offsetX,
          y: item.position.y + offsetY
        })
      });
    };
    var createOffset = (dir, x, y) => {
      switch (dir) {
        case "n":
          return {
            offsetX: 0,
            offsetY: -y
          };
        case "s":
          return {
            offsetX: 0,
            offsetY: y
          };
        case "w":
          return {
            offsetX: -x,
            offsetY: 0
          };
        case "e":
          return {
            offsetX: x,
            offsetY: 0
          };
        default:
          return {
            offsetX: 0,
            offsetY: 0
          };
      }
    };
    var computeScaleToFit = ({
      canvasWidth,
      canvasHeight,
      containerWidth,
      containerHeight,
      scrollbarWidth,
      max = Infinity,
      enableGridLayoutCssScaling = true
    }) => {
      if (!((0, lodash_exports.isNumber)(containerWidth) && containerWidth > 0 && (0, lodash_exports.isNumber)(canvasWidth) && canvasWidth > 0)) {
        dashboard_utils_exports.console.warn(
          `Failed to calculate layout scale: canvasWidth=${canvasWidth}, containerWidth=${containerWidth}; falling back to scale=1`
        );
        return 1;
      }
      const scale = Math.min(containerWidth / canvasWidth, max);
      const scrollbarScale = Math.min(
        (containerWidth - scrollbarWidth) / canvasWidth,
        max
      );
      if (!enableGridLayoutCssScaling) {
        return scrollbarScale;
      }
      if (canvasHeight * scale > containerHeight) {
        return scrollbarScale;
      }
      return scale;
    };
    var moveLayoutItem = (items, from, to) => {
      const structure = [...items];
      const removed = (0, lodash_exports.pullAt)(structure, [from]);
      structure.splice(to, 0, removed[0]);
      return structure;
    };
    var isLineConnected = ({ line, dir }) => "item" in line.position[dir];
    var disconnectLine = ({
      line,
      dir,
      absPos
    }) => {
      const updatePosition = __spreadProps(__spreadValues({}, line.position), {
        [dir]: __spreadValues({}, absPos)
      });
      return __spreadProps(__spreadValues({}, line), {
        position: updatePosition
      });
    };
    var connectLine = ({
      line,
      dir,
      itemId,
      port
    }) => {
      const { position } = line;
      const updatedPosition = __spreadProps(__spreadValues({}, position), {
        [dir]: {
          item: itemId,
          port
        }
      });
      return __spreadProps(__spreadValues({}, line), {
        position: updatedPosition
      });
    };
    var updateLineAbsPosition = ({
      line,
      dir,
      offset
    }) => {
      const { offsetX, offsetY } = offset;
      const { position } = line;
      if (!("x" in position[dir])) {
        throw Error(
          `line item ${line.item} does not have x value for its direction ${dir}`
        );
      }
      if (!("y" in position[dir])) {
        throw Error(
          `line item ${line.item} does not have y value for its direction ${dir}`
        );
      }
      const { x, y } = position[dir];
      return __spreadProps(__spreadValues({}, line), {
        position: __spreadProps(__spreadValues({}, position), {
          [dir]: {
            x: x + offsetX,
            y: y + offsetY
          }
        })
      });
    };
    var computeLineBoxPosition = (from, to) => ({
      x: Math.min(from.x, to.x),
      y: Math.min(from.y, to.y)
    });
    var computeLineRelativePosition = (from, to, box) => ({
      from: {
        x: from.x - box.x,
        y: from.y - box.y
      },
      to: {
        x: to.x - box.x,
        y: to.y - box.y
      }
    });
    var cloneBlockItem = ({
      id,
      item,
      offsetMultiplier
    }) => {
      const copiedPosition = item.position;
      return __spreadProps(__spreadValues({}, item), {
        item: id,
        position: {
          x: copiedPosition.x + OFFSET_SIZE * offsetMultiplier,
          y: copiedPosition.y + OFFSET_SIZE * offsetMultiplier,
          w: copiedPosition.w,
          h: copiedPosition.h
        }
      });
    };
    var cloneLine = ({
      id,
      item,
      offsetMultiplier
    }) => {
      const copiedPosition = item.position;
      return __spreadProps(__spreadValues({}, item), {
        item: id,
        position: {
          from: {
            x: copiedPosition.from.x + OFFSET_SIZE * offsetMultiplier,
            y: copiedPosition.from.y + OFFSET_SIZE * offsetMultiplier
          },
          to: {
            x: copiedPosition.to.x + OFFSET_SIZE * offsetMultiplier,
            y: copiedPosition.to.y + OFFSET_SIZE * offsetMultiplier
          }
        }
      });
    };
    var shiftViewportOnZoom = ({
      scrollLeft,
      scrollTop,
      offsetWidth,
      offsetHeight,
      scaleRatio
    }) => {
      const middleOffsetWidth = offsetWidth / 2;
      const middleOffsetHeight = offsetHeight / 2;
      return {
        scrollLeft: (scrollLeft + middleOffsetWidth) * scaleRatio - middleOffsetWidth,
        scrollTop: (scrollTop + middleOffsetHeight) * scaleRatio - middleOffsetHeight
      };
    };
    var computeRelativePosition = (e, canvasRef, scale = 1) => {
      var _a;
      const pos = getClientPosition(e, scale);
      const canvasDomNode = canvasRef == null ? void 0 : canvasRef.current;
      const rect = (_a = canvasDomNode == null ? void 0 : canvasDomNode.getBoundingClientRect) == null ? void 0 : _a.call(canvasDomNode);
      if (pos && rect) {
        return {
          x: pos.x - rect.left / scale,
          y: pos.y - rect.top / scale
        };
      }
      return pos;
    };
    var scaleGridLayoutStructureByWidth = ({
      layout,
      scale = 1
    }) => {
      if (scale === 1) {
        return layout;
      }
      const edges = getAllEdges(layout);
      const verticalEdges = (0, lodash_exports.sortBy)(
        edges.filter((edge) => edge.orientation === "vertical"),
        ["edgeStart.x"]
      );
      const newLayout = [];
      verticalEdges.forEach((edge) => {
        const {
          visualizations,
          edgeStart: { x }
        } = edge;
        const scaledEdgeX = Math.round(x * scale);
        const left = visualizations.filter((viz) => viz.position.x < x);
        const right = visualizations.filter((viz) => viz.position.x >= x);
        left.forEach((layoutItem) => {
          const newLayoutItem = newLayout.find(
            ({ item: id }) => layoutItem.item === id
          );
          if (newLayoutItem) {
            newLayoutItem.position.w = scaledEdgeX - newLayoutItem.position.x;
          }
        });
        right.forEach((layoutItem) => {
          newLayout.push(__spreadProps(__spreadValues({}, layoutItem), {
            position: __spreadProps(__spreadValues({}, layoutItem.position), {
              x: scaledEdgeX
            })
          }));
        });
      });
      return newLayout;
    };
    var useCanvasZoomCenter = ({
      layoutId,
      scale,
      fitToWidth
    }) => {
      var _a;
      const { enableZoomCenter } = (0, dashboard_context_exports.useFeatureFlags)();
      const canvasRef = (0, dashboard_context_exports.useCanvasRef)(layoutId);
      const previousScale = (0, dashboard_context_exports.usePrevious)(scale);
      const savedScroll = (0, react_exports.useRef)(null);
      if (previousScale != null && previousScale >= 1 && scale < 1 && enableZoomCenter) {
        const previousLayout = (_a = canvasRef.current) == null ? void 0 : _a.parentElement;
        if (previousLayout) {
          savedScroll.current = {
            x: previousLayout.scrollLeft + previousLayout.offsetWidth / 2,
            y: previousLayout.scrollTop + previousLayout.offsetHeight / 2
          };
        }
      }
      (0, react_exports.useLayoutEffect)(() => {
        var _a2, _b, _c;
        if (fitToWidth || previousScale == null || previousScale === scale) {
          return;
        }
        const layout = (_a2 = canvasRef.current) == null ? void 0 : _a2.parentElement;
        if (!layout) {
          return;
        }
        const { offsetWidth, offsetHeight, scrollTop, scrollLeft } = layout;
        if (previousScale < 1 && scale > 1 && ((_b = savedScroll.current) == null ? void 0 : _b.x) != null && ((_c = savedScroll.current) == null ? void 0 : _c.y) != null && enableZoomCenter) {
          layout.scrollLeft = savedScroll.current.x - layout.offsetWidth / 2;
          layout.scrollTop = savedScroll.current.y - layout.offsetHeight / 2;
        } else {
          const scaleRatio = scale / previousScale;
          const newScroll = shiftViewportOnZoom({
            offsetWidth,
            offsetHeight,
            scrollTop,
            scrollLeft,
            scaleRatio
          });
          layout.scrollLeft = newScroll.scrollLeft;
          layout.scrollTop = newScroll.scrollTop;
        }
      }, [canvasRef, enableZoomCenter, fitToWidth, previousScale, scale]);
    };
    var useScaleOnDisplayChange = ({
      display,
      layoutId,
      setFitToWidth,
      setScale
    }) => {
      const canvasRef = (0, dashboard_context_exports.useCanvasRef)(layoutId);
      const setFitToWidthAndScrollToTopLeft = (0, react_exports.useCallback)(
        (maxScale) => {
          var _a;
          setFitToWidth(maxScale);
          const layoutEl = (_a = canvasRef.current) == null ? void 0 : _a.parentElement;
          if (layoutEl) {
            layoutEl.scrollTop = 0;
            layoutEl.scrollLeft = 0;
          }
        },
        [canvasRef, setFitToWidth]
      );
      (0, react_exports.useEffect)(() => {
        if (display === "fit-to-width" || display === "auto-scale") {
          setFitToWidthAndScrollToTopLeft();
        } else if (display === "actual-size") {
          setScale(1);
        } else {
          setFitToWidthAndScrollToTopLeft(1);
        }
      }, [display, setFitToWidthAndScrollToTopLeft, setScale]);
    };
    var useScaleToFit = ({
      width,
      height,
      containerWidth,
      containerHeight,
      fitToWidth,
      getZoomObserver
    }) => {
      (0, react_exports.useEffect)(() => {
        if (!fitToWidth) {
          return;
        }
        const scrollbarWidth = (0, dashboard_utils_exports.getScrollbarWidth)();
        const newScale = computeScaleToFit({
          canvasWidth: width,
          canvasHeight: height,
          containerWidth,
          containerHeight,
          max: fitToWidth,
          scrollbarWidth
        });
        getZoomObserver().next(newScale);
      }, [
        width,
        height,
        containerWidth,
        containerHeight,
        fitToWidth,
        getZoomObserver
      ]);
    };
    var useScrollOnFitToWidth = ({
      layoutId,
      fitToWidth
    }) => {
      var _a;
      const canvasRef = (0, dashboard_context_exports.useCanvasRef)(layoutId);
      const prevFitToWidth = (0, react_exports.useRef)(fitToWidth);
      if (fitToWidth !== prevFitToWidth.current) {
        prevFitToWidth.current = fitToWidth;
        if (!fitToWidth) {
          return;
        }
        if (!((_a = canvasRef.current) == null ? void 0 : _a.parentElement)) {
          return;
        }
        canvasRef.current.parentElement.scrollLeft = 0;
        canvasRef.current.parentElement.scrollTop = 0;
      }
    };
    var useAbsoluteLayoutZoom = ({
      display,
      layoutId,
      width,
      height,
      containerWidth,
      containerHeight
    }) => {
      const { fitToWidth, scale, getZoomObserver, setFitToWidth, setScale } = (0, dashboard_context_exports.useLayoutZoomApi)({ layoutId });
      (0, dashboard_context_exports.useKeyboardZoom)({ layoutId });
      useScrollOnFitToWidth({ layoutId, fitToWidth });
      useScaleToFit({
        width,
        height,
        containerWidth,
        containerHeight,
        fitToWidth,
        getZoomObserver
      });
      useScaleOnDisplayChange({ display, layoutId, setFitToWidth, setScale });
      useCanvasZoomCenter({ layoutId, scale, fitToWidth });
      return scale;
    };
    var useBackgroundImage = (backgroundImageSrc) => {
      const [imageSrc, setImageSrc] = (0, react_exports.useState)("");
      const imageRegistry = (0, dashboard_context_exports.useImageRegistry)();
      const fetchBackgroundImage = (registry, bgImageSrc) => __async(void 0, null, function* () {
        try {
          if (registry) {
            if (registry.isResourceURL(bgImageSrc)) {
              const imageObject = yield registry.getByURL(bgImageSrc);
              setImageSrc(imageObject.dataURI);
            } else {
              setImageSrc(bgImageSrc);
            }
          } else {
            setImageSrc(bgImageSrc);
          }
        } catch (error) {
          if (error instanceof Error) {
            dashboard_utils_exports.console.error(error.message);
          } else {
            dashboard_utils_exports.console.error("An unknown error occurred");
          }
        }
      });
      (0, react_exports.useEffect)(() => {
        if (backgroundImageSrc) {
          fetchBackgroundImage(
            imageRegistry,
            backgroundImageSrc
          );
        } else {
          setImageSrc("");
        }
      }, [imageRegistry, backgroundImageSrc]);
      return imageSrc;
    };
    var getCondIds = (allItems) => allItems === void 0 ? [] : Object.values(allItems).flatMap((itemDef) => {
      var _a, _b;
      const {
        conditions = [],
        showConditions = [],
        hideConditions = []
      } = (_b = (_a = itemDef.containerOptions) == null ? void 0 : _a.visibility) != null ? _b : {};
      return [...conditions, ...showConditions, ...hideConditions];
    });
    var useLayoutShowHide = (layoutStructure, handleReflow) => {
      const allVizs = (0, dashboard_state_exports.useSelector)(dashboard_state_exports.selectVisualizations);
      const allInputs = (0, dashboard_state_exports.useSelector)(dashboard_state_exports.selectInputs);
      const mode = (0, dashboard_state_exports.useSelector)(dashboard_state_exports.selectMode);
      const allConditionIds = (0, react_exports.useMemo)(
        () => /* @__PURE__ */ new Set([...getCondIds(allVizs), ...getCondIds(allInputs)]),
        [allInputs, allVizs]
      );
      const conditionResults = (0, dashboard_state_exports.useSelector)(
        (state) => (0, dashboard_state_exports.selectConditionResults)(state, Array.from(allConditionIds))
      );
      const subscriptions = (0, dashboard_ui_exports.useBatchSubscribeToSearches)({
        consumerId: "<layout>"
      });
      const { enableShowHide } = (0, dashboard_context_exports.useFeatureFlags)();
      return (0, react_exports.useMemo)(() => {
        if (!enableShowHide || mode === "edit") {
          return layoutStructure;
        }
        const itemsToRemove = [];
        const filteredStructure = layoutStructure.filter((item) => {
          var _a;
          if ((0, dashboard_utils_exports.shouldHideItem)({
            itemType: item.type,
            definition: (_a = allVizs[item.item]) != null ? _a : allInputs == null ? void 0 : allInputs[item.item],
            searchData: subscriptions[item.item],
            conditionResults
          })) {
            itemsToRemove.push(item);
            return false;
          }
          return true;
        });
        return itemsToRemove.length && handleReflow ? handleReflow(layoutStructure, itemsToRemove) : filteredStructure;
      }, [
        enableShowHide,
        mode,
        layoutStructure,
        handleReflow,
        allVizs,
        allInputs,
        subscriptions,
        conditionResults
      ]);
    };
    var useMouseDownWithHandleEventListeners = ({
      handleMouseDownOnItem,
      canvasRef,
      scale,
      setStartPosition,
      movable,
      isMovingRef
    }) => {
      const handleMouseDownOnVizWithHandle = (0, dashboard_ui_exports.useEventCallback)(
        (e) => {
          const { vizId, initialEvent, type } = e.detail;
          const pos = computeRelativePosition(initialEvent, canvasRef, scale);
          setStartPosition(pos);
          const block = {
            id: vizId,
            type
          };
          handleMouseDownOnItem(initialEvent, block);
        }
      );
      const handleMouseDownOnHandle = (0, dashboard_ui_exports.useEventCallback)((e) => {
        const { vizId, initialEvent, type } = e.detail;
        const pos = computeRelativePosition(initialEvent, canvasRef, scale);
        setStartPosition(pos);
        const block = {
          id: vizId,
          type
        };
        handleMouseDownOnItem(initialEvent, block);
        if (movable) {
          isMovingRef.current = true;
        }
      });
      (0, dashboard_ui_exports.useEventListener)({
        eventName: dashboard_ui_exports.EVENT_MOUSE_DOWN_ON_VIZ_WITH_HANDLE,
        target: document,
        listener: handleMouseDownOnVizWithHandle
      });
      (0, dashboard_ui_exports.useEventListener)({
        eventName: dashboard_ui_exports.EVENT_MOUSE_DOWN_ON_HANDLE,
        target: document,
        listener: handleMouseDownOnHandle
      });
    };
    var toBackgroundImageSize = ({
      src,
      imageHeight,
      imageWidth,
      sizeType
    }) => {
      const { width: w, height: h } = getImageDimension(src != null ? src : "");
      if (imageWidth && imageHeight) {
        return `${(0, dashboard_utils_exports.toPx)(imageWidth)} ${(0, dashboard_utils_exports.toPx)(imageHeight)}`;
      }
      if (imageWidth || imageHeight) {
        return `${(0, dashboard_utils_exports.toPx)(imageWidth != null ? imageWidth : w)} ${(0, dashboard_utils_exports.toPx)(imageHeight != null ? imageHeight : h)}`;
      }
      return sizeType != null ? sizeType : "contain";
    };
    var BackgroundImageDiv = styled_components_default.div.attrs(() => ({
      "data-test": "background-image"
    }))`
    ${themes_exports.mixins.reset("inline-block")};
    width: 100%;
    height: 100%;
    position: relative;
    background-repeat: no-repeat;
    background-image: ${(props) => `url("${props.src}")`};
    background-size: ${(props) => toBackgroundImageSize(props)};
    background-position: ${(props) => `${(0, dashboard_utils_exports.toPx)(props.imageX)} ${(0, dashboard_utils_exports.toPx)(props.imageY)}`};
    opacity: ${(prop) => validateOpacity(prop.opacity)};
`;
    var BackgroundImage = (_a) => {
      var _b = _a, { src } = _b, rest = __objRest(_b, ["src"]);
      const imageSrc = useBackgroundImage(src);
      if (!imageSrc) {
        return null;
      }
      return react_default.createElement(BackgroundImageDiv, __spreadProps(__spreadValues({}, rest), { src: imageSrc }));
    };
    var Border = styled_components_default.div.attrs(() => ({
      "data-test": "canvas-border"
    }))`
    position: absolute;
    box-sizing: border-box;
    border: 2px dashed ${themes_exports.variables.interactiveColorBorder};
    left: 0px;
    top: 0px;
    right: 0px;
    bottom: 0px;
    width: 100%;
    height: 100%;
`;
    var CanvasBorder = ({
      showBorder = false
    }) => {
      if (!showBorder) {
        return null;
      }
      return react_default.createElement(Border, null);
    };
    var GRID_LINE_OPACITY = 0.1;
    var getGridLineColor = (props) => {
      var _a;
      return (_a = props.gridLineColor) != null ? _a : themes_exports.variables.contentColorMuted;
    };
    var GridLines = styled_components_default.div`
    position: absolute;
    box-sizing: border-box;
    left: 0px;
    top: 0px;
    right: 0px;
    bottom: 0px;
    width: 100%;
    height: 100%;
    opacity: ${(prop) => {
      var _a;
      return (_a = prop.gridLineOpacity) != null ? _a : GRID_LINE_OPACITY;
    }};
    background-size: ${(prop) => prop.gridWidth + prop.gridLineWidth}px
        ${(prop) => prop.gridHeight + prop.gridLineWidth}px;
    background-image: repeating-linear-gradient(
            0deg,
            ${getGridLineColor},
            ${getGridLineColor} ${(prop) => (0, dashboard_utils_exports.toPx)(prop.gridLineWidth)},
            transparent ${(prop) => prop.gridLineWidth}px,
            transparent ${(prop) => prop.gridHeight + prop.gridLineWidth}px
        ),
        repeating-linear-gradient(
            -90deg,
            ${getGridLineColor},
            ${getGridLineColor} ${(prop) => (0, dashboard_utils_exports.toPx)(prop.gridLineWidth)},
            transparent ${(prop) => prop.gridLineWidth}px,
            transparent ${(prop) => prop.gridWidth + prop.gridLineWidth}px
        );
`;
    var CanvasGridlines = (_a) => {
      var _b = _a, { showGrid } = _b, rest = __objRest(_b, ["showGrid"]);
      if (!showGrid) {
        return null;
      }
      return react_default.createElement(GridLines, __spreadProps(__spreadValues({}, rest), { "data-test": "gridlines" }));
    };
    var toScale = (scale) => scale ? {
      transform: `scale(${scale})`,
      transformOrigin: "0 0",
      width: `${100 / scale}%`
    } : {
      width: "100%"
    };
    var Background = styled_components_default.div.attrs((props) => ({
      style: __spreadValues({
        height: props.height
      }, toScale(props.scale))
    }))`
    ${themes_exports.mixins.reset("inline-block")};
    position: relative;
    background: ${(prop) => prop.bgColor || // NOTE: this needs to match packages/dashboard-editors/src/layouts/AbsoluteLayoutEditor.tsx
    dashboard_ui_exports.customThemeVariables.dashboardBackgroundColor};
`;
    var CanvasContainer = styled_components_default.div.attrs((props) => ({
      style: { width: props.width, height: props.height }
    }))`
    ${themes_exports.mixins.reset("block")};
    overflow: ${(prop) => prop.showOverflowContent ? "visible" : "hidden"};
    user-select: ${(prop) => prop.userSelect ? "text" : "none"};
    position: relative;
`;
    var Canvas = (_a, canvasRef) => {
      var _b = _a, {
        width,
        height,
        scale,
        backgroundColor: unsanitizedBgColor = "",
        backgroundImageSrc,
        backgroundImageSizeType,
        backgroundImageWidth,
        backgroundImageHeight,
        backgroundImagePositionX,
        backgroundImagePositionY,
        backgroundImageOpacity,
        gridLineOpacity,
        children,
        showOverflowContent = false,
        userSelect = false,
        showGrid = false,
        gridPadding = 0,
        gridLineWidth = 1,
        gridLineColor,
        gridWidth = 9,
        gridHeight = 9,
        showBorder = false,
        cssScaling = true
      } = _b, others = __objRest(_b, [
        "width",
        "height",
        "scale",
        "backgroundColor",
        "backgroundImageSrc",
        "backgroundImageSizeType",
        "backgroundImageWidth",
        "backgroundImageHeight",
        "backgroundImagePositionX",
        "backgroundImagePositionY",
        "backgroundImageOpacity",
        "gridLineOpacity",
        "children",
        "showOverflowContent",
        "userSelect",
        "showGrid",
        "gridPadding",
        "gridLineWidth",
        "gridLineColor",
        "gridWidth",
        "gridHeight",
        "showBorder",
        "cssScaling"
      ]);
      const containerWidth = scale != null ? width * scale : width;
      const containerHeight = scale != null && cssScaling ? height * scale : height;
      const backgroundColor = (0, dashboard_ui_exports.sanitizeColor)(unsanitizedBgColor);
      return react_default.createElement(
        CanvasContainer,
        __spreadValues({
          "data-test": "canvas-container",
          "data-width": containerWidth,
          "data-height": containerHeight,
          width: cssScaling ? containerWidth : width,
          height: containerHeight,
          showOverflowContent,
          userSelect,
          ref: canvasRef
        }, others),
        react_default.createElement(
          Background,
          {
            "data-test": "canvas",
            "data-width": width,
            "data-height": height,
            "data-scale": scale,
            height,
            scale: cssScaling ? scale : void 0,
            bgColor: backgroundColor
          },
          react_default.createElement(
            BackgroundImage,
            {
              src: backgroundImageSrc,
              sizeType: backgroundImageSizeType,
              imageWidth: backgroundImageWidth,
              imageHeight: backgroundImageHeight,
              imageX: backgroundImagePositionX,
              imageY: backgroundImagePositionY,
              opacity: backgroundImageOpacity
            }
          ),
          react_default.createElement(CanvasBorder, { showBorder }),
          react_default.createElement(
            CanvasGridlines,
            {
              showGrid,
              gridLineOpacity,
              gridPadding,
              gridLineWidth,
              gridLineColor,
              gridWidth,
              gridHeight
            }
          ),
          children
        )
      );
    };
    var Canvas_default = (0, react_exports.forwardRef)(Canvas);
    var prop_types_exports = {};
    __export(prop_types_exports, {
      default: () => prop_types_default
    });
    var defaultImport10 = __toESM2(require_prop_types());
    __reExport(prop_types_exports, require_prop_types());
    var prop_types_default = "default" in defaultImport10 ? defaultImport10.default : defaultImport10;
    var SelectDiv = styled_components_default.div.attrs(({ x, y, w, h }) => ({
      style: {
        width: w,
        height: h,
        transform: `translate(${x}px, ${y}px)`
      }
    }))`
    ${themes_exports.mixins.reset("block")};
    position: absolute;
    background: transparent;
    // the next line is important to avoid blocking the drilldowns, and it allows to select text from visualizations
    pointer-events: none;
    border: 1px solid ${themes_exports.variables.focusColor};
    z-index: 1000;
`;
    var Wrapper = styled_components_default.div`
    ${themes_exports.mixins.reset("block")};
    background: transparent;
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
`;
    var SelectBox = ({ start, end }) => react_default.createElement(Wrapper, null, react_default.createElement(
      SelectDiv,
      {
        w: Math.abs(start.x - end.x),
        h: Math.abs(start.y - end.y),
        x: Math.min(start.x, end.x),
        y: Math.min(start.y, end.y)
      }
    ));
    SelectBox.propTypes = {
      /**
       * starting position
       */
      start: prop_types_default.shape({
        x: prop_types_default.number,
        y: prop_types_default.number
      }),
      /**
       * end position
       */
      end: prop_types_default.shape({
        x: prop_types_default.number,
        y: prop_types_default.number
      })
    };
    var SelectBox_default = SelectBox;
    var findStatusIcon = ({
      canvasRef,
      id
    }) => {
      const canvas = canvasRef == null ? void 0 : canvasRef.current;
      if (!canvas) {
        return null;
      }
      return canvas.querySelector(
        `[data-id="${id}"] [data-test="simple-status-icon-container"]`
      );
    };
    var defaultState = {
      startPosition: null,
      currentPosition: null,
      isMoving: false,
      isSelecting: false
    };
    var DEFAULT_SELECTED_LAYOUT_ITEMS = [];
    var AbsoluteCanvas = (props) => {
      const _a = props, {
        scale,
        children,
        canvasRef,
        blockItems,
        onItemMove = dashboard_utils_exports.noop,
        onItemMoved = dashboard_utils_exports.noop,
        onItemSelected,
        movable = false,
        allowMultiselect,
        selectedLayoutItems = DEFAULT_SELECTED_LAYOUT_ITEMS,
        initialState = defaultState,
        onMouseDownCapture,
        onMouseUpCapture
      } = _a, canvasProps = __objRest(_a, [
        "scale",
        "children",
        "canvasRef",
        "blockItems",
        "onItemMove",
        "onItemMoved",
        "onItemSelected",
        "movable",
        "allowMultiselect",
        "selectedLayoutItems",
        "initialState",
        "onMouseDownCapture",
        "onMouseUpCapture"
      ]);
      const dispatch = (0, dashboard_state_exports.useDispatch)();
      const startPositionRef = (0, react_exports.useRef)(
        initialState.startPosition
      );
      const [currentBoundary, setCurrentBoundary] = (0, react_exports.useState)(() => ({
        start: initialState.currentPosition,
        end: initialState.currentPosition
      }));
      const [isSelecting, setIsSelecting] = (0, react_exports.useState)(initialState.isSelecting);
      const isMovingRef = (0, react_exports.useRef)(false);
      const { isMouseDownOnItemWithHandle, setIsMouseDownOnItemWithHandle } = (0, dashboard_context_exports.useMouseEventsContext)();
      const isMetaKeyUsed = (0, react_exports.useRef)(false);
      const isSelectedWithMetaKey = (0, react_exports.useRef)(false);
      const isMacOS = (0, dashboard_utils_exports.isMac)();
      const resetState = (0, react_exports.useCallback)(() => {
        startPositionRef.current = defaultState.startPosition;
        setCurrentBoundary({
          start: defaultState.currentPosition,
          end: defaultState.currentPosition
        });
        setIsSelecting(defaultState.isSelecting);
        isMovingRef.current = false;
        isMetaKeyUsed.current = false;
        isSelectedWithMetaKey.current = false;
      }, []);
      (0, react_exports.useEffect)(() => {
        if (isMovingRef.current && blockItems) {
          dispatch((0, dashboard_state_exports.blockItemMoving)());
        }
      }, [blockItems, dispatch]);
      const handleItemSelected = (0, react_exports.useCallback)(
        (e, items = []) => {
          if (items.some(
            ({ id, type }) => {
              var _a2;
              return type === "input" && ((_a2 = findStatusIcon({ canvasRef, id })) == null ? void 0 : _a2.contains(
                e.target
              ));
            }
          )) {
            return;
          }
          if (isMacOS && e.metaKey || !isMacOS && e.ctrlKey) {
            const selectedItems = selectedLayoutItems.filter(
              ({ type }) => type === "block" || type === "input"
            );
            isSelectedWithMetaKey.current = true;
            onItemSelected(e, (0, lodash_exports.uniqBy)([...selectedItems, ...items], "id"));
          } else {
            onItemSelected(e, items);
          }
        },
        [canvasRef, selectedLayoutItems, onItemSelected, isMacOS]
      );
      const handleMouseDownOnItem = (0, react_exports.useCallback)(
        (event, blockItem) => {
          if (isMacOS && event.metaKey || !isMacOS && event.ctrlKey) {
            isMetaKeyUsed.current = true;
          }
          const { id, type = "block" } = blockItem;
          if (selectedLayoutItems.find(
            ({ id: selectedId }) => selectedId === id
          )) {
            return;
          }
          handleItemSelected(event, [{ id, type }]);
        },
        [handleItemSelected, selectedLayoutItems, isMacOS]
      );
      const handleMouseMove = (0, dashboard_ui_exports.useEventCallback)((e) => {
        if (!startPositionRef.current) {
          return;
        }
        const newPosition = computeRelativePosition(e, canvasRef, scale);
        const offset = getOffset(newPosition, startPositionRef.current);
        if (isMovingRef.current && considerMoved(offset)) {
          e.stopImmediatePropagation();
          e.preventDefault();
          onItemMove(e, offset);
        }
        setCurrentBoundary({
          start: startPositionRef.current,
          end: newPosition
        });
      });
      const handleMouseUpWithMetaKey = (0, react_exports.useCallback)(
        (event, item) => {
          var _a2;
          if (!item) {
            return;
          }
          const { item: itemId } = item;
          if (itemId && isMetaKeyUsed.current && !isSelectedWithMetaKey.current) {
            const selectedItems = selectedLayoutItems.filter(
              ({ type }) => type === "block" || type === "input"
            );
            const alreadySelected = selectedItems.some(
              (element) => element.id === itemId
            );
            if (alreadySelected) {
              const removedAlreadySelected = selectedItems.filter(
                (element) => element.id !== itemId
              );
              onItemSelected(event, removedAlreadySelected);
            } else {
              handleItemSelected(event, [
                { id: itemId, type: (_a2 = item == null ? void 0 : item.type) != null ? _a2 : "block" }
              ]);
            }
          }
        },
        [handleItemSelected, onItemSelected, selectedLayoutItems]
      );
      const handleMouseUp = (0, dashboard_ui_exports.useEventCallback)((e) => {
        if (!startPositionRef.current) {
          return;
        }
        e.preventDefault();
        const curPosition = computeRelativePosition(e, canvasRef, scale);
        const offset = getOffset(curPosition, startPositionRef.current);
        const isMoved = considerMoved(offset);
        if (isMovingRef.current && isMoved) {
          isMovingRef.current = false;
          onItemMoved(e, offset);
        } else if (allowMultiselect && !findTopBlockItemByPosition(blockItems, startPositionRef.current)) {
          const boundary = positionsToBoundary(
            startPositionRef.current,
            curPosition
          );
          const selectedBlocks = filterBlockItemsByBoundary(
            blockItems,
            boundary
          ).map(
            ({ item, type = "block" }) => ({
              id: item,
              type
            })
          );
          let selectedBlockItems = [];
          if (!isMoved && selectedBlocks.length) {
            selectedBlockItems.push((0, lodash_exports.last)(selectedBlocks));
          } else {
            selectedBlockItems = selectedBlocks;
          }
          handleItemSelected(e, selectedBlockItems);
        } else {
          const item = findTopBlockItemByPosition(blockItems, curPosition);
          const { item: itemId, type = "block" } = item != null ? item : {};
          if (isMetaKeyUsed.current) {
            handleMouseUpWithMetaKey(e, item);
          } else if (itemId && !(selectedLayoutItems.length === 1 && selectedLayoutItems[0].id === itemId) && !isMoved && !isMetaKeyUsed.current) {
            handleItemSelected(e, [{ id: itemId, type }]);
          } else if (!itemId && !findTopBlockItemByPosition(
            blockItems,
            startPositionRef.current
          )) {
            handleItemSelected(e, []);
          }
        }
        resetState();
      });
      const handleMouseDown = (0, dashboard_ui_exports.useEventCallback)(
        (e, selectedBlockItem) => {
          if (isMouseDownOnItemWithHandle == null ? void 0 : isMouseDownOnItemWithHandle.current) {
            setIsMouseDownOnItemWithHandle(false);
            return;
          }
          const pos = computeRelativePosition(e, canvasRef, scale);
          startPositionRef.current = pos;
          const block = selectedBlockItem != null ? selectedBlockItem : findTopBlockItemByPosition(blockItems, pos);
          if (!block) {
            if (allowMultiselect) {
              setIsSelecting(true);
            }
            return;
          }
          const { item, type } = block;
          handleMouseDownOnItem(e, {
            id: item,
            type
          });
          if (movable) {
            isMovingRef.current = true;
          }
        }
      );
      const handleMouseDownCapture = (0, dashboard_ui_exports.useEventCallback)((e) => {
        onMouseDownCapture == null ? void 0 : onMouseDownCapture(e);
        const pos = computeRelativePosition(e, canvasRef, scale);
        const selectedBlockItems = blockItems.filter(
          (item) => selectedLayoutItems.some(
            (selectedItem) => selectedItem.id === item.item
          )
        );
        const topSelectedBlock = findTopBlockItemByPosition(
          selectedBlockItems,
          pos
        );
        const topBlock = findTopBlockItemByPosition(blockItems, pos);
        if (topSelectedBlock && topSelectedBlock !== topBlock) {
          handleMouseDown(e, topSelectedBlock);
          e.stopPropagation();
          e.preventDefault();
        }
      });
      (0, react_exports.useEffect)(() => {
        document.addEventListener("mousemove", handleMouseMove, true);
        return () => {
          document.removeEventListener("mousemove", handleMouseMove, true);
        };
      }, [handleMouseMove]);
      (0, react_exports.useEffect)(() => {
        document.addEventListener("mouseup", handleMouseUp);
        return () => {
          document.removeEventListener("mouseup", handleMouseUp);
        };
      }, [handleMouseUp]);
      const setStartPositionRef = (0, react_exports.useCallback)((position) => {
        startPositionRef.current = position;
      }, []);
      useMouseDownWithHandleEventListeners({
        handleMouseDownOnItem,
        canvasRef,
        scale,
        setStartPosition: setStartPositionRef,
        movable,
        isMovingRef
      });
      const selectBox = (0, react_exports.useMemo)(() => {
        if (allowMultiselect && isSelecting && currentBoundary.start && currentBoundary.end) {
          return react_default.createElement(
            SelectBox_default,
            {
              start: currentBoundary.start,
              end: currentBoundary.end
            }
          );
        }
        return null;
      }, [
        allowMultiselect,
        isSelecting,
        currentBoundary.start,
        currentBoundary.end
      ]);
      return react_default.createElement(
        Canvas_default,
        __spreadProps(__spreadValues({
          ref: canvasRef
        }, canvasProps), {
          scale,
          onMouseDown: handleMouseDown,
          onContextMenu: resetState,
          onMouseDownCapture: handleMouseDownCapture,
          onMouseUpCapture
        }),
        selectBox,
        children
      );
    };
    var AbsoluteCanvas_default = (0, react_exports.forwardRef)((props, ref) => {
      return react_default.createElement(AbsoluteCanvas, __spreadValues({ canvasRef: ref }, props));
    });
    var AbsoluteDiv = styled_components_default.div.attrs(({ x, y, w, h }) => ({
      style: {
        width: w,
        height: h,
        top: `${y}px`,
        left: `${x}px`
      }
    }))`
    display: block;
    position: absolute;
    background: transparent;
`;
    var AbsoluteItem = ({
      itemId,
      type = "block",
      x,
      y,
      w,
      h,
      renderLayoutItem
    }) => react_default.createElement(
      AbsoluteDiv,
      {
        x,
        y,
        w,
        h,
        "data-test": "absolute-item",
        "data-x": x,
        "data-y": y,
        "data-w": w,
        "data-h": h
      },
      renderLayoutItem(
        itemId,
        {
          width: w,
          height: h
        },
        type
      )
    );
    AbsoluteItem.propTypes = {
      itemId: prop_types_default.string.isRequired,
      type: prop_types_default.string,
      x: prop_types_default.number.isRequired,
      y: prop_types_default.number.isRequired,
      w: prop_types_default.number.isRequired,
      h: prop_types_default.number.isRequired,
      renderLayoutItem: prop_types_default.func.isRequired
    };
    var AbsoluteItem_default = AbsoluteItem;
    var ActionMenuPortal = styled_components_default.div.attrs((props) => ({
      "data-test": "action-menu-portal",
      style: {
        width: props.w,
        top: props.y + props.h,
        left: props.x
      }
    }))`
    display: block;
    position: absolute;
    background: transparent;
    pointer-events: all;
    box-sizing: border-box;
    height: 0px;
    z-index: ${(props) => props.zIndex};
`;
    var ActionMenuPortal_default = ActionMenuPortal;
    var EdgeWrapper = styled_components_default.div.attrs(
      ({ x, y, w, h }) => {
        return {
          style: {
            width: w,
            height: h,
            transform: `translate(${x}px, ${y}px)`
          }
        };
      }
    )`
    display: block;
    position: absolute;
    background: transparent;
    box-sizing: border-box;

    &:hover {
        cursor: ${(props) => props.orientation === "vertical" ? "col-resize" : "row-resize"};
        background: ${(0, themes_exports.pickVariant)("appearance", {
      invalid: themes_exports.variables.notificationColorNegative,
      dropTarget: dashboard_ui_exports.customThemeVariables.validDropTargetBackgroundColor,
      normal: "transparent",
      hidden: "transparent"
    })};
        border: ${(0, themes_exports.pickVariant)("appearance", {
      invalid: `1px solid ${themes_exports.variables.severityColorAlert}`,
      dropTarget: `1px solid ${dashboard_ui_exports.customThemeVariables.validDropTargetBorderColor}`,
      normal: "none",
      hidden: "none"
    })};
        transition: background 0.2s ease-out;
    }
`;
    var EdgeComponent = styled_components_default.div.attrs(
      ({ x, y, w, h }) => {
        return {
          style: {
            width: w,
            height: h,
            transform: `translate(${x}px, ${y}px)`
          }
        };
      }
    )`
    display: block;
    position: absolute;
    opacity: 0.35;
    pointer-events: none;
    background-color: ${(props) => props.appearance === "dropTarget" ? dashboard_ui_exports.customThemeVariables.validDropTargetBorderColor : dashboard_ui_exports.customThemeVariables.resizeHandleColor};
    ${EdgeWrapper}:hover + & {
        opacity: 0.7;
    }
`;
    var Edge = ({
      itemId,
      x,
      y,
      h,
      w,
      orientation,
      isCanvasEdge,
      padding = 0,
      appearance = "normal",
      onMouseDown,
      "data-test-edge-position": edgePositionTestHook
    }) => {
      const handleMouseDown = (0, react_exports.useCallback)(
        (e) => {
          e.preventDefault();
          e.stopPropagation();
          onMouseDown(e, { id: itemId });
        },
        [onMouseDown, itemId]
      );
      if (appearance === "hidden" || isCanvasEdge && appearance !== "dropTarget" && (orientation === "vertical" || y + padding === 0)) {
        return null;
      }
      const coord = { x, y, w, h };
      const shift = padding / 2;
      if (orientation === "horizontal") {
        coord.y += shift;
        coord.h -= padding;
      }
      if (orientation === "vertical") {
        coord.x += shift;
        coord.w -= padding;
      }
      return react_default.createElement(react_default.Fragment, null, react_default.createElement(
        EdgeWrapper,
        {
          x,
          y,
          w,
          h,
          orientation,
          appearance,
          onMouseDown: handleMouseDown,
          "data-test": "edge",
          "data-test-edge-position": edgePositionTestHook
        }
      ), react_default.createElement(
        EdgeComponent,
        {
          x: coord.x,
          y: coord.y,
          w: coord.w,
          h: coord.h,
          appearance
        }
      ));
    };
    var i18n_exports = {};
    __export(i18n_exports, {
      default: () => i18n_default
    });
    var defaultImport11 = __toESM2(require_i18n());
    __reExport(i18n_exports, require_i18n());
    var i18n_default = "default" in defaultImport11 ? defaultImport11.default : defaultImport11;
    var ErrorOverlay = styled_components_default.div`
    position: absolute;
    box-sizing: border-box;
    top: 0;
    left: 0;
    height: 100%;
    width: 100%;
    pointer-events: none;
    background-color: ${(0, dashboard_ui_exports.applyTranslucence)(
      themes_exports.variables.notificationColorNegativeWeak,
      0.85
    )};
    color: ${themes_exports.variables.contentColorActive};
    overflow: hidden;
    padding: 8px;
    z-index: 2;
`;
    var MessageContainer = styled_components_default.div`
    padding-top: 8px;
`;
    var OverlayTitle = styled_components_default.div`
    font-weight: bold;
`;
    var ErrorMessageOverlay = ({ messages }) => {
      if (!Array.isArray(messages) || messages.length === 0) {
        return null;
      }
      return react_default.createElement(ErrorOverlay, { "data-test": "error-overlay" }, react_default.createElement(OverlayTitle, null, (0, i18n_exports._)("Layout Errors:")), messages.map((message) => react_default.createElement(
        MessageContainer,
        {
          "data-test": "error-overlay-message",
          key: message
        },
        message
      )));
    };
    var defaultState2 = {
      startPosition: null,
      isMoving: false
    };
    var DEFAULT_SELECTED_LAYOUT_ITEMS2 = [];
    var noop2 = () => void 0;
    var GridCanvas = (props) => {
      const _a = props, {
        movable = false,
        selectable = false,
        selectedLayoutItems = DEFAULT_SELECTED_LAYOUT_ITEMS2,
        panelPadding = 0,
        scale = 1,
        onItemMove = noop2,
        onItemMoved = noop2,
        onItemSelected,
        children,
        canvasRef,
        blockItems
      } = _a, canvasProps = __objRest(_a, [
        "movable",
        "selectable",
        "selectedLayoutItems",
        "panelPadding",
        "scale",
        "onItemMove",
        "onItemMoved",
        "onItemSelected",
        "children",
        "canvasRef",
        "blockItems"
      ]);
      const { enableGridLayoutCssScaling } = (0, dashboard_context_exports.useFeatureFlags)();
      const startPositionRef = (0, react_exports.useRef)(defaultState2.startPosition);
      const isMovingRef = (0, react_exports.useRef)(defaultState2.isMoving);
      const { isMouseDownOnItemWithHandle, setIsMouseDownOnItemWithHandle } = (0, dashboard_context_exports.useMouseEventsContext)();
      const resetState = (0, react_exports.useCallback)(() => {
        isMovingRef.current = defaultState2.isMoving;
        startPositionRef.current = defaultState2.startPosition;
      }, []);
      const mouseScale = enableGridLayoutCssScaling ? scale : 1;
      const handleItemSelected = (0, react_exports.useCallback)(
        (e, itemIds = []) => {
          if (itemIds.some(
            ({ id, type }) => {
              var _a2;
              return type === "input" && ((_a2 = findStatusIcon({ canvasRef, id })) == null ? void 0 : _a2.contains(
                e.target
              ));
            }
          )) {
            return;
          }
          if (e.metaKey) {
            const selectedItems = selectedLayoutItems.filter(
              ({ type }) => type === "block"
            );
            onItemSelected(e, (0, lodash_exports.uniqBy)([...selectedItems, ...itemIds], "id"));
          } else {
            onItemSelected(e, itemIds);
          }
        },
        [canvasRef, selectedLayoutItems, onItemSelected]
      );
      const handleMouseDownOnItem = (0, react_exports.useCallback)(
        (event, blockItem) => {
          const { id, type = "block" } = blockItem;
          if (!selectedLayoutItems.find(
            ({ id: selectedId }) => selectedId === id
          )) {
            handleItemSelected(event, [{ id, type }]);
          }
        },
        [handleItemSelected, selectedLayoutItems]
      );
      const handleMouseDown = (0, react_exports.useCallback)(
        (e) => {
          if (isMouseDownOnItemWithHandle == null ? void 0 : isMouseDownOnItemWithHandle.current) {
            setIsMouseDownOnItemWithHandle(false);
            return;
          }
          const pos = computeRelativePosition(e, canvasRef, mouseScale);
          const block = findTopBlockItemByPosition(
            blockItems,
            pos,
            panelPadding
          );
          if (selectable) {
            startPositionRef.current = pos;
          }
          if (block) {
            handleMouseDownOnItem(e, {
              id: block.item,
              type: block.type
            });
            if (movable) {
              isMovingRef.current = true;
            }
          }
        },
        [
          isMouseDownOnItemWithHandle,
          canvasRef,
          mouseScale,
          blockItems,
          panelPadding,
          selectable,
          setIsMouseDownOnItemWithHandle,
          handleMouseDownOnItem,
          movable
        ]
      );
      const handleMouseMove = (0, dashboard_ui_exports.useEventCallback)((e) => {
        if (startPositionRef.current) {
          const currentPosition = computeRelativePosition(
            e,
            canvasRef,
            mouseScale
          );
          if (currentPosition) {
            const offset = getOffset(
              currentPosition,
              startPositionRef.current
            );
            if (isMovingRef.current && considerMoved(offset)) {
              e.preventDefault();
              onItemMove(e, { currentPosition });
            }
          }
        }
      });
      const handleMouseUp = (0, dashboard_ui_exports.useEventCallback)((e) => {
        if (startPositionRef.current) {
          const currentPosition = computeRelativePosition(
            e,
            canvasRef,
            mouseScale
          );
          if (currentPosition) {
            const offset = getOffset(
              currentPosition,
              startPositionRef.current
            );
            if (isMovingRef.current && considerMoved(offset)) {
              onItemMoved(e, offset);
            } else {
              let blocks = blockItems;
              if (panelPadding) {
                blocks = blocks.map(
                  (block) => applyVizPadding({
                    item: block,
                    padding: panelPadding
                  })
                );
              }
              const boundary = positionsToBoundary(
                startPositionRef.current,
                currentPosition
              );
              const selectedBlocks = filterBlockItemsByBoundary(
                blocks,
                boundary
              ).map(({ item, type = "block" }) => ({
                id: item,
                type
              }));
              const topItem = selectedBlocks[selectedBlocks.length - 1];
              handleItemSelected(e, topItem ? [topItem] : []);
            }
            resetState();
          }
        }
      });
      const setStartPosition = (0, react_exports.useCallback)((pos) => {
        startPositionRef.current = pos;
      }, []);
      useMouseDownWithHandleEventListeners({
        handleMouseDownOnItem,
        canvasRef,
        scale: mouseScale,
        setStartPosition,
        movable,
        isMovingRef
      });
      (0, react_exports.useEffect)(() => {
        document.addEventListener("mouseup", handleMouseUp);
        return () => {
          document.removeEventListener("mouseup", handleMouseUp);
        };
      }, [handleMouseUp]);
      (0, dashboard_ui_exports.useMouseMoveHandler)({ onMouseMove: handleMouseMove, isEnabled: movable });
      return react_default.createElement(
        Canvas_default,
        __spreadProps(__spreadValues({
          ref: canvasRef
        }, canvasProps), {
          scale,
          onMouseDown: handleMouseDown,
          onContextMenu: resetState,
          cssScaling: enableGridLayoutCssScaling,
          showGrid: false
        }),
        children
      );
    };
    var GridCanvas_default = (0, react_exports.forwardRef)(
      (props, ref) => react_default.createElement(GridCanvas, __spreadValues({ canvasRef: ref }, props))
    );
    var GridDiv = styled_components_default.div`
    height: 100%;
    width: 100%;
    grid-row: ${(props) => props.id}-start / ${(props) => props.id}-end;
    grid-column: ${(props) => props.id}-start / ${(props) => props.id}-end;
    background: transparent;
`;
    var GridItem = ({
      itemId,
      type = "block",
      renderLayoutItem
    }) => react_default.createElement(GridDiv, { id: itemId, "data-test": "grid-item" }, renderLayoutItem(itemId, { width: "100%", height: "100%" }, type));
    GridItem.propTypes = {
      itemId: prop_types_default.string.isRequired,
      type: prop_types_default.string,
      renderLayoutItem: prop_types_default.func.isRequired
    };
    var GridItem_default = GridItem;
    var Placeholder = styled_components_default.div.attrs(
      ({ position }) => ({
        style: positionToStyle(position)
      })
    )`
    background-color: ${themes_exports.variables.interactiveColorOverlayDrag};
    opacity: 0.75;
    user-select: none;
    position: absolute;
    flex-direction: column;
    top: 0;
    left: 0;
    cursor: move;
`;
    var ItemDragPlaceholder = ({
      position,
      size = 128
    }) => {
      const placeHolderPosition = (0, react_exports.useMemo)(() => {
        return {
          // update x and y to be the center of the placeholder
          x: position.x - Math.round(size / 2),
          y: position.y - Math.round(size / 2),
          w: size,
          h: size
        };
      }, [position, size]);
      return react_default.createElement(
        Placeholder,
        {
          "data-test": "item-drag-placeholder",
          position: placeHolderPosition
        }
      );
    };
    var CLONE_LAYOUT_ITEMS_MSG_PANEL_TOO_SMALL = (0, i18n_exports._)(
      "This panel is too small to be split into duplicates. Stretch or move the panel to make it bigger first."
    );
    var EDGE_THICKNESS_PX = 4;
    var GRID_PADDING_PX = 1;
    var GRID_SIZE_PX = 10;
    var MIN_HEIGHT_PX = 64;
    var MIN_WIDTH_PX = 64;
    var SNAP_RANGE_PX = 8;
    var PLACEHOLDER_SIZE_PX = 128;
    var ITEM_DROP_TARGET_PX = 12;
    var VIZ_DEFAULT_HEIGHT_PX = 400;
    var VIZ_PREVIEW_DELAY_MS = 50;
    var EDGE_PREVIEW_DELAY_MS = 500;
    var DropTarget = styled_components_default.div.attrs(({ position }) => ({
      style: positionToStyle(position)
    }))`
    background-color: ${(0, themes_exports.pickVariant)("validDropTarget", {
      true: dashboard_ui_exports.customThemeVariables.validDropTargetBackgroundColor,
      false: themes_exports.variables.notificationColorNegative
    })};
    border-width: '1px';
    border-style: 'solid';
    border-color: ${(0, themes_exports.pickVariant)("validDropTarget", {
      true: dashboard_ui_exports.customThemeVariables.validDropTargetBorderColor,
      false: themes_exports.variables.severityColorAlert
    })};
    user-select: none;
    position: absolute;
    pointer-events: none;
`;
    var ItemDropTarget = ({ position, direction }) => {
      const validDropTarget = (direction === "e" || direction === "w") && position.w >= 128 || (direction === "n" || direction === "s") && position.h >= 128;
      const dropTargetPosition = (0, react_exports.useMemo)(() => {
        let updatedPosition = null;
        switch (direction) {
          case "n":
            updatedPosition = __spreadProps(__spreadValues({}, position), {
              h: ITEM_DROP_TARGET_PX
            });
            break;
          case "s":
            updatedPosition = __spreadProps(__spreadValues({}, position), {
              y: position.y + position.h - ITEM_DROP_TARGET_PX,
              h: ITEM_DROP_TARGET_PX
            });
            break;
          case "w":
            updatedPosition = __spreadProps(__spreadValues({}, position), {
              w: ITEM_DROP_TARGET_PX
            });
            break;
          case "e":
            updatedPosition = __spreadProps(__spreadValues({}, position), {
              x: position.x + position.w - ITEM_DROP_TARGET_PX,
              w: ITEM_DROP_TARGET_PX
            });
            break;
          default:
            updatedPosition = position;
            break;
        }
        return updatedPosition;
      }, [position, direction]);
      if (validDropTarget) {
        return null;
      }
      return react_default.createElement(
        DropTarget,
        {
          "data-test": "item-drop-target",
          position: dropTargetPosition,
          validDropTarget
        }
      );
    };
    ItemDropTarget.propTypes = {
      position: prop_types_default.shape({
        x: prop_types_default.number.isRequired,
        y: prop_types_default.number.isRequired,
        w: prop_types_default.number.isRequired,
        h: prop_types_default.number.isRequired
      }).isRequired,
      direction: prop_types_default.oneOf(["n", "s", "w", "e"]).isRequired
    };
    var Layer = styled_components_default.div`
    position: absolute;
    top: 0px;
    left: 0px;
    right: 0px;
    bottom: 0px;
    pointer-events: none;
    z-index: ${(props) => props.zIndex};
`;
    var Layer_default = Layer;
    var Plus_exports = {};
    __export(Plus_exports, {
      default: () => Plus_default
    });
    var defaultImport12 = __toESM2(require_Plus());
    __reExport(Plus_exports, require_Plus());
    var Plus_default = "default" in defaultImport12 ? defaultImport12.default : defaultImport12;
    var format_exports = {};
    __export(format_exports, {
      default: () => format_default
    });
    var defaultImport13 = __toESM2(require_format());
    __reExport(format_exports, require_format());
    var format_default = "default" in defaultImport13 ? defaultImport13.default : defaultImport13;
    var getVerticalPosition = (dir, offset) => {
      if (dir[0] === "n") {
        return `top: -${offset}px`;
      }
      if (dir[0] === "s") {
        return `bottom: -${offset}px`;
      }
      return `top: calc(50% - ${offset}px)`;
    };
    var getHorizontalPosition = (dir, offset) => {
      if (dir.slice(-1) === "w") {
        return `left: -${offset}px`;
      }
      if (dir.slice(-1) === "e") {
        return `right: -${offset}px`;
      }
      return `left: calc(50% - ${offset}px)`;
    };
    var portOffset = 8;
    var PORT_DIRECTIONS = ["n", "e", "s", "w"];
    var PortContainer = styled_components_default.div.attrs(({ port }) => ({
      "data-test": "port",
      "data-test-port": port,
      "aria-label": (0, format_exports.sprintf)((0, i18n_exports._)("Port %s"), port)
    }))`
    display: flex;
    justify-content: center;
    align-items: center;
    width: 16px;
    height: 16px;
    box-sizing: border-box;
    border-radius: 50%;
    position: absolute;
    color: ${dashboard_ui_exports.customThemeVariables.resizeHandleColor};
    ${({ port }) => getVerticalPosition(port, portOffset)};
    ${({ port }) => getHorizontalPosition(port, portOffset)};
    z-index: 999;
    pointer-events: auto;
    user-select: none;
    &:hover {
        background-color: ${dashboard_ui_exports.customThemeVariables.resizeHandleColor};
    }
`;
    var Port = ({
      port,
      onMouseEnter,
      onMouseLeave
    }) => react_default.createElement(
      PortContainer,
      {
        port,
        onMouseEnter,
        onMouseLeave
      },
      react_default.createElement(Plus_default, { "data-test": "plus-glyph" })
    );
    var PlaceholderComponent = styled_components_default.div.attrs(({ position }) => ({
      style: {
        width: position.w,
        height: position.h,
        transform: `translate(${position.x}px, ${position.y}px)`
      }
    }))`
    display: block;
    position: absolute;
    pointer-events: none;
    box-sizing: border-box;
    border: 1px solid ${dashboard_ui_exports.customThemeVariables.validDropTargetBorderColor};
    background-color: ${dashboard_ui_exports.customThemeVariables.validDropTargetBackgroundColor};
`;
    var PreviewPlaceholderItem = ({ position }) => {
      return react_default.createElement(
        PlaceholderComponent,
        {
          position,
          "data-test": "preview-placeholder",
          "data-test-preview-position": `${position.x},${position.y}-${position.w},${position.h}`
        }
      );
    };
    PreviewPlaceholderItem.propTypes = {
      position: prop_types_default.shape({
        x: prop_types_default.number.isRequired,
        y: prop_types_default.number.isRequired,
        w: prop_types_default.number.isRequired,
        h: prop_types_default.number.isRequired
      }).isRequired
    };
    var resizeHandleOffset = 7;
    var computeCursor = (dir) => {
      switch (dir) {
        case "n":
        case "s":
          return "ns-resize";
        case "e":
        case "w":
          return "ew-resize";
        case "ne":
        case "sw":
          return "nesw-resize";
        case "se":
        case "nw":
        default:
          return "nwse-resize";
      }
    };
    var computeDirection = (dir) => {
      switch (dir) {
        case "n":
          return (0, i18n_exports._)("North");
        case "s":
          return (0, i18n_exports._)("South");
        case "e":
          return (0, i18n_exports._)("East");
        case "w":
          return (0, i18n_exports._)("West");
        case "ne":
          return (0, i18n_exports._)("North-East");
        case "sw":
          return (0, i18n_exports._)("South-West");
        case "se":
          return (0, i18n_exports._)("South-East");
        case "nw":
          return (0, i18n_exports._)("North-West");
        default:
          return "";
      }
    };
    var Handle = styled_components_default.button.attrs(({ direction }) => ({
      "data-test": "handle",
      "data-test-direction": direction
    }))`
    width: 10px;
    height: 10px;
    background-color: ${dashboard_ui_exports.customThemeVariables.resizeHandleColor};
    border: none;
    border-radius: 20%;
    padding: 0;
    position: absolute;
    ${({ direction }) => getVerticalPosition(direction, resizeHandleOffset)};
    ${({ direction }) => getHorizontalPosition(direction, resizeHandleOffset)};
    cursor: ${({ direction }) => computeCursor(direction)};
    z-index: 999;
    pointer-events: auto;
    user-select: none;
`;
    var ResizeHandle = ({
      onMouseDown,
      onKeyDown,
      direction
    }) => {
      const handleMouseDown = (0, react_exports.useCallback)(
        (e) => {
          onMouseDown(e, direction);
        },
        [onMouseDown, direction]
      );
      const handleKeyDown = (0, react_exports.useCallback)(
        (e) => {
          onKeyDown(e, direction);
        },
        [onKeyDown, direction]
      );
      return react_default.createElement(
        Handle,
        {
          "aria-label": (0, format_exports.sprintf)((0, i18n_exports._)("Move %(direction)s direction"), {
            direction: computeDirection(direction)
          }),
          direction,
          onMouseDown: handleMouseDown,
          onKeyDown: handleKeyDown
        }
      );
    };
    var ResponsiveBox = styled_components_default.div.attrs(
      ({ itemId, x, y, w, h, "data-test": dataTest, zIndex }) => {
        const attributes = {
          "data-test": dataTest != null ? dataTest : "responsive-box",
          "data-id": itemId,
          "data-test-viz-item-position": `${x},${y},${w},${h}`,
          style: {
            width: `${w}px`,
            height: `${h}px`,
            top: `${y}px`,
            left: `${x}px`,
            zIndex
          }
        };
        if (!zIndex) {
          delete attributes.style.zIndex;
        }
        return attributes;
      }
    )`
    display: block;
    position: absolute;
    background: transparent;
    pointer-events: none;
    box-sizing: border-box;
    visibility: ${(props) => {
      return props.appearance === "hidden" ? "hidden" : "visible";
    }};
    opacity: ${(props) => props.appearance === "highlighted" ? 1 : 0.5};
`;
    ResponsiveBox.defaultProps = {
      appearance: "highlighted"
    };
    var ResponsiveBox_default = ResponsiveBox;
    var DragHandlePortal = styled_components_default.div.attrs(
      (props) => ({
        "data-test": "drag-handle-portal",
        style: {
          width: props.w,
          top: props.y,
          left: props.x
        }
      })
    )`
    display: block;
    position: absolute;
    background: transparent;
    pointer-events: all;
    box-sizing: border-box;
    height: 0px;
    z-index: ${(props) => props.zIndex};
    visibility: ${({ isHidden }) => isHidden ? "hidden" : "visible"};
`;
    var defaultPortalState = Object.freeze({
      current: null
    });
    var ResponsiveBlockItem = ({
      x: originalX,
      y: originalY,
      w: originalW,
      h: originalH,
      canvasHeight,
      padding,
      itemId,
      type = "block",
      errorMessages,
      onItemSelected,
      renderLayoutItem,
      appearance = "highlighted",
      isMouseDownEventRef
    }) => {
      var _a;
      const selectIsSelected = (0, react_exports.useMemo)(dashboard_state_exports.makeSelectIsSelected, []);
      const mode = (0, dashboard_state_exports.useSelector)(dashboard_state_exports.selectMode);
      const isSelected = (0, dashboard_state_exports.useSelector)((state) => selectIsSelected(state, itemId));
      const [isClicked, setIsClicked] = (0, react_exports.useState)(false);
      const [actionMenuPortal, setActionMenuPortal] = (0, react_exports.useState)(defaultPortalState);
      const [dragHandlePortal, setDragHandlePortal] = (0, react_exports.useState)(defaultPortalState);
      const layerData = (0, dashboard_context_exports.useLayoutLayers)();
      const {
        layer: itemLayer,
        actionMenu: actionMenuLayer,
        dragHandle: dragHandleLayer
      } = (_a = layerData == null ? void 0 : layerData[itemId]) != null ? _a : {};
      const renderActionMenuInPortal = typeof itemLayer === "number";
      const {
        position: { x, y, w, h }
      } = applyVizPadding({
        item: {
          position: {
            x: originalX,
            y: originalY,
            w: originalW,
            h: originalH
          }
        },
        padding
      });
      const layoutItem = (0, react_exports.useMemo)(
        () => renderLayoutItem(
          itemId,
          {
            width: w,
            height: h,
            y,
            canvasHeight,
            renderActionMenuInPortal,
            actionMenuPortal,
            dragHandlePortal
          },
          type,
          onItemSelected
        ),
        [
          renderLayoutItem,
          itemId,
          type,
          w,
          h,
          y,
          canvasHeight,
          onItemSelected,
          renderActionMenuInPortal,
          actionMenuPortal,
          dragHandlePortal
        ]
      );
      const handleFocus = (0, react_exports.useCallback)(
        (event) => {
          if (isMouseDownEventRef == null ? void 0 : isMouseDownEventRef.current) {
            setIsClicked(true);
            return;
          }
          if (!event.relatedTarget) {
            return;
          }
          setIsClicked(false);
          if (
            // The tabindex was moved to the SelectableContainer (in renderLayoutItem), so we'll check that thats the target
            event.target.getAttribute("data-test") === "select-outline" && event.target.getAttribute("data-id") === itemId
          ) {
            onItemSelected(event, [{ id: itemId, type }]);
          }
        },
        [isMouseDownEventRef, itemId, onItemSelected, type]
      );
      const trackActionMenuPortal = (0, react_exports.useCallback)((element) => {
        setActionMenuPortal({ current: element });
      }, []);
      const trackDragHandlePortal = (0, react_exports.useCallback)((element) => {
        setDragHandlePortal({ current: element });
      }, []);
      const isHidden = appearance === "hidden";
      return react_default.createElement(
        dashboard_ui_exports.AbsoluteItemContainer,
        {
          "data-id": itemId,
          "data-selected": `${isSelected}`,
          "data-click-focus": `${isClicked && isSelected && mode === "view"}`
        },
        react_default.createElement(
          ResponsiveBox_default,
          {
            "data-test": "absolute-item",
            itemId,
            appearance,
            x,
            y,
            w,
            h,
            onFocusCapture: handleFocus
          },
          layoutItem,
          react_default.createElement(ErrorMessageOverlay, { messages: errorMessages })
        ),
        renderActionMenuInPortal && react_default.createElement(
          ActionMenuPortal_default,
          {
            x,
            y,
            w,
            h,
            ref: trackActionMenuPortal,
            zIndex: actionMenuLayer
          }
        ),
        react_default.createElement(
          DragHandlePortal,
          {
            x,
            y,
            w,
            ref: trackDragHandlePortal,
            zIndex: dragHandleLayer,
            isHidden
          }
        )
      );
    };
    var ResponsiveBlockItem_default = react_default.memo(ResponsiveBlockItem);
    var keyDirectionMap = {
      ArrowUp: ["n", "ne", "se", "s", "sw", "nw"],
      ArrowDown: ["n", "ne", "se", "s", "sw", "nw"],
      ArrowLeft: ["ne", "e", "se", "sw", "w", "nw"],
      ArrowRight: ["ne", "e", "se", "sw", "w", "nw"]
    };
    var isKeyAllowedCheck = (key) => Object.keys(keyDirectionMap).includes(key);
    var noop3 = () => void 0;
    var ResponsiveBlockOutline = ({
      itemId,
      scale = 1,
      connectable = false,
      resizable = false,
      onResize = noop3,
      onResized = noop3,
      onLineConnect = noop3,
      onLineDisconnect = noop3,
      handleDirections,
      x,
      y,
      w,
      h
    }) => {
      const startPosition = (0, react_exports.useRef)(
        null
      );
      const resizing = (0, react_exports.useRef)(false);
      const resizeDir = (0, react_exports.useRef)(null);
      const keyUpOffset = (0, react_exports.useRef)({ offsetX: 0, offsetY: 0 });
      const handleResizeMouseDown = (0, react_exports.useCallback)(
        (e, dir) => {
          e.preventDefault();
          e.stopPropagation();
          startPosition.current = getClientPosition(e, scale);
          resizing.current = true;
          resizeDir.current = dir;
        },
        [scale]
      );
      const handleMouseMove = (0, react_exports.useCallback)(
        (e) => {
          if (startPosition.current && resizing.current && resizeDir.current) {
            e.preventDefault();
            const currentPosition = getClientPosition(e, scale);
            const offset = getOffset(
              currentPosition,
              startPosition.current
            );
            onResize(e, itemId, offset, resizeDir.current);
          }
        },
        [scale, onResize, itemId]
      );
      const handleMouseUp = (0, react_exports.useCallback)(
        (e) => {
          if (startPosition.current && resizing.current && resizeDir.current) {
            e.preventDefault();
            const currentPosition = getClientPosition(e, scale);
            const offset = getOffset(
              currentPosition,
              startPosition.current
            );
            startPosition.current = null;
            resizing.current = false;
            onResized(e, itemId, offset, resizeDir.current);
            resizeDir.current = null;
          }
        },
        [itemId, scale, onResized]
      );
      const handleResizeKeyDown = (0, react_exports.useCallback)(
        (e, dir) => {
          const { key } = e;
          const isKeyAllowed = isKeyAllowedCheck(key);
          const isDirectionAllowed = isKeyAllowed && keyDirectionMap[key].includes(dir);
          if (!isDirectionAllowed) {
            return;
          }
          e.preventDefault();
          e.stopPropagation();
          resizeDir.current = dir;
          if (e.key === "ArrowUp") {
            keyUpOffset.current.offsetY -= GRID_SIZE;
          }
          if (e.key === "ArrowDown") {
            keyUpOffset.current.offsetY += GRID_SIZE;
          }
          if (e.key === "ArrowLeft") {
            keyUpOffset.current.offsetX -= GRID_SIZE;
          }
          if (e.key === "ArrowRight") {
            keyUpOffset.current.offsetX += GRID_SIZE;
          }
          onResize(e, itemId, keyUpOffset.current, dir);
        },
        [itemId, onResize]
      );
      const handleKeyUp = (0, react_exports.useCallback)(
        (e) => {
          if (keyUpOffset.current && resizeDir.current) {
            onResized(e, itemId, keyUpOffset.current, resizeDir.current);
            resizeDir.current = null;
            keyUpOffset.current = { offsetX: 0, offsetY: 0 };
          }
        },
        [itemId, onResized]
      );
      const handlePortEnter = (0, react_exports.useCallback)(
        (port) => (e) => {
          e.preventDefault();
          onLineConnect(itemId, port);
        },
        [itemId, onLineConnect]
      );
      const handlePortLeave = (0, react_exports.useCallback)(
        (port) => (e) => {
          e.preventDefault();
          onLineDisconnect(itemId, port);
        },
        [itemId, onLineDisconnect]
      );
      (0, react_exports.useLayoutEffect)(() => {
        if (resizable) {
          document.addEventListener("mousemove", handleMouseMove);
        }
        return () => {
          document.removeEventListener("mousemove", handleMouseMove);
        };
      }, [resizable, handleMouseMove]);
      (0, react_exports.useLayoutEffect)(() => {
        if (resizable) {
          document.addEventListener("mouseup", handleMouseUp);
        }
        return () => {
          document.removeEventListener("mouseup", handleMouseUp);
        };
      }, [resizable, handleMouseUp]);
      (0, react_exports.useLayoutEffect)(() => {
        if (resizable) {
          document.addEventListener("keyup", handleKeyUp);
        }
        return () => {
          document.removeEventListener("keyup", handleKeyUp);
        };
      }, [resizable, handleKeyUp]);
      const ResizeHandles = (0, react_exports.useMemo)(() => {
        if (!resizable) {
          return null;
        }
        return handleDirections.map((dir) => react_default.createElement(
          ResizeHandle,
          {
            key: `handle-${dir}`,
            onMouseDown: handleResizeMouseDown,
            onKeyDown: handleResizeKeyDown,
            direction: dir
          }
        ));
      }, [
        resizable,
        handleDirections,
        handleResizeMouseDown,
        handleResizeKeyDown
      ]);
      const Ports = (0, react_exports.useMemo)(() => {
        if (!connectable) {
          return null;
        }
        return PORT_DIRECTIONS.map((port) => react_default.createElement(
          Port,
          {
            key: `port-${port}`,
            port,
            onMouseEnter: handlePortEnter(port),
            onMouseLeave: handlePortLeave(port)
          }
        ));
      }, [connectable, handlePortEnter, handlePortLeave]);
      return react_default.createElement(ResponsiveBox_default, { itemId, x, y, w, h }, ResizeHandles, Ports);
    };
    var ResponsiveBlockOutline_default = ResponsiveBlockOutline;
    var allowedKeys = ["ArrowDown", "ArrowUp", "ArrowLeft", "ArrowRight"];
    var LineBox = styled_components_default.div`
    position: absolute;
    pointer-events: none;
    z-index: ${(props) => props.zIndex};
`;
    var AdjustHandle = styled_components_default.button.attrs(({ x, y }) => ({
      style: {
        transform: `translate(${x}px, ${y}px)`
      }
    }))`
    width: 10px;
    height: 10px;
    left: -5px;
    top: -5px;
    background-color: ${dashboard_ui_exports.customThemeVariables.resizeHandleColor};
    border: none;
    padding: 0;
    border-radius: 50%;
    position: absolute;
    z-index: 999;
    pointer-events: auto;
    cursor: move;
    user-select: none;
`;
    var ResponsiveLine = ({
      fromX,
      fromY,
      fromItem,
      fromPort,
      toX,
      toY,
      toItem,
      toPort,
      lineId,
      scale = 1,
      selectable = false,
      editable = false,
      renderLayoutItem,
      onItemSelected = dashboard_utils_exports.noop,
      onLineDragStart = dashboard_utils_exports.noop,
      onLineMove = dashboard_utils_exports.noop,
      onLineMoved = dashboard_utils_exports.noop,
      onLineDrag = dashboard_utils_exports.noop,
      onLineDragged = dashboard_utils_exports.noop
    }) => {
      const startPositionRef = (0, react_exports.useRef)(null);
      const actionRef = (0, react_exports.useRef)(null);
      const keyUpOffset = (0, react_exports.useRef)({ offsetX: 0, offsetY: 0 });
      const layerData = (0, dashboard_context_exports.useLayoutLayers)();
      const lineLayer = (0, react_exports.useMemo)(() => {
        const selectionLayer = Object.values(layerData != null ? layerData : {}).map((entry) => entry.selection).filter(Boolean)[0];
        return typeof selectionLayer === "number" ? selectionLayer + 1 : void 0;
      }, [layerData]);
      const handleLineSelected = (0, react_exports.useCallback)(
        (e) => {
          e.stopPropagation();
          startPositionRef.current = getClientPosition(e, scale);
          actionRef.current = "move";
          onItemSelected(e, [{ id: lineId, type: "line" }]);
        },
        [lineId, onItemSelected, scale]
      );
      const handleLineSelectedOnEnter = (0, react_exports.useCallback)(
        (e) => {
          if (e.key === "Enter") {
            onItemSelected(e, [{ id: lineId, type: "line" }]);
          }
        },
        [lineId, onItemSelected]
      );
      const handleKeyDown = (0, react_exports.useCallback)(
        (e) => {
          e.preventDefault();
          if (e.key === "ArrowUp") {
            keyUpOffset.current.offsetY -= 1;
          }
          if (e.key === "ArrowDown") {
            keyUpOffset.current.offsetY += 1;
          }
          if (e.key === "ArrowLeft") {
            keyUpOffset.current.offsetX -= 1;
          }
          if (e.key === "ArrowRight") {
            keyUpOffset.current.offsetX += 1;
          }
          onLineDrag(e, keyUpOffset.current);
        },
        [onLineDrag]
      );
      const handleKeyDownFrom = (0, react_exports.useCallback)(
        (e) => {
          if (!allowedKeys.includes(e.key)) {
            return;
          }
          if (keyUpOffset.current.offsetX === 0 && keyUpOffset.current.offsetY === 0) {
            onLineDragStart(e, "from");
          }
          handleKeyDown(e);
        },
        [onLineDragStart, handleKeyDown]
      );
      const handleKeyDownTo = (0, react_exports.useCallback)(
        (e) => {
          if (!allowedKeys.includes(e.key)) {
            return;
          }
          if (keyUpOffset.current.offsetX === 0 && keyUpOffset.current.offsetY === 0) {
            onLineDragStart(e, "to");
          }
          handleKeyDown(e);
        },
        [onLineDragStart, handleKeyDown]
      );
      const handleKeyUp = (0, react_exports.useCallback)(
        (e) => {
          var _a, _b, _c;
          const isLineHandleFocused = ((_a = document.activeElement) == null ? void 0 : _a.tagName) === "BUTTON" && ((_c = (_b = document.activeElement) == null ? void 0 : _b.getAttribute("data-test")) == null ? void 0 : _c.startsWith("line-handle"));
          if (!allowedKeys.includes(e.key) || keyUpOffset.current.offsetX === 0 && keyUpOffset.current.offsetY === 0 || !isLineHandleFocused) {
            return;
          }
          onLineDragged(e, keyUpOffset.current);
          keyUpOffset.current = { offsetX: 0, offsetY: 0 };
        },
        [onLineDragged]
      );
      const handleMouseDownFrom = (0, react_exports.useCallback)(
        (e) => {
          e.stopPropagation();
          startPositionRef.current = getClientPosition(e, scale);
          actionRef.current = "drag";
          onLineDragStart(e, "from");
        },
        [onLineDragStart, scale]
      );
      const handleMouseDownTo = (0, react_exports.useCallback)(
        (e) => {
          e.stopPropagation();
          startPositionRef.current = getClientPosition(e, scale);
          actionRef.current = "drag";
          onLineDragStart(e, "to");
        },
        [onLineDragStart, scale]
      );
      const handleMouseUp = (0, react_exports.useCallback)(
        (e) => {
          if (!startPositionRef.current || !actionRef.current) {
            return;
          }
          const currentPosition = getClientPosition(e, scale);
          const offset = getOffset(currentPosition, startPositionRef.current);
          startPositionRef.current = null;
          if (!offset.offsetX && !offset.offsetY || !editable) {
            return;
          }
          switch (actionRef.current) {
            case "drag":
              onLineDragged(e, offset);
              break;
            case "move":
              onLineMoved(e, offset);
              break;
            default:
              break;
          }
          actionRef.current = null;
        },
        [editable, onLineDragged, onLineMoved, scale]
      );
      const handleMouseMove = (0, react_exports.useCallback)(
        (e) => {
          if (startPositionRef.current == null || actionRef.current == null) {
            return;
          }
          if (e.buttons <= 0 || e.buttons % 2 === 0) {
            handleMouseUp(e);
            return;
          }
          e.preventDefault();
          const currentPosition = getClientPosition(e, scale);
          const offset = getOffset(currentPosition, startPositionRef.current);
          if (!offset.offsetX && !offset.offsetY || !editable) {
            return;
          }
          switch (actionRef.current) {
            case "drag":
              onLineDrag(e, offset);
              break;
            case "move":
              onLineMove(e, offset);
              break;
            default:
              break;
          }
        },
        [editable, handleMouseUp, onLineDrag, onLineMove, scale]
      );
      const from = { x: fromX, y: fromY };
      const to = { x: toX, y: toY };
      const boxPos = computeLineBoxPosition(from, to);
      const relativePos = computeLineRelativePosition(from, to, boxPos);
      const lineBoxStyle = (0, react_exports.useMemo)(
        () => ({
          transform: `translate(${boxPos.x}px, ${boxPos.y}px)`
        }),
        [boxPos.x, boxPos.y]
      );
      const fromHandleElement = (0, react_exports.useMemo)(() => {
        if (!editable) {
          return null;
        }
        return react_default.createElement(
          AdjustHandle,
          {
            "data-test": "line-handle-from",
            "data-test-item": fromItem,
            "data-test-port": fromPort,
            x: relativePos.from.x,
            y: relativePos.from.y,
            onMouseDown: handleMouseDownFrom,
            onKeyDown: handleKeyDownFrom,
            "aria-label": (0, i18n_exports._)("From line handle")
          }
        );
      }, [
        editable,
        fromItem,
        fromPort,
        relativePos.from.x,
        relativePos.from.y,
        handleMouseDownFrom,
        handleKeyDownFrom
      ]);
      const toHandleElement = (0, react_exports.useMemo)(() => {
        if (!editable) {
          return null;
        }
        return react_default.createElement(
          AdjustHandle,
          {
            "data-test": "line-handle-to",
            "data-test-item": toItem,
            "data-test-port": toPort,
            x: relativePos.to.x,
            y: relativePos.to.y,
            onMouseDown: handleMouseDownTo,
            onKeyDown: handleKeyDownTo,
            "aria-label": (0, i18n_exports._)("To line handle")
          }
        );
      }, [
        editable,
        toItem,
        toPort,
        relativePos.to.x,
        relativePos.to.y,
        handleMouseDownTo,
        handleKeyDownTo
      ]);
      const lineElement = (0, react_exports.useMemo)(
        () => renderLayoutItem(
          lineId,
          {
            from: {
              x: relativePos.from.x,
              y: relativePos.from.y
            },
            to: {
              x: relativePos.to.x,
              y: relativePos.to.y
            },
            // todo: this is inconsistent with the ResponsiveBlockItem which accepts the `onSelect` callback as the 4th argument of `renderLayoutItem`.
            onLineSelect: selectable ? handleLineSelected : dashboard_utils_exports.noop
          },
          "line"
        ),
        [
          handleLineSelected,
          lineId,
          relativePos.from.x,
          relativePos.from.y,
          relativePos.to.x,
          relativePos.to.y,
          renderLayoutItem,
          selectable
        ]
      );
      (0, react_exports.useEffect)(() => {
        document.addEventListener("mousemove", handleMouseMove);
        document.addEventListener("mouseup", handleMouseUp);
        return () => {
          document.removeEventListener("mousemove", handleMouseMove);
          document.removeEventListener("mouseup", handleMouseUp);
        };
      }, [handleMouseMove, handleMouseUp]);
      (0, react_exports.useEffect)(() => {
        if (editable) {
          document.addEventListener("keyup", handleKeyUp);
        }
        return () => {
          document.removeEventListener("keyup", handleKeyUp);
        };
      }, [editable, handleKeyUp]);
      return react_default.createElement(
        LineBox,
        {
          "data-test": "line-box",
          tabIndex: !editable ? 0 : void 0,
          onKeyDown: handleLineSelectedOnEnter,
          style: lineBoxStyle,
          "data-viz-type": "abslayout.line",
          "data-id": lineId,
          "data-test-line-position": `${from.x},${from.y}-${to.x},${to.y}`,
          zIndex: lineLayer
        },
        fromHandleElement,
        toHandleElement,
        lineElement
      );
    };
    var ResponsiveLine_default = ResponsiveLine;
    var absoluteLayoutOptions = {
      width: dashboard_utils_exports.DEFAULT_CANVAS_WIDTH,
      height: dashboard_utils_exports.DEFAULT_CANVAS_HEIGHT,
      display: "auto"
    };
    var gridLayoutOptions = {
      width: dashboard_utils_exports.DEFAULT_CANVAS_WIDTH,
      gutterSize: 8
    };
    var findSelectedBlockItems = ({
      layoutStructure,
      selectedItems
    }) => layoutStructure.filter(
      (item) => selectedItems.findIndex(
        ({ id }) => item.item === id && (0, dashboard_utils_exports.isBlockItem)(item)
      ) >= 0
    );
    var getAllBlockItems = ({
      layoutStructure,
      layoutStructureState = {}
    }) => {
      return layoutStructure.map((item) => {
        var _a;
        return (_a = layoutStructureState[item.item]) != null ? _a : item;
      }).filter((item) => (0, dashboard_utils_exports.isBlockItem)(item));
    };
    var computePortPosition = (blockItem, port) => {
      const blockPosition = blockItem.position;
      switch (port) {
        case "n":
          return {
            x: Math.round(blockPosition.x + blockPosition.w / 2),
            y: blockPosition.y
          };
        case "w":
          return {
            x: blockPosition.x,
            y: Math.round(blockPosition.y + blockPosition.h / 2)
          };
        case "e":
          return {
            x: blockPosition.x + blockPosition.w,
            y: Math.round(blockPosition.y + blockPosition.h / 2)
          };
        case "s":
        default:
          return {
            x: Math.round(blockPosition.x + blockPosition.w / 2),
            y: blockPosition.y + blockPosition.h
          };
      }
    };
    var InvalidBlockItemError = "refers to an invalid block item";
    var InvalidBlockItemErrorMessage = (0, i18n_exports._)(`%s ${InvalidBlockItemError}`);
    var getBlockItem = ({
      layoutStructure,
      id
    }) => {
      const blockItem = layoutStructure.find(({ item }) => item === id);
      if (!blockItem || blockItem.type === "line") {
        throw Error(InvalidBlockItemErrorMessage.replace("%s", id));
      }
      return blockItem;
    };
    var computeLineAbsPosition = ({
      layoutStructure,
      position
    }) => {
      let { from, to } = position;
      if ("item" in from && "port" in from) {
        const blockItem = getBlockItem({ layoutStructure, id: from.item });
        from = computePortPosition(blockItem, from.port);
      }
      if ("item" in to && "port" in to) {
        const blockItem = getBlockItem({ layoutStructure, id: to.item });
        to = computePortPosition(blockItem, to.port);
      }
      return {
        from,
        to
      };
    };
    var findSelectedLineItems = ({
      layoutStructure,
      selectedItems
    }) => layoutStructure.filter(
      ({ item, type }) => selectedItems.findIndex(
        ({ id }) => item === id && type === "line"
      ) >= 0
    );
    var handleSingleLineMove = ({
      lineId,
      offset,
      layoutStructure
    }) => {
      let line = layoutStructure.find(
        (item) => item.item === lineId
      );
      const linePosition = computeLineAbsPosition({
        layoutStructure,
        position: line.position
      });
      if (isLineConnected({ line, dir: "from" })) {
        line = disconnectLine({
          line,
          dir: "from",
          absPos: linePosition.from
        });
      }
      if (isLineConnected({ line, dir: "to" })) {
        line = disconnectLine({
          line,
          dir: "to",
          absPos: linePosition.to
        });
      }
      line = updateLineAbsPosition({
        line,
        dir: "from",
        offset
      });
      line = updateLineAbsPosition({
        line,
        dir: "to",
        offset
      });
      return line;
    };
    var handleSingleLineDragStart = ({
      lineId,
      layoutStructure,
      lineDir
    }) => {
      let line = layoutStructure.find(
        (item) => item.item === lineId
      );
      const linePosition = computeLineAbsPosition({
        layoutStructure,
        position: line.position
      });
      if (isLineConnected({
        line,
        dir: lineDir
      })) {
        line = disconnectLine({
          line,
          dir: lineDir,
          absPos: linePosition[lineDir]
        });
      }
      return line;
    };
    var getAllLineItems = ({
      layoutStructure,
      layoutStructureState = {}
    }) => {
      return layoutStructure.map((item) => {
        var _a;
        return (_a = layoutStructureState[item.item]) != null ? _a : item;
      }).filter(({ type }) => type === "line");
    };
    var initializeLayoutStructureState = (layoutStructure) => layoutStructure.reduce((obj, item) => {
      obj[item.item] = __spreadValues({}, item);
      return obj;
    }, {});
    var reducer = (state, action) => {
      switch (action.type) {
        case "lineMove":
          return __spreadProps(__spreadValues({}, state), {
            [action.payload.item]: action.payload
          });
        case "lineDragStart":
          return __spreadProps(__spreadValues({}, state), {
            [action.payload.item]: action.payload
          });
        case "lineDrag": {
          const lineToDrag = state[action.payload.id];
          return isLineConnected({
            line: lineToDrag,
            dir: action.payload.dir
          }) ? state : __spreadProps(__spreadValues({}, state), {
            [action.payload.id]: __spreadProps(__spreadValues({}, lineToDrag), {
              position: __spreadProps(__spreadValues({}, lineToDrag.position), {
                [action.payload.dir]: action.payload.absPos
              })
            })
          });
        }
        case "lineConnect": {
          const lineToConnect = state[action.payload.lineId];
          return isLineConnected({
            line: lineToConnect,
            dir: action.payload.lineDir
          }) ? state : __spreadProps(__spreadValues({}, state), {
            [action.payload.lineId]: connectLine({
              line: lineToConnect,
              dir: action.payload.lineDir,
              itemId: action.payload.itemId,
              port: action.payload.port
            })
          });
        }
        case "lineDisconnect": {
          const lineToDisconnect = state[action.payload.lineId];
          return isLineConnected({
            line: lineToDisconnect,
            dir: action.payload.lineDir
          }) ? __spreadProps(__spreadValues({}, state), {
            [action.payload.lineId]: disconnectLine({
              line: lineToDisconnect,
              dir: action.payload.lineDir,
              absPos: computeLineAbsPosition({
                layoutStructure: Object.values(state),
                position: lineToDisconnect.position
              })[action.payload.lineDir]
            })
          }) : state;
        }
        case "blockResize":
          return __spreadProps(__spreadValues({}, state), {
            [action.payload.item]: action.payload
          });
        case "blocksMove":
          return action.payload.reduce(
            (s, blockItem) => __spreadProps(__spreadValues({}, s), {
              [blockItem.item]: blockItem
            }),
            __spreadValues({}, state)
          );
        case "reset":
          return initializeLayoutStructureState(action.payload);
        default:
          return state;
      }
    };
    var updateLayoutStructureOnKeyboardMove = ({
      selectedLineItems,
      selectedBlockItems,
      layoutStructure,
      dir,
      snap,
      gridSize
    }) => {
      const updatedLines = selectedLineItems.map(({ item }) => {
        const offset = createOffset(dir, 1, 1);
        return handleSingleLineMove({
          layoutStructure,
          lineId: item,
          offset
        });
      });
      const updatedBlocks = selectedBlockItems.map((blockItem) => {
        const { position } = blockItem;
        const snapOffset2 = snap ? snapOffsetToXY({
          position,
          offset: createOffset(dir, gridSize, gridSize),
          gridWidth: gridSize,
          gridHeight: gridSize,
          spacing: 0,
          padding: 0
        }) : createOffset(dir, 1, 1);
        return updateBlockItemPosition(blockItem, snapOffset2);
      });
      const updatedItems = [...updatedLines, ...updatedBlocks];
      const updatedLayoutStructure = layoutStructure.map(
        (item) => {
          var _a;
          return (_a = updatedItems.find((line) => line.item === item.item)) != null ? _a : item;
        }
      );
      return updatedLayoutStructure;
    };
    var absoluteLayoutOptionsSchema_default = {
      backgroundColor: {
        anyOf: [
          {
            pattern: dashboard_definition_exports.COLOR_PATTERN_WITH_RGBA_AND_TOKEN,
            type: "string",
            description: `Specify the color of the layout background color using using a hex code, rgb/rgba value, an HTML color name, or a token.

The default for light mode is "#F2F4f5". The default for dark mode is "#3C444D". The default for SCP mode is "#15161B"`
          },
          {
            type: "string",
            enum: dashboard_ui_exports.namedColors,
            description: `Specify the color of the layout background color using a valid web color such as 'blue'`
          }
        ]
      },
      display: {
        type: "string",
        default: "auto",
        enum: ["actual-size", "fit-to-width", "auto", "auto-scale"],
        description: `Specify the display behavior. Valid options are:


actual-size: The dashboard will not change size when the browser is resized.


fit-to-width: The dashboard will change in size as the browser is resized, always filling the available width of the browser.


auto: The dashboard will change in size as the browser is resized, to a maximum zoom of 100%.`
      },
      backgroundImage: {
        type: "object",
        properties: {
          w: {
            type: "number",
            description: `Specify the image's h (height) and w (width) in pixels. These options should not be specified if you set the sizeType option. If they are, they will overrule that setting.`
          },
          h: {
            type: "number",
            description: `Specify the image's h (height) and w (width) in pixels. These options should not be specified if you set the sizeType option. If they are, they will overrule that setting.`
          },
          x: {
            type: "number",
            description: "Specify, in pixels, the position of the background image on the x-axis and y-axis. These options should not be specified if you set the sizeType option. If they are, they will overrule that setting."
          },
          y: {
            type: "number",
            description: "Specify, in pixels, the position of the background image on the x-axis and y-axis. These options should not be specified if you set the sizeType option. If they are, they will overrule that setting."
          },
          src: {
            type: "string",
            description: "The url of background image."
          },
          opacity: {
            type: "number",
            minimum: 0,
            maximum: 1,
            description: "The opacity of the image."
          },
          sizeType: {
            type: "string",
            enum: ["auto", "contain", "cover"],
            default: "contain",
            description: `Specify one of the following:


auto: Scales the image while maintaining the image proportion.


contain: Increases the size of the of the image as much as possible without cropping or stretching it.


cover: Increases the size of the image without stretching it. The image may be cropped vertically and horizontally so that no empty space is shown.`
          }
        },
        description: `A background image must be one of the following types: jpg, jpeg, png, svg, or gif

Specify the location of a background image using the option src. For example: "src": "https://www.myImageLocation.com/galleryX/image1.png`,
        additionalProperties: false
      },
      width: {
        type: "number",
        default: dashboard_utils_exports.DEFAULT_CANVAS_WIDTH,
        description: "Canvas width in pixels."
      },
      height: {
        type: "number",
        default: dashboard_utils_exports.DEFAULT_CANVAS_HEIGHT,
        description: "Canvas height in pixels."
      }
    };
    var EmptyStructure = [];
    var withLayoutShowHide = (Layout, { schema, reflowFn }) => {
      const EnhancedLayout = (props) => {
        var _a;
        const layoutStructure = useLayoutShowHide(
          (_a = props.layoutStructure) != null ? _a : EmptyStructure,
          reflowFn
        );
        return react_default.createElement(
          Layout,
          __spreadProps(__spreadValues({}, props), {
            layoutStructure,
            rawLayoutStructure: props.layoutStructure
          })
        );
      };
      EnhancedLayout.schema = schema;
      return EnhancedLayout;
    };
    var emptySelectedItems = [];
    var emptyLayoutStructure = [];
    var AbsoluteLayout = (props) => {
      const {
        layoutId,
        mode = "view",
        showGrid = true,
        options: {
          width = absoluteLayoutOptions.width,
          height = absoluteLayoutOptions.height,
          display = absoluteLayoutOptions.display,
          backgroundColor,
          backgroundImage
        } = absoluteLayoutOptions,
        layoutStructure = emptyLayoutStructure,
        rawLayoutStructure = emptyLayoutStructure,
        containerWidth,
        containerHeight,
        selectedItems = emptySelectedItems,
        renderLayoutItem,
        onLayoutItemsSelect = dashboard_utils_exports.noop,
        onLayoutStructureChange = dashboard_utils_exports.noop
      } = props;
      const activeLine = (0, react_exports.useRef)(null);
      const reduxDispatch = (0, dashboard_state_exports.useDispatch)();
      const [layoutStructureState, dispatch] = (0, react_exports.useReducer)(
        reducer,
        layoutStructure,
        initializeLayoutStructureState
      );
      const canvasRef = (0, dashboard_context_exports.useCanvasRef)(layoutId);
      const isMouseDownEventRef = (0, react_exports.useRef)(false);
      const layoutStructureRef = (0, react_exports.useRef)(layoutStructure);
      layoutStructureRef.current = layoutStructure;
      const keyboardListener = (0, dashboard_context_exports.useKeyboardListener)();
      const preset = (0, dashboard_context_exports.usePreset)();
      const dashboardApi = (0, dashboard_context_exports.useDashboardCoreApi)();
      const scale = useAbsoluteLayoutZoom({
        layoutId,
        display,
        width,
        height,
        containerWidth,
        containerHeight
      });
      const previousLayoutStructure = (0, dashboard_ui_exports.usePrevious)(layoutStructure);
      const handleKeyboardMove = (0, react_exports.useCallback)(
        ({
          dir,
          snap,
          preventDefault
        }) => {
          var _a, _b, _c, _d, _e;
          if (!(0, dashboard_utils_exports.allowKeyboardShortcut)()) {
            return;
          }
          const selectedLineItems = findSelectedLineItems({
            layoutStructure: layoutStructureRef.current,
            selectedItems
          });
          const selectedBlockItems = findSelectedBlockItems({
            layoutStructure: layoutStructureRef.current,
            selectedItems
          });
          const isResizeHandleFocused = ((_a = document.activeElement) == null ? void 0 : _a.tagName) === "BUTTON" && ((_b = document.activeElement) == null ? void 0 : _b.hasAttribute("direction"));
          const isLineHandleFocused = ((_c = document.activeElement) == null ? void 0 : _c.tagName) === "BUTTON" && ((_e = (_d = document.activeElement) == null ? void 0 : _d.getAttribute("data-test")) == null ? void 0 : _e.startsWith("line-handle"));
          if (selectedLineItems.length === 0 && selectedBlockItems.length === 0 || mode !== "edit" || isResizeHandleFocused || isLineHandleFocused) {
            return;
          }
          const updatedLayoutStructure = updateLayoutStructureOnKeyboardMove({
            selectedBlockItems,
            selectedLineItems,
            dir,
            snap,
            gridSize: GRID_SIZE,
            layoutStructure: layoutStructureRef.current
          });
          onLayoutStructureChange(updatedLayoutStructure);
          preventDefault();
        },
        [mode, onLayoutStructureChange, selectedItems]
      );
      const handleLayoutStructureChange = (0, react_exports.useCallback)(
        (newLayoutStructure) => {
          const updatedLayoutStructure = layoutStructureRef.current.map(
            (item) => {
              var _a;
              return (_a = newLayoutStructure[item.item]) != null ? _a : item;
            }
          );
          onLayoutStructureChange(updatedLayoutStructure);
        },
        [onLayoutStructureChange]
      );
      const calculateLineMove = (0, react_exports.useCallback)(
        (offset) => {
          const selectedLineItems = findSelectedLineItems({
            layoutStructure: layoutStructureRef.current,
            selectedItems
          });
          if (selectedLineItems.length === 0) {
            return void 0;
          }
          const lineId = selectedLineItems[0].item;
          return handleSingleLineMove({
            layoutStructure: layoutStructureRef.current,
            lineId,
            offset
          });
        },
        [selectedItems]
      );
      const handleLineMove = (0, react_exports.useCallback)(
        (_e, offset) => {
          const lineItem = calculateLineMove(offset);
          if (typeof lineItem === "undefined") {
            return;
          }
          dispatch({
            type: "lineMove",
            payload: lineItem
          });
        },
        [calculateLineMove]
      );
      const handleLineMoved = (0, react_exports.useCallback)(
        (_e, offset) => {
          const lineItem = calculateLineMove(offset);
          if (typeof lineItem === "undefined") {
            handleLayoutStructureChange(layoutStructureState);
            return;
          }
          const newLayoutStructure = reducer(layoutStructureState, {
            type: "lineMove",
            payload: lineItem
          });
          handleLayoutStructureChange(newLayoutStructure);
        },
        [calculateLineMove, handleLayoutStructureChange, layoutStructureState]
      );
      const handleLineDragStart = (0, react_exports.useCallback)(
        (_e, dir) => {
          const selectedLineItems = findSelectedLineItems({
            layoutStructure: layoutStructureRef.current,
            selectedItems
          });
          if (selectedLineItems.length !== 1) {
            return;
          }
          const lineId = selectedLineItems[0].item;
          const line = handleSingleLineDragStart({
            lineId,
            layoutStructure: layoutStructureRef.current,
            lineDir: dir
          });
          dispatch({
            type: "lineDragStart",
            payload: line
          });
          activeLine.current = { id: lineId, dir };
        },
        [selectedItems]
      );
      const calculateLineDrag = (0, react_exports.useCallback)((offset) => {
        if (!activeLine.current) {
          return void 0;
        }
        const line = layoutStructureRef.current.find(
          (item) => {
            var _a;
            return item.item === ((_a = activeLine.current) == null ? void 0 : _a.id);
          }
        );
        const absPos = computeLineAbsPosition({
          layoutStructure: layoutStructureRef.current,
          position: line.position
        })[activeLine.current.dir];
        return {
          id: activeLine.current.id,
          dir: activeLine.current.dir,
          absPos: {
            x: absPos.x + offset.offsetX,
            y: absPos.y + offset.offsetY
          }
        };
      }, []);
      const handleLineDrag = (0, react_exports.useCallback)(
        (_e, offset) => {
          const lineItem = calculateLineDrag(offset);
          if (typeof lineItem === "undefined") {
            return;
          }
          dispatch({
            type: "lineDrag",
            payload: lineItem
          });
        },
        [calculateLineDrag]
      );
      const handleLineDragged = (0, react_exports.useCallback)(
        (e, offset) => {
          activeLine.current = null;
          const lineItem = calculateLineDrag(offset);
          if (typeof lineItem === "undefined") {
            handleLayoutStructureChange(layoutStructureState);
            return;
          }
          const newLayoutStructure = reducer(layoutStructureState, {
            type: "lineDrag",
            payload: lineItem
          });
          handleLayoutStructureChange(newLayoutStructure);
        },
        [calculateLineDrag, handleLayoutStructureChange, layoutStructureState]
      );
      const handleLineConnected = (0, react_exports.useCallback)((itemId, port) => {
        if (!activeLine.current) {
          return;
        }
        const lineId = activeLine.current.id;
        dispatch({
          type: "lineConnect",
          payload: {
            lineId,
            lineDir: activeLine.current.dir,
            itemId,
            port
          }
        });
      }, []);
      const handleLineDisconnected = (0, react_exports.useCallback)(() => {
        if (!activeLine.current) {
          return;
        }
        dispatch({
          type: "lineDisconnect",
          payload: {
            lineId: activeLine.current.id,
            lineDir: activeLine.current.dir
          }
        });
      }, []);
      const handleItemSelected = (0, react_exports.useCallback)(
        (_e, newSelectedItems = emptySelectedItems) => {
          onLayoutItemsSelect(newSelectedItems);
        },
        [onLayoutItemsSelect]
      );
      const calculateBlockItemResize = (0, react_exports.useCallback)(
        (itemId, offset, dir) => {
          const item = layoutStructureRef.current.find(
            (itm) => itm.item === itemId
          );
          const snapOffset2 = snapOffsetToWH({
            position: item.position,
            offset,
            gridWidth: GRID_SIZE,
            gridHeight: GRID_SIZE,
            spacing: 0,
            padding: 0
          });
          const newItem = updateBlockItemSize({
            item,
            offset: snapOffset2,
            dir,
            options: {
              minHeight: MIN_HEIGHT,
              minWidth: MIN_WIDTH
            }
          });
          if ((0, lodash_exports.isEqual)(
            newItem.position,
            layoutStructureState[newItem.item].position
          )) {
            return void 0;
          }
          return newItem;
        },
        [layoutStructureState]
      );
      const handleBlockItemResize = (0, react_exports.useCallback)(
        (_e, itemId, offset, dir) => {
          const newItem = calculateBlockItemResize(itemId, offset, dir);
          if (typeof newItem === "undefined") {
            return;
          }
          reduxDispatch((0, dashboard_state_exports.blockItemResize)());
          dispatch({
            type: "blockResize",
            payload: newItem
          });
        },
        [calculateBlockItemResize, reduxDispatch]
      );
      const handleBlockItemResized = (0, react_exports.useCallback)(
        (_e, itemId, offset, dir) => {
          reduxDispatch((0, dashboard_state_exports.blockItemResized)());
          const newItem = calculateBlockItemResize(itemId, offset, dir);
          if (typeof newItem === "undefined") {
            handleLayoutStructureChange(layoutStructureState);
            return;
          }
          const newLayoutStructure = reducer(layoutStructureState, {
            type: "blockResize",
            payload: newItem
          });
          handleLayoutStructureChange(newLayoutStructure);
        },
        [
          calculateBlockItemResize,
          handleLayoutStructureChange,
          layoutStructureState,
          reduxDispatch
        ]
      );
      const calculateBlockItemMove = (0, react_exports.useCallback)(
        (offset) => {
          const selectedBlockItems = findSelectedBlockItems({
            layoutStructure: layoutStructureRef.current,
            selectedItems
          });
          if (selectedBlockItems.length === 0) {
            return void 0;
          }
          const firstBlockItem = selectedBlockItems[0];
          const moveOffset = snapOffsetToXY({
            position: firstBlockItem.position,
            offset,
            gridWidth: GRID_SIZE,
            gridHeight: GRID_SIZE,
            spacing: 0,
            padding: 0
          });
          const updatedSelectedBlockItems = selectedBlockItems.map(
            (blockItem) => updateBlockItemPosition(blockItem, moveOffset)
          );
          const firstUpdatedBlockItem = updatedSelectedBlockItems[0];
          if ((0, lodash_exports.isEqual)(
            firstUpdatedBlockItem.position,
            layoutStructureState[firstUpdatedBlockItem.item].position
          )) {
            return void 0;
          }
          return updatedSelectedBlockItems;
        },
        [layoutStructureState, selectedItems]
      );
      const handleBlockItemMove = (0, react_exports.useCallback)(
        (_e, offset) => {
          const updatedSelectedBlockItems = calculateBlockItemMove(offset);
          if (typeof updatedSelectedBlockItems === "undefined") {
            return;
          }
          reduxDispatch((0, dashboard_state_exports.blockItemMove)());
          dispatch({
            type: "blocksMove",
            payload: updatedSelectedBlockItems
          });
        },
        [calculateBlockItemMove, reduxDispatch]
      );
      const handleBlockItemMoved = (0, react_exports.useCallback)(
        (_e, offset) => {
          const numVisualizationsMoved = selectedItems.length;
          reduxDispatch((0, dashboard_state_exports.blockItemMoved)({ numVisualizationsMoved }));
          const updatedSelectedBlockItems = calculateBlockItemMove(offset);
          if (typeof updatedSelectedBlockItems === "undefined") {
            handleLayoutStructureChange(layoutStructureState);
            return;
          }
          const newLayoutStructure = reducer(layoutStructureState, {
            type: "blocksMove",
            payload: updatedSelectedBlockItems
          });
          handleLayoutStructureChange(newLayoutStructure);
        },
        [
          calculateBlockItemMove,
          handleLayoutStructureChange,
          layoutStructureState,
          reduxDispatch,
          selectedItems.length
        ]
      );
      const blockItems = (0, react_exports.useMemo)(
        () => layoutStructure.filter((item) => (0, dashboard_utils_exports.isBlockItem)(item)).map(
          (block) => {
            var _a;
            return (_a = layoutStructureState[block.item]) != null ? _a : block;
          }
        ),
        [layoutStructure, layoutStructureState]
      );
      const lineItems = (0, react_exports.useMemo)(
        () => layoutStructure.filter(({ type }) => type === "line").map(
          (line) => {
            var _a;
            return (_a = layoutStructureState[line.item]) != null ? _a : line;
          }
        ),
        [layoutStructure, layoutStructureState]
      );
      const optionsRef = (0, react_exports.useRef)(props.options);
      optionsRef.current = props.options;
      (0, react_exports.useEffect)(() => {
        if (!(0, lodash_exports.isEqual)(layoutStructure, previousLayoutStructure)) {
          dispatch({
            type: "reset",
            payload: layoutStructure
          });
        }
      }, [layoutStructure, previousLayoutStructure]);
      (0, react_exports.useEffect)(() => {
        if (!keyboardListener) {
          return dashboard_utils_exports.noop;
        }
        const unsubscribeMove = keyboardListener.subscribe(
          "move",
          handleKeyboardMove
        );
        return () => {
          unsubscribeMove();
        };
      }, [handleKeyboardMove, keyboardListener]);
      (0, react_exports.useEffect)(() => {
        if (!keyboardListener) {
          return dashboard_utils_exports.noop;
        }
        const unsubscribeCancel = keyboardListener.subscribe(
          "cancel",
          () => handleItemSelected(null, [])
        );
        return () => {
          unsubscribeCancel();
        };
      }, [handleItemSelected, keyboardListener]);
      (0, react_exports.useEffect)(() => {
        if (activeLine.current && layoutStructureState[activeLine.current.id] == null) {
          activeLine.current = null;
        }
      }, [layoutStructureState]);
      const image = (0, react_exports.useMemo)(
        () => backgroundImage ? validateBackgroundImage({
          backgroundImage,
          canvasWidth: width,
          canvasHeight: height
        }) : {},
        [backgroundImage, height, width]
      );
      const modeSpecificProps = (0, react_exports.useMemo)(
        () => mode === "edit" ? {
          movable: true,
          showOverflowContent: true,
          showGrid,
          showBorder: true,
          gridLineWidth: 1,
          gridPadding: GRID_PADDING,
          onItemMove: handleBlockItemMove,
          onItemMoved: handleBlockItemMoved,
          userSelect: false,
          allowMultiselect: true
        } : {
          movable: false,
          showOverflowContent: false,
          showGrid: false,
          showBorder: false,
          userSelect: true,
          allowMultiselect: false
        },
        [handleBlockItemMove, handleBlockItemMoved, mode, showGrid]
      );
      const allBlockItems = (0, react_exports.useMemo)(
        () => getAllBlockItems({ layoutStructure, layoutStructureState }),
        [layoutStructure, layoutStructureState]
      );
      const blockItemElements = (0, react_exports.useMemo)(() => {
        return allBlockItems.map(({ item, type, position: { x, y, w, h } }) => react_default.createElement(
          ResponsiveBlockItem_default,
          {
            key: item,
            itemId: item,
            type,
            x,
            y,
            w,
            h,
            canvasHeight: height,
            renderLayoutItem,
            onItemSelected: handleItemSelected,
            isMouseDownEventRef
          }
        ));
      }, [handleItemSelected, height, allBlockItems, renderLayoutItem]);
      const lineElements = (0, react_exports.useMemo)(() => {
        const selectedLineItems = findSelectedLineItems({
          layoutStructure,
          selectedItems
        });
        const selectable = mode === "edit";
        return lineItems.map((line) => {
          const editable = selectedLineItems.length === 1 && selectedLineItems[0].item === line.item && selectable;
          let absPos = { from: { x: 0, y: 0 }, to: { x: 0, y: 0 } };
          try {
            absPos = computeLineAbsPosition({
              layoutStructure: Object.values(layoutStructureState),
              position: line.position
            });
          } catch (err) {
            if (err instanceof Error && err.message.endsWith(InvalidBlockItemError)) {
              absPos = computeLineAbsPosition({
                layoutStructure: rawLayoutStructure,
                position: line.position
              });
            }
          }
          const fromTestHooks = "item" in line.position.from && "port" in line.position.from ? {
            fromItem: line.position.from.item,
            fromPort: line.position.from.port
          } : {};
          const toTestHooks = "item" in line.position.to && "port" in line.position.to ? {
            toItem: line.position.to.item,
            toPort: line.position.to.port
          } : {};
          return react_default.createElement(
            ResponsiveLine_default,
            __spreadValues(__spreadValues({
              key: line.item,
              lineId: line.item,
              scale,
              selectable,
              editable,
              renderLayoutItem,
              onLineMove: handleLineMove,
              onLineMoved: handleLineMoved,
              onLineDragStart: handleLineDragStart,
              onLineDrag: handleLineDrag,
              onLineDragged: handleLineDragged,
              onItemSelected: handleItemSelected,
              fromX: absPos.from.x,
              fromY: absPos.from.y,
              toX: absPos.to.x,
              toY: absPos.to.y
            }, fromTestHooks), toTestHooks)
          );
        });
      }, [
        handleItemSelected,
        handleLineDrag,
        handleLineDragStart,
        handleLineDragged,
        handleLineMove,
        handleLineMoved,
        rawLayoutStructure,
        layoutStructure,
        layoutStructureState,
        lineItems,
        mode,
        renderLayoutItem,
        scale,
        selectedItems
      ]);
      const outlineElements = (0, react_exports.useMemo)(() => {
        const selectedLineItems = findSelectedLineItems({
          layoutStructure: Object.values(layoutStructureState),
          selectedItems
        });
        const selectedBlockItems = findSelectedBlockItems({
          layoutStructure: Object.values(layoutStructureState),
          selectedItems
        });
        return allBlockItems.map((block) => {
          const connectable = mode === "edit" && selectedBlockItems.length === 0 && selectedLineItems.length === 1 && activeLine != null;
          const resizable = mode === "edit" && selectedBlockItems.length === 1 && selectedBlockItems[0].item === block.item;
          const selected = selectedBlockItems.findIndex((b) => b.item === block.item) >= 0;
          if (!connectable && !resizable && !selected) {
            return null;
          }
          const definition = dashboard_definition_exports.DashboardDefinition.fromJSON(
            dashboardApi == null ? void 0 : dashboardApi.getDefinition()
          );
          const itemPresetType = definition.getItemPresetType(block.item);
          const handleDirections = preset.getResizeHandleDirections(itemPresetType);
          return react_default.createElement(
            ResponsiveBlockOutline_default,
            {
              key: block.item,
              itemId: block.item,
              x: block.position.x,
              y: block.position.y,
              w: block.position.w,
              h: block.position.h,
              scale,
              connectable,
              resizable,
              onResize: handleBlockItemResize,
              onResized: handleBlockItemResized,
              onLineConnect: handleLineConnected,
              onLineDisconnect: handleLineDisconnected,
              handleDirections
            }
          );
        });
      }, [
        layoutStructureState,
        selectedItems,
        allBlockItems,
        mode,
        activeLine,
        dashboardApi,
        preset,
        scale,
        handleBlockItemResize,
        handleBlockItemResized,
        handleLineConnected,
        handleLineDisconnected
      ]);
      const handleMouseDownCapture = (0, react_exports.useCallback)(() => {
        isMouseDownEventRef.current = true;
      }, []);
      const handleMouseUpCapture = (0, react_exports.useCallback)(() => {
        isMouseDownEventRef.current = false;
      }, []);
      return react_default.createElement(
        AbsoluteCanvas_default,
        __spreadValues({
          "data-test": "absolute-layout",
          blockItems,
          width,
          height,
          scale,
          gridWidth: GRID_SIZE - 1,
          gridHeight: GRID_SIZE - 1,
          backgroundColor,
          backgroundImageSrc: image.src,
          backgroundImageSizeType: image.sizeType,
          backgroundImageWidth: image.w,
          backgroundImageHeight: image.h,
          backgroundImagePositionX: image.x,
          backgroundImagePositionY: image.y,
          backgroundImageOpacity: image.opacity,
          selectedLayoutItems: selectedItems,
          onItemSelected: handleItemSelected,
          ref: canvasRef,
          onMouseDownCapture: handleMouseDownCapture,
          onMouseUpCapture: handleMouseUpCapture
        }, modeSpecificProps),
        react_default.createElement(
          Layer_default,
          {
            key: "block-item-layer",
            "data-test": "block-item-layer",
            zIndex: 0
          },
          lineElements,
          blockItemElements.map((el, i) => react_default.createElement(react_default.Fragment, { key: el.key }, el, react_default.createElement(Layer_default, { key: "outline-layer", "data-test": "outline-layer" }, outlineElements[i])))
        )
      );
    };
    var AbsoluteLayout_default = withLayoutShowHide(AbsoluteLayout, {
      schema: absoluteLayoutOptionsSchema_default
    });
    var defaultLayoutStructure = [];
    var defaultOptions = absoluteLayoutOptions;
    var AbsoluteLayoutViewer = ({
      containerWidth,
      containerHeight,
      layoutStructure = defaultLayoutStructure,
      renderLayoutItem,
      options = defaultOptions
    }) => {
      const {
        width,
        height,
        backgroundColor,
        backgroundImage = {},
        display
      } = __spreadValues(__spreadValues({}, absoluteLayoutOptions), options);
      const scrollbarWidth = (0, react_exports.useMemo)(() => (0, dashboard_utils_exports.getScrollbarWidth)(), []);
      const scale = (0, react_exports.useMemo)(() => {
        switch (display) {
          case "fit-to-width":
          case "auto-scale":
            return computeScaleToFit({
              canvasWidth: width,
              canvasHeight: height,
              containerWidth,
              containerHeight,
              scrollbarWidth
            });
          case "actual-size":
            return 1;
          default:
            return computeScaleToFit({
              canvasWidth: width,
              canvasHeight: height,
              containerWidth,
              containerHeight,
              scrollbarWidth,
              max: 1
            });
        }
      }, [
        display,
        height,
        width,
        containerWidth,
        containerHeight,
        scrollbarWidth
      ]);
      const image = (0, react_exports.useMemo)(
        () => backgroundImage ? validateBackgroundImage({
          backgroundImage,
          canvasWidth: width,
          canvasHeight: height
        }) : {},
        [backgroundImage, height, width]
      );
      const renderLines = (0, react_exports.useMemo)(() => {
        const lineItems = layoutStructure.filter(
          ({ type }) => type === "line"
        );
        return lineItems.map(({ item, position }) => {
          const absPosition = computeLineAbsPosition({
            layoutStructure,
            position
          });
          return react_default.createElement(
            ResponsiveLine_default,
            {
              key: item,
              lineId: item,
              scale,
              fromX: absPosition.from.x,
              toX: absPosition.to.x,
              fromY: absPosition.from.y,
              toY: absPosition.to.y,
              renderLayoutItem
            }
          );
        });
      }, [layoutStructure, scale, renderLayoutItem]);
      const renderBlockItems2 = (0, react_exports.useMemo)(() => {
        const blockItems = layoutStructure.filter(
          ({ type }) => type !== "line"
        );
        return blockItems.map(({ item, type, position }) => {
          const { x, y, w, h } = position;
          return react_default.createElement(
            AbsoluteItem_default,
            {
              itemId: item,
              type,
              key: item,
              x,
              y,
              w,
              h,
              renderLayoutItem
            }
          );
        });
      }, [renderLayoutItem, layoutStructure]);
      return react_default.createElement(
        Canvas_default,
        {
          "data-layout-type": "absolute",
          width,
          height,
          scale,
          showGrid: false,
          backgroundColor,
          backgroundImageSrc: image.src,
          backgroundImageSizeType: image.sizeType,
          backgroundImageWidth: image.w,
          backgroundImageHeight: image.h,
          backgroundImagePositionX: image.x,
          backgroundImagePositionY: image.y,
          backgroundImageOpacity: image.opacity
        },
        renderBlockItems2,
        renderLines
      );
    };
    var AbsoluteLayoutViewer_default = AbsoluteLayoutViewer;
    var memoize_one_exports = {};
    __export(memoize_one_exports, {
      default: () => memoize_one_default
    });
    var defaultImport14 = __toESM2((init_memoize_one_esm(), __toCommonJS(memoize_one_esm_exports)));
    __reExport(memoize_one_exports, (init_memoize_one_esm(), __toCommonJS(memoize_one_esm_exports)));
    var memoize_one_default = "default" in defaultImport14 ? defaultImport14.default : defaultImport14;
    var dashboard_telemetry_exports = {};
    __export(dashboard_telemetry_exports, {
      default: () => dashboard_telemetry_default
    });
    var defaultImport15 = __toESM2(require_dashboard_telemetry());
    __reExport(dashboard_telemetry_exports, require_dashboard_telemetry());
    var dashboard_telemetry_default = "default" in defaultImport15 ? defaultImport15.default : defaultImport15;
    var gridLayoutOptionsSchema_default = {
      gutterSize: {
        type: "number",
        default: 8,
        minimum: 8,
        maximum: 16,
        description: "A number that represents the size of the gutter between visualizations in pixels. The minimum value is 8 and maximum value is 16."
      },
      backgroundColor: {
        type: "string",
        description: `Specify the color of the layout background using a hex code, rgb/rgba value, an HTML color name, or a token`,
        anyOf: [
          { enum: dashboard_ui_exports.namedColors },
          { pattern: dashboard_definition_exports.COLOR_PATTERN_WITH_RGBA_AND_TOKEN }
        ]
      }
    };
    var resetLayoutAction = (payload) => ({
      type: "structure/reset",
      payload
    });
    var updateItemAction = (payload) => ({
      type: "structure/update",
      payload
    });
    var getBlockItems = (state) => Object.values(state);
    var filterSelectedItems = (state, selectedItems = []) => {
      const itemKeys = state.map(({ item }) => item);
      return selectedItems.filter(({ id }) => itemKeys.indexOf(id) >= 0);
    };
    var getStructureItem = (state, itemId) => state.find(({ item }) => item === itemId);
    var getItem = (state, itemId) => state[itemId];
    var hasPreviewItem = (state, itemId = "preview-old-item") => !!state[itemId];
    var getFilteredStructure = (state, layoutStructure) => {
      const result = [];
      layoutStructure.forEach((item) => {
        result.push(state[item.item] || item);
      });
      if (hasPreviewItem(state)) {
        result.push(state["preview-old-item"]);
      }
      return result;
    };
    var initializeGridReducer = (layoutStructure = []) => {
      const gridLayout = {};
      layoutStructure.forEach((item) => {
        gridLayout[item.item] = item;
      });
      return gridLayout;
    };
    var gridReducer = (state, action) => {
      switch (action.type) {
        // TODO: handle more actions (above), to further reduce size of grid code
        // TODO: expand set of reduced state, to limit amount of non-layout data tracked in layout component
        case "structure/reset":
          return initializeGridReducer(action.payload);
        case "structure/update":
          return __spreadProps(__spreadValues({}, state), {
            [action.payload.item]: action.payload
          });
        default:
          return state;
      }
    };
    var trackItemsByCoordinate = (layout) => {
      const result = {};
      layout.forEach((item) => {
        var _a, _b;
        (_b = result[_a = item.position.y]) != null ? _b : result[_a] = {};
        result[item.position.y][item.position.x] = item;
      });
      return result;
    };
    var getItemsInCoordinateRange = ({
      itemCoordinateMap,
      range
    }) => {
      if (!range) {
        return Object.values(itemCoordinateMap).flatMap(Object.values);
      }
      const { x: fromX = 0, y: fromY = 0 } = range.from || {};
      const {
        x: toX = Number.POSITIVE_INFINITY,
        y: toY = Number.POSITIVE_INFINITY
      } = range.to || {};
      return Object.keys(itemCoordinateMap).map((key) => parseInt(key, 10)).filter((yPos) => yPos >= fromY && yPos < toY).reduce((acc, yPos) => {
        Object.keys(itemCoordinateMap[yPos]).forEach((key) => {
          const xPos = parseInt(key, 10);
          if (xPos >= fromX && xPos < toX) {
            acc.push(itemCoordinateMap[yPos][xPos]);
          }
        });
        return acc;
      }, []);
    };
    var getVizAtCoord = ({
      x,
      y,
      nodes,
      prevVizId
    }) => nodes[x][y].find(
      (viz) => viz.position.x === x && viz.position.y === y && prevVizId !== viz.item
    );
    var isFullEdge = ({
      x,
      y,
      nodes,
      gridWidth,
      gridHeight,
      type
    }) => {
      if (x === gridWidth || y === gridHeight) {
        return true;
      }
      const originViz = getVizAtCoord({ x, y, nodes });
      if (!originViz) {
        return false;
      }
      return isFullEdge({
        x: type === "horizontal" ? x + originViz.position.w : x,
        y: type === "vertical" ? y + originViz.position.h : y,
        nodes,
        gridWidth,
        gridHeight,
        type
      });
    };
    var splitGridByRows = ({
      nodes,
      layout,
      gridWidth,
      gridHeight,
      originViz,
      alwaysIncludeLastRow = false
    }) => {
      const { x, y, h } = originViz.position;
      const itemCoordinateMap = trackItemsByCoordinate(layout);
      const newGrids = [];
      let lastHorizontalEdgeY = y;
      let nextViz = getVizAtCoord({ x, y: y + h, nodes });
      while (nextViz && nextViz.position.y < gridHeight) {
        if (isFullEdge({
          x,
          y: nextViz.position.y,
          nodes,
          gridWidth,
          gridHeight,
          type: "horizontal"
        })) {
          const rowItems = getItemsInCoordinateRange({
            itemCoordinateMap,
            range: {
              from: { y: lastHorizontalEdgeY },
              to: { y: nextViz.position.y }
            }
          });
          newGrids.push({
            nodes,
            layout,
            gridWidth,
            gridHeight: nextViz.position.y,
            origin: { x, y: lastHorizontalEdgeY },
            content: {
              // the width of the split is the full grid width less the origin of the split
              width: gridWidth - x,
              // the height of the split is the top of the next split less the origin of the current split
              height: nextViz.position.y - lastHorizontalEdgeY,
              items: rowItems
            }
          });
          lastHorizontalEdgeY = nextViz.position.y;
        }
        nextViz = getVizAtCoord({
          x,
          y: nextViz.position.y + nextViz.position.h,
          nodes,
          prevVizId: nextViz.item
        });
      }
      if (newGrids.length === 0 && !alwaysIncludeLastRow) {
        return [];
      }
      const lastRowItems = getItemsInCoordinateRange({
        itemCoordinateMap,
        range: {
          from: { y: lastHorizontalEdgeY }
        }
      });
      newGrids.push({
        nodes,
        layout,
        gridWidth,
        gridHeight,
        origin: { x, y: lastHorizontalEdgeY },
        content: {
          width: gridWidth - x,
          height: gridHeight - lastHorizontalEdgeY,
          items: lastRowItems
        }
      });
      return newGrids;
    };
    var splitGridByColumns = ({
      nodes,
      layout,
      gridWidth,
      gridHeight,
      originViz
    }) => {
      const { x, y, w } = originViz.position;
      const itemCoordinateMap = trackItemsByCoordinate(layout);
      const newGrids = [];
      let lastVerticalEdgeX = x;
      let nextViz = getVizAtCoord({ x: x + w, y, nodes });
      while (nextViz && nextViz.position.x < gridWidth) {
        if (isFullEdge({
          x: nextViz.position.x,
          y,
          nodes,
          gridWidth,
          gridHeight,
          type: "vertical"
        })) {
          const colItems = getItemsInCoordinateRange({
            itemCoordinateMap,
            range: {
              from: { x: lastVerticalEdgeX },
              to: { x: nextViz.position.x }
            }
          });
          newGrids.push({
            nodes,
            layout,
            gridWidth: nextViz.position.x,
            gridHeight,
            origin: { x: lastVerticalEdgeX, y },
            content: {
              // the width of the split is the left-edge of the next column less the origin of the current column
              width: nextViz.position.x - lastVerticalEdgeX,
              // the height of the split is the height of the grid less the origin of the column
              height: gridHeight - y,
              items: colItems
            }
          });
          lastVerticalEdgeX = nextViz.position.x;
        }
        nextViz = getVizAtCoord({
          x: nextViz.position.x + nextViz.position.w,
          y,
          nodes,
          prevVizId: nextViz.item
        });
      }
      if (newGrids.length === 0) {
        return [];
      }
      const lastColumnItems = getItemsInCoordinateRange({
        itemCoordinateMap,
        range: {
          from: { x: lastVerticalEdgeX }
        }
      });
      newGrids.push({
        nodes,
        layout,
        gridWidth,
        gridHeight,
        origin: { x: lastVerticalEdgeX, y },
        content: {
          width: gridWidth - lastVerticalEdgeX,
          height: gridHeight - y,
          items: lastColumnItems
        }
      });
      return newGrids;
    };
    var splitGridByRowsAndColumns = ({
      origin,
      nodes,
      layout,
      newLayout,
      gridWidth,
      gridHeight
    }) => {
      const originViz = getVizAtCoord({ x: origin.x, y: origin.y, nodes });
      if (!originViz) {
        throw new Error("Getting grid layout order failed");
      }
      if (originViz.position.x + originViz.position.w === gridWidth && originViz.position.y + originViz.position.h === gridHeight) {
        newLayout.push(originViz);
        return;
      }
      let newGrids = splitGridByRows({
        nodes,
        layout,
        originViz,
        gridHeight,
        gridWidth
      });
      newGrids.forEach(
        (gridInfo) => splitGridByRowsAndColumns(__spreadProps(__spreadValues({}, gridInfo), { newLayout }))
      );
      if (newGrids.length > 0) {
        return;
      }
      newGrids = splitGridByColumns({
        nodes,
        layout,
        originViz,
        gridHeight,
        gridWidth
      });
      newGrids.forEach(
        (gridInfo) => splitGridByRowsAndColumns(__spreadProps(__spreadValues({}, gridInfo), { newLayout }))
      );
      if (newGrids.length === 0) {
        const vizInCurrentGrid = [];
        layout.forEach((viz) => {
          const { x, y, w, h } = viz.position;
          if (x >= origin.x && x + w <= gridWidth && y >= origin.y && y + h <= gridHeight) {
            vizInCurrentGrid.push(viz);
          }
        });
        const sortedViz = vizInCurrentGrid.sort((viz1, viz2) => {
          if (viz1.position.y < viz2.position.y) {
            return -1;
          }
          if (viz1.position.y > viz2.position.y) {
            return 1;
          }
          if (viz1.position.x < viz2.position.x) {
            return -1;
          }
          if (viz1.position.x > viz2.position.x) {
            return 1;
          }
          return 0;
        });
        newLayout.push(...sortedViz);
      }
    };
    var getGridLayoutOrder = ({
      layout,
      canvasWidth,
      canvasHeight
    }) => {
      const nodes = getNodes(layout);
      if (nodes === null || nodes[0] === void 0 || nodes[0][0] === void 0) {
        return layout;
      }
      const newLayout = [];
      try {
        splitGridByRowsAndColumns({
          origin: { x: 0, y: 0 },
          nodes,
          layout,
          newLayout,
          gridWidth: canvasWidth,
          gridHeight: canvasHeight
        });
      } catch (e) {
        return layout;
      }
      if (newLayout.length !== layout.length) {
        return layout;
      }
      return newLayout;
    };
    var formatEdgeWrapper = ({
      edge,
      padding = 0
    }) => {
      const wrapperStart = __spreadValues({}, edge.edgeStart);
      const wrapperEnd = __spreadValues({}, edge.edgeEnd);
      if (edge.orientation === "horizontal") {
        wrapperStart.x += padding;
        wrapperEnd.x -= padding;
        wrapperStart.y -= padding;
        wrapperEnd.y -= padding;
      } else {
        wrapperStart.y += padding;
        wrapperEnd.y -= padding;
        wrapperStart.x -= padding;
        wrapperEnd.x -= padding;
      }
      return __spreadProps(__spreadValues({}, edge), { edgeStart: wrapperStart, edgeEnd: wrapperEnd });
    };
    var getDimensions = ({
      edge,
      thickness
    }) => {
      return {
        width: edge.orientation === "horizontal" ? edge.edgeEnd.x - edge.edgeStart.x : thickness,
        height: edge.orientation === "vertical" ? edge.edgeEnd.y - edge.edgeStart.y : thickness
      };
    };
    var isMouseOnEdge = ({
      edge,
      mousePosition,
      padding = 0
    }) => {
      const formattedEdge = formatEdgeWrapper({ edge, padding });
      const { width, height } = getDimensions({
        edge: formattedEdge,
        thickness: 2 * padding
      });
      return mousePosition.x <= formattedEdge.edgeStart.x + width && mousePosition.x >= formattedEdge.edgeStart.x && mousePosition.y <= formattedEdge.edgeStart.y + height && mousePosition.y >= formattedEdge.edgeStart.y;
    };
    var computeNewVizPositionsGutterCase = ({
      edge,
      itemToMove,
      items
    }) => {
      const updatedVisualizations = [];
      items.forEach((item) => {
        if (item.position.y >= edge.edgeStart.y) {
          const viz = item.item === itemToMove.item ? __spreadProps(__spreadValues({}, item), { item: "itemToRemove" }) : item;
          updatedVisualizations.push(__spreadProps(__spreadValues({}, viz), {
            position: __spreadProps(__spreadValues({}, viz.position), {
              y: viz.position.y + itemToMove.position.h
            })
          }));
        }
      });
      updatedVisualizations.push(__spreadProps(__spreadValues({}, itemToMove), {
        position: __spreadProps(__spreadValues({}, itemToMove.position), {
          // height is preserved
          y: edge.edgeStart.y,
          x: edge.edgeStart.x,
          w: edge.edgeEnd.x - edge.edgeStart.x
        })
      }));
      return updatedVisualizations;
    };
    var sizeToTakeFromViz = ({
      amountToTake,
      edge,
      minWidth,
      minHeight
    }) => {
      const reduction = edge.visualizations.reduce(
        (acc, viz) => {
          if (acc === null) {
            return null;
          }
          if (edge.orientation === "vertical") {
            const widthToTake = Math.ceil(viz.position.w * amountToTake);
            if (viz.position.w - widthToTake < minWidth) {
              return null;
            }
            if (viz.position.x < edge.edgeStart.x) {
              return __spreadProps(__spreadValues({}, acc), {
                firstHalf: [...acc.firstHalf, widthToTake]
              });
            }
            return __spreadProps(__spreadValues({}, acc), {
              secondHalf: [...acc.secondHalf, widthToTake]
            });
          }
          const heightToTake = Math.ceil(viz.position.h * amountToTake);
          if (viz.position.h - heightToTake < minHeight) {
            return null;
          }
          if (viz.position.y < edge.edgeStart.y) {
            return __spreadProps(__spreadValues({}, acc), {
              firstHalf: [...acc.firstHalf, heightToTake]
            });
          }
          return __spreadProps(__spreadValues({}, acc), {
            secondHalf: [...acc.secondHalf, heightToTake]
          });
        },
        { firstHalf: [], secondHalf: [] }
      );
      if (reduction === null) {
        return {
          firstHalf: null,
          secondHalf: null
        };
      }
      return {
        firstHalf: reduction.firstHalf.length === 0 ? 0 : Math.min(...reduction.firstHalf),
        secondHalf: reduction.secondHalf.length === 0 ? 0 : Math.min(...reduction.secondHalf)
      };
    };
    var computeNewVizPositions = ({
      edge,
      itemToMove,
      firstHalf,
      secondHalf
    }) => {
      const updatedVisualizations = [];
      edge.visualizations.forEach((edgeViz) => {
        const viz = edgeViz.item === itemToMove.item ? __spreadProps(__spreadValues({}, edgeViz), { item: "itemToRemove" }) : edgeViz;
        if (edge.orientation === "horizontal") {
          if (viz.position.y < edge.edgeStart.y) {
            updatedVisualizations.push(
              updateBlockItemSize({
                item: __spreadValues({}, viz),
                offset: { offsetY: -1 * firstHalf, offsetX: 0 },
                dir: "s"
              })
            );
          }
          if (viz.position.y >= edge.edgeStart.y) {
            updatedVisualizations.push(
              updateBlockItemSize({
                item: __spreadValues({}, viz),
                offset: { offsetY: secondHalf, offsetX: 0 },
                dir: "n"
              })
            );
          }
        } else {
          if (viz.position.x < edge.edgeStart.x) {
            updatedVisualizations.push(
              updateBlockItemSize({
                item: __spreadValues({}, viz),
                offset: { offsetX: -1 * firstHalf, offsetY: 0 },
                dir: "e"
              })
            );
          }
          if (viz.position.x >= edge.edgeStart.x) {
            updatedVisualizations.push(
              updateBlockItemSize({
                item: __spreadValues({}, viz),
                offset: { offsetX: secondHalf, offsetY: 0 },
                dir: "w"
              })
            );
          }
        }
      });
      updatedVisualizations.push(__spreadProps(__spreadValues({}, itemToMove), {
        position: {
          x: edge.edgeStart.x - (edge.orientation === "vertical" ? firstHalf : 0),
          y: edge.edgeStart.y - (edge.orientation === "horizontal" ? firstHalf : 0),
          w: edge.orientation === "vertical" ? firstHalf + secondHalf : edge.edgeEnd.x - edge.edgeStart.x,
          h: edge.orientation === "horizontal" ? firstHalf + secondHalf : edge.edgeEnd.y - edge.edgeStart.y
        }
      }));
      return updatedVisualizations;
    };
    var isResultingVizSizeGreaterThanMin = ({
      size,
      edgeOrientation
    }) => {
      if (edgeOrientation === "vertical") {
        return size >= MIN_WIDTH_PX;
      }
      return size >= MIN_HEIGHT_PX;
    };
    var updateItems = ({
      updatedVisualizations,
      itemToMove,
      items,
      canvasWidth
    }) => {
      const updatedItems = [
        ...items.filter(
          (item) => updatedVisualizations.find((viz) => viz.item === item.item) === void 0
        ),
        ...updatedVisualizations
      ];
      const updatedNeighbors = (0, dashboard_utils_exports.updateRemovedVizNeighbors)({
        itemToRemove: itemToMove,
        items: updatedItems,
        width: canvasWidth
      });
      const filteredUpdatedVisualizations = updatedVisualizations.filter(
        (viz) => updatedNeighbors.find((neighbor) => neighbor.item === viz.item) === void 0 && viz.item !== "itemToRemove"
      );
      const filteredItems = items.filter(
        (viz) => updatedNeighbors.find((neighbor) => neighbor.item === viz.item) === void 0 && filteredUpdatedVisualizations.find(
          (updatedViz) => updatedViz.item === viz.item
        ) === void 0 && viz.item !== itemToMove.item
      );
      return [
        ...filteredItems,
        ...filteredUpdatedVisualizations,
        ...updatedNeighbors
      ];
    };
    var isDropOnOwnEdge = ({
      edge,
      itemToMove
    }) => edge.visualizations.find((viz) => viz.item === itemToMove.item) != null && (edge.orientation === "horizontal" && itemToMove.position.w === edge.edgeEnd.x - edge.edgeStart.x || edge.orientation === "vertical" && itemToMove.position.h === edge.edgeEnd.y - edge.edgeStart.y);
    var updateDropOnEdge = ({
      edge,
      itemToMove,
      items,
      canvasWidth
    }) => {
      if (isDropOnOwnEdge({ edge, itemToMove })) {
        return null;
      }
      const amountToTake = 1 / 3;
      let updatedVisualizations = [];
      if (edge.orientation === "horizontal" && edge.edgeEnd.x - edge.edgeStart.x === canvasWidth) {
        updatedVisualizations = computeNewVizPositionsGutterCase({
          edge,
          itemToMove,
          items
        });
      } else {
        const { firstHalf, secondHalf } = sizeToTakeFromViz({
          amountToTake,
          edge,
          minWidth: MIN_WIDTH_PX,
          minHeight: MIN_HEIGHT_PX
        });
        if (firstHalf === null || secondHalf === null || // Check if the moved viz resulting size will be greater than the minimum width/height
        // This particular case occurs when adding to the top and bottom canvas edge
        !isResultingVizSizeGreaterThanMin({
          size: firstHalf + secondHalf,
          edgeOrientation: edge.orientation
        })) {
          return null;
        }
        updatedVisualizations = computeNewVizPositions({
          edge,
          itemToMove,
          firstHalf,
          secondHalf
        });
      }
      const updatedItemToMove = updatedVisualizations.find((viz) => viz.item === "itemToRemove") || itemToMove;
      return { updatedVisualizations, updatedItemToMove };
    };
    var positionInItemBoundary = ({
      item,
      position
    }) => {
      return position.x >= item.position.x && position.x <= item.position.x + item.position.w && position.y >= item.position.y && position.y <= item.position.y + item.position.h;
    };
    var findQuadrant = ({
      item,
      position
    }) => {
      if (positionInItemBoundary({ item, position })) {
        let { x, y } = position;
        x -= item.position.x;
        y -= item.position.y;
        const slope = item.position.h / item.position.w;
        let quadrant;
        if (y > slope * x) {
          quadrant = ["w", "s"];
        } else {
          quadrant = ["n", "e"];
        }
        return y < -slope * x + item.position.h ? quadrant[0] : quadrant[1];
      }
      return null;
    };
    var updateDropOnViz = ({
      itemToMove,
      itemToDropOn,
      direction
    }) => {
      if ((direction === "e" || direction === "w") && itemToDropOn.position.w < MIN_WIDTH_PX * 2 || (direction === "n" || direction === "s") && itemToDropOn.position.h < MIN_WIDTH_PX * 2) {
        return null;
      }
      let vizToMove = __spreadProps(__spreadValues({}, itemToMove), {
        position: itemToDropOn.position
      });
      let vizTarget = __spreadValues({}, itemToDropOn);
      switch (direction) {
        case "n":
          vizToMove = updateBlockItemSize({
            item: vizToMove,
            offset: {
              offsetY: -Math.floor(vizToMove.position.h / 2),
              offsetX: 0
            },
            dir: "s"
          });
          vizTarget = updateBlockItemSize({
            item: vizTarget,
            offset: {
              offsetY: Math.ceil(vizTarget.position.h / 2),
              offsetX: 0
            },
            dir: "n"
          });
          break;
        case "s":
          vizToMove = updateBlockItemSize({
            item: vizToMove,
            offset: {
              offsetY: Math.floor(vizToMove.position.h / 2),
              offsetX: 0
            },
            dir: "n"
          });
          vizTarget = updateBlockItemSize({
            item: vizTarget,
            offset: {
              offsetY: -Math.ceil(vizTarget.position.h / 2),
              offsetX: 0
            },
            dir: "s"
          });
          break;
        case "w":
          vizToMove = updateBlockItemSize({
            item: vizToMove,
            offset: {
              offsetX: -Math.floor(vizToMove.position.w / 2),
              offsetY: 0
            },
            dir: "e"
          });
          vizTarget = updateBlockItemSize({
            item: vizTarget,
            offset: {
              offsetX: Math.ceil(vizTarget.position.w / 2),
              offsetY: 0
            },
            dir: "w"
          });
          break;
        case "e":
          vizToMove = updateBlockItemSize({
            item: vizToMove,
            offset: {
              offsetX: Math.floor(vizToMove.position.w / 2),
              offsetY: 0
            },
            dir: "w"
          });
          vizTarget = updateBlockItemSize({
            item: vizTarget,
            offset: {
              offsetX: -Math.ceil(vizTarget.position.w / 2),
              offsetY: 0
            },
            dir: "e"
          });
          break;
        default:
          vizToMove = itemToMove;
          break;
      }
      return [vizToMove, vizTarget];
    };
    var previewDropOnEdge = ({
      edge,
      itemToMove,
      items,
      canvasWidth
    }) => {
      const updatedItems = updateDropOnEdge({
        edge,
        itemToMove,
        items,
        canvasWidth
      });
      if (!updatedItems) {
        return null;
      }
      let { updatedVisualizations } = updatedItems;
      const { updatedItemToMove } = updatedItems;
      updatedVisualizations = updatedVisualizations.filter(
        (viz) => !(0, lodash_exports.isEqual)(viz, updatedItemToMove)
      );
      return [
        ...items.filter(
          (item) => updatedVisualizations.find((viz) => viz.item === item.item) === void 0
        ),
        ...updatedVisualizations,
        __spreadProps(__spreadValues({}, updatedItemToMove), {
          item: "preview-old-item"
        })
      ];
    };
    var previewDropOnViz = ({
      itemToDropOn,
      itemToMove,
      items,
      direction
    }) => {
      const updatedItems = updateDropOnViz({
        itemToMove,
        itemToDropOn,
        direction
      });
      if (!updatedItems) {
        return null;
      }
      return [
        ...items.filter(
          (item) => updatedItems.find((viz) => viz.item === item.item) === void 0
        ),
        ...updatedItems,
        __spreadProps(__spreadValues({}, itemToMove), {
          item: "preview-old-item"
        })
      ];
    };
    var findItemsOutsideBoundary = ({
      items,
      boundary
    }) => {
      const invalidItems = [];
      const message = (0, i18n_exports._)("is outside of canvas bounds");
      items.forEach((item) => {
        if (item.position.x < boundary.x || item.position.x + item.position.w > boundary.x + boundary.w || item.position.y < boundary.y || item.position.y + item.position.h > boundary.y + boundary.h) {
          invalidItems.push({
            itemId: item.item,
            messages: [`"${item.item}" ${message}`]
          });
        }
      });
      return invalidItems;
    };
    var getItemEdges = ({
      item,
      belongsTo = {}
    }) => {
      const topEdge = {
        start: { x: item.x, y: item.y },
        end: { x: item.x + item.w, y: item.y },
        orientation: "horizontal",
        type: "above",
        belongsTo
      };
      const bottomEdge = {
        start: { x: item.x, y: item.y + item.h },
        end: { x: item.x + item.w, y: item.y + item.h },
        orientation: "horizontal",
        type: "below",
        belongsTo
      };
      const leftEdge = {
        start: { x: item.x, y: item.y },
        end: { x: item.x, y: item.y + item.h },
        orientation: "vertical",
        type: "left",
        belongsTo
      };
      const rightEdge = {
        start: { x: item.x + item.w, y: item.y },
        end: { x: item.x + item.w, y: item.y + item.h },
        orientation: "vertical",
        type: "right",
        belongsTo
      };
      return [topEdge, bottomEdge, leftEdge, rightEdge];
    };
    var createEdges = ({
      items,
      canvasBounds
    }) => {
      const edges = [];
      items.forEach((item) => {
        edges.push(
          ...getItemEdges({ item: item.position, belongsTo: item.position })
        );
      });
      edges.push(...getItemEdges({ item: canvasBounds }));
      return edges;
    };
    var findInvalidItemEdges = ({
      item,
      edges
    }) => {
      const invalidEdges = [];
      const curEdges = getItemEdges({
        item: item.position,
        belongsTo: item.position
      });
      curEdges.forEach((curEdge) => {
        const overlappingEdge = edges.find((edge) => {
          if (curEdge.orientation !== edge.orientation || (0, lodash_exports.isEqual)(curEdge.belongsTo, edge.belongsTo)) {
            return false;
          }
          if (curEdge.orientation === "horizontal" && curEdge.start.y === edge.start.y) {
            if (curEdge.start.x >= edge.end.x || edge.start.x >= curEdge.end.x) {
              return false;
            }
            return true;
          }
          if (curEdge.orientation === "vertical" && curEdge.start.x === edge.start.x) {
            if (curEdge.start.y >= edge.end.y || edge.start.y >= curEdge.end.y) {
              return false;
            }
            return true;
          }
          return false;
        });
        if (overlappingEdge === void 0) {
          const positionString = curEdge.orientation === "horizontal" ? `y=${curEdge.start.y}` : `x=${curEdge.start.x}`;
          const positionType = curEdge.type === "below" || curEdge.type === "above" ? curEdge.type : `to its ${curEdge.type}`;
          invalidEdges.push(
            (0, i18n_exports._)(
              `"${item.item}" expected a viz or canvas edge directly ${positionType} at ${positionString}`
            )
          );
        }
      });
      return invalidEdges;
    };
    var findInvalidItems = ({
      items,
      canvasBounds
    }) => {
      const invalidItems = [];
      const edges = createEdges({ items, canvasBounds });
      items.forEach((item) => {
        const invalidEdges = findInvalidItemEdges({ item, edges });
        if (invalidEdges.length > 0) {
          invalidItems.push({
            itemId: item.item,
            messages: invalidEdges
          });
        }
      });
      return invalidItems;
    };
    var validateLayoutStructure = ({
      layout,
      canvasBounds
    }) => {
      if (!layout) {
        return [];
      }
      const res = findItemsOutsideBoundary({
        items: layout,
        boundary: canvasBounds
      });
      if (!(0, lodash_exports.isEmpty)(res)) {
        return res;
      }
      return findInvalidItems({ items: layout, canvasBounds });
    };
    var isVerticallyAligned = (viz, another) => viz.position.y === another.position.y && viz.position.h === another.position.h;
    var isHorizontallyAligned = (viz, another) => viz.position.x === another.position.x && viz.position.w === another.position.w;
    var isInvalidAdjacentVizDrop = ({
      itemToMove,
      itemToDropOn,
      direction,
      visualizations
    }) => {
      if (direction === "e" && (0, dashboard_utils_exports.isLeftNeighbor)(itemToMove, itemToDropOn) && isVerticallyAligned(itemToMove, itemToDropOn)) {
        return true;
      }
      if (direction === "w" && (0, dashboard_utils_exports.isRightNeighbor)(itemToMove, itemToDropOn) && isVerticallyAligned(itemToMove, itemToDropOn)) {
        return true;
      }
      if (direction === "e" || direction === "w") {
        return false;
      }
      const { leftNeighbors, rightNeighbors } = (0, dashboard_utils_exports.findHorizontalNeighbors)({
        item: itemToMove,
        visualizations
      });
      if (leftNeighbors.length > 0 || rightNeighbors.length > 0) {
        return false;
      }
      if (direction === "n" && (0, dashboard_utils_exports.isBottomNeighbor)(itemToMove, itemToDropOn) && isHorizontallyAligned(itemToMove, itemToDropOn)) {
        return true;
      }
      if (direction === "s" && (0, dashboard_utils_exports.isTopNeighbor)(itemToMove, itemToDropOn) && isHorizontallyAligned(itemToMove, itemToDropOn)) {
        return true;
      }
      return false;
    };
    var DEFAULT_BLOCK_ITEM = {
      item: "",
      position: { x: -1, y: -1, w: -1, h: -1 }
    };
    var translateBlockItem = (item, translation) => __spreadProps(__spreadValues({}, item), {
      position: __spreadProps(__spreadValues({}, item.position), {
        x: item.position.x + translation.x,
        y: item.position.y + translation.y
      })
    });
    var translateBlockItems = (items, translation) => items.map((item) => translateBlockItem(item, translation));
    var translateGridSplit = (gridSplit, translation) => __spreadProps(__spreadValues({}, gridSplit), {
      layout: translateBlockItems(gridSplit.layout, translation),
      content: __spreadProps(__spreadValues({}, gridSplit.content), {
        items: translateBlockItems(gridSplit.content.items, translation)
      }),
      origin: {
        x: gridSplit.origin.x + translation.x,
        y: gridSplit.origin.y + translation.y
      }
    });
    var splitGrid = ({
      layoutStructure,
      idToRemove,
      splitConfig = "both",
      alwaysIncludeLastRow = false
    }) => {
      const gridInfo = {
        width: 0,
        height: 0,
        originItem: DEFAULT_BLOCK_ITEM,
        nodes: {},
        splitByRows: [],
        splitByColumns: [],
        itemToRemove: DEFAULT_BLOCK_ITEM
      };
      if (layoutStructure.length === 0) {
        return gridInfo;
      }
      let originX = Number.MAX_SAFE_INTEGER;
      let originY = Number.MAX_SAFE_INTEGER;
      layoutStructure.forEach((item) => {
        const { x, y, w, h } = item.position;
        gridInfo.width = Math.max(gridInfo.width, x + w);
        gridInfo.height = Math.max(gridInfo.height, y + h);
        if (x <= originX && y <= originY) {
          originX = x;
          originY = y;
          gridInfo.originItem = item;
        }
        [
          [x, y],
          [x + w, y],
          [x, y + h],
          [x + w, y + h]
        ].forEach(([cornerX, cornerY]) => {
          var _a, _b, _c, _d;
          (_b = (_a = gridInfo.nodes)[cornerX]) != null ? _b : _a[cornerX] = {};
          (_d = (_c = gridInfo.nodes[cornerX])[cornerY]) != null ? _d : _c[cornerY] = [];
          gridInfo.nodes[cornerX][cornerY].push(item);
        });
        if (idToRemove === item.item) {
          gridInfo.itemToRemove = item;
        }
      });
      gridInfo.width = Math.max(0, gridInfo.width - originX);
      gridInfo.height = Math.max(0, gridInfo.height - originY);
      if (splitConfig === "both" || splitConfig === "rows") {
        gridInfo.splitByRows = splitGridByRows({
          nodes: gridInfo.nodes,
          layout: layoutStructure,
          gridWidth: gridInfo.width,
          gridHeight: gridInfo.height,
          originViz: gridInfo.originItem,
          alwaysIncludeLastRow
        });
      }
      if (splitConfig === "both" || splitConfig === "columns") {
        gridInfo.splitByColumns = splitGridByColumns({
          nodes: gridInfo.nodes,
          layout: layoutStructure,
          gridWidth: gridInfo.width,
          gridHeight: gridInfo.height,
          originViz: gridInfo.originItem
        });
      }
      return gridInfo;
    };
    var findContainingRow = ({ splits, itemPosition }) => {
      const edgeTop = itemPosition.y;
      const edgeBottom = itemPosition.y + itemPosition.h;
      return splits.find(
        ({ origin, content }) => (
          // Find the first row split which starts above the item in question and ends below it
          origin.y <= edgeTop && origin.y + content.height >= edgeBottom
        )
      );
    };
    var findContainingColumn = ({ splits, itemPosition }) => {
      const edgeLeft = itemPosition.x;
      const edgeRight = itemPosition.x + itemPosition.w;
      return splits.find(
        ({ origin, content }) => (
          // Find the first column split which starts before the item in question and ends after it
          origin.x <= edgeLeft && origin.x + content.width >= edgeRight
        )
      );
    };
    var getContainingRowColumnRecursive = ({
      findContainerFn,
      itemToContain,
      previousResult,
      structure
    }) => {
      const splittingByRows = findContainerFn === findContainingRow;
      const splitGridInfo = splitGrid({
        layoutStructure: structure,
        idToRemove: itemToContain.item,
        splitConfig: splittingByRows ? "rows" : "columns",
        alwaysIncludeLastRow: true
      });
      const container = findContainerFn({
        splits: splittingByRows ? splitGridInfo.splitByRows : splitGridInfo.splitByColumns,
        itemPosition: splitGridInfo.itemToRemove.position
      });
      if (!container || container.content.items.length <= 1) {
        return previousResult;
      }
      const containerTranslation = {
        x: -container.origin.x,
        y: -container.origin.y
      };
      const translatedContainer = translateGridSplit(
        container,
        containerTranslation
      );
      const nextFindContainerFn = splittingByRows ? findContainingColumn : findContainingRow;
      return translateGridSplit(
        getContainingRowColumnRecursive({
          structure: translatedContainer.content.items,
          itemToContain,
          findContainerFn: nextFindContainerFn,
          previousResult: translatedContainer
        }),
        // NOSONAR
        container.origin
      );
    };
    var getContainingRowColumn = ({
      structure,
      itemToContain
    }) => getContainingRowColumnRecursive({
      structure,
      itemToContain,
      findContainerFn: findContainingRow
    });
    var recursivelyApplyHorizontalResize = ({
      container: {
        content: { items, width: totalWidth },
        origin
      },
      newSize,
      position,
      translation
    }) => {
      const changes = {};
      const { splitByRows, splitByColumns } = splitGrid({
        layoutStructure: translateBlockItems(items, {
          x: -origin.x,
          y: -origin.y
        })
      });
      splitByRows.forEach((container) => {
        Object.assign(
          changes,
          recursivelyApplyHorizontalResize({
            container,
            newSize,
            position,
            translation: {
              x: translation.x + origin.x,
              y: translation.y + origin.y
            }
          })
        );
      });
      let colPosition = position;
      splitByColumns.forEach((container, idx) => {
        let newColWidth = Math.floor(
          newSize * (container.content.width / totalWidth)
        );
        if (
          // If resizing the last column
          idx === splitByColumns.length - 1 && // and there's a fractional correction needed
          colPosition + newColWidth !== position + newSize
        ) {
          newColWidth = position + newSize - colPosition;
        }
        Object.assign(
          changes,
          recursivelyApplyHorizontalResize({
            container,
            newSize: newColWidth,
            position: colPosition,
            translation: {
              x: translation.x + origin.x,
              y: translation.y + origin.y
            }
          })
        );
        colPosition += newColWidth;
      });
      if (splitByColumns.length === 0 && splitByRows.length === 0) {
        items.forEach((item) => {
          const { position: itemPos } = translateBlockItem(item, translation);
          changes[item.item] = __spreadProps(__spreadValues({}, item), {
            position: __spreadProps(__spreadValues({}, itemPos), {
              x: position,
              w: newSize
            })
          });
        });
      }
      return changes;
    };
    var recursivelyApplyVerticalResize = ({
      container: {
        content: { items, height: totalHeight },
        origin
      },
      newSize,
      position,
      translation
    }) => {
      const changes = {};
      const { splitByRows, splitByColumns } = splitGrid({
        layoutStructure: translateBlockItems(items, {
          x: -origin.x,
          y: -origin.y
        })
      });
      splitByColumns.forEach((container) => {
        Object.assign(
          changes,
          recursivelyApplyVerticalResize({
            container,
            newSize,
            position,
            translation: {
              x: translation.x + origin.x,
              y: translation.y + origin.y
            }
          })
        );
      });
      let rowPosition = position;
      splitByRows.forEach((container, idx) => {
        let newRowHeight = Math.floor(
          newSize * (container.content.height / totalHeight)
        );
        if (
          // If resizing the last row
          idx === splitByRows.length - 1 && // and there's a fractional correction needed
          rowPosition + newRowHeight !== position + newSize
        ) {
          newRowHeight = position + newSize - rowPosition;
        }
        Object.assign(
          changes,
          recursivelyApplyVerticalResize({
            container,
            newSize: newRowHeight,
            position: rowPosition,
            translation: {
              x: translation.x + origin.x,
              y: translation.y + origin.y
            }
          })
        );
        rowPosition += newRowHeight;
      });
      if (splitByColumns.length === 0 && splitByRows.length === 0) {
        items.forEach((item) => {
          const { position: itemPos } = translateBlockItem(item, translation);
          changes[item.item] = __spreadProps(__spreadValues({}, item), {
            position: __spreadProps(__spreadValues({}, itemPos), {
              y: position,
              h: newSize
            })
          });
        });
      }
      return changes;
    };
    var HorizontalResizeConfig = {
      dimension: "width",
      blockSizeDimension: "w",
      blockPosDimension: "x",
      splitGridConfig: "columns",
      splitGridKey: "splitByColumns",
      recursiveResizeFn: recursivelyApplyHorizontalResize
    };
    var VerticalResizeConfig = {
      dimension: "height",
      blockSizeDimension: "h",
      blockPosDimension: "y",
      splitGridConfig: "rows",
      splitGridKey: "splitByRows",
      recursiveResizeFn: recursivelyApplyVerticalResize
    };
    var handleResizing = ({
      container,
      itemToRemove,
      config: {
        dimension,
        blockSizeDimension,
        blockPosDimension,
        splitGridConfig,
        splitGridKey,
        recursiveResizeFn
      }
    }) => {
      if (!container) {
        return {};
      }
      const {
        origin,
        content: {
          // Items in the container which are being resized
          items: impactedItems,
          // The important container dimension (width or height) being recalculated
          [dimension]: containerSize
        }
      } = container;
      const negatedOrigin = { x: -origin.x, y: -origin.y };
      if (impactedItems.length < 2) {
        return {};
      }
      if (impactedItems.length === 2) {
        const itemToUpdate = impactedItems[0].item !== itemToRemove.item ? impactedItems[0] : impactedItems[1];
        return {
          [itemToUpdate.item]: __spreadProps(__spreadValues({}, itemToUpdate), {
            position: __spreadProps(__spreadValues({}, itemToUpdate.position), {
              [blockPosDimension]: origin[blockPosDimension],
              [blockSizeDimension]: containerSize
            })
          })
        };
      }
      const pendingChanges = {};
      const {
        [splitGridKey]: splitByResizeDimension,
        itemToRemove: {
          position: { [blockSizeDimension]: itemToRemoveSize }
        }
      } = splitGrid({
        layoutStructure: translateBlockItems(impactedItems, negatedOrigin),
        splitConfig: splitGridConfig,
        idToRemove: itemToRemove.item
      });
      const pctToDistribute = itemToRemoveSize / (splitByResizeDimension.length - 1) / containerSize;
      let itemPosition = origin[blockPosDimension];
      const containerEdge = origin[blockPosDimension] + containerSize;
      let lastFRCIdx = splitByResizeDimension.length - 2;
      splitByResizeDimension.forEach((split, idx) => {
        if (split.content.items[0].item === itemToRemove.item) {
          lastFRCIdx += 1;
          return;
        }
        const splitSize = split.content[dimension] / containerSize;
        let newSize = Math.floor(containerSize * (pctToDistribute + splitSize));
        if (idx === lastFRCIdx && itemPosition + newSize !== containerEdge) {
          newSize = containerEdge - itemPosition;
        }
        Object.values(
          recursiveResizeFn({
            container: split,
            newSize,
            position: itemPosition,
            translation: origin
          })
        ).forEach((change) => {
          pendingChanges[change.item] = change;
        });
        itemPosition += newSize;
      });
      return pendingChanges;
    };
    var handleHorizontalResizing = (args) => handleResizing(__spreadProps(__spreadValues({}, args), { config: HorizontalResizeConfig }));
    var handleVerticalResizing = (args) => handleResizing(__spreadProps(__spreadValues({}, args), { config: VerticalResizeConfig }));
    var cloneLayoutStructure = (source) => {
      if (!source.length) {
        return [];
      }
      return (0, lodash_exports.cloneDeep)(source);
    };
    var createStructureMap = (structure) => Object.fromEntries(structure.map((item) => [item.item, item]));
    var getWidthFromStructure = (structure) => {
      const [min, max] = structure.reduce(
        ([minX, maxX], { position: { x, w } }) => [
          // minX = either block item left or current minX (initial: MAX_SAFE_INTEGER)
          Math.min(minX, x),
          // maxX = either block item right or current maxX (initial: 0)
          Math.max(maxX, x + w)
        ],
        [Number.MAX_SAFE_INTEGER, 0]
      );
      return Math.max(max - min, 0);
    };
    var popTopLeftBlock = ({
      itemsToRemove,
      itemMap
    }) => {
      let result = itemMap[itemsToRemove[0].item];
      let resultIdx = 0;
      itemsToRemove.forEach(({ item }, idx) => {
        const itemMapItem = itemMap[item];
        if (result.position.y > itemMapItem.position.y) {
          result = itemMapItem;
          resultIdx = idx;
          return;
        }
        if (result.position.y === itemMapItem.position.y && result.position.x > itemMapItem.position.x) {
          result = itemMapItem;
          resultIdx = idx;
        }
      });
      itemsToRemove.splice(resultIdx, 1);
      return result;
    };
    var applyUpdatesToStructure = ({
      structure,
      itemMap,
      itemToRemove,
      updatesMap
    }) => {
      let idxToRemove = -1;
      structure.forEach((item, idx) => {
        if (item.item === itemToRemove.item) {
          idxToRemove = idx;
        } else if (item.item in updatesMap) {
          structure[idx] = updatesMap[item.item];
          itemMap[item.item] = updatesMap[item.item];
        }
      });
      if (idxToRemove >= 0) {
        structure.splice(idxToRemove, 1);
      }
      delete itemMap[itemToRemove.item];
    };
    var baseCaseRemoval = ({
      structure,
      itemMap,
      itemToRemove,
      width
    }) => {
      const updates = (0, dashboard_utils_exports.updateRemovedVizNeighbors)({
        items: structure,
        itemToRemove,
        width
      });
      const updatesMap = createStructureMap(updates);
      applyUpdatesToStructure({
        structure,
        itemMap,
        itemToRemove,
        updatesMap
      });
    };
    var handleRecursiveItemRemoval = ({
      structure,
      itemsToRemove,
      itemMap
    }) => {
      var _a, _b;
      if (itemsToRemove.length === 0) {
        return;
      }
      const itemToRemove = popTopLeftBlock({ itemsToRemove, itemMap });
      const container = getContainingRowColumn({
        structure,
        itemToContain: itemToRemove
      });
      if (!container || container.content.items.length <= 1) {
        baseCaseRemoval({
          structure,
          itemMap,
          width: (_a = container == null ? void 0 : container.gridWidth) != null ? _a : getWidthFromStructure(structure),
          itemToRemove
        });
      } else {
        const { width, height } = container.content;
        let updatesMap;
        if (itemToRemove.position.w === width) {
          updatesMap = handleVerticalResizing({ container, itemToRemove });
        } else if (itemToRemove.position.h === height) {
          updatesMap = handleHorizontalResizing({ container, itemToRemove });
        } else {
          baseCaseRemoval({
            structure,
            width: (_b = container == null ? void 0 : container.gridWidth) != null ? _b : getWidthFromStructure(structure),
            itemToRemove,
            itemMap
          });
        }
        if (updatesMap) {
          applyUpdatesToStructure({
            structure,
            itemMap,
            itemToRemove,
            updatesMap
          });
        }
      }
      handleRecursiveItemRemoval({ structure, itemsToRemove, itemMap });
    };
    var gridLayoutShowHideReflow = (initialStructure, itemsToRemove) => {
      if (!itemsToRemove.length) {
        return initialStructure;
      }
      const newStructure = cloneLayoutStructure(
        initialStructure
      );
      const clonedItemsToRemove = cloneLayoutStructure(
        itemsToRemove
      );
      const itemMap = createStructureMap(newStructure);
      handleRecursiveItemRemoval({
        structure: newStructure,
        itemsToRemove: clonedItemsToRemove,
        itemMap
      });
      return newStructure;
    };
    var HANDLE_DIRECTIONS = [];
    var MemoizedBlockItem = react_default.memo(
      ResponsiveBlockItem_default,
      (prevProps, nextProps) => {
        if (nextProps.y + nextProps.h === nextProps.canvasHeight) {
          return (0, lodash_exports.isEqual)(prevProps, nextProps);
        }
        const prevPropsWithoutCanvasHeight = (0, lodash_exports.omit)(prevProps, "canvasHeight");
        const nextPropsWithoutCanvasHeight = (0, lodash_exports.omit)(nextProps, "canvasHeight");
        return (0, lodash_exports.isEqual)(
          prevPropsWithoutCanvasHeight,
          nextPropsWithoutCanvasHeight
        );
      }
    );
    var MemoizedBlockOutline = react_default.memo(ResponsiveBlockOutline_default);
    var MemoizedEdge = react_default.memo(Edge);
    var renderBlockItems = memoize_one_default(
      ({
        layoutStructure,
        renderLayoutItem,
        handleItemSelected,
        isBlockItemMoving,
        selectedItem,
        mode,
        errors,
        padding,
        canvasHeight
      }) => {
        return layoutStructure.map((item) => {
          const key = item.item;
          if (key === "preview-old-item") {
            return null;
          }
          const isSelected = (selectedItem == null ? void 0 : selectedItem.id) === key;
          let appearance = mode === "view" || !selectedItem || isSelected ? "highlighted" : "visible";
          if (isSelected && isBlockItemMoving) {
            appearance = "hidden";
          }
          let errorMessages;
          if (errors) {
            const vizErrors = errors.find(({ itemId }) => itemId === key);
            errorMessages = vizErrors == null ? void 0 : vizErrors.messages;
          }
          return react_default.createElement(
            MemoizedBlockItem,
            {
              key,
              itemId: key,
              type: item.type,
              x: item.position.x,
              y: item.position.y,
              h: item.position.h,
              w: item.position.w,
              padding,
              canvasHeight,
              renderLayoutItem,
              onItemSelected: handleItemSelected,
              appearance,
              errorMessages
            }
          );
        });
      },
      lodash_exports.isEqual
    );
    var BOTTOM_EDGE_MIN_SPEED = 2;
    var BOTTOM_EDGE_MAX_SPEED = 4;
    var BOTTOM_RESIZING_SCROLL_SPEED = 50;
    var CANVAS_BOTTOM_PADDING = 8;
    var defaultLayoutStructure2 = [];
    var BaseGridLayout = ({
      layoutId,
      onLayoutItemsSelect,
      selectedItems: selectedLayoutItems,
      layoutStructure = defaultLayoutStructure2,
      onLayoutStructureChange,
      options = {},
      renderLayoutItem,
      mode,
      scale,
      setCanvasHeight,
      canvasWidth
    }) => {
      const canvasRef = (0, dashboard_context_exports.useCanvasRef)(layoutId);
      const keyboardListener = (0, dashboard_context_exports.useKeyboardListener)();
      const telemetryAPI = (0, dashboard_telemetry_exports.useTelemetryApi)();
      const { enableGridLayoutErrors, enableGridLayoutCssScaling } = (0, dashboard_context_exports.useFeatureFlags)();
      const { backgroundColor, gutterSize = gridLayoutOptions.gutterSize } = options;
      const panelPadding = gutterSize / 2;
      const [gridState, dispatch] = (0, react_exports.useReducer)(
        gridReducer,
        layoutStructure,
        initializeGridReducer
      );
      const maxHeight = computeMaxHeight(getBlockItems(gridState));
      (0, react_exports.useLayoutEffect)(() => {
        setCanvasHeight(maxHeight);
      }, [setCanvasHeight, maxHeight]);
      const [isBlockItemMoving, setIsBlockItemMoving] = (0, react_exports.useState)(false);
      const [edges, setEdges] = (0, react_exports.useState)(
        computeEdges({
          layout: layoutStructure,
          canvasWidth,
          canvasHeight: computeMaxHeight(layoutStructure)
          // need to recompute height on layout change
        })
      );
      const [snappableEdges, setSnappableEdges] = (0, react_exports.useState)([]);
      const [mousePosition, setMousePosition] = (0, react_exports.useState)(null);
      const [edgesBeforeMove, setEdgesBeforeMove] = (0, react_exports.useState)(
        null
      );
      const [invalidEdgeId, setInvalidEdgeId] = (0, react_exports.useState)(null);
      const [hoveredEdge, setHoveredEdge] = (0, react_exports.useState)(null);
      const [initialItemToMove, setInitialItemToMove] = (0, react_exports.useState)(null);
      const [hoveredBlock, setHoveredBlock] = (0, react_exports.useState)(
        null
      );
      const [hoveredQuadrant, setHoveredQuadrant] = (0, react_exports.useState)(
        null
      );
      const [, setForceUpdate] = (0, react_exports.useState)(0);
      const [selectedItemsForEdge, setSelectedItemsForEdge] = (0, react_exports.useState)(
        []
      );
      const [isInvalidVizDrop, setIsInvalidVizDrop] = (0, react_exports.useState)(false);
      const [showPreviewPlaceholder, setShowPreviewPlaceholder] = (0, react_exports.useState)(true);
      const [layoutErrors, setLayoutErrors] = (0, react_exports.useState)([]);
      const isDraggingEdge = (0, react_exports.useRef)(false);
      const delayPreviewEdge = (0, react_exports.useRef)(null);
      const delayPreviewViz = (0, react_exports.useRef)(null);
      const mouseDownEdge = (0, react_exports.useRef)(null);
      const edgeMouseDownPosition = (0, react_exports.useRef)(null);
      const edgeBoundaries = (0, react_exports.useRef)(null);
      const edgesInBoundary = (0, react_exports.useRef)(null);
      const cumulativeScrollIncrease = (0, react_exports.useRef)(0);
      const edgeVelocity = (0, react_exports.useRef)(0);
      const containsPreviewItem = hasPreviewItem(gridState);
      const sendTelemetry = (0, react_exports.useCallback)(
        (eventData) => {
          telemetryAPI.collect(eventData);
        },
        [telemetryAPI]
      );
      const firstSelectedItemStructure = (0, react_exports.useMemo)(
        () => (selectedLayoutItems == null ? void 0 : selectedLayoutItems.length) ? getItem(gridState, selectedLayoutItems[0].id) : null,
        [gridState, selectedLayoutItems]
      );
      const prevLayoutStructure = (0, dashboard_ui_exports.usePrevious)(layoutStructure);
      (0, react_exports.useEffect)(() => {
        if (mode === "edit" && enableGridLayoutErrors) {
          const errors = validateLayoutStructure({
            layout: layoutStructure,
            canvasBounds: { x: 0, y: 0, w: canvasWidth, h: maxHeight }
          });
          setLayoutErrors(errors);
        } else if (mode === "view") {
          setLayoutErrors([]);
        }
      }, [layoutStructure, mode, enableGridLayoutErrors, canvasWidth, maxHeight]);
      (0, react_exports.useEffect)(() => {
        if ((0, lodash_exports.isEqual)(prevLayoutStructure, layoutStructure)) {
          return;
        }
        dispatch(resetLayoutAction(layoutStructure));
        const canvasHeight = computeMaxHeight(layoutStructure);
        setEdges(
          computeEdges({
            layout: layoutStructure,
            canvasWidth,
            canvasHeight
            // need to recompute height on layout change
          })
        );
      }, [layoutStructure, canvasWidth, prevLayoutStructure]);
      const handleLayoutStructureChange = (0, react_exports.useCallback)(() => {
        const layout = getBlockItems(gridState);
        onLayoutStructureChange(layout);
      }, [onLayoutStructureChange, gridState]);
      const getSelectedItems = (0, react_exports.useMemo)(() => {
        let itemsCache;
        return () => {
          const filteredItems = filterSelectedItems(
            layoutStructure,
            selectedLayoutItems
          );
          if (!(0, lodash_exports.isEqual)(itemsCache, filteredItems)) {
            itemsCache = filteredItems;
          }
          return itemsCache;
        };
      }, [layoutStructure, selectedLayoutItems]);
      const handleItemSelected = (0, react_exports.useCallback)(
        (_e, selectedItems = []) => {
          const selectedItem = selectedItems.length > 0 ? [selectedItems[selectedItems.length - 1]] : [];
          onLayoutItemsSelect(selectedItem);
        },
        [onLayoutItemsSelect]
      );
      const mouseScale = enableGridLayoutCssScaling ? scale : 1;
      (0, react_exports.useEffect)(() => {
        var _a;
        let delayed;
        const layoutContainer = (_a = canvasRef.current) == null ? void 0 : _a.parentElement;
        if (!isBlockItemMoving || !mousePosition || !layoutContainer) {
          return () => void 0;
        }
        const visibleCanvasHeight = layoutContainer.clientHeight / mouseScale;
        const hasScrolledToBottom = layoutContainer.scrollTop / mouseScale + visibleCanvasHeight >= maxHeight;
        const isInBottomScrollArea = layoutContainer.scrollTop / mouseScale + visibleCanvasHeight - mousePosition.y < MIN_HEIGHT_PX;
        const hasScrolledToTop = layoutContainer.scrollTop <= 0;
        const isInTopScrollArea = mousePosition.y - layoutContainer.scrollTop / mouseScale < MIN_HEIGHT_PX;
        if (!hasScrolledToBottom && isInBottomScrollArea) {
          const increment = Math.min(
            Math.abs(
              maxHeight - (layoutContainer.scrollTop / mouseScale + visibleCanvasHeight)
            ),
            10
          );
          delayed = setTimeout(() => {
            layoutContainer.scrollTop += increment;
            setMousePosition(
              (pos) => pos ? __spreadProps(__spreadValues({}, pos), {
                y: pos.y + increment / mouseScale
              }) : null
            );
          }, 32);
        } else if (!hasScrolledToTop && isInTopScrollArea) {
          const decrement = Math.min(layoutContainer.scrollTop, 10);
          delayed = setTimeout(() => {
            layoutContainer.scrollTop -= decrement;
            setMousePosition(
              (pos) => pos ? __spreadProps(__spreadValues({}, pos), {
                y: pos.y - decrement / mouseScale
              }) : null
            );
          }, 32);
        }
        return () => {
          clearTimeout(delayed);
        };
      }, [isBlockItemMoving, mousePosition, mouseScale, maxHeight, canvasRef]);
      const resetEdgePreviewState = (0, react_exports.useCallback)(() => {
        if (edgesBeforeMove) {
          if (delayPreviewEdge.current) {
            clearTimeout(delayPreviewEdge.current);
          }
          setEdges(edgesBeforeMove);
          dispatch(resetLayoutAction(layoutStructure));
        }
      }, [edgesBeforeMove, layoutStructure]);
      const showEdgeDropPreview = (0, react_exports.useCallback)(
        ({ mousePos }) => {
          if (edgesBeforeMove === null) {
            setEdgesBeforeMove(edges);
          }
          const validEdges = edgesBeforeMove || edges;
          const edge = validEdges.find((edgeToFind) => {
            return isMouseOnEdge({
              edge: edgeToFind,
              mousePosition: mousePos,
              padding: panelPadding
            });
          });
          if (!edge) {
            if (hoveredEdge) {
              setHoveredEdge(null);
              setInvalidEdgeId(null);
              resetEdgePreviewState();
            }
            return;
          }
          if (!hoveredEdge || hoveredEdge.item !== edge.item) {
            let itemToMove = firstSelectedItemStructure;
            if (!initialItemToMove) {
              setInitialItemToMove(itemToMove);
            } else {
              itemToMove = initialItemToMove;
            }
            if (isDropOnOwnEdge({
              edge,
              itemToMove
            })) {
              return;
            }
            const updatedItems = previewDropOnEdge({
              edge,
              itemToMove,
              items: layoutStructure,
              canvasWidth
            });
            if (updatedItems) {
              setInvalidEdgeId(null);
              if (delayPreviewEdge.current) {
                clearTimeout(delayPreviewEdge.current);
              }
              setShowPreviewPlaceholder(false);
              delayPreviewEdge.current = setTimeout(() => {
                dispatch(resetLayoutAction(updatedItems));
                setEdges(
                  computeEdges({
                    layout: updatedItems,
                    canvasWidth,
                    canvasHeight: computeMaxHeight(updatedItems)
                  })
                );
                setShowPreviewPlaceholder(true);
              }, EDGE_PREVIEW_DELAY_MS);
            } else {
              setShowPreviewPlaceholder(true);
              setInvalidEdgeId(edge.item);
              resetEdgePreviewState();
            }
          }
          setHoveredEdge(edge);
        },
        [
          firstSelectedItemStructure,
          edgesBeforeMove,
          edges,
          hoveredEdge,
          panelPadding,
          resetEdgePreviewState,
          initialItemToMove,
          layoutStructure,
          canvasWidth
        ]
      );
      const showVizDropPreview = (0, react_exports.useCallback)(
        ({ mousePos }) => {
          const block = findTopBlockItemByPosition(
            layoutStructure,
            mousePos,
            panelPadding
          );
          let itemToMove = firstSelectedItemStructure;
          if (!initialItemToMove) {
            setInitialItemToMove(itemToMove);
          } else {
            itemToMove = initialItemToMove;
          }
          if (block === void 0 || block.item === (itemToMove == null ? void 0 : itemToMove.item)) {
            if (delayPreviewViz.current) {
              clearTimeout(delayPreviewViz.current);
            }
            setHoveredQuadrant(null);
            setHoveredBlock(null);
            setIsInvalidVizDrop(false);
            if (hoveredBlock) {
              dispatch(resetLayoutAction(layoutStructure));
            }
            return;
          }
          const currentQuadrant = findQuadrant({
            item: applyVizPadding({ item: block, padding: panelPadding }),
            position: mousePos
          });
          if (!hoveredBlock && !hoveredQuadrant || hoveredQuadrant !== currentQuadrant || (hoveredBlock == null ? void 0 : hoveredBlock.item) !== block.item) {
            if (isInvalidAdjacentVizDrop({
              itemToMove,
              itemToDropOn: block,
              visualizations: layoutStructure,
              direction: currentQuadrant
            })) {
              return;
            }
            const updatedItems = previewDropOnViz({
              itemToDropOn: block,
              itemToMove,
              items: layoutStructure,
              direction: currentQuadrant
            });
            if (delayPreviewViz.current) {
              clearTimeout(delayPreviewViz.current);
            }
            if (updatedItems) {
              setIsInvalidVizDrop(false);
              setHoveredQuadrant(currentQuadrant);
              setHoveredBlock(block);
              setShowPreviewPlaceholder(false);
              delayPreviewViz.current = setTimeout(() => {
                dispatch(resetLayoutAction(updatedItems));
                setForceUpdate(
                  (prevForceUpdate) => prevForceUpdate + 1
                );
                setShowPreviewPlaceholder(true);
              }, VIZ_PREVIEW_DELAY_MS);
            } else {
              setHoveredQuadrant(null);
              setHoveredBlock(null);
              setIsInvalidVizDrop(true);
              if (hoveredBlock) {
                dispatch(resetLayoutAction(layoutStructure));
              }
            }
          }
        },
        [
          firstSelectedItemStructure,
          panelPadding,
          hoveredBlock,
          hoveredQuadrant,
          initialItemToMove,
          layoutStructure
        ]
      );
      const renderItemDropTarget = memoize_one_default(
        ({
          position,
          direction
        }) => {
          return react_default.createElement(ItemDropTarget, { position, direction });
        }
      );
      const handleRenderItemDropTarget = (0, react_exports.useCallback)(() => {
        let block = findTopBlockItemByPosition(
          layoutStructure,
          mousePosition,
          panelPadding
        );
        const selectedItems = getSelectedItems();
        if (block !== void 0 && selectedItems.length > 0 && block.item !== selectedItems[0].id && // disables drop targets when showing preview
        !hoveredQuadrant) {
          block = applyVizPadding({ item: block, padding: panelPadding });
          return renderItemDropTarget({
            position: block.position,
            direction: findQuadrant({
              item: block,
              position: mousePosition
            })
          });
        }
        return null;
      }, [
        layoutStructure,
        panelPadding,
        getSelectedItems,
        hoveredQuadrant,
        mousePosition,
        renderItemDropTarget
      ]);
      const handleShowPreviewPlaceholder = (0, react_exports.useCallback)(
        ({ mousePos }) => {
          const selectedItem = getSelectedItems()[0];
          if (!selectedItem) {
            setShowPreviewPlaceholder(false);
            return;
          }
          const hoveredViz = findTopBlockItemByPosition(
            layoutStructure,
            mousePos,
            panelPadding
          );
          if (hoveredViz && hoveredViz.item === selectedItem.id) {
            setShowPreviewPlaceholder(true);
            return;
          }
          if (invalidEdgeId !== null || isInvalidVizDrop) {
            setShowPreviewPlaceholder(true);
            return;
          }
          if (containsPreviewItem) {
            setShowPreviewPlaceholder(true);
            return;
          }
          setShowPreviewPlaceholder(false);
        },
        [
          containsPreviewItem,
          panelPadding,
          getSelectedItems,
          invalidEdgeId,
          isInvalidVizDrop,
          layoutStructure
        ]
      );
      const handleBlockItemMove = (0, react_exports.useCallback)(
        (_e, { currentPosition }) => {
          if (getSelectedItems().length > 0) {
            handleShowPreviewPlaceholder({ mousePos: currentPosition });
            setIsBlockItemMoving(true);
            setMousePosition(currentPosition);
            showEdgeDropPreview({ mousePos: currentPosition });
            showVizDropPreview({ mousePos: currentPosition });
          }
        },
        [
          getSelectedItems,
          showEdgeDropPreview,
          showVizDropPreview,
          handleShowPreviewPlaceholder
        ]
      );
      const handleVizDrop = (0, react_exports.useCallback)(() => {
        const validEdges = edgesBeforeMove || edges;
        const selectedItems = getSelectedItems();
        if (selectedItems.length === 0) {
          return;
        }
        const edge = validEdges.find((e) => {
          return isMouseOnEdge({
            edge: e,
            mousePosition,
            padding: panelPadding
          });
        });
        const block = findTopBlockItemByPosition(
          layoutStructure,
          mousePosition,
          panelPadding
        );
        const itemToMove = layoutStructure.find(
          ({ item }) => item === selectedItems[0].id
        );
        if (block === itemToMove) {
          sendTelemetry({
            source: "canvas",
            event: "viz_drop_on_self_successful"
          });
          return;
        }
        const itemsSelected = layoutStructure;
        let updatedItems = null;
        if (edge !== void 0) {
          updatedItems = updateDropOnEdge({
            edge,
            itemToMove,
            items: itemsSelected,
            canvasWidth
          });
          if (updatedItems === null) {
            sendTelemetry({
              source: "canvas",
              event: "viz_drop_on_edge_unsuccessful"
            });
            return;
          }
          updatedItems = updateItems({
            updatedVisualizations: updatedItems.updatedVisualizations,
            itemToMove: updatedItems.updatedItemToMove,
            items: itemsSelected,
            canvasWidth
          });
          sendTelemetry({
            source: "canvas",
            event: "viz_drop_on_edge_successful"
          });
        } else if (block !== void 0 && block.item !== selectedItems[0].id) {
          const direction = findQuadrant({
            item: applyVizPadding({ item: block, padding: panelPadding }),
            position: mousePosition
          });
          if (isInvalidAdjacentVizDrop({
            itemToMove,
            itemToDropOn: block,
            direction,
            visualizations: layoutStructure
          })) {
            return;
          }
          const updatedVisualizations = updateDropOnViz({
            itemToMove,
            itemToDropOn: block,
            direction
          });
          if (updatedVisualizations === null) {
            sendTelemetry({
              source: "canvas",
              event: "viz_drop_on_viz_unsuccessful"
            });
            return;
          }
          updatedItems = updateItems({
            updatedVisualizations,
            itemToMove,
            items: itemsSelected,
            canvasWidth
          });
          sendTelemetry({
            source: "canvas",
            event: "viz_drop_on_viz_successful"
          });
        }
        if (updatedItems != null) {
          onLayoutStructureChange(updatedItems);
        }
      }, [
        layoutStructure,
        edgesBeforeMove,
        edges,
        getSelectedItems,
        mousePosition,
        panelPadding,
        sendTelemetry,
        canvasWidth,
        onLayoutStructureChange
      ]);
      const cleanupAfterPreview = (0, react_exports.useCallback)(() => {
        if (delayPreviewViz.current) {
          clearTimeout(delayPreviewViz.current);
        }
        if (delayPreviewEdge.current) {
          clearTimeout(delayPreviewEdge.current);
        }
        setInvalidEdgeId(null);
        setIsInvalidVizDrop(false);
        setInitialItemToMove(null);
        setHoveredBlock(null);
        setHoveredQuadrant(null);
        if (edgesBeforeMove) {
          setEdges(edgesBeforeMove);
          setEdgesBeforeMove(null);
          dispatch(resetLayoutAction(layoutStructure));
        }
        if (hoveredBlock) {
          dispatch(resetLayoutAction(layoutStructure));
        }
      }, [edgesBeforeMove, hoveredBlock, layoutStructure]);
      const handleBlockItemMoved = (0, react_exports.useCallback)(() => {
        cleanupAfterPreview();
        if (mousePosition !== null) {
          handleVizDrop();
        }
        setIsBlockItemMoving(false);
        setMousePosition(null);
      }, [cleanupAfterPreview, mousePosition, handleVizDrop]);
      const handleBlockItemPositionUpdate = (0, react_exports.useCallback)(
        ({ item, offset }) => {
          const newItem = updateBlockItemPosition(item, offset);
          dispatch(updateItemAction(newItem));
        },
        []
      );
      const handleBlockItemResize = (0, react_exports.useCallback)(
        (_e, {
          itemId,
          offset,
          dir
        }) => {
          const item = getStructureItem(layoutStructure, itemId);
          const newItem = updateBlockItemSize({
            item,
            offset,
            dir,
            options: {
              minHeight: MIN_HEIGHT_PX,
              minWidth: MIN_WIDTH_PX
            }
          });
          dispatch(updateItemAction(newItem));
        },
        [layoutStructure]
      );
      const handleBlockItemResized = (0, react_exports.useCallback)(() => {
        handleLayoutStructureChange();
        sendTelemetry({
          source: "canvas",
          event: "edge_resize"
        });
      }, [handleLayoutStructureChange, sendTelemetry]);
      const handleMouseDownOnEdge = (0, react_exports.useCallback)(
        (e, { id }) => {
          isDraggingEdge.current = true;
          const edge = edges.find(({ item }) => item === id);
          if (!edge) {
            return;
          }
          const visualizationIds = edge.visualizations.map((viz) => viz.item);
          const newEdgeBoundaries = edge.orientation === "horizontal" ? getVerticalBoundaries({
            visualizations: edge.visualizations,
            y: edge.edgeStart.y,
            minHeight: MIN_HEIGHT_PX,
            isFullWidthEdge: edge.edgeEnd.x - edge.edgeStart.x === canvasWidth
          }) : getHorizontalBoundaries({
            visualizations: edge.visualizations,
            x: edge.edgeStart.x,
            minWidth: MIN_WIDTH_PX
          });
          edgeBoundaries.current = newEdgeBoundaries;
          edgesInBoundary.current = findEdgesInBoundary({
            edge,
            edges,
            edgeBoundaries: newEdgeBoundaries
          });
          edgeMouseDownPosition.current = getClientPosition(e, mouseScale);
          mouseDownEdge.current = __spreadValues({}, edge);
          setSelectedItemsForEdge(visualizationIds);
        },
        [edges, mouseScale, canvasWidth]
      );
      const handleEdgeMove = (0, dashboard_ui_exports.useEventCallback)((e) => {
        var _a, _b, _c, _d;
        e.preventDefault();
        e.stopPropagation();
        if (!isDraggingEdge.current || !mouseDownEdge.current) {
          return;
        }
        const currentPosition = getClientPosition(e, mouseScale);
        const offset = getOffset(
          currentPosition,
          edgeMouseDownPosition.current
        );
        offset.offsetY += cumulativeScrollIncrease.current;
        let updatedEdge = ((_a = mouseDownEdge == null ? void 0 : mouseDownEdge.current) == null ? void 0 : _a.orientation) === "vertical" ? moveVerticalEdge({
          edge: mouseDownEdge.current,
          offset: offset.offsetX,
          edgeBoundaries: edgeBoundaries.current
        }) : moveHorizontalEdge({
          edge: mouseDownEdge.current,
          offset: offset.offsetY,
          edgeBoundaries: edgeBoundaries.current
        });
        let updatedSnappableEdges = [];
        if (!e.shiftKey) {
          const { updatedEdge: ue, snappableEdges: se } = findSnappableEdges({
            edge: updatedEdge,
            edges: (_b = edgesInBoundary.current) != null ? _b : [],
            snapRange: SNAP_RANGE_PX
          });
          updatedEdge = ue;
          updatedSnappableEdges = se;
        }
        setEdges(
          (prevEdges) => prevEdges.map((anEdge) => {
            if (anEdge.item === updatedEdge.item) {
              return updatedEdge;
            }
            return anEdge;
          })
        );
        const vizOffset = {
          offsetX: updatedEdge.edgeStart.x - mouseDownEdge.current.edgeStart.x,
          offsetY: updatedEdge.edgeStart.y - mouseDownEdge.current.edgeStart.y
        };
        const isFullWidthEdge = mouseDownEdge.current.edgeEnd.x - mouseDownEdge.current.edgeStart.x === canvasWidth;
        if (isFullWidthEdge) {
          layoutStructure.forEach((item) => {
            if (mouseDownEdge.current && item.position.y >= mouseDownEdge.current.edgeStart.y) {
              handleBlockItemPositionUpdate({
                item,
                offset: vizOffset
              });
            }
          });
        }
        if (selectedItemsForEdge.length > 0) {
          selectedItemsForEdge.forEach((itemId) => {
            var _a2;
            const item = getStructureItem(layoutStructure, itemId);
            if (!mouseDownEdge.current || isFullWidthEdge && item.position.y >= mouseDownEdge.current.edgeStart.y) {
              return;
            }
            let resizeDir;
            if (((_a2 = mouseDownEdge.current) == null ? void 0 : _a2.orientation) === "horizontal") {
              resizeDir = item.position.y >= mouseDownEdge.current.edgeStart.y ? "n" : "s";
            } else {
              resizeDir = item.position.x >= mouseDownEdge.current.edgeStart.x ? "w" : "e";
            }
            handleBlockItemResize(e, {
              itemId,
              offset: vizOffset,
              dir: resizeDir
            });
          });
        }
        setSnappableEdges(updatedSnappableEdges);
        if (((_c = mouseDownEdge == null ? void 0 : mouseDownEdge.current) == null ? void 0 : _c.orientation) === "horizontal" && ((_d = mouseDownEdge == null ? void 0 : mouseDownEdge.current) == null ? void 0 : _d.isCanvasEdge)) {
          const scrollVelocity = e.clientY - window.innerHeight + CANVAS_BOTTOM_PADDING * 2;
          edgeVelocity.current = scrollVelocity;
          setMousePosition(getClientPosition(e, mouseScale));
        }
      });
      (0, dashboard_ui_exports.useMouseMoveHandler)({
        onMouseMove: handleEdgeMove,
        isEnabled: mode === "edit",
        throttledMs: 32
      });
      (0, react_exports.useEffect)(() => {
        if (mode !== "edit" || edgeVelocity.current <= 0 || !mouseDownEdge.current || !edgeMouseDownPosition.current || !mousePosition) {
          return void 0;
        }
        const currEdge = mouseDownEdge.current;
        const isFullWidthEdge = currEdge.edgeEnd.x - currEdge.edgeStart.x === canvasWidth;
        if (!isFullWidthEdge) {
          return void 0;
        }
        const offset = edgeVelocity.current > 8 ? BOTTOM_EDGE_MAX_SPEED : BOTTOM_EDGE_MIN_SPEED;
        const edgeMousePos = edgeMouseDownPosition.current;
        const interval = setInterval(() => {
          var _a;
          cumulativeScrollIncrease.current += offset;
          const mouseOffset = getOffset(mousePosition, edgeMousePos);
          const updatedEdge = moveHorizontalEdge({
            edge: currEdge,
            offset: mouseOffset.offsetY + cumulativeScrollIncrease.current,
            edgeBoundaries: edgeBoundaries.current
          });
          setEdges(
            (prevEdges) => prevEdges.map((anEdge) => {
              if (anEdge.item === currEdge.item) {
                return __spreadProps(__spreadValues({}, anEdge), {
                  edgeStart: {
                    x: anEdge.edgeStart.x,
                    y: updatedEdge.edgeStart.y
                  },
                  edgeEnd: {
                    x: anEdge.edgeEnd.x,
                    y: updatedEdge.edgeStart.y
                  }
                });
              }
              return anEdge;
            })
          );
          const vizOffset = {
            offsetX: 0,
            offsetY: updatedEdge.edgeStart.y - currEdge.edgeStart.y
          };
          if (selectedItemsForEdge.length > 0) {
            selectedItemsForEdge.forEach((itemId) => {
              const resizeDir = "s";
              handleBlockItemResize(mousePosition, {
                itemId,
                offset: vizOffset,
                dir: resizeDir
              });
            });
          }
          if ((_a = canvasRef.current) == null ? void 0 : _a.parentElement) {
            canvasRef.current.parentElement.scrollTop += BOTTOM_RESIZING_SCROLL_SPEED;
          }
        }, 32);
        return () => {
          clearInterval(interval);
        };
      }, [
        mode,
        edgeVelocity,
        mousePosition,
        cumulativeScrollIncrease,
        canvasRef,
        canvasWidth,
        handleBlockItemResize,
        layoutStructure,
        selectedItemsForEdge
      ]);
      const handleEdgeMoved = (0, dashboard_ui_exports.useEventCallback)((e) => {
        e.preventDefault();
        mouseDownEdge.current = null;
        edgeMouseDownPosition.current = null;
        edgeBoundaries.current = null;
        edgesInBoundary.current = null;
        cumulativeScrollIncrease.current = 0;
        edgeVelocity.current = 0;
        if (isDraggingEdge.current) {
          isDraggingEdge.current = false;
          setSelectedItemsForEdge([]);
          handleBlockItemResized();
        }
        if (snappableEdges.length > 0) {
          setSnappableEdges([]);
        }
      });
      (0, react_exports.useEffect)(() => {
        if (mode !== "edit") {
          return void 0;
        }
        document.addEventListener("mouseup", handleEdgeMoved);
        return () => {
          document.removeEventListener("mouseup", handleEdgeMoved);
        };
      }, [handleEdgeMoved, mode]);
      (0, react_exports.useEffect)(() => {
        if (!keyboardListener) {
          return () => void 0;
        }
        const unsubscribeKeyboardListener = keyboardListener.subscribe(
          "cancel",
          () => {
            if (isBlockItemMoving) {
              cleanupAfterPreview();
              setIsBlockItemMoving(false);
              setMousePosition(null);
            } else {
              onLayoutItemsSelect([]);
            }
          }
        );
        return () => {
          unsubscribeKeyboardListener();
        };
      }, [
        cleanupAfterPreview,
        isBlockItemMoving,
        onLayoutItemsSelect,
        keyboardListener
      ]);
      const renderOutline = () => {
        const selectedItems = selectedItemsForEdge.length > 0 ? selectedItemsForEdge : getSelectedItems().map(({ id }) => id);
        const blockItems = getBlockItems(gridState);
        return blockItems.map((item) => {
          const displayOutline = selectedItems.includes(item.item) && (!isBlockItemMoving || showPreviewPlaceholder);
          if (displayOutline) {
            const paddedItem = applyVizPadding({
              item,
              padding: panelPadding
            });
            return react_default.createElement(
              MemoizedBlockOutline,
              {
                handleDirections: HANDLE_DIRECTIONS,
                key: item.item,
                itemId: item.item,
                scale: mouseScale,
                x: paddedItem.position.x,
                y: paddedItem.position.y,
                w: paddedItem.position.w,
                h: paddedItem.position.h
              }
            );
          }
          return null;
        });
      };
      const getEdgeAppearance = (0, react_exports.useCallback)(
        ({ edge }) => {
          var _a;
          const renderAllEdges = !mouseDownEdge.current;
          let appearance = renderAllEdges || edge.item === ((_a = mouseDownEdge.current) == null ? void 0 : _a.item) || snappableEdges.find((e) => e.item === edge.item) ? "normal" : "hidden";
          if (isBlockItemMoving) {
            const itemToMove = layoutStructure.find(
              ({ item }) => {
                var _a2;
                return item === ((_a2 = getSelectedItems()[0]) == null ? void 0 : _a2.id);
              }
            );
            if (itemToMove && isDropOnOwnEdge({ edge, itemToMove })) {
              appearance = "hidden";
            } else {
              appearance = "dropTarget";
            }
          }
          if (invalidEdgeId === edge.item) {
            appearance = "invalid";
          }
          return appearance;
        },
        [
          invalidEdgeId,
          isBlockItemMoving,
          mouseDownEdge,
          snappableEdges,
          getSelectedItems,
          layoutStructure
        ]
      );
      const edgeItems = (0, react_exports.useMemo)(() => {
        if (mode !== "edit") {
          return null;
        }
        return edges.map((edge) => {
          const formattedEdge = formatEdgeWrapper({
            edge,
            padding: panelPadding
          });
          const { width, height } = getDimensions({
            edge: formattedEdge,
            thickness: 2 * panelPadding
          });
          const { x, y } = formattedEdge.edgeStart;
          return react_default.createElement(
            MemoizedEdge,
            {
              key: edge.item,
              itemId: edge.item,
              x,
              y,
              w: width,
              h: height,
              padding: panelPadding,
              orientation: edge.orientation,
              isCanvasEdge: edge.isCanvasEdge,
              appearance: getEdgeAppearance({ edge }),
              onMouseDown: handleMouseDownOnEdge,
              "data-test-edge-position": `${edge.edgeStart.x},${edge.edgeStart.y}-${edge.edgeEnd.x},${edge.edgeEnd.y}`
            }
          );
        });
      }, [mode, edges, getEdgeAppearance, panelPadding, handleMouseDownOnEdge]);
      const handleRenderPreviewPlaceholderItem = (0, react_exports.useCallback)(() => {
        if (!firstSelectedItemStructure || !showPreviewPlaceholder) {
          return null;
        }
        const item = applyVizPadding({
          item: firstSelectedItemStructure,
          padding: panelPadding
        });
        return react_default.createElement(
          PreviewPlaceholderItem,
          {
            key: `${firstSelectedItemStructure.item}-preview`,
            position: item.position
          }
        );
      }, [firstSelectedItemStructure, panelPadding, showPreviewPlaceholder]);
      const filteredState = (0, react_exports.useMemo)(
        () => getFilteredStructure(gridState, layoutStructure),
        [gridState, layoutStructure]
      );
      const items = getSelectedItems();
      const commonProps = {
        width: canvasWidth,
        height: maxHeight,
        scale,
        selectable: true,
        selectedLayoutItems: items,
        onItemSelected: handleItemSelected,
        panelPadding,
        ref: canvasRef
      };
      const modeSpecificProps = mode === "edit" ? {
        movable: true,
        showOverflowContent: false,
        showBorder: true,
        gridWidth: GRID_SIZE_PX - 1,
        gridHeight: GRID_SIZE_PX - 1,
        gridLineWidth: 1,
        gridPadding: GRID_PADDING_PX,
        onItemMove: handleBlockItemMove,
        onItemMoved: handleBlockItemMoved,
        userSelect: false
      } : {
        movable: false,
        showOverflowContent: false,
        showBorder: false,
        userSelect: true
      };
      return react_default.createElement(
        GridCanvas_default,
        __spreadValues(__spreadValues({
          "data-test": "grid-layout",
          blockItems: filteredState,
          "data-test-scale": scale,
          backgroundColor
        }, commonProps), modeSpecificProps),
        react_default.createElement(Layer_default, { key: "block-item-layer", "data-test": "block-item-layer" }, renderBlockItems({
          layoutStructure: filteredState,
          renderLayoutItem,
          handleItemSelected,
          isBlockItemMoving,
          selectedItem: getSelectedItems()[0],
          mode,
          errors: layoutErrors,
          padding: panelPadding,
          canvasHeight: maxHeight
        })),
        edgeItems,
        react_default.createElement(Layer_default, { key: "outline-layer", "data-test": "outline-layer" }, renderOutline()),
        mousePosition && isBlockItemMoving && handleRenderItemDropTarget(),
        mousePosition && isBlockItemMoving && handleRenderPreviewPlaceholderItem(),
        mousePosition && isBlockItemMoving && react_default.createElement(
          ItemDragPlaceholder,
          {
            position: mousePosition,
            size: PLACEHOLDER_SIZE_PX
          }
        )
      );
    };
    var GridLayout = (props) => {
      const {
        containerWidth,
        containerHeight,
        options: {
          width: canvasWidth = gridLayoutOptions.width
        } = gridLayoutOptions,
        onLayoutStructureChange,
        layoutStructure = defaultLayoutStructure2
      } = props;
      const { enableGridLayoutCssScaling } = (0, dashboard_context_exports.useFeatureFlags)();
      const scrollbarWidth = (0, dashboard_utils_exports.getScrollbarWidth)();
      const [canvasHeight, setCanvasHeight] = (0, react_exports.useState)(
        () => computeMaxHeight(layoutStructure)
      );
      const scale = (0, react_exports.useMemo)(
        () => computeScaleToFit({
          canvasWidth,
          canvasHeight,
          containerWidth,
          containerHeight,
          scrollbarWidth,
          enableGridLayoutCssScaling
        }),
        [
          enableGridLayoutCssScaling,
          canvasWidth,
          canvasHeight,
          containerWidth,
          containerHeight,
          scrollbarWidth
        ]
      );
      const handleLayoutStructureChange = (0, react_exports.useCallback)(
        (layout) => {
          onLayoutStructureChange(
            scaleGridLayoutStructureByWidth({
              layout,
              scale: 1 / scale
            })
          );
        },
        [scale, onLayoutStructureChange]
      );
      const scaledLayoutStructure = (0, react_exports.useMemo)(
        () => !enableGridLayoutCssScaling ? scaleGridLayoutStructureByWidth({
          layout: layoutStructure,
          scale
        }) : layoutStructure,
        [enableGridLayoutCssScaling, layoutStructure, scale]
      );
      const sortedLayoutStructure = (0, react_exports.useMemo)(
        () => getGridLayoutOrder({
          layout: scaledLayoutStructure,
          canvasWidth,
          canvasHeight: computeMaxHeight(scaledLayoutStructure)
        }),
        [canvasWidth, scaledLayoutStructure]
      );
      return react_default.createElement(
        BaseGridLayout,
        __spreadValues(__spreadProps(__spreadValues({}, props), {
          scale,
          canvasWidth,
          layoutStructure: sortedLayoutStructure,
          setCanvasHeight
        }), !enableGridLayoutCssScaling ? {
          canvasWidth: Math.round(containerWidth - scrollbarWidth),
          onLayoutStructureChange: handleLayoutStructureChange
        } : null)
      );
    };
    var GridLayout_default = withLayoutShowHide(GridLayout, {
      schema: gridLayoutOptionsSchema_default,
      reflowFn: gridLayoutShowHideReflow
    });
    var getTemplateItems = ([currGridLine, nextGridLine, ...rest], axisLength, templateItems = []) => {
      templateItems.push(`[${currGridLine.names.join(" ")}]`);
      if (!nextGridLine) {
        return templateItems.join(" ");
      }
      const gridTrackWidth = Math.round(
        (nextGridLine.pos - currGridLine.pos) / axisLength * 100
      );
      templateItems.push(`minmax(0, ${gridTrackWidth}fr)`);
      return getTemplateItems([nextGridLine, ...rest], axisLength, templateItems);
    };
    var getTemplateItemsFromGridLines = (gridLines, axisLength) => {
      if (gridLines.length === 0) {
        return "";
      }
      return getTemplateItems(gridLines, axisLength);
    };
    var getCSSGridTemplate = ({
      layoutStructure,
      width,
      height
    }) => {
      const xCoords = [];
      const yCoords = [];
      layoutStructure.forEach(({ position: { x, y, w, h }, item }) => {
        var _a, _b, _c, _d;
        xCoords[x] = (_a = xCoords[x]) != null ? _a : [];
        xCoords[x + w] = (_b = xCoords[x + w]) != null ? _b : [];
        yCoords[y] = (_c = yCoords[y]) != null ? _c : [];
        yCoords[y + h] = (_d = yCoords[y + h]) != null ? _d : [];
        xCoords[x].push(`${item}-start`);
        xCoords[x + w].push(`${item}-end`);
        yCoords[y].push(`${item}-start`);
        yCoords[y + h].push(`${item}-end`);
      });
      const xGridLines = Object.entries(xCoords).map(([pos, names]) => ({
        pos: Number(pos),
        names
      }));
      const yGridLines = Object.entries(yCoords).map(([pos, names]) => ({
        pos: Number(pos),
        names
      }));
      const gridRowTemplate = getTemplateItemsFromGridLines(yGridLines, height);
      const gridColTemplate = getTemplateItemsFromGridLines(xGridLines, width);
      return { gridRowTemplate, gridColTemplate };
    };
    var GridCanvas2 = styled_components_default.div`
    ${themes_exports.mixins.reset("grid")};
    height: ${(props) => props.height}px;
    width: 100%;
    padding: ${(props) => props.gutterSize / 2}px;
    box-sizing: border-box;
    grid-template-columns: ${(props) => props.colTemplate};
    grid-template-rows: ${(props) => props.rowTemplate};
    gap: ${(props) => props.gutterSize}px;
    background: ${dashboard_ui_exports.customThemeVariables.dashboardBackgroundColor};
`;
    GridCanvas2.displayName = "GridCanvas";
    var defaultLayoutStructure3 = [];
    var GridLayoutViewer = ({
      layoutStructure = defaultLayoutStructure3,
      renderLayoutItem = dashboard_utils_exports.noop,
      options = gridLayoutOptions
    }) => {
      const { width, gutterSize } = __spreadValues(__spreadValues({}, gridLayoutOptions), options);
      const { height, gridItems, rowTemplate, colTemplate } = (0, react_exports.useMemo)(() => {
        const filteredStructure = removeInvalidItems(
          layoutStructure
        );
        const structureHeight = computeMaxHeight(filteredStructure);
        const { gridRowTemplate, gridColTemplate } = getCSSGridTemplate({
          layoutStructure: filteredStructure,
          width,
          height: structureHeight
        });
        const items = filteredStructure.map(({ item: itemId, type }) => react_default.createElement(
          GridItem_default,
          {
            itemId,
            type,
            key: itemId,
            renderLayoutItem
          }
        ));
        return {
          height: structureHeight,
          gridItems: items,
          rowTemplate: gridRowTemplate,
          colTemplate: gridColTemplate
        };
      }, [layoutStructure, width, renderLayoutItem]);
      return react_default.createElement(
        GridCanvas2,
        {
          "data-test": "grid-layout-canvas",
          "data-layout-type": "grid",
          height,
          gutterSize,
          rowTemplate,
          colTemplate
        },
        gridItems
      );
    };
    var GridLayoutViewer_default = GridLayoutViewer;
    var core_exports = {};
    __export(core_exports, {
      default: () => core_default
    });
    var defaultImport16 = __toESM2((init_core_esm(), __toCommonJS(core_esm_exports)));
    __reExport(core_exports, (init_core_esm(), __toCommonJS(core_esm_exports)));
    var core_default = "default" in defaultImport16 ? defaultImport16.default : defaultImport16;
    var sortable_exports = {};
    __export(sortable_exports, {
      default: () => sortable_default
    });
    var defaultImport17 = __toESM2((init_sortable_esm(), __toCommonJS(sortable_esm_exports)));
    __reExport(sortable_exports, (init_sortable_esm(), __toCommonJS(sortable_esm_exports)));
    var sortable_default = "default" in defaultImport17 ? defaultImport17.default : defaultImport17;
    var utilities_exports = {};
    __export(utilities_exports, {
      default: () => utilities_default
    });
    var defaultImport18 = __toESM2((init_utilities_esm(), __toCommonJS(utilities_esm_exports)));
    __reExport(utilities_exports, (init_utilities_esm(), __toCommonJS(utilities_esm_exports)));
    var utilities_default = "default" in defaultImport18 ? defaultImport18.default : defaultImport18;
    var InputContainer = styled_components_default.div`
    ${themes_exports.mixins.reset("block")};
    padding: ${themes_exports.variables.spacingSmall} 0 0 0;
    background: ${(prop) => prop.backgroundColor || dashboard_ui_exports.customThemeVariables.dashboardBackgroundColor};
    display: flex;
    flex-wrap: wrap;

    &:empty {
        padding: 0;
    }
`;
    var defaultInputRender = () => null;
    var defaultStructure = [];
    var InputSubmitButton = ({
      disabled,
      onClick
    }) => {
      const { setNodeRef, transform } = (0, sortable_exports.useSortable)({
        id: dashboard_context_exports.GlobalInputSubmitDraggableId,
        disabled: true
      });
      const containerStyle = (0, react_exports.useMemo)(
        () => ({ transform: utilities_exports.CSS.Translate.toString(transform) }),
        [transform]
      );
      return react_default.createElement(
        dashboard_ui_exports.SubmitButton,
        {
          key: "submit_button",
          "data-test": "input-item-submit-button",
          ref: setNodeRef,
          containerStyle,
          disabled,
          onClick
        }
      );
    };
    var InputLayout = (0, react_exports.forwardRef)(
      ({
        submitButton = false,
        submitButtonDisabled = false,
        inputStructure = defaultStructure,
        renderInput = defaultInputRender,
        onSubmitButtonClick = dashboard_utils_exports.noop
      }, ref) => {
        const { setNodeRef } = (0, core_exports.useDroppable)({ id: dashboard_context_exports.GlobalInputDropzoneId });
        const composedRef = (0, react_exports.useCallback)(
          (element) => {
            if (ref) {
              if (typeof ref === "function") {
                ref(element);
              } else {
                ref.current = element;
              }
            }
            setNodeRef(element);
          },
          [ref, setNodeRef]
        );
        if (inputStructure.length === 0) {
          return null;
        }
        const renderSubmitButton = !!(inputStructure.length && submitButton);
        return react_default.createElement(
          InputContainer,
          {
            ref: composedRef,
            "data-test": "input-layout-container"
          },
          inputStructure.map(
            (inputId, index) => renderInput({ inputId, index })
          ),
          renderSubmitButton && react_default.createElement(
            InputSubmitButton,
            {
              disabled: submitButtonDisabled,
              onClick: onSubmitButtonClick
            }
          )
        );
      }
    );
    var InputLayoutViewer_default = InputLayout;
    var Line_exports = {};
    __export(Line_exports, {
      default: () => Line_default
    });
    var defaultImport19 = __toESM2(require_Line());
    __reExport(Line_exports, require_Line());
    var Line_default = "default" in defaultImport19 ? defaultImport19.default : defaultImport19;
    var Options_exports = {};
    __export(Options_exports, {
      default: () => Options_default
    });
    var defaultImport20 = __toESM2(require_Options());
    __reExport(Options_exports, require_Options());
    var Options_default = "default" in defaultImport20 ? defaultImport20.default : defaultImport20;
    var schemaUtils_exports = {};
    __export(schemaUtils_exports, {
      default: () => schemaUtils_default
    });
    var defaultImport21 = __toESM2(require_schemaUtils());
    __reExport(schemaUtils_exports, require_schemaUtils());
    var schemaUtils_default = "default" in defaultImport21 ? defaultImport21.default : defaultImport21;
    var ConnectedLineOptionsSchema_default = {
      toArrow: {
        type: "boolean",
        default: false,
        description: "Specify whether the line begins with an arrow."
      },
      fromArrow: {
        type: "boolean",
        default: false,
        description: "Specify whether the line ends in an arrow."
      },
      strokeColor: {
        anyOf: [
          {
            type: "string",
            pattern: schemaUtils_exports.COLOR_OR_TOKEN_PATTERN,
            description: 'Specify the color of the line. The default for light mode is "#000000". The default for dark mode is "#FFFFFF"'
          },
          {
            type: "string",
            pattern: "^>.*"
          }
        ]
      },
      strokeDataSeries: {
        type: "string",
        pattern: "^>.*",
        description: "Data series for dynamic line coloring.",
        default: '> primary | seriesByType("number")'
      },
      strokeDataPoint: {
        type: "string",
        pattern: "^>.*",
        description: "Data point that will map to the line color.",
        default: "> strokeDataSeries | lastPoint()"
      },
      strokeDasharray: {
        type: "number",
        default: 0,
        description: "Specify the length, in pixels, of both the line segments and the spaces between the line segments when you choose break up a line so that it is not solid."
      },
      strokeWidth: {
        type: "number",
        default: 1,
        description: "Specify the thickness, in pixels, of the line."
      },
      strokeOpacity: {
        type: "number",
        default: 1,
        description: "Specify a number less than one to increase the opacity of the line. For example, if you specify 0.50, the line will have an opacity that is half that of no opacity."
      }
    };
    var PresetPalettes_exports = {};
    __export(PresetPalettes_exports, {
      default: () => PresetPalettes_default
    });
    var defaultImport22 = __toESM2(require_PresetPalettes());
    __reExport(PresetPalettes_exports, require_PresetPalettes());
    var PresetPalettes_default = "default" in defaultImport22 ? defaultImport22.default : defaultImport22;
    var configUtils_exports = {};
    __export(configUtils_exports, {
      default: () => configUtils_default
    });
    var defaultImport23 = __toESM2(require_configUtils());
    __reExport(configUtils_exports, require_configUtils());
    var configUtils_default = "default" in defaultImport23 ? defaultImport23.default : defaultImport23;
    var defaultContext = {
      defaultRangeValue: [
        { to: 20, value: "#D41F1F" },
        { from: 20, to: 40, value: "#D94E17" },
        { from: 40, to: 60, value: "#CBA700" },
        { from: 60, to: 80, value: "#669922" },
        { from: 80, value: "#118832" }
      ]
    };
    var basePresetContext = {
      strokeColorEditorConfig: void 0
    };
    var basePresetOptions = {
      strokeColor: void 0
    };
    var presets = [
      {
        label: (0, i18n_exports._)("Static"),
        name: "lineColor.static",
        value: {
          context: __spreadValues({}, basePresetContext),
          options: __spreadValues({}, basePresetOptions)
        }
      },
      {
        label: (0, i18n_exports._)("Dynamic"),
        name: "lineColor.dynamic",
        value: {
          context: __spreadProps(__spreadValues({}, basePresetContext), {
            strokeColorEditorConfig: defaultContext.defaultRangeValue
          }),
          options: __spreadProps(__spreadValues({}, basePresetOptions), {
            strokeColor: "> strokeDataPoint | rangeValue(strokeColorEditorConfig)"
          })
        }
      }
    ];
    var StaticColorEditor = {
      label: (0, i18n_exports._)("Color value"),
      option: "strokeColor",
      editor: "editor.color",
      showEditor: ({ options }) => !(0, configUtils_exports.isDynamicOption)(options == null ? void 0 : options.strokeColor),
      editorProps: {
        labelPosition: "top",
        themeVariable: "@splunk/dashboard-layouts/ConnectedLine.strokeColor"
      }
    };
    var DynamicColorEditor = {
      label: (0, i18n_exports._)("Color range"),
      option: "strokeColor",
      context: "defaultContext",
      editor: "editor.dynamicColor",
      showEditor: ({ options }) => (0, configUtils_exports.isDynamicOption)(options == null ? void 0 : options.strokeColor),
      editorProps: {
        labelPosition: "top",
        flyoutTitle: (0, i18n_exports._)("Dynamic line color"),
        formatters: [
          {
            label: (0, i18n_exports._)("Ranges"),
            value: "rangeValue",
            isDefault: true,
            // show it by default when open dynamic color flyout
            defaults: {
              strokeDataPoint: defaultContext.defaultRangeValue
            }
          }
        ],
        dataSelectors: [
          {
            label: (0, i18n_exports._)("Color field"),
            value: "strokeDataPoint"
          }
        ],
        defaultPalettesConfig: PresetPalettes_exports.defaultPalettesConfig
      }
    };
    var editorConfig = [
      {
        label: (0, i18n_exports._)("Selected data field"),
        layout: [
          [
            {
              label: (0, i18n_exports._)("Data field"),
              editor: "editor.columnSelector",
              option: "strokeDataSeries",
              context: "strokeDataContext",
              editorProps: {
                dataSourceKey: "primary",
                prepareValue: (definition) => {
                  const {
                    options: { strokeDataSeries }
                  } = definition;
                  return {
                    context: {},
                    options: {
                      strokeDataPoint: `> strokeDataSeries | lastPoint()`,
                      strokeDataSeries
                    }
                  };
                }
              }
            }
          ]
        ]
      },
      {
        label: (0, i18n_exports._)("Color and style"),
        layout: [
          [
            {
              label: (0, i18n_exports._)("Mode"),
              key: "presetSelector",
              editor: "editor.presetSelector",
              editorProps: {
                presets,
                value: ({
                  context,
                  options
                }) => {
                  const initialPreset = (0, configUtils_exports.getInitialPreset)(
                    context,
                    options,
                    presets
                  );
                  return (initialPreset == null ? void 0 : initialPreset.label) || null;
                }
              }
            }
          ],
          [
            __spreadValues({}, StaticColorEditor)
          ],
          [
            __spreadValues({}, DynamicColorEditor)
          ],
          [
            {
              label: (0, i18n_exports._)("Stroke opacity"),
              option: "strokeOpacity",
              editor: "editor.percent"
            }
          ],
          [
            {
              label: (0, i18n_exports._)("Stroke thickness (px)"),
              option: "strokeWidth",
              editor: "editor.number",
              editorProps: {
                min: 1
              }
            }
          ],
          [
            {
              label: (0, i18n_exports._)("Stroke dash style"),
              option: "strokeDasharray",
              editor: "editor.number",
              editorProps: {
                min: 0
              }
            }
          ],
          [
            {
              label: (0, i18n_exports._)("Starting arrow point"),
              option: "fromArrow",
              editor: "editor.toggle",
              editorProps: {
                labelPosition: "right"
              }
            }
          ],
          [
            {
              label: (0, i18n_exports._)("Ending arrow point"),
              option: "toArrow",
              editor: "editor.toggle",
              editorProps: {
                labelPosition: "right"
              }
            }
          ]
        ]
      }
    ];
    var ConnectedLineEditorConfig_default = editorConfig;
    var computeArrowTriangle = (w, h, l, L) => {
      if (l === 0) {
        return { arrowW: 0, arrowH: 0, arrowL: 0 };
      }
      const arrowW = w * L / l;
      const arrowH = h * L / l;
      return { arrowW, arrowH, arrowL: L };
    };
    var computeFromArrowAngle = (from, to) => {
      if (to.x - from.x === 0) {
        return from.y > to.y ? 90 : 270;
      }
      const angle = Math.atan((to.y - from.y) / (to.x - from.x)) * (180 / Math.PI);
      return from.x > to.x ? angle : 180 + angle;
    };
    var computeToArrowAngle = (from, to) => {
      if (to.x - from.x === 0) {
        return from.y > to.y ? 270 : 90;
      }
      const angle = Math.atan((to.y - from.y) / (to.x - from.x)) * (180 / Math.PI);
      return from.x > to.x ? 180 + angle : angle;
    };
    var getNewFrom = (from, to, arrowW, arrowH, fromArrow) => {
      let newFromX;
      let newFromY;
      if (fromArrow) {
        newFromX = from.x > to.x ? from.x - arrowW : from.x + arrowW;
        newFromY = from.y > to.y ? from.y - arrowH : from.y + arrowH;
      } else {
        newFromX = from.x;
        newFromY = from.y;
      }
      return { newFrom: { x: newFromX, y: newFromY } };
    };
    var getNewTo = (from, to, arrowW, arrowH, toArrow) => {
      let newToX;
      let newToY;
      if (toArrow) {
        newToX = from.x > to.x ? to.x + arrowW : to.x - arrowW;
        newToY = from.y > to.y ? to.y + arrowH : to.y - arrowH;
      } else {
        newToX = to.x;
        newToY = to.y;
      }
      return { newTo: { x: newToX, y: newToY } };
    };
    var computePathTriangle = (from, to) => {
      const w = Math.abs(from.x - to.x);
      const h = Math.abs(from.y - to.y);
      const l = Math.sqrt(w * w + h * h);
      return { w, h, l };
    };
    var rootSvgStyle = {
      pointerEvents: "none",
      overflow: "visible"
    };
    var lineStyle = {
      pointerEvents: "auto"
    };
    var dataContract = {
      requiredDataSources: ["primary"],
      initialRequestParams: {}
    };
    var vizConfig = {
      optionsSchema: ConnectedLineOptionsSchema_default,
      editorConfig: ConnectedLineEditorConfig_default,
      dataContract,
      key: "abslayout.line",
      name: (0, i18n_exports._)("Connected Line"),
      category: dashboard_context_exports.vizCategories.get("shapes"),
      icon: Line_default,
      events: {},
      // no onEventTrigger called by connected line
      supports: ["dynamic-options"],
      // what capabilities are supported?
      requiredProps: []
    };
    var defaultOptions2 = {
      strokeOpacity: 1,
      strokeWidth: 1,
      strokeDasharray: 0,
      strokeDataSeries: '> primary | seriesByType("number")',
      strokeDataPoint: "> strokeDataSeries | lastPoint()",
      fromArrow: false,
      toArrow: false
    };
    var defaultFrom = {
      x: 0,
      y: 0
    };
    var defaultTo = {
      x: 150,
      y: 0
    };
    var empty = {};
    var ConnectedLine = ({
      from = defaultFrom,
      to = defaultTo,
      onLineSelect = dashboard_utils_exports.noop,
      options = defaultOptions2,
      dataSources = empty,
      context = empty
    }) => {
      const { backgroundColorFloating } = (0, themes_exports.useSplunkTheme)();
      const renderOptions = (0, react_exports.useMemo)(() => {
        try {
          return Options_exports.Options.evaluate(
            {
              context,
              options: __spreadValues(__spreadValues({}, defaultOptions2), options)
            },
            dataSources
          );
        } catch (e) {
          if (e instanceof Error) {
            dashboard_utils_exports.console.error(
              `Unexpected error evaluating line options: ${e.message}`
            );
          }
        }
        return defaultOptions2;
      }, [context, options, dataSources]);
      const { w, h, l } = computePathTriangle(from, to);
      const arrowL = 5 * renderOptions.strokeWidth;
      const { arrowW, arrowH } = computeArrowTriangle(w, h, l, arrowL);
      const squashedArrows = arrowL > l && renderOptions.fromArrow && renderOptions.toArrow;
      const fromArrowAngle = computeFromArrowAngle(from, to);
      const toArrowAngle = computeToArrowAngle(from, to);
      const fromArrowId = (0, dashboard_utils_exports.uniqueId)();
      const toArrowId = (0, dashboard_utils_exports.uniqueId)();
      const newW = w + arrowL;
      const newH = h + 2 * arrowL + 10;
      const { newFrom } = getNewFrom(
        from,
        to,
        arrowW,
        arrowH,
        renderOptions.fromArrow
      );
      const { newTo } = getNewTo(from, to, arrowW, arrowH, renderOptions.toArrow);
      return react_default.createElement("svg", { width: newW, height: newH, style: rootSvgStyle }, react_default.createElement(
        "path",
        {
          "data-test": "arrows",
          d: squashedArrows ? `M${newTo.x} ${newTo.y} L${newFrom.x} ${newFrom.y}` : `M${newFrom.x} ${newFrom.y} L${newTo.x} ${newTo.y}`,
          stroke: renderOptions.strokeColor || backgroundColorFloating,
          strokeOpacity: `${renderOptions.strokeOpacity}`,
          strokeWidth: `${renderOptions.strokeWidth}`,
          strokeDasharray: `${renderOptions.strokeDasharray}`,
          fill: "none",
          markerStart: renderOptions.fromArrow ? `url(#${fromArrowId})` : "",
          markerEnd: renderOptions.toArrow ? `url(#${toArrowId})` : ""
        }
      ), react_default.createElement(
        "path",
        {
          "data-test": "line",
          onMouseDown: onLineSelect,
          d: `M${from.x} ${from.y} L${to.x} ${to.y}`,
          strokeWidth: `${renderOptions.strokeWidth + 20}`,
          fill: "none",
          stroke: "white",
          strokeOpacity: 0,
          style: lineStyle
        }
      ), react_default.createElement("defs", null, react_default.createElement(
        "marker",
        {
          id: `${fromArrowId}`,
          markerWidth: "10",
          markerHeight: "10",
          refX: squashedArrows ? "5" : "0",
          refY: "2",
          orient: `${fromArrowAngle}deg`,
          markerUnits: "strokeWidth"
        },
        react_default.createElement(
          "path",
          {
            d: "M0,0 L0,4 L5,2 z",
            fill: renderOptions.strokeColor || backgroundColorFloating,
            fillOpacity: `${renderOptions.strokeOpacity}`
          }
        )
      ), react_default.createElement(
        "marker",
        {
          id: `${toArrowId}`,
          markerWidth: "10",
          markerHeight: "10",
          refX: squashedArrows ? "5" : "0",
          refY: "2",
          orient: `${toArrowAngle}deg`,
          markerUnits: "strokeWidth"
        },
        react_default.createElement(
          "path",
          {
            d: "M0,0 L0,4 L5,2 z",
            fill: renderOptions.strokeColor || backgroundColorFloating,
            fillOpacity: `${renderOptions.strokeOpacity}`
          }
        )
      )));
    };
    ConnectedLine.config = vizConfig;
    var ConnectedLine_default = ConnectedLine;
    var commonLayoutOptionsSchema_default = {
      showTitleAndDescription: {
        type: "boolean",
        default: true,
        description: "A Boolean value to determine whether to display the Canvas Title and Description or not."
      },
      submitButton: {
        type: "boolean",
        description: 'You can also specify the layout option "submitButton". When set to true, a user must click a Submit button in order for the change in input selection to take effect (e.g. rerun searches with new dropdown values). If set to false, or if not specified at all, the dashboard will immediately refresh when a user makes a change in input selection.',
        default: false
      },
      submitOnDashboardLoad: {
        type: "boolean",
        default: false,
        description: "A Boolean value to determine whether inputs should submit their default values (if they exist) on initial dashboard load in order to allow searches to run once before requiring submit button to be used. To be used when `submitButton` is set to true."
      }
    };
    var BaseLayoutApi = class {
      constructor(arg0) {
        this.layoutId = arg0.layoutId;
        this.telemetry = arg0.telemetry;
        this.getDefinition = arg0.getDefinition;
        this.userMessage = arg0.userMessage;
      }
      emitTelemetry(payload) {
        if (!this.telemetry) {
          return false;
        }
        this.telemetry.emit(__spreadValues({ source: "layoutApi" }, payload));
        return true;
      }
    };
    var { width: DEFAULT_WIDTH, height: DEFAULT_HEIGHT } = absoluteLayoutOptions;
    var copyStructureItem = ({
      item,
      toId,
      offsetMultiplier,
      initialStructure,
      updatedStructure
    }) => {
      if (!item) {
        return;
      }
      if ((0, dashboard_utils_exports.isBlockItem)(item)) {
        const clonedBlockItem = cloneBlockItem({
          id: toId,
          item,
          offsetMultiplier
        });
        updatedStructure.push(clonedBlockItem);
      } else if (item.type === "line") {
        const linePosition = computeLineAbsPosition({
          layoutStructure: initialStructure,
          position: item.position
        });
        const clonedLine = cloneLine({
          id: toId,
          item: {
            item: item.item,
            type: "line",
            position: linePosition
          },
          offsetMultiplier
        });
        updatedStructure.push(clonedLine);
      }
    };
    var _AbsoluteLayoutApi_instances;
    var options_get;
    var structure_get;
    var AbsoluteLayoutApi = class extends BaseLayoutApi {
      constructor() {
        super(...arguments);
        __privateAdd(this, _AbsoluteLayoutApi_instances);
        this.cloneLayoutItems = ({
          from,
          to,
          offsetMultiplier = 1,
          metadata
        }) => {
          if (!Array.isArray(from) || !Array.isArray(to) || from.length !== to.length) {
            throw new Error((0, i18n_exports._)("Cannot clone item(s), incorrect inputs"), {
              cause: { from, to }
            });
          }
          this.emitTelemetry({ pageAction: "cloneLayoutItems", metadata });
          const layoutStructure = __privateGet(this, _AbsoluteLayoutApi_instances, structure_get);
          const currentStructure = /* @__PURE__ */ new Map();
          layoutStructure.forEach((item) => {
            currentStructure.set(item.item, item);
          });
          const updatedStructure = [...layoutStructure];
          from.forEach((copyItemId, idx) => {
            copyStructureItem({
              item: currentStructure.get(copyItemId),
              toId: to[idx],
              offsetMultiplier,
              initialStructure: layoutStructure,
              updatedStructure
            });
          });
          return updatedStructure;
        };
      }
      /**
       * Get layout items in order
       * @method
       * @returns {String} ordered item ids
       * @public
       */
      getLayoutItemOrder() {
        const layoutStructure = __privateGet(this, _AbsoluteLayoutApi_instances, structure_get);
        return getAllBlockItems({ layoutStructure }).map(({ item }) => item);
      }
      /**
       * Adjust layout item order
       * @method
       * @param {Number} currentOrder
       * @param {Number} newOrder
       * @param {Object} [arg0.metadata] Optional telemetry metadata to be emitted as part of the **adjustLayoutItemOrder** page action event
       * @returns {AbsoluteLayoutStructure} updated layout structure
       * @public
       */
      adjustLayoutItemOrder(currentOrder, newOrder, metadata) {
        this.emitTelemetry({ pageAction: "adjustLayoutItemOrder", metadata });
        const layoutStructure = __privateGet(this, _AbsoluteLayoutApi_instances, structure_get);
        const blockItems = getAllBlockItems({ layoutStructure });
        const lineItems = getAllLineItems({ layoutStructure });
        const updatedBlockItems = moveLayoutItem(
          blockItems,
          currentOrder,
          Math.min(newOrder, blockItems.length)
        );
        return [...lineItems, ...updatedBlockItems];
      }
      /**
       * Get an array of all items owned by the layout
       * @returns {StructureItem[]} An unordered array of items in the structure
       * @public
       */
      getLayoutItems() {
        return [...__privateGet(this, _AbsoluteLayoutApi_instances, structure_get)];
      }
      /**
       * Generate a new layout structure with one one or more items added
       * @method addLayoutItems
       * @param {Object[]} arg0.items An array of items to be added to the structure
       * @param {Object} [arg0.metadata] Optional telemetry metadata to be emitted as part of the **addLayoutItems** page action event
       * @returns {AbsoluteLayoutStructure} A new layout structure
       * @public
       */
      addLayoutItems({ items, metadata }) {
        this.emitTelemetry({ pageAction: "addLayoutItems", metadata });
        const { width = DEFAULT_WIDTH, height = DEFAULT_HEIGHT } = __privateGet(this, _AbsoluteLayoutApi_instances, options_get);
        const structure = __privateGet(this, _AbsoluteLayoutApi_instances, structure_get);
        return items.reduce(
          (proposedStructure, item) => {
            var _a;
            const newStructureItem = (0, dashboard_utils_exports.computeNewAbsoluteStructureItem)(__spreadProps(__spreadValues({}, item), {
              config: item.config,
              type: (_a = item.type) != null ? _a : "block",
              canvasWidth: width,
              canvasHeight: height,
              layoutItems: proposedStructure
            }));
            proposedStructure.push(newStructureItem);
            return proposedStructure;
          },
          [...structure]
        );
      }
      /**
       * Generate a new layout structure with one or more items removed by their ID
       * @method removeLayoutItems
       * @param {Object[]} arg0.itemIds An array of item IDs to be removed from the structure
       * @param {Object} [arg0.metadata] Optional telemetry metadata to be emitted as part of the **removeLayoutItems** page action event
       * @returns {AbsoluteLayoutStructure} A new layout structure
       * @public
       */
      removeLayoutItems({
        itemIds = [],
        metadata
      }) {
        this.emitTelemetry({ pageAction: "removeLayoutItems", metadata });
        const updatedItems = [];
        const layoutStructure = __privateGet(this, _AbsoluteLayoutApi_instances, structure_get);
        layoutStructure.forEach((item) => {
          let iterItem = item;
          if (item.type === "line") {
            let updatedLine = item;
            const absPos = computeLineAbsPosition({
              layoutStructure,
              position: updatedLine.position
            });
            if ("item" in updatedLine.position.from && itemIds.indexOf(updatedLine.position.from.item) >= 0) {
              updatedLine = disconnectLine({
                line: updatedLine,
                dir: "from",
                absPos: absPos.from
              });
            }
            if ("item" in updatedLine.position.to && itemIds.indexOf(updatedLine.position.to.item) >= 0) {
              updatedLine = disconnectLine({
                line: updatedLine,
                dir: "to",
                absPos: absPos.to
              });
            }
            iterItem = updatedLine;
          }
          if (itemIds.indexOf(iterItem.item) < 0) {
            updatedItems.push(iterItem);
          }
        });
        return updatedItems;
      }
      /**
       * Return snapshot of the layout options which includes the inlined background image
       * @method snapshot
       * @returns {Object} Updated Layout options with encoded background image
       * @public
       */
      snapshot() {
        var _a, _b;
        const options = __privateGet(this, _AbsoluteLayoutApi_instances, options_get) === absoluteLayoutOptions ? {} : __privateGet(this, _AbsoluteLayoutApi_instances, options_get);
        if (!((_a = options.backgroundImage) == null ? void 0 : _a.src)) {
          const clonedOptions = __spreadValues({}, options);
          if (clonedOptions.backgroundImage) {
            clonedOptions.backgroundImage = __spreadValues({}, options.backgroundImage);
          }
          return clonedOptions;
        }
        return __spreadProps(__spreadValues({}, options), {
          backgroundImage: __spreadProps(__spreadValues({}, options.backgroundImage), {
            src: (_b = this.bgImageSrc) != null ? _b : options.backgroundImage.src
          })
        });
      }
    };
    _AbsoluteLayoutApi_instances = /* @__PURE__ */ new WeakSet();
    options_get = function() {
      var _a;
      return (_a = this.getDefinition().options) != null ? _a : absoluteLayoutOptions;
    };
    structure_get = function() {
      var _a;
      return (_a = this.getDefinition().structure) != null ? _a : [];
    };
    var { width: DEFAULT_WIDTH2 } = gridLayoutOptions;
    var removeGridItem = ({
      layoutStructure,
      id,
      width
    }) => {
      const itemToRemove = getBlockItem({ layoutStructure, id });
      const updatedItems = (0, dashboard_utils_exports.updateRemovedVizNeighbors)({
        itemToRemove,
        items: layoutStructure,
        width
      });
      const updatedItemIds = new Set(updatedItems.map(({ item }) => item));
      return [
        // anything in the structure which was updated to fill the hole in the grid
        ...updatedItems,
        // and anything which was left unchanged and is not the item being removed
        ...layoutStructure.filter(
          ({ item }) => item !== id && !updatedItemIds.has(item)
        )
      ];
    };
    var _GridLayoutApi_instances;
    var options_get2;
    var structure_get2;
    var GridLayoutApi = class extends BaseLayoutApi {
      constructor() {
        super(...arguments);
        __privateAdd(this, _GridLayoutApi_instances);
      }
      /**
       * Get an array of all items owned by the layout
       * @returns {StructureItem[]} An unordered array of items in the structure
       * @public
       */
      getLayoutItems() {
        return [...__privateGet(this, _GridLayoutApi_instances, structure_get2)];
      }
      /**
       * Generate a new layout structure with one one or more items added
       * @method addLayoutItems
       * @param {Object[]} arg0.items An array of items to be added to the structure
       * @param {Object} [arg0.metadata] Optional telemetry metadata to be emitted as part of the **addLayoutItems** page action event
       * @returns {GridLayoutStructure} A new layout structure
       * @public
       */
      addLayoutItems({ items, metadata }) {
        var _a;
        this.emitTelemetry({ pageAction: "addLayoutItems", metadata });
        const { width = DEFAULT_WIDTH2 } = (_a = __privateGet(this, _GridLayoutApi_instances, options_get2)) != null ? _a : gridLayoutOptions;
        const proposedLayoutStructure = items.reduce(
          (structure, { itemId, type }) => {
            const newStructureItem = (0, dashboard_utils_exports.computeNewGridStructureItem)({
              itemId,
              type: type != null ? type : "block",
              canvasWidth: width,
              layoutItems: structure
            });
            structure.push(newStructureItem);
            return structure;
          },
          [...__privateGet(this, _GridLayoutApi_instances, structure_get2)]
        );
        return proposedLayoutStructure;
      }
      /**
       * Generates a new layout structure with copies of item(s) specified in the `from` array, having new IDs specified in the `to` array.
       * @method cloneLayoutItems
       * @param {Array} arg0.from List of original item IDs
       * @param {Array} arg0.to List of new item IDs
       * @param {Object} [arg0.metadata] Optional telemetry metadata to be emitted as part of the **cloneLayoutItems** page action event
       * @returns {GridLayoutStructure} Layout structure of all known items
       * @public
       * @throws {Error} Will error if `from` or `to` is not an array, or `from.length` != `to.length`
       */
      cloneLayoutItems({ from, to, metadata }) {
        if (!Array.isArray(from) || !Array.isArray(to) || from.length !== to.length) {
          throw new Error((0, i18n_exports._)("Cannot clone item(s), incorrect inputs"), {
            cause: { from, to }
          });
        }
        this.emitTelemetry({ pageAction: "cloneLayoutItems", metadata });
        return from.reduce(
          (layoutStructure, fromId, idx) => {
            const ancestor = getBlockItem({ layoutStructure, id: fromId });
            if (ancestor.position.w < MIN_WIDTH_PX * 2) {
              this.userMessage({
                message: CLONE_LAYOUT_ITEMS_MSG_PANEL_TOO_SMALL,
                level: "warning",
                sender: "GridLayoutApi"
              });
              return layoutStructure;
            }
            const offsetLS = -1 * Math.floor(ancestor.position.w / 2);
            const lsDescendant = updateBlockItemSize({
              item: __spreadValues({}, ancestor),
              offset: { offsetX: offsetLS, offsetY: 0 },
              dir: "e"
            });
            const offsetRS = Math.ceil(ancestor.position.w / 2);
            const rsDescendant = updateBlockItemSize({
              item: __spreadProps(__spreadValues({}, ancestor), { item: to[idx] }),
              offset: { offsetX: offsetRS, offsetY: 0 },
              dir: "w"
            });
            return [
              ...layoutStructure.filter(({ item }) => item !== fromId),
              lsDescendant,
              rsDescendant
            ];
          },
          [...__privateGet(this, _GridLayoutApi_instances, structure_get2)]
        );
      }
      /**
       * Generate a new layout structure with one or more items removed by their ID. The space occupied by the removed item(s) will be reallocated to the closest neighboring panel.
       *
       * **Note:** Changing the order of the values of `itemIds` can change the generated structure. Items are removed sequentially with the dimensions of neighbors of the item being updated between each removal.
       * @method removeLayoutItems
       * @param {Object[]} arg0.itemIds An array of item IDs to be removed from the structure
       * @param {Object} [arg0.metadata] Optional telemetry metadata to be emitted as part of the **removeLayoutItems** page action event
       * @returns {GridLayoutStructure} A new layout structure
       * @public
       */
      removeLayoutItems({ itemIds, metadata }) {
        this.emitTelemetry({ pageAction: "removeLayoutItems", metadata });
        const { width = DEFAULT_WIDTH2 } = __privateGet(this, _GridLayoutApi_instances, options_get2);
        return itemIds.reduce(
          (layoutStructure, id) => {
            try {
              return removeGridItem({ width, layoutStructure, id });
            } catch (e) {
              return layoutStructure;
            }
          },
          [...__privateGet(this, _GridLayoutApi_instances, structure_get2)]
        );
      }
      /**
       * Return snapshot as a clone of the layout options
       * @method snapshot
       * @returns {Object} Cloned layout options
       * @public
       */
      snapshot() {
        return __privateGet(this, _GridLayoutApi_instances, options_get2) === gridLayoutOptions ? {} : __spreadValues({}, __privateGet(this, _GridLayoutApi_instances, options_get2));
      }
    };
    _GridLayoutApi_instances = /* @__PURE__ */ new WeakSet();
    options_get2 = function() {
      var _a;
      return (_a = this.getDefinition().options) != null ? _a : gridLayoutOptions;
    };
    structure_get2 = function() {
      var _a;
      return (_a = this.getDefinition().structure) != null ? _a : [];
    };
  }
});

export {
  require_Plus,
  require_dashboard_layouts
};
//# sourceMappingURL=chunk-FNRCM6U5.js.map
