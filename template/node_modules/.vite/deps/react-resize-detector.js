import __buffer_polyfill from 'vite-plugin-node-polyfills/shims/buffer'
globalThis.Buffer = globalThis.Buffer || __buffer_polyfill
import __global_polyfill from 'vite-plugin-node-polyfills/shims/global'
globalThis.global = globalThis.global || __global_polyfill
import __process_polyfill from 'vite-plugin-node-polyfills/shims/process'
globalThis.process = globalThis.process || __process_polyfill

import {
  require_debounce,
  require_throttle
} from "./chunk-27LK67HU.js";
import "./chunk-CTKMSYPV.js";
import "./chunk-QUVU6COR.js";
import "./chunk-UTZ7MW2J.js";
import "./chunk-YCW3LPUS.js";
import "./chunk-ONA6R2CQ.js";
import {
  require_react
} from "./chunk-ACNULIE3.js";
import {
  __toESM,
  require_dist,
  require_dist2,
  require_dist3
} from "./chunk-2RF6DQJU.js";

// node_modules/react-resize-detector/build/index.esm.js
var import_dist = __toESM(require_dist());
var import_dist2 = __toESM(require_dist2());
var import_dist3 = __toESM(require_dist3());
var React = __toESM(require_react());
var import_react = __toESM(require_react());
var import_debounce = __toESM(require_debounce());
var import_throttle = __toESM(require_throttle());
var patchResizeCallback = (resizeCallback, refreshMode, refreshRate, refreshOptions) => {
  switch (refreshMode) {
    case "debounce":
      return (0, import_debounce.default)(resizeCallback, refreshRate, refreshOptions);
    case "throttle":
      return (0, import_throttle.default)(resizeCallback, refreshRate, refreshOptions);
    default:
      return resizeCallback;
  }
};
var useCallbackRef = (
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  (callback) => {
    const callbackRef = React.useRef(callback);
    React.useEffect(() => {
      callbackRef.current = callback;
    });
    return React.useMemo(() => ((...args) => {
      var _a;
      return (_a = callbackRef.current) === null || _a === void 0 ? void 0 : _a.call(callbackRef, ...args);
    }), []);
  }
);
var useRefProxy = (
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  (targetRef) => {
    const [refElement, setRefElement] = React.useState((targetRef === null || targetRef === void 0 ? void 0 : targetRef.current) || null);
    if (targetRef) {
      setTimeout(() => {
        if (targetRef.current !== refElement) {
          setRefElement(targetRef.current);
        }
      }, 0);
    }
    const refProxy = React.useMemo(() => new Proxy((node) => {
      if (node !== refElement) {
        setRefElement(node);
      }
    }, {
      get(target, prop) {
        if (prop === "current") {
          return refElement;
        }
        return target[prop];
      },
      set(target, prop, value) {
        if (prop === "current") {
          setRefElement(value);
        } else {
          target[prop] = value;
        }
        return true;
      }
    }), [refElement]);
    return { refProxy, refElement, setRefElement };
  }
);
var getDimensions = (entry, box) => {
  if (box === "border-box") {
    return {
      width: entry.borderBoxSize[0].inlineSize,
      height: entry.borderBoxSize[0].blockSize
    };
  }
  if (box === "content-box") {
    return {
      width: entry.contentBoxSize[0].inlineSize,
      height: entry.contentBoxSize[0].blockSize
    };
  }
  return {
    width: entry.contentRect.width,
    height: entry.contentRect.height
  };
};
function useResizeDetector({ skipOnMount = false, refreshMode, refreshRate = 1e3, refreshOptions, handleWidth = true, handleHeight = true, targetRef, observerOptions, onResize } = {}) {
  const skipResize = (0, import_react.useRef)(skipOnMount);
  const onResizeRef = useCallbackRef(onResize);
  const [size, setSize] = (0, import_react.useState)({
    width: void 0,
    height: void 0
  });
  const { refProxy, refElement } = useRefProxy(targetRef);
  const { box } = observerOptions || {};
  const resizeCallback = (0, import_react.useCallback)((entries) => {
    if (!handleWidth && !handleHeight)
      return;
    if (skipResize.current) {
      skipResize.current = false;
      return;
    }
    const shouldSetSize = (prevSize, nextSize) => handleWidth && prevSize.width !== nextSize.width || handleHeight && prevSize.height !== nextSize.height;
    entries.forEach((entry) => {
      const dimensions = getDimensions(entry, box);
      setSize((prevSize) => {
        if (!shouldSetSize(prevSize, dimensions))
          return prevSize;
        onResizeRef === null || onResizeRef === void 0 ? void 0 : onResizeRef({
          width: dimensions.width,
          height: dimensions.height,
          entry
        });
        return dimensions;
      });
    });
  }, [handleWidth, handleHeight, skipResize, box]);
  const resizeHandler = (0, import_react.useCallback)(patchResizeCallback(resizeCallback, refreshMode, refreshRate, refreshOptions), [
    resizeCallback,
    refreshMode,
    refreshRate,
    refreshOptions
  ]);
  (0, import_react.useEffect)(() => {
    let resizeObserver;
    if (refElement) {
      resizeObserver = new window.ResizeObserver(resizeHandler);
      resizeObserver.observe(refElement, observerOptions);
    } else if (size.width || size.height) {
      onResizeRef === null || onResizeRef === void 0 ? void 0 : onResizeRef({
        width: null,
        height: null,
        entry: null
      });
      setSize({ width: void 0, height: void 0 });
    }
    return () => {
      var _a, _b, _c;
      (_a = resizeObserver === null || resizeObserver === void 0 ? void 0 : resizeObserver.disconnect) === null || _a === void 0 ? void 0 : _a.call(resizeObserver);
      (_c = (_b = resizeHandler).cancel) === null || _c === void 0 ? void 0 : _c.call(_b);
    };
  }, [resizeHandler, refElement]);
  return Object.assign({ ref: refProxy }, size);
}
export {
  useResizeDetector
};
//# sourceMappingURL=react-resize-detector.js.map
