import __buffer_polyfill from 'vite-plugin-node-polyfills/shims/buffer'
globalThis.Buffer = globalThis.Buffer || __buffer_polyfill
import __global_polyfill from 'vite-plugin-node-polyfills/shims/global'
globalThis.global = globalThis.global || __global_polyfill
import __process_polyfill from 'vite-plugin-node-polyfills/shims/process'
globalThis.process = globalThis.process || __process_polyfill

import {
  require_datasource_utils
} from "./chunk-DMMSRVDK.js";
import {
  require_dashboard_utils
} from "./chunk-XH2XD4WE.js";
import {
  require_i18n
} from "./chunk-SFZFMFKO.js";
import {
  require_lodash
} from "./chunk-FUC7W543.js";
import {
  __commonJS,
  __toESM,
  require_dist,
  require_dist2,
  require_dist3
} from "./chunk-2RF6DQJU.js";

// node_modules/@splunk/datasources/TestDataSource.js
var require_TestDataSource = __commonJS({
  "node_modules/@splunk/datasources/TestDataSource.js"(exports, module) {
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    var __create = Object.create;
    var __defProp = Object.defineProperty;
    var __defProps = Object.defineProperties;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __getOwnPropSymbols = Object.getOwnPropertySymbols;
    var __getProtoOf = Object.getPrototypeOf;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __propIsEnum = Object.prototype.propertyIsEnumerable;
    var __pow = Math.pow;
    var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
    var __spreadValues = (a, b) => {
      for (var prop in b || (b = {}))
        if (__hasOwnProp.call(b, prop))
          __defNormalProp(a, prop, b[prop]);
      if (__getOwnPropSymbols)
        for (var prop of __getOwnPropSymbols(b)) {
          if (__propIsEnum.call(b, prop))
            __defNormalProp(a, prop, b[prop]);
        }
      return a;
    };
    var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
    var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
      // If the importer is in node compatibility mode or this is not an ESM
      // file that has been converted to a CommonJS file using a Babel-
      // compatible transform (i.e. "__esModule" has not been set), then set
      // "default" to the CommonJS "module.exports" for node compatibility.
      isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
      mod
    ));
    var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var __async = (__this, __arguments, generator) => {
      return new Promise((resolve, reject) => {
        var fulfilled = (value) => {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        };
        var rejected = (value) => {
          try {
            step(generator.throw(value));
          } catch (e) {
            reject(e);
          }
        };
        var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
        step((generator = generator.apply(__this, __arguments)).next());
      });
    };
    var TestDataSource_exports = {};
    __export(TestDataSource_exports, {
      default: () => TestDataSource
    });
    module.exports = __toCommonJS(TestDataSource_exports);
    var datasource_utils_exports = {};
    __export(datasource_utils_exports, {
      default: () => datasource_utils_default
    });
    var defaultImport = __toESM2(require_datasource_utils());
    __reExport(datasource_utils_exports, require_datasource_utils());
    var datasource_utils_default = "default" in defaultImport ? defaultImport.default : defaultImport;
    var lodash_exports = {};
    __export(lodash_exports, {
      default: () => lodash_default
    });
    var defaultImport2 = __toESM2(require_lodash());
    __reExport(lodash_exports, require_lodash());
    var lodash_default = "default" in defaultImport2 ? defaultImport2.default : defaultImport2;
    var DataSource = class {
      /**
       * Create a new DataSource instance
       * @param {Object} options DataSource options such as search string, earliest/latest time
       * @param {Object} context contextual information such as api key or scope
       * @param {Object} meta metadata of this datasource
       * @param {Object} baseChainModel base chain definition
       */
      constructor(options = {}, context = {}, meta = {}, baseChainModel = {}) {
        this.options = options;
        this.context = context;
        this.meta = meta;
        this.baseChainModel = baseChainModel;
      }
      /**
       * Setup the DataSource, create a connection or search job.
       * setup() will be called only once per DataSource.
       * Returns null by default; override to implement custom setup logic.
       *
       * @return {Promise}
       * @public
       */
      setup() {
        return Promise.resolve(null);
      }
      /**
       * Request a Data Stream represent by an Observable.
       * Once the Observable was created and returned,
       * it's the DataSource itself responsible for 'pushing' the data out via Observable.next() function.
       * Override this function to implement your own data fetching logic.
       *
       * @param {Object} [requestParams] RequestParams
       * @param {Number} [requestParams.offset] result offset
       * @param {Number} [requestParams.count] result count, use with offset to return data in pages
       * @param {Object} [requestParams.sort] result sorting, key indicate the sorting fields and value must be one of ['none', 'asc', 'desc']
       * @param {Boolean} [requestParams.requireTotalCount] true if TotalCount is required in meta
       * @param {Boolean} [requestParams.progress] true to emit progress data, false to only return data when search is finalized
       * @return {Observable}
       * @public
       */
      request(requestParams) {
        return (observer) => {
          if (observer) {
            observer.complete();
          }
          return () => {
          };
        };
      }
      /**
       * Halt updates to results, if supported
       * @return {Promise}
       * @public
       */
      pause() {
        return __async(this, null, function* () {
          return Promise.resolve(null);
        });
      }
      /**
       * Resume previously-halted updates to results, if supported
       * @return {Promise}
       * @public
       */
      resume() {
        return __async(this, null, function* () {
          return Promise.resolve(null);
        });
      }
      /**
       * Reports whether pause and resume controls are supported for the class instance
       * @return {Boolean} true if the DataSource supports pause and resume actions
       * @public
       */
      supportsControlActions() {
        return false;
      }
      /**
       * Teardown the DataSource, clean up the connection or other resources.
       * Returns null by default; override to implement custom teardown logic.
       *
       * @return {Promise}
       * @public
       */
      teardown() {
        return Promise.resolve(null);
      }
      /**
       * @param {DataSource} another another DataSource to compare with
       * @return {Boolean} true if the these two DataSources are considered equal.
       * @public
       */
      equals(another) {
        return this.constructor === another.constructor && (0, lodash_exports.isEqual)(this.options, another.options);
      }
      /**
       * Return an observer that can be used for chaining with other DataSources
       *
       * @return {Object}
       * @public
       */
      getObserver() {
        return {
          next({ requestParams, data, meta }) {
          },
          error({ level, message }) {
          },
          complete() {
          }
        };
      }
      /**
       * Flag used to indicate whether the subscription for this DataSource should be refreshed
       *
       * @return {Boolean}
       * @public
       */
      shouldRefreshSubscription() {
        return false;
      }
    };
    var i18n_exports = {};
    __export(i18n_exports, {
      default: () => i18n_default
    });
    var defaultImport3 = __toESM2(require_i18n());
    __reExport(i18n_exports, require_i18n());
    var i18n_default = "default" in defaultImport3 ? defaultImport3.default : defaultImport3;
    var TestDataSourceOptionsSchema_default = {
      data: {
        type: "object",
        nullable: true,
        additionalProperties: false,
        properties: {
          fields: {
            type: "array",
            nullable: true,
            description: (0, i18n_exports._)(
              "The fields which should be returned in the data."
            ),
            items: {
              oneOf: [
                { type: "string" },
                {
                  type: "object",
                  properties: {
                    name: {
                      type: "string",
                      description: (0, i18n_exports._)("The name of the field.")
                    }
                  },
                  required: ["name"],
                  additionalProperties: true
                }
              ]
            }
          },
          columns: {
            type: "array",
            nullable: true,
            description: (0, i18n_exports._)(
              "The values for each field in the row. The order of the values must match the order of the fields."
            ),
            items: {
              type: "array",
              nullable: false
            }
          }
        },
        description: (0, i18n_exports._)("The data to return from the test data source.")
      },
      meta: {
        type: "object",
        nullable: true,
        additionalProperties: true,
        properties: {
          percentComplete: {
            type: "number",
            description: (0, i18n_exports._)("The percent complete of the search.")
          },
          statusMessage: {
            type: "string",
            description: (0, i18n_exports._)(
              "A message describing the status of the search."
            )
          },
          sid: {
            type: "string",
            description: (0, i18n_exports._)("The search ID for the search.")
          },
          status: {
            type: "string",
            enum: ["pending", "running", "completed", "failed"],
            description: (0, i18n_exports._)("The status of the search.")
          }
        },
        description: (0, i18n_exports._)("Metadata about the search")
      },
      errorLevel: {
        type: "string",
        enum: ["info", "warning", "error"],
        description: (0, i18n_exports._)("The level of the error."),
        nullable: true
      },
      error: {
        type: "string",
        description: (0, i18n_exports._)(
          "An error message if there was an error with the search."
        ),
        nullable: true
      },
      timeToStart: {
        type: "number",
        nullable: true,
        description: (0, i18n_exports._)(
          "The time in milliseconds it takes for the search to start."
        )
      },
      timeToComplete: {
        type: "number",
        nullable: true,
        description: (0, i18n_exports._)(
          "The time in milliseconds it takes for the search to complete."
        )
      },
      increments: {
        type: "number",
        nullable: true,
        description: (0, i18n_exports._)(
          "The number of batches of results to return between start and end of the search execution."
        )
      },
      random: {
        type: "object",
        nullable: true,
        additionalProperties: false,
        description: (0, i18n_exports._)(
          "An object containing options for generating random data."
        ),
        properties: {
          min: {
            type: "number",
            description: (0, i18n_exports._)(
              "The inclusive minimum value which can be returned."
            )
          },
          max: {
            type: "number",
            description: (0, i18n_exports._)(
              "The inclusive maximum value which can be returned."
            )
          },
          precision: {
            type: "number",
            description: (0, i18n_exports._)("The number of decimal places to use.")
          },
          fields: {
            type: "array",
            nullable: false,
            items: {
              type: "string"
            },
            description: (0, i18n_exports._)("The fields which should have random values.")
          },
          count: {
            type: "number",
            description: (0, i18n_exports._)(
              "The number of rows to generate. This is only used if there is no static field data defined."
            )
          }
        }
      }
    };
    var dashboard_utils_exports = {};
    __export(dashboard_utils_exports, {
      default: () => dashboard_utils_default
    });
    var defaultImport4 = __toESM2(require_dashboard_utils());
    __reExport(dashboard_utils_exports, require_dashboard_utils());
    var dashboard_utils_default = "default" in defaultImport4 ? defaultImport4.default : defaultImport4;
    var SimpleScheduler = class _SimpleScheduler {
      static createScheduler(tickFunc, options) {
        return new _SimpleScheduler(tickFunc, options);
      }
      /**
       *
       * @param {*} tickFunc a function that will be executed by scheduler, its return value will be used to schedule next execution.
       * return false from this function will stop the execution
       * @param {*} options
       */
      constructor(tickFunc = dashboard_utils_exports.noop, options = {}) {
        var _a;
        this.tickFunc = tickFunc;
        this.minDelay = (_a = options.minDelay) != null ? _a : 0;
        this.loop = this.loop.bind(this);
        this.t = null;
        this.stopped = false;
      }
      /**
       * execute tick function and stop next execution if error caught
       */
      tick() {
        return __async(this, null, function* () {
          try {
            return yield this.tickFunc(this);
          } catch (e) {
            return false;
          }
        });
      }
      /**
       * start scheduler
       */
      start() {
        return __async(this, null, function* () {
          this.stopped = false;
          yield this.loop();
        });
      }
      loop() {
        return __async(this, null, function* () {
          const delay = yield this.tick();
          if (!this.stopped && delay !== false && (0, lodash_exports.isNumber)(delay)) {
            this.t = setTimeout(this.loop, Math.max(this.minDelay, delay));
          }
        });
      }
      /**
       * stop scheduler
       */
      stop() {
        this.stopped = true;
        if (this.t) {
          clearTimeout(this.t);
          this.t = null;
        }
      }
    };
    var SimpleScheduler_default = SimpleScheduler;
    var Uint32Max = __pow(2, 32);
    var getRandomValue = () => {
      if (typeof globalThis.crypto !== "undefined") {
        const buffer = new Uint32Array(1);
        crypto.getRandomValues(buffer);
        return buffer[0];
      }
      return 0;
    };
    var Random = class {
      constructor({
        min = 0,
        max = min + 10,
        precision = 0
      } = {}) {
        this.digits = Math.min(20, Math.max(0, precision));
        this.precision = __pow(10, this.digits);
        if (min > max) {
          this.min = max;
          this.range = (min - max + 1) * this.precision;
        } else {
          this.min = min;
          this.range = (max - min + 1) * this.precision;
        }
      }
      /**
       * Get a single random number between the configured min and max (inclusive)
       * with a specified decimal precision
       * @returns {number} a random number
       */
      nextValue() {
        const randValue = getRandomValue();
        const wholeNumber = Math.floor(randValue / Uint32Max * this.range);
        const roundedWholeNumber = Math.round(wholeNumber + Number.EPSILON);
        const result = roundedWholeNumber / this.precision + this.min;
        return Number(result.toFixed(this.digits));
      }
      /**
       * Get an array of random numbers between the configured min and max
       * (inclusive) with a specified decimal precision
       * @param {number} length the number of values to return. This must be >= 1.
       * @returns {number} an array of size `length` of random numbers
       */
      nextValues(length) {
        if (length < 1) {
          throw RangeError("Count of values to get cannot be less than 1");
        }
        return Array.from({ length }, () => this.nextValue());
      }
    };
    var TestDataSource = class extends DataSource {
      /**
       * Test Datasource
       * @param {Object} options.data static data set
       * @param {Number} [options.delay=0] time before first results return (deprecated)
       * @param {Object} [options.meta] Return meta, merged with search progress
       * @param {*} [options.errorLevel] Passthrough data for errors
       * @param {String} [options.error] Passthrough error message - Set to create an erroring datasource
       * @param {Number} [options.timeToStart=0] time before first results return (same as delay)
       * @param {Number} [options.timeToComplete=0] time before all results return (same as delay)
       * @param {Number} [options.timeToStart=0] time before results return (same as delay)
       * @param {Number} [options.increments=10] Number of times to return partial results after initial delay
       * @param {Object} context
       */
      constructor(options = {}, context = {}) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        super(options, context);
        this.isIgnorableRiskyCommand = () => {
          var _a2;
          return (
            // Ignorable risky command needs to actually be a risky command
            ((_a2 = this.error) == null ? void 0 : _a2.startsWith("Found potentially risky commands:")) && // and it needs to have checkRiskyCommand = false
            !this.checkRiskyCommand
          );
        };
        this.data = this.processData({
          data: options.data,
          random: options.random
        });
        this.meta = __spreadValues({}, (_a = options.meta) != null ? _a : {});
        if (typeof this.meta.sid === "undefined") {
          const contextId = typeof context.id === "string" && context.id ? context.id : "TestDataSource";
          this.meta.sid = `${contextId}_sid`;
        }
        this.timeToStart = (_c = (_b = options.delay) != null ? _b : options.timeToStart) != null ? _c : 0;
        this.errorLevel = options.errorLevel;
        this.error = options.error;
        const timeToComplete = (_d = options.timeToComplete) != null ? _d : 0;
        const increments = Math.max((_e = options.increments) != null ? _e : 10, 1);
        this.timePerUpdate = timeToComplete / increments;
        this.incrementSize = Math.ceil(100 / increments);
        this.progress = (_g = (_f = options.meta) == null ? void 0 : _f.percentComplete) != null ? _g : timeToComplete ? 0 : 100;
        this.status = datasource_utils_exports.DS_STATUS.QUEUED;
        this.checkRiskyCommand = (_h = options.checkRiskyCommand) != null ? _h : true;
      }
      // eslint-disable-next-line class-methods-use-this
      processData({
        data,
        random: { min, max, precision, fields, count = 10 } = { fields: [] }
      }) {
        const staticData = data != null ? data : { fields: [], columns: [] };
        const randomFields = fields != null ? fields : [];
        const random = new Random({ min, max, precision });
        randomFields.forEach((field) => {
          var _a, _b;
          const fieldIdx = staticData.fields.findIndex(
            ({ name }) => name === field
          );
          if (fieldIdx < 0) {
            staticData.fields.push({ name: field });
            staticData.columns.push(random.nextValues(Math.max(0, count)));
          } else {
            const staticCount = (_b = (_a = staticData.columns[fieldIdx]) == null ? void 0 : _a.length) != null ? _b : 0;
            const requestedCount = Math.max(0, count);
            const neededCount = requestedCount - staticCount;
            if (neededCount > 0) {
              staticData.columns[fieldIdx].push(
                ...random.nextValues(neededCount)
              );
            }
          }
        });
        return staticData;
      }
      /**
       * Create a DataSet
       * @param {Object} [config]
       * @param {Array} [config.fields=[]] List of field names
       * @param {Array[]} [config.columns=[]] List of column data
       * @return {DataSet}
       */
      // eslint-disable-next-line class-methods-use-this
      toDataSet({ fields = [], columns = [] }) {
        console.log(fields, columns);
        return datasource_utils_exports.DataSet.fromJSONCols(fields, columns);
      }
      /**
       * Calculate the partial results for a dataset
       * @returns {DataSet}
       */
      getData(requestParams) {
        if (this.progress >= 100) {
          return this.toDataSet(this.data).getPage({
            count: requestParams == null ? void 0 : requestParams.count,
            offset: requestParams == null ? void 0 : requestParams.offset
          });
        }
        const data = { fields: this.data.fields, columns: [] };
        const size = Math.floor(
          this.data.columns[0].length * (this.progress / 100)
        );
        this.data.columns.forEach((column) => {
          if (!size) {
            data.columns.push([]);
          } else {
            data.columns.push(column.slice(0, size));
          }
        });
        return this.toDataSet(data);
      }
      /**
       * Calculate the content of meta
       * @return {Object}
       */
      getMeta() {
        var _a, _b, _c, _d;
        const meta = __spreadProps(__spreadValues({}, this.meta), { status: this.status });
        if (this.status === datasource_utils_exports.DS_STATUS.FAILED) {
          return meta;
        }
        meta.percentComplete = this.progress;
        meta.totalCount = (_d = meta.totalCount) != null ? _d : Math.floor(
          ((_c = (_b = (_a = this.data.columns) == null ? void 0 : _a[0]) == null ? void 0 : _b.length) != null ? _c : 0) * (this.progress / 100)
        );
        if (this.status !== datasource_utils_exports.DS_STATUS.QUEUED) {
          meta.lastUpdated = (/* @__PURE__ */ new Date()).toISOString();
        }
        return meta;
      }
      progressUpdateFactory({
        observer,
        requestParams
      }) {
        return (resultScheduler) => __async(this, null, function* () {
          if (this.progress >= 100) {
            this.status = datasource_utils_exports.DS_STATUS.DONE;
          }
          observer.next({
            data: this.getData(requestParams),
            meta: this.getMeta()
          });
          if (this.progress >= 100) {
            observer.complete();
            resultScheduler == null ? void 0 : resultScheduler.stop();
          }
          this.progress = Math.min(this.progress + this.incrementSize, 100);
          return this.timePerUpdate;
        });
      }
      scheduleRequest(observer, requestParams) {
        let resultScheduler = null;
        const timer = setTimeout(() => {
          this.status = datasource_utils_exports.DS_STATUS.RUNNING;
          if (this.meta.isRealTimeSearch) {
            observer.next({
              meta: {
                isRealTimeSearch: true,
                status: datasource_utils_exports.DS_STATUS.RUNNING
              }
            });
          } else if (typeof this.meta.percentComplete !== "undefined" && this.meta.freezeProgress) {
            observer.next({
              meta: {
                percentComplete: this.meta.percentComplete,
                totalCount: this.meta.totalCount || 0,
                status: datasource_utils_exports.DS_STATUS.RUNNING
              }
            });
          } else {
            resultScheduler = SimpleScheduler_default.createScheduler(
              this.progressUpdateFactory({
                observer,
                requestParams
              })
            );
            resultScheduler.start();
          }
        }, this.timeToStart);
        return { timer, resultScheduler };
      }
      /**
       * Creates loop to request and return results
       * @return {Function} Given an observable, schedule data updates over time
       */
      request(requestParams) {
        return (observer) => {
          if (!observer) {
            return () => void 0;
          }
          if (this.error && !this.isIgnorableRiskyCommand()) {
            this.status = datasource_utils_exports.DS_STATUS.FAILED;
            observer.error({
              level: this.errorLevel,
              message: this.error,
              meta: this.getMeta()
            });
            return () => void 0;
          }
          const { timer, resultScheduler } = this.scheduleRequest(observer, __spreadValues({}, requestParams));
          return () => {
            clearTimeout(timer);
            if (this.status === datasource_utils_exports.DS_STATUS.RUNNING) {
              this.status = datasource_utils_exports.DS_STATUS.CANCELED;
            }
            if (resultScheduler) {
              resultScheduler.stop();
            }
          };
        };
      }
    };
    TestDataSource.schema = TestDataSourceOptionsSchema_default;
    TestDataSource.config = {
      optionsSchema: TestDataSourceOptionsSchema_default
    };
  }
});

export {
  require_TestDataSource
};
//# sourceMappingURL=chunk-MGSCIXFA.js.map
