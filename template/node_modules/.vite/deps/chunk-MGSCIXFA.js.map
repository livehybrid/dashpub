{
  "version": 3,
  "sources": ["../../@splunk/datasources/src/TestDataSource.ts", "../../@splunk/datasources/@splunk/datasource-utils", "../../@splunk/datasources/lodash", "../../@splunk/datasources/src/DataSource.ts", "../../@splunk/datasources/@splunk/ui-utils/i18n", "../../@splunk/datasources/src/TestDataSourceOptionsSchema.ts", "../../@splunk/datasources/@splunk/dashboard-utils", "../../@splunk/datasources/src/utils/SimpleScheduler.ts", "../../@splunk/datasources/src/utils/random.ts"],
  "sourcesContent": ["import type { Subscriber } from 'rxjs';\nimport type {\n    JSONCols,\n    DataSourceMeta,\n    JobStatus,\n    RequestParams,\n    ErrorLevel,\n} from '@splunk/dashboard-types';\nimport { DataSet, DS_STATUS } from '@splunk/datasource-utils';\nimport type { ObservableData } from './types';\nimport DataSource from './DataSource';\nimport TestDataSourceOptionsSchema from './TestDataSourceOptionsSchema';\nimport SimpleScheduler from './utils/SimpleScheduler';\nimport { Random } from './utils/random';\n\nexport interface TestDataSourceOptions {\n    data?: JSONCols;\n    meta?: DataSourceMeta;\n    delay?: number;\n    timeToStart?: number;\n    errorLevel?: ErrorLevel;\n    error?: string;\n    timeToComplete?: number;\n    increments?: number;\n    checkRiskyCommand?: boolean;\n    random?: {\n        min?: number;\n        max?: number;\n        precision?: number;\n        count?: number;\n        fields: string[];\n    };\n}\n\ninterface TestDataSourceContext {\n    id?: string;\n}\n\n/**\n * @class TestDataSource\n */\nexport default class TestDataSource extends DataSource<\n    TestDataSourceOptions,\n    TestDataSourceContext\n> {\n    /**\n     * List of valid configuration options\n     * @static\n     */\n    static readonly schema = TestDataSourceOptionsSchema;\n\n    static readonly config = {\n        optionsSchema: TestDataSourceOptionsSchema,\n    };\n\n    readonly data: JSONCols;\n\n    readonly meta: DataSourceMeta;\n\n    readonly timeToStart: number;\n\n    readonly errorLevel?: ErrorLevel;\n\n    readonly error?: string;\n\n    readonly timePerUpdate: number;\n\n    readonly incrementSize: number;\n\n    readonly checkRiskyCommand: boolean;\n\n    progress: number;\n\n    status: JobStatus;\n\n    /**\n     * Test Datasource\n     * @param {Object} options.data static data set\n     * @param {Number} [options.delay=0] time before first results return (deprecated)\n     * @param {Object} [options.meta] Return meta, merged with search progress\n     * @param {*} [options.errorLevel] Passthrough data for errors\n     * @param {String} [options.error] Passthrough error message - Set to create an erroring datasource\n     * @param {Number} [options.timeToStart=0] time before first results return (same as delay)\n     * @param {Number} [options.timeToComplete=0] time before all results return (same as delay)\n     * @param {Number} [options.timeToStart=0] time before results return (same as delay)\n     * @param {Number} [options.increments=10] Number of times to return partial results after initial delay\n     * @param {Object} context\n     */\n    constructor(\n        options: TestDataSourceOptions = {},\n        context: TestDataSourceContext = {}\n    ) {\n        super(options, context);\n\n        this.data = this.processData({\n            data: options.data,\n            random: options.random,\n        });\n\n        this.meta = { ...(options.meta ?? {}) };\n        if (typeof this.meta.sid === 'undefined') {\n            // don't use empty strings or undefined as a sid\n            const contextId =\n                typeof context.id === 'string' && context.id\n                    ? context.id\n                    : 'TestDataSource';\n            this.meta.sid = `${contextId}_sid`;\n        }\n        this.timeToStart = options.delay ?? options.timeToStart ?? 0;\n        this.errorLevel = options.errorLevel;\n        this.error = options.error;\n        const timeToComplete = options.timeToComplete ?? 0;\n        const increments = Math.max(options.increments ?? 10, 1);\n        this.timePerUpdate = timeToComplete / increments;\n        this.incrementSize = Math.ceil(100 / increments);\n        this.progress =\n            options.meta?.percentComplete ?? (timeToComplete ? 0 : 100);\n        this.status = DS_STATUS.QUEUED;\n        this.checkRiskyCommand = options.checkRiskyCommand ?? true;\n    }\n\n    // eslint-disable-next-line class-methods-use-this\n    private processData({\n        data,\n        random: { min, max, precision, fields, count = 10 } = { fields: [] },\n    }: Pick<TestDataSourceOptions, 'data' | 'random'>): JSONCols {\n        // start with static data\n        const staticData: JSONCols = data ?? { fields: [], columns: [] };\n\n        // track the fields for which data should be generated\n        const randomFields = fields ?? [];\n\n        // create a class for generating the numeric data\n        const random = new Random({ min, max, precision });\n\n        randomFields.forEach((field) => {\n            const fieldIdx = staticData.fields.findIndex(\n                ({ name }) => name === field\n            );\n\n            if (fieldIdx < 0) {\n                // generate the needed number of rows\n                staticData.fields.push({ name: field });\n                staticData.columns.push(random.nextValues(Math.max(0, count)));\n            } else {\n                // the number of rows currently present\n                const staticCount = staticData.columns[fieldIdx]?.length ?? 0;\n                // what was requested by the user (ignore negatives and default to 10)\n                const requestedCount = Math.max(0, count);\n                // we need the total less the static data\n                const neededCount = requestedCount - staticCount;\n\n                if (neededCount > 0) {\n                    staticData.columns[fieldIdx].push(\n                        ...random.nextValues(neededCount)\n                    );\n                }\n            }\n        });\n\n        return staticData;\n    }\n\n    /**\n     * Create a DataSet\n     * @param {Object} [config]\n     * @param {Array} [config.fields=[]] List of field names\n     * @param {Array[]} [config.columns=[]] List of column data\n     * @return {DataSet}\n     */\n    // eslint-disable-next-line class-methods-use-this\n    toDataSet({ fields = [], columns = [] }: JSONCols): DataSet {\n        return DataSet.fromJSONCols(fields, columns);\n    }\n\n    /**\n     * Calculate the partial results for a dataset\n     * @returns {DataSet}\n     */\n    getData(requestParams?: RequestParams): DataSet {\n        if (this.progress >= 100) {\n            // for now, we only allow pagination for completed data source\n            return this.toDataSet(this.data).getPage({\n                count: requestParams?.count,\n                offset: requestParams?.offset,\n            });\n        }\n\n        const data: JSONCols = { fields: this.data.fields, columns: [] };\n        const size = Math.floor(\n            this.data.columns[0].length * (this.progress / 100)\n        );\n        this.data.columns.forEach((column) => {\n            if (!size) {\n                data.columns.push([]);\n            } else {\n                data.columns.push(column.slice(0, size));\n            }\n        });\n\n        return this.toDataSet(data);\n    }\n\n    /**\n     * Calculate the content of meta\n     * @return {Object}\n     */\n    getMeta(): DataSourceMeta {\n        const meta = { ...this.meta, status: this.status };\n\n        if (this.status === DS_STATUS.FAILED) {\n            return meta;\n        }\n\n        meta.percentComplete = this.progress;\n        // Number of results produced so far...\n        meta.totalCount =\n            meta.totalCount ??\n            Math.floor(\n                (this.data.columns?.[0]?.length ?? 0) * (this.progress / 100)\n            );\n\n        if (this.status !== DS_STATUS.QUEUED) {\n            meta.lastUpdated = new Date().toISOString();\n        }\n\n        return meta;\n    }\n\n    isIgnorableRiskyCommand = () =>\n        // Ignorable risky command needs to actually be a risky command\n        this.error?.startsWith('Found potentially risky commands:') &&\n        // and it needs to have checkRiskyCommand = false\n        !this.checkRiskyCommand;\n\n    private progressUpdateFactory({\n        observer,\n        requestParams,\n    }: {\n        observer: Subscriber<ObservableData>;\n        requestParams?: RequestParams;\n    }) {\n        return async (resultScheduler: SimpleScheduler | null) => {\n            if (this.progress >= 100) {\n                this.status = DS_STATUS.DONE;\n            }\n\n            observer.next({\n                data: this.getData(requestParams),\n                meta: this.getMeta(),\n            });\n\n            if (this.progress >= 100) {\n                observer.complete();\n                resultScheduler?.stop();\n            }\n            this.progress = Math.min(this.progress + this.incrementSize, 100);\n\n            return this.timePerUpdate;\n        };\n    }\n\n    private scheduleRequest(\n        observer: Subscriber<ObservableData>,\n        requestParams?: RequestParams\n    ): {\n        timer: ReturnType<typeof setTimeout>;\n        resultScheduler: SimpleScheduler | null;\n    } {\n        let resultScheduler: SimpleScheduler | null = null;\n\n        const timer = setTimeout(() => {\n            this.status = DS_STATUS.RUNNING;\n\n            if (this.meta.isRealTimeSearch) {\n                // If isRealTimeSearch is set in `.options.meta` then\n                // preserve that during the observer.next call. Otherwise\n                // run the observer to completion as usual.\n                observer.next({\n                    meta: {\n                        isRealTimeSearch: true,\n                        status: DS_STATUS.RUNNING,\n                    },\n                });\n            } else if (\n                typeof this.meta.percentComplete !== 'undefined' &&\n                this.meta.freezeProgress\n            ) {\n                // Allow for data sources to have \"frozen\" progress values\n                // for rendering static progress bar sizes\n                observer.next({\n                    meta: {\n                        percentComplete: this.meta.percentComplete,\n                        totalCount: this.meta.totalCount || 0,\n                        status: DS_STATUS.RUNNING,\n                    },\n                });\n            } else {\n                resultScheduler = SimpleScheduler.createScheduler(\n                    this.progressUpdateFactory({\n                        observer,\n                        requestParams,\n                    })\n                );\n                // kick off the loop\n                resultScheduler.start();\n            }\n        }, this.timeToStart);\n\n        return { timer, resultScheduler };\n    }\n\n    /**\n     * Creates loop to request and return results\n     * @return {Function} Given an observable, schedule data updates over time\n     */\n    request(requestParams?: RequestParams) {\n        return (observer?: Subscriber<ObservableData>): (() => void) => {\n            if (!observer) {\n                return () => undefined;\n            }\n\n            if (this.error && !this.isIgnorableRiskyCommand()) {\n                this.status = DS_STATUS.FAILED;\n                observer.error({\n                    level: this.errorLevel,\n                    message: this.error,\n                    meta: this.getMeta(),\n                });\n                return () => undefined;\n            }\n\n            const { timer, resultScheduler } = this.scheduleRequest(observer, {\n                ...requestParams,\n            });\n\n            return () => {\n                clearTimeout(timer);\n                if (this.status === DS_STATUS.RUNNING) {\n                    this.status = DS_STATUS.CANCELED;\n                }\n                if (resultScheduler) {\n                    resultScheduler.stop();\n                }\n            };\n        };\n    }\n}\n", "\nimport * as defaultImport from \"@splunk/datasource-utils\";\nexport * from \"@splunk/datasource-utils\";\nexport default ('default' in defaultImport ? defaultImport.default : defaultImport);\n", "\nimport * as defaultImport from \"lodash\";\nexport * from \"lodash\";\nexport default ('default' in defaultImport ? defaultImport.default : defaultImport);\n", "/* eslint-disable class-methods-use-this,no-unused-vars, @typescript-eslint/no-unused-vars */\nimport { isEqual } from 'lodash';\nimport type {\n    ExtendableDataSourceDefinition,\n    RequestParams,\n    DSTypes,\n} from '@splunk/dashboard-types';\nimport type { Subscriber } from 'rxjs';\n\ntype DefaultOptions = Record<string, unknown>;\ntype DefaultContext = Record<string, unknown>;\n\n/**\n * Base class of a DataSource\n */\nexport default class DataSource<O = DefaultOptions, C = DefaultContext> {\n    options: O;\n\n    context: C;\n\n    // deprecated property\n    meta?: Record<string, unknown>;\n\n    // deprecated property\n    baseChainModel?: Record<string, ExtendableDataSourceDefinition>;\n\n    /**\n     * Create a new DataSource instance\n     * @param {Object} options DataSource options such as search string, earliest/latest time\n     * @param {Object} context contextual information such as api key or scope\n     * @param {Object} meta metadata of this datasource\n     * @param {Object} baseChainModel base chain definition\n     */\n    constructor(\n        options: O = {} as O,\n        context: C = {} as C,\n        meta = {},\n        baseChainModel = {}\n    ) {\n        this.options = options;\n        this.context = context;\n        this.meta = meta;\n        this.baseChainModel = baseChainModel;\n    }\n\n    /**\n     * Setup the DataSource, create a connection or search job.\n     * setup() will be called only once per DataSource.\n     * Returns null by default; override to implement custom setup logic.\n     *\n     * @return {Promise}\n     * @public\n     */\n    setup(): DSTypes['setup'] {\n        return Promise.resolve(null);\n    }\n\n    /**\n     * Request a Data Stream represent by an Observable.\n     * Once the Observable was created and returned,\n     * it's the DataSource itself responsible for 'pushing' the data out via Observable.next() function.\n     * Override this function to implement your own data fetching logic.\n     *\n     * @param {Object} [requestParams] RequestParams\n     * @param {Number} [requestParams.offset] result offset\n     * @param {Number} [requestParams.count] result count, use with offset to return data in pages\n     * @param {Object} [requestParams.sort] result sorting, key indicate the sorting fields and value must be one of ['none', 'asc', 'desc']\n     * @param {Boolean} [requestParams.requireTotalCount] true if TotalCount is required in meta\n     * @param {Boolean} [requestParams.progress] true to emit progress data, false to only return data when search is finalized\n     * @return {Observable}\n     * @public\n     */\n    request(requestParams?: RequestParams): DSTypes['request'] {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return (observer?: Subscriber<any>) => {\n            if (observer) {\n                observer.complete();\n            }\n            return () => {\n                // cleanup\n            };\n        };\n    }\n\n    /**\n     * Halt updates to results, if supported\n     * @return {Promise}\n     * @public\n     */\n    async pause?(): DSTypes['pause'] {\n        return Promise.resolve(null);\n    }\n\n    /**\n     * Resume previously-halted updates to results, if supported\n     * @return {Promise}\n     * @public\n     */\n    async resume?(): DSTypes['resume'] {\n        return Promise.resolve(null);\n    }\n\n    /**\n     * Reports whether pause and resume controls are supported for the class instance\n     * @return {Boolean} true if the DataSource supports pause and resume actions\n     * @public\n     */\n    supportsControlActions?(): DSTypes['supportsControlActions'] {\n        return false;\n    }\n\n    /**\n     * Teardown the DataSource, clean up the connection or other resources.\n     * Returns null by default; override to implement custom teardown logic.\n     *\n     * @return {Promise}\n     * @public\n     */\n    teardown(): DSTypes['teardown'] {\n        return Promise.resolve(null);\n    }\n\n    /**\n     * @param {DataSource} another another DataSource to compare with\n     * @return {Boolean} true if the these two DataSources are considered equal.\n     * @public\n     */\n    equals(another: DataSource): DSTypes['equals'] {\n        return (\n            this.constructor === another.constructor &&\n            isEqual(this.options, another.options)\n        );\n    }\n\n    /**\n     * Return an observer that can be used for chaining with other DataSources\n     *\n     * @return {Object}\n     * @public\n     */\n    getObserver(): DSTypes['getObserver'] {\n        return {\n            next({ requestParams, data, meta }) {\n                // next\n            },\n            error({ level, message }) {\n                // error\n            },\n            complete() {\n                // complete\n            },\n        };\n    }\n\n    /**\n     * Flag used to indicate whether the subscription for this DataSource should be refreshed\n     *\n     * @return {Boolean}\n     * @public\n     */\n    shouldRefreshSubscription(): DSTypes['shouldRefreshSubscription'] {\n        return false;\n    }\n}\n", "\nimport * as defaultImport from \"@splunk/ui-utils/i18n\";\nexport * from \"@splunk/ui-utils/i18n\";\nexport default ('default' in defaultImport ? defaultImport.default : defaultImport);\n", "import { _ } from '@splunk/ui-utils/i18n';\n\nexport default {\n    data: {\n        type: 'object',\n        nullable: true,\n        additionalProperties: false,\n        properties: {\n            fields: {\n                type: 'array',\n                nullable: true,\n                description: _(\n                    'The fields which should be returned in the data.'\n                ),\n                items: {\n                    oneOf: [\n                        { type: 'string' },\n                        {\n                            type: 'object',\n                            properties: {\n                                name: {\n                                    type: 'string',\n                                    description: _('The name of the field.'),\n                                },\n                            },\n                            required: ['name'],\n                            additionalProperties: true,\n                        },\n                    ],\n                },\n            },\n            columns: {\n                type: 'array',\n                nullable: true,\n                description: _(\n                    'The values for each field in the row. The order of the values must match the order of the fields.'\n                ),\n                items: {\n                    type: 'array',\n                    nullable: false,\n                },\n            },\n        },\n        description: _('The data to return from the test data source.'),\n    },\n    meta: {\n        type: 'object',\n        nullable: true,\n        additionalProperties: true,\n        properties: {\n            percentComplete: {\n                type: 'number',\n                description: _('The percent complete of the search.'),\n            },\n            statusMessage: {\n                type: 'string',\n                description: _(\n                    'A message describing the status of the search.'\n                ),\n            },\n            sid: {\n                type: 'string',\n                description: _('The search ID for the search.'),\n            },\n            status: {\n                type: 'string',\n                enum: ['pending', 'running', 'completed', 'failed'],\n                description: _('The status of the search.'),\n            },\n        },\n        description: _('Metadata about the search'),\n    },\n    errorLevel: {\n        type: 'string',\n        enum: ['info', 'warning', 'error'],\n        description: _('The level of the error.'),\n        nullable: true,\n    },\n    error: {\n        type: 'string',\n        description: _(\n            'An error message if there was an error with the search.'\n        ),\n        nullable: true,\n    },\n    timeToStart: {\n        type: 'number',\n        nullable: true,\n        description: _(\n            'The time in milliseconds it takes for the search to start.'\n        ),\n    },\n    timeToComplete: {\n        type: 'number',\n        nullable: true,\n        description: _(\n            'The time in milliseconds it takes for the search to complete.'\n        ),\n    },\n    increments: {\n        type: 'number',\n        nullable: true,\n        description: _(\n            'The number of batches of results to return between start and end of the search execution.'\n        ),\n    },\n    random: {\n        type: 'object',\n        nullable: true,\n        additionalProperties: false,\n        description: _(\n            'An object containing options for generating random data.'\n        ),\n        properties: {\n            min: {\n                type: 'number',\n                description: _(\n                    'The inclusive minimum value which can be returned.'\n                ),\n            },\n            max: {\n                type: 'number',\n                description: _(\n                    'The inclusive maximum value which can be returned.'\n                ),\n            },\n            precision: {\n                type: 'number',\n                description: _('The number of decimal places to use.'),\n            },\n            fields: {\n                type: 'array',\n                nullable: false,\n                items: {\n                    type: 'string',\n                },\n                description: _('The fields which should have random values.'),\n            },\n            count: {\n                type: 'number',\n                description: _(\n                    'The number of rows to generate. This is only used if there is no static field data defined.'\n                ),\n            },\n        },\n    },\n};\n", "\nimport * as defaultImport from \"@splunk/dashboard-utils\";\nexport * from \"@splunk/dashboard-utils\";\nexport default ('default' in defaultImport ? defaultImport.default : defaultImport);\n", "import { isNumber } from 'lodash';\nimport { noop } from '@splunk/dashboard-utils';\n\ntype TickFn = (resultScheduler: SimpleScheduler) => Promise<number | false>;\ninterface SchedulerOptions {\n    minDelay?: number;\n}\n\n/**\n * A Simple task scheduler\n */\nclass SimpleScheduler {\n    static createScheduler(tickFunc: TickFn, options?: SchedulerOptions) {\n        return new SimpleScheduler(tickFunc, options);\n    }\n\n    private readonly tickFunc: TickFn;\n\n    private readonly minDelay: number;\n\n    private t: ReturnType<typeof setTimeout> | null;\n\n    private stopped: boolean;\n\n    /**\n     *\n     * @param {*} tickFunc a function that will be executed by scheduler, its return value will be used to schedule next execution.\n     * return false from this function will stop the execution\n     * @param {*} options\n     */\n    constructor(tickFunc: TickFn = noop, options: SchedulerOptions = {}) {\n        this.tickFunc = tickFunc;\n        this.minDelay = options.minDelay ?? 0;\n        this.loop = this.loop.bind(this);\n        this.t = null;\n        this.stopped = false;\n    }\n\n    /**\n     * execute tick function and stop next execution if error caught\n     */\n    async tick() {\n        try {\n            return await this.tickFunc(this);\n        } catch {\n            return false;\n        }\n    }\n\n    /**\n     * start scheduler\n     */\n    async start() {\n        this.stopped = false;\n        await this.loop();\n    }\n\n    async loop() {\n        const delay = await this.tick();\n        if (!this.stopped && delay !== false && isNumber(delay)) {\n            this.t = setTimeout(this.loop, Math.max(this.minDelay, delay));\n        }\n    }\n\n    /**\n     * stop scheduler\n     */\n    stop() {\n        this.stopped = true;\n        if (this.t) {\n            clearTimeout(this.t);\n            this.t = null;\n        }\n    }\n}\n\nexport default SimpleScheduler;\n", "// Max value of a Uint32Array entry\nconst Uint32Max = 2 ** 32;\n\nconst getRandomValue = () => {\n    if (typeof globalThis.crypto !== 'undefined') {\n        // get a random unsigned 32-bit int (0 to 2^32)\n        const buffer = new Uint32Array(1);\n        crypto.getRandomValues(buffer);\n\n        return buffer[0];\n    }\n\n    return 0;\n};\n\nexport type RandomNumberInfo = {\n    min?: number;\n    max?: number;\n    precision?: number;\n};\n\nexport class Random {\n    private readonly min: number;\n\n    private readonly range: number;\n\n    private readonly digits: number;\n\n    private readonly precision: number;\n\n    constructor({\n        min = 0,\n        max = min + 10,\n        precision = 0,\n    }: RandomNumberInfo = {}) {\n        // no negative precision, and no more than 20 digits of precision\n        this.digits = Math.min(20, Math.max(0, precision));\n        this.precision = 10 ** this.digits;\n\n        // always keep min <= max\n        if (min > max) {\n            this.min = max;\n            this.range = (min - max + 1) * this.precision;\n        } else {\n            this.min = min;\n            this.range = (max - min + 1) * this.precision;\n        }\n    }\n\n    /**\n     * Get a single random number between the configured min and max (inclusive)\n     * with a specified decimal precision\n     * @returns {number} a random number\n     */\n    public nextValue(): number {\n        const randValue = getRandomValue();\n\n        // clamp the random unsigned 32-bit int to the configured range\n        const wholeNumber = Math.floor((randValue / Uint32Max) * this.range);\n\n        // round the number\n        const roundedWholeNumber = Math.round(wholeNumber + Number.EPSILON);\n\n        // adjust to account for the precision and range min\n        const result = roundedWholeNumber / this.precision + this.min;\n\n        // fix the digits\n        return Number(result.toFixed(this.digits));\n    }\n\n    /**\n     * Get an array of random numbers between the configured min and max\n     * (inclusive) with a specified decimal precision\n     * @param {number} length the number of values to return. This must be >= 1.\n     * @returns {number} an array of size `length` of random numbers\n     */\n    public nextValues(length: number): number[] {\n        if (length < 1) {\n            throw RangeError('Count of values to get cannot be less than 1');\n        }\n\n        // this can't have the shorthand `Array.from({ length }, this.nextValue)` because of the scoping of `this`\n        return Array.from({ length }, () => this.nextValue());\n    }\n}\n"],
  "mappings": "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",
  "names": ["__toESM", "defaultImport", "_a"]
}
