import __buffer_polyfill from 'vite-plugin-node-polyfills/shims/buffer'
globalThis.Buffer = globalThis.Buffer || __buffer_polyfill
import __global_polyfill from 'vite-plugin-node-polyfills/shims/global'
globalThis.global = globalThis.global || __global_polyfill
import __process_polyfill from 'vite-plugin-node-polyfills/shims/process'
globalThis.process = globalThis.process || __process_polyfill

import {
  require_throttle
} from "./chunk-27LK67HU.js";
import {
  require_InformationCircle,
  require_baseClamp,
  require_includes,
  require_isEqual
} from "./chunk-E2Z3JYKW.js";
import {
  require_Button
} from "./chunk-ICO5BW3R.js";
import {
  require_ScreenReaderContent,
  require_last,
  require_omit
} from "./chunk-62I7WT4R.js";
import {
  require_copyArray,
  require_themes
} from "./chunk-CHFSHVDX.js";
import {
  require_useSplunkTheme
} from "./chunk-OXWLTD4R.js";
import {
  init_styled_components_esm,
  styled_components_esm_exports
} from "./chunk-3A7H6U64.js";
import {
  require_prop_types
} from "./chunk-QNBKYQLU.js";
import {
  require_react_dom
} from "./chunk-5LHX6SPM.js";
import {
  require_baseEach,
  require_baseIndexOf,
  require_baseIteratee,
  require_every,
  require_id,
  require_intersection,
  require_isFinite
} from "./chunk-ADRYVMRQ.js";
import {
  require_arrayFilter,
  require_arrayMap,
  require_baseFlatten,
  require_baseGet,
  require_has
} from "./chunk-PYQODTGJ.js";
import {
  require_i18n
} from "./chunk-SFZFMFKO.js";
import {
  require_baseRest,
  require_baseUnary,
  require_identity,
  require_isArrayLike,
  require_isIterateeCall
} from "./chunk-RQTG6R3C.js";
import {
  require_isFunction
} from "./chunk-WZ5QAOVA.js";
import {
  require_isArray
} from "./chunk-H754STBO.js";
import {
  require_toNumber
} from "./chunk-CTKMSYPV.js";
import {
  require_isSymbol
} from "./chunk-QUVU6COR.js";
import {
  require_react
} from "./chunk-ACNULIE3.js";
import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS,
  __toESM,
  require_dist,
  require_dist2,
  require_dist3
} from "./chunk-2RF6DQJU.js";

// node_modules/@splunk/react-ui/usePrevious.js
var require_usePrevious = __commonJS({
  "node_modules/@splunk/react-ui/usePrevious.js"(exports, module) {
    var import_dist10 = __toESM(require_dist());
    var import_dist11 = __toESM(require_dist2());
    var import_dist12 = __toESM(require_dist3());
    (() => {
      "use strict";
      var e2 = {
        /***/
        9497: (
          /***/
          (e3) => {
            e3.exports = require_react();
          }
        )
      };
      var r2 = {};
      function t(o2) {
        var n = r2[o2];
        if (n !== void 0) {
          return n.exports;
        }
        var u = r2[o2] = {
          /******/
          // no module.id needed
          /******/
          // no module.loaded needed
          /******/
          exports: {}
          /******/
        };
        e2[o2](u, u.exports, t);
        return u.exports;
      }
      (() => {
        t.d = (e3, r3) => {
          for (var o2 in r3) {
            if (t.o(r3, o2) && !t.o(e3, o2)) {
              Object.defineProperty(e3, o2, {
                enumerable: true,
                get: r3[o2]
              });
            }
          }
        };
      })();
      (() => {
        t.o = (e3, r3) => Object.prototype.hasOwnProperty.call(e3, r3);
      })();
      (() => {
        t.r = (e3) => {
          if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
            Object.defineProperty(e3, Symbol.toStringTag, {
              value: "Module"
            });
          }
          Object.defineProperty(e3, "__esModule", {
            value: true
          });
        };
      })();
      var o = {};
      (() => {
        t.r(o);
        t.d(o, {
          default: () => (
            /* reexport */
            n
          )
        });
        var e3 = t(9497);
        function r3(r4) {
          var t2 = (0, e3.useRef)();
          (0, e3.useEffect)((function() {
            t2.current = r4;
          }), [r4]);
          return t2.current;
        }
        const n = r3;
      })();
      module.exports = o;
    })();
  }
});

// node_modules/@splunk/react-ui/Box.js
var require_Box = __commonJS({
  "node_modules/@splunk/react-ui/Box.js"(exports, module) {
    var import_dist10 = __toESM(require_dist());
    var import_dist11 = __toESM(require_dist2());
    var import_dist12 = __toESM(require_dist3());
    (() => {
      "use strict";
      var e2 = {};
      (() => {
        e2.n = (n2) => {
          var t2 = n2 && n2.__esModule ? (
            /******/
            () => n2["default"]
          ) : () => n2;
          e2.d(t2, {
            a: t2
          });
          return t2;
        };
      })();
      (() => {
        e2.d = (n2, t2) => {
          for (var r3 in t2) {
            if (e2.o(t2, r3) && !e2.o(n2, r3)) {
              Object.defineProperty(n2, r3, {
                enumerable: true,
                get: t2[r3]
              });
            }
          }
        };
      })();
      (() => {
        e2.o = (e3, n2) => Object.prototype.hasOwnProperty.call(e3, n2);
      })();
      (() => {
        e2.r = (e3) => {
          if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
            Object.defineProperty(e3, Symbol.toStringTag, {
              value: "Module"
            });
          }
          Object.defineProperty(e3, "__esModule", {
            value: true
          });
        };
      })();
      var n = {};
      e2.r(n);
      e2.d(n, {
        default: () => (
          /* reexport */
          v
        )
      });
      const t = require_react();
      var r2 = e2.n(t);
      const l = require_prop_types();
      var i = e2.n(l);
      const o = (init_styled_components_esm(), __toCommonJS(styled_components_esm_exports));
      var a = e2.n(o);
      const f = require_themes();
      var d = a().div.withConfig({
        displayName: "BoxStyles__Styled",
        componentId: "sc-1h4b5f6-0"
      })(["", ";align-items:stretch;align-content:stretch;flex-flow:row nowrap;flex-grow:0;flex-shrink:0;justify-content:flex-start;width:auto;max-width:100%;&[data-inline]{display:inline-block;vertical-align:middle;}&[data-flex]{display:flex;}&[data-flex][data-inline]{display:inline-flex;}"], f.mixins.reset("block"));
      function s() {
        return s = Object.assign ? Object.assign.bind() : function(e3) {
          for (var n2 = 1; n2 < arguments.length; n2++) {
            var t2 = arguments[n2];
            for (var r3 in t2) {
              ({}).hasOwnProperty.call(t2, r3) && (e3[r3] = t2[r3]);
            }
          }
          return e3;
        }, s.apply(null, arguments);
      }
      function c(e3, n2) {
        if (null == e3) return {};
        var t2, r3, l2 = u(e3, n2);
        if (Object.getOwnPropertySymbols) {
          var i2 = Object.getOwnPropertySymbols(e3);
          for (r3 = 0; r3 < i2.length; r3++) {
            t2 = i2[r3], -1 === n2.indexOf(t2) && {}.propertyIsEnumerable.call(e3, t2) && (l2[t2] = e3[t2]);
          }
        }
        return l2;
      }
      function u(e3, n2) {
        if (null == e3) return {};
        var t2 = {};
        for (var r3 in e3) {
          if ({}.hasOwnProperty.call(e3, r3)) {
            if (-1 !== n2.indexOf(r3)) continue;
            t2[r3] = e3[r3];
          }
        }
        return t2;
      }
      var p = {
        children: i().node,
        elementRef: i().oneOfType([i().func, i().object]),
        flex: i().bool,
        inline: i().bool
      };
      function y(e3) {
        var n2 = e3.children, t2 = e3.elementRef, l2 = e3.flex, i2 = l2 === void 0 ? false : l2, o2 = e3.tag, a2 = o2 === void 0 ? "div" : o2, f2 = e3.inline, u2 = f2 === void 0 ? false : f2, p2 = c(e3, ["children", "elementRef", "flex", "tag", "inline"]);
        return r2().createElement(d, s({
          as: a2,
          ref: t2
        }, p2, {
          "data-inline": u2 || void 0,
          "data-flex": i2 || void 0
        }), n2);
      }
      y.propTypes = p;
      const v = y;
      module.exports = n;
    })();
  }
});

// node_modules/@splunk/react-ui/useControlled.js
var require_useControlled = __commonJS({
  "node_modules/@splunk/react-ui/useControlled.js"(exports, module) {
    var import_dist10 = __toESM(require_dist());
    var import_dist11 = __toESM(require_dist2());
    var import_dist12 = __toESM(require_dist3());
    (() => {
      "use strict";
      var e2 = {
        /***/
        5919: (
          /***/
          (e3) => {
            e3.exports = require_has();
          }
        ),
        /***/
        9497: (
          /***/
          (e3) => {
            e3.exports = require_react();
          }
        )
      };
      var r2 = {};
      function t(o2) {
        var n = r2[o2];
        if (n !== void 0) {
          return n.exports;
        }
        var u = r2[o2] = {
          /******/
          // no module.id needed
          /******/
          // no module.loaded needed
          /******/
          exports: {}
          /******/
        };
        e2[o2](u, u.exports, t);
        return u.exports;
      }
      (() => {
        t.n = (e3) => {
          var r3 = e3 && e3.__esModule ? (
            /******/
            () => e3["default"]
          ) : () => e3;
          t.d(r3, {
            a: r3
          });
          return r3;
        };
      })();
      (() => {
        t.d = (e3, r3) => {
          for (var o2 in r3) {
            if (t.o(r3, o2) && !t.o(e3, o2)) {
              Object.defineProperty(e3, o2, {
                enumerable: true,
                get: r3[o2]
              });
            }
          }
        };
      })();
      (() => {
        t.o = (e3, r3) => Object.prototype.hasOwnProperty.call(e3, r3);
      })();
      (() => {
        t.r = (e3) => {
          if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
            Object.defineProperty(e3, Symbol.toStringTag, {
              value: "Module"
            });
          }
          Object.defineProperty(e3, "__esModule", {
            value: true
          });
        };
      })();
      var o = {};
      (() => {
        t.r(o);
        t.d(o, {
          default: () => (
            /* reexport */
            l
          ),
          isAllowedType: () => (
            /* reexport */
            f
          ),
          isPrimitive: () => (
            /* reexport */
            a
          )
        });
        var e3 = t(9497);
        const r3 = require_isEqual();
        var n = t(5919);
        var u = t.n(n);
        function a(e4) {
          return e4 === null || e4 === void 0 || typeof e4 === "boolean" || typeof e4 === "string" || typeof e4 === "number";
        }
        function f(e4) {
          if (a(e4)) {
            return true;
          }
          if (Array.isArray(e4)) {
            return e4.every(a);
          }
          return false;
        }
        function i(r4) {
          var t2 = r4.componentProps, o2 = r4.componentName, n2 = o2 === void 0 ? "this component" : o2, a2 = r4.defaultValuePropName, f2 = a2 === void 0 ? "defaultValue" : a2, i2 = r4.valuePropName, l2 = i2 === void 0 ? "value" : i2;
          var s = (0, e3.useRef)(u()(t2, l2));
          var d = (0, e3.useRef)(t2[f2]);
          (0, e3.useEffect)((function() {
            if (false) {
            }
          }), [n2, t2, f2, l2]);
          (0, e3.useEffect)((function() {
            if (false) {
            }
            if (false) {
            }
            if (false) {
            }
          }), [n2, t2, f2, l2]);
          return s.current;
        }
        const l = i;
      })();
      module.exports = o;
    })();
  }
});

// node_modules/lodash/clamp.js
var require_clamp = __commonJS({
  "node_modules/lodash/clamp.js"(exports, module) {
    var import_dist10 = __toESM(require_dist());
    var import_dist11 = __toESM(require_dist2());
    var import_dist12 = __toESM(require_dist3());
    var baseClamp = require_baseClamp();
    var toNumber = require_toNumber();
    function clamp(number, lower, upper) {
      if (upper === void 0) {
        upper = lower;
        lower = void 0;
      }
      if (upper !== void 0) {
        upper = toNumber(upper);
        upper = upper === upper ? upper : 0;
      }
      if (lower !== void 0) {
        lower = toNumber(lower);
        lower = lower === lower ? lower : 0;
      }
      return baseClamp(toNumber(number), lower, upper);
    }
    module.exports = clamp;
  }
});

// node_modules/lodash/_baseDelay.js
var require_baseDelay = __commonJS({
  "node_modules/lodash/_baseDelay.js"(exports, module) {
    var import_dist10 = __toESM(require_dist());
    var import_dist11 = __toESM(require_dist2());
    var import_dist12 = __toESM(require_dist3());
    var FUNC_ERROR_TEXT = "Expected a function";
    function baseDelay(func, wait, args) {
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return setTimeout(function() {
        func.apply(void 0, args);
      }, wait);
    }
    module.exports = baseDelay;
  }
});

// node_modules/lodash/defer.js
var require_defer = __commonJS({
  "node_modules/lodash/defer.js"(exports, module) {
    var import_dist10 = __toESM(require_dist());
    var import_dist11 = __toESM(require_dist2());
    var import_dist12 = __toESM(require_dist3());
    var baseDelay = require_baseDelay();
    var baseRest = require_baseRest();
    var defer = baseRest(function(func, args) {
      return baseDelay(func, 1, args);
    });
    module.exports = defer;
  }
});

// node_modules/@react-spring/rafz/dist/cjs/react-spring_rafz.production.min.cjs
var require_react_spring_rafz_production_min = __commonJS({
  "node_modules/@react-spring/rafz/dist/cjs/react-spring_rafz.production.min.cjs"(exports, module) {
    "use strict";
    var import_dist10 = __toESM(require_dist());
    var import_dist11 = __toESM(require_dist2());
    var import_dist12 = __toESM(require_dist3());
    var T = Object.defineProperty;
    var S = Object.getOwnPropertyDescriptor;
    var U = Object.getOwnPropertyNames;
    var g = Object.prototype.hasOwnProperty;
    var E = (e2, t) => {
      for (var a in t) T(e2, a, { get: t[a], enumerable: true });
    };
    var L = (e2, t, a, o) => {
      if (t && typeof t == "object" || typeof t == "function") for (let r2 of U(t)) !g.call(e2, r2) && r2 !== a && T(e2, r2, { get: () => t[r2], enumerable: !(o = S(t, r2)) || o.enumerable });
      return e2;
    };
    var A = (e2) => L(T({}, "__esModule", { value: true }), e2);
    var N = {};
    E(N, { __raf: () => I, raf: () => n });
    module.exports = A(N);
    var f = l();
    var n = (e2) => s(e2, f);
    var m = l();
    n.write = (e2) => s(e2, m);
    var c = l();
    n.onStart = (e2) => s(e2, c);
    var h = l();
    n.onFrame = (e2) => s(e2, h);
    var p = l();
    n.onFinish = (e2) => s(e2, p);
    var d = [];
    n.setTimeout = (e2, t) => {
      let a = n.now() + t, o = () => {
        let F = d.findIndex((R) => R.cancel == o);
        ~F && d.splice(F, 1), i -= ~F ? 1 : 0;
      }, r2 = { time: a, handler: e2, cancel: o };
      return d.splice(v(a), 0, r2), i += 1, b(), r2;
    };
    var v = (e2) => ~(~d.findIndex((t) => t.time > e2) || ~d.length);
    n.cancel = (e2) => {
      c.delete(e2), h.delete(e2), p.delete(e2), f.delete(e2), m.delete(e2);
    };
    n.sync = (e2) => {
      y = true, n.batchedUpdates(e2), y = false;
    };
    n.throttle = (e2) => {
      let t;
      function a() {
        try {
          e2(...t);
        } finally {
          t = null;
        }
      }
      function o(...r2) {
        t = r2, n.onStart(a);
      }
      return o.handler = e2, o.cancel = () => {
        c.delete(a), t = null;
      }, o;
    };
    var w = typeof window < "u" ? window.requestAnimationFrame : () => {
    };
    n.use = (e2) => w = e2;
    n.now = typeof performance < "u" ? () => performance.now() : Date.now;
    n.batchedUpdates = (e2) => e2();
    n.catch = console.error;
    n.frameLoop = "always";
    n.advance = () => {
      n.frameLoop !== "demand" ? console.warn("Cannot call the manual advancement of rafz whilst frameLoop is not set as demand") : Q();
    };
    var u = -1;
    var i = 0;
    var y = false;
    function s(e2, t) {
      y ? (t.delete(e2), e2(0)) : (t.add(e2), b());
    }
    function b() {
      u < 0 && (u = 0, n.frameLoop !== "demand" && w(x));
    }
    function C() {
      u = -1;
    }
    function x() {
      ~u && (w(x), n.batchedUpdates(Q));
    }
    function Q() {
      let e2 = u;
      u = n.now();
      let t = v(u);
      if (t && (z(d.splice(0, t), (a) => a.handler()), i -= t), !i) {
        C();
        return;
      }
      c.flush(), f.flush(e2 ? Math.min(64, u - e2) : 16.667), h.flush(), m.flush(), p.flush();
    }
    function l() {
      let e2 = /* @__PURE__ */ new Set(), t = e2;
      return { add(a) {
        i += t == e2 && !e2.has(a) ? 1 : 0, e2.add(a);
      }, delete(a) {
        return i -= t == e2 && e2.has(a) ? 1 : 0, e2.delete(a);
      }, flush(a) {
        t.size && (e2 = /* @__PURE__ */ new Set(), i -= t.size, z(t, (o) => o(a) && e2.add(o)), i += e2.size, t = e2);
      } };
    }
    function z(e2, t) {
      e2.forEach((a) => {
        try {
          t(a);
        } catch (o) {
          n.catch(o);
        }
      });
    }
    var I = { count() {
      return i;
    }, isRunning() {
      return u >= 0;
    }, clear() {
      u = -1, d = [], c = l(), f = l(), h = l(), m = l(), p = l(), i = 0;
    } };
  }
});

// node_modules/@react-spring/rafz/dist/cjs/react-spring_rafz.development.cjs
var require_react_spring_rafz_development = __commonJS({
  "node_modules/@react-spring/rafz/dist/cjs/react-spring_rafz.development.cjs"(exports, module) {
    "use strict";
    var import_dist10 = __toESM(require_dist());
    var import_dist11 = __toESM(require_dist2());
    var import_dist12 = __toESM(require_dist3());
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export2(src_exports, {
      __raf: () => __raf,
      raf: () => raf
    });
    module.exports = __toCommonJS2(src_exports);
    var updateQueue = makeQueue();
    var raf = (fn) => schedule(fn, updateQueue);
    var writeQueue = makeQueue();
    raf.write = (fn) => schedule(fn, writeQueue);
    var onStartQueue = makeQueue();
    raf.onStart = (fn) => schedule(fn, onStartQueue);
    var onFrameQueue = makeQueue();
    raf.onFrame = (fn) => schedule(fn, onFrameQueue);
    var onFinishQueue = makeQueue();
    raf.onFinish = (fn) => schedule(fn, onFinishQueue);
    var timeouts = [];
    raf.setTimeout = (handler, ms) => {
      const time = raf.now() + ms;
      const cancel = () => {
        const i = timeouts.findIndex((t) => t.cancel == cancel);
        if (~i)
          timeouts.splice(i, 1);
        pendingCount -= ~i ? 1 : 0;
      };
      const timeout = { time, handler, cancel };
      timeouts.splice(findTimeout(time), 0, timeout);
      pendingCount += 1;
      start();
      return timeout;
    };
    var findTimeout = (time) => ~(~timeouts.findIndex((t) => t.time > time) || ~timeouts.length);
    raf.cancel = (fn) => {
      onStartQueue.delete(fn);
      onFrameQueue.delete(fn);
      onFinishQueue.delete(fn);
      updateQueue.delete(fn);
      writeQueue.delete(fn);
    };
    raf.sync = (fn) => {
      sync = true;
      raf.batchedUpdates(fn);
      sync = false;
    };
    raf.throttle = (fn) => {
      let lastArgs;
      function queuedFn() {
        try {
          fn(...lastArgs);
        } finally {
          lastArgs = null;
        }
      }
      function throttled(...args) {
        lastArgs = args;
        raf.onStart(queuedFn);
      }
      throttled.handler = fn;
      throttled.cancel = () => {
        onStartQueue.delete(queuedFn);
        lastArgs = null;
      };
      return throttled;
    };
    var nativeRaf = typeof window != "undefined" ? window.requestAnimationFrame : (
      // eslint-disable-next-line @typescript-eslint/no-empty-function
      (() => {
      })
    );
    raf.use = (impl) => nativeRaf = impl;
    raf.now = typeof performance != "undefined" ? () => performance.now() : Date.now;
    raf.batchedUpdates = (fn) => fn();
    raf.catch = console.error;
    raf.frameLoop = "always";
    raf.advance = () => {
      if (raf.frameLoop !== "demand") {
        console.warn(
          "Cannot call the manual advancement of rafz whilst frameLoop is not set as demand"
        );
      } else {
        update();
      }
    };
    var ts = -1;
    var pendingCount = 0;
    var sync = false;
    function schedule(fn, queue) {
      if (sync) {
        queue.delete(fn);
        fn(0);
      } else {
        queue.add(fn);
        start();
      }
    }
    function start() {
      if (ts < 0) {
        ts = 0;
        if (raf.frameLoop !== "demand") {
          nativeRaf(loop);
        }
      }
    }
    function stop() {
      ts = -1;
    }
    function loop() {
      if (~ts) {
        nativeRaf(loop);
        raf.batchedUpdates(update);
      }
    }
    function update() {
      const prevTs = ts;
      ts = raf.now();
      const count = findTimeout(ts);
      if (count) {
        eachSafely(timeouts.splice(0, count), (t) => t.handler());
        pendingCount -= count;
      }
      if (!pendingCount) {
        stop();
        return;
      }
      onStartQueue.flush();
      updateQueue.flush(prevTs ? Math.min(64, ts - prevTs) : 16.667);
      onFrameQueue.flush();
      writeQueue.flush();
      onFinishQueue.flush();
    }
    function makeQueue() {
      let next = /* @__PURE__ */ new Set();
      let current = next;
      return {
        add(fn) {
          pendingCount += current == next && !next.has(fn) ? 1 : 0;
          next.add(fn);
        },
        delete(fn) {
          pendingCount -= current == next && next.has(fn) ? 1 : 0;
          return next.delete(fn);
        },
        flush(arg) {
          if (current.size) {
            next = /* @__PURE__ */ new Set();
            pendingCount -= current.size;
            eachSafely(current, (fn) => fn(arg) && next.add(fn));
            pendingCount += next.size;
            current = next;
          }
        }
      };
    }
    function eachSafely(values, each) {
      values.forEach((value) => {
        try {
          each(value);
        } catch (e2) {
          raf.catch(e2);
        }
      });
    }
    var __raf = {
      /** The number of pending tasks */
      count() {
        return pendingCount;
      },
      /** Whether there's a raf update loop running */
      isRunning() {
        return ts >= 0;
      },
      /** Clear internal state. Never call from update loop! */
      clear() {
        ts = -1;
        timeouts = [];
        onStartQueue = makeQueue();
        updateQueue = makeQueue();
        onFrameQueue = makeQueue();
        writeQueue = makeQueue();
        onFinishQueue = makeQueue();
        pendingCount = 0;
      }
    };
  }
});

// node_modules/@react-spring/rafz/dist/cjs/index.js
var require_cjs = __commonJS({
  "node_modules/@react-spring/rafz/dist/cjs/index.js"(exports, module) {
    "use strict";
    var import_dist10 = __toESM(require_dist());
    var import_dist11 = __toESM(require_dist2());
    var import_dist12 = __toESM(require_dist3());
    if (process.env.NODE_ENV === "production") {
      module.exports = require_react_spring_rafz_production_min();
    } else {
      module.exports = require_react_spring_rafz_development();
    }
  }
});

// node_modules/@react-spring/shared/dist/cjs/react-spring_shared.production.min.cjs
var require_react_spring_shared_production_min = __commonJS({
  "node_modules/@react-spring/shared/dist/cjs/react-spring_shared.production.min.cjs"(exports, module) {
    "use strict";
    var import_dist10 = __toESM(require_dist());
    var import_dist11 = __toESM(require_dist2());
    var import_dist12 = __toESM(require_dist3());
    var K = Object.defineProperty;
    var _e = Object.getOwnPropertyDescriptor;
    var Ze = Object.getOwnPropertyNames;
    var Xe = Object.prototype.hasOwnProperty;
    var he = (e2, t) => {
      for (var r2 in t) K(e2, r2, { get: t[r2], enumerable: true });
    };
    var Ye = (e2, t, r2, n) => {
      if (t && typeof t == "object" || typeof t == "function") for (let o of Ze(t)) !Xe.call(e2, o) && o !== r2 && K(e2, o, { get: () => t[o], enumerable: !(n = _e(t, o)) || n.enumerable });
      return e2;
    };
    var Je = (e2) => Ye(K({}, "__esModule", { value: true }), e2);
    var $t = {};
    he($t, { FluidValue: () => se, Globals: () => p, addFluidObserver: () => xt, callFluidObserver: () => Ce, callFluidObservers: () => bt, clamp: () => Y, colorToRgba: () => P, colors: () => it, createInterpolator: () => q, createStringInterpolator: () => vt, defineHidden: () => et, deprecateDirectCall: () => Tt, deprecateInterpolate: () => Ot, each: () => ye, eachProp: () => rt, easings: () => dt, flush: () => ge, flushCalls: () => ot, frameLoop: () => Oe, getFluidObservers: () => mt, getFluidValue: () => ue, hasFluidValue: () => pt, hex3: () => ne, hex4: () => oe, hex6: () => fe, hex8: () => ae, hsl: () => te, hsla: () => re, is: () => u, isAnimatedString: () => Ft, isEqual: () => tt, isSSR: () => m, noop: () => N, onResize: () => me, onScroll: () => Rt, once: () => pe, prefix: () => U, raf: () => Ne.raf, removeFluidObserver: () => ht, rgb: () => J, rgba: () => ee, setFluidGetter: () => ze, toArray: () => nt, useConstant: () => At, useForceUpdate: () => Mt, useIsomorphicLayoutEffect: () => S, useMemoOne: () => Ct, useOnce: () => Lt, usePrev: () => Pt, useReducedMotion: () => qt });
    module.exports = Je($t);
    var p = {};
    he(p, { assign: () => _, colors: () => c, createStringInterpolator: () => A, skipAnimation: () => Ee, to: () => ve, willAdvance: () => M });
    var O = require_cjs();
    function N() {
    }
    var et = (e2, t, r2) => Object.defineProperty(e2, t, { value: r2, writable: true, configurable: true });
    var u = { arr: Array.isArray, obj: (e2) => !!e2 && e2.constructor.name === "Object", fun: (e2) => typeof e2 == "function", str: (e2) => typeof e2 == "string", num: (e2) => typeof e2 == "number", und: (e2) => e2 === void 0 };
    function tt(e2, t) {
      if (u.arr(e2)) {
        if (!u.arr(t) || e2.length !== t.length) return false;
        for (let r2 = 0; r2 < e2.length; r2++) if (e2[r2] !== t[r2]) return false;
        return true;
      }
      return e2 === t;
    }
    var ye = (e2, t) => e2.forEach(t);
    function rt(e2, t, r2) {
      if (u.arr(e2)) {
        for (let n = 0; n < e2.length; n++) t.call(r2, e2[n], `${n}`);
        return;
      }
      for (let n in e2) e2.hasOwnProperty(n) && t.call(r2, e2[n], n);
    }
    var nt = (e2) => u.und(e2) ? [] : u.arr(e2) ? e2 : [e2];
    function ge(e2, t) {
      if (e2.size) {
        let r2 = Array.from(e2);
        e2.clear(), ye(r2, t);
      }
    }
    var ot = (e2, ...t) => ge(e2, (r2) => r2(...t));
    var m = () => typeof window > "u" || !window.navigator || /ServerSideRendering|^Deno\//.test(window.navigator.userAgent);
    var A;
    var ve;
    var c = null;
    var Ee = false;
    var M = N;
    var _ = (e2) => {
      e2.to && (ve = e2.to), e2.now && (O.raf.now = e2.now), e2.colors !== void 0 && (c = e2.colors), e2.skipAnimation != null && (Ee = e2.skipAnimation), e2.createStringInterpolator && (A = e2.createStringInterpolator), e2.requestAnimationFrame && O.raf.use(e2.requestAnimationFrame), e2.batchedUpdates && (O.raf.batchedUpdates = e2.batchedUpdates), e2.willAdvance && (M = e2.willAdvance), e2.frameLoop && (O.raf.frameLoop = e2.frameLoop);
    };
    var w = require_cjs();
    var T = /* @__PURE__ */ new Set();
    var l = [];
    var Z = [];
    var C = 0;
    var Oe = { get idle() {
      return !T.size && !l.length;
    }, start(e2) {
      C > e2.priority ? (T.add(e2), w.raf.onStart(ft)) : (we(e2), (0, w.raf)(X));
    }, advance: X, sort(e2) {
      if (C) w.raf.onFrame(() => Oe.sort(e2));
      else {
        let t = l.indexOf(e2);
        ~t && (l.splice(t, 1), Te(e2));
      }
    }, clear() {
      l = [], T.clear();
    } };
    function ft() {
      T.forEach(we), T.clear(), (0, w.raf)(X);
    }
    function we(e2) {
      l.includes(e2) || Te(e2);
    }
    function Te(e2) {
      l.splice(at(l, (t) => t.priority > e2.priority), 0, e2);
    }
    function X(e2) {
      let t = Z;
      for (let r2 = 0; r2 < l.length; r2++) {
        let n = l[r2];
        C = n.priority, n.idle || (M(n), n.advance(e2), n.idle || t.push(n));
      }
      return C = 0, Z = l, Z.length = 0, l = t, l.length > 0;
    }
    function at(e2, t) {
      let r2 = e2.findIndex(t);
      return r2 < 0 ? e2.length : r2;
    }
    var Y = (e2, t, r2) => Math.min(Math.max(r2, e2), t);
    var it = { transparent: 0, aliceblue: 4042850303, antiquewhite: 4209760255, aqua: 16777215, aquamarine: 2147472639, azure: 4043309055, beige: 4126530815, bisque: 4293182719, black: 255, blanchedalmond: 4293643775, blue: 65535, blueviolet: 2318131967, brown: 2771004159, burlywood: 3736635391, burntsienna: 3934150143, cadetblue: 1604231423, chartreuse: 2147418367, chocolate: 3530104575, coral: 4286533887, cornflowerblue: 1687547391, cornsilk: 4294499583, crimson: 3692313855, cyan: 16777215, darkblue: 35839, darkcyan: 9145343, darkgoldenrod: 3095792639, darkgray: 2846468607, darkgreen: 6553855, darkgrey: 2846468607, darkkhaki: 3182914559, darkmagenta: 2332068863, darkolivegreen: 1433087999, darkorange: 4287365375, darkorchid: 2570243327, darkred: 2332033279, darksalmon: 3918953215, darkseagreen: 2411499519, darkslateblue: 1211993087, darkslategray: 793726975, darkslategrey: 793726975, darkturquoise: 13554175, darkviolet: 2483082239, deeppink: 4279538687, deepskyblue: 12582911, dimgray: 1768516095, dimgrey: 1768516095, dodgerblue: 512819199, firebrick: 2988581631, floralwhite: 4294635775, forestgreen: 579543807, fuchsia: 4278255615, gainsboro: 3705462015, ghostwhite: 4177068031, gold: 4292280575, goldenrod: 3668254975, gray: 2155905279, green: 8388863, greenyellow: 2919182335, grey: 2155905279, honeydew: 4043305215, hotpink: 4285117695, indianred: 3445382399, indigo: 1258324735, ivory: 4294963455, khaki: 4041641215, lavender: 3873897215, lavenderblush: 4293981695, lawngreen: 2096890111, lemonchiffon: 4294626815, lightblue: 2916673279, lightcoral: 4034953471, lightcyan: 3774873599, lightgoldenrodyellow: 4210742015, lightgray: 3553874943, lightgreen: 2431553791, lightgrey: 3553874943, lightpink: 4290167295, lightsalmon: 4288707327, lightseagreen: 548580095, lightskyblue: 2278488831, lightslategray: 2005441023, lightslategrey: 2005441023, lightsteelblue: 2965692159, lightyellow: 4294959359, lime: 16711935, limegreen: 852308735, linen: 4210091775, magenta: 4278255615, maroon: 2147483903, mediumaquamarine: 1724754687, mediumblue: 52735, mediumorchid: 3126187007, mediumpurple: 2473647103, mediumseagreen: 1018393087, mediumslateblue: 2070474495, mediumspringgreen: 16423679, mediumturquoise: 1221709055, mediumvioletred: 3340076543, midnightblue: 421097727, mintcream: 4127193855, mistyrose: 4293190143, moccasin: 4293178879, navajowhite: 4292783615, navy: 33023, oldlace: 4260751103, olive: 2155872511, olivedrab: 1804477439, orange: 4289003775, orangered: 4282712319, orchid: 3664828159, palegoldenrod: 4008225535, palegreen: 2566625535, paleturquoise: 2951671551, palevioletred: 3681588223, papayawhip: 4293907967, peachpuff: 4292524543, peru: 3448061951, pink: 4290825215, plum: 3718307327, powderblue: 2967529215, purple: 2147516671, rebeccapurple: 1714657791, red: 4278190335, rosybrown: 3163525119, royalblue: 1097458175, saddlebrown: 2336560127, salmon: 4202722047, sandybrown: 4104413439, seagreen: 780883967, seashell: 4294307583, sienna: 2689740287, silver: 3233857791, skyblue: 2278484991, slateblue: 1784335871, slategray: 1887473919, slategrey: 1887473919, snow: 4294638335, springgreen: 16744447, steelblue: 1182971135, tan: 3535047935, teal: 8421631, thistle: 3636451583, tomato: 4284696575, turquoise: 1088475391, violet: 4001558271, wheat: 4125012991, white: 4294967295, whitesmoke: 4126537215, yellow: 4294902015, yellowgreen: 2597139199 };
    var d = "[-+]?\\d*\\.?\\d+";
    var z = d + "%";
    function L(...e2) {
      return "\\(\\s*(" + e2.join(")\\s*,\\s*(") + ")\\s*\\)";
    }
    var J = new RegExp("rgb" + L(d, d, d));
    var ee = new RegExp("rgba" + L(d, d, d, d));
    var te = new RegExp("hsl" + L(d, z, z));
    var re = new RegExp("hsla" + L(d, z, z, d));
    var ne = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;
    var oe = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;
    var fe = /^#([0-9a-fA-F]{6})$/;
    var ae = /^#([0-9a-fA-F]{8})$/;
    function Se(e2) {
      let t;
      return typeof e2 == "number" ? e2 >>> 0 === e2 && e2 >= 0 && e2 <= 4294967295 ? e2 : null : (t = fe.exec(e2)) ? parseInt(t[1] + "ff", 16) >>> 0 : c && c[e2] !== void 0 ? c[e2] : (t = J.exec(e2)) ? (y(t[1]) << 24 | y(t[2]) << 16 | y(t[3]) << 8 | 255) >>> 0 : (t = ee.exec(e2)) ? (y(t[1]) << 24 | y(t[2]) << 16 | y(t[3]) << 8 | ke(t[4])) >>> 0 : (t = ne.exec(e2)) ? parseInt(t[1] + t[1] + t[2] + t[2] + t[3] + t[3] + "ff", 16) >>> 0 : (t = ae.exec(e2)) ? parseInt(t[1], 16) >>> 0 : (t = oe.exec(e2)) ? parseInt(t[1] + t[1] + t[2] + t[2] + t[3] + t[3] + t[4] + t[4], 16) >>> 0 : (t = te.exec(e2)) ? (Fe(Ie(t[1]), V(t[2]), V(t[3])) | 255) >>> 0 : (t = re.exec(e2)) ? (Fe(Ie(t[1]), V(t[2]), V(t[3])) | ke(t[4])) >>> 0 : null;
    }
    function ie(e2, t, r2) {
      return r2 < 0 && (r2 += 1), r2 > 1 && (r2 -= 1), r2 < 1 / 6 ? e2 + (t - e2) * 6 * r2 : r2 < 1 / 2 ? t : r2 < 2 / 3 ? e2 + (t - e2) * (2 / 3 - r2) * 6 : e2;
    }
    function Fe(e2, t, r2) {
      let n = r2 < 0.5 ? r2 * (1 + t) : r2 + t - r2 * t, o = 2 * r2 - n, f = ie(o, n, e2 + 1 / 3), i = ie(o, n, e2), s = ie(o, n, e2 - 1 / 3);
      return Math.round(f * 255) << 24 | Math.round(i * 255) << 16 | Math.round(s * 255) << 8;
    }
    function y(e2) {
      let t = parseInt(e2, 10);
      return t < 0 ? 0 : t > 255 ? 255 : t;
    }
    function Ie(e2) {
      return (parseFloat(e2) % 360 + 360) % 360 / 360;
    }
    function ke(e2) {
      let t = parseFloat(e2);
      return t < 0 ? 0 : t > 1 ? 255 : Math.round(t * 255);
    }
    function V(e2) {
      let t = parseFloat(e2);
      return t < 0 ? 0 : t > 100 ? 1 : t / 100;
    }
    function P(e2) {
      let t = Se(e2);
      if (t === null) return e2;
      t = t || 0;
      let r2 = (t & 4278190080) >>> 24, n = (t & 16711680) >>> 16, o = (t & 65280) >>> 8, f = (t & 255) / 255;
      return `rgba(${r2}, ${n}, ${o}, ${f})`;
    }
    var q = (e2, t, r2) => {
      if (u.fun(e2)) return e2;
      if (u.arr(e2)) return q({ range: e2, output: t, extrapolate: r2 });
      if (u.str(e2.output[0])) return A(e2);
      let n = e2, o = n.output, f = n.range || [0, 1], i = n.extrapolateLeft || n.extrapolate || "extend", s = n.extrapolateRight || n.extrapolate || "extend", h = n.easing || ((a) => a);
      return (a) => {
        let R = lt(a, f);
        return ut(a, f[R], f[R + 1], o[R], o[R + 1], h, i, s, n.map);
      };
    };
    function ut(e2, t, r2, n, o, f, i, s, h) {
      let a = h ? h(e2) : e2;
      if (a < t) {
        if (i === "identity") return a;
        i === "clamp" && (a = t);
      }
      if (a > r2) {
        if (s === "identity") return a;
        s === "clamp" && (a = r2);
      }
      return n === o ? n : t === r2 ? e2 <= t ? n : o : (t === -1 / 0 ? a = -a : r2 === 1 / 0 ? a = a - t : a = (a - t) / (r2 - t), a = f(a), n === -1 / 0 ? a = -a : o === 1 / 0 ? a = a + n : a = a * (o - n) + n, a);
    }
    function lt(e2, t) {
      for (var r2 = 1; r2 < t.length - 1 && !(t[r2] >= e2); ++r2) ;
      return r2 - 1;
    }
    var ct = (e2, t = "end") => (r2) => {
      r2 = t === "end" ? Math.min(r2, 0.999) : Math.max(r2, 1e-3);
      let n = r2 * e2, o = t === "end" ? Math.floor(n) : Math.ceil(n);
      return Y(0, 1, o / e2);
    };
    var Q = 1.70158;
    var $ = Q * 1.525;
    var Re = Q + 1;
    var Ae = 2 * Math.PI / 3;
    var Me = 2 * Math.PI / 4.5;
    var G = (e2) => e2 < 1 / 2.75 ? 7.5625 * e2 * e2 : e2 < 2 / 2.75 ? 7.5625 * (e2 -= 1.5 / 2.75) * e2 + 0.75 : e2 < 2.5 / 2.75 ? 7.5625 * (e2 -= 2.25 / 2.75) * e2 + 0.9375 : 7.5625 * (e2 -= 2.625 / 2.75) * e2 + 0.984375;
    var dt = { linear: (e2) => e2, easeInQuad: (e2) => e2 * e2, easeOutQuad: (e2) => 1 - (1 - e2) * (1 - e2), easeInOutQuad: (e2) => e2 < 0.5 ? 2 * e2 * e2 : 1 - Math.pow(-2 * e2 + 2, 2) / 2, easeInCubic: (e2) => e2 * e2 * e2, easeOutCubic: (e2) => 1 - Math.pow(1 - e2, 3), easeInOutCubic: (e2) => e2 < 0.5 ? 4 * e2 * e2 * e2 : 1 - Math.pow(-2 * e2 + 2, 3) / 2, easeInQuart: (e2) => e2 * e2 * e2 * e2, easeOutQuart: (e2) => 1 - Math.pow(1 - e2, 4), easeInOutQuart: (e2) => e2 < 0.5 ? 8 * e2 * e2 * e2 * e2 : 1 - Math.pow(-2 * e2 + 2, 4) / 2, easeInQuint: (e2) => e2 * e2 * e2 * e2 * e2, easeOutQuint: (e2) => 1 - Math.pow(1 - e2, 5), easeInOutQuint: (e2) => e2 < 0.5 ? 16 * e2 * e2 * e2 * e2 * e2 : 1 - Math.pow(-2 * e2 + 2, 5) / 2, easeInSine: (e2) => 1 - Math.cos(e2 * Math.PI / 2), easeOutSine: (e2) => Math.sin(e2 * Math.PI / 2), easeInOutSine: (e2) => -(Math.cos(Math.PI * e2) - 1) / 2, easeInExpo: (e2) => e2 === 0 ? 0 : Math.pow(2, 10 * e2 - 10), easeOutExpo: (e2) => e2 === 1 ? 1 : 1 - Math.pow(2, -10 * e2), easeInOutExpo: (e2) => e2 === 0 ? 0 : e2 === 1 ? 1 : e2 < 0.5 ? Math.pow(2, 20 * e2 - 10) / 2 : (2 - Math.pow(2, -20 * e2 + 10)) / 2, easeInCirc: (e2) => 1 - Math.sqrt(1 - Math.pow(e2, 2)), easeOutCirc: (e2) => Math.sqrt(1 - Math.pow(e2 - 1, 2)), easeInOutCirc: (e2) => e2 < 0.5 ? (1 - Math.sqrt(1 - Math.pow(2 * e2, 2))) / 2 : (Math.sqrt(1 - Math.pow(-2 * e2 + 2, 2)) + 1) / 2, easeInBack: (e2) => Re * e2 * e2 * e2 - Q * e2 * e2, easeOutBack: (e2) => 1 + Re * Math.pow(e2 - 1, 3) + Q * Math.pow(e2 - 1, 2), easeInOutBack: (e2) => e2 < 0.5 ? Math.pow(2 * e2, 2) * (($ + 1) * 2 * e2 - $) / 2 : (Math.pow(2 * e2 - 2, 2) * (($ + 1) * (e2 * 2 - 2) + $) + 2) / 2, easeInElastic: (e2) => e2 === 0 ? 0 : e2 === 1 ? 1 : -Math.pow(2, 10 * e2 - 10) * Math.sin((e2 * 10 - 10.75) * Ae), easeOutElastic: (e2) => e2 === 0 ? 0 : e2 === 1 ? 1 : Math.pow(2, -10 * e2) * Math.sin((e2 * 10 - 0.75) * Ae) + 1, easeInOutElastic: (e2) => e2 === 0 ? 0 : e2 === 1 ? 1 : e2 < 0.5 ? -(Math.pow(2, 20 * e2 - 10) * Math.sin((20 * e2 - 11.125) * Me)) / 2 : Math.pow(2, -20 * e2 + 10) * Math.sin((20 * e2 - 11.125) * Me) / 2 + 1, easeInBounce: (e2) => 1 - G(1 - e2), easeOutBounce: G, easeInOutBounce: (e2) => e2 < 0.5 ? (1 - G(1 - 2 * e2)) / 2 : (1 + G(2 * e2 - 1)) / 2, steps: ct };
    var g = Symbol.for("FluidValue.get");
    var b = Symbol.for("FluidValue.observers");
    var pt = (e2) => !!(e2 && e2[g]);
    var ue = (e2) => e2 && e2[g] ? e2[g]() : e2;
    var mt = (e2) => e2[b] || null;
    function Ce(e2, t) {
      e2.eventObserved ? e2.eventObserved(t) : e2(t);
    }
    function bt(e2, t) {
      let r2 = e2[b];
      r2 && r2.forEach((n) => {
        Ce(n, t);
      });
    }
    var se = class {
      constructor(t) {
        if (!t && !(t = this.get)) throw Error("Unknown getter");
        ze(this, t);
      }
    };
    var ze = (e2, t) => Le(e2, g, t);
    function xt(e2, t) {
      if (e2[g]) {
        let r2 = e2[b];
        r2 || Le(e2, b, r2 = /* @__PURE__ */ new Set()), r2.has(t) || (r2.add(t), e2.observerAdded && e2.observerAdded(r2.size, t));
      }
      return t;
    }
    function ht(e2, t) {
      let r2 = e2[b];
      if (r2 && r2.has(t)) {
        let n = r2.size - 1;
        n ? r2.delete(t) : e2[b] = null, e2.observerRemoved && e2.observerRemoved(n, t);
      }
    }
    var Le = (e2, t, r2) => Object.defineProperty(e2, t, { value: r2, writable: true, configurable: true });
    var F = /[+\-]?(?:0|[1-9]\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)?/g;
    var Ve = /(#(?:[0-9a-f]{2}){2,4}|(#[0-9a-f]{3})|(rgb|hsl)a?\((-?\d+%?[,\s]+){2,3}\s*[\d\.]+%?\))/gi;
    var le = new RegExp(`(${F.source})(%|[a-z]+)`, "i");
    var Pe = /rgba\(([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+)\)/gi;
    var x = /var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/;
    var ce = (e2) => {
      let [t, r2] = yt(e2);
      if (!t || m()) return e2;
      let n = window.getComputedStyle(document.documentElement).getPropertyValue(t);
      if (n) return n.trim();
      if (r2 && r2.startsWith("--")) {
        let o = window.getComputedStyle(document.documentElement).getPropertyValue(r2);
        return o || e2;
      } else {
        if (r2 && x.test(r2)) return ce(r2);
        if (r2) return r2;
      }
      return e2;
    };
    var yt = (e2) => {
      let t = x.exec(e2);
      if (!t) return [,];
      let [, r2, n] = t;
      return [r2, n];
    };
    var de;
    var gt = (e2, t, r2, n, o) => `rgba(${Math.round(t)}, ${Math.round(r2)}, ${Math.round(n)}, ${o})`;
    var vt = (e2) => {
      de || (de = c ? new RegExp(`(${Object.keys(c).join("|")})(?!\\w)`, "g") : /^\b$/);
      let t = e2.output.map((f) => ue(f).replace(x, ce).replace(Ve, P).replace(de, P)), r2 = t.map((f) => f.match(F).map(Number)), o = r2[0].map((f, i) => r2.map((s) => {
        if (!(i in s)) throw Error('The arity of each "output" value must be equal');
        return s[i];
      })).map((f) => q({ ...e2, output: f }));
      return (f) => {
        var _a;
        let i = !le.test(t[0]) && ((_a = t.find((h) => le.test(h))) == null ? void 0 : _a.replace(F, "")), s = 0;
        return t[0].replace(F, () => `${o[s++](f)}${i || ""}`).replace(Pe, gt);
      };
    };
    var U = "react-spring: ";
    var pe = (e2) => {
      let t = e2, r2 = false;
      if (typeof t != "function") throw new TypeError(`${U}once requires a function parameter`);
      return (...n) => {
        r2 || (t(...n), r2 = true);
      };
    };
    var Et = pe(console.warn);
    function Ot() {
      Et(`${U}The "interpolate" function is deprecated in v9 (use "to" instead)`);
    }
    var wt = pe(console.warn);
    function Tt() {
      wt(`${U}Directly calling start instead of using the api object is deprecated in v9 (use ".start" instead), this will be removed in later 0.X.0 versions`);
    }
    function Ft(e2) {
      return u.str(e2) && (e2[0] == "#" || /\d/.test(e2) || !m() && x.test(e2) || e2 in (c || {}));
    }
    var xe = require_cjs();
    var v;
    var H = /* @__PURE__ */ new WeakMap();
    var It = (e2) => e2.forEach(({ target: t, contentRect: r2 }) => {
      var _a;
      return (_a = H.get(t)) == null ? void 0 : _a.forEach((n) => n(r2));
    });
    function qe(e2, t) {
      v || typeof ResizeObserver < "u" && (v = new ResizeObserver(It));
      let r2 = H.get(t);
      return r2 || (r2 = /* @__PURE__ */ new Set(), H.set(t, r2)), r2.add(e2), v && v.observe(t), () => {
        let n = H.get(t);
        n && (n.delete(e2), !n.size && v && v.unobserve(t));
      };
    }
    var B = /* @__PURE__ */ new Set();
    var I;
    var kt = () => {
      let e2 = () => {
        B.forEach((t) => t({ width: window.innerWidth, height: window.innerHeight }));
      };
      return window.addEventListener("resize", e2), () => {
        window.removeEventListener("resize", e2);
      };
    };
    var $e = (e2) => (B.add(e2), I || (I = kt()), () => {
      B.delete(e2), !B.size && I && (I(), I = void 0);
    });
    var me = (e2, { container: t = document.documentElement } = {}) => t === document.documentElement ? $e(e2) : qe(e2, t);
    var Ge = (e2, t, r2) => t - e2 === 0 ? 1 : (r2 - e2) / (t - e2);
    var St = { x: { length: "Width", position: "Left" }, y: { length: "Height", position: "Top" } };
    var j = class {
      constructor(t, r2) {
        this.createAxis = () => ({ current: 0, progress: 0, scrollLength: 0 });
        this.updateAxis = (t2) => {
          let r3 = this.info[t2], { length: n, position: o } = St[t2];
          r3.current = this.container[`scroll${o}`], r3.scrollLength = this.container[`scroll${n}`] - this.container[`client${n}`], r3.progress = Ge(0, r3.scrollLength, r3.current);
        };
        this.update = () => {
          this.updateAxis("x"), this.updateAxis("y");
        };
        this.sendEvent = () => {
          this.callback(this.info);
        };
        this.advance = () => {
          this.update(), this.sendEvent();
        };
        this.callback = t, this.container = r2, this.info = { time: 0, x: this.createAxis(), y: this.createAxis() };
      }
    };
    var k = /* @__PURE__ */ new WeakMap();
    var Qe = /* @__PURE__ */ new WeakMap();
    var be = /* @__PURE__ */ new WeakMap();
    var Ue = (e2) => e2 === document.documentElement ? window : e2;
    var Rt = (e2, { container: t = document.documentElement } = {}) => {
      let r2 = be.get(t);
      r2 || (r2 = /* @__PURE__ */ new Set(), be.set(t, r2));
      let n = new j(e2, t);
      if (r2.add(n), !k.has(t)) {
        let f = () => (r2 == null ? void 0 : r2.forEach((s) => s.advance()), true);
        k.set(t, f);
        let i = Ue(t);
        window.addEventListener("resize", f, { passive: true }), t !== document.documentElement && Qe.set(t, me(f, { container: t })), i.addEventListener("scroll", f, { passive: true });
      }
      let o = k.get(t);
      return (0, xe.raf)(o), () => {
        var _a;
        xe.raf.cancel(o);
        let f = be.get(t);
        if (!f || (f.delete(n), f.size)) return;
        let i = k.get(t);
        k.delete(t), i && (Ue(t).removeEventListener("scroll", i), window.removeEventListener("resize", i), (_a = Qe.get(t)) == null ? void 0 : _a());
      };
    };
    var He = require_react();
    function At(e2) {
      let t = (0, He.useRef)(null);
      return t.current === null && (t.current = e2()), t.current;
    }
    var De = require_react();
    var Be = require_react();
    var D = require_react();
    var S = m() ? D.useEffect : D.useLayoutEffect;
    var je = () => {
      let e2 = (0, Be.useRef)(false);
      return S(() => (e2.current = true, () => {
        e2.current = false;
      }), []), e2;
    };
    function Mt() {
      let e2 = (0, De.useState)()[1], t = je();
      return () => {
        t.current && e2(Math.random());
      };
    }
    var E = require_react();
    function Ct(e2, t) {
      let [r2] = (0, E.useState)(() => ({ inputs: t, result: e2() })), n = (0, E.useRef)(), o = n.current, f = o;
      return f ? t && f.inputs && zt(t, f.inputs) || (f = { inputs: t, result: e2() }) : f = r2, (0, E.useEffect)(() => {
        n.current = f, o == r2 && (r2.inputs = r2.result = void 0);
      }, [f]), f.result;
    }
    function zt(e2, t) {
      if (e2.length !== t.length) return false;
      for (let r2 = 0; r2 < e2.length; r2++) if (e2[r2] !== t[r2]) return false;
      return true;
    }
    var We = require_react();
    var Lt = (e2) => (0, We.useEffect)(e2, Vt);
    var Vt = [];
    var W = require_react();
    function Pt(e2) {
      let t = (0, W.useRef)();
      return (0, W.useEffect)(() => {
        t.current = e2;
      }), t.current;
    }
    var Ke = require_react();
    var qt = () => {
      let [e2, t] = (0, Ke.useState)(null);
      return S(() => {
        let r2 = window.matchMedia("(prefers-reduced-motion)"), n = (o) => {
          t(o.matches), _({ skipAnimation: o.matches });
        };
        return n(r2), r2.addEventListener ? r2.addEventListener("change", n) : r2.addListener(n), () => {
          r2.removeEventListener ? r2.removeEventListener("change", n) : r2.removeListener(n);
        };
      }, []), e2;
    };
    var Ne = require_cjs();
  }
});

// node_modules/@react-spring/shared/dist/cjs/react-spring_shared.development.cjs
var require_react_spring_shared_development = __commonJS({
  "node_modules/@react-spring/shared/dist/cjs/react-spring_shared.development.cjs"(exports, module) {
    "use strict";
    var import_dist10 = __toESM(require_dist());
    var import_dist11 = __toESM(require_dist2());
    var import_dist12 = __toESM(require_dist3());
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to2, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to2, key) && key !== except)
            __defProp(to2, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to2;
    };
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export2(src_exports, {
      FluidValue: () => FluidValue,
      Globals: () => globals_exports,
      addFluidObserver: () => addFluidObserver,
      callFluidObserver: () => callFluidObserver,
      callFluidObservers: () => callFluidObservers,
      clamp: () => clamp,
      colorToRgba: () => colorToRgba,
      colors: () => colors2,
      createInterpolator: () => createInterpolator,
      createStringInterpolator: () => createStringInterpolator2,
      defineHidden: () => defineHidden,
      deprecateDirectCall: () => deprecateDirectCall,
      deprecateInterpolate: () => deprecateInterpolate,
      each: () => each,
      eachProp: () => eachProp,
      easings: () => easings,
      flush: () => flush,
      flushCalls: () => flushCalls,
      frameLoop: () => frameLoop,
      getFluidObservers: () => getFluidObservers,
      getFluidValue: () => getFluidValue,
      hasFluidValue: () => hasFluidValue,
      hex3: () => hex3,
      hex4: () => hex4,
      hex6: () => hex6,
      hex8: () => hex8,
      hsl: () => hsl,
      hsla: () => hsla,
      is: () => is,
      isAnimatedString: () => isAnimatedString,
      isEqual: () => isEqual,
      isSSR: () => isSSR,
      noop: () => noop,
      onResize: () => onResize,
      onScroll: () => onScroll,
      once: () => once,
      prefix: () => prefix,
      raf: () => import_rafz4.raf,
      removeFluidObserver: () => removeFluidObserver,
      rgb: () => rgb,
      rgba: () => rgba,
      setFluidGetter: () => setFluidGetter,
      toArray: () => toArray,
      useConstant: () => useConstant,
      useForceUpdate: () => useForceUpdate,
      useIsomorphicLayoutEffect: () => useIsomorphicLayoutEffect,
      useMemoOne: () => useMemoOne,
      useOnce: () => useOnce,
      usePrev: () => usePrev,
      useReducedMotion: () => useReducedMotion
    });
    module.exports = __toCommonJS2(src_exports);
    var globals_exports = {};
    __export2(globals_exports, {
      assign: () => assign,
      colors: () => colors,
      createStringInterpolator: () => createStringInterpolator,
      skipAnimation: () => skipAnimation,
      to: () => to,
      willAdvance: () => willAdvance
    });
    var import_rafz = require_cjs();
    function noop() {
    }
    var defineHidden = (obj, key, value) => Object.defineProperty(obj, key, { value, writable: true, configurable: true });
    var is = {
      arr: Array.isArray,
      obj: (a) => !!a && a.constructor.name === "Object",
      fun: (a) => typeof a === "function",
      str: (a) => typeof a === "string",
      num: (a) => typeof a === "number",
      und: (a) => a === void 0
    };
    function isEqual(a, b) {
      if (is.arr(a)) {
        if (!is.arr(b) || a.length !== b.length)
          return false;
        for (let i = 0; i < a.length; i++) {
          if (a[i] !== b[i])
            return false;
        }
        return true;
      }
      return a === b;
    }
    var each = (obj, fn) => obj.forEach(fn);
    function eachProp(obj, fn, ctx) {
      if (is.arr(obj)) {
        for (let i = 0; i < obj.length; i++) {
          fn.call(ctx, obj[i], `${i}`);
        }
        return;
      }
      for (const key in obj) {
        if (obj.hasOwnProperty(key)) {
          fn.call(ctx, obj[key], key);
        }
      }
    }
    var toArray = (a) => is.und(a) ? [] : is.arr(a) ? a : [a];
    function flush(queue, iterator) {
      if (queue.size) {
        const items = Array.from(queue);
        queue.clear();
        each(items, iterator);
      }
    }
    var flushCalls = (queue, ...args) => flush(queue, (fn) => fn(...args));
    var isSSR = () => typeof window === "undefined" || !window.navigator || /ServerSideRendering|^Deno\//.test(window.navigator.userAgent);
    var createStringInterpolator;
    var to;
    var colors = null;
    var skipAnimation = false;
    var willAdvance = noop;
    var assign = (globals) => {
      if (globals.to)
        to = globals.to;
      if (globals.now)
        import_rafz.raf.now = globals.now;
      if (globals.colors !== void 0)
        colors = globals.colors;
      if (globals.skipAnimation != null)
        skipAnimation = globals.skipAnimation;
      if (globals.createStringInterpolator)
        createStringInterpolator = globals.createStringInterpolator;
      if (globals.requestAnimationFrame)
        import_rafz.raf.use(globals.requestAnimationFrame);
      if (globals.batchedUpdates)
        import_rafz.raf.batchedUpdates = globals.batchedUpdates;
      if (globals.willAdvance)
        willAdvance = globals.willAdvance;
      if (globals.frameLoop)
        import_rafz.raf.frameLoop = globals.frameLoop;
    };
    var import_rafz2 = require_cjs();
    var startQueue = /* @__PURE__ */ new Set();
    var currentFrame = [];
    var prevFrame = [];
    var priority = 0;
    var frameLoop = {
      get idle() {
        return !startQueue.size && !currentFrame.length;
      },
      /** Advance the given animation on every frame until idle. */
      start(animation) {
        if (priority > animation.priority) {
          startQueue.add(animation);
          import_rafz2.raf.onStart(flushStartQueue);
        } else {
          startSafely(animation);
          (0, import_rafz2.raf)(advance);
        }
      },
      /** Advance all animations by the given time. */
      advance,
      /** Call this when an animation's priority changes. */
      sort(animation) {
        if (priority) {
          import_rafz2.raf.onFrame(() => frameLoop.sort(animation));
        } else {
          const prevIndex = currentFrame.indexOf(animation);
          if (~prevIndex) {
            currentFrame.splice(prevIndex, 1);
            startUnsafely(animation);
          }
        }
      },
      /**
       * Clear all animations. For testing purposes.
       *
       *  Never call this from within the frameloop.
       */
      clear() {
        currentFrame = [];
        startQueue.clear();
      }
    };
    function flushStartQueue() {
      startQueue.forEach(startSafely);
      startQueue.clear();
      (0, import_rafz2.raf)(advance);
    }
    function startSafely(animation) {
      if (!currentFrame.includes(animation))
        startUnsafely(animation);
    }
    function startUnsafely(animation) {
      currentFrame.splice(
        findIndex(currentFrame, (other) => other.priority > animation.priority),
        0,
        animation
      );
    }
    function advance(dt) {
      const nextFrame = prevFrame;
      for (let i = 0; i < currentFrame.length; i++) {
        const animation = currentFrame[i];
        priority = animation.priority;
        if (!animation.idle) {
          willAdvance(animation);
          animation.advance(dt);
          if (!animation.idle) {
            nextFrame.push(animation);
          }
        }
      }
      priority = 0;
      prevFrame = currentFrame;
      prevFrame.length = 0;
      currentFrame = nextFrame;
      return currentFrame.length > 0;
    }
    function findIndex(arr, test) {
      const index = arr.findIndex(test);
      return index < 0 ? arr.length : index;
    }
    var clamp = (min, max, v) => Math.min(Math.max(v, min), max);
    var colors2 = {
      transparent: 0,
      aliceblue: 4042850303,
      antiquewhite: 4209760255,
      aqua: 16777215,
      aquamarine: 2147472639,
      azure: 4043309055,
      beige: 4126530815,
      bisque: 4293182719,
      black: 255,
      blanchedalmond: 4293643775,
      blue: 65535,
      blueviolet: 2318131967,
      brown: 2771004159,
      burlywood: 3736635391,
      burntsienna: 3934150143,
      cadetblue: 1604231423,
      chartreuse: 2147418367,
      chocolate: 3530104575,
      coral: 4286533887,
      cornflowerblue: 1687547391,
      cornsilk: 4294499583,
      crimson: 3692313855,
      cyan: 16777215,
      darkblue: 35839,
      darkcyan: 9145343,
      darkgoldenrod: 3095792639,
      darkgray: 2846468607,
      darkgreen: 6553855,
      darkgrey: 2846468607,
      darkkhaki: 3182914559,
      darkmagenta: 2332068863,
      darkolivegreen: 1433087999,
      darkorange: 4287365375,
      darkorchid: 2570243327,
      darkred: 2332033279,
      darksalmon: 3918953215,
      darkseagreen: 2411499519,
      darkslateblue: 1211993087,
      darkslategray: 793726975,
      darkslategrey: 793726975,
      darkturquoise: 13554175,
      darkviolet: 2483082239,
      deeppink: 4279538687,
      deepskyblue: 12582911,
      dimgray: 1768516095,
      dimgrey: 1768516095,
      dodgerblue: 512819199,
      firebrick: 2988581631,
      floralwhite: 4294635775,
      forestgreen: 579543807,
      fuchsia: 4278255615,
      gainsboro: 3705462015,
      ghostwhite: 4177068031,
      gold: 4292280575,
      goldenrod: 3668254975,
      gray: 2155905279,
      green: 8388863,
      greenyellow: 2919182335,
      grey: 2155905279,
      honeydew: 4043305215,
      hotpink: 4285117695,
      indianred: 3445382399,
      indigo: 1258324735,
      ivory: 4294963455,
      khaki: 4041641215,
      lavender: 3873897215,
      lavenderblush: 4293981695,
      lawngreen: 2096890111,
      lemonchiffon: 4294626815,
      lightblue: 2916673279,
      lightcoral: 4034953471,
      lightcyan: 3774873599,
      lightgoldenrodyellow: 4210742015,
      lightgray: 3553874943,
      lightgreen: 2431553791,
      lightgrey: 3553874943,
      lightpink: 4290167295,
      lightsalmon: 4288707327,
      lightseagreen: 548580095,
      lightskyblue: 2278488831,
      lightslategray: 2005441023,
      lightslategrey: 2005441023,
      lightsteelblue: 2965692159,
      lightyellow: 4294959359,
      lime: 16711935,
      limegreen: 852308735,
      linen: 4210091775,
      magenta: 4278255615,
      maroon: 2147483903,
      mediumaquamarine: 1724754687,
      mediumblue: 52735,
      mediumorchid: 3126187007,
      mediumpurple: 2473647103,
      mediumseagreen: 1018393087,
      mediumslateblue: 2070474495,
      mediumspringgreen: 16423679,
      mediumturquoise: 1221709055,
      mediumvioletred: 3340076543,
      midnightblue: 421097727,
      mintcream: 4127193855,
      mistyrose: 4293190143,
      moccasin: 4293178879,
      navajowhite: 4292783615,
      navy: 33023,
      oldlace: 4260751103,
      olive: 2155872511,
      olivedrab: 1804477439,
      orange: 4289003775,
      orangered: 4282712319,
      orchid: 3664828159,
      palegoldenrod: 4008225535,
      palegreen: 2566625535,
      paleturquoise: 2951671551,
      palevioletred: 3681588223,
      papayawhip: 4293907967,
      peachpuff: 4292524543,
      peru: 3448061951,
      pink: 4290825215,
      plum: 3718307327,
      powderblue: 2967529215,
      purple: 2147516671,
      rebeccapurple: 1714657791,
      red: 4278190335,
      rosybrown: 3163525119,
      royalblue: 1097458175,
      saddlebrown: 2336560127,
      salmon: 4202722047,
      sandybrown: 4104413439,
      seagreen: 780883967,
      seashell: 4294307583,
      sienna: 2689740287,
      silver: 3233857791,
      skyblue: 2278484991,
      slateblue: 1784335871,
      slategray: 1887473919,
      slategrey: 1887473919,
      snow: 4294638335,
      springgreen: 16744447,
      steelblue: 1182971135,
      tan: 3535047935,
      teal: 8421631,
      thistle: 3636451583,
      tomato: 4284696575,
      turquoise: 1088475391,
      violet: 4001558271,
      wheat: 4125012991,
      white: 4294967295,
      whitesmoke: 4126537215,
      yellow: 4294902015,
      yellowgreen: 2597139199
    };
    var NUMBER = "[-+]?\\d*\\.?\\d+";
    var PERCENTAGE = NUMBER + "%";
    function call(...parts) {
      return "\\(\\s*(" + parts.join(")\\s*,\\s*(") + ")\\s*\\)";
    }
    var rgb = new RegExp("rgb" + call(NUMBER, NUMBER, NUMBER));
    var rgba = new RegExp("rgba" + call(NUMBER, NUMBER, NUMBER, NUMBER));
    var hsl = new RegExp("hsl" + call(NUMBER, PERCENTAGE, PERCENTAGE));
    var hsla = new RegExp(
      "hsla" + call(NUMBER, PERCENTAGE, PERCENTAGE, NUMBER)
    );
    var hex3 = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;
    var hex4 = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;
    var hex6 = /^#([0-9a-fA-F]{6})$/;
    var hex8 = /^#([0-9a-fA-F]{8})$/;
    function normalizeColor(color) {
      let match;
      if (typeof color === "number") {
        return color >>> 0 === color && color >= 0 && color <= 4294967295 ? color : null;
      }
      if (match = hex6.exec(color))
        return parseInt(match[1] + "ff", 16) >>> 0;
      if (colors && colors[color] !== void 0) {
        return colors[color];
      }
      if (match = rgb.exec(color)) {
        return (parse255(match[1]) << 24 | // r
        parse255(match[2]) << 16 | // g
        parse255(match[3]) << 8 | // b
        255) >>> // a
        0;
      }
      if (match = rgba.exec(color)) {
        return (parse255(match[1]) << 24 | // r
        parse255(match[2]) << 16 | // g
        parse255(match[3]) << 8 | // b
        parse1(match[4])) >>> // a
        0;
      }
      if (match = hex3.exec(color)) {
        return parseInt(
          match[1] + match[1] + // r
          match[2] + match[2] + // g
          match[3] + match[3] + // b
          "ff",
          // a
          16
        ) >>> 0;
      }
      if (match = hex8.exec(color))
        return parseInt(match[1], 16) >>> 0;
      if (match = hex4.exec(color)) {
        return parseInt(
          match[1] + match[1] + // r
          match[2] + match[2] + // g
          match[3] + match[3] + // b
          match[4] + match[4],
          // a
          16
        ) >>> 0;
      }
      if (match = hsl.exec(color)) {
        return (hslToRgb(
          parse360(match[1]),
          // h
          parsePercentage(match[2]),
          // s
          parsePercentage(match[3])
          // l
        ) | 255) >>> // a
        0;
      }
      if (match = hsla.exec(color)) {
        return (hslToRgb(
          parse360(match[1]),
          // h
          parsePercentage(match[2]),
          // s
          parsePercentage(match[3])
          // l
        ) | parse1(match[4])) >>> // a
        0;
      }
      return null;
    }
    function hue2rgb(p, q, t) {
      if (t < 0)
        t += 1;
      if (t > 1)
        t -= 1;
      if (t < 1 / 6)
        return p + (q - p) * 6 * t;
      if (t < 1 / 2)
        return q;
      if (t < 2 / 3)
        return p + (q - p) * (2 / 3 - t) * 6;
      return p;
    }
    function hslToRgb(h, s, l) {
      const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
      const p = 2 * l - q;
      const r2 = hue2rgb(p, q, h + 1 / 3);
      const g = hue2rgb(p, q, h);
      const b = hue2rgb(p, q, h - 1 / 3);
      return Math.round(r2 * 255) << 24 | Math.round(g * 255) << 16 | Math.round(b * 255) << 8;
    }
    function parse255(str) {
      const int = parseInt(str, 10);
      if (int < 0)
        return 0;
      if (int > 255)
        return 255;
      return int;
    }
    function parse360(str) {
      const int = parseFloat(str);
      return (int % 360 + 360) % 360 / 360;
    }
    function parse1(str) {
      const num = parseFloat(str);
      if (num < 0)
        return 0;
      if (num > 1)
        return 255;
      return Math.round(num * 255);
    }
    function parsePercentage(str) {
      const int = parseFloat(str);
      if (int < 0)
        return 0;
      if (int > 100)
        return 1;
      return int / 100;
    }
    function colorToRgba(input) {
      let int32Color = normalizeColor(input);
      if (int32Color === null)
        return input;
      int32Color = int32Color || 0;
      const r2 = (int32Color & 4278190080) >>> 24;
      const g = (int32Color & 16711680) >>> 16;
      const b = (int32Color & 65280) >>> 8;
      const a = (int32Color & 255) / 255;
      return `rgba(${r2}, ${g}, ${b}, ${a})`;
    }
    var createInterpolator = (range, output, extrapolate) => {
      if (is.fun(range)) {
        return range;
      }
      if (is.arr(range)) {
        return createInterpolator({
          range,
          output,
          extrapolate
        });
      }
      if (is.str(range.output[0])) {
        return createStringInterpolator(range);
      }
      const config = range;
      const outputRange = config.output;
      const inputRange = config.range || [0, 1];
      const extrapolateLeft = config.extrapolateLeft || config.extrapolate || "extend";
      const extrapolateRight = config.extrapolateRight || config.extrapolate || "extend";
      const easing = config.easing || ((t) => t);
      return (input) => {
        const range2 = findRange(input, inputRange);
        return interpolate(
          input,
          inputRange[range2],
          inputRange[range2 + 1],
          outputRange[range2],
          outputRange[range2 + 1],
          easing,
          extrapolateLeft,
          extrapolateRight,
          config.map
        );
      };
    };
    function interpolate(input, inputMin, inputMax, outputMin, outputMax, easing, extrapolateLeft, extrapolateRight, map) {
      let result = map ? map(input) : input;
      if (result < inputMin) {
        if (extrapolateLeft === "identity")
          return result;
        else if (extrapolateLeft === "clamp")
          result = inputMin;
      }
      if (result > inputMax) {
        if (extrapolateRight === "identity")
          return result;
        else if (extrapolateRight === "clamp")
          result = inputMax;
      }
      if (outputMin === outputMax)
        return outputMin;
      if (inputMin === inputMax)
        return input <= inputMin ? outputMin : outputMax;
      if (inputMin === -Infinity)
        result = -result;
      else if (inputMax === Infinity)
        result = result - inputMin;
      else
        result = (result - inputMin) / (inputMax - inputMin);
      result = easing(result);
      if (outputMin === -Infinity)
        result = -result;
      else if (outputMax === Infinity)
        result = result + outputMin;
      else
        result = result * (outputMax - outputMin) + outputMin;
      return result;
    }
    function findRange(input, inputRange) {
      for (var i = 1; i < inputRange.length - 1; ++i)
        if (inputRange[i] >= input)
          break;
      return i - 1;
    }
    var steps = (steps2, direction = "end") => (progress2) => {
      progress2 = direction === "end" ? Math.min(progress2, 0.999) : Math.max(progress2, 1e-3);
      const expanded = progress2 * steps2;
      const rounded = direction === "end" ? Math.floor(expanded) : Math.ceil(expanded);
      return clamp(0, 1, rounded / steps2);
    };
    var c1 = 1.70158;
    var c2 = c1 * 1.525;
    var c3 = c1 + 1;
    var c4 = 2 * Math.PI / 3;
    var c5 = 2 * Math.PI / 4.5;
    var bounceOut = (x) => {
      const n1 = 7.5625;
      const d1 = 2.75;
      if (x < 1 / d1) {
        return n1 * x * x;
      } else if (x < 2 / d1) {
        return n1 * (x -= 1.5 / d1) * x + 0.75;
      } else if (x < 2.5 / d1) {
        return n1 * (x -= 2.25 / d1) * x + 0.9375;
      } else {
        return n1 * (x -= 2.625 / d1) * x + 0.984375;
      }
    };
    var easings = {
      linear: (x) => x,
      easeInQuad: (x) => x * x,
      easeOutQuad: (x) => 1 - (1 - x) * (1 - x),
      easeInOutQuad: (x) => x < 0.5 ? 2 * x * x : 1 - Math.pow(-2 * x + 2, 2) / 2,
      easeInCubic: (x) => x * x * x,
      easeOutCubic: (x) => 1 - Math.pow(1 - x, 3),
      easeInOutCubic: (x) => x < 0.5 ? 4 * x * x * x : 1 - Math.pow(-2 * x + 2, 3) / 2,
      easeInQuart: (x) => x * x * x * x,
      easeOutQuart: (x) => 1 - Math.pow(1 - x, 4),
      easeInOutQuart: (x) => x < 0.5 ? 8 * x * x * x * x : 1 - Math.pow(-2 * x + 2, 4) / 2,
      easeInQuint: (x) => x * x * x * x * x,
      easeOutQuint: (x) => 1 - Math.pow(1 - x, 5),
      easeInOutQuint: (x) => x < 0.5 ? 16 * x * x * x * x * x : 1 - Math.pow(-2 * x + 2, 5) / 2,
      easeInSine: (x) => 1 - Math.cos(x * Math.PI / 2),
      easeOutSine: (x) => Math.sin(x * Math.PI / 2),
      easeInOutSine: (x) => -(Math.cos(Math.PI * x) - 1) / 2,
      easeInExpo: (x) => x === 0 ? 0 : Math.pow(2, 10 * x - 10),
      easeOutExpo: (x) => x === 1 ? 1 : 1 - Math.pow(2, -10 * x),
      easeInOutExpo: (x) => x === 0 ? 0 : x === 1 ? 1 : x < 0.5 ? Math.pow(2, 20 * x - 10) / 2 : (2 - Math.pow(2, -20 * x + 10)) / 2,
      easeInCirc: (x) => 1 - Math.sqrt(1 - Math.pow(x, 2)),
      easeOutCirc: (x) => Math.sqrt(1 - Math.pow(x - 1, 2)),
      easeInOutCirc: (x) => x < 0.5 ? (1 - Math.sqrt(1 - Math.pow(2 * x, 2))) / 2 : (Math.sqrt(1 - Math.pow(-2 * x + 2, 2)) + 1) / 2,
      easeInBack: (x) => c3 * x * x * x - c1 * x * x,
      easeOutBack: (x) => 1 + c3 * Math.pow(x - 1, 3) + c1 * Math.pow(x - 1, 2),
      easeInOutBack: (x) => x < 0.5 ? Math.pow(2 * x, 2) * ((c2 + 1) * 2 * x - c2) / 2 : (Math.pow(2 * x - 2, 2) * ((c2 + 1) * (x * 2 - 2) + c2) + 2) / 2,
      easeInElastic: (x) => x === 0 ? 0 : x === 1 ? 1 : -Math.pow(2, 10 * x - 10) * Math.sin((x * 10 - 10.75) * c4),
      easeOutElastic: (x) => x === 0 ? 0 : x === 1 ? 1 : Math.pow(2, -10 * x) * Math.sin((x * 10 - 0.75) * c4) + 1,
      easeInOutElastic: (x) => x === 0 ? 0 : x === 1 ? 1 : x < 0.5 ? -(Math.pow(2, 20 * x - 10) * Math.sin((20 * x - 11.125) * c5)) / 2 : Math.pow(2, -20 * x + 10) * Math.sin((20 * x - 11.125) * c5) / 2 + 1,
      easeInBounce: (x) => 1 - bounceOut(1 - x),
      easeOutBounce: bounceOut,
      easeInOutBounce: (x) => x < 0.5 ? (1 - bounceOut(1 - 2 * x)) / 2 : (1 + bounceOut(2 * x - 1)) / 2,
      steps
    };
    var $get = Symbol.for("FluidValue.get");
    var $observers = Symbol.for("FluidValue.observers");
    var hasFluidValue = (arg) => Boolean(arg && arg[$get]);
    var getFluidValue = (arg) => arg && arg[$get] ? arg[$get]() : arg;
    var getFluidObservers = (target) => target[$observers] || null;
    function callFluidObserver(observer2, event) {
      if (observer2.eventObserved) {
        observer2.eventObserved(event);
      } else {
        observer2(event);
      }
    }
    function callFluidObservers(target, event) {
      const observers = target[$observers];
      if (observers) {
        observers.forEach((observer2) => {
          callFluidObserver(observer2, event);
        });
      }
    }
    var FluidValue = class {
      constructor(get) {
        if (!get && !(get = this.get)) {
          throw Error("Unknown getter");
        }
        setFluidGetter(this, get);
      }
    };
    var setFluidGetter = (target, get) => setHidden(target, $get, get);
    function addFluidObserver(target, observer2) {
      if (target[$get]) {
        let observers = target[$observers];
        if (!observers) {
          setHidden(target, $observers, observers = /* @__PURE__ */ new Set());
        }
        if (!observers.has(observer2)) {
          observers.add(observer2);
          if (target.observerAdded) {
            target.observerAdded(observers.size, observer2);
          }
        }
      }
      return observer2;
    }
    function removeFluidObserver(target, observer2) {
      const observers = target[$observers];
      if (observers && observers.has(observer2)) {
        const count = observers.size - 1;
        if (count) {
          observers.delete(observer2);
        } else {
          target[$observers] = null;
        }
        if (target.observerRemoved) {
          target.observerRemoved(count, observer2);
        }
      }
    }
    var setHidden = (target, key, value) => Object.defineProperty(target, key, {
      value,
      writable: true,
      configurable: true
    });
    var numberRegex = /[+\-]?(?:0|[1-9]\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)?/g;
    var colorRegex = /(#(?:[0-9a-f]{2}){2,4}|(#[0-9a-f]{3})|(rgb|hsl)a?\((-?\d+%?[,\s]+){2,3}\s*[\d\.]+%?\))/gi;
    var unitRegex = new RegExp(`(${numberRegex.source})(%|[a-z]+)`, "i");
    var rgbaRegex = /rgba\(([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+)\)/gi;
    var cssVariableRegex = /var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/;
    var variableToRgba = (input) => {
      const [token, fallback] = parseCSSVariable(input);
      if (!token || isSSR()) {
        return input;
      }
      const value = window.getComputedStyle(document.documentElement).getPropertyValue(token);
      if (value) {
        return value.trim();
      } else if (fallback && fallback.startsWith("--")) {
        const value2 = window.getComputedStyle(document.documentElement).getPropertyValue(fallback);
        if (value2) {
          return value2;
        } else {
          return input;
        }
      } else if (fallback && cssVariableRegex.test(fallback)) {
        return variableToRgba(fallback);
      } else if (fallback) {
        return fallback;
      }
      return input;
    };
    var parseCSSVariable = (current) => {
      const match = cssVariableRegex.exec(current);
      if (!match)
        return [,];
      const [, token, fallback] = match;
      return [token, fallback];
    };
    var namedColorRegex;
    var rgbaRound = (_, p1, p2, p3, p4) => `rgba(${Math.round(p1)}, ${Math.round(p2)}, ${Math.round(p3)}, ${p4})`;
    var createStringInterpolator2 = (config) => {
      if (!namedColorRegex)
        namedColorRegex = colors ? (
          // match color names, ignore partial matches
          new RegExp(`(${Object.keys(colors).join("|")})(?!\\w)`, "g")
        ) : (
          // never match
          /^\b$/
        );
      const output = config.output.map((value) => {
        return getFluidValue(value).replace(cssVariableRegex, variableToRgba).replace(colorRegex, colorToRgba).replace(namedColorRegex, colorToRgba);
      });
      const keyframes = output.map((value) => value.match(numberRegex).map(Number));
      const outputRanges = keyframes[0].map(
        (_, i) => keyframes.map((values) => {
          if (!(i in values)) {
            throw Error('The arity of each "output" value must be equal');
          }
          return values[i];
        })
      );
      const interpolators = outputRanges.map(
        (output2) => createInterpolator({ ...config, output: output2 })
      );
      return (input) => {
        var _a;
        const missingUnit = !unitRegex.test(output[0]) && ((_a = output.find((value) => unitRegex.test(value))) == null ? void 0 : _a.replace(numberRegex, ""));
        let i = 0;
        return output[0].replace(
          numberRegex,
          () => `${interpolators[i++](input)}${missingUnit || ""}`
        ).replace(rgbaRegex, rgbaRound);
      };
    };
    var prefix = "react-spring: ";
    var once = (fn) => {
      const func = fn;
      let called = false;
      if (typeof func != "function") {
        throw new TypeError(`${prefix}once requires a function parameter`);
      }
      return (...args) => {
        if (!called) {
          func(...args);
          called = true;
        }
      };
    };
    var warnInterpolate = once(console.warn);
    function deprecateInterpolate() {
      warnInterpolate(
        `${prefix}The "interpolate" function is deprecated in v9 (use "to" instead)`
      );
    }
    var warnDirectCall = once(console.warn);
    function deprecateDirectCall() {
      warnDirectCall(
        `${prefix}Directly calling start instead of using the api object is deprecated in v9 (use ".start" instead), this will be removed in later 0.X.0 versions`
      );
    }
    function isAnimatedString(value) {
      return is.str(value) && (value[0] == "#" || /\d/.test(value) || // Do not identify a CSS variable as an AnimatedString if its SSR
      !isSSR() && cssVariableRegex.test(value) || value in (colors || {}));
    }
    var import_rafz3 = require_cjs();
    var observer;
    var resizeHandlers = /* @__PURE__ */ new WeakMap();
    var handleObservation = (entries) => entries.forEach(({ target, contentRect }) => {
      var _a;
      return (_a = resizeHandlers.get(target)) == null ? void 0 : _a.forEach((handler) => handler(contentRect));
    });
    function resizeElement(handler, target) {
      if (!observer) {
        if (typeof ResizeObserver !== "undefined") {
          observer = new ResizeObserver(handleObservation);
        }
      }
      let elementHandlers = resizeHandlers.get(target);
      if (!elementHandlers) {
        elementHandlers = /* @__PURE__ */ new Set();
        resizeHandlers.set(target, elementHandlers);
      }
      elementHandlers.add(handler);
      if (observer) {
        observer.observe(target);
      }
      return () => {
        const elementHandlers2 = resizeHandlers.get(target);
        if (!elementHandlers2)
          return;
        elementHandlers2.delete(handler);
        if (!elementHandlers2.size && observer) {
          observer.unobserve(target);
        }
      };
    }
    var listeners = /* @__PURE__ */ new Set();
    var cleanupWindowResizeHandler;
    var createResizeHandler = () => {
      const handleResize = () => {
        listeners.forEach(
          (callback) => callback({
            width: window.innerWidth,
            height: window.innerHeight
          })
        );
      };
      window.addEventListener("resize", handleResize);
      return () => {
        window.removeEventListener("resize", handleResize);
      };
    };
    var resizeWindow = (callback) => {
      listeners.add(callback);
      if (!cleanupWindowResizeHandler) {
        cleanupWindowResizeHandler = createResizeHandler();
      }
      return () => {
        listeners.delete(callback);
        if (!listeners.size && cleanupWindowResizeHandler) {
          cleanupWindowResizeHandler();
          cleanupWindowResizeHandler = void 0;
        }
      };
    };
    var onResize = (callback, { container = document.documentElement } = {}) => {
      if (container === document.documentElement) {
        return resizeWindow(callback);
      } else {
        return resizeElement(callback, container);
      }
    };
    var progress = (min, max, value) => max - min === 0 ? 1 : (value - min) / (max - min);
    var SCROLL_KEYS = {
      x: {
        length: "Width",
        position: "Left"
      },
      y: {
        length: "Height",
        position: "Top"
      }
    };
    var ScrollHandler = class {
      constructor(callback, container) {
        this.createAxis = () => ({
          current: 0,
          progress: 0,
          scrollLength: 0
        });
        this.updateAxis = (axisName) => {
          const axis = this.info[axisName];
          const { length, position } = SCROLL_KEYS[axisName];
          axis.current = this.container[`scroll${position}`];
          axis.scrollLength = this.container[`scroll${length}`] - this.container[`client${length}`];
          axis.progress = progress(0, axis.scrollLength, axis.current);
        };
        this.update = () => {
          this.updateAxis("x");
          this.updateAxis("y");
        };
        this.sendEvent = () => {
          this.callback(this.info);
        };
        this.advance = () => {
          this.update();
          this.sendEvent();
        };
        this.callback = callback;
        this.container = container;
        this.info = {
          time: 0,
          x: this.createAxis(),
          y: this.createAxis()
        };
      }
    };
    var scrollListeners = /* @__PURE__ */ new WeakMap();
    var resizeListeners = /* @__PURE__ */ new WeakMap();
    var onScrollHandlers = /* @__PURE__ */ new WeakMap();
    var getTarget = (container) => container === document.documentElement ? window : container;
    var onScroll = (callback, { container = document.documentElement } = {}) => {
      let containerHandlers = onScrollHandlers.get(container);
      if (!containerHandlers) {
        containerHandlers = /* @__PURE__ */ new Set();
        onScrollHandlers.set(container, containerHandlers);
      }
      const containerHandler = new ScrollHandler(callback, container);
      containerHandlers.add(containerHandler);
      if (!scrollListeners.has(container)) {
        const listener = () => {
          containerHandlers == null ? void 0 : containerHandlers.forEach((handler) => handler.advance());
          return true;
        };
        scrollListeners.set(container, listener);
        const target = getTarget(container);
        window.addEventListener("resize", listener, { passive: true });
        if (container !== document.documentElement) {
          resizeListeners.set(container, onResize(listener, { container }));
        }
        target.addEventListener("scroll", listener, { passive: true });
      }
      const animateScroll = scrollListeners.get(container);
      (0, import_rafz3.raf)(animateScroll);
      return () => {
        var _a;
        import_rafz3.raf.cancel(animateScroll);
        const containerHandlers2 = onScrollHandlers.get(container);
        if (!containerHandlers2)
          return;
        containerHandlers2.delete(containerHandler);
        if (containerHandlers2.size)
          return;
        const listener = scrollListeners.get(container);
        scrollListeners.delete(container);
        if (listener) {
          getTarget(container).removeEventListener("scroll", listener);
          window.removeEventListener("resize", listener);
          (_a = resizeListeners.get(container)) == null ? void 0 : _a();
        }
      };
    };
    var import_react3 = require_react();
    function useConstant(init) {
      const ref = (0, import_react3.useRef)(null);
      if (ref.current === null) {
        ref.current = init();
      }
      return ref.current;
    }
    var import_react4 = require_react();
    var import_react32 = require_react();
    var import_react22 = require_react();
    var useIsomorphicLayoutEffect = isSSR() ? import_react22.useEffect : import_react22.useLayoutEffect;
    var useIsMounted = () => {
      const isMounted = (0, import_react32.useRef)(false);
      useIsomorphicLayoutEffect(() => {
        isMounted.current = true;
        return () => {
          isMounted.current = false;
        };
      }, []);
      return isMounted;
    };
    function useForceUpdate() {
      const update = (0, import_react4.useState)()[1];
      const isMounted = useIsMounted();
      return () => {
        if (isMounted.current) {
          update(Math.random());
        }
      };
    }
    var import_react5 = require_react();
    function useMemoOne(getResult, inputs) {
      const [initial] = (0, import_react5.useState)(
        () => ({
          inputs,
          result: getResult()
        })
      );
      const committed = (0, import_react5.useRef)();
      const prevCache = committed.current;
      let cache = prevCache;
      if (cache) {
        const useCache = Boolean(
          inputs && cache.inputs && areInputsEqual(inputs, cache.inputs)
        );
        if (!useCache) {
          cache = {
            inputs,
            result: getResult()
          };
        }
      } else {
        cache = initial;
      }
      (0, import_react5.useEffect)(() => {
        committed.current = cache;
        if (prevCache == initial) {
          initial.inputs = initial.result = void 0;
        }
      }, [cache]);
      return cache.result;
    }
    function areInputsEqual(next, prev) {
      if (next.length !== prev.length) {
        return false;
      }
      for (let i = 0; i < next.length; i++) {
        if (next[i] !== prev[i]) {
          return false;
        }
      }
      return true;
    }
    var import_react6 = require_react();
    var useOnce = (effect) => (0, import_react6.useEffect)(effect, emptyDeps);
    var emptyDeps = [];
    var import_react7 = require_react();
    function usePrev(value) {
      const prevRef = (0, import_react7.useRef)();
      (0, import_react7.useEffect)(() => {
        prevRef.current = value;
      });
      return prevRef.current;
    }
    var import_react8 = require_react();
    var useReducedMotion = () => {
      const [reducedMotion, setReducedMotion] = (0, import_react8.useState)(null);
      useIsomorphicLayoutEffect(() => {
        const mql = window.matchMedia("(prefers-reduced-motion)");
        const handleMediaChange = (e2) => {
          setReducedMotion(e2.matches);
          assign({
            skipAnimation: e2.matches
          });
        };
        handleMediaChange(mql);
        if (mql.addEventListener) {
          mql.addEventListener("change", handleMediaChange);
        } else {
          mql.addListener(handleMediaChange);
        }
        return () => {
          if (mql.removeEventListener) {
            mql.removeEventListener("change", handleMediaChange);
          } else {
            mql.removeListener(handleMediaChange);
          }
        };
      }, []);
      return reducedMotion;
    };
    var import_rafz4 = require_cjs();
  }
});

// node_modules/@react-spring/shared/dist/cjs/index.js
var require_cjs2 = __commonJS({
  "node_modules/@react-spring/shared/dist/cjs/index.js"(exports, module) {
    "use strict";
    var import_dist10 = __toESM(require_dist());
    var import_dist11 = __toESM(require_dist2());
    var import_dist12 = __toESM(require_dist3());
    if (process.env.NODE_ENV === "production") {
      module.exports = require_react_spring_shared_production_min();
    } else {
      module.exports = require_react_spring_shared_development();
    }
  }
});

// node_modules/@react-spring/animated/dist/cjs/react-spring_animated.production.min.cjs
var require_react_spring_animated_production_min = __commonJS({
  "node_modules/@react-spring/animated/dist/cjs/react-spring_animated.production.min.cjs"(exports, module) {
    "use strict";
    var import_dist10 = __toESM(require_dist());
    var import_dist11 = __toESM(require_dist2());
    var import_dist12 = __toESM(require_dist3());
    var D = Object.create;
    var T = Object.defineProperty;
    var K = Object.getOwnPropertyDescriptor;
    var M = Object.getOwnPropertyNames;
    var q = Object.getPrototypeOf;
    var z = Object.prototype.hasOwnProperty;
    var G = (e2, r2) => {
      for (var t in r2) T(e2, t, { get: r2[t], enumerable: true });
    };
    var E = (e2, r2, t, a) => {
      if (r2 && typeof r2 == "object" || typeof r2 == "function") for (let n of M(r2)) !z.call(e2, n) && n !== t && T(e2, n, { get: () => r2[n], enumerable: !(a = K(r2, n)) || a.enumerable });
      return e2;
    };
    var J = (e2, r2, t) => (t = e2 != null ? D(q(e2)) : {}, E(r2 || !e2 || !e2.__esModule ? T(t, "default", { value: e2, enumerable: true }) : t, e2));
    var Q = (e2) => E(T({}, "__esModule", { value: true }), e2);
    var re = {};
    G(re, { Animated: () => h, AnimatedArray: () => g, AnimatedObject: () => p, AnimatedString: () => m, AnimatedValue: () => d, createHost: () => te, getAnimated: () => v, getAnimatedType: () => Y, getPayload: () => k, isAnimated: () => S, setAnimated: () => N });
    module.exports = Q(re);
    var O = require_cjs2();
    var b = Symbol.for("Animated:node");
    var S = (e2) => !!e2 && e2[b] === e2;
    var v = (e2) => e2 && e2[b];
    var N = (e2, r2) => (0, O.defineHidden)(e2, b, r2);
    var k = (e2) => e2 && e2[b] && e2[b].getPayload();
    var h = class {
      constructor() {
        N(this, this);
      }
      getPayload() {
        return this.payload || [];
      }
    };
    var P = require_cjs2();
    var d = class extends h {
      constructor(t) {
        super();
        this._value = t;
        this.done = true;
        this.durationProgress = 0;
        P.is.num(this._value) && (this.lastPosition = this._value);
      }
      static create(t) {
        return new d(t);
      }
      getPayload() {
        return [this];
      }
      getValue() {
        return this._value;
      }
      setValue(t, a) {
        return P.is.num(t) && (this.lastPosition = t, a && (t = Math.round(t / a) * a, this.done && (this.lastPosition = t))), this._value === t ? false : (this._value = t, true);
      }
      reset() {
        let { done: t } = this;
        this.done = false, P.is.num(this._value) && (this.elapsedTime = 0, this.durationProgress = 0, this.lastPosition = this._value, t && (this.lastVelocity = null), this.v0 = null);
      }
    };
    var x = require_cjs2();
    var m = class extends d {
      constructor(t) {
        super(0);
        this._string = null;
        this._toString = (0, x.createInterpolator)({ output: [t, t] });
      }
      static create(t) {
        return new m(t);
      }
      getValue() {
        let t = this._string;
        return t ?? (this._string = this._toString(this._value));
      }
      setValue(t) {
        if (x.is.str(t)) {
          if (t == this._string) return false;
          this._string = t, this._value = 1;
        } else if (super.setValue(t)) this._string = null;
        else return false;
        return true;
      }
      reset(t) {
        t && (this._toString = (0, x.createInterpolator)({ output: [this.getValue(), t] })), this._value = 0, super.reset();
      }
    };
    var U = require_cjs2();
    var u = require_cjs2();
    var V = { dependencies: null };
    var p = class extends h {
      constructor(t) {
        super();
        this.source = t;
        this.setValue(t);
      }
      getValue(t) {
        let a = {};
        return (0, u.eachProp)(this.source, (n, s) => {
          S(n) ? a[s] = n.getValue(t) : (0, u.hasFluidValue)(n) ? a[s] = (0, u.getFluidValue)(n) : t || (a[s] = n);
        }), a;
      }
      setValue(t) {
        this.source = t, this.payload = this._makePayload(t);
      }
      reset() {
        this.payload && (0, u.each)(this.payload, (t) => t.reset());
      }
      _makePayload(t) {
        if (t) {
          let a = /* @__PURE__ */ new Set();
          return (0, u.eachProp)(t, this._addToPayload, a), Array.from(a);
        }
      }
      _addToPayload(t) {
        V.dependencies && (0, u.hasFluidValue)(t) && V.dependencies.add(t);
        let a = k(t);
        a && (0, u.each)(a, (n) => this.add(n));
      }
    };
    var g = class extends p {
      constructor(r2) {
        super(r2);
      }
      static create(r2) {
        return new g(r2);
      }
      getValue() {
        return this.source.map((r2) => r2.getValue());
      }
      setValue(r2) {
        let t = this.getPayload();
        return r2.length == t.length ? t.map((a, n) => a.setValue(r2[n])).some(Boolean) : (super.setValue(r2.map(X)), true);
      }
    };
    function X(e2) {
      return ((0, U.isAnimatedString)(e2) ? m : d).create(e2);
    }
    var _ = require_cjs2();
    function Y(e2) {
      let r2 = v(e2);
      return r2 ? r2.constructor : _.is.arr(e2) ? g : (0, _.isAnimatedString)(e2) ? m : d;
    }
    var f = require_cjs2();
    var j = J(require_react());
    var c = require_react();
    var o = require_cjs2();
    var R = (e2, r2) => {
      let t = !o.is.fun(e2) || e2.prototype && e2.prototype.isReactComponent;
      return (0, c.forwardRef)((a, n) => {
        let s = (0, c.useRef)(null), i = t && (0, c.useCallback)((l) => {
          s.current = ee(n, l);
        }, [n]), [y, L] = Z(a, r2), $ = (0, o.useForceUpdate)(), w = () => {
          let l = s.current;
          if (t && !l) return;
          (l ? r2.applyAnimatedValues(l, y.getValue(true)) : false) === false && $();
        }, C = new F(w, L), A = (0, c.useRef)();
        (0, o.useIsomorphicLayoutEffect)(() => (A.current = C, (0, o.each)(L, (l) => (0, o.addFluidObserver)(l, C)), () => {
          A.current && ((0, o.each)(A.current.deps, (l) => (0, o.removeFluidObserver)(l, A.current)), o.raf.cancel(A.current.update));
        })), (0, c.useEffect)(w, []), (0, o.useOnce)(() => () => {
          let l = A.current;
          (0, o.each)(l.deps, (H) => (0, o.removeFluidObserver)(H, l));
        });
        let B = r2.getComponentProps(y.getValue());
        return j.createElement(e2, { ...B, ref: i });
      });
    };
    var F = class {
      constructor(r2, t) {
        this.update = r2;
        this.deps = t;
      }
      eventObserved(r2) {
        r2.type == "change" && o.raf.write(this.update);
      }
    };
    function Z(e2, r2) {
      let t = /* @__PURE__ */ new Set();
      return V.dependencies = t, e2.style && (e2 = { ...e2, style: r2.createAnimatedStyle(e2.style) }), e2 = new p(e2), V.dependencies = null, [e2, t];
    }
    function ee(e2, r2) {
      return e2 && (o.is.fun(e2) ? e2(r2) : e2.current = r2), r2;
    }
    var I = Symbol.for("AnimatedComponent");
    var te = (e2, { applyAnimatedValues: r2 = () => false, createAnimatedStyle: t = (n) => new p(n), getComponentProps: a = (n) => n } = {}) => {
      let n = { applyAnimatedValues: r2, createAnimatedStyle: t, getComponentProps: a }, s = (i) => {
        let y = W(i) || "Anonymous";
        return f.is.str(i) ? i = s[i] || (s[i] = R(i, n)) : i = i[I] || (i[I] = R(i, n)), i.displayName = `Animated(${y})`, i;
      };
      return (0, f.eachProp)(e2, (i, y) => {
        f.is.arr(e2) && (y = W(i)), s[y] = s(i);
      }), { animated: s };
    };
    var W = (e2) => f.is.str(e2) ? e2 : e2 && f.is.str(e2.displayName) ? e2.displayName : f.is.fun(e2) && e2.name || null;
  }
});

// node_modules/@react-spring/animated/dist/cjs/react-spring_animated.development.cjs
var require_react_spring_animated_development = __commonJS({
  "node_modules/@react-spring/animated/dist/cjs/react-spring_animated.development.cjs"(exports, module) {
    "use strict";
    var import_dist10 = __toESM(require_dist());
    var import_dist11 = __toESM(require_dist2());
    var import_dist12 = __toESM(require_dist3());
    var __create = Object.create;
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __getProtoOf = Object.getPrototypeOf;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
      // If the importer is in node compatibility mode or this is not an ESM
      // file that has been converted to a CommonJS file using a Babel-
      // compatible transform (i.e. "__esModule" has not been set), then set
      // "default" to the CommonJS "module.exports" for node compatibility.
      isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
      mod
    ));
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export2(src_exports, {
      Animated: () => Animated,
      AnimatedArray: () => AnimatedArray,
      AnimatedObject: () => AnimatedObject,
      AnimatedString: () => AnimatedString,
      AnimatedValue: () => AnimatedValue,
      createHost: () => createHost,
      getAnimated: () => getAnimated,
      getAnimatedType: () => getAnimatedType,
      getPayload: () => getPayload,
      isAnimated: () => isAnimated,
      setAnimated: () => setAnimated
    });
    module.exports = __toCommonJS2(src_exports);
    var import_shared = require_cjs2();
    var $node = Symbol.for("Animated:node");
    var isAnimated = (value) => !!value && value[$node] === value;
    var getAnimated = (owner) => owner && owner[$node];
    var setAnimated = (owner, node) => (0, import_shared.defineHidden)(owner, $node, node);
    var getPayload = (owner) => owner && owner[$node] && owner[$node].getPayload();
    var Animated = class {
      constructor() {
        setAnimated(this, this);
      }
      /** Get every `AnimatedValue` used by this node. */
      getPayload() {
        return this.payload || [];
      }
    };
    var import_shared2 = require_cjs2();
    var AnimatedValue = class extends Animated {
      constructor(_value) {
        super();
        this._value = _value;
        this.done = true;
        this.durationProgress = 0;
        if (import_shared2.is.num(this._value)) {
          this.lastPosition = this._value;
        }
      }
      /** @internal */
      static create(value) {
        return new AnimatedValue(value);
      }
      getPayload() {
        return [this];
      }
      getValue() {
        return this._value;
      }
      setValue(value, step) {
        if (import_shared2.is.num(value)) {
          this.lastPosition = value;
          if (step) {
            value = Math.round(value / step) * step;
            if (this.done) {
              this.lastPosition = value;
            }
          }
        }
        if (this._value === value) {
          return false;
        }
        this._value = value;
        return true;
      }
      reset() {
        const { done } = this;
        this.done = false;
        if (import_shared2.is.num(this._value)) {
          this.elapsedTime = 0;
          this.durationProgress = 0;
          this.lastPosition = this._value;
          if (done)
            this.lastVelocity = null;
          this.v0 = null;
        }
      }
    };
    var import_shared3 = require_cjs2();
    var AnimatedString = class extends AnimatedValue {
      constructor(value) {
        super(0);
        this._string = null;
        this._toString = (0, import_shared3.createInterpolator)({
          output: [value, value]
        });
      }
      /** @internal */
      static create(value) {
        return new AnimatedString(value);
      }
      getValue() {
        const value = this._string;
        return value == null ? this._string = this._toString(this._value) : value;
      }
      setValue(value) {
        if (import_shared3.is.str(value)) {
          if (value == this._string) {
            return false;
          }
          this._string = value;
          this._value = 1;
        } else if (super.setValue(value)) {
          this._string = null;
        } else {
          return false;
        }
        return true;
      }
      reset(goal) {
        if (goal) {
          this._toString = (0, import_shared3.createInterpolator)({
            output: [this.getValue(), goal]
          });
        }
        this._value = 0;
        super.reset();
      }
    };
    var import_shared5 = require_cjs2();
    var import_shared4 = require_cjs2();
    var TreeContext = { dependencies: null };
    var AnimatedObject = class extends Animated {
      constructor(source) {
        super();
        this.source = source;
        this.setValue(source);
      }
      getValue(animated) {
        const values = {};
        (0, import_shared4.eachProp)(this.source, (source, key) => {
          if (isAnimated(source)) {
            values[key] = source.getValue(animated);
          } else if ((0, import_shared4.hasFluidValue)(source)) {
            values[key] = (0, import_shared4.getFluidValue)(source);
          } else if (!animated) {
            values[key] = source;
          }
        });
        return values;
      }
      /** Replace the raw object data */
      setValue(source) {
        this.source = source;
        this.payload = this._makePayload(source);
      }
      reset() {
        if (this.payload) {
          (0, import_shared4.each)(this.payload, (node) => node.reset());
        }
      }
      /** Create a payload set. */
      _makePayload(source) {
        if (source) {
          const payload = /* @__PURE__ */ new Set();
          (0, import_shared4.eachProp)(source, this._addToPayload, payload);
          return Array.from(payload);
        }
      }
      /** Add to a payload set. */
      _addToPayload(source) {
        if (TreeContext.dependencies && (0, import_shared4.hasFluidValue)(source)) {
          TreeContext.dependencies.add(source);
        }
        const payload = getPayload(source);
        if (payload) {
          (0, import_shared4.each)(payload, (node) => this.add(node));
        }
      }
    };
    var AnimatedArray = class extends AnimatedObject {
      constructor(source) {
        super(source);
      }
      /** @internal */
      static create(source) {
        return new AnimatedArray(source);
      }
      getValue() {
        return this.source.map((node) => node.getValue());
      }
      setValue(source) {
        const payload = this.getPayload();
        if (source.length == payload.length) {
          return payload.map((node, i) => node.setValue(source[i])).some(Boolean);
        }
        super.setValue(source.map(makeAnimated));
        return true;
      }
    };
    function makeAnimated(value) {
      const nodeType = (0, import_shared5.isAnimatedString)(value) ? AnimatedString : AnimatedValue;
      return nodeType.create(value);
    }
    var import_shared6 = require_cjs2();
    function getAnimatedType(value) {
      const parentNode = getAnimated(value);
      return parentNode ? parentNode.constructor : import_shared6.is.arr(value) ? AnimatedArray : (0, import_shared6.isAnimatedString)(value) ? AnimatedString : AnimatedValue;
    }
    var import_shared8 = require_cjs2();
    var React2 = __toESM2(require_react());
    var import_react3 = require_react();
    var import_shared7 = require_cjs2();
    var withAnimated = (Component, host) => {
      const hasInstance = (
        // Function components must use "forwardRef" to avoid being
        // re-rendered on every animation frame.
        !import_shared7.is.fun(Component) || Component.prototype && Component.prototype.isReactComponent
      );
      return (0, import_react3.forwardRef)((givenProps, givenRef) => {
        const instanceRef = (0, import_react3.useRef)(null);
        const ref = hasInstance && // eslint-disable-next-line react-hooks/rules-of-hooks
        (0, import_react3.useCallback)(
          (value) => {
            instanceRef.current = updateRef(givenRef, value);
          },
          [givenRef]
        );
        const [props, deps] = getAnimatedState(givenProps, host);
        const forceUpdate = (0, import_shared7.useForceUpdate)();
        const callback = () => {
          const instance = instanceRef.current;
          if (hasInstance && !instance) {
            return;
          }
          const didUpdate = instance ? host.applyAnimatedValues(instance, props.getValue(true)) : false;
          if (didUpdate === false) {
            forceUpdate();
          }
        };
        const observer = new PropsObserver(callback, deps);
        const observerRef = (0, import_react3.useRef)();
        (0, import_shared7.useIsomorphicLayoutEffect)(() => {
          observerRef.current = observer;
          (0, import_shared7.each)(deps, (dep) => (0, import_shared7.addFluidObserver)(dep, observer));
          return () => {
            if (observerRef.current) {
              (0, import_shared7.each)(
                observerRef.current.deps,
                (dep) => (0, import_shared7.removeFluidObserver)(dep, observerRef.current)
              );
              import_shared7.raf.cancel(observerRef.current.update);
            }
          };
        });
        (0, import_react3.useEffect)(callback, []);
        (0, import_shared7.useOnce)(() => () => {
          const observer2 = observerRef.current;
          (0, import_shared7.each)(observer2.deps, (dep) => (0, import_shared7.removeFluidObserver)(dep, observer2));
        });
        const usedProps = host.getComponentProps(props.getValue());
        return React2.createElement(Component, { ...usedProps, ref });
      });
    };
    var PropsObserver = class {
      constructor(update, deps) {
        this.update = update;
        this.deps = deps;
      }
      eventObserved(event) {
        if (event.type == "change") {
          import_shared7.raf.write(this.update);
        }
      }
    };
    function getAnimatedState(props, host) {
      const dependencies = /* @__PURE__ */ new Set();
      TreeContext.dependencies = dependencies;
      if (props.style)
        props = {
          ...props,
          style: host.createAnimatedStyle(props.style)
        };
      props = new AnimatedObject(props);
      TreeContext.dependencies = null;
      return [props, dependencies];
    }
    function updateRef(ref, value) {
      if (ref) {
        if (import_shared7.is.fun(ref))
          ref(value);
        else
          ref.current = value;
      }
      return value;
    }
    var cacheKey = Symbol.for("AnimatedComponent");
    var createHost = (components, {
      applyAnimatedValues = () => false,
      createAnimatedStyle = (style) => new AnimatedObject(style),
      getComponentProps = (props) => props
    } = {}) => {
      const hostConfig = {
        applyAnimatedValues,
        createAnimatedStyle,
        getComponentProps
      };
      const animated = (Component) => {
        const displayName = getDisplayName(Component) || "Anonymous";
        if (import_shared8.is.str(Component)) {
          Component = animated[Component] || (animated[Component] = withAnimated(Component, hostConfig));
        } else {
          Component = Component[cacheKey] || (Component[cacheKey] = withAnimated(Component, hostConfig));
        }
        Component.displayName = `Animated(${displayName})`;
        return Component;
      };
      (0, import_shared8.eachProp)(components, (Component, key) => {
        if (import_shared8.is.arr(components)) {
          key = getDisplayName(Component);
        }
        animated[key] = animated(Component);
      });
      return {
        animated
      };
    };
    var getDisplayName = (arg) => import_shared8.is.str(arg) ? arg : arg && import_shared8.is.str(arg.displayName) ? arg.displayName : import_shared8.is.fun(arg) && arg.name || null;
  }
});

// node_modules/@react-spring/animated/dist/cjs/index.js
var require_cjs3 = __commonJS({
  "node_modules/@react-spring/animated/dist/cjs/index.js"(exports, module) {
    "use strict";
    var import_dist10 = __toESM(require_dist());
    var import_dist11 = __toESM(require_dist2());
    var import_dist12 = __toESM(require_dist3());
    if (process.env.NODE_ENV === "production") {
      module.exports = require_react_spring_animated_production_min();
    } else {
      module.exports = require_react_spring_animated_development();
    }
  }
});

// node_modules/@react-spring/types/dist/cjs/react-spring_types.production.min.cjs
var require_react_spring_types_production_min = __commonJS({
  "node_modules/@react-spring/types/dist/cjs/react-spring_types.production.min.cjs"(exports, module) {
    "use strict";
    var import_dist10 = __toESM(require_dist());
    var import_dist11 = __toESM(require_dist2());
    var import_dist12 = __toESM(require_dist3());
    var r2 = Object.defineProperty;
    var T = Object.getOwnPropertyDescriptor;
    var a = Object.getOwnPropertyNames;
    var s = Object.prototype.hasOwnProperty;
    var x = (t, e2) => {
      for (var o in e2) r2(t, o, { get: e2[o], enumerable: true });
    };
    var i = (t, e2, o, y) => {
      if (e2 && typeof e2 == "object" || typeof e2 == "function") for (let n of a(e2)) !s.call(t, n) && n !== o && r2(t, n, { get: () => e2[n], enumerable: !(y = T(e2, n)) || y.enumerable });
      return t;
    };
    var f = (t) => i(r2({}, "__esModule", { value: true }), t);
    var d = {};
    x(d, { Any: () => p });
    module.exports = f(d);
    var p = class {
    };
  }
});

// node_modules/@react-spring/types/dist/cjs/react-spring_types.development.cjs
var require_react_spring_types_development = __commonJS({
  "node_modules/@react-spring/types/dist/cjs/react-spring_types.development.cjs"(exports, module) {
    "use strict";
    var import_dist10 = __toESM(require_dist());
    var import_dist11 = __toESM(require_dist2());
    var import_dist12 = __toESM(require_dist3());
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export2(src_exports, {
      Any: () => Any
    });
    module.exports = __toCommonJS2(src_exports);
    var Any = class {
    };
  }
});

// node_modules/@react-spring/types/dist/cjs/index.js
var require_cjs4 = __commonJS({
  "node_modules/@react-spring/types/dist/cjs/index.js"(exports, module) {
    "use strict";
    var import_dist10 = __toESM(require_dist());
    var import_dist11 = __toESM(require_dist2());
    var import_dist12 = __toESM(require_dist3());
    if (process.env.NODE_ENV === "production") {
      module.exports = require_react_spring_types_production_min();
    } else {
      module.exports = require_react_spring_types_development();
    }
  }
});

// node_modules/@react-spring/core/dist/cjs/react-spring_core.production.min.cjs
var require_react_spring_core_production_min = __commonJS({
  "node_modules/@react-spring/core/dist/cjs/react-spring_core.production.min.cjs"(exports, module) {
    "use strict";
    var import_dist10 = __toESM(require_dist());
    var import_dist11 = __toESM(require_dist2());
    var import_dist12 = __toESM(require_dist3());
    var qt = Object.create;
    var ze = Object.defineProperty;
    var Qt = Object.getOwnPropertyDescriptor;
    var zt = Object.getOwnPropertyNames;
    var Gt = Object.getPrototypeOf;
    var Bt = Object.prototype.hasOwnProperty;
    var Kt = (t, n) => {
      for (var e2 in n) ze(t, e2, { get: n[e2], enumerable: true });
    };
    var Qe = (t, n, e2, r2) => {
      if (n && typeof n == "object" || typeof n == "function") for (let o of zt(n)) !Bt.call(t, o) && o !== e2 && ze(t, o, { get: () => n[o], enumerable: !(r2 = Qt(n, o)) || r2.enumerable });
      return t;
    };
    var E = (t, n, e2) => (Qe(t, n, "default"), e2 && Qe(e2, n, "default"));
    var Pt = (t, n, e2) => (e2 = t != null ? qt(Gt(t)) : {}, Qe(n || !t || !t.__esModule ? ze(e2, "default", { value: t, enumerable: true }) : e2, t));
    var Xt = (t) => Qe(ze({}, "__esModule", { value: true }), t);
    var U = {};
    Kt(U, { BailSignal: () => Ce, Controller: () => le, FrameValue: () => te, Globals: () => Ae.Globals, Interpolation: () => se, Spring: () => mn, SpringContext: () => re, SpringRef: () => ce, SpringValue: () => pe, Trail: () => hn, Transition: () => gn, config: () => it, createInterpolator: () => de.createInterpolator, easings: () => de.easings, inferTo: () => Se, interpolate: () => Pn, to: () => Sn, update: () => Tn, useChain: () => $t, useInView: () => dn, useIsomorphicLayoutEffect: () => de.useIsomorphicLayoutEffect, useReducedMotion: () => de.useReducedMotion, useResize: () => cn, useScroll: () => ln, useSpring: () => oe, useSpringRef: () => sn, useSpringValue: () => an, useSprings: () => je, useTrail: () => ht, useTransition: () => gt });
    module.exports = Xt(U);
    var Z = require_cjs2();
    var _ = require_cjs2();
    function k(t, ...n) {
      return _.is.fun(t) ? t(...n) : t;
    }
    var ge = (t, n) => t === true || !!(n && t && (_.is.fun(t) ? t(n) : (0, _.toArray)(t).includes(n)));
    var st = (t, n) => _.is.obj(t) ? n && t[n] : t;
    var Ge = (t, n) => t.default === true ? t[n] : t.default ? t.default[n] : void 0;
    var Yt = (t) => t;
    var ye = (t, n = Yt) => {
      let e2 = Ht;
      t.default && t.default !== true && (t = t.default, e2 = Object.keys(t));
      let r2 = {};
      for (let o of e2) {
        let s = n(t[o], o);
        _.is.und(s) || (r2[o] = s);
      }
      return r2;
    };
    var Ht = ["config", "onProps", "onStart", "onChange", "onPause", "onResume", "onRest"];
    var Jt = { config: 1, from: 1, to: 1, ref: 1, loop: 1, reset: 1, pause: 1, cancel: 1, reverse: 1, immediate: 1, default: 1, delay: 1, onProps: 1, onStart: 1, onChange: 1, onPause: 1, onResume: 1, onRest: 1, onResolve: 1, items: 1, trail: 1, sort: 1, expires: 1, initial: 1, enter: 1, update: 1, leave: 1, children: 1, onDestroyed: 1, keys: 1, callId: 1, parentId: 1 };
    function Wt(t) {
      let n = {}, e2 = 0;
      if ((0, _.eachProp)(t, (r2, o) => {
        Jt[o] || (n[o] = r2, e2++);
      }), e2) return n;
    }
    function Se(t) {
      let n = Wt(t);
      if (n) {
        let e2 = { to: n };
        return (0, _.eachProp)(t, (r2, o) => o in n || (e2[o] = r2)), e2;
      }
      return { ...t };
    }
    function Re(t) {
      return t = (0, _.getFluidValue)(t), _.is.arr(t) ? t.map(Re) : (0, _.isAnimatedString)(t) ? _.Globals.createStringInterpolator({ range: [0, 1], output: [t, t] })(1) : t;
    }
    function Be(t) {
      for (let n in t) return true;
      return false;
    }
    function Ke(t) {
      return _.is.fun(t) || _.is.arr(t) && _.is.obj(t[0]);
    }
    function ke(t, n) {
      var _a;
      (_a = t.ref) == null ? void 0 : _a.delete(t), n == null ? void 0 : n.delete(t);
    }
    function ve(t, n) {
      var _a;
      n && t.ref !== n && ((_a = t.ref) == null ? void 0 : _a.delete(t), n.add(t), t.ref = n);
    }
    function $t(t, n, e2 = 1e3) {
      (0, Z.useIsomorphicLayoutEffect)(() => {
        if (n) {
          let r2 = 0;
          (0, Z.each)(t, (o, s) => {
            let u = o.current;
            if (u.length) {
              let i = e2 * n[s];
              isNaN(i) ? i = r2 : r2 = i, (0, Z.each)(u, (l) => {
                (0, Z.each)(l.queue, (p) => {
                  let R = p.delay;
                  p.delay = (c) => i + k(R || 0, c);
                });
              }), o.start();
            }
          });
        } else {
          let r2 = Promise.resolve();
          (0, Z.each)(t, (o) => {
            let s = o.current;
            if (s.length) {
              let u = s.map((i) => {
                let l = i.queue;
                return i.queue = [], l;
              });
              r2 = r2.then(() => ((0, Z.each)(s, (i, l) => (0, Z.each)(u[l] || [], (p) => i.queue.push(p))), Promise.all(o.start())));
            }
          });
        }
      });
    }
    var Et = require_cjs2();
    var W = require_react();
    var j = require_cjs2();
    var a = require_cjs2();
    var O = require_cjs3();
    var J = require_cjs2();
    var it = { default: { tension: 170, friction: 26 }, gentle: { tension: 120, friction: 14 }, wobbly: { tension: 180, friction: 12 }, stiff: { tension: 210, friction: 20 }, slow: { tension: 280, friction: 60 }, molasses: { tension: 280, friction: 120 } };
    var at = { ...it.default, mass: 1, damping: 1, easing: J.easings.linear, clamp: false };
    var Xe = class {
      constructor() {
        this.velocity = 0;
        Object.assign(this, at);
      }
    };
    function xt(t, n, e2) {
      e2 && (e2 = { ...e2 }, Tt(e2, n), n = { ...e2, ...n }), Tt(t, n), Object.assign(t, n);
      for (let u in at) t[u] == null && (t[u] = at[u]);
      let { frequency: r2, damping: o } = t, { mass: s } = t;
      return J.is.und(r2) || (r2 < 0.01 && (r2 = 0.01), o < 0 && (o = 0), t.tension = Math.pow(2 * Math.PI / r2, 2) * s, t.friction = 4 * Math.PI * o * s / r2), t;
    }
    function Tt(t, n) {
      if (!J.is.und(n.decay)) t.duration = void 0;
      else {
        let e2 = !J.is.und(n.tension) || !J.is.und(n.friction);
        (e2 || !J.is.und(n.frequency) || !J.is.und(n.damping) || !J.is.und(n.mass)) && (t.duration = void 0, t.decay = void 0), e2 && (t.frequency = void 0);
      }
    }
    var bt = [];
    var Ye = class {
      constructor() {
        this.changed = false;
        this.values = bt;
        this.toValues = null;
        this.fromValues = bt;
        this.config = new Xe();
        this.immediate = false;
      }
    };
    var Pe = require_cjs2();
    function He(t, { key: n, props: e2, defaultProps: r2, state: o, actions: s }) {
      return new Promise((u, i) => {
        let l, p, R = ge(e2.cancel ?? (r2 == null ? void 0 : r2.cancel), n);
        if (R) y();
        else {
          Pe.is.und(e2.pause) || (o.paused = ge(e2.pause, n));
          let g = r2 == null ? void 0 : r2.pause;
          g !== true && (g = o.paused || ge(g, n)), l = k(e2.delay || 0, n), g ? (o.resumeQueue.add(S), s.pause()) : (s.resume(), S());
        }
        function c() {
          o.resumeQueue.add(S), o.timeouts.delete(p), p.cancel(), l = p.time - Pe.raf.now();
        }
        function S() {
          l > 0 && !Pe.Globals.skipAnimation ? (o.delayed = true, p = Pe.raf.setTimeout(y, l), o.pauseQueue.add(c), o.timeouts.add(p)) : y();
        }
        function y() {
          o.delayed && (o.delayed = false), o.pauseQueue.delete(c), o.timeouts.delete(p), t <= (o.cancelId || 0) && (R = true);
          try {
            s.start({ ...e2, callId: t, cancel: R }, u);
          } catch (g) {
            i(g);
          }
        }
      });
    }
    var Q = require_cjs2();
    var Ue = (t, n) => n.length == 1 ? n[0] : n.some((e2) => e2.cancelled) ? ee(t.get()) : n.every((e2) => e2.noop) ? ut(t.get()) : B(t.get(), n.every((e2) => e2.finished));
    var ut = (t) => ({ value: t, noop: true, finished: true, cancelled: false });
    var B = (t, n, e2 = false) => ({ value: t, finished: n, cancelled: e2 });
    var ee = (t) => ({ value: t, cancelled: true, finished: false });
    function We(t, n, e2, r2) {
      let { callId: o, parentId: s, onRest: u } = n, { asyncTo: i, promise: l } = e2;
      return !s && t === i && !n.reset ? l : e2.promise = (async () => {
        e2.asyncId = o, e2.asyncTo = t;
        let p = ye(n, (m, d) => d === "onRest" ? void 0 : m), R, c, S = new Promise((m, d) => (R = m, c = d)), y = (m) => {
          let d = o <= (e2.cancelId || 0) && ee(r2) || o !== e2.asyncId && B(r2, false);
          if (d) throw m.result = d, c(m), m;
        }, g = (m, d) => {
          let b = new Ce(), T = new Je();
          return (async () => {
            if (Q.Globals.skipAnimation) throw Te(e2), T.result = B(r2, false), c(T), T;
            y(b);
            let I = Q.is.obj(m) ? { ...m } : { ...d, to: m };
            I.parentId = o, (0, Q.eachProp)(p, (F, V) => {
              Q.is.und(I[V]) && (I[V] = F);
            });
            let A = await r2.start(I);
            return y(b), e2.paused && await new Promise((F) => {
              e2.resumeQueue.add(F);
            }), A;
          })();
        }, f;
        if (Q.Globals.skipAnimation) return Te(e2), B(r2, false);
        try {
          let m;
          Q.is.arr(t) ? m = (async (d) => {
            for (let b of d) await g(b);
          })(t) : m = Promise.resolve(t(g, r2.stop.bind(r2))), await Promise.all([m.then(R), S]), f = B(r2.get(), true, false);
        } catch (m) {
          if (m instanceof Ce) f = m.result;
          else if (m instanceof Je) f = m.result;
          else throw m;
        } finally {
          o == e2.asyncId && (e2.asyncId = s, e2.asyncTo = s ? i : void 0, e2.promise = s ? l : void 0);
        }
        return Q.is.fun(u) && Q.raf.batchedUpdates(() => {
          u(f, r2, r2.item);
        }), f;
      })();
    }
    function Te(t, n) {
      (0, Q.flush)(t.timeouts, (e2) => e2.cancel()), t.pauseQueue.clear(), t.resumeQueue.clear(), t.asyncId = t.asyncTo = t.promise = void 0, n && (t.cancelId = n);
    }
    var Ce = class extends Error {
      constructor() {
        super("An async animation has been interrupted. You see this error because you forgot to use `await` or `.catch(...)` on its returned promise.");
      }
    };
    var Je = class extends Error {
      constructor() {
        super("SkipAnimationSignal");
      }
    };
    var X = require_cjs2();
    var At = require_cjs3();
    var Ee = (t) => t instanceof te;
    var Zt = 1;
    var te = class extends X.FluidValue {
      constructor() {
        super(...arguments);
        this.id = Zt++;
        this._priority = 0;
      }
      get priority() {
        return this._priority;
      }
      set priority(e2) {
        this._priority != e2 && (this._priority = e2, this._onPriorityChange(e2));
      }
      get() {
        let e2 = (0, At.getAnimated)(this);
        return e2 && e2.getValue();
      }
      to(...e2) {
        return X.Globals.to(this, e2);
      }
      interpolate(...e2) {
        return (0, X.deprecateInterpolate)(), X.Globals.to(this, e2);
      }
      toJSON() {
        return this.get();
      }
      observerAdded(e2) {
        e2 == 1 && this._attach();
      }
      observerRemoved(e2) {
        e2 == 0 && this._detach();
      }
      _attach() {
      }
      _detach() {
      }
      _onChange(e2, r2 = false) {
        (0, X.callFluidObservers)(this, { type: "change", parent: this, value: e2, idle: r2 });
      }
      _onPriorityChange(e2) {
        this.idle || X.frameLoop.sort(this), (0, X.callFluidObservers)(this, { type: "priority", parent: this, priority: e2 });
      }
    };
    var xe = Symbol.for("SpringPhase");
    var Rt = 1;
    var pt = 2;
    var lt = 4;
    var $e = (t) => (t[xe] & Rt) > 0;
    var ne = (t) => (t[xe] & pt) > 0;
    var Ie = (t) => (t[xe] & lt) > 0;
    var ct = (t, n) => n ? t[xe] |= pt | Rt : t[xe] &= ~pt;
    var ft = (t, n) => n ? t[xe] |= lt : t[xe] &= ~lt;
    var pe = class extends te {
      constructor(e2, r2) {
        super();
        this.animation = new Ye();
        this.defaultProps = {};
        this._state = { paused: false, delayed: false, pauseQueue: /* @__PURE__ */ new Set(), resumeQueue: /* @__PURE__ */ new Set(), timeouts: /* @__PURE__ */ new Set() };
        this._pendingCalls = /* @__PURE__ */ new Set();
        this._lastCallId = 0;
        this._lastToId = 0;
        this._memoizedDuration = 0;
        if (!a.is.und(e2) || !a.is.und(r2)) {
          let o = a.is.obj(e2) ? { ...e2 } : { ...r2, from: e2 };
          a.is.und(o.default) && (o.default = true), this.start(o);
        }
      }
      get idle() {
        return !(ne(this) || this._state.asyncTo) || Ie(this);
      }
      get goal() {
        return (0, a.getFluidValue)(this.animation.to);
      }
      get velocity() {
        let e2 = (0, O.getAnimated)(this);
        return e2 instanceof O.AnimatedValue ? e2.lastVelocity || 0 : e2.getPayload().map((r2) => r2.lastVelocity || 0);
      }
      get hasAnimated() {
        return $e(this);
      }
      get isAnimating() {
        return ne(this);
      }
      get isPaused() {
        return Ie(this);
      }
      get isDelayed() {
        return this._state.delayed;
      }
      advance(e2) {
        let r2 = true, o = false, s = this.animation, { toValues: u } = s, { config: i } = s, l = (0, O.getPayload)(s.to);
        !l && (0, a.hasFluidValue)(s.to) && (u = (0, a.toArray)((0, a.getFluidValue)(s.to))), s.values.forEach((c, S) => {
          if (c.done) return;
          let y = c.constructor == O.AnimatedString ? 1 : l ? l[S].lastPosition : u[S], g = s.immediate, f = y;
          if (!g) {
            if (f = c.lastPosition, i.tension <= 0) {
              c.done = true;
              return;
            }
            let m = c.elapsedTime += e2, d = s.fromValues[S], b = c.v0 != null ? c.v0 : c.v0 = a.is.arr(i.velocity) ? i.velocity[S] : i.velocity, T, I = i.precision || (d == y ? 5e-3 : Math.min(1, Math.abs(y - d) * 1e-3));
            if (a.is.und(i.duration)) if (i.decay) {
              let A = i.decay === true ? 0.998 : i.decay, F = Math.exp(-(1 - A) * m);
              f = d + b / (1 - A) * (1 - F), g = Math.abs(c.lastPosition - f) <= I, T = b * F;
            } else {
              T = c.lastVelocity == null ? b : c.lastVelocity;
              let A = i.restVelocity || I / 10, F = i.clamp ? 0 : i.bounce, V = !a.is.und(F), z = d == y ? c.v0 > 0 : d < y, w, Y = false, q = 1, ae = Math.ceil(e2 / q);
              for (let K = 0; K < ae && (w = Math.abs(T) > A, !(!w && (g = Math.abs(y - f) <= I, g))); ++K) {
                V && (Y = f == y || f > y == z, Y && (T = -T * F, f = y));
                let h = -i.tension * 1e-6 * (f - y), x = -i.friction * 1e-3 * T, L = (h + x) / i.mass;
                T = T + L * q, f = f + T * q;
              }
            }
            else {
              let A = 1;
              i.duration > 0 && (this._memoizedDuration !== i.duration && (this._memoizedDuration = i.duration, c.durationProgress > 0 && (c.elapsedTime = i.duration * c.durationProgress, m = c.elapsedTime += e2)), A = (i.progress || 0) + m / this._memoizedDuration, A = A > 1 ? 1 : A < 0 ? 0 : A, c.durationProgress = A), f = d + i.easing(A) * (y - d), T = (f - c.lastPosition) / e2, g = A == 1;
            }
            c.lastVelocity = T, Number.isNaN(f) && (console.warn("Got NaN while animating:", this), g = true);
          }
          l && !l[S].done && (g = false), g ? c.done = true : r2 = false, c.setValue(f, i.round) && (o = true);
        });
        let p = (0, O.getAnimated)(this), R = p.getValue();
        if (r2) {
          let c = (0, a.getFluidValue)(s.to);
          (R !== c || o) && !i.decay ? (p.setValue(c), this._onChange(c)) : o && i.decay && this._onChange(R), this._stop();
        } else o && this._onChange(R);
      }
      set(e2) {
        return a.raf.batchedUpdates(() => {
          this._stop(), this._focus(e2), this._set(e2);
        }), this;
      }
      pause() {
        this._update({ pause: true });
      }
      resume() {
        this._update({ pause: false });
      }
      finish() {
        if (ne(this)) {
          let { to: e2, config: r2 } = this.animation;
          a.raf.batchedUpdates(() => {
            this._onStart(), r2.decay || this._set(e2, false), this._stop();
          });
        }
        return this;
      }
      update(e2) {
        return (this.queue || (this.queue = [])).push(e2), this;
      }
      start(e2, r2) {
        let o;
        return a.is.und(e2) ? (o = this.queue || [], this.queue = []) : o = [a.is.obj(e2) ? e2 : { ...r2, to: e2 }], Promise.all(o.map((s) => this._update(s))).then((s) => Ue(this, s));
      }
      stop(e2) {
        let { to: r2 } = this.animation;
        return this._focus(this.get()), Te(this._state, e2 && this._lastCallId), a.raf.batchedUpdates(() => this._stop(r2, e2)), this;
      }
      reset() {
        this._update({ reset: true });
      }
      eventObserved(e2) {
        e2.type == "change" ? this._start() : e2.type == "priority" && (this.priority = e2.priority + 1);
      }
      _prepareNode(e2) {
        let r2 = this.key || "", { to: o, from: s } = e2;
        o = a.is.obj(o) ? o[r2] : o, (o == null || Ke(o)) && (o = void 0), s = a.is.obj(s) ? s[r2] : s, s == null && (s = void 0);
        let u = { to: o, from: s };
        return $e(this) || (e2.reverse && ([o, s] = [s, o]), s = (0, a.getFluidValue)(s), a.is.und(s) ? (0, O.getAnimated)(this) || this._set(o) : this._set(s)), u;
      }
      _update({ ...e2 }, r2) {
        let { key: o, defaultProps: s } = this;
        e2.default && Object.assign(s, ye(e2, (l, p) => /^on/.test(p) ? st(l, o) : l)), Ct(this, e2, "onProps"), Le(this, "onProps", e2, this);
        let u = this._prepareNode(e2);
        if (Object.isFrozen(this)) throw Error("Cannot animate a `SpringValue` object that is frozen. Did you forget to pass your component to `animated(...)` before animating its props?");
        let i = this._state;
        return He(++this._lastCallId, { key: o, props: e2, defaultProps: s, state: i, actions: { pause: () => {
          Ie(this) || (ft(this, true), (0, a.flushCalls)(i.pauseQueue), Le(this, "onPause", B(this, we(this, this.animation.to)), this));
        }, resume: () => {
          Ie(this) && (ft(this, false), ne(this) && this._resume(), (0, a.flushCalls)(i.resumeQueue), Le(this, "onResume", B(this, we(this, this.animation.to)), this));
        }, start: this._merge.bind(this, u) } }).then((l) => {
          if (e2.loop && l.finished && !(r2 && l.noop)) {
            let p = dt(e2);
            if (p) return this._update(p, true);
          }
          return l;
        });
      }
      _merge(e2, r2, o) {
        if (r2.cancel) return this.stop(true), o(ee(this));
        let s = !a.is.und(e2.to), u = !a.is.und(e2.from);
        if (s || u) if (r2.callId > this._lastToId) this._lastToId = r2.callId;
        else return o(ee(this));
        let { key: i, defaultProps: l, animation: p } = this, { to: R, from: c } = p, { to: S = R, from: y = c } = e2;
        u && !s && (!r2.default || a.is.und(S)) && (S = y), r2.reverse && ([S, y] = [y, S]);
        let g = !(0, a.isEqual)(y, c);
        g && (p.from = y), y = (0, a.getFluidValue)(y);
        let f = !(0, a.isEqual)(S, R);
        f && this._focus(S);
        let m = Ke(r2.to), { config: d } = p, { decay: b, velocity: T } = d;
        (s || u) && (d.velocity = 0), r2.config && !m && xt(d, k(r2.config, i), r2.config !== l.config ? k(l.config, i) : void 0);
        let I = (0, O.getAnimated)(this);
        if (!I || a.is.und(S)) return o(B(this, true));
        let A = a.is.und(r2.reset) ? u && !r2.default : !a.is.und(y) && ge(r2.reset, i), F = A ? y : this.get(), V = Re(S), z = a.is.num(V) || a.is.arr(V) || (0, a.isAnimatedString)(V), w = !m && (!z || ge(l.immediate || r2.immediate, i));
        if (f) {
          let K = (0, O.getAnimatedType)(S);
          if (K !== I.constructor) if (w) I = this._set(V);
          else throw Error(`Cannot animate between ${I.constructor.name} and ${K.name}, as the "to" prop suggests`);
        }
        let Y = I.constructor, q = (0, a.hasFluidValue)(S), ae = false;
        if (!q) {
          let K = A || !$e(this) && g;
          (f || K) && (ae = (0, a.isEqual)(Re(F), V), q = !ae), (!(0, a.isEqual)(p.immediate, w) && !w || !(0, a.isEqual)(d.decay, b) || !(0, a.isEqual)(d.velocity, T)) && (q = true);
        }
        if (ae && ne(this) && (p.changed && !A ? q = true : q || this._stop(R)), !m && ((q || (0, a.hasFluidValue)(R)) && (p.values = I.getPayload(), p.toValues = (0, a.hasFluidValue)(S) ? null : Y == O.AnimatedString ? [1] : (0, a.toArray)(V)), p.immediate != w && (p.immediate = w, !w && !A && this._set(R)), q)) {
          let { onRest: K } = p;
          (0, a.each)(en, (x) => Ct(this, r2, x));
          let h = B(this, we(this, R));
          (0, a.flushCalls)(this._pendingCalls, h), this._pendingCalls.add(o), p.changed && a.raf.batchedUpdates(() => {
            var _a;
            p.changed = !A, K == null ? void 0 : K(h, this), A ? k(l.onRest, h) : (_a = p.onStart) == null ? void 0 : _a.call(p, h, this);
          });
        }
        A && this._set(F), m ? o(We(r2.to, r2, this._state, this)) : q ? this._start() : ne(this) && !f ? this._pendingCalls.add(o) : o(ut(F));
      }
      _focus(e2) {
        let r2 = this.animation;
        e2 !== r2.to && ((0, a.getFluidObservers)(this) && this._detach(), r2.to = e2, (0, a.getFluidObservers)(this) && this._attach());
      }
      _attach() {
        let e2 = 0, { to: r2 } = this.animation;
        (0, a.hasFluidValue)(r2) && ((0, a.addFluidObserver)(r2, this), Ee(r2) && (e2 = r2.priority + 1)), this.priority = e2;
      }
      _detach() {
        let { to: e2 } = this.animation;
        (0, a.hasFluidValue)(e2) && (0, a.removeFluidObserver)(e2, this);
      }
      _set(e2, r2 = true) {
        let o = (0, a.getFluidValue)(e2);
        if (!a.is.und(o)) {
          let s = (0, O.getAnimated)(this);
          if (!s || !(0, a.isEqual)(o, s.getValue())) {
            let u = (0, O.getAnimatedType)(o);
            !s || s.constructor != u ? (0, O.setAnimated)(this, u.create(o)) : s.setValue(o), s && a.raf.batchedUpdates(() => {
              this._onChange(o, r2);
            });
          }
        }
        return (0, O.getAnimated)(this);
      }
      _onStart() {
        let e2 = this.animation;
        e2.changed || (e2.changed = true, Le(this, "onStart", B(this, we(this, e2.to)), this));
      }
      _onChange(e2, r2) {
        r2 || (this._onStart(), k(this.animation.onChange, e2, this)), k(this.defaultProps.onChange, e2, this), super._onChange(e2, r2);
      }
      _start() {
        let e2 = this.animation;
        (0, O.getAnimated)(this).reset((0, a.getFluidValue)(e2.to)), e2.immediate || (e2.fromValues = e2.values.map((r2) => r2.lastPosition)), ne(this) || (ct(this, true), Ie(this) || this._resume());
      }
      _resume() {
        a.Globals.skipAnimation ? this.finish() : a.frameLoop.start(this);
      }
      _stop(e2, r2) {
        if (ne(this)) {
          ct(this, false);
          let o = this.animation;
          (0, a.each)(o.values, (u) => {
            u.done = true;
          }), o.toValues && (o.onChange = o.onPause = o.onResume = void 0), (0, a.callFluidObservers)(this, { type: "idle", parent: this });
          let s = r2 ? ee(this.get()) : B(this.get(), we(this, e2 ?? o.to));
          (0, a.flushCalls)(this._pendingCalls, s), o.changed && (o.changed = false, Le(this, "onRest", s, this));
        }
      }
    };
    function we(t, n) {
      let e2 = Re(n), r2 = Re(t.get());
      return (0, a.isEqual)(r2, e2);
    }
    function dt(t, n = t.loop, e2 = t.to) {
      let r2 = k(n);
      if (r2) {
        let o = r2 !== true && Se(r2), s = (o || t).reverse, u = !o || o.reset;
        return Ve({ ...t, loop: n, default: false, pause: void 0, to: !s || Ke(e2) ? e2 : void 0, from: u ? t.from : void 0, reset: u, ...o });
      }
    }
    function Ve(t) {
      let { to: n, from: e2 } = t = Se(t), r2 = /* @__PURE__ */ new Set();
      return a.is.obj(n) && vt(n, r2), a.is.obj(e2) && vt(e2, r2), t.keys = r2.size ? Array.from(r2) : null, t;
    }
    function It(t) {
      let n = Ve(t);
      return a.is.und(n.default) && (n.default = ye(n)), n;
    }
    function vt(t, n) {
      (0, a.eachProp)(t, (e2, r2) => e2 != null && n.add(r2));
    }
    var en = ["onStart", "onRest", "onChange", "onPause", "onResume"];
    function Ct(t, n, e2) {
      t.animation[e2] = n[e2] !== Ge(n, e2) ? st(n[e2], t.key) : void 0;
    }
    function Le(t, n, ...e2) {
      var _a, _b, _c, _d;
      (_b = (_a = t.animation)[n]) == null ? void 0 : _b.call(_a, ...e2), (_d = (_c = t.defaultProps)[n]) == null ? void 0 : _d.call(_c, ...e2);
    }
    var P = require_cjs2();
    var tn = ["onStart", "onChange", "onRest"];
    var nn = 1;
    var le = class {
      constructor(n, e2) {
        this.id = nn++;
        this.springs = {};
        this.queue = [];
        this._lastAsyncId = 0;
        this._active = /* @__PURE__ */ new Set();
        this._changed = /* @__PURE__ */ new Set();
        this._started = false;
        this._state = { paused: false, pauseQueue: /* @__PURE__ */ new Set(), resumeQueue: /* @__PURE__ */ new Set(), timeouts: /* @__PURE__ */ new Set() };
        this._events = { onStart: /* @__PURE__ */ new Map(), onChange: /* @__PURE__ */ new Map(), onRest: /* @__PURE__ */ new Map() };
        this._onFrame = this._onFrame.bind(this), e2 && (this._flush = e2), n && this.start({ default: true, ...n });
      }
      get idle() {
        return !this._state.asyncTo && Object.values(this.springs).every((n) => n.idle && !n.isDelayed && !n.isPaused);
      }
      get item() {
        return this._item;
      }
      set item(n) {
        this._item = n;
      }
      get() {
        let n = {};
        return this.each((e2, r2) => n[r2] = e2.get()), n;
      }
      set(n) {
        for (let e2 in n) {
          let r2 = n[e2];
          P.is.und(r2) || this.springs[e2].set(r2);
        }
      }
      update(n) {
        return n && this.queue.push(Ve(n)), this;
      }
      start(n) {
        let { queue: e2 } = this;
        return n ? e2 = (0, P.toArray)(n).map(Ve) : this.queue = [], this._flush ? this._flush(this, e2) : (Ft(this, e2), Ze(this, e2));
      }
      stop(n, e2) {
        if (n !== !!n && (e2 = n), e2) {
          let r2 = this.springs;
          (0, P.each)((0, P.toArray)(e2), (o) => r2[o].stop(!!n));
        } else Te(this._state, this._lastAsyncId), this.each((r2) => r2.stop(!!n));
        return this;
      }
      pause(n) {
        if (P.is.und(n)) this.start({ pause: true });
        else {
          let e2 = this.springs;
          (0, P.each)((0, P.toArray)(n), (r2) => e2[r2].pause());
        }
        return this;
      }
      resume(n) {
        if (P.is.und(n)) this.start({ pause: false });
        else {
          let e2 = this.springs;
          (0, P.each)((0, P.toArray)(n), (r2) => e2[r2].resume());
        }
        return this;
      }
      each(n) {
        (0, P.eachProp)(this.springs, n);
      }
      _onFrame() {
        let { onStart: n, onChange: e2, onRest: r2 } = this._events, o = this._active.size > 0, s = this._changed.size > 0;
        (o && !this._started || s && !this._started) && (this._started = true, (0, P.flush)(n, ([l, p]) => {
          p.value = this.get(), l(p, this, this._item);
        }));
        let u = !o && this._started, i = s || u && r2.size ? this.get() : null;
        s && e2.size && (0, P.flush)(e2, ([l, p]) => {
          p.value = i, l(p, this, this._item);
        }), u && (this._started = false, (0, P.flush)(r2, ([l, p]) => {
          p.value = i, l(p, this, this._item);
        }));
      }
      eventObserved(n) {
        if (n.type == "change") this._changed.add(n.parent), n.idle || this._active.add(n.parent);
        else if (n.type == "idle") this._active.delete(n.parent);
        else return;
        P.raf.onFrame(this._onFrame);
      }
    };
    function Ze(t, n) {
      return Promise.all(n.map((e2) => Vt(t, e2))).then((e2) => Ue(t, e2));
    }
    async function Vt(t, n, e2) {
      let { keys: r2, to: o, from: s, loop: u, onRest: i, onResolve: l } = n, p = P.is.obj(n.default) && n.default;
      u && (n.loop = false), o === false && (n.to = null), s === false && (n.from = null);
      let R = P.is.arr(o) || P.is.fun(o) ? o : void 0;
      R ? (n.to = void 0, n.onRest = void 0, p && (p.onRest = void 0)) : (0, P.each)(tn, (f) => {
        let m = n[f];
        if (P.is.fun(m)) {
          let d = t._events[f];
          n[f] = ({ finished: b, cancelled: T }) => {
            let I = d.get(m);
            I ? (b || (I.finished = false), T && (I.cancelled = true)) : d.set(m, { value: null, finished: b || false, cancelled: T || false });
          }, p && (p[f] = n[f]);
        }
      });
      let c = t._state;
      n.pause === !c.paused ? (c.paused = n.pause, (0, P.flushCalls)(n.pause ? c.pauseQueue : c.resumeQueue)) : c.paused && (n.pause = true);
      let S = (r2 || Object.keys(t.springs)).map((f) => t.springs[f].start(n)), y = n.cancel === true || Ge(n, "cancel") === true;
      (R || y && c.asyncId) && S.push(He(++t._lastAsyncId, { props: n, state: c, actions: { pause: P.noop, resume: P.noop, start(f, m) {
        y ? (Te(c, t._lastAsyncId), m(ee(t))) : (f.onRest = i, m(We(R, f, c, t)));
      } } })), c.paused && await new Promise((f) => {
        c.resumeQueue.add(f);
      });
      let g = Ue(t, await Promise.all(S));
      if (u && g.finished && !(e2 && g.noop)) {
        let f = dt(n, u, o);
        if (f) return Ft(t, [f]), Vt(t, f, true);
      }
      return l && P.raf.batchedUpdates(() => l(g, t, t.item)), g;
    }
    function Me(t, n) {
      let e2 = { ...t.springs };
      return n && (0, P.each)((0, P.toArray)(n), (r2) => {
        P.is.und(r2.keys) && (r2 = Ve(r2)), P.is.obj(r2.to) || (r2 = { ...r2, to: void 0 }), Ot(e2, r2, (o) => _t(o));
      }), mt(t, e2), e2;
    }
    function mt(t, n) {
      (0, P.eachProp)(n, (e2, r2) => {
        t.springs[r2] || (t.springs[r2] = e2, (0, P.addFluidObserver)(e2, t));
      });
    }
    function _t(t, n) {
      let e2 = new pe();
      return e2.key = t, n && (0, P.addFluidObserver)(e2, n), e2;
    }
    function Ot(t, n, e2) {
      n.keys && (0, P.each)(n.keys, (r2) => {
        (t[r2] || (t[r2] = e2(r2)))._prepareNode(n);
      });
    }
    function Ft(t, n) {
      (0, P.each)(n, (e2) => {
        Ot(t.springs, e2, (r2) => _t(r2, t));
      });
    }
    var tt = Pt(require_react());
    var kt = require_react();
    var Ut = require_cjs2();
    var re = ({ children: t, ...n }) => {
      let e2 = (0, kt.useContext)(et), r2 = n.pause || !!e2.pause, o = n.immediate || !!e2.immediate;
      n = (0, Ut.useMemoOne)(() => ({ pause: r2, immediate: o }), [r2, o]);
      let { Provider: s } = et;
      return tt.createElement(s, { value: n }, t);
    };
    var et = rn(re, {});
    re.Provider = et.Provider;
    re.Consumer = et.Consumer;
    function rn(t, n) {
      return Object.assign(t, tt.createContext(n)), t.Provider._context = t, t.Consumer._context = t, t;
    }
    var D = require_cjs2();
    var ce = () => {
      let t = [], n = function(r2) {
        (0, D.deprecateDirectCall)();
        let o = [];
        return (0, D.each)(t, (s, u) => {
          if (D.is.und(r2)) o.push(s.start());
          else {
            let i = e2(r2, s, u);
            i && o.push(s.start(i));
          }
        }), o;
      };
      n.current = t, n.add = function(r2) {
        t.includes(r2) || t.push(r2);
      }, n.delete = function(r2) {
        let o = t.indexOf(r2);
        ~o && t.splice(o, 1);
      }, n.pause = function() {
        return (0, D.each)(t, (r2) => r2.pause(...arguments)), this;
      }, n.resume = function() {
        return (0, D.each)(t, (r2) => r2.resume(...arguments)), this;
      }, n.set = function(r2) {
        (0, D.each)(t, (o, s) => {
          let u = D.is.fun(r2) ? r2(s, o) : r2;
          u && o.set(u);
        });
      }, n.start = function(r2) {
        let o = [];
        return (0, D.each)(t, (s, u) => {
          if (D.is.und(r2)) o.push(s.start());
          else {
            let i = this._getProps(r2, s, u);
            i && o.push(s.start(i));
          }
        }), o;
      }, n.stop = function() {
        return (0, D.each)(t, (r2) => r2.stop(...arguments)), this;
      }, n.update = function(r2) {
        return (0, D.each)(t, (o, s) => o.update(this._getProps(r2, o, s))), this;
      };
      let e2 = function(r2, o, s) {
        return D.is.fun(r2) ? r2(s, o) : r2;
      };
      return n._getProps = e2, n;
    };
    function je(t, n, e2) {
      let r2 = j.is.fun(n) && n;
      r2 && !e2 && (e2 = []);
      let o = (0, W.useMemo)(() => r2 || arguments.length == 3 ? ce() : void 0, []), s = (0, W.useRef)(0), u = (0, j.useForceUpdate)(), i = (0, W.useMemo)(() => ({ ctrls: [], queue: [], flush(d, b) {
        let T = Me(d, b);
        return s.current > 0 && !i.queue.length && !Object.keys(T).some((A) => !d.springs[A]) ? Ze(d, b) : new Promise((A) => {
          mt(d, T), i.queue.push(() => {
            A(Ze(d, b));
          }), u();
        });
      } }), []), l = (0, W.useRef)([...i.ctrls]), p = [], R = (0, j.usePrev)(t) || 0;
      (0, W.useMemo)(() => {
        (0, j.each)(l.current.slice(t, R), (d) => {
          ke(d, o), d.stop(true);
        }), l.current.length = t, c(R, t);
      }, [t]), (0, W.useMemo)(() => {
        c(0, Math.min(R, t));
      }, e2);
      function c(d, b) {
        for (let T = d; T < b; T++) {
          let I = l.current[T] || (l.current[T] = new le(null, i.flush)), A = r2 ? r2(T, I) : n[T];
          A && (p[T] = It(A));
        }
      }
      let S = l.current.map((d, b) => Me(d, p[b])), y = (0, W.useContext)(re), g = (0, j.usePrev)(y), f = y !== g && Be(y);
      (0, j.useIsomorphicLayoutEffect)(() => {
        s.current++, i.ctrls = l.current;
        let { queue: d } = i;
        d.length && (i.queue = [], (0, j.each)(d, (b) => b())), (0, j.each)(l.current, (b, T) => {
          o == null ? void 0 : o.add(b), f && b.start({ default: y });
          let I = p[T];
          I && (ve(b, I.ref), b.ref ? b.queue.push(I) : b.start(I));
        });
      }), (0, j.useOnce)(() => () => {
        (0, j.each)(i.ctrls, (d) => d.stop(true));
      });
      let m = S.map((d) => ({ ...d }));
      return o ? [m, o] : m;
    }
    function oe(t, n) {
      let e2 = Et.is.fun(t), [[r2], o] = je(1, e2 ? t : [t], e2 ? n || [] : n);
      return e2 || arguments.length == 2 ? [r2, o] : r2;
    }
    var wt = require_react();
    var on = () => ce();
    var sn = () => (0, wt.useState)(on)[0];
    var nt = require_cjs2();
    var an = (t, n) => {
      let e2 = (0, nt.useConstant)(() => new pe(t, n));
      return (0, nt.useOnce)(() => () => {
        e2.stop();
      }), e2;
    };
    var be = require_cjs2();
    function ht(t, n, e2) {
      let r2 = be.is.fun(n) && n;
      r2 && !e2 && (e2 = []);
      let o = true, s, u = je(t, (i, l) => {
        let p = r2 ? r2(i, l) : n;
        return s = p.ref, o = o && p.reverse, p;
      }, e2 || [{}]);
      if ((0, be.useIsomorphicLayoutEffect)(() => {
        (0, be.each)(u[1].current, (i, l) => {
          let p = u[1].current[l + (o ? 1 : -1)];
          if (ve(i, s), i.ref) {
            p && i.update({ to: p.springs });
            return;
          }
          p ? i.start({ to: p.springs }) : i.start();
        });
      }, e2), r2 || arguments.length == 3) {
        let i = s ?? u[1];
        return i._getProps = (l, p, R) => {
          let c = be.is.fun(l) ? l(R, p) : l;
          if (c) {
            let S = i.current[R + (c.reverse ? 1 : -1)];
            return S && (c.to = S.springs), c;
          }
        }, u;
      }
      return u[0];
    }
    var Ne = Pt(require_react());
    var fe = require_react();
    var v = require_cjs2();
    function gt(t, n, e2) {
      let r2 = v.is.fun(n) && n, { reset: o, sort: s, trail: u = 0, expires: i = true, exitBeforeEnter: l = false, onDestroyed: p, ref: R, config: c } = r2 ? r2() : n, S = (0, fe.useMemo)(() => r2 || arguments.length == 3 ? ce() : void 0, []), y = (0, v.toArray)(t), g = [], f = (0, fe.useRef)(null), m = o ? null : f.current;
      (0, v.useIsomorphicLayoutEffect)(() => {
        f.current = g;
      }), (0, v.useOnce)(() => ((0, v.each)(g, (h) => {
        S == null ? void 0 : S.add(h.ctrl), h.ctrl.ref = S;
      }), () => {
        (0, v.each)(f.current, (h) => {
          h.expired && clearTimeout(h.expirationId), ke(h.ctrl, S), h.ctrl.stop(true);
        });
      }));
      let d = pn(y, r2 ? r2() : n, m), b = o && f.current || [];
      (0, v.useIsomorphicLayoutEffect)(() => (0, v.each)(b, ({ ctrl: h, item: x, key: L }) => {
        ke(h, S), k(p, x, L);
      }));
      let T = [];
      if (m && (0, v.each)(m, (h, x) => {
        h.expired ? (clearTimeout(h.expirationId), b.push(h)) : (x = T[x] = d.indexOf(h.key), ~x && (g[x] = h));
      }), (0, v.each)(y, (h, x) => {
        g[x] || (g[x] = { key: d[x], item: h, phase: "mount", ctrl: new le() }, g[x].ctrl.item = h);
      }), T.length) {
        let h = -1, { leave: x } = r2 ? r2() : n;
        (0, v.each)(T, (L, N) => {
          let M = m[N];
          ~L ? (h = g.indexOf(M), g[h] = { ...M, item: y[L] }) : x && g.splice(++h, 0, M);
        });
      }
      v.is.fun(s) && g.sort((h, x) => s(h.item, x.item));
      let I = -u, A = (0, v.useForceUpdate)(), F = ye(n), V = /* @__PURE__ */ new Map(), z = (0, fe.useRef)(/* @__PURE__ */ new Map()), w = (0, fe.useRef)(false);
      (0, v.each)(g, (h, x) => {
        let L = h.key, N = h.phase, M = r2 ? r2() : n, G, $, Nt = k(M.delay || 0, L);
        if (N == "mount") G = M.enter, $ = "enter";
        else {
          let H = d.indexOf(L) < 0;
          if (N != "leave") if (H) G = M.leave, $ = "leave";
          else if (G = M.update) $ = "update";
          else return;
          else if (!H) G = M.enter, $ = "enter";
          else return;
        }
        if (G = k(G, h.item, x), G = v.is.obj(G) ? Se(G) : { to: G }, !G.config) {
          let H = c || F.config;
          G.config = k(H, h.item, x, $);
        }
        I += u;
        let me = { ...F, delay: Nt + I, ref: R, immediate: M.immediate, reset: false, ...G };
        if ($ == "enter" && v.is.und(me.from)) {
          let H = r2 ? r2() : n, Fe = v.is.und(H.initial) || m ? H.from : H.initial;
          me.from = k(Fe, h.item, x);
        }
        let { onResolve: Dt } = me;
        me.onResolve = (H) => {
          k(Dt, H);
          let Fe = f.current, ue = Fe.find((qe) => qe.key === L);
          if (ue && !(H.cancelled && ue.phase != "update") && ue.ctrl.idle) {
            let qe = Fe.every((he) => he.ctrl.idle);
            if (ue.phase == "leave") {
              let he = k(i, ue.item);
              if (he !== false) {
                let ot = he === true ? 0 : he;
                if (ue.expired = true, !qe && ot > 0) {
                  ot <= 2147483647 && (ue.expirationId = setTimeout(A, ot));
                  return;
                }
              }
            }
            qe && Fe.some((he) => he.expired) && (z.current.delete(ue), l && (w.current = true), A());
          }
        };
        let St = Me(h.ctrl, me);
        $ === "leave" && l ? z.current.set(h, { phase: $, springs: St, payload: me }) : V.set(h, { phase: $, springs: St, payload: me });
      });
      let Y = (0, fe.useContext)(re), q = (0, v.usePrev)(Y), ae = Y !== q && Be(Y);
      (0, v.useIsomorphicLayoutEffect)(() => {
        ae && (0, v.each)(g, (h) => {
          h.ctrl.start({ default: Y });
        });
      }, [Y]), (0, v.each)(V, (h, x) => {
        if (z.current.size) {
          let L = g.findIndex((N) => N.key === x.key);
          g.splice(L, 1);
        }
      }), (0, v.useIsomorphicLayoutEffect)(() => {
        (0, v.each)(z.current.size ? z.current : V, ({ phase: h, payload: x }, L) => {
          let { ctrl: N } = L;
          L.phase = h, S == null ? void 0 : S.add(N), ae && h == "enter" && N.start({ default: Y }), x && (ve(N, x.ref), (N.ref || S) && !w.current ? N.update(x) : (N.start(x), w.current && (w.current = false)));
        });
      }, o ? void 0 : e2);
      let K = (h) => Ne.createElement(Ne.Fragment, null, g.map((x, L) => {
        let { springs: N } = V.get(x) || x.ctrl, M = h({ ...N }, x.item, x, L);
        return M && M.type ? Ne.createElement(M.type, { ...M.props, key: v.is.str(x.key) || v.is.num(x.key) ? x.key : x.ctrl.id, ref: M.ref }) : M;
      }));
      return S ? [K, S] : K;
    }
    var un = 1;
    function pn(t, { key: n, keys: e2 = n }, r2) {
      if (e2 === null) {
        let o = /* @__PURE__ */ new Set();
        return t.map((s) => {
          let u = r2 && r2.find((i) => i.item === s && i.phase !== "leave" && !o.has(i));
          return u ? (o.add(u), u.key) : un++;
        });
      }
      return v.is.und(e2) ? t : v.is.fun(e2) ? t.map(e2) : (0, v.toArray)(e2);
    }
    var _e = require_cjs2();
    var ln = ({ container: t, ...n } = {}) => {
      let [e2, r2] = oe(() => ({ scrollX: 0, scrollY: 0, scrollXProgress: 0, scrollYProgress: 0, ...n }), []);
      return (0, _e.useIsomorphicLayoutEffect)(() => {
        let o = (0, _e.onScroll)(({ x: s, y: u }) => {
          r2.start({ scrollX: s.current, scrollXProgress: s.progress, scrollY: u.current, scrollYProgress: u.progress });
        }, { container: (t == null ? void 0 : t.current) || void 0 });
        return () => {
          (0, _e.each)(Object.values(e2), (s) => s.stop()), o();
        };
      }, []), e2;
    };
    var Oe = require_cjs2();
    var cn = ({ container: t, ...n }) => {
      let [e2, r2] = oe(() => ({ width: 0, height: 0, ...n }), []);
      return (0, Oe.useIsomorphicLayoutEffect)(() => {
        let o = (0, Oe.onResize)(({ width: s, height: u }) => {
          r2.start({ width: s, height: u, immediate: e2.width.get() === 0 || e2.height.get() === 0 });
        }, { container: (t == null ? void 0 : t.current) || void 0 });
        return () => {
          (0, Oe.each)(Object.values(e2), (s) => s.stop()), o();
        };
      }, []), e2;
    };
    var rt = require_react();
    var De = require_cjs2();
    var fn = { any: 0, all: 1 };
    function dn(t, n) {
      let [e2, r2] = (0, rt.useState)(false), o = (0, rt.useRef)(), s = De.is.fun(t) && t, u = s ? s() : {}, { to: i = {}, from: l = {}, ...p } = u, R = s ? n : t, [c, S] = oe(() => ({ from: l, ...p }), []);
      return (0, De.useIsomorphicLayoutEffect)(() => {
        let y = o.current, { root: g, once: f, amount: m = "any", ...d } = R ?? {};
        if (!y || f && e2 || typeof IntersectionObserver > "u") return;
        let b = /* @__PURE__ */ new WeakMap(), T = () => (i && S.start(i), r2(true), f ? void 0 : () => {
          l && S.start(l), r2(false);
        }), I = (F) => {
          F.forEach((V) => {
            let z = b.get(V.target);
            if (V.isIntersecting !== !!z) if (V.isIntersecting) {
              let w = T();
              De.is.fun(w) ? b.set(V.target, w) : A.unobserve(V.target);
            } else z && (z(), b.delete(V.target));
          });
        }, A = new IntersectionObserver(I, { root: g && g.current || void 0, threshold: typeof m == "number" || Array.isArray(m) ? m : fn[m], ...d });
        return A.observe(y), () => A.unobserve(y);
      }, [R]), s ? [o, c] : [o, e2];
    }
    function mn({ children: t, ...n }) {
      return t(oe(n));
    }
    var Lt = require_cjs2();
    function hn({ items: t, children: n, ...e2 }) {
      let r2 = ht(t.length, e2);
      return t.map((o, s) => {
        let u = n(o, s);
        return Lt.is.fun(u) ? u(r2[s]) : u;
      });
    }
    function gn({ items: t, children: n, ...e2 }) {
      return gt(t, e2)(n);
    }
    var jt = require_cjs2();
    var C = require_cjs2();
    var ie = require_cjs3();
    var se = class extends te {
      constructor(e2, r2) {
        super();
        this.source = e2;
        this.idle = true;
        this._active = /* @__PURE__ */ new Set();
        this.calc = (0, C.createInterpolator)(...r2);
        let o = this._get(), s = (0, ie.getAnimatedType)(o);
        (0, ie.setAnimated)(this, s.create(o));
      }
      advance(e2) {
        let r2 = this._get(), o = this.get();
        (0, C.isEqual)(r2, o) || ((0, ie.getAnimated)(this).setValue(r2), this._onChange(r2, this.idle)), !this.idle && Mt(this._active) && yt(this);
      }
      _get() {
        let e2 = C.is.arr(this.source) ? this.source.map(C.getFluidValue) : (0, C.toArray)((0, C.getFluidValue)(this.source));
        return this.calc(...e2);
      }
      _start() {
        this.idle && !Mt(this._active) && (this.idle = false, (0, C.each)((0, ie.getPayload)(this), (e2) => {
          e2.done = false;
        }), C.Globals.skipAnimation ? (C.raf.batchedUpdates(() => this.advance()), yt(this)) : C.frameLoop.start(this));
      }
      _attach() {
        let e2 = 1;
        (0, C.each)((0, C.toArray)(this.source), (r2) => {
          (0, C.hasFluidValue)(r2) && (0, C.addFluidObserver)(r2, this), Ee(r2) && (r2.idle || this._active.add(r2), e2 = Math.max(e2, r2.priority + 1));
        }), this.priority = e2, this._start();
      }
      _detach() {
        (0, C.each)((0, C.toArray)(this.source), (e2) => {
          (0, C.hasFluidValue)(e2) && (0, C.removeFluidObserver)(e2, this);
        }), this._active.clear(), yt(this);
      }
      eventObserved(e2) {
        e2.type == "change" ? e2.idle ? this.advance() : (this._active.add(e2.parent), this._start()) : e2.type == "idle" ? this._active.delete(e2.parent) : e2.type == "priority" && (this.priority = (0, C.toArray)(this.source).reduce((r2, o) => Math.max(r2, (Ee(o) ? o.priority : 0) + 1), 0));
      }
    };
    function yn(t) {
      return t.idle !== false;
    }
    function Mt(t) {
      return !t.size || Array.from(t).every(yn);
    }
    function yt(t) {
      t.idle || (t.idle = true, (0, C.each)((0, ie.getPayload)(t), (n) => {
        n.done = true;
      }), (0, C.callFluidObservers)(t, { type: "idle", parent: t }));
    }
    var Sn = (t, ...n) => new se(t, n);
    var Pn = (t, ...n) => ((0, jt.deprecateInterpolate)(), new se(t, n));
    var Ae = require_cjs2();
    Ae.Globals.assign({ createStringInterpolator: Ae.createStringInterpolator, to: (t, n) => new se(t, n) });
    var Tn = Ae.frameLoop.advance;
    var de = require_cjs2();
    E(U, require_cjs4(), module.exports);
  }
});

// node_modules/@react-spring/core/dist/cjs/react-spring_core.development.cjs
var require_react_spring_core_development = __commonJS({
  "node_modules/@react-spring/core/dist/cjs/react-spring_core.development.cjs"(exports, module) {
    "use strict";
    var import_dist10 = __toESM(require_dist());
    var import_dist11 = __toESM(require_dist2());
    var import_dist12 = __toESM(require_dist3());
    var __create = Object.create;
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __getProtoOf = Object.getPrototypeOf;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to2, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to2, key) && key !== except)
            __defProp(to2, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to2;
    };
    var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
    var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
      // If the importer is in node compatibility mode or this is not an ESM
      // file that has been converted to a CommonJS file using a Babel-
      // compatible transform (i.e. "__esModule" has not been set), then set
      // "default" to the CommonJS "module.exports" for node compatibility.
      isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
      mod
    ));
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export2(src_exports, {
      BailSignal: () => BailSignal,
      Controller: () => Controller,
      FrameValue: () => FrameValue,
      Globals: () => import_shared22.Globals,
      Interpolation: () => Interpolation,
      Spring: () => Spring,
      SpringContext: () => SpringContext,
      SpringRef: () => SpringRef,
      SpringValue: () => SpringValue,
      Trail: () => Trail,
      Transition: () => Transition,
      config: () => config,
      createInterpolator: () => import_shared23.createInterpolator,
      easings: () => import_shared23.easings,
      inferTo: () => inferTo,
      interpolate: () => interpolate,
      to: () => to,
      update: () => update,
      useChain: () => useChain,
      useInView: () => useInView,
      useIsomorphicLayoutEffect: () => import_shared23.useIsomorphicLayoutEffect,
      useReducedMotion: () => import_shared23.useReducedMotion,
      useResize: () => useResize,
      useScroll: () => useScroll,
      useSpring: () => useSpring,
      useSpringRef: () => useSpringRef,
      useSpringValue: () => useSpringValue,
      useSprings: () => useSprings,
      useTrail: () => useTrail,
      useTransition: () => useTransition
    });
    module.exports = __toCommonJS2(src_exports);
    var import_shared2 = require_cjs2();
    var import_shared = require_cjs2();
    function callProp(value, ...args) {
      return import_shared.is.fun(value) ? value(...args) : value;
    }
    var matchProp = (value, key) => value === true || !!(key && value && (import_shared.is.fun(value) ? value(key) : (0, import_shared.toArray)(value).includes(key)));
    var resolveProp = (prop, key) => import_shared.is.obj(prop) ? key && prop[key] : prop;
    var getDefaultProp = (props, key) => props.default === true ? props[key] : props.default ? props.default[key] : void 0;
    var noopTransform = (value) => value;
    var getDefaultProps = (props, transform = noopTransform) => {
      let keys = DEFAULT_PROPS;
      if (props.default && props.default !== true) {
        props = props.default;
        keys = Object.keys(props);
      }
      const defaults2 = {};
      for (const key of keys) {
        const value = transform(props[key], key);
        if (!import_shared.is.und(value)) {
          defaults2[key] = value;
        }
      }
      return defaults2;
    };
    var DEFAULT_PROPS = [
      "config",
      "onProps",
      "onStart",
      "onChange",
      "onPause",
      "onResume",
      "onRest"
    ];
    var RESERVED_PROPS = {
      config: 1,
      from: 1,
      to: 1,
      ref: 1,
      loop: 1,
      reset: 1,
      pause: 1,
      cancel: 1,
      reverse: 1,
      immediate: 1,
      default: 1,
      delay: 1,
      onProps: 1,
      onStart: 1,
      onChange: 1,
      onPause: 1,
      onResume: 1,
      onRest: 1,
      onResolve: 1,
      // Transition props
      items: 1,
      trail: 1,
      sort: 1,
      expires: 1,
      initial: 1,
      enter: 1,
      update: 1,
      leave: 1,
      children: 1,
      onDestroyed: 1,
      // Internal props
      keys: 1,
      callId: 1,
      parentId: 1
    };
    function getForwardProps(props) {
      const forward = {};
      let count = 0;
      (0, import_shared.eachProp)(props, (value, prop) => {
        if (!RESERVED_PROPS[prop]) {
          forward[prop] = value;
          count++;
        }
      });
      if (count) {
        return forward;
      }
    }
    function inferTo(props) {
      const to2 = getForwardProps(props);
      if (to2) {
        const out = { to: to2 };
        (0, import_shared.eachProp)(props, (val, key) => key in to2 || (out[key] = val));
        return out;
      }
      return { ...props };
    }
    function computeGoal(value) {
      value = (0, import_shared.getFluidValue)(value);
      return import_shared.is.arr(value) ? value.map(computeGoal) : (0, import_shared.isAnimatedString)(value) ? import_shared.Globals.createStringInterpolator({
        range: [0, 1],
        output: [value, value]
      })(1) : value;
    }
    function hasProps(props) {
      for (const _ in props)
        return true;
      return false;
    }
    function isAsyncTo(to2) {
      return import_shared.is.fun(to2) || import_shared.is.arr(to2) && import_shared.is.obj(to2[0]);
    }
    function detachRefs(ctrl, ref) {
      var _a;
      (_a = ctrl.ref) == null ? void 0 : _a.delete(ctrl);
      ref == null ? void 0 : ref.delete(ctrl);
    }
    function replaceRef(ctrl, ref) {
      var _a;
      if (ref && ctrl.ref !== ref) {
        (_a = ctrl.ref) == null ? void 0 : _a.delete(ctrl);
        ref.add(ctrl);
        ctrl.ref = ref;
      }
    }
    function useChain(refs, timeSteps, timeFrame = 1e3) {
      (0, import_shared2.useIsomorphicLayoutEffect)(() => {
        if (timeSteps) {
          let prevDelay = 0;
          (0, import_shared2.each)(refs, (ref, i) => {
            const controllers = ref.current;
            if (controllers.length) {
              let delay = timeFrame * timeSteps[i];
              if (isNaN(delay))
                delay = prevDelay;
              else
                prevDelay = delay;
              (0, import_shared2.each)(controllers, (ctrl) => {
                (0, import_shared2.each)(ctrl.queue, (props) => {
                  const memoizedDelayProp = props.delay;
                  props.delay = (key) => delay + callProp(memoizedDelayProp || 0, key);
                });
              });
              ref.start();
            }
          });
        } else {
          let p = Promise.resolve();
          (0, import_shared2.each)(refs, (ref) => {
            const controllers = ref.current;
            if (controllers.length) {
              const queues = controllers.map((ctrl) => {
                const q = ctrl.queue;
                ctrl.queue = [];
                return q;
              });
              p = p.then(() => {
                (0, import_shared2.each)(
                  controllers,
                  (ctrl, i) => (0, import_shared2.each)(queues[i] || [], (update2) => ctrl.queue.push(update2))
                );
                return Promise.all(ref.start());
              });
            }
          });
        }
      });
    }
    var import_shared12 = require_cjs2();
    var import_react22 = require_react();
    var import_shared11 = require_cjs2();
    var import_shared7 = require_cjs2();
    var import_animated2 = require_cjs3();
    var import_shared3 = require_cjs2();
    var config = {
      default: { tension: 170, friction: 26 },
      gentle: { tension: 120, friction: 14 },
      wobbly: { tension: 180, friction: 12 },
      stiff: { tension: 210, friction: 20 },
      slow: { tension: 280, friction: 60 },
      molasses: { tension: 280, friction: 120 }
    };
    var defaults = {
      ...config.default,
      mass: 1,
      damping: 1,
      easing: import_shared3.easings.linear,
      clamp: false
    };
    var AnimationConfig = class {
      constructor() {
        this.velocity = 0;
        Object.assign(this, defaults);
      }
    };
    function mergeConfig(config2, newConfig, defaultConfig) {
      if (defaultConfig) {
        defaultConfig = { ...defaultConfig };
        sanitizeConfig(defaultConfig, newConfig);
        newConfig = { ...defaultConfig, ...newConfig };
      }
      sanitizeConfig(config2, newConfig);
      Object.assign(config2, newConfig);
      for (const key in defaults) {
        if (config2[key] == null) {
          config2[key] = defaults[key];
        }
      }
      let { frequency, damping } = config2;
      const { mass } = config2;
      if (!import_shared3.is.und(frequency)) {
        if (frequency < 0.01)
          frequency = 0.01;
        if (damping < 0)
          damping = 0;
        config2.tension = Math.pow(2 * Math.PI / frequency, 2) * mass;
        config2.friction = 4 * Math.PI * damping * mass / frequency;
      }
      return config2;
    }
    function sanitizeConfig(config2, props) {
      if (!import_shared3.is.und(props.decay)) {
        config2.duration = void 0;
      } else {
        const isTensionConfig = !import_shared3.is.und(props.tension) || !import_shared3.is.und(props.friction);
        if (isTensionConfig || !import_shared3.is.und(props.frequency) || !import_shared3.is.und(props.damping) || !import_shared3.is.und(props.mass)) {
          config2.duration = void 0;
          config2.decay = void 0;
        }
        if (isTensionConfig) {
          config2.frequency = void 0;
        }
      }
    }
    var emptyArray = [];
    var Animation = class {
      constructor() {
        this.changed = false;
        this.values = emptyArray;
        this.toValues = null;
        this.fromValues = emptyArray;
        this.config = new AnimationConfig();
        this.immediate = false;
      }
    };
    var import_shared4 = require_cjs2();
    function scheduleProps(callId, { key, props, defaultProps, state, actions }) {
      return new Promise((resolve, reject) => {
        let delay;
        let timeout;
        let cancel = matchProp(props.cancel ?? (defaultProps == null ? void 0 : defaultProps.cancel), key);
        if (cancel) {
          onStart();
        } else {
          if (!import_shared4.is.und(props.pause)) {
            state.paused = matchProp(props.pause, key);
          }
          let pause = defaultProps == null ? void 0 : defaultProps.pause;
          if (pause !== true) {
            pause = state.paused || matchProp(pause, key);
          }
          delay = callProp(props.delay || 0, key);
          if (pause) {
            state.resumeQueue.add(onResume);
            actions.pause();
          } else {
            actions.resume();
            onResume();
          }
        }
        function onPause() {
          state.resumeQueue.add(onResume);
          state.timeouts.delete(timeout);
          timeout.cancel();
          delay = timeout.time - import_shared4.raf.now();
        }
        function onResume() {
          if (delay > 0 && !import_shared4.Globals.skipAnimation) {
            state.delayed = true;
            timeout = import_shared4.raf.setTimeout(onStart, delay);
            state.pauseQueue.add(onPause);
            state.timeouts.add(timeout);
          } else {
            onStart();
          }
        }
        function onStart() {
          if (state.delayed) {
            state.delayed = false;
          }
          state.pauseQueue.delete(onPause);
          state.timeouts.delete(timeout);
          if (callId <= (state.cancelId || 0)) {
            cancel = true;
          }
          try {
            actions.start({ ...props, callId, cancel }, resolve);
          } catch (err) {
            reject(err);
          }
        }
      });
    }
    var import_shared5 = require_cjs2();
    var getCombinedResult = (target, results) => results.length == 1 ? results[0] : results.some((result) => result.cancelled) ? getCancelledResult(target.get()) : results.every((result) => result.noop) ? getNoopResult(target.get()) : getFinishedResult(
      target.get(),
      results.every((result) => result.finished)
    );
    var getNoopResult = (value) => ({
      value,
      noop: true,
      finished: true,
      cancelled: false
    });
    var getFinishedResult = (value, finished, cancelled = false) => ({
      value,
      finished,
      cancelled
    });
    var getCancelledResult = (value) => ({
      value,
      cancelled: true,
      finished: false
    });
    function runAsync(to2, props, state, target) {
      const { callId, parentId, onRest } = props;
      const { asyncTo: prevTo, promise: prevPromise } = state;
      if (!parentId && to2 === prevTo && !props.reset) {
        return prevPromise;
      }
      return state.promise = (async () => {
        state.asyncId = callId;
        state.asyncTo = to2;
        const defaultProps = getDefaultProps(
          props,
          (value, key) => (
            // The `onRest` prop is only called when the `runAsync` promise is resolved.
            key === "onRest" ? void 0 : value
          )
        );
        let preventBail;
        let bail;
        const bailPromise = new Promise(
          (resolve, reject) => (preventBail = resolve, bail = reject)
        );
        const bailIfEnded = (bailSignal) => {
          const bailResult = (
            // The `cancel` prop or `stop` method was used.
            callId <= (state.cancelId || 0) && getCancelledResult(target) || // The async `to` prop was replaced.
            callId !== state.asyncId && getFinishedResult(target, false)
          );
          if (bailResult) {
            bailSignal.result = bailResult;
            bail(bailSignal);
            throw bailSignal;
          }
        };
        const animate = (arg1, arg2) => {
          const bailSignal = new BailSignal();
          const skipAnimationSignal = new SkipAnimationSignal();
          return (async () => {
            if (import_shared5.Globals.skipAnimation) {
              stopAsync(state);
              skipAnimationSignal.result = getFinishedResult(target, false);
              bail(skipAnimationSignal);
              throw skipAnimationSignal;
            }
            bailIfEnded(bailSignal);
            const props2 = import_shared5.is.obj(arg1) ? { ...arg1 } : { ...arg2, to: arg1 };
            props2.parentId = callId;
            (0, import_shared5.eachProp)(defaultProps, (value, key) => {
              if (import_shared5.is.und(props2[key])) {
                props2[key] = value;
              }
            });
            const result2 = await target.start(props2);
            bailIfEnded(bailSignal);
            if (state.paused) {
              await new Promise((resume) => {
                state.resumeQueue.add(resume);
              });
            }
            return result2;
          })();
        };
        let result;
        if (import_shared5.Globals.skipAnimation) {
          stopAsync(state);
          return getFinishedResult(target, false);
        }
        try {
          let animating;
          if (import_shared5.is.arr(to2)) {
            animating = (async (queue) => {
              for (const props2 of queue) {
                await animate(props2);
              }
            })(to2);
          } else {
            animating = Promise.resolve(to2(animate, target.stop.bind(target)));
          }
          await Promise.all([animating.then(preventBail), bailPromise]);
          result = getFinishedResult(target.get(), true, false);
        } catch (err) {
          if (err instanceof BailSignal) {
            result = err.result;
          } else if (err instanceof SkipAnimationSignal) {
            result = err.result;
          } else {
            throw err;
          }
        } finally {
          if (callId == state.asyncId) {
            state.asyncId = parentId;
            state.asyncTo = parentId ? prevTo : void 0;
            state.promise = parentId ? prevPromise : void 0;
          }
        }
        if (import_shared5.is.fun(onRest)) {
          import_shared5.raf.batchedUpdates(() => {
            onRest(result, target, target.item);
          });
        }
        return result;
      })();
    }
    function stopAsync(state, cancelId) {
      (0, import_shared5.flush)(state.timeouts, (t) => t.cancel());
      state.pauseQueue.clear();
      state.resumeQueue.clear();
      state.asyncId = state.asyncTo = state.promise = void 0;
      if (cancelId)
        state.cancelId = cancelId;
    }
    var BailSignal = class extends Error {
      constructor() {
        super(
          "An async animation has been interrupted. You see this error because you forgot to use `await` or `.catch(...)` on its returned promise."
        );
      }
    };
    var SkipAnimationSignal = class extends Error {
      constructor() {
        super("SkipAnimationSignal");
      }
    };
    var import_shared6 = require_cjs2();
    var import_animated = require_cjs3();
    var isFrameValue = (value) => value instanceof FrameValue;
    var nextId = 1;
    var FrameValue = class extends import_shared6.FluidValue {
      constructor() {
        super(...arguments);
        this.id = nextId++;
        this._priority = 0;
      }
      get priority() {
        return this._priority;
      }
      set priority(priority) {
        if (this._priority != priority) {
          this._priority = priority;
          this._onPriorityChange(priority);
        }
      }
      /** Get the current value */
      get() {
        const node = (0, import_animated.getAnimated)(this);
        return node && node.getValue();
      }
      /** Create a spring that maps our value to another value */
      to(...args) {
        return import_shared6.Globals.to(this, args);
      }
      /** @deprecated Use the `to` method instead. */
      interpolate(...args) {
        (0, import_shared6.deprecateInterpolate)();
        return import_shared6.Globals.to(this, args);
      }
      toJSON() {
        return this.get();
      }
      observerAdded(count) {
        if (count == 1)
          this._attach();
      }
      observerRemoved(count) {
        if (count == 0)
          this._detach();
      }
      /** Called when the first child is added. */
      _attach() {
      }
      /** Called when the last child is removed. */
      _detach() {
      }
      /** Tell our children about our new value */
      _onChange(value, idle = false) {
        (0, import_shared6.callFluidObservers)(this, {
          type: "change",
          parent: this,
          value,
          idle
        });
      }
      /** Tell our children about our new priority */
      _onPriorityChange(priority) {
        if (!this.idle) {
          import_shared6.frameLoop.sort(this);
        }
        (0, import_shared6.callFluidObservers)(this, {
          type: "priority",
          parent: this,
          priority
        });
      }
    };
    var $P = Symbol.for("SpringPhase");
    var HAS_ANIMATED = 1;
    var IS_ANIMATING = 2;
    var IS_PAUSED = 4;
    var hasAnimated = (target) => (target[$P] & HAS_ANIMATED) > 0;
    var isAnimating = (target) => (target[$P] & IS_ANIMATING) > 0;
    var isPaused = (target) => (target[$P] & IS_PAUSED) > 0;
    var setActiveBit = (target, active) => active ? target[$P] |= IS_ANIMATING | HAS_ANIMATED : target[$P] &= ~IS_ANIMATING;
    var setPausedBit = (target, paused) => paused ? target[$P] |= IS_PAUSED : target[$P] &= ~IS_PAUSED;
    var SpringValue = class extends FrameValue {
      constructor(arg1, arg2) {
        super();
        this.animation = new Animation();
        this.defaultProps = {};
        this._state = {
          paused: false,
          delayed: false,
          pauseQueue: /* @__PURE__ */ new Set(),
          resumeQueue: /* @__PURE__ */ new Set(),
          timeouts: /* @__PURE__ */ new Set()
        };
        this._pendingCalls = /* @__PURE__ */ new Set();
        this._lastCallId = 0;
        this._lastToId = 0;
        this._memoizedDuration = 0;
        if (!import_shared7.is.und(arg1) || !import_shared7.is.und(arg2)) {
          const props = import_shared7.is.obj(arg1) ? { ...arg1 } : { ...arg2, from: arg1 };
          if (import_shared7.is.und(props.default)) {
            props.default = true;
          }
          this.start(props);
        }
      }
      /** Equals true when not advancing on each frame. */
      get idle() {
        return !(isAnimating(this) || this._state.asyncTo) || isPaused(this);
      }
      get goal() {
        return (0, import_shared7.getFluidValue)(this.animation.to);
      }
      get velocity() {
        const node = (0, import_animated2.getAnimated)(this);
        return node instanceof import_animated2.AnimatedValue ? node.lastVelocity || 0 : node.getPayload().map((node2) => node2.lastVelocity || 0);
      }
      /**
       * When true, this value has been animated at least once.
       */
      get hasAnimated() {
        return hasAnimated(this);
      }
      /**
       * When true, this value has an unfinished animation,
       * which is either active or paused.
       */
      get isAnimating() {
        return isAnimating(this);
      }
      /**
       * When true, all current and future animations are paused.
       */
      get isPaused() {
        return isPaused(this);
      }
      /**
       *
       *
       */
      get isDelayed() {
        return this._state.delayed;
      }
      /** Advance the current animation by a number of milliseconds */
      advance(dt) {
        let idle = true;
        let changed = false;
        const anim = this.animation;
        let { toValues } = anim;
        const { config: config2 } = anim;
        const payload = (0, import_animated2.getPayload)(anim.to);
        if (!payload && (0, import_shared7.hasFluidValue)(anim.to)) {
          toValues = (0, import_shared7.toArray)((0, import_shared7.getFluidValue)(anim.to));
        }
        anim.values.forEach((node2, i) => {
          if (node2.done)
            return;
          const to2 = (
            // Animated strings always go from 0 to 1.
            node2.constructor == import_animated2.AnimatedString ? 1 : payload ? payload[i].lastPosition : toValues[i]
          );
          let finished = anim.immediate;
          let position = to2;
          if (!finished) {
            position = node2.lastPosition;
            if (config2.tension <= 0) {
              node2.done = true;
              return;
            }
            let elapsed = node2.elapsedTime += dt;
            const from = anim.fromValues[i];
            const v0 = node2.v0 != null ? node2.v0 : node2.v0 = import_shared7.is.arr(config2.velocity) ? config2.velocity[i] : config2.velocity;
            let velocity;
            const precision = config2.precision || (from == to2 ? 5e-3 : Math.min(1, Math.abs(to2 - from) * 1e-3));
            if (!import_shared7.is.und(config2.duration)) {
              let p = 1;
              if (config2.duration > 0) {
                if (this._memoizedDuration !== config2.duration) {
                  this._memoizedDuration = config2.duration;
                  if (node2.durationProgress > 0) {
                    node2.elapsedTime = config2.duration * node2.durationProgress;
                    elapsed = node2.elapsedTime += dt;
                  }
                }
                p = (config2.progress || 0) + elapsed / this._memoizedDuration;
                p = p > 1 ? 1 : p < 0 ? 0 : p;
                node2.durationProgress = p;
              }
              position = from + config2.easing(p) * (to2 - from);
              velocity = (position - node2.lastPosition) / dt;
              finished = p == 1;
            } else if (config2.decay) {
              const decay = config2.decay === true ? 0.998 : config2.decay;
              const e2 = Math.exp(-(1 - decay) * elapsed);
              position = from + v0 / (1 - decay) * (1 - e2);
              finished = Math.abs(node2.lastPosition - position) <= precision;
              velocity = v0 * e2;
            } else {
              velocity = node2.lastVelocity == null ? v0 : node2.lastVelocity;
              const restVelocity = config2.restVelocity || precision / 10;
              const bounceFactor = config2.clamp ? 0 : config2.bounce;
              const canBounce = !import_shared7.is.und(bounceFactor);
              const isGrowing = from == to2 ? node2.v0 > 0 : from < to2;
              let isMoving;
              let isBouncing = false;
              const step = 1;
              const numSteps = Math.ceil(dt / step);
              for (let n = 0; n < numSteps; ++n) {
                isMoving = Math.abs(velocity) > restVelocity;
                if (!isMoving) {
                  finished = Math.abs(to2 - position) <= precision;
                  if (finished) {
                    break;
                  }
                }
                if (canBounce) {
                  isBouncing = position == to2 || position > to2 == isGrowing;
                  if (isBouncing) {
                    velocity = -velocity * bounceFactor;
                    position = to2;
                  }
                }
                const springForce = -config2.tension * 1e-6 * (position - to2);
                const dampingForce = -config2.friction * 1e-3 * velocity;
                const acceleration = (springForce + dampingForce) / config2.mass;
                velocity = velocity + acceleration * step;
                position = position + velocity * step;
              }
            }
            node2.lastVelocity = velocity;
            if (Number.isNaN(position)) {
              console.warn(`Got NaN while animating:`, this);
              finished = true;
            }
          }
          if (payload && !payload[i].done) {
            finished = false;
          }
          if (finished) {
            node2.done = true;
          } else {
            idle = false;
          }
          if (node2.setValue(position, config2.round)) {
            changed = true;
          }
        });
        const node = (0, import_animated2.getAnimated)(this);
        const currVal = node.getValue();
        if (idle) {
          const finalVal = (0, import_shared7.getFluidValue)(anim.to);
          if ((currVal !== finalVal || changed) && !config2.decay) {
            node.setValue(finalVal);
            this._onChange(finalVal);
          } else if (changed && config2.decay) {
            this._onChange(currVal);
          }
          this._stop();
        } else if (changed) {
          this._onChange(currVal);
        }
      }
      /** Set the current value, while stopping the current animation */
      set(value) {
        import_shared7.raf.batchedUpdates(() => {
          this._stop();
          this._focus(value);
          this._set(value);
        });
        return this;
      }
      /**
       * Freeze the active animation in time, as well as any updates merged
       * before `resume` is called.
       */
      pause() {
        this._update({ pause: true });
      }
      /** Resume the animation if paused. */
      resume() {
        this._update({ pause: false });
      }
      /** Skip to the end of the current animation. */
      finish() {
        if (isAnimating(this)) {
          const { to: to2, config: config2 } = this.animation;
          import_shared7.raf.batchedUpdates(() => {
            this._onStart();
            if (!config2.decay) {
              this._set(to2, false);
            }
            this._stop();
          });
        }
        return this;
      }
      /** Push props into the pending queue. */
      update(props) {
        const queue = this.queue || (this.queue = []);
        queue.push(props);
        return this;
      }
      start(to2, arg2) {
        let queue;
        if (!import_shared7.is.und(to2)) {
          queue = [import_shared7.is.obj(to2) ? to2 : { ...arg2, to: to2 }];
        } else {
          queue = this.queue || [];
          this.queue = [];
        }
        return Promise.all(
          queue.map((props) => {
            const up = this._update(props);
            return up;
          })
        ).then((results) => getCombinedResult(this, results));
      }
      /**
       * Stop the current animation, and cancel any delayed updates.
       *
       * Pass `true` to call `onRest` with `cancelled: true`.
       */
      stop(cancel) {
        const { to: to2 } = this.animation;
        this._focus(this.get());
        stopAsync(this._state, cancel && this._lastCallId);
        import_shared7.raf.batchedUpdates(() => this._stop(to2, cancel));
        return this;
      }
      /** Restart the animation. */
      reset() {
        this._update({ reset: true });
      }
      /** @internal */
      eventObserved(event) {
        if (event.type == "change") {
          this._start();
        } else if (event.type == "priority") {
          this.priority = event.priority + 1;
        }
      }
      /**
       * Parse the `to` and `from` range from the given `props` object.
       *
       * This also ensures the initial value is available to animated components
       * during the render phase.
       */
      _prepareNode(props) {
        const key = this.key || "";
        let { to: to2, from } = props;
        to2 = import_shared7.is.obj(to2) ? to2[key] : to2;
        if (to2 == null || isAsyncTo(to2)) {
          to2 = void 0;
        }
        from = import_shared7.is.obj(from) ? from[key] : from;
        if (from == null) {
          from = void 0;
        }
        const range = { to: to2, from };
        if (!hasAnimated(this)) {
          if (props.reverse)
            [to2, from] = [from, to2];
          from = (0, import_shared7.getFluidValue)(from);
          if (!import_shared7.is.und(from)) {
            this._set(from);
          } else if (!(0, import_animated2.getAnimated)(this)) {
            this._set(to2);
          }
        }
        return range;
      }
      /** Every update is processed by this method before merging. */
      _update({ ...props }, isLoop) {
        const { key, defaultProps } = this;
        if (props.default)
          Object.assign(
            defaultProps,
            getDefaultProps(
              props,
              (value, prop) => /^on/.test(prop) ? resolveProp(value, key) : value
            )
          );
        mergeActiveFn(this, props, "onProps");
        sendEvent(this, "onProps", props, this);
        const range = this._prepareNode(props);
        if (Object.isFrozen(this)) {
          throw Error(
            "Cannot animate a `SpringValue` object that is frozen. Did you forget to pass your component to `animated(...)` before animating its props?"
          );
        }
        const state = this._state;
        return scheduleProps(++this._lastCallId, {
          key,
          props,
          defaultProps,
          state,
          actions: {
            pause: () => {
              if (!isPaused(this)) {
                setPausedBit(this, true);
                (0, import_shared7.flushCalls)(state.pauseQueue);
                sendEvent(
                  this,
                  "onPause",
                  getFinishedResult(this, checkFinished(this, this.animation.to)),
                  this
                );
              }
            },
            resume: () => {
              if (isPaused(this)) {
                setPausedBit(this, false);
                if (isAnimating(this)) {
                  this._resume();
                }
                (0, import_shared7.flushCalls)(state.resumeQueue);
                sendEvent(
                  this,
                  "onResume",
                  getFinishedResult(this, checkFinished(this, this.animation.to)),
                  this
                );
              }
            },
            start: this._merge.bind(this, range)
          }
        }).then((result) => {
          if (props.loop && result.finished && !(isLoop && result.noop)) {
            const nextProps = createLoopUpdate(props);
            if (nextProps) {
              return this._update(nextProps, true);
            }
          }
          return result;
        });
      }
      /** Merge props into the current animation */
      _merge(range, props, resolve) {
        if (props.cancel) {
          this.stop(true);
          return resolve(getCancelledResult(this));
        }
        const hasToProp = !import_shared7.is.und(range.to);
        const hasFromProp = !import_shared7.is.und(range.from);
        if (hasToProp || hasFromProp) {
          if (props.callId > this._lastToId) {
            this._lastToId = props.callId;
          } else {
            return resolve(getCancelledResult(this));
          }
        }
        const { key, defaultProps, animation: anim } = this;
        const { to: prevTo, from: prevFrom } = anim;
        let { to: to2 = prevTo, from = prevFrom } = range;
        if (hasFromProp && !hasToProp && (!props.default || import_shared7.is.und(to2))) {
          to2 = from;
        }
        if (props.reverse)
          [to2, from] = [from, to2];
        const hasFromChanged = !(0, import_shared7.isEqual)(from, prevFrom);
        if (hasFromChanged) {
          anim.from = from;
        }
        from = (0, import_shared7.getFluidValue)(from);
        const hasToChanged = !(0, import_shared7.isEqual)(to2, prevTo);
        if (hasToChanged) {
          this._focus(to2);
        }
        const hasAsyncTo = isAsyncTo(props.to);
        const { config: config2 } = anim;
        const { decay, velocity } = config2;
        if (hasToProp || hasFromProp) {
          config2.velocity = 0;
        }
        if (props.config && !hasAsyncTo) {
          mergeConfig(
            config2,
            callProp(props.config, key),
            // Avoid calling the same "config" prop twice.
            props.config !== defaultProps.config ? callProp(defaultProps.config, key) : void 0
          );
        }
        let node = (0, import_animated2.getAnimated)(this);
        if (!node || import_shared7.is.und(to2)) {
          return resolve(getFinishedResult(this, true));
        }
        const reset = (
          // When `reset` is undefined, the `from` prop implies `reset: true`,
          // except for declarative updates. When `reset` is defined, there
          // must exist a value to animate from.
          import_shared7.is.und(props.reset) ? hasFromProp && !props.default : !import_shared7.is.und(from) && matchProp(props.reset, key)
        );
        const value = reset ? from : this.get();
        const goal = computeGoal(to2);
        const isAnimatable = import_shared7.is.num(goal) || import_shared7.is.arr(goal) || (0, import_shared7.isAnimatedString)(goal);
        const immediate = !hasAsyncTo && (!isAnimatable || matchProp(defaultProps.immediate || props.immediate, key));
        if (hasToChanged) {
          const nodeType = (0, import_animated2.getAnimatedType)(to2);
          if (nodeType !== node.constructor) {
            if (immediate) {
              node = this._set(goal);
            } else
              throw Error(
                `Cannot animate between ${node.constructor.name} and ${nodeType.name}, as the "to" prop suggests`
              );
          }
        }
        const goalType = node.constructor;
        let started = (0, import_shared7.hasFluidValue)(to2);
        let finished = false;
        if (!started) {
          const hasValueChanged = reset || !hasAnimated(this) && hasFromChanged;
          if (hasToChanged || hasValueChanged) {
            finished = (0, import_shared7.isEqual)(computeGoal(value), goal);
            started = !finished;
          }
          if (!(0, import_shared7.isEqual)(anim.immediate, immediate) && !immediate || !(0, import_shared7.isEqual)(config2.decay, decay) || !(0, import_shared7.isEqual)(config2.velocity, velocity)) {
            started = true;
          }
        }
        if (finished && isAnimating(this)) {
          if (anim.changed && !reset) {
            started = true;
          } else if (!started) {
            this._stop(prevTo);
          }
        }
        if (!hasAsyncTo) {
          if (started || (0, import_shared7.hasFluidValue)(prevTo)) {
            anim.values = node.getPayload();
            anim.toValues = (0, import_shared7.hasFluidValue)(to2) ? null : goalType == import_animated2.AnimatedString ? [1] : (0, import_shared7.toArray)(goal);
          }
          if (anim.immediate != immediate) {
            anim.immediate = immediate;
            if (!immediate && !reset) {
              this._set(prevTo);
            }
          }
          if (started) {
            const { onRest } = anim;
            (0, import_shared7.each)(ACTIVE_EVENTS, (type) => mergeActiveFn(this, props, type));
            const result = getFinishedResult(this, checkFinished(this, prevTo));
            (0, import_shared7.flushCalls)(this._pendingCalls, result);
            this._pendingCalls.add(resolve);
            if (anim.changed)
              import_shared7.raf.batchedUpdates(() => {
                var _a;
                anim.changed = !reset;
                onRest == null ? void 0 : onRest(result, this);
                if (reset) {
                  callProp(defaultProps.onRest, result);
                } else {
                  (_a = anim.onStart) == null ? void 0 : _a.call(anim, result, this);
                }
              });
          }
        }
        if (reset) {
          this._set(value);
        }
        if (hasAsyncTo) {
          resolve(runAsync(props.to, props, this._state, this));
        } else if (started) {
          this._start();
        } else if (isAnimating(this) && !hasToChanged) {
          this._pendingCalls.add(resolve);
        } else {
          resolve(getNoopResult(value));
        }
      }
      /** Update the `animation.to` value, which might be a `FluidValue` */
      _focus(value) {
        const anim = this.animation;
        if (value !== anim.to) {
          if ((0, import_shared7.getFluidObservers)(this)) {
            this._detach();
          }
          anim.to = value;
          if ((0, import_shared7.getFluidObservers)(this)) {
            this._attach();
          }
        }
      }
      _attach() {
        let priority = 0;
        const { to: to2 } = this.animation;
        if ((0, import_shared7.hasFluidValue)(to2)) {
          (0, import_shared7.addFluidObserver)(to2, this);
          if (isFrameValue(to2)) {
            priority = to2.priority + 1;
          }
        }
        this.priority = priority;
      }
      _detach() {
        const { to: to2 } = this.animation;
        if ((0, import_shared7.hasFluidValue)(to2)) {
          (0, import_shared7.removeFluidObserver)(to2, this);
        }
      }
      /**
       * Update the current value from outside the frameloop,
       * and return the `Animated` node.
       */
      _set(arg, idle = true) {
        const value = (0, import_shared7.getFluidValue)(arg);
        if (!import_shared7.is.und(value)) {
          const oldNode = (0, import_animated2.getAnimated)(this);
          if (!oldNode || !(0, import_shared7.isEqual)(value, oldNode.getValue())) {
            const nodeType = (0, import_animated2.getAnimatedType)(value);
            if (!oldNode || oldNode.constructor != nodeType) {
              (0, import_animated2.setAnimated)(this, nodeType.create(value));
            } else {
              oldNode.setValue(value);
            }
            if (oldNode) {
              import_shared7.raf.batchedUpdates(() => {
                this._onChange(value, idle);
              });
            }
          }
        }
        return (0, import_animated2.getAnimated)(this);
      }
      _onStart() {
        const anim = this.animation;
        if (!anim.changed) {
          anim.changed = true;
          sendEvent(
            this,
            "onStart",
            getFinishedResult(this, checkFinished(this, anim.to)),
            this
          );
        }
      }
      _onChange(value, idle) {
        if (!idle) {
          this._onStart();
          callProp(this.animation.onChange, value, this);
        }
        callProp(this.defaultProps.onChange, value, this);
        super._onChange(value, idle);
      }
      // This method resets the animation state (even if already animating) to
      // ensure the latest from/to range is used, and it also ensures this spring
      // is added to the frameloop.
      _start() {
        const anim = this.animation;
        (0, import_animated2.getAnimated)(this).reset((0, import_shared7.getFluidValue)(anim.to));
        if (!anim.immediate) {
          anim.fromValues = anim.values.map((node) => node.lastPosition);
        }
        if (!isAnimating(this)) {
          setActiveBit(this, true);
          if (!isPaused(this)) {
            this._resume();
          }
        }
      }
      _resume() {
        if (import_shared7.Globals.skipAnimation) {
          this.finish();
        } else {
          import_shared7.frameLoop.start(this);
        }
      }
      /**
       * Exit the frameloop and notify `onRest` listeners.
       *
       * Always wrap `_stop` calls with `batchedUpdates`.
       */
      _stop(goal, cancel) {
        if (isAnimating(this)) {
          setActiveBit(this, false);
          const anim = this.animation;
          (0, import_shared7.each)(anim.values, (node) => {
            node.done = true;
          });
          if (anim.toValues) {
            anim.onChange = anim.onPause = anim.onResume = void 0;
          }
          (0, import_shared7.callFluidObservers)(this, {
            type: "idle",
            parent: this
          });
          const result = cancel ? getCancelledResult(this.get()) : getFinishedResult(this.get(), checkFinished(this, goal ?? anim.to));
          (0, import_shared7.flushCalls)(this._pendingCalls, result);
          if (anim.changed) {
            anim.changed = false;
            sendEvent(this, "onRest", result, this);
          }
        }
      }
    };
    function checkFinished(target, to2) {
      const goal = computeGoal(to2);
      const value = computeGoal(target.get());
      return (0, import_shared7.isEqual)(value, goal);
    }
    function createLoopUpdate(props, loop = props.loop, to2 = props.to) {
      const loopRet = callProp(loop);
      if (loopRet) {
        const overrides = loopRet !== true && inferTo(loopRet);
        const reverse = (overrides || props).reverse;
        const reset = !overrides || overrides.reset;
        return createUpdate({
          ...props,
          loop,
          // Avoid updating default props when looping.
          default: false,
          // Never loop the `pause` prop.
          pause: void 0,
          // For the "reverse" prop to loop as expected, the "to" prop
          // must be undefined. The "reverse" prop is ignored when the
          // "to" prop is an array or function.
          to: !reverse || isAsyncTo(to2) ? to2 : void 0,
          // Ignore the "from" prop except on reset.
          from: reset ? props.from : void 0,
          reset,
          // The "loop" prop can return a "useSpring" props object to
          // override any of the original props.
          ...overrides
        });
      }
    }
    function createUpdate(props) {
      const { to: to2, from } = props = inferTo(props);
      const keys = /* @__PURE__ */ new Set();
      if (import_shared7.is.obj(to2))
        findDefined(to2, keys);
      if (import_shared7.is.obj(from))
        findDefined(from, keys);
      props.keys = keys.size ? Array.from(keys) : null;
      return props;
    }
    function declareUpdate(props) {
      const update2 = createUpdate(props);
      if (import_shared7.is.und(update2.default)) {
        update2.default = getDefaultProps(update2);
      }
      return update2;
    }
    function findDefined(values, keys) {
      (0, import_shared7.eachProp)(values, (value, key) => value != null && keys.add(key));
    }
    var ACTIVE_EVENTS = [
      "onStart",
      "onRest",
      "onChange",
      "onPause",
      "onResume"
    ];
    function mergeActiveFn(target, props, type) {
      target.animation[type] = props[type] !== getDefaultProp(props, type) ? resolveProp(props[type], target.key) : void 0;
    }
    function sendEvent(target, type, ...args) {
      var _a, _b, _c, _d;
      (_b = (_a = target.animation)[type]) == null ? void 0 : _b.call(_a, ...args);
      (_d = (_c = target.defaultProps)[type]) == null ? void 0 : _d.call(_c, ...args);
    }
    var import_shared8 = require_cjs2();
    var BATCHED_EVENTS = ["onStart", "onChange", "onRest"];
    var nextId2 = 1;
    var Controller = class {
      constructor(props, flush3) {
        this.id = nextId2++;
        this.springs = {};
        this.queue = [];
        this._lastAsyncId = 0;
        this._active = /* @__PURE__ */ new Set();
        this._changed = /* @__PURE__ */ new Set();
        this._started = false;
        this._state = {
          paused: false,
          pauseQueue: /* @__PURE__ */ new Set(),
          resumeQueue: /* @__PURE__ */ new Set(),
          timeouts: /* @__PURE__ */ new Set()
        };
        this._events = {
          onStart: /* @__PURE__ */ new Map(),
          onChange: /* @__PURE__ */ new Map(),
          onRest: /* @__PURE__ */ new Map()
        };
        this._onFrame = this._onFrame.bind(this);
        if (flush3) {
          this._flush = flush3;
        }
        if (props) {
          this.start({ default: true, ...props });
        }
      }
      /**
       * Equals `true` when no spring values are in the frameloop, and
       * no async animation is currently active.
       */
      get idle() {
        return !this._state.asyncTo && Object.values(this.springs).every((spring) => {
          return spring.idle && !spring.isDelayed && !spring.isPaused;
        });
      }
      get item() {
        return this._item;
      }
      set item(item) {
        this._item = item;
      }
      /** Get the current values of our springs */
      get() {
        const values = {};
        this.each((spring, key) => values[key] = spring.get());
        return values;
      }
      /** Set the current values without animating. */
      set(values) {
        for (const key in values) {
          const value = values[key];
          if (!import_shared8.is.und(value)) {
            this.springs[key].set(value);
          }
        }
      }
      /** Push an update onto the queue of each value. */
      update(props) {
        if (props) {
          this.queue.push(createUpdate(props));
        }
        return this;
      }
      /**
       * Start the queued animations for every spring, and resolve the returned
       * promise once all queued animations have finished or been cancelled.
       *
       * When you pass a queue (instead of nothing), that queue is used instead of
       * the queued animations added with the `update` method, which are left alone.
       */
      start(props) {
        let { queue } = this;
        if (props) {
          queue = (0, import_shared8.toArray)(props).map(createUpdate);
        } else {
          this.queue = [];
        }
        if (this._flush) {
          return this._flush(this, queue);
        }
        prepareKeys(this, queue);
        return flushUpdateQueue(this, queue);
      }
      /** @internal */
      stop(arg, keys) {
        if (arg !== !!arg) {
          keys = arg;
        }
        if (keys) {
          const springs = this.springs;
          (0, import_shared8.each)((0, import_shared8.toArray)(keys), (key) => springs[key].stop(!!arg));
        } else {
          stopAsync(this._state, this._lastAsyncId);
          this.each((spring) => spring.stop(!!arg));
        }
        return this;
      }
      /** Freeze the active animation in time */
      pause(keys) {
        if (import_shared8.is.und(keys)) {
          this.start({ pause: true });
        } else {
          const springs = this.springs;
          (0, import_shared8.each)((0, import_shared8.toArray)(keys), (key) => springs[key].pause());
        }
        return this;
      }
      /** Resume the animation if paused. */
      resume(keys) {
        if (import_shared8.is.und(keys)) {
          this.start({ pause: false });
        } else {
          const springs = this.springs;
          (0, import_shared8.each)((0, import_shared8.toArray)(keys), (key) => springs[key].resume());
        }
        return this;
      }
      /** Call a function once per spring value */
      each(iterator) {
        (0, import_shared8.eachProp)(this.springs, iterator);
      }
      /** @internal Called at the end of every animation frame */
      _onFrame() {
        const { onStart, onChange, onRest } = this._events;
        const active = this._active.size > 0;
        const changed = this._changed.size > 0;
        if (active && !this._started || changed && !this._started) {
          this._started = true;
          (0, import_shared8.flush)(onStart, ([onStart2, result]) => {
            result.value = this.get();
            onStart2(result, this, this._item);
          });
        }
        const idle = !active && this._started;
        const values = changed || idle && onRest.size ? this.get() : null;
        if (changed && onChange.size) {
          (0, import_shared8.flush)(onChange, ([onChange2, result]) => {
            result.value = values;
            onChange2(result, this, this._item);
          });
        }
        if (idle) {
          this._started = false;
          (0, import_shared8.flush)(onRest, ([onRest2, result]) => {
            result.value = values;
            onRest2(result, this, this._item);
          });
        }
      }
      /** @internal */
      eventObserved(event) {
        if (event.type == "change") {
          this._changed.add(event.parent);
          if (!event.idle) {
            this._active.add(event.parent);
          }
        } else if (event.type == "idle") {
          this._active.delete(event.parent);
        } else
          return;
        import_shared8.raf.onFrame(this._onFrame);
      }
    };
    function flushUpdateQueue(ctrl, queue) {
      return Promise.all(queue.map((props) => flushUpdate(ctrl, props))).then(
        (results) => getCombinedResult(ctrl, results)
      );
    }
    async function flushUpdate(ctrl, props, isLoop) {
      const { keys, to: to2, from, loop, onRest, onResolve } = props;
      const defaults2 = import_shared8.is.obj(props.default) && props.default;
      if (loop) {
        props.loop = false;
      }
      if (to2 === false)
        props.to = null;
      if (from === false)
        props.from = null;
      const asyncTo = import_shared8.is.arr(to2) || import_shared8.is.fun(to2) ? to2 : void 0;
      if (asyncTo) {
        props.to = void 0;
        props.onRest = void 0;
        if (defaults2) {
          defaults2.onRest = void 0;
        }
      } else {
        (0, import_shared8.each)(BATCHED_EVENTS, (key) => {
          const handler = props[key];
          if (import_shared8.is.fun(handler)) {
            const queue = ctrl["_events"][key];
            props[key] = ({ finished, cancelled }) => {
              const result2 = queue.get(handler);
              if (result2) {
                if (!finished)
                  result2.finished = false;
                if (cancelled)
                  result2.cancelled = true;
              } else {
                queue.set(handler, {
                  value: null,
                  finished: finished || false,
                  cancelled: cancelled || false
                });
              }
            };
            if (defaults2) {
              defaults2[key] = props[key];
            }
          }
        });
      }
      const state = ctrl["_state"];
      if (props.pause === !state.paused) {
        state.paused = props.pause;
        (0, import_shared8.flushCalls)(props.pause ? state.pauseQueue : state.resumeQueue);
      } else if (state.paused) {
        props.pause = true;
      }
      const promises = (keys || Object.keys(ctrl.springs)).map(
        (key) => ctrl.springs[key].start(props)
      );
      const cancel = props.cancel === true || getDefaultProp(props, "cancel") === true;
      if (asyncTo || cancel && state.asyncId) {
        promises.push(
          scheduleProps(++ctrl["_lastAsyncId"], {
            props,
            state,
            actions: {
              pause: import_shared8.noop,
              resume: import_shared8.noop,
              start(props2, resolve) {
                if (cancel) {
                  stopAsync(state, ctrl["_lastAsyncId"]);
                  resolve(getCancelledResult(ctrl));
                } else {
                  props2.onRest = onRest;
                  resolve(
                    runAsync(
                      asyncTo,
                      props2,
                      state,
                      ctrl
                    )
                  );
                }
              }
            }
          })
        );
      }
      if (state.paused) {
        await new Promise((resume) => {
          state.resumeQueue.add(resume);
        });
      }
      const result = getCombinedResult(ctrl, await Promise.all(promises));
      if (loop && result.finished && !(isLoop && result.noop)) {
        const nextProps = createLoopUpdate(props, loop, to2);
        if (nextProps) {
          prepareKeys(ctrl, [nextProps]);
          return flushUpdate(ctrl, nextProps, true);
        }
      }
      if (onResolve) {
        import_shared8.raf.batchedUpdates(() => onResolve(result, ctrl, ctrl.item));
      }
      return result;
    }
    function getSprings(ctrl, props) {
      const springs = { ...ctrl.springs };
      if (props) {
        (0, import_shared8.each)((0, import_shared8.toArray)(props), (props2) => {
          if (import_shared8.is.und(props2.keys)) {
            props2 = createUpdate(props2);
          }
          if (!import_shared8.is.obj(props2.to)) {
            props2 = { ...props2, to: void 0 };
          }
          prepareSprings(springs, props2, (key) => {
            return createSpring(key);
          });
        });
      }
      setSprings(ctrl, springs);
      return springs;
    }
    function setSprings(ctrl, springs) {
      (0, import_shared8.eachProp)(springs, (spring, key) => {
        if (!ctrl.springs[key]) {
          ctrl.springs[key] = spring;
          (0, import_shared8.addFluidObserver)(spring, ctrl);
        }
      });
    }
    function createSpring(key, observer) {
      const spring = new SpringValue();
      spring.key = key;
      if (observer) {
        (0, import_shared8.addFluidObserver)(spring, observer);
      }
      return spring;
    }
    function prepareSprings(springs, props, create) {
      if (props.keys) {
        (0, import_shared8.each)(props.keys, (key) => {
          const spring = springs[key] || (springs[key] = create(key));
          spring["_prepareNode"](props);
        });
      }
    }
    function prepareKeys(ctrl, queue) {
      (0, import_shared8.each)(queue, (props) => {
        prepareSprings(ctrl.springs, props, (key) => {
          return createSpring(key, ctrl);
        });
      });
    }
    var React2 = __toESM2(require_react());
    var import_react3 = require_react();
    var import_shared9 = require_cjs2();
    var SpringContext = ({
      children,
      ...props
    }) => {
      const inherited = (0, import_react3.useContext)(ctx);
      const pause = props.pause || !!inherited.pause, immediate = props.immediate || !!inherited.immediate;
      props = (0, import_shared9.useMemoOne)(() => ({ pause, immediate }), [pause, immediate]);
      const { Provider } = ctx;
      return React2.createElement(Provider, { value: props }, children);
    };
    var ctx = makeContext(SpringContext, {});
    SpringContext.Provider = ctx.Provider;
    SpringContext.Consumer = ctx.Consumer;
    function makeContext(target, init) {
      Object.assign(target, React2.createContext(init));
      target.Provider._context = target;
      target.Consumer._context = target;
      return target;
    }
    var import_shared10 = require_cjs2();
    var SpringRef = () => {
      const current = [];
      const SpringRef2 = function(props) {
        (0, import_shared10.deprecateDirectCall)();
        const results = [];
        (0, import_shared10.each)(current, (ctrl, i) => {
          if (import_shared10.is.und(props)) {
            results.push(ctrl.start());
          } else {
            const update2 = _getProps(props, ctrl, i);
            if (update2) {
              results.push(ctrl.start(update2));
            }
          }
        });
        return results;
      };
      SpringRef2.current = current;
      SpringRef2.add = function(ctrl) {
        if (!current.includes(ctrl)) {
          current.push(ctrl);
        }
      };
      SpringRef2.delete = function(ctrl) {
        const i = current.indexOf(ctrl);
        if (~i)
          current.splice(i, 1);
      };
      SpringRef2.pause = function() {
        (0, import_shared10.each)(current, (ctrl) => ctrl.pause(...arguments));
        return this;
      };
      SpringRef2.resume = function() {
        (0, import_shared10.each)(current, (ctrl) => ctrl.resume(...arguments));
        return this;
      };
      SpringRef2.set = function(values) {
        (0, import_shared10.each)(current, (ctrl, i) => {
          const update2 = import_shared10.is.fun(values) ? values(i, ctrl) : values;
          if (update2) {
            ctrl.set(update2);
          }
        });
      };
      SpringRef2.start = function(props) {
        const results = [];
        (0, import_shared10.each)(current, (ctrl, i) => {
          if (import_shared10.is.und(props)) {
            results.push(ctrl.start());
          } else {
            const update2 = this._getProps(props, ctrl, i);
            if (update2) {
              results.push(ctrl.start(update2));
            }
          }
        });
        return results;
      };
      SpringRef2.stop = function() {
        (0, import_shared10.each)(current, (ctrl) => ctrl.stop(...arguments));
        return this;
      };
      SpringRef2.update = function(props) {
        (0, import_shared10.each)(current, (ctrl, i) => ctrl.update(this._getProps(props, ctrl, i)));
        return this;
      };
      const _getProps = function(arg, ctrl, index) {
        return import_shared10.is.fun(arg) ? arg(index, ctrl) : arg;
      };
      SpringRef2._getProps = _getProps;
      return SpringRef2;
    };
    function useSprings(length, props, deps) {
      const propsFn = import_shared11.is.fun(props) && props;
      if (propsFn && !deps)
        deps = [];
      const ref = (0, import_react22.useMemo)(
        () => propsFn || arguments.length == 3 ? SpringRef() : void 0,
        []
      );
      const layoutId = (0, import_react22.useRef)(0);
      const forceUpdate = (0, import_shared11.useForceUpdate)();
      const state = (0, import_react22.useMemo)(
        () => ({
          ctrls: [],
          queue: [],
          flush(ctrl, updates2) {
            const springs2 = getSprings(ctrl, updates2);
            const canFlushSync = layoutId.current > 0 && !state.queue.length && !Object.keys(springs2).some((key) => !ctrl.springs[key]);
            return canFlushSync ? flushUpdateQueue(ctrl, updates2) : new Promise((resolve) => {
              setSprings(ctrl, springs2);
              state.queue.push(() => {
                resolve(flushUpdateQueue(ctrl, updates2));
              });
              forceUpdate();
            });
          }
        }),
        []
      );
      const ctrls = (0, import_react22.useRef)([...state.ctrls]);
      const updates = [];
      const prevLength = (0, import_shared11.usePrev)(length) || 0;
      (0, import_react22.useMemo)(() => {
        (0, import_shared11.each)(ctrls.current.slice(length, prevLength), (ctrl) => {
          detachRefs(ctrl, ref);
          ctrl.stop(true);
        });
        ctrls.current.length = length;
        declareUpdates(prevLength, length);
      }, [length]);
      (0, import_react22.useMemo)(() => {
        declareUpdates(0, Math.min(prevLength, length));
      }, deps);
      function declareUpdates(startIndex, endIndex) {
        for (let i = startIndex; i < endIndex; i++) {
          const ctrl = ctrls.current[i] || (ctrls.current[i] = new Controller(null, state.flush));
          const update2 = propsFn ? propsFn(i, ctrl) : props[i];
          if (update2) {
            updates[i] = declareUpdate(update2);
          }
        }
      }
      const springs = ctrls.current.map((ctrl, i) => getSprings(ctrl, updates[i]));
      const context = (0, import_react22.useContext)(SpringContext);
      const prevContext = (0, import_shared11.usePrev)(context);
      const hasContext = context !== prevContext && hasProps(context);
      (0, import_shared11.useIsomorphicLayoutEffect)(() => {
        layoutId.current++;
        state.ctrls = ctrls.current;
        const { queue } = state;
        if (queue.length) {
          state.queue = [];
          (0, import_shared11.each)(queue, (cb) => cb());
        }
        (0, import_shared11.each)(ctrls.current, (ctrl, i) => {
          ref == null ? void 0 : ref.add(ctrl);
          if (hasContext) {
            ctrl.start({ default: context });
          }
          const update2 = updates[i];
          if (update2) {
            replaceRef(ctrl, update2.ref);
            if (ctrl.ref) {
              ctrl.queue.push(update2);
            } else {
              ctrl.start(update2);
            }
          }
        });
      });
      (0, import_shared11.useOnce)(() => () => {
        (0, import_shared11.each)(state.ctrls, (ctrl) => ctrl.stop(true));
      });
      const values = springs.map((x) => ({ ...x }));
      return ref ? [values, ref] : values;
    }
    function useSpring(props, deps) {
      const isFn = import_shared12.is.fun(props);
      const [[values], ref] = useSprings(
        1,
        isFn ? props : [props],
        isFn ? deps || [] : deps
      );
      return isFn || arguments.length == 2 ? [values, ref] : values;
    }
    var import_react32 = require_react();
    var initSpringRef = () => SpringRef();
    var useSpringRef = () => (0, import_react32.useState)(initSpringRef)[0];
    var import_shared13 = require_cjs2();
    var useSpringValue = (initial, props) => {
      const springValue = (0, import_shared13.useConstant)(() => new SpringValue(initial, props));
      (0, import_shared13.useOnce)(() => () => {
        springValue.stop();
      });
      return springValue;
    };
    var import_shared14 = require_cjs2();
    function useTrail(length, propsArg, deps) {
      const propsFn = import_shared14.is.fun(propsArg) && propsArg;
      if (propsFn && !deps)
        deps = [];
      let reverse = true;
      let passedRef = void 0;
      const result = useSprings(
        length,
        (i, ctrl) => {
          const props = propsFn ? propsFn(i, ctrl) : propsArg;
          passedRef = props.ref;
          reverse = reverse && props.reverse;
          return props;
        },
        // Ensure the props function is called when no deps exist.
        // This works around the 3 argument rule.
        deps || [{}]
      );
      (0, import_shared14.useIsomorphicLayoutEffect)(() => {
        (0, import_shared14.each)(result[1].current, (ctrl, i) => {
          const parent = result[1].current[i + (reverse ? 1 : -1)];
          replaceRef(ctrl, passedRef);
          if (ctrl.ref) {
            if (parent) {
              ctrl.update({ to: parent.springs });
            }
            return;
          }
          if (parent) {
            ctrl.start({ to: parent.springs });
          } else {
            ctrl.start();
          }
        });
      }, deps);
      if (propsFn || arguments.length == 3) {
        const ref = passedRef ?? result[1];
        ref["_getProps"] = (propsArg2, ctrl, i) => {
          const props = import_shared14.is.fun(propsArg2) ? propsArg2(i, ctrl) : propsArg2;
          if (props) {
            const parent = ref.current[i + (props.reverse ? 1 : -1)];
            if (parent)
              props.to = parent.springs;
            return props;
          }
        };
        return result;
      }
      return result[0];
    }
    var React22 = __toESM2(require_react());
    var import_react4 = require_react();
    var import_shared15 = require_cjs2();
    function useTransition(data, props, deps) {
      const propsFn = import_shared15.is.fun(props) && props;
      const {
        reset,
        sort,
        trail = 0,
        expires = true,
        exitBeforeEnter = false,
        onDestroyed,
        ref: propsRef,
        config: propsConfig
      } = propsFn ? propsFn() : props;
      const ref = (0, import_react4.useMemo)(
        () => propsFn || arguments.length == 3 ? SpringRef() : void 0,
        []
      );
      const items = (0, import_shared15.toArray)(data);
      const transitions = [];
      const usedTransitions = (0, import_react4.useRef)(null);
      const prevTransitions = reset ? null : usedTransitions.current;
      (0, import_shared15.useIsomorphicLayoutEffect)(() => {
        usedTransitions.current = transitions;
      });
      (0, import_shared15.useOnce)(() => {
        (0, import_shared15.each)(transitions, (t) => {
          ref == null ? void 0 : ref.add(t.ctrl);
          t.ctrl.ref = ref;
        });
        return () => {
          (0, import_shared15.each)(usedTransitions.current, (t) => {
            if (t.expired) {
              clearTimeout(t.expirationId);
            }
            detachRefs(t.ctrl, ref);
            t.ctrl.stop(true);
          });
        };
      });
      const keys = getKeys(items, propsFn ? propsFn() : props, prevTransitions);
      const expired = reset && usedTransitions.current || [];
      (0, import_shared15.useIsomorphicLayoutEffect)(
        () => (0, import_shared15.each)(expired, ({ ctrl, item, key }) => {
          detachRefs(ctrl, ref);
          callProp(onDestroyed, item, key);
        })
      );
      const reused = [];
      if (prevTransitions)
        (0, import_shared15.each)(prevTransitions, (t, i) => {
          if (t.expired) {
            clearTimeout(t.expirationId);
            expired.push(t);
          } else {
            i = reused[i] = keys.indexOf(t.key);
            if (~i)
              transitions[i] = t;
          }
        });
      (0, import_shared15.each)(items, (item, i) => {
        if (!transitions[i]) {
          transitions[i] = {
            key: keys[i],
            item,
            phase: "mount",
            ctrl: new Controller()
          };
          transitions[i].ctrl.item = item;
        }
      });
      if (reused.length) {
        let i = -1;
        const { leave } = propsFn ? propsFn() : props;
        (0, import_shared15.each)(reused, (keyIndex, prevIndex) => {
          const t = prevTransitions[prevIndex];
          if (~keyIndex) {
            i = transitions.indexOf(t);
            transitions[i] = { ...t, item: items[keyIndex] };
          } else if (leave) {
            transitions.splice(++i, 0, t);
          }
        });
      }
      if (import_shared15.is.fun(sort)) {
        transitions.sort((a, b) => sort(a.item, b.item));
      }
      let delay = -trail;
      const forceUpdate = (0, import_shared15.useForceUpdate)();
      const defaultProps = getDefaultProps(props);
      const changes = /* @__PURE__ */ new Map();
      const exitingTransitions = (0, import_react4.useRef)(/* @__PURE__ */ new Map());
      const forceChange = (0, import_react4.useRef)(false);
      (0, import_shared15.each)(transitions, (t, i) => {
        const key = t.key;
        const prevPhase = t.phase;
        const p = propsFn ? propsFn() : props;
        let to2;
        let phase;
        const propsDelay = callProp(p.delay || 0, key);
        if (prevPhase == "mount") {
          to2 = p.enter;
          phase = "enter";
        } else {
          const isLeave = keys.indexOf(key) < 0;
          if (prevPhase != "leave") {
            if (isLeave) {
              to2 = p.leave;
              phase = "leave";
            } else if (to2 = p.update) {
              phase = "update";
            } else
              return;
          } else if (!isLeave) {
            to2 = p.enter;
            phase = "enter";
          } else
            return;
        }
        to2 = callProp(to2, t.item, i);
        to2 = import_shared15.is.obj(to2) ? inferTo(to2) : { to: to2 };
        if (!to2.config) {
          const config2 = propsConfig || defaultProps.config;
          to2.config = callProp(config2, t.item, i, phase);
        }
        delay += trail;
        const payload = {
          ...defaultProps,
          // we need to add our props.delay value you here.
          delay: propsDelay + delay,
          ref: propsRef,
          immediate: p.immediate,
          // This prevents implied resets.
          reset: false,
          // Merge any phase-specific props.
          ...to2
        };
        if (phase == "enter" && import_shared15.is.und(payload.from)) {
          const p2 = propsFn ? propsFn() : props;
          const from = import_shared15.is.und(p2.initial) || prevTransitions ? p2.from : p2.initial;
          payload.from = callProp(from, t.item, i);
        }
        const { onResolve } = payload;
        payload.onResolve = (result) => {
          callProp(onResolve, result);
          const transitions2 = usedTransitions.current;
          const t2 = transitions2.find((t3) => t3.key === key);
          if (!t2)
            return;
          if (result.cancelled && t2.phase != "update") {
            return;
          }
          if (t2.ctrl.idle) {
            const idle = transitions2.every((t3) => t3.ctrl.idle);
            if (t2.phase == "leave") {
              const expiry = callProp(expires, t2.item);
              if (expiry !== false) {
                const expiryMs = expiry === true ? 0 : expiry;
                t2.expired = true;
                if (!idle && expiryMs > 0) {
                  if (expiryMs <= 2147483647)
                    t2.expirationId = setTimeout(forceUpdate, expiryMs);
                  return;
                }
              }
            }
            if (idle && transitions2.some((t3) => t3.expired)) {
              exitingTransitions.current.delete(t2);
              if (exitBeforeEnter) {
                forceChange.current = true;
              }
              forceUpdate();
            }
          }
        };
        const springs = getSprings(t.ctrl, payload);
        if (phase === "leave" && exitBeforeEnter) {
          exitingTransitions.current.set(t, { phase, springs, payload });
        } else {
          changes.set(t, { phase, springs, payload });
        }
      });
      const context = (0, import_react4.useContext)(SpringContext);
      const prevContext = (0, import_shared15.usePrev)(context);
      const hasContext = context !== prevContext && hasProps(context);
      (0, import_shared15.useIsomorphicLayoutEffect)(() => {
        if (hasContext) {
          (0, import_shared15.each)(transitions, (t) => {
            t.ctrl.start({ default: context });
          });
        }
      }, [context]);
      (0, import_shared15.each)(changes, (_, t) => {
        if (exitingTransitions.current.size) {
          const ind = transitions.findIndex((state) => state.key === t.key);
          transitions.splice(ind, 1);
        }
      });
      (0, import_shared15.useIsomorphicLayoutEffect)(
        () => {
          (0, import_shared15.each)(
            exitingTransitions.current.size ? exitingTransitions.current : changes,
            ({ phase, payload }, t) => {
              const { ctrl } = t;
              t.phase = phase;
              ref == null ? void 0 : ref.add(ctrl);
              if (hasContext && phase == "enter") {
                ctrl.start({ default: context });
              }
              if (payload) {
                replaceRef(ctrl, payload.ref);
                if ((ctrl.ref || ref) && !forceChange.current) {
                  ctrl.update(payload);
                } else {
                  ctrl.start(payload);
                  if (forceChange.current) {
                    forceChange.current = false;
                  }
                }
              }
            }
          );
        },
        reset ? void 0 : deps
      );
      const renderTransitions = (render) => React22.createElement(React22.Fragment, null, transitions.map((t, i) => {
        const { springs } = changes.get(t) || t.ctrl;
        const elem = render({ ...springs }, t.item, t, i);
        return elem && elem.type ? React22.createElement(
          elem.type,
          {
            ...elem.props,
            key: import_shared15.is.str(t.key) || import_shared15.is.num(t.key) ? t.key : t.ctrl.id,
            ref: elem.ref
          }
        ) : elem;
      }));
      return ref ? [renderTransitions, ref] : renderTransitions;
    }
    var nextKey = 1;
    function getKeys(items, { key, keys = key }, prevTransitions) {
      if (keys === null) {
        const reused = /* @__PURE__ */ new Set();
        return items.map((item) => {
          const t = prevTransitions && prevTransitions.find(
            (t2) => t2.item === item && t2.phase !== "leave" && !reused.has(t2)
          );
          if (t) {
            reused.add(t);
            return t.key;
          }
          return nextKey++;
        });
      }
      return import_shared15.is.und(keys) ? items : import_shared15.is.fun(keys) ? items.map(keys) : (0, import_shared15.toArray)(keys);
    }
    var import_shared16 = require_cjs2();
    var useScroll = ({
      container,
      ...springOptions
    } = {}) => {
      const [scrollValues, api] = useSpring(
        () => ({
          scrollX: 0,
          scrollY: 0,
          scrollXProgress: 0,
          scrollYProgress: 0,
          ...springOptions
        }),
        []
      );
      (0, import_shared16.useIsomorphicLayoutEffect)(() => {
        const cleanupScroll = (0, import_shared16.onScroll)(
          ({ x, y }) => {
            api.start({
              scrollX: x.current,
              scrollXProgress: x.progress,
              scrollY: y.current,
              scrollYProgress: y.progress
            });
          },
          { container: (container == null ? void 0 : container.current) || void 0 }
        );
        return () => {
          (0, import_shared16.each)(Object.values(scrollValues), (value) => value.stop());
          cleanupScroll();
        };
      }, []);
      return scrollValues;
    };
    var import_shared17 = require_cjs2();
    var useResize = ({
      container,
      ...springOptions
    }) => {
      const [sizeValues, api] = useSpring(
        () => ({
          width: 0,
          height: 0,
          ...springOptions
        }),
        []
      );
      (0, import_shared17.useIsomorphicLayoutEffect)(() => {
        const cleanupScroll = (0, import_shared17.onResize)(
          ({ width, height }) => {
            api.start({
              width,
              height,
              immediate: sizeValues.width.get() === 0 || sizeValues.height.get() === 0
            });
          },
          { container: (container == null ? void 0 : container.current) || void 0 }
        );
        return () => {
          (0, import_shared17.each)(Object.values(sizeValues), (value) => value.stop());
          cleanupScroll();
        };
      }, []);
      return sizeValues;
    };
    var import_react5 = require_react();
    var import_shared18 = require_cjs2();
    var defaultThresholdOptions = {
      any: 0,
      all: 1
    };
    function useInView(props, args) {
      const [isInView, setIsInView] = (0, import_react5.useState)(false);
      const ref = (0, import_react5.useRef)();
      const propsFn = import_shared18.is.fun(props) && props;
      const springsProps = propsFn ? propsFn() : {};
      const { to: to2 = {}, from = {}, ...restSpringProps } = springsProps;
      const intersectionArguments = propsFn ? args : props;
      const [springs, api] = useSpring(() => ({ from, ...restSpringProps }), []);
      (0, import_shared18.useIsomorphicLayoutEffect)(() => {
        const element = ref.current;
        const {
          root,
          once,
          amount = "any",
          ...restArgs
        } = intersectionArguments ?? {};
        if (!element || once && isInView || typeof IntersectionObserver === "undefined")
          return;
        const activeIntersections = /* @__PURE__ */ new WeakMap();
        const onEnter = () => {
          if (to2) {
            api.start(to2);
          }
          setIsInView(true);
          const cleanup = () => {
            if (from) {
              api.start(from);
            }
            setIsInView(false);
          };
          return once ? void 0 : cleanup;
        };
        const handleIntersection = (entries) => {
          entries.forEach((entry) => {
            const onLeave = activeIntersections.get(entry.target);
            if (entry.isIntersecting === Boolean(onLeave)) {
              return;
            }
            if (entry.isIntersecting) {
              const newOnLeave = onEnter();
              if (import_shared18.is.fun(newOnLeave)) {
                activeIntersections.set(entry.target, newOnLeave);
              } else {
                observer.unobserve(entry.target);
              }
            } else if (onLeave) {
              onLeave();
              activeIntersections.delete(entry.target);
            }
          });
        };
        const observer = new IntersectionObserver(handleIntersection, {
          root: root && root.current || void 0,
          threshold: typeof amount === "number" || Array.isArray(amount) ? amount : defaultThresholdOptions[amount],
          ...restArgs
        });
        observer.observe(element);
        return () => observer.unobserve(element);
      }, [intersectionArguments]);
      if (propsFn) {
        return [ref, springs];
      }
      return [ref, isInView];
    }
    function Spring({ children, ...props }) {
      return children(useSpring(props));
    }
    var import_shared19 = require_cjs2();
    function Trail({
      items,
      children,
      ...props
    }) {
      const trails = useTrail(items.length, props);
      return items.map((item, index) => {
        const result = children(item, index);
        return import_shared19.is.fun(result) ? result(trails[index]) : result;
      });
    }
    function Transition({
      items,
      children,
      ...props
    }) {
      return useTransition(items, props)(children);
    }
    var import_shared21 = require_cjs2();
    var import_shared20 = require_cjs2();
    var import_animated3 = require_cjs3();
    var Interpolation = class extends FrameValue {
      constructor(source, args) {
        super();
        this.source = source;
        this.idle = true;
        this._active = /* @__PURE__ */ new Set();
        this.calc = (0, import_shared20.createInterpolator)(...args);
        const value = this._get();
        const nodeType = (0, import_animated3.getAnimatedType)(value);
        (0, import_animated3.setAnimated)(this, nodeType.create(value));
      }
      advance(_dt) {
        const value = this._get();
        const oldValue = this.get();
        if (!(0, import_shared20.isEqual)(value, oldValue)) {
          (0, import_animated3.getAnimated)(this).setValue(value);
          this._onChange(value, this.idle);
        }
        if (!this.idle && checkIdle(this._active)) {
          becomeIdle(this);
        }
      }
      _get() {
        const inputs = import_shared20.is.arr(this.source) ? this.source.map(import_shared20.getFluidValue) : (0, import_shared20.toArray)((0, import_shared20.getFluidValue)(this.source));
        return this.calc(...inputs);
      }
      _start() {
        if (this.idle && !checkIdle(this._active)) {
          this.idle = false;
          (0, import_shared20.each)((0, import_animated3.getPayload)(this), (node) => {
            node.done = false;
          });
          if (import_shared20.Globals.skipAnimation) {
            import_shared20.raf.batchedUpdates(() => this.advance());
            becomeIdle(this);
          } else {
            import_shared20.frameLoop.start(this);
          }
        }
      }
      // Observe our sources only when we're observed.
      _attach() {
        let priority = 1;
        (0, import_shared20.each)((0, import_shared20.toArray)(this.source), (source) => {
          if ((0, import_shared20.hasFluidValue)(source)) {
            (0, import_shared20.addFluidObserver)(source, this);
          }
          if (isFrameValue(source)) {
            if (!source.idle) {
              this._active.add(source);
            }
            priority = Math.max(priority, source.priority + 1);
          }
        });
        this.priority = priority;
        this._start();
      }
      // Stop observing our sources once we have no observers.
      _detach() {
        (0, import_shared20.each)((0, import_shared20.toArray)(this.source), (source) => {
          if ((0, import_shared20.hasFluidValue)(source)) {
            (0, import_shared20.removeFluidObserver)(source, this);
          }
        });
        this._active.clear();
        becomeIdle(this);
      }
      /** @internal */
      eventObserved(event) {
        if (event.type == "change") {
          if (event.idle) {
            this.advance();
          } else {
            this._active.add(event.parent);
            this._start();
          }
        } else if (event.type == "idle") {
          this._active.delete(event.parent);
        } else if (event.type == "priority") {
          this.priority = (0, import_shared20.toArray)(this.source).reduce(
            (highest, parent) => Math.max(highest, (isFrameValue(parent) ? parent.priority : 0) + 1),
            0
          );
        }
      }
    };
    function isIdle(source) {
      return source.idle !== false;
    }
    function checkIdle(active) {
      return !active.size || Array.from(active).every(isIdle);
    }
    function becomeIdle(self) {
      if (!self.idle) {
        self.idle = true;
        (0, import_shared20.each)((0, import_animated3.getPayload)(self), (node) => {
          node.done = true;
        });
        (0, import_shared20.callFluidObservers)(self, {
          type: "idle",
          parent: self
        });
      }
    }
    var to = (source, ...args) => new Interpolation(source, args);
    var interpolate = (source, ...args) => ((0, import_shared21.deprecateInterpolate)(), new Interpolation(source, args));
    var import_shared22 = require_cjs2();
    import_shared22.Globals.assign({
      createStringInterpolator: import_shared22.createStringInterpolator,
      to: (source, args) => new Interpolation(source, args)
    });
    var update = import_shared22.frameLoop.advance;
    var import_shared23 = require_cjs2();
    __reExport(src_exports, require_cjs4(), module.exports);
  }
});

// node_modules/@react-spring/core/dist/cjs/index.js
var require_cjs5 = __commonJS({
  "node_modules/@react-spring/core/dist/cjs/index.js"(exports, module) {
    "use strict";
    var import_dist10 = __toESM(require_dist());
    var import_dist11 = __toESM(require_dist2());
    var import_dist12 = __toESM(require_dist3());
    if (process.env.NODE_ENV === "production") {
      module.exports = require_react_spring_core_production_min();
    } else {
      module.exports = require_react_spring_core_development();
    }
  }
});

// node_modules/@react-spring/web/dist/cjs/react-spring_web.production.min.cjs
var require_react_spring_web_production_min = __commonJS({
  "node_modules/@react-spring/web/dist/cjs/react-spring_web.production.min.cjs"(exports, module) {
    "use strict";
    var import_dist10 = __toESM(require_dist());
    var import_dist11 = __toESM(require_dist2());
    var import_dist12 = __toESM(require_dist3());
    var k = Object.defineProperty;
    var T = Object.getOwnPropertyDescriptor;
    var j = Object.getOwnPropertyNames;
    var N = Object.prototype.hasOwnProperty;
    var R = (t, e2) => {
      for (var o in e2) k(t, o, { get: e2[o], enumerable: true });
    };
    var v = (t, e2, o, i) => {
      if (e2 && typeof e2 == "object" || typeof e2 == "function") for (let s of j(e2)) !N.call(t, s) && s !== o && k(t, s, { get: () => e2[s], enumerable: !(i = T(e2, s)) || i.enumerable });
      return t;
    };
    var l = (t, e2, o) => (v(t, e2, "default"), o && v(o, e2, "default"));
    var W = (t) => v(k({}, "__esModule", { value: true }), t);
    var u = {};
    R(u, { a: () => q, animated: () => q });
    module.exports = W(u);
    var S = require_cjs5();
    var E = require_react_dom();
    var O = require_cjs2();
    var P = require_cjs3();
    var C = /^--/;
    function _(t, e2) {
      return e2 == null || typeof e2 == "boolean" || e2 === "" ? "" : typeof e2 == "number" && e2 !== 0 && !C.test(t) && !(g.hasOwnProperty(t) && g[t]) ? e2 + "px" : ("" + e2).trim();
    }
    var A = {};
    function I(t, e2) {
      if (!t.nodeType || !t.setAttribute) return false;
      let o = t.nodeName === "filter" || t.parentNode && t.parentNode.nodeName === "filter", { className: i, style: s, children: d, scrollTop: m, scrollLeft: p, viewBox: a, ...f } = e2, b = Object.values(f), h = Object.keys(f).map((n) => o || t.hasAttribute(n) ? n : A[n] || (A[n] = n.replace(/([A-Z])/g, (c) => "-" + c.toLowerCase())));
      d !== void 0 && (t.textContent = d);
      for (let n in s) if (s.hasOwnProperty(n)) {
        let c = _(n, s[n]);
        C.test(n) ? t.style.setProperty(n, c) : t.style[n] = c;
      }
      h.forEach((n, c) => {
        t.setAttribute(n, b[c]);
      }), i !== void 0 && (t.className = i), m !== void 0 && (t.scrollTop = m), p !== void 0 && (t.scrollLeft = p), a !== void 0 && t.setAttribute("viewBox", a);
    }
    var g = { animationIterationCount: true, borderImageOutset: true, borderImageSlice: true, borderImageWidth: true, boxFlex: true, boxFlexGroup: true, boxOrdinalGroup: true, columnCount: true, columns: true, flex: true, flexGrow: true, flexPositive: true, flexShrink: true, flexNegative: true, flexOrder: true, gridRow: true, gridRowEnd: true, gridRowSpan: true, gridRowStart: true, gridColumn: true, gridColumnEnd: true, gridColumnSpan: true, gridColumnStart: true, fontWeight: true, lineClamp: true, lineHeight: true, opacity: true, order: true, orphans: true, tabSize: true, widows: true, zIndex: true, zoom: true, fillOpacity: true, floodOpacity: true, stopOpacity: true, strokeDasharray: true, strokeDashoffset: true, strokeMiterlimit: true, strokeOpacity: true, strokeWidth: true };
    var $ = (t, e2) => t + e2.charAt(0).toUpperCase() + e2.substring(1);
    var G = ["Webkit", "Ms", "Moz", "O"];
    g = Object.keys(g).reduce((t, e2) => (G.forEach((o) => t[$(o, e2)] = t[e2]), t), g);
    var F = require_cjs3();
    var r2 = require_cjs2();
    var M = /^(matrix|translate|scale|rotate|skew)/;
    var U = /^(translate)/;
    var D = /^(rotate|skew)/;
    var V = (t, e2) => r2.is.num(t) && t !== 0 ? t + e2 : t;
    var y = (t, e2) => r2.is.arr(t) ? t.every((o) => y(o, e2)) : r2.is.num(t) ? t === e2 : parseFloat(t) === e2;
    var x = class extends F.AnimatedObject {
      constructor({ x: e2, y: o, z: i, ...s }) {
        let d = [], m = [];
        (e2 || o || i) && (d.push([e2 || 0, o || 0, i || 0]), m.push((p) => [`translate3d(${p.map((a) => V(a, "px")).join(",")})`, y(p, 0)])), (0, r2.eachProp)(s, (p, a) => {
          if (a === "transform") d.push([p || ""]), m.push((f) => [f, f === ""]);
          else if (M.test(a)) {
            if (delete s[a], r2.is.und(p)) return;
            let f = U.test(a) ? "px" : D.test(a) ? "deg" : "";
            d.push((0, r2.toArray)(p)), m.push(a === "rotate3d" ? ([b, h, n, c]) => [`rotate3d(${b},${h},${n},${V(c, f)})`, y(c, 0)] : (b) => [`${a}(${b.map((h) => V(h, f)).join(",")})`, y(b, a.startsWith("scale") ? 1 : 0)]);
          }
        }), d.length && (s.transform = new w(d, m)), super(s);
      }
    };
    var w = class extends r2.FluidValue {
      constructor(o, i) {
        super();
        this.inputs = o;
        this.transforms = i;
        this._value = null;
      }
      get() {
        return this._value || (this._value = this._get());
      }
      _get() {
        let o = "", i = true;
        return (0, r2.each)(this.inputs, (s, d) => {
          let m = (0, r2.getFluidValue)(s[0]), [p, a] = this.transforms[d](r2.is.arr(m) ? m : s.map(r2.getFluidValue));
          o += " " + p, i = i && a;
        }), i ? "none" : o;
      }
      observerAdded(o) {
        o == 1 && (0, r2.each)(this.inputs, (i) => (0, r2.each)(i, (s) => (0, r2.hasFluidValue)(s) && (0, r2.addFluidObserver)(s, this)));
      }
      observerRemoved(o) {
        o == 0 && (0, r2.each)(this.inputs, (i) => (0, r2.each)(i, (s) => (0, r2.hasFluidValue)(s) && (0, r2.removeFluidObserver)(s, this)));
      }
      eventObserved(o) {
        o.type == "change" && (this._value = null), (0, r2.callFluidObservers)(this, o);
      }
    };
    var L = ["a", "abbr", "address", "area", "article", "aside", "audio", "b", "base", "bdi", "bdo", "big", "blockquote", "body", "br", "button", "canvas", "caption", "cite", "code", "col", "colgroup", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "keygen", "label", "legend", "li", "link", "main", "map", "mark", "menu", "menuitem", "meta", "meter", "nav", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "script", "section", "select", "small", "source", "span", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "u", "ul", "var", "video", "wbr", "circle", "clipPath", "defs", "ellipse", "foreignObject", "g", "image", "line", "linearGradient", "mask", "path", "pattern", "polygon", "polyline", "radialGradient", "rect", "stop", "svg", "text", "tspan"];
    l(u, require_cjs5(), module.exports);
    S.Globals.assign({ batchedUpdates: E.unstable_batchedUpdates, createStringInterpolator: O.createStringInterpolator, colors: O.colors });
    var H = (0, P.createHost)(L, { applyAnimatedValues: I, createAnimatedStyle: (t) => new x(t), getComponentProps: ({ scrollTop: t, scrollLeft: e2, ...o }) => o });
    var q = H.animated;
  }
});

// node_modules/@react-spring/web/dist/cjs/react-spring_web.development.cjs
var require_react_spring_web_development = __commonJS({
  "node_modules/@react-spring/web/dist/cjs/react-spring_web.development.cjs"(exports, module) {
    "use strict";
    var import_dist10 = __toESM(require_dist());
    var import_dist11 = __toESM(require_dist2());
    var import_dist12 = __toESM(require_dist3());
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export2(src_exports, {
      a: () => animated,
      animated: () => animated
    });
    module.exports = __toCommonJS2(src_exports);
    var import_core = require_cjs5();
    var import_react_dom = require_react_dom();
    var import_shared2 = require_cjs2();
    var import_animated2 = require_cjs3();
    var isCustomPropRE = /^--/;
    function dangerousStyleValue(name, value) {
      if (value == null || typeof value === "boolean" || value === "")
        return "";
      if (typeof value === "number" && value !== 0 && !isCustomPropRE.test(name) && !(isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name]))
        return value + "px";
      return ("" + value).trim();
    }
    var attributeCache = {};
    function applyAnimatedValues(instance, props) {
      if (!instance.nodeType || !instance.setAttribute) {
        return false;
      }
      const isFilterElement = instance.nodeName === "filter" || instance.parentNode && instance.parentNode.nodeName === "filter";
      const {
        className,
        style,
        children,
        scrollTop,
        scrollLeft,
        viewBox,
        ...attributes
      } = props;
      const values = Object.values(attributes);
      const names = Object.keys(attributes).map(
        (name) => isFilterElement || instance.hasAttribute(name) ? name : attributeCache[name] || (attributeCache[name] = name.replace(
          /([A-Z])/g,
          // Attributes are written in dash case
          (n) => "-" + n.toLowerCase()
        ))
      );
      if (children !== void 0) {
        instance.textContent = children;
      }
      for (const name in style) {
        if (style.hasOwnProperty(name)) {
          const value = dangerousStyleValue(name, style[name]);
          if (isCustomPropRE.test(name)) {
            instance.style.setProperty(name, value);
          } else {
            instance.style[name] = value;
          }
        }
      }
      names.forEach((name, i) => {
        instance.setAttribute(name, values[i]);
      });
      if (className !== void 0) {
        instance.className = className;
      }
      if (scrollTop !== void 0) {
        instance.scrollTop = scrollTop;
      }
      if (scrollLeft !== void 0) {
        instance.scrollLeft = scrollLeft;
      }
      if (viewBox !== void 0) {
        instance.setAttribute("viewBox", viewBox);
      }
    }
    var isUnitlessNumber = {
      animationIterationCount: true,
      borderImageOutset: true,
      borderImageSlice: true,
      borderImageWidth: true,
      boxFlex: true,
      boxFlexGroup: true,
      boxOrdinalGroup: true,
      columnCount: true,
      columns: true,
      flex: true,
      flexGrow: true,
      flexPositive: true,
      flexShrink: true,
      flexNegative: true,
      flexOrder: true,
      gridRow: true,
      gridRowEnd: true,
      gridRowSpan: true,
      gridRowStart: true,
      gridColumn: true,
      gridColumnEnd: true,
      gridColumnSpan: true,
      gridColumnStart: true,
      fontWeight: true,
      lineClamp: true,
      lineHeight: true,
      opacity: true,
      order: true,
      orphans: true,
      tabSize: true,
      widows: true,
      zIndex: true,
      zoom: true,
      // SVG-related properties
      fillOpacity: true,
      floodOpacity: true,
      stopOpacity: true,
      strokeDasharray: true,
      strokeDashoffset: true,
      strokeMiterlimit: true,
      strokeOpacity: true,
      strokeWidth: true
    };
    var prefixKey = (prefix, key) => prefix + key.charAt(0).toUpperCase() + key.substring(1);
    var prefixes = ["Webkit", "Ms", "Moz", "O"];
    isUnitlessNumber = Object.keys(isUnitlessNumber).reduce((acc, prop) => {
      prefixes.forEach((prefix) => acc[prefixKey(prefix, prop)] = acc[prop]);
      return acc;
    }, isUnitlessNumber);
    var import_animated = require_cjs3();
    var import_shared = require_cjs2();
    var domTransforms = /^(matrix|translate|scale|rotate|skew)/;
    var pxTransforms = /^(translate)/;
    var degTransforms = /^(rotate|skew)/;
    var addUnit = (value, unit) => import_shared.is.num(value) && value !== 0 ? value + unit : value;
    var isValueIdentity = (value, id) => import_shared.is.arr(value) ? value.every((v) => isValueIdentity(v, id)) : import_shared.is.num(value) ? value === id : parseFloat(value) === id;
    var AnimatedStyle = class extends import_animated.AnimatedObject {
      constructor({ x, y, z, ...style }) {
        const inputs = [];
        const transforms = [];
        if (x || y || z) {
          inputs.push([x || 0, y || 0, z || 0]);
          transforms.push((xyz) => [
            `translate3d(${xyz.map((v) => addUnit(v, "px")).join(",")})`,
            // prettier-ignore
            isValueIdentity(xyz, 0)
          ]);
        }
        (0, import_shared.eachProp)(style, (value, key) => {
          if (key === "transform") {
            inputs.push([value || ""]);
            transforms.push((transform) => [transform, transform === ""]);
          } else if (domTransforms.test(key)) {
            delete style[key];
            if (import_shared.is.und(value))
              return;
            const unit = pxTransforms.test(key) ? "px" : degTransforms.test(key) ? "deg" : "";
            inputs.push((0, import_shared.toArray)(value));
            transforms.push(
              key === "rotate3d" ? ([x2, y2, z2, deg]) => [
                `rotate3d(${x2},${y2},${z2},${addUnit(deg, unit)})`,
                isValueIdentity(deg, 0)
              ] : (input) => [
                `${key}(${input.map((v) => addUnit(v, unit)).join(",")})`,
                isValueIdentity(input, key.startsWith("scale") ? 1 : 0)
              ]
            );
          }
        });
        if (inputs.length) {
          style.transform = new FluidTransform(inputs, transforms);
        }
        super(style);
      }
    };
    var FluidTransform = class extends import_shared.FluidValue {
      constructor(inputs, transforms) {
        super();
        this.inputs = inputs;
        this.transforms = transforms;
        this._value = null;
      }
      get() {
        return this._value || (this._value = this._get());
      }
      _get() {
        let transform = "";
        let identity = true;
        (0, import_shared.each)(this.inputs, (input, i) => {
          const arg1 = (0, import_shared.getFluidValue)(input[0]);
          const [t, id] = this.transforms[i](
            import_shared.is.arr(arg1) ? arg1 : input.map(import_shared.getFluidValue)
          );
          transform += " " + t;
          identity = identity && id;
        });
        return identity ? "none" : transform;
      }
      // Start observing our inputs once we have an observer.
      observerAdded(count) {
        if (count == 1)
          (0, import_shared.each)(
            this.inputs,
            (input) => (0, import_shared.each)(
              input,
              (value) => (0, import_shared.hasFluidValue)(value) && (0, import_shared.addFluidObserver)(value, this)
            )
          );
      }
      // Stop observing our inputs once we have no observers.
      observerRemoved(count) {
        if (count == 0)
          (0, import_shared.each)(
            this.inputs,
            (input) => (0, import_shared.each)(
              input,
              (value) => (0, import_shared.hasFluidValue)(value) && (0, import_shared.removeFluidObserver)(value, this)
            )
          );
      }
      eventObserved(event) {
        if (event.type == "change") {
          this._value = null;
        }
        (0, import_shared.callFluidObservers)(this, event);
      }
    };
    var primitives = [
      "a",
      "abbr",
      "address",
      "area",
      "article",
      "aside",
      "audio",
      "b",
      "base",
      "bdi",
      "bdo",
      "big",
      "blockquote",
      "body",
      "br",
      "button",
      "canvas",
      "caption",
      "cite",
      "code",
      "col",
      "colgroup",
      "data",
      "datalist",
      "dd",
      "del",
      "details",
      "dfn",
      "dialog",
      "div",
      "dl",
      "dt",
      "em",
      "embed",
      "fieldset",
      "figcaption",
      "figure",
      "footer",
      "form",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "head",
      "header",
      "hgroup",
      "hr",
      "html",
      "i",
      "iframe",
      "img",
      "input",
      "ins",
      "kbd",
      "keygen",
      "label",
      "legend",
      "li",
      "link",
      "main",
      "map",
      "mark",
      "menu",
      "menuitem",
      "meta",
      "meter",
      "nav",
      "noscript",
      "object",
      "ol",
      "optgroup",
      "option",
      "output",
      "p",
      "param",
      "picture",
      "pre",
      "progress",
      "q",
      "rp",
      "rt",
      "ruby",
      "s",
      "samp",
      "script",
      "section",
      "select",
      "small",
      "source",
      "span",
      "strong",
      "style",
      "sub",
      "summary",
      "sup",
      "table",
      "tbody",
      "td",
      "textarea",
      "tfoot",
      "th",
      "thead",
      "time",
      "title",
      "tr",
      "track",
      "u",
      "ul",
      "var",
      "video",
      "wbr",
      // SVG
      "circle",
      "clipPath",
      "defs",
      "ellipse",
      "foreignObject",
      "g",
      "image",
      "line",
      "linearGradient",
      "mask",
      "path",
      "pattern",
      "polygon",
      "polyline",
      "radialGradient",
      "rect",
      "stop",
      "svg",
      "text",
      "tspan"
    ];
    __reExport(src_exports, require_cjs5(), module.exports);
    import_core.Globals.assign({
      batchedUpdates: import_react_dom.unstable_batchedUpdates,
      createStringInterpolator: import_shared2.createStringInterpolator,
      colors: import_shared2.colors
    });
    var host = (0, import_animated2.createHost)(primitives, {
      applyAnimatedValues,
      createAnimatedStyle: (style) => new AnimatedStyle(style),
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      getComponentProps: ({ scrollTop, scrollLeft, ...props }) => props
    });
    var animated = host.animated;
  }
});

// node_modules/@react-spring/web/dist/cjs/index.js
var require_cjs6 = __commonJS({
  "node_modules/@react-spring/web/dist/cjs/index.js"(exports, module) {
    "use strict";
    var import_dist10 = __toESM(require_dist());
    var import_dist11 = __toESM(require_dist2());
    var import_dist12 = __toESM(require_dist3());
    if (process.env.NODE_ENV === "production") {
      module.exports = require_react_spring_web_production_min();
    } else {
      module.exports = require_react_spring_web_development();
    }
  }
});

// node_modules/@splunk/react-ui/AnimationToggle.js
var require_AnimationToggle = __commonJS({
  "node_modules/@splunk/react-ui/AnimationToggle.js"(exports, module) {
    var import_dist10 = __toESM(require_dist());
    var import_dist11 = __toESM(require_dist2());
    var import_dist12 = __toESM(require_dist3());
    (() => {
      "use strict";
      var e2 = {};
      (() => {
        e2.n = (r3) => {
          var n2 = r3 && r3.__esModule ? (
            /******/
            () => r3["default"]
          ) : () => r3;
          e2.d(n2, {
            a: n2
          });
          return n2;
        };
      })();
      (() => {
        e2.d = (r3, n2) => {
          for (var t2 in n2) {
            if (e2.o(n2, t2) && !e2.o(r3, t2)) {
              Object.defineProperty(r3, t2, {
                enumerable: true,
                get: n2[t2]
              });
            }
          }
        };
      })();
      (() => {
        e2.o = (e3, r3) => Object.prototype.hasOwnProperty.call(e3, r3);
      })();
      (() => {
        e2.r = (e3) => {
          if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
            Object.defineProperty(e3, Symbol.toStringTag, {
              value: "Module"
            });
          }
          Object.defineProperty(e3, "__esModule", {
            value: true
          });
        };
      })();
      var r2 = {};
      e2.r(r2);
      e2.d(r2, {
        AnimationToggleContext: () => (
          /* reexport */
          u
        ),
        AnimationToggleProvider: () => (
          /* reexport */
          h
        ),
        default: () => (
          /* reexport */
          b
        ),
        useAnimationToggle: () => (
          /* reexport */
          v
        )
      });
      const n = require_react();
      var t = e2.n(n);
      const o = require_prop_types();
      var a = e2.n(o);
      var u = t().createContext(true);
      function i(e3, r3) {
        return s(e3) || d(e3, r3) || c(e3, r3) || l();
      }
      function l() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      function c(e3, r3) {
        if (e3) {
          if ("string" == typeof e3) return f(e3, r3);
          var n2 = {}.toString.call(e3).slice(8, -1);
          return "Object" === n2 && e3.constructor && (n2 = e3.constructor.name), "Map" === n2 || "Set" === n2 ? Array.from(e3) : "Arguments" === n2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2) ? f(e3, r3) : void 0;
        }
      }
      function f(e3, r3) {
        (null == r3 || r3 > e3.length) && (r3 = e3.length);
        for (var n2 = 0, t2 = Array(r3); n2 < r3; n2++) {
          t2[n2] = e3[n2];
        }
        return t2;
      }
      function d(e3, r3) {
        var n2 = null == e3 ? null : "undefined" != typeof Symbol && e3[Symbol.iterator] || e3["@@iterator"];
        if (null != n2) {
          var t2, o2, a2, u2, i2 = [], l2 = true, c2 = false;
          try {
            if (a2 = (n2 = n2.call(e3)).next, 0 === r3) {
              if (Object(n2) !== n2) return;
              l2 = false;
            } else for (; !(l2 = (t2 = a2.call(n2)).done) && (i2.push(t2.value), i2.length !== r3); l2 = true) {
            }
          } catch (e4) {
            c2 = true, o2 = e4;
          } finally {
            try {
              if (!l2 && null != n2["return"] && (u2 = n2["return"](), Object(u2) !== u2)) return;
            } finally {
              if (c2) throw o2;
            }
          }
          return i2;
        }
      }
      function s(e3) {
        if (Array.isArray(e3)) return e3;
      }
      var v = function e3() {
        var r3 = (0, n.useContext)(u);
        var t2 = "screen and (prefers-reduced-motion: reduce)";
        var o2 = typeof window !== "undefined" && !!window.matchMedia;
        var a2 = (0, n.useState)(o2 && window.matchMedia(t2).matches), l2 = i(a2, 2), c2 = l2[0], f2 = l2[1];
        (0, n.useEffect)((function() {
          if (o2) {
            var e4 = window.matchMedia(t2);
            var r4 = function r5() {
              f2(e4.matches);
            };
            e4.addListener(r4);
            return function() {
              e4.removeListener(r4);
            };
          }
          return void 0;
        }), [o2, t2]);
        if (r3) {
          return c2 ? "reduced" : "on";
        }
        return "off";
      };
      var m = function e3(r3) {
        return typeof r3 === "function" ? r3() : r3;
      };
      var y = {
        on: a().oneOfType([a().node, a().func]).isRequired,
        off: a().oneOfType([a().node, a().func]).isRequired,
        reduced: a().oneOfType([a().node, a().func])
      };
      function p(e3) {
        var r3 = e3.on, n2 = e3.off, o2 = e3.reduced;
        var a2 = v();
        if (a2 === "on") {
          return t().createElement(t().Fragment, null, m(r3));
        }
        if (a2 === "reduced" && o2) {
          return t().createElement(t().Fragment, null, m(o2));
        }
        return t().createElement(t().Fragment, null, m(n2));
        return t().createElement(t().Fragment, null);
      }
      p.propTypes = y;
      const b = p;
      var g = {
        children: a().node,
        enabled: a().bool
      };
      var h = function e3(r3) {
        var n2 = r3.children, o2 = r3.enabled, a2 = o2 === void 0 ? false : o2;
        return t().createElement(u.Provider, {
          value: a2
        }, n2);
      };
      h.propTypes = g;
      module.exports = r2;
    })();
  }
});

// node_modules/@splunk/react-ui/Animation.js
var require_Animation = __commonJS({
  "node_modules/@splunk/react-ui/Animation.js"(exports, module) {
    var import_dist10 = __toESM(require_dist());
    var import_dist11 = __toESM(require_dist2());
    var import_dist12 = __toESM(require_dist3());
    (() => {
      "use strict";
      var e2 = {};
      (() => {
        e2.d = (r3, t2) => {
          for (var n2 in t2) {
            if (e2.o(t2, n2) && !e2.o(r3, n2)) {
              Object.defineProperty(r3, n2, {
                enumerable: true,
                get: t2[n2]
              });
            }
          }
        };
      })();
      (() => {
        e2.o = (e3, r3) => Object.prototype.hasOwnProperty.call(e3, r3);
      })();
      (() => {
        e2.r = (e3) => {
          if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
            Object.defineProperty(e3, Symbol.toStringTag, {
              value: "Module"
            });
          }
          Object.defineProperty(e3, "__esModule", {
            value: true
          });
        };
      })();
      var r2 = {};
      e2.r(r2);
      e2.d(r2, {
        Spring: () => (
          /* reexport */
          p
        ),
        Transition: () => (
          /* reexport */
          y
        ),
        useAnimation: () => (
          /* reexport */
          s
        ),
        useAnimationTransition: () => (
          /* reexport */
          b
        )
      });
      const t = require_cjs6();
      const n = require_AnimationToggle();
      function i(e3) {
        "@babel/helpers - typeof";
        return i = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
          return typeof e4;
        } : function(e4) {
          return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
        }, i(e3);
      }
      function o(e3, r3) {
        var t2 = Object.keys(e3);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e3);
          r3 && (n2 = n2.filter((function(r4) {
            return Object.getOwnPropertyDescriptor(e3, r4).enumerable;
          }))), t2.push.apply(t2, n2);
        }
        return t2;
      }
      function u(e3) {
        for (var r3 = 1; r3 < arguments.length; r3++) {
          var t2 = null != arguments[r3] ? arguments[r3] : {};
          r3 % 2 ? o(Object(t2), true).forEach((function(r4) {
            a(e3, r4, t2[r4]);
          })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t2)) : o(Object(t2)).forEach((function(r4) {
            Object.defineProperty(e3, r4, Object.getOwnPropertyDescriptor(t2, r4));
          }));
        }
        return e3;
      }
      function a(e3, r3, t2) {
        return (r3 = c(r3)) in e3 ? Object.defineProperty(e3, r3, {
          value: t2,
          enumerable: true,
          configurable: true,
          writable: true
        }) : e3[r3] = t2, e3;
      }
      function c(e3) {
        var r3 = l(e3, "string");
        return "symbol" == i(r3) ? r3 : r3 + "";
      }
      function l(e3, r3) {
        if ("object" != i(e3) || !e3) return e3;
        var t2 = e3[Symbol.toPrimitive];
        if (void 0 !== t2) {
          var n2 = t2.call(e3, r3 || "default");
          if ("object" != i(n2)) return n2;
          throw new TypeError("@@toPrimitive must return a primitive value.");
        }
        return ("string" === r3 ? String : Number)(e3);
      }
      function m(e3, r3) {
        if (null == e3) return {};
        var t2, n2, i2 = f(e3, r3);
        if (Object.getOwnPropertySymbols) {
          var o2 = Object.getOwnPropertySymbols(e3);
          for (n2 = 0; n2 < o2.length; n2++) {
            t2 = o2[n2], -1 === r3.indexOf(t2) && {}.propertyIsEnumerable.call(e3, t2) && (i2[t2] = e3[t2]);
          }
        }
        return i2;
      }
      function f(e3, r3) {
        if (null == e3) return {};
        var t2 = {};
        for (var n2 in e3) {
          if ({}.hasOwnProperty.call(e3, n2)) {
            if (-1 !== r3.indexOf(n2)) continue;
            t2[n2] = e3[n2];
          }
        }
        return t2;
      }
      function s(e3) {
        var r3 = e3.immediate, i2 = m(e3, ["immediate"]);
        var o2 = (0, n.useAnimationToggle)();
        return (0, t.useSpring)(u({
          immediate: r3 || o2 !== "on"
        }, i2));
      }
      function b(e3, r3) {
        var i2 = r3.immediate, o2 = m(r3, ["immediate"]);
        var a2 = (0, n.useAnimationToggle)();
        return (0, t.useTransition)(e3, u({
          immediate: i2 || a2 !== "on"
        }, o2));
      }
      function p(e3) {
        var r3 = e3.children, i2 = e3.immediate, o2 = m(e3, ["children", "immediate"]);
        var a2 = (0, n.useAnimationToggle)();
        return r3((0, t.useSpring)(u({
          immediate: i2 || a2 !== "on"
        }, o2)));
      }
      function y(e3) {
        var r3 = e3.items, i2 = e3.children, o2 = e3.immediate, a2 = m(e3, ["items", "children", "immediate"]);
        var c2 = (0, n.useAnimationToggle)();
        return (0, t.useTransition)(r3, u({
          immediate: o2 || c2 !== "on"
        }, a2))(i2);
      }
      module.exports = r2;
    })();
  }
});

// node_modules/dequal/dist/index.mjs
function find(iter, tar, key) {
  for (key of iter.keys()) {
    if (dequal(key, tar)) return key;
  }
}
function dequal(foo, bar) {
  var ctor, len, tmp;
  if (foo === bar) return true;
  if (foo && bar && (ctor = foo.constructor) === bar.constructor) {
    if (ctor === Date) return foo.getTime() === bar.getTime();
    if (ctor === RegExp) return foo.toString() === bar.toString();
    if (ctor === Array) {
      if ((len = foo.length) === bar.length) {
        while (len-- && dequal(foo[len], bar[len])) ;
      }
      return len === -1;
    }
    if (ctor === Set) {
      if (foo.size !== bar.size) {
        return false;
      }
      for (len of foo) {
        tmp = len;
        if (tmp && typeof tmp === "object") {
          tmp = find(bar, tmp);
          if (!tmp) return false;
        }
        if (!bar.has(tmp)) return false;
      }
      return true;
    }
    if (ctor === Map) {
      if (foo.size !== bar.size) {
        return false;
      }
      for (len of foo) {
        tmp = len[0];
        if (tmp && typeof tmp === "object") {
          tmp = find(bar, tmp);
          if (!tmp) return false;
        }
        if (!dequal(len[1], bar.get(tmp))) {
          return false;
        }
      }
      return true;
    }
    if (ctor === ArrayBuffer) {
      foo = new Uint8Array(foo);
      bar = new Uint8Array(bar);
    } else if (ctor === DataView) {
      if ((len = foo.byteLength) === bar.byteLength) {
        while (len-- && foo.getInt8(len) === bar.getInt8(len)) ;
      }
      return len === -1;
    }
    if (ArrayBuffer.isView(foo)) {
      if ((len = foo.byteLength) === bar.byteLength) {
        while (len-- && foo[len] === bar[len]) ;
      }
      return len === -1;
    }
    if (!ctor || typeof foo === "object") {
      len = 0;
      for (ctor in foo) {
        if (has.call(foo, ctor) && ++len && !has.call(bar, ctor)) return false;
        if (!(ctor in bar) || !dequal(foo[ctor], bar[ctor])) return false;
      }
      return Object.keys(bar).length === len;
    }
  }
  return foo !== foo && bar !== bar;
}
var import_dist, import_dist2, import_dist3, has;
var init_dist = __esm({
  "node_modules/dequal/dist/index.mjs"() {
    import_dist = __toESM(require_dist(), 1);
    import_dist2 = __toESM(require_dist2(), 1);
    import_dist3 = __toESM(require_dist3(), 1);
    has = Object.prototype.hasOwnProperty;
  }
});

// node_modules/use-deep-compare/dist-web/index.js
function useDeepCompareMemoize(dependencies) {
  const dependenciesRef = import_react.default.useRef(dependencies);
  const signalRef = import_react.default.useRef(0);
  if (!dequal(dependencies, dependenciesRef.current)) {
    dependenciesRef.current = dependencies;
    signalRef.current += 1;
  }
  return import_react.default.useMemo(() => dependenciesRef.current, [signalRef.current]);
}
function useDeepCompareMemo(factory, dependencies) {
  return import_react.default.useMemo(factory, useDeepCompareMemoize(dependencies));
}
var import_dist4, import_dist5, import_dist6, import_react;
var init_dist_web = __esm({
  "node_modules/use-deep-compare/dist-web/index.js"() {
    import_dist4 = __toESM(require_dist());
    import_dist5 = __toESM(require_dist2());
    import_dist6 = __toESM(require_dist3());
    import_react = __toESM(require_react());
    init_dist();
  }
});

// node_modules/use-typed-event-listener/dist/index.esm.js
var index_esm_exports = {};
__export(index_esm_exports, {
  default: () => index_esm_default
});
function index_esm_default(n, o, c, u) {
  const i = (0, import_react2.useRef)(c);
  i.current = c;
  const m = useDeepCompareMemo(() => u, [u]);
  (0, import_react2.useEffect)(() => {
    if (!n) return;
    const e2 = (e3) => i.current.call(n, e3);
    return n.addEventListener(o, e2, m), () => {
      n.removeEventListener(o, e2, m);
    };
  }, [n, o, m]);
}
var import_dist7, import_dist8, import_dist9, import_react2;
var init_index_esm = __esm({
  "node_modules/use-typed-event-listener/dist/index.esm.js"() {
    import_dist7 = __toESM(require_dist());
    import_dist8 = __toESM(require_dist2());
    import_dist9 = __toESM(require_dist3());
    import_react2 = __toESM(require_react());
    init_dist_web();
  }
});

// node_modules/@splunk/react-ui/EventListener.js
var require_EventListener = __commonJS({
  "node_modules/@splunk/react-ui/EventListener.js"(exports, module) {
    var import_dist10 = __toESM(require_dist());
    var import_dist11 = __toESM(require_dist2());
    var import_dist12 = __toESM(require_dist3());
    (() => {
      "use strict";
      var e2 = {};
      (() => {
        e2.n = (r3) => {
          var t2 = r3 && r3.__esModule ? (
            /******/
            () => r3["default"]
          ) : () => r3;
          e2.d(t2, {
            a: t2
          });
          return t2;
        };
      })();
      (() => {
        e2.d = (r3, t2) => {
          for (var n2 in t2) {
            if (e2.o(t2, n2) && !e2.o(r3, n2)) {
              Object.defineProperty(r3, n2, {
                enumerable: true,
                get: t2[n2]
              });
            }
          }
        };
      })();
      (() => {
        e2.o = (e3, r3) => Object.prototype.hasOwnProperty.call(e3, r3);
      })();
      (() => {
        e2.r = (e3) => {
          if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
            Object.defineProperty(e3, Symbol.toStringTag, {
              value: "Module"
            });
          }
          Object.defineProperty(e3, "__esModule", {
            value: true
          });
        };
      })();
      var r2 = {};
      e2.r(r2);
      e2.d(r2, {
        default: () => (
          /* reexport */
          s
        )
      });
      const t = require_react();
      var n = e2.n(t);
      const o = require_prop_types();
      var a = e2.n(o);
      const l = (init_index_esm(), __toCommonJS(index_esm_exports));
      var u = e2.n(l);
      var i = {
        children: a().node,
        target: a().oneOfType([a().object, a().string]),
        eventType: a().any,
        listener: a().func,
        options: a().oneOfType([a().object, a().bool])
      };
      function p(e3) {
        var r3 = e3.children, t2 = e3.target, o2 = e3.eventType, a2 = e3.listener, l2 = e3.options;
        u()(t2, o2, a2, l2);
        return n().createElement(n().Fragment, null, r3 || null);
      }
      p.propTypes = i;
      const s = p;
      module.exports = r2;
    })();
  }
});

// node_modules/lodash/_baseIndexOfWith.js
var require_baseIndexOfWith = __commonJS({
  "node_modules/lodash/_baseIndexOfWith.js"(exports, module) {
    var import_dist10 = __toESM(require_dist());
    var import_dist11 = __toESM(require_dist2());
    var import_dist12 = __toESM(require_dist3());
    function baseIndexOfWith(array, value, fromIndex, comparator) {
      var index = fromIndex - 1, length = array.length;
      while (++index < length) {
        if (comparator(array[index], value)) {
          return index;
        }
      }
      return -1;
    }
    module.exports = baseIndexOfWith;
  }
});

// node_modules/lodash/_basePullAll.js
var require_basePullAll = __commonJS({
  "node_modules/lodash/_basePullAll.js"(exports, module) {
    var import_dist10 = __toESM(require_dist());
    var import_dist11 = __toESM(require_dist2());
    var import_dist12 = __toESM(require_dist3());
    var arrayMap = require_arrayMap();
    var baseIndexOf = require_baseIndexOf();
    var baseIndexOfWith = require_baseIndexOfWith();
    var baseUnary = require_baseUnary();
    var copyArray = require_copyArray();
    var arrayProto = Array.prototype;
    var splice = arrayProto.splice;
    function basePullAll(array, values, iteratee, comparator) {
      var indexOf = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length = values.length, seen = array;
      if (array === values) {
        values = copyArray(values);
      }
      if (iteratee) {
        seen = arrayMap(array, baseUnary(iteratee));
      }
      while (++index < length) {
        var fromIndex = 0, value = values[index], computed = iteratee ? iteratee(value) : value;
        while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {
          if (seen !== array) {
            splice.call(seen, fromIndex, 1);
          }
          splice.call(array, fromIndex, 1);
        }
      }
      return array;
    }
    module.exports = basePullAll;
  }
});

// node_modules/lodash/pullAll.js
var require_pullAll = __commonJS({
  "node_modules/lodash/pullAll.js"(exports, module) {
    var import_dist10 = __toESM(require_dist());
    var import_dist11 = __toESM(require_dist2());
    var import_dist12 = __toESM(require_dist3());
    var basePullAll = require_basePullAll();
    function pullAll(array, values) {
      return array && array.length && values && values.length ? basePullAll(array, values) : array;
    }
    module.exports = pullAll;
  }
});

// node_modules/lodash/pull.js
var require_pull = __commonJS({
  "node_modules/lodash/pull.js"(exports, module) {
    var import_dist10 = __toESM(require_dist());
    var import_dist11 = __toESM(require_dist2());
    var import_dist12 = __toESM(require_dist3());
    var baseRest = require_baseRest();
    var pullAll = require_pullAll();
    var pull = baseRest(pullAll);
    module.exports = pull;
  }
});

// node_modules/@splunk/react-ui/Layer.js
var require_Layer = __commonJS({
  "node_modules/@splunk/react-ui/Layer.js"(exports, module) {
    var import_dist10 = __toESM(require_dist());
    var import_dist11 = __toESM(require_dist2());
    var import_dist12 = __toESM(require_dist3());
    (() => {
      "use strict";
      var e2 = {};
      (() => {
        e2.n = (t2) => {
          var n2 = t2 && t2.__esModule ? (
            /******/
            () => t2["default"]
          ) : () => t2;
          e2.d(n2, {
            a: n2
          });
          return n2;
        };
      })();
      (() => {
        e2.d = (t2, n2) => {
          for (var r3 in n2) {
            if (e2.o(n2, r3) && !e2.o(t2, r3)) {
              Object.defineProperty(t2, r3, {
                enumerable: true,
                get: n2[r3]
              });
            }
          }
        };
      })();
      (() => {
        e2.o = (e3, t2) => Object.prototype.hasOwnProperty.call(e3, t2);
      })();
      (() => {
        e2.r = (e3) => {
          if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
            Object.defineProperty(e3, Symbol.toStringTag, {
              value: "Module"
            });
          }
          Object.defineProperty(e3, "__esModule", {
            value: true
          });
        };
      })();
      var t = {};
      e2.r(t);
      e2.d(t, {
        LayerContext: () => (
          /* reexport */
          b
        ),
        LayerStackContext: () => (
          /* reexport */
          g
        ),
        LayerStackGlobalProvider: () => (
          /* reexport */
          E
        ),
        default: () => (
          /* reexport */
          G
        )
      });
      const n = require_react();
      var r2 = e2.n(n);
      const o = require_includes();
      var a = e2.n(o);
      const i = require_last();
      var u = e2.n(i);
      const l = require_pull();
      var c = e2.n(l);
      const s = require_prop_types();
      var f = e2.n(s);
      const d = require_react_dom();
      const v = require_EventListener();
      var y = e2.n(v);
      const p = require_usePrevious();
      var m = e2.n(p);
      const h = require_id();
      var g = r2().createContext([]);
      var b = r2().createContext({});
      var C = {
        children: f().node,
        name: f().string,
        scope: f().object,
        separateStackingContexts: f().bool
      };
      function E(e3) {
        var t2 = e3.children, o2 = e3.name, a2 = o2 === void 0 ? "__splunkui_layer_instances__" : o2, i2 = e3.scope, u2 = i2 === void 0 ? typeof window !== "undefined" ? window : globalThis : i2, l2 = e3.separateStackingContexts, c2 = l2 === void 0 ? false : l2;
        if (!u2[a2]) {
          u2[a2] = [];
        }
        var s2 = (0, n.useMemo)((function() {
          return {
            separateStackingContexts: c2
          };
        }), [c2]);
        return r2().createElement(g.Provider, {
          value: u2[a2]
        }, r2().createElement(b.Provider, {
          value: s2
        }, t2));
      }
      E.propTypes = C;
      const S = (init_styled_components_esm(), __toCommonJS(styled_components_esm_exports));
      var k = e2.n(S);
      const w = require_themes();
      var T = k().div.withConfig({
        displayName: "LayerStyles__StyledLayer",
        componentId: "ii6psl-0"
      })(["", ""], (function(e3) {
        var t2 = e3.$separateStackingContexts;
        return t2 && (0, S.css)(["isolation:isolate;position:relative;z-index:", ";"], w.variables.zindexLayer);
      }));
      var q = {
        body: {
          appendChild: function e3() {
            return [];
          }
        },
        addEventListener: function e3() {
        },
        removeEventListener: function e3() {
        },
        activeElement: {
          blur: function e3() {
          },
          nodeName: ""
        },
        querySelector: function e3() {
          return null;
        },
        querySelectorAll: function e3() {
          return [];
        },
        getElementById: function e3() {
          return null;
        },
        createEvent: function e3() {
          return {
            initEvent: function e4() {
            }
          };
        },
        createElement: function e3() {
          return {
            children: [],
            childNodes: [],
            style: {},
            setAttribute: function e4() {
            },
            getElementsByTagName: function e4() {
              return [];
            }
          };
        },
        createElementNS: function e3() {
          return {};
        },
        importNode: function e3() {
          return null;
        },
        location: {
          hash: "",
          host: "",
          hostname: "",
          href: "",
          origin: "",
          pathname: "",
          protocol: "",
          search: ""
        }
      };
      function x() {
        var e3 = typeof document !== "undefined" ? document : q;
        return e3;
      }
      var A = x();
      const L = (
        /* unused pure expression or super */
        null
      );
      var _ = {
        document: q,
        navigator: {
          userAgent: ""
        },
        location: {
          hash: "",
          host: "",
          hostname: "",
          href: "",
          origin: "",
          pathname: "",
          protocol: "",
          search: ""
        },
        history: {
          replaceState: function e3() {
          },
          pushState: function e3() {
          },
          go: function e3() {
          },
          back: function e3() {
          }
        },
        CustomEvent: function e3() {
          return this;
        },
        addEventListener: function e3() {
        },
        removeEventListener: function e3() {
        },
        getComputedStyle: function e3() {
          return {
            getPropertyValue: function e4() {
              return "";
            }
          };
        },
        Image: function e3() {
        },
        Date: function e3() {
        },
        screen: {},
        setTimeout: function e3() {
        },
        clearTimeout: function e3() {
        },
        matchMedia: function e3() {
          return {};
        },
        requestAnimationFrame: function e3(t2) {
          if (typeof setTimeout === "undefined") {
            t2();
            return null;
          }
          return setTimeout(t2, 0);
        },
        cancelAnimationFrame: function e3(t2) {
          if (typeof setTimeout === "undefined") {
            return;
          }
          clearTimeout(t2);
        }
      };
      function O() {
        var e3 = typeof window !== "undefined" ? window : _;
        return e3;
      }
      var P = O();
      const j = P;
      function M(e3, t2) {
        return F(e3) || D(e3, t2) || N(e3, t2) || I();
      }
      function I() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      function N(e3, t2) {
        if (e3) {
          if ("string" == typeof e3) return R(e3, t2);
          var n2 = {}.toString.call(e3).slice(8, -1);
          return "Object" === n2 && e3.constructor && (n2 = e3.constructor.name), "Map" === n2 || "Set" === n2 ? Array.from(e3) : "Arguments" === n2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2) ? R(e3, t2) : void 0;
        }
      }
      function R(e3, t2) {
        (null == t2 || t2 > e3.length) && (t2 = e3.length);
        for (var n2 = 0, r3 = Array(t2); n2 < t2; n2++) {
          r3[n2] = e3[n2];
        }
        return r3;
      }
      function D(e3, t2) {
        var n2 = null == e3 ? null : "undefined" != typeof Symbol && e3[Symbol.iterator] || e3["@@iterator"];
        if (null != n2) {
          var r3, o2, a2, i2, u2 = [], l2 = true, c2 = false;
          try {
            if (a2 = (n2 = n2.call(e3)).next, 0 === t2) {
              if (Object(n2) !== n2) return;
              l2 = false;
            } else for (; !(l2 = (r3 = a2.call(n2)).done) && (u2.push(r3.value), u2.length !== t2); l2 = true) {
            }
          } catch (e4) {
            c2 = true, o2 = e4;
          } finally {
            try {
              if (!l2 && null != n2["return"] && (i2 = n2["return"](), Object(i2) !== i2)) return;
            } finally {
              if (c2) throw o2;
            }
          }
          return u2;
        }
      }
      function F(e3) {
        if (Array.isArray(e3)) return e3;
      }
      var K = ["clickAway", "escapeKey"];
      var $ = {
        children: f().node,
        closeReasons: f().arrayOf(f().oneOf(K)),
        onRequestClose: f().func,
        open: f().bool
      };
      var z = {
        passive: true
      };
      var B = function e3(t2) {
        var o2 = t2.children, i2 = t2.closeReasons, l2 = i2 === void 0 ? K : i2, s2 = t2.open, f2 = t2.onRequestClose;
        var v2 = (0, n.useContext)(b), p2 = v2.separateStackingContexts;
        var C2 = (0, n.useContext)(g);
        var E2 = (0, n.useRef)(null);
        var S2 = (0, n.useState)((0, h.createGUID)()), k2 = M(S2, 1), w2 = k2[0];
        var q2 = m()(s2);
        (0, n.useEffect)((function() {
          if (s2 && !q2) {
            C2.push(w2);
          } else if (q2 && !s2) {
            c()(C2, w2);
          }
        }), [w2, C2, s2, q2]);
        (0, n.useEffect)((function() {
          return function() {
            c()(C2, w2);
          };
        }), [w2, C2]);
        if (!e3.layerContainer) {
          var A2 = x();
          var L2 = A2.createElement("div");
          L2.setAttribute("data-test", "layer-container");
          A2.body.appendChild(L2);
          e3.layerContainer = L2;
        }
        var _2 = (0, n.useCallback)((function() {
          if (e3.layerContainer) {
            var t3 = x();
            var n2 = e3.layerContainer.contains(t3.fullscreenElement);
            if (t3.fullscreenElement != null) {
              if (!n2) {
                t3.fullscreenElement.appendChild(e3.layerContainer);
              }
            } else {
              t3.body.appendChild(e3.layerContainer);
            }
          }
        }), []);
        var O2 = (0, n.useCallback)((function(e4) {
          var t3 = e4.nativeEvent;
          E2.current = t3;
        }), []);
        var P2 = (0, n.useCallback)((function(e4) {
          if (!s2 || !a()(l2, "clickAway") || E2.current === e4) {
            return;
          }
          f2 === null || f2 === void 0 ? void 0 : f2({
            event: e4,
            reason: "clickAway"
          });
        }), [l2, s2, f2]);
        var I2 = (0, n.useCallback)((function(e4) {
          if (s2 && e4.key === "Escape" && u()(C2) === w2 && a()(l2, "escapeKey")) {
            f2 === null || f2 === void 0 ? void 0 : f2({
              event: e4,
              reason: "escapeKey"
            });
          }
        }), [l2, w2, C2, s2, f2]);
        var N2 = r2().createElement(y(), {
          target: j,
          eventType: "fullscreenchange",
          listener: _2,
          key: "fullScreenChange"
        });
        if (s2) {
          var R2 = (0, d.createPortal)(r2().createElement(T, {
            $separateStackingContexts: p2,
            "data-test": "layer",
            onMouseDown: O2,
            onTouchStart: O2
          }, o2), e3.layerContainer);
          return r2().createElement(r2().Fragment, null, r2().createElement(y(), {
            target: j,
            eventType: "keydown",
            listener: I2,
            key: "eventListenerKeydown"
          }), r2().createElement(y(), {
            target: j,
            eventType: "mousedown",
            listener: P2,
            key: "eventListenerMouseDown"
          }), r2().createElement(y(), {
            target: j,
            eventType: "touchstart",
            listener: P2,
            key: "eventListenerTouchStart",
            options: z
          }), N2, R2);
        }
        return r2().createElement(r2().Fragment, null, N2);
      };
      B.propTypes = $;
      B.layerContainer = null;
      B.possibleCloseReasons = K;
      const G = B;
      module.exports = t;
    })();
  }
});

// node_modules/@splunk/react-ui/ScrollContainerContext.js
var require_ScrollContainerContext = __commonJS({
  "node_modules/@splunk/react-ui/ScrollContainerContext.js"(exports, module) {
    var import_dist10 = __toESM(require_dist());
    var import_dist11 = __toESM(require_dist2());
    var import_dist12 = __toESM(require_dist3());
    (() => {
      "use strict";
      var e2 = {};
      (() => {
        e2.n = (t2) => {
          var n2 = t2 && t2.__esModule ? (
            /******/
            () => t2["default"]
          ) : () => t2;
          e2.d(n2, {
            a: n2
          });
          return n2;
        };
      })();
      (() => {
        e2.d = (t2, n2) => {
          for (var r3 in n2) {
            if (e2.o(n2, r3) && !e2.o(t2, r3)) {
              Object.defineProperty(t2, r3, {
                enumerable: true,
                get: n2[r3]
              });
            }
          }
        };
      })();
      (() => {
        e2.o = (e3, t2) => Object.prototype.hasOwnProperty.call(e3, t2);
      })();
      (() => {
        e2.r = (e3) => {
          if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
            Object.defineProperty(e3, Symbol.toStringTag, {
              value: "Module"
            });
          }
          Object.defineProperty(e3, "__esModule", {
            value: true
          });
        };
      })();
      var t = {};
      e2.r(t);
      e2.d(t, {
        ScrollContainerContext: () => (
          /* reexport */
          s
        ),
        ScrollContainerProvider: () => (
          /* reexport */
          m
        ),
        default: () => (
          /* reexport */
          v
        )
      });
      const n = require_react();
      var r2 = e2.n(n);
      var o = {
        body: {
          appendChild: function e3() {
            return [];
          }
        },
        addEventListener: function e3() {
        },
        removeEventListener: function e3() {
        },
        activeElement: {
          blur: function e3() {
          },
          nodeName: ""
        },
        querySelector: function e3() {
          return null;
        },
        querySelectorAll: function e3() {
          return [];
        },
        getElementById: function e3() {
          return null;
        },
        createEvent: function e3() {
          return {
            initEvent: function e4() {
            }
          };
        },
        createElement: function e3() {
          return {
            children: [],
            childNodes: [],
            style: {},
            setAttribute: function e4() {
            },
            getElementsByTagName: function e4() {
              return [];
            }
          };
        },
        createElementNS: function e3() {
          return {};
        },
        importNode: function e3() {
          return null;
        },
        location: {
          hash: "",
          host: "",
          hostname: "",
          href: "",
          origin: "",
          pathname: "",
          protocol: "",
          search: ""
        }
      };
      function u() {
        var e3 = typeof document !== "undefined" ? document : o;
        return e3;
      }
      var i = u();
      const c = (
        /* unused pure expression or super */
        null
      );
      var a = {
        document: o,
        navigator: {
          userAgent: ""
        },
        location: {
          hash: "",
          host: "",
          hostname: "",
          href: "",
          origin: "",
          pathname: "",
          protocol: "",
          search: ""
        },
        history: {
          replaceState: function e3() {
          },
          pushState: function e3() {
          },
          go: function e3() {
          },
          back: function e3() {
          }
        },
        CustomEvent: function e3() {
          return this;
        },
        addEventListener: function e3() {
        },
        removeEventListener: function e3() {
        },
        getComputedStyle: function e3() {
          return {
            getPropertyValue: function e4() {
              return "";
            }
          };
        },
        Image: function e3() {
        },
        Date: function e3() {
        },
        screen: {},
        setTimeout: function e3() {
        },
        clearTimeout: function e3() {
        },
        matchMedia: function e3() {
          return {};
        },
        requestAnimationFrame: function e3(t2) {
          if (typeof setTimeout === "undefined") {
            t2();
            return null;
          }
          return setTimeout(t2, 0);
        },
        cancelAnimationFrame: function e3(t2) {
          if (typeof setTimeout === "undefined") {
            return;
          }
          clearTimeout(t2);
        }
      };
      function f() {
        var e3 = typeof window !== "undefined" ? window : a;
        return e3;
      }
      var l = f();
      const d = (
        /* unused pure expression or super */
        null
      );
      var s = r2().createContext(f());
      var m = s.Provider;
      const v = s;
      module.exports = t;
    })();
  }
});

// node_modules/lodash/_baseFilter.js
var require_baseFilter = __commonJS({
  "node_modules/lodash/_baseFilter.js"(exports, module) {
    var import_dist10 = __toESM(require_dist());
    var import_dist11 = __toESM(require_dist2());
    var import_dist12 = __toESM(require_dist3());
    var baseEach = require_baseEach();
    function baseFilter(collection, predicate) {
      var result = [];
      baseEach(collection, function(value, index, collection2) {
        if (predicate(value, index, collection2)) {
          result.push(value);
        }
      });
      return result;
    }
    module.exports = baseFilter;
  }
});

// node_modules/lodash/filter.js
var require_filter = __commonJS({
  "node_modules/lodash/filter.js"(exports, module) {
    var import_dist10 = __toESM(require_dist());
    var import_dist11 = __toESM(require_dist2());
    var import_dist12 = __toESM(require_dist3());
    var arrayFilter = require_arrayFilter();
    var baseFilter = require_baseFilter();
    var baseIteratee = require_baseIteratee();
    var isArray = require_isArray();
    function filter(collection, predicate) {
      var func = isArray(collection) ? arrayFilter : baseFilter;
      return func(collection, baseIteratee(predicate, 3));
    }
    module.exports = filter;
  }
});

// node_modules/lodash/_baseMap.js
var require_baseMap = __commonJS({
  "node_modules/lodash/_baseMap.js"(exports, module) {
    var import_dist10 = __toESM(require_dist());
    var import_dist11 = __toESM(require_dist2());
    var import_dist12 = __toESM(require_dist3());
    var baseEach = require_baseEach();
    var isArrayLike = require_isArrayLike();
    function baseMap(collection, iteratee) {
      var index = -1, result = isArrayLike(collection) ? Array(collection.length) : [];
      baseEach(collection, function(value, key, collection2) {
        result[++index] = iteratee(value, key, collection2);
      });
      return result;
    }
    module.exports = baseMap;
  }
});

// node_modules/lodash/_baseSortBy.js
var require_baseSortBy = __commonJS({
  "node_modules/lodash/_baseSortBy.js"(exports, module) {
    var import_dist10 = __toESM(require_dist());
    var import_dist11 = __toESM(require_dist2());
    var import_dist12 = __toESM(require_dist3());
    function baseSortBy(array, comparer) {
      var length = array.length;
      array.sort(comparer);
      while (length--) {
        array[length] = array[length].value;
      }
      return array;
    }
    module.exports = baseSortBy;
  }
});

// node_modules/lodash/_compareAscending.js
var require_compareAscending = __commonJS({
  "node_modules/lodash/_compareAscending.js"(exports, module) {
    var import_dist10 = __toESM(require_dist());
    var import_dist11 = __toESM(require_dist2());
    var import_dist12 = __toESM(require_dist3());
    var isSymbol = require_isSymbol();
    function compareAscending(value, other) {
      if (value !== other) {
        var valIsDefined = value !== void 0, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
        var othIsDefined = other !== void 0, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
        if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
          return 1;
        }
        if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
          return -1;
        }
      }
      return 0;
    }
    module.exports = compareAscending;
  }
});

// node_modules/lodash/_compareMultiple.js
var require_compareMultiple = __commonJS({
  "node_modules/lodash/_compareMultiple.js"(exports, module) {
    var import_dist10 = __toESM(require_dist());
    var import_dist11 = __toESM(require_dist2());
    var import_dist12 = __toESM(require_dist3());
    var compareAscending = require_compareAscending();
    function compareMultiple(object, other, orders) {
      var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
      while (++index < length) {
        var result = compareAscending(objCriteria[index], othCriteria[index]);
        if (result) {
          if (index >= ordersLength) {
            return result;
          }
          var order = orders[index];
          return result * (order == "desc" ? -1 : 1);
        }
      }
      return object.index - other.index;
    }
    module.exports = compareMultiple;
  }
});

// node_modules/lodash/_baseOrderBy.js
var require_baseOrderBy = __commonJS({
  "node_modules/lodash/_baseOrderBy.js"(exports, module) {
    var import_dist10 = __toESM(require_dist());
    var import_dist11 = __toESM(require_dist2());
    var import_dist12 = __toESM(require_dist3());
    var arrayMap = require_arrayMap();
    var baseGet = require_baseGet();
    var baseIteratee = require_baseIteratee();
    var baseMap = require_baseMap();
    var baseSortBy = require_baseSortBy();
    var baseUnary = require_baseUnary();
    var compareMultiple = require_compareMultiple();
    var identity = require_identity();
    var isArray = require_isArray();
    function baseOrderBy(collection, iteratees, orders) {
      if (iteratees.length) {
        iteratees = arrayMap(iteratees, function(iteratee) {
          if (isArray(iteratee)) {
            return function(value) {
              return baseGet(value, iteratee.length === 1 ? iteratee[0] : iteratee);
            };
          }
          return iteratee;
        });
      } else {
        iteratees = [identity];
      }
      var index = -1;
      iteratees = arrayMap(iteratees, baseUnary(baseIteratee));
      var result = baseMap(collection, function(value, key, collection2) {
        var criteria = arrayMap(iteratees, function(iteratee) {
          return iteratee(value);
        });
        return { "criteria": criteria, "index": ++index, "value": value };
      });
      return baseSortBy(result, function(object, other) {
        return compareMultiple(object, other, orders);
      });
    }
    module.exports = baseOrderBy;
  }
});

// node_modules/lodash/sortBy.js
var require_sortBy = __commonJS({
  "node_modules/lodash/sortBy.js"(exports, module) {
    var import_dist10 = __toESM(require_dist());
    var import_dist11 = __toESM(require_dist2());
    var import_dist12 = __toESM(require_dist3());
    var baseFlatten = require_baseFlatten();
    var baseOrderBy = require_baseOrderBy();
    var baseRest = require_baseRest();
    var isIterateeCall = require_isIterateeCall();
    var sortBy = baseRest(function(collection, iteratees) {
      if (collection == null) {
        return [];
      }
      var length = iteratees.length;
      if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
        iteratees = [];
      } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
        iteratees = [iteratees[0]];
      }
      return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
    });
    module.exports = sortBy;
  }
});

// node_modules/@splunk/ui-utils/focus.js
var require_focus = __commonJS({
  "node_modules/@splunk/ui-utils/focus.js"(exports) {
    "use strict";
    var import_dist10 = __toESM(require_dist());
    var import_dist11 = __toESM(require_dist2());
    var import_dist12 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.getSortedTabbableElements = getSortedTabbableElements;
    exports.isTabKey = isTabKey;
    exports.handleTab = handleTab;
    exports.takeFocus = takeFocus;
    exports.handleFocus = handleFocus;
    exports.updateTabIndex = exports.getNewIndex = exports.calculateIndex = exports.isHidden = void 0;
    var _defer = _interopRequireDefault(require_defer());
    var _filter = _interopRequireDefault(require_filter());
    var _sortBy = _interopRequireDefault(require_sortBy());
    function _interopRequireDefault(e2) {
      return e2 && e2.__esModule ? e2 : { "default": e2 };
    }
    var tabbableSelectors = ["a[href]", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])", "button:not([disabled])", "[contenteditable]"];
    var tabbableSelectorsWithTabIndex = tabbableSelectors.concat(["[tabindex]"]);
    var isStyleVisible = function isStyleVisible2(element) {
      var style = window.getComputedStyle(element);
      return style.display !== "none" && style.visibility !== "hidden";
    };
    var isAttributeVisible = function isAttributeVisible2(element) {
      return !element.hasAttribute("hidden");
    };
    var isElementVisible = function isElementVisible2(element) {
      var visibleByStyle = isStyleVisible(element);
      var visibleByAttribute = isAttributeVisible(element);
      return visibleByStyle && visibleByAttribute;
    };
    var isHidden = function isHidden2(element) {
      var isZeroSize = element.getClientRects().length > 0 && (element.offsetWidth === 0 || element.offsetHeight === 0);
      return isZeroSize || !isElementVisible(element);
    };
    exports.isHidden = isHidden;
    function getSortedTabbableElements(container) {
      var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, ignoreTabIndex = _ref.ignoreTabIndex;
      var tabbableElementSelector = (ignoreTabIndex ? tabbableSelectors : tabbableSelectorsWithTabIndex).join(", ");
      var elems = container.querySelectorAll(tabbableElementSelector);
      var tabbableElems = (0, _filter["default"])(elems, function(el) {
        var isValidTabIndex = ignoreTabIndex || el.tabIndex >= 0;
        return !isHidden(el) && isValidTabIndex || el === document.activeElement;
      });
      var reducedElements = tabbableElems.reduce(function(accumulator, currentElement) {
        var prevElement = accumulator[accumulator.length - 1];
        var isPrevElementRadio = (prevElement === null || prevElement === void 0 ? void 0 : prevElement.getAttribute("type")) === "radio";
        var isCurrElementRadio = currentElement.getAttribute("type") === "radio";
        var sameRadioGroup = currentElement.getAttribute("name") === (prevElement === null || prevElement === void 0 ? void 0 : prevElement.getAttribute("name"));
        if (isPrevElementRadio && isCurrElementRadio && sameRadioGroup) {
          if (currentElement.checked) {
            accumulator.pop();
            accumulator.push(currentElement);
          }
        } else {
          accumulator.push(currentElement);
        }
        return accumulator;
      }, []);
      return (0, _sortBy["default"])(reducedElements, function(el) {
        if (el.tabIndex > 0) {
          return -1 / el.tabIndex;
        }
        return 0;
      });
    }
    function isTabKey(event) {
      return !(event.key !== "Tab" || event.metaKey || event.altKey || event.controlKey);
    }
    function handleTab(container, event) {
      if (!container.contains(document.activeElement)) {
        return null;
      }
      if (!isTabKey(event)) {
        return null;
      }
      var tabbableElements = getSortedTabbableElements(container);
      if (tabbableElements.length === 0) {
        if (document.activeElement === container) {
          event.preventDefault();
          return container;
        }
        return null;
      }
      var currentElement = event && event.target || container.querySelector(":focus");
      var currentIndex = tabbableElements.indexOf(currentElement);
      if (currentIndex === -1) {
        currentIndex = event.shiftKey ? 0 : tabbableElements.length - 1;
      }
      if (event.shiftKey) {
        tabbableElements.unshift(tabbableElements.pop());
      } else {
        tabbableElements.push(tabbableElements.shift());
      }
      event.preventDefault();
      tabbableElements[currentIndex].focus();
      return tabbableElements[currentIndex];
    }
    function takeFocus(container) {
      var defaultElement = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "first";
      var currentElement = container.querySelector(":focus");
      if (currentElement) {
        return currentElement;
      }
      if (defaultElement === "first") {
        var targetEl = getSortedTabbableElements(container)[0];
        if (targetEl) {
          (0, _defer["default"])(function() {
            return targetEl.focus();
          });
          return targetEl;
        }
      }
      if (container.hasAttribute("tabIndex")) {
        (0, _defer["default"])(function() {
          return container.focus();
        });
        return container;
      }
      return null;
    }
    var focusMoveDirection = Object.freeze({
      NONE: "none",
      NEXT: "next",
      PREVIOUS: "previous"
    });
    var calculateIndex = function calculateIndex2(_ref2) {
      var itemsLength = _ref2.itemsLength, currentIndex = _ref2.currentIndex, direction = _ref2.direction, enableLoop = _ref2.enableLoop;
      if (direction === focusMoveDirection.NONE || ![focusMoveDirection.NONE, focusMoveDirection.NEXT, focusMoveDirection.PREVIOUS].includes(direction)) {
        return currentIndex;
      }
      var increment = direction === focusMoveDirection.NEXT ? 1 : -1;
      if (!enableLoop) {
        var newIndex = currentIndex + increment;
        if (newIndex >= itemsLength || newIndex < 0) {
          return currentIndex;
        }
        return newIndex;
      }
      return (currentIndex + increment + itemsLength) % itemsLength;
    };
    exports.calculateIndex = calculateIndex;
    var getNewIndex = function getNewIndex2(key, itemsLength, currentIndex, _ref3) {
      var enableLoop = _ref3.enableLoop, orientation = _ref3.orientation, enableTab = _ref3.enableTab, enableHomeEnd = _ref3.enableHomeEnd;
      if (currentIndex < 0 || currentIndex >= itemsLength) {
        return 0;
      }
      if (key === "Home") {
        return enableHomeEnd ? 0 : -1;
      }
      if (key === "End") {
        return enableHomeEnd ? itemsLength - 1 : -1;
      }
      var direction = focusMoveDirection.NONE;
      if (orientation === "horizontal") {
        if (key === "ArrowLeft") {
          direction = focusMoveDirection.PREVIOUS;
        }
        if (key === "ArrowRight") {
          direction = focusMoveDirection.NEXT;
        }
      } else if (orientation === "vertical") {
        if (key === "ArrowUp") {
          direction = focusMoveDirection.PREVIOUS;
        }
        if (key === "ArrowDown") {
          direction = focusMoveDirection.NEXT;
        }
      }
      if (enableTab) {
        if (key === "tabShift") {
          direction = focusMoveDirection.PREVIOUS;
        }
        if (key === "Tab") {
          direction = focusMoveDirection.NEXT;
        }
      }
      if (direction !== focusMoveDirection.NONE) {
        return calculateIndex({
          itemsLength,
          currentIndex,
          direction,
          enableLoop
        });
      }
      return -1;
    };
    exports.getNewIndex = getNewIndex;
    var updateTabIndex = function updateTabIndex2(activeIndex, actionItems) {
      actionItems.forEach(function(el, index) {
        return el.setAttribute("tabindex", index === activeIndex ? "0" : "-1");
      });
    };
    exports.updateTabIndex = updateTabIndex;
    function handleFocus(key, actionItems, currentIndex) {
      var _ref4 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {}, _ref4$enableLoop = _ref4.enableLoop, enableLoop = _ref4$enableLoop === void 0 ? false : _ref4$enableLoop, _ref4$orientation = _ref4.orientation, orientation = _ref4$orientation === void 0 ? "horizontal" : _ref4$orientation, _ref4$enableTab = _ref4.enableTab, enableTab = _ref4$enableTab === void 0 ? false : _ref4$enableTab, _ref4$enableHomeEnd = _ref4.enableHomeEnd, enableHomeEnd = _ref4$enableHomeEnd === void 0 ? true : _ref4$enableHomeEnd;
      var itemsLength = actionItems.length;
      if (!enableTab && key === "Tab") {
        updateTabIndex(0, actionItems);
        return;
      }
      var newIndex = getNewIndex(key, itemsLength, currentIndex, {
        enableLoop,
        orientation,
        enableTab,
        enableHomeEnd
      });
      if (newIndex >= 0 && newIndex < itemsLength) {
        var _actionItems$newIndex, _actionItems$newIndex2;
        updateTabIndex(newIndex, actionItems);
        (_actionItems$newIndex = (_actionItems$newIndex2 = actionItems[newIndex]).focus) === null || _actionItems$newIndex === void 0 ? void 0 : _actionItems$newIndex.call(_actionItems$newIndex2);
      }
      if (newIndex === -1 && !enableTab && key === "tabShift") {
        updateTabIndex(currentIndex, actionItems);
      }
    }
  }
});

// node_modules/@splunk/react-ui/Popover.js
var require_Popover = __commonJS({
  "node_modules/@splunk/react-ui/Popover.js"(exports, module) {
    var import_dist10 = __toESM(require_dist());
    var import_dist11 = __toESM(require_dist2());
    var import_dist12 = __toESM(require_dist3());
    (() => {
      "use strict";
      var e2 = {};
      (() => {
        e2.n = (t2) => {
          var r3 = t2 && t2.__esModule ? (
            /******/
            () => t2["default"]
          ) : () => t2;
          e2.d(r3, {
            a: r3
          });
          return r3;
        };
      })();
      (() => {
        e2.d = (t2, r3) => {
          for (var n2 in r3) {
            if (e2.o(r3, n2) && !e2.o(t2, n2)) {
              Object.defineProperty(t2, n2, {
                enumerable: true,
                get: r3[n2]
              });
            }
          }
        };
      })();
      (() => {
        e2.o = (e3, t2) => Object.prototype.hasOwnProperty.call(e3, t2);
      })();
      (() => {
        e2.r = (e3) => {
          if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
            Object.defineProperty(e3, Symbol.toStringTag, {
              value: "Module"
            });
          }
          Object.defineProperty(e3, "__esModule", {
            value: true
          });
        };
      })();
      var t = {};
      e2.r(t);
      e2.d(t, {
        PopoverContext: () => (
          /* reexport */
          ve
        ),
        PopoverMenuContext: () => (
          /* reexport */
          st
        ),
        PopoverProvider: () => (
          /* reexport */
          he
        ),
        default: () => (
          /* reexport */
          ft
        )
      });
      const r2 = require_react();
      var n = e2.n(r2);
      const o = require_clamp();
      var a = e2.n(o);
      const i = require_defer();
      var l = e2.n(i);
      const c = require_every();
      var u = e2.n(c);
      const f = require_has();
      var s = e2.n(f);
      const p = require_intersection();
      var v = e2.n(p);
      const d = require_isFinite();
      var h = e2.n(d);
      const m = require_isFunction();
      var b = e2.n(m);
      const g = require_omit();
      var y = e2.n(g);
      const w = require_throttle();
      var P = e2.n(w);
      const S = require_prop_types();
      var O = e2.n(S);
      const C = require_Animation();
      const E = require_EventListener();
      var j = e2.n(E);
      const x = require_Layer();
      var k = e2.n(x);
      const A = require_ScrollContainerContext();
      var T = e2.n(A);
      const R = require_useSplunkTheme();
      var M = e2.n(R);
      const W = require_focus();
      function q(e3) {
        "@babel/helpers - typeof";
        return q = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
          return typeof e4;
        } : function(e4) {
          return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
        }, q(e3);
      }
      function H(e3, t2) {
        var r3 = Object.keys(e3);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e3);
          t2 && (n2 = n2.filter((function(t3) {
            return Object.getOwnPropertyDescriptor(e3, t3).enumerable;
          }))), r3.push.apply(r3, n2);
        }
        return r3;
      }
      function I(e3) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var r3 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? H(Object(r3), true).forEach((function(t3) {
            N(e3, t3, r3[t3]);
          })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(r3)) : H(Object(r3)).forEach((function(t3) {
            Object.defineProperty(e3, t3, Object.getOwnPropertyDescriptor(r3, t3));
          }));
        }
        return e3;
      }
      function N(e3, t2, r3) {
        return (t2 = L(t2)) in e3 ? Object.defineProperty(e3, t2, {
          value: r3,
          enumerable: true,
          configurable: true,
          writable: true
        }) : e3[t2] = r3, e3;
      }
      function L(e3) {
        var t2 = D(e3, "string");
        return "symbol" == q(t2) ? t2 : t2 + "";
      }
      function D(e3, t2) {
        if ("object" != q(e3) || !e3) return e3;
        var r3 = e3[Symbol.toPrimitive];
        if (void 0 !== r3) {
          var n2 = r3.call(e3, t2 || "default");
          if ("object" != q(n2)) return n2;
          throw new TypeError("@@toPrimitive must return a primitive value.");
        }
        return ("string" === t2 ? String : Number)(e3);
      }
      function F(e3) {
        var t2 = e3.align, r3 = e3.anchorPos, n2 = e3.outerContainerEl, o2 = e3.padding, a2 = e3.placement;
        switch (a2) {
          case "above":
            return {
              top: r3.top - n2.offsetHeight,
              left: t2 === "edge" ? r3.left - o2 : r3.middle - n2.offsetWidth / 2
            };
          case "below":
            if (t2 === "end") {
              return {
                top: r3.bottom,
                left: r3.right - n2.offsetWidth + o2
              };
            }
            return {
              top: r3.bottom,
              left: t2 === "edge" ? r3.left - o2 : r3.middle - n2.offsetWidth / 2
            };
          case "left":
            return {
              top: t2 === "edge" ? r3.top - o2 : r3.center - n2.offsetHeight / 2,
              left: r3.left - n2.offsetWidth
            };
          case "right":
            return {
              top: t2 === "edge" ? r3.top - o2 : r3.center - n2.offsetHeight / 2,
              left: r3.right
            };
          default:
            throw new Error("".concat(a2, " is not a valid placement value. Valid options are: 'above', 'below', 'left', or 'right'"));
        }
      }
      var $ = function e3(t2) {
        var r3 = t2.align, n2 = t2.anchorPos, o2 = t2.outerContainerEl, a2 = t2.padding;
        if (r3 === "edge") {
          return n2.left + o2.offsetWidth - a2;
        }
        if (r3 === "end") {
          return n2.right + a2;
        }
        return n2.middle + o2.offsetWidth / 2;
      };
      var _ = function e3(t2) {
        var r3 = t2.align, n2 = t2.anchorPos, o2 = t2.outerContainerEl, a2 = t2.padding;
        if (r3 === "edge") return n2.left - a2;
        if (r3 === "end") return n2.right - o2.offsetWidth + a2;
        return n2.middle - o2.offsetWidth / 2;
      };
      var V = function e3(t2) {
        var r3 = t2.align, n2 = t2.anchorPos, o2 = t2.outerContainerEl, a2 = t2.padding;
        if (r3 === "edge") return n2.top - a2;
        return n2.top - o2.offsetHeight / 2;
      };
      var z = function e3(t2) {
        var r3 = t2.align, n2 = t2.anchorPos, o2 = t2.outerContainerEl, a2 = t2.padding;
        if (r3 === "edge") return n2.top + o2.offsetHeight - a2;
        return n2.bottom + o2.offsetHeight / 2;
      };
      function K(e3) {
        var t2 = e3.align, r3 = e3.anchorPos, n2 = e3.scrollContainerPos, o2 = e3.canCoverAnchor, a2 = e3.defaultPlacement, i2 = e3.outerContainerEl, l2 = e3.padding, c2 = e3.repositionMode, u2 = e3.windowHeight, f2 = e3.windowWidth;
        var s2 = c2 === "flip";
        var p2 = c2 === "any";
        var v2 = s2 || p2;
        var d2 = e3.placement || a2;
        if (a2 === "vertical") {
          d2 = r3.top > u2 - r3.bottom ? "above" : "below";
        } else if (a2 === "horizontal") {
          d2 = r3.left > f2 - r3.right ? "left" : "right";
        }
        var h2 = d2;
        var m2 = F({
          align: t2,
          anchorPos: r3,
          outerContainerEl: i2,
          padding: l2,
          placement: h2
        }), b2 = m2.top, g2 = m2.left;
        var y2 = "auto";
        var w2 = f2;
        var P2 = u2;
        var S2 = h2;
        var O2 = r3.top - i2.offsetHeight > 0;
        var C2 = r3.bottom + i2.offsetHeight < u2;
        var E2 = r3.left - i2.offsetWidth > 0;
        var j2 = r3.right + i2.offsetWidth < f2;
        var x2 = r3.top * 0.7 > u2 - r3.bottom;
        var k2 = $({
          align: t2,
          anchorPos: r3,
          outerContainerEl: i2,
          padding: l2
        }) > f2;
        var A2 = _({
          align: t2,
          anchorPos: r3,
          outerContainerEl: i2,
          padding: l2
        }) < 0;
        var T2 = V({
          align: t2,
          anchorPos: r3,
          outerContainerEl: i2,
          padding: l2
        }) < 0;
        var R2 = z({
          align: t2,
          anchorPos: r3,
          outerContainerEl: i2,
          padding: l2
        }) > u2;
        if (S2 === "above") {
          if (!O2 && v2) {
            if (C2) {
              return K(I(I({}, e3), {}, {
                placement: "below"
              }));
            }
            if (p2 && j2) {
              return K(I(I({}, e3), {}, {
                placement: "right"
              }));
            }
            if (p2 && E2) {
              return K(I(I({}, e3), {}, {
                placement: "left"
              }));
            }
            if (o2) {
              S2 = "misaligned";
              b2 = 0;
            }
          }
          if (S2 !== "misaligned") {
            y2 = u2 - b2 - i2.offsetHeight;
            if (n2) {
              y2 = Math.min(y2, u2 - n2.top);
            }
            b2 = "auto";
          }
          if (k2) {
            g2 = Math.max(f2 - i2.offsetWidth, 0);
          } else if (A2) {
            g2 = 0;
          }
          if (!o2) {
            P2 = r3.top;
          }
        }
        if (S2 === "below") {
          if (!C2 && v2) {
            if (O2 && x2) {
              return K(I(I({}, e3), {}, {
                placement: "above"
              }));
            }
            if (p2 && j2) {
              return K(I(I({}, e3), {}, {
                placement: "right"
              }));
            }
            if (p2 && E2) {
              return K(I(I({}, e3), {}, {
                placement: "left"
              }));
            }
            if (o2) {
              S2 = "misaligned";
              b2 = 0;
            }
          }
          if (n2) {
            b2 = Math.min(b2, n2.bottom);
          }
          if (k2) {
            g2 = Math.max(f2 - i2.offsetWidth, 0);
          } else if (A2) {
            g2 = 0;
          }
          if (!o2) {
            P2 = u2 - r3.bottom;
          }
        }
        if (S2 === "left") {
          if (!E2 && v2) {
            if (j2) {
              return K(I(I({}, e3), {}, {
                placement: "right"
              }));
            }
            if (p2 && C2) {
              return K(I(I({}, e3), {}, {
                placement: "below"
              }));
            }
            if (p2 && O2) {
              return K(I(I({}, e3), {}, {
                placement: "above"
              }));
            }
            if (o2) {
              S2 = "misaligned";
              b2 = 0;
            }
          }
          if (T2) {
            b2 = 0;
          } else if (R2) {
            b2 = Math.max(u2 - i2.offsetHeight, 0);
          }
          if (!o2) {
            w2 = r3.left;
          }
        }
        if (S2 === "right") {
          if (!j2 && v2) {
            if (E2) {
              return K(I(I({}, e3), {}, {
                placement: "left"
              }));
            }
            if (p2 && C2) {
              return K(I(I({}, e3), {}, {
                placement: "below"
              }));
            }
            if (p2 && O2) {
              return K(I(I({}, e3), {}, {
                placement: "above"
              }));
            }
            if (o2) {
              S2 = "misaligned";
              b2 = 0;
            }
          }
          if (T2) {
            b2 = 0;
          } else if (R2) {
            b2 = Math.max(u2 - i2.offsetHeight, 0);
          }
          if (!o2) {
            w2 = f2 - r3.left;
          }
        }
        return {
          placement: S2,
          maxHeight: P2,
          maxWidth: w2,
          outerContainerStyle: {
            top: b2,
            left: g2,
            bottom: y2
          }
        };
      }
      const X = require_cjs6();
      const B = (init_styled_components_esm(), __toCommonJS(styled_components_esm_exports));
      var Y = e2.n(B);
      const U = require_themes();
      var G = 8;
      var J = Y()(X.animated.div).withConfig({
        displayName: "PopoverStyles__Styled",
        componentId: "sc-1nahsvw-0"
      })(["position:fixed;z-index:", ";left:-300%;top:-300%;"], U.variables.zindexPopover);
      var Q = (0, B.css)(["", ""], (0, U.pick)({
        light: "#27292e",
        dark: U.variables.white
      }));
      var Z = Y().div.withConfig({
        displayName: "PopoverStyles__StyledBox",
        componentId: "sc-1nahsvw-1"
      })(["", ";", ";", ";"], U.mixins.reset("block"), (function(e3) {
        var t2 = e3.$open;
        return !t2 && (0, B.css)(["pointer-events:none;"]);
      }), (function(e3) {
        var t2 = e3.$appearance, r3 = e3.$boxPadding;
        return t2 !== "none" && (0, B.css)(["padding:", "px;"], r3);
      }));
      var ee = Y().div.withConfig({
        displayName: "PopoverStyles__StyledContent",
        componentId: "sc-1nahsvw-2"
      })(["border-radius:", ";background-color:", ";color:", ";", ""], U.variables.borderRadius, (0, U.pickVariant)("$appearance", {
        normal: U.variables.backgroundColorPopup,
        inverted: Q
      }), (0, U.pickVariant)("$appearance", {
        normal: U.variables.contentColorDefault,
        inverted: U.variables.contentColorInverted
      }), (0, U.pickVariant)("$appearance", {
        normal: (0, B.css)(["box-shadow:", ";"], U.variables.overlayShadow)
      }));
      var te = Y().div.withConfig({
        displayName: "PopoverStyles__StyledArrow",
        componentId: "sc-1nahsvw-3"
      })(["width:0;height:0;border-left:", "px solid transparent;border-right:", "px solid transparent;position:absolute;border-bottom-width:", "px;border-bottom-style:solid;", ";"], G, G, G, (function(e3) {
        var t2 = e3.$appearance;
        return t2 !== "none" && (0, B.css)(["border-bottom-color:", ";"], (0, U.pickVariant)("$appearance", {
          normal: U.variables.backgroundColorPopup,
          inverted: Q
        }));
      }));
      var re = Y().svg.withConfig({
        displayName: "PopoverStyles__StyledHitArea",
        componentId: "sc-1nahsvw-4"
      })(["position:fixed;pointer-events:none;path{pointer-events:auto;stroke-width:0;stroke:transparent;fill:transparent;}"]);
      function ne(e3, t2) {
        return ce(e3) || le(e3, t2) || ae(e3, t2) || oe();
      }
      function oe() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      function ae(e3, t2) {
        if (e3) {
          if ("string" == typeof e3) return ie(e3, t2);
          var r3 = {}.toString.call(e3).slice(8, -1);
          return "Object" === r3 && e3.constructor && (r3 = e3.constructor.name), "Map" === r3 || "Set" === r3 ? Array.from(e3) : "Arguments" === r3 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r3) ? ie(e3, t2) : void 0;
        }
      }
      function ie(e3, t2) {
        (null == t2 || t2 > e3.length) && (t2 = e3.length);
        for (var r3 = 0, n2 = Array(t2); r3 < t2; r3++) {
          n2[r3] = e3[r3];
        }
        return n2;
      }
      function le(e3, t2) {
        var r3 = null == e3 ? null : "undefined" != typeof Symbol && e3[Symbol.iterator] || e3["@@iterator"];
        if (null != r3) {
          var n2, o2, a2, i2, l2 = [], c2 = true, u2 = false;
          try {
            if (a2 = (r3 = r3.call(e3)).next, 0 === t2) {
              if (Object(r3) !== r3) return;
              c2 = false;
            } else for (; !(c2 = (n2 = a2.call(r3)).done) && (l2.push(n2.value), l2.length !== t2); c2 = true) {
            }
          } catch (e4) {
            u2 = true, o2 = e4;
          } finally {
            try {
              if (!c2 && null != r3["return"] && (i2 = r3["return"](), Object(i2) !== i2)) return;
            } finally {
              if (u2) throw o2;
            }
          }
          return l2;
        }
      }
      function ce(e3) {
        if (Array.isArray(e3)) return e3;
      }
      var ue = {
        anchorRect: O().object,
        popoverEl: O().object,
        popoverPlacement: O().oneOf(["above", "below", "left", "right", "misaligned"])
      };
      var fe = function e3(t2) {
        var r3 = t2.anchorRect, n2 = t2.popoverEl, o2 = t2.popoverPlacement;
        if (r3 != null && n2 != null && o2 != null) {
          var a2 = n2.getBoundingClientRect();
          if (o2 === "above" || o2 === "below") {
            var i2 = r3.left - a2.left;
            var l2 = r3.height;
            var c2 = 0;
            if (o2 === "above") {
              l2 = 0;
              c2 = r3.height;
            }
            var u2 = "0 ".concat(l2);
            var f2 = "".concat(a2.width, " ").concat(l2);
            var s2 = "".concat(i2, " ").concat(l2);
            var p2 = "".concat(i2, " ").concat(c2);
            var v2 = "".concat(i2 + r3.width, " ").concat(l2);
            var d2 = "".concat(i2 + r3.width, " ").concat(c2);
            var h2 = "\n                        M ".concat(u2, "\n                        S ").concat(s2, " , ").concat(p2, "\n                        L ").concat(s2, "\n                        L ").concat(v2, "\n                        L ").concat(d2, "\n                        S ").concat(v2, " , ").concat(f2, "\n                    ");
            return {
              hitAreaPath: h2,
              hitAreaStyle: {
                left: a2.left,
                top: r3.top,
                width: a2.width,
                height: r3.height
              }
            };
          }
          if (o2 === "left" || o2 === "right") {
            var m2 = r3.top - a2.top;
            var b2 = 0;
            var g2 = r3.width;
            if (o2 === "right") {
              b2 = r3.width;
              g2 = 0;
            }
            var y2 = "".concat(b2, " 0");
            var w2 = "".concat(b2, " ").concat(a2.height);
            var P2 = "".concat(b2, " ").concat(m2);
            var S2 = "".concat(g2, " ").concat(m2);
            var O2 = "".concat(b2, " ").concat(m2 + r3.height);
            var C2 = "".concat(g2, " ").concat(m2 + r3.height);
            var E2 = "\n                        M ".concat(y2, "\n                        S ").concat(P2, " , ").concat(S2, "\n                        L ").concat(P2, "\n                        L ").concat(O2, "\n                        L ").concat(C2, "\n                        S ").concat(O2, " , ").concat(w2, "\n                    ");
            return {
              hitAreaPath: E2,
              hitAreaStyle: {
                left: r3.left,
                top: a2.top,
                width: r3.width,
                height: a2.height
              }
            };
          }
        }
        return {
          hitAreaPath: null,
          hitAreaStyle: {}
        };
      };
      var se = n().forwardRef((function(e3, t2) {
        var o2 = e3.anchorRect, a2 = e3.popoverEl, i2 = e3.popoverPlacement;
        var l2 = (0, r2.useState)(null), c2 = ne(l2, 2), u2 = c2[0], f2 = c2[1];
        var s2 = (0, r2.useState)({}), p2 = ne(s2, 2), v2 = p2[0], d2 = p2[1];
        (0, r2.useEffect)((function() {
          var e4 = fe({
            anchorRect: o2,
            popoverEl: a2,
            popoverPlacement: i2
          }), t3 = e4.hitAreaPath, r3 = e4.hitAreaStyle;
          f2(t3);
          d2(r3);
        }), [o2, a2, i2]);
        if (u2 != null) {
          return n().createElement(re, {
            "data-test": "popover-hit-area",
            style: v2
          }, n().createElement("path", {
            d: u2,
            ref: t2
          }));
        }
        return null;
      }));
      se.propTypes = ue;
      const pe = se;
      var ve = (0, r2.createContext)({});
      var de = {
        /** @private */
        allowPropagation: O().bool,
        children: O().node,
        hideArrow: O().bool
      };
      var he = function e3(t2) {
        var o2 = t2.allowPropagation, a2 = t2.children, i2 = t2.hideArrow;
        var l2 = (0, r2.useMemo)((function() {
          return {
            allowPropagation: o2,
            hideArrow: i2
          };
        }), [o2, i2]);
        return n().createElement(ve.Provider, {
          value: l2
        }, a2);
      };
      he.propTypes = de;
      var me = {
        body: {
          appendChild: function e3() {
            return [];
          }
        },
        addEventListener: function e3() {
        },
        removeEventListener: function e3() {
        },
        activeElement: {
          blur: function e3() {
          },
          nodeName: ""
        },
        querySelector: function e3() {
          return null;
        },
        querySelectorAll: function e3() {
          return [];
        },
        getElementById: function e3() {
          return null;
        },
        createEvent: function e3() {
          return {
            initEvent: function e4() {
            }
          };
        },
        createElement: function e3() {
          return {
            children: [],
            childNodes: [],
            style: {},
            setAttribute: function e4() {
            },
            getElementsByTagName: function e4() {
              return [];
            }
          };
        },
        createElementNS: function e3() {
          return {};
        },
        importNode: function e3() {
          return null;
        },
        location: {
          hash: "",
          host: "",
          hostname: "",
          href: "",
          origin: "",
          pathname: "",
          protocol: "",
          search: ""
        }
      };
      function be() {
        var e3 = typeof document !== "undefined" ? document : me;
        return e3;
      }
      var ge = be();
      const ye = (
        /* unused pure expression or super */
        null
      );
      var we = {
        document: me,
        navigator: {
          userAgent: ""
        },
        location: {
          hash: "",
          host: "",
          hostname: "",
          href: "",
          origin: "",
          pathname: "",
          protocol: "",
          search: ""
        },
        history: {
          replaceState: function e3() {
          },
          pushState: function e3() {
          },
          go: function e3() {
          },
          back: function e3() {
          }
        },
        CustomEvent: function e3() {
          return this;
        },
        addEventListener: function e3() {
        },
        removeEventListener: function e3() {
        },
        getComputedStyle: function e3() {
          return {
            getPropertyValue: function e4() {
              return "";
            }
          };
        },
        Image: function e3() {
        },
        Date: function e3() {
        },
        screen: {},
        setTimeout: function e3() {
        },
        clearTimeout: function e3() {
        },
        matchMedia: function e3() {
          return {};
        },
        requestAnimationFrame: function e3(t2) {
          if (typeof setTimeout === "undefined") {
            t2();
            return null;
          }
          return setTimeout(t2, 0);
        },
        cancelAnimationFrame: function e3(t2) {
          if (typeof setTimeout === "undefined") {
            return;
          }
          clearTimeout(t2);
        }
      };
      function Pe() {
        var e3 = typeof window !== "undefined" ? window : we;
        return e3;
      }
      var Se = Pe();
      const Oe = (
        /* unused pure expression or super */
        null
      );
      function Ce(e3) {
        "@babel/helpers - typeof";
        return Ce = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
          return typeof e4;
        } : function(e4) {
          return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
        }, Ce(e3);
      }
      function Ee(e3, t2) {
        var r3 = Object.keys(e3);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e3);
          t2 && (n2 = n2.filter((function(t3) {
            return Object.getOwnPropertyDescriptor(e3, t3).enumerable;
          }))), r3.push.apply(r3, n2);
        }
        return r3;
      }
      function je(e3) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var r3 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? Ee(Object(r3), true).forEach((function(t3) {
            xe(e3, t3, r3[t3]);
          })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(r3)) : Ee(Object(r3)).forEach((function(t3) {
            Object.defineProperty(e3, t3, Object.getOwnPropertyDescriptor(r3, t3));
          }));
        }
        return e3;
      }
      function xe(e3, t2, r3) {
        return (t2 = ke(t2)) in e3 ? Object.defineProperty(e3, t2, {
          value: r3,
          enumerable: true,
          configurable: true,
          writable: true
        }) : e3[t2] = r3, e3;
      }
      function ke(e3) {
        var t2 = Ae(e3, "string");
        return "symbol" == Ce(t2) ? t2 : t2 + "";
      }
      function Ae(e3, t2) {
        if ("object" != Ce(e3) || !e3) return e3;
        var r3 = e3[Symbol.toPrimitive];
        if (void 0 !== r3) {
          var n2 = r3.call(e3, t2 || "default");
          if ("object" != Ce(n2)) return n2;
          throw new TypeError("@@toPrimitive must return a primitive value.");
        }
        return ("string" === t2 ? String : Number)(e3);
      }
      function Te() {
        return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
      }
      function Re(e3) {
        return je(je({}, e3), {}, {
          top: e3.y,
          left: e3.x,
          right: e3.x + e3.width,
          bottom: e3.y + e3.height
        });
      }
      function Me(e3, t2) {
        var r3, n2;
        var o2 = e3.getBoundingClientRect();
        var a2 = Te();
        if (!t2 || !a2) {
          return o2;
        }
        var i2 = Pe();
        var l2 = o2.left + (((r3 = i2.visualViewport) === null || r3 === void 0 ? void 0 : r3.offsetLeft) || 0);
        var c2 = o2.top + (((n2 = i2.visualViewport) === null || n2 === void 0 ? void 0 : n2.offsetTop) || 0);
        var u2 = o2.width, f2 = o2.height;
        return Re({
          width: u2,
          height: f2,
          x: l2,
          y: c2
        });
      }
      function We(e3, t2) {
        if (e3) {
          if (typeof e3 === "function") {
            e3(t2);
          } else {
            e3.current = t2;
          }
        }
      }
      var qe = "is deprecated and will be removed in the next major version.";
      var He = function e3(t2) {
        var r3 = t2.additionalMessage, n2 = r3 === void 0 ? "" : r3, o2 = t2.componentName;
        useEffect((function() {
          if (false) {
          }
        }), [n2, o2]);
      };
      var Ie = function e3(t2) {
        var r3 = t2.additionalMessage, n2 = r3 === void 0 ? "" : r3, o2 = t2.componentName, a2 = t2.propName, i2 = t2.propValue;
        useEffect((function() {
          if (false) {
          }
        }), [n2, o2, a2, i2]);
      };
      var Ne = function e3(t2) {
        var n2 = t2.additionalMessage, o2 = n2 === void 0 ? "" : n2, a2 = t2.componentName, i2 = t2.deprecatedPropValue, l2 = t2.propName, c2 = t2.propValue;
        (0, r2.useEffect)((function() {
          if (false) {
          }
        }), [o2, a2, l2, c2, i2]);
      };
      function Le(e3) {
        "@babel/helpers - typeof";
        return Le = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
          return typeof e4;
        } : function(e4) {
          return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
        }, Le(e3);
      }
      function De() {
        return De = Object.assign ? Object.assign.bind() : function(e3) {
          for (var t2 = 1; t2 < arguments.length; t2++) {
            var r3 = arguments[t2];
            for (var n2 in r3) {
              ({}).hasOwnProperty.call(r3, n2) && (e3[n2] = r3[n2]);
            }
          }
          return e3;
        }, De.apply(null, arguments);
      }
      function Fe(e3, t2) {
        var r3 = Object.keys(e3);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e3);
          t2 && (n2 = n2.filter((function(t3) {
            return Object.getOwnPropertyDescriptor(e3, t3).enumerable;
          }))), r3.push.apply(r3, n2);
        }
        return r3;
      }
      function $e(e3) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var r3 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? Fe(Object(r3), true).forEach((function(t3) {
            _e(e3, t3, r3[t3]);
          })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(r3)) : Fe(Object(r3)).forEach((function(t3) {
            Object.defineProperty(e3, t3, Object.getOwnPropertyDescriptor(r3, t3));
          }));
        }
        return e3;
      }
      function _e(e3, t2, r3) {
        return (t2 = Ve(t2)) in e3 ? Object.defineProperty(e3, t2, {
          value: r3,
          enumerable: true,
          configurable: true,
          writable: true
        }) : e3[t2] = r3, e3;
      }
      function Ve(e3) {
        var t2 = ze(e3, "string");
        return "symbol" == Le(t2) ? t2 : t2 + "";
      }
      function ze(e3, t2) {
        if ("object" != Le(e3) || !e3) return e3;
        var r3 = e3[Symbol.toPrimitive];
        if (void 0 !== r3) {
          var n2 = r3.call(e3, t2 || "default");
          if ("object" != Le(n2)) return n2;
          throw new TypeError("@@toPrimitive must return a primitive value.");
        }
        return ("string" === t2 ? String : Number)(e3);
      }
      function Ke(e3, t2) {
        return Ge(e3) || Ue(e3, t2) || Be(e3, t2) || Xe();
      }
      function Xe() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      function Be(e3, t2) {
        if (e3) {
          if ("string" == typeof e3) return Ye(e3, t2);
          var r3 = {}.toString.call(e3).slice(8, -1);
          return "Object" === r3 && e3.constructor && (r3 = e3.constructor.name), "Map" === r3 || "Set" === r3 ? Array.from(e3) : "Arguments" === r3 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r3) ? Ye(e3, t2) : void 0;
        }
      }
      function Ye(e3, t2) {
        (null == t2 || t2 > e3.length) && (t2 = e3.length);
        for (var r3 = 0, n2 = Array(t2); r3 < t2; r3++) {
          n2[r3] = e3[r3];
        }
        return n2;
      }
      function Ue(e3, t2) {
        var r3 = null == e3 ? null : "undefined" != typeof Symbol && e3[Symbol.iterator] || e3["@@iterator"];
        if (null != r3) {
          var n2, o2, a2, i2, l2 = [], c2 = true, u2 = false;
          try {
            if (a2 = (r3 = r3.call(e3)).next, 0 === t2) {
              if (Object(r3) !== r3) return;
              c2 = false;
            } else for (; !(c2 = (n2 = a2.call(r3)).done) && (l2.push(n2.value), l2.length !== t2); c2 = true) {
            }
          } catch (e4) {
            u2 = true, o2 = e4;
          } finally {
            try {
              if (!c2 && null != r3["return"] && (i2 = r3["return"](), Object(i2) !== i2)) return;
            } finally {
              if (u2) throw o2;
            }
          }
          return l2;
        }
      }
      function Ge(e3) {
        if (Array.isArray(e3)) return e3;
      }
      function Je(e3, t2) {
        if (null == e3) return {};
        var r3, n2, o2 = Qe(e3, t2);
        if (Object.getOwnPropertySymbols) {
          var a2 = Object.getOwnPropertySymbols(e3);
          for (n2 = 0; n2 < a2.length; n2++) {
            r3 = a2[n2], -1 === t2.indexOf(r3) && {}.propertyIsEnumerable.call(e3, r3) && (o2[r3] = e3[r3]);
          }
        }
        return o2;
      }
      function Qe(e3, t2) {
        if (null == e3) return {};
        var r3 = {};
        for (var n2 in e3) {
          if ({}.hasOwnProperty.call(e3, n2)) {
            if (-1 !== t2.indexOf(n2)) continue;
            r3[n2] = e3[n2];
          }
        }
        return r3;
      }
      var Ze = ["clickAway", "escapeKey", "offScreen", "tabKey"];
      var et = {
        align: O().oneOf(["center", "edge", "end"]),
        anchor: O().object,
        animation: O().bool,
        animationConfig: O().object,
        appearance: O().oneOf(["normal", "inverted", "none"]),
        autoCloseWhenOffScreen: O().bool,
        canCoverAnchor: O().bool,
        children: O().oneOfType([O().node, O().func]),
        closeReasons: O().arrayOf(O().oneOf(Ze)),
        defaultPlacement: O().oneOf(["above", "below", "left", "right", "vertical", "horizontal"]),
        elementRef: O().oneOfType([O().func, O().object]),
        id: O().string,
        hideArrow: O().bool,
        hitAreaRef: O().oneOfType([O().func, O().object]),
        onRequestClose: O().func,
        open: O().bool,
        outerRef: O().oneOfType([O().func, O().object]),
        pointTo: O().shape({
          x: O().number,
          y: O().number
        }),
        repositionMode: O().oneOf(["none", "flip", "any"]),
        retainFocus: O().bool,
        takeFocus: O().bool,
        splunkTheme: O().object
      };
      var tt = {
        passive: false,
        capture: true
      };
      function rt(e3, t2) {
        var r3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
        return !!e3 && !!t2 && u()(e3, (function(e4, n2) {
          if (h()(e4)) {
            return Math.abs(t2[n2] - e4) <= r3;
          }
          return t2[n2] === e4;
        }));
      }
      function nt(e3) {
        var t2 = e3.anchorPos, r3 = e3.borderRadius, n2 = e3.placement, o2 = e3.outerContainerStyle, i2 = e3.outerContainerEl;
        if (n2 === "misaligned") {
          return [{
            display: "none"
          }];
        }
        var l2 = {
          display: "block"
        };
        var c2 = G * 2;
        var u2 = i2.offsetHeight / 2 - (G * 2 + r3 + G / 2);
        var f2 = -(i2.offsetHeight / 2 - (G + r3 + G / 2));
        var s2 = t2.center - (o2.top + i2.offsetHeight / 2) - G / 2;
        var p2 = a()(s2, f2, u2);
        var v2 = i2.offsetWidth / 2 - (c2 + G + r3);
        var d2 = -(i2.offsetWidth / 2 - (G + r3));
        var h2 = t2.middle - (o2.left + i2.offsetWidth / 2) - G;
        var m2 = a()(h2, d2, v2);
        var b2 = {
          left: {
            translateX: G / 2,
            translateY: p2,
            rotate: 90
          },
          right: {
            translateX: -G / 2,
            translateY: p2,
            rotate: -90
          },
          above: {
            translateX: m2,
            translateY: 0,
            rotate: 180
          },
          below: {
            translateX: m2,
            translateY: 0,
            rotate: 0
          }
        };
        var g2 = b2[n2];
        l2.transform = "translate(".concat(g2.translateX, "px, ").concat(g2.translateY, "px) rotate(").concat(g2.rotate, "deg)");
        var y2 = {
          left: "right",
          right: "left",
          above: "bottom",
          below: "top"
        };
        l2[y2[n2]] = "0";
        var w2 = {
          left: "top",
          right: "top",
          above: "left",
          below: "left"
        };
        l2[w2[n2]] = "50%";
        return [l2, g2];
      }
      function ot(e3) {
        var t2 = e3.anchorEl, r3 = e3.offsets, n2 = r3 === void 0 ? false : r3, o2 = e3.pointTo;
        var a2 = Me(t2, n2);
        var i2 = {
          // these are rounded to avoid causing visual regressions
          // they were previously clientWidth and clientHeight which were already rounded
          width: Math.round(a2.width),
          height: Math.round(a2.height)
        };
        var l2 = o2 && s()(o2, "x");
        var c2 = o2 && s()(o2, "y");
        i2.left = l2 ? a2.left + ((o2 === null || o2 === void 0 ? void 0 : o2.x) || 0) : a2.left;
        i2.top = c2 ? a2.top + ((o2 === null || o2 === void 0 ? void 0 : o2.y) || 0) : a2.top;
        i2.right = l2 ? i2.left + i2.width : a2.left + i2.width || a2.right;
        i2.bottom = c2 ? i2.top + i2.height : a2.top + i2.height || a2.bottom;
        i2.middle = l2 ? i2.left : a2.left + (i2.right - a2.left) / 2;
        i2.center = c2 ? i2.top : a2.top + (i2.bottom - a2.top) / 2;
        return i2;
      }
      function at(e3) {
        return e3 !== window && e3 !== window.document;
      }
      function it(e3, t2) {
        var r3 = Pe();
        if (e3.top < 0 || e3.top > r3.innerHeight || e3.left < 0 || e3.left > r3.innerWidth) {
          return true;
        }
        if (t2) {
          if (e3.height + e3.top < t2.top || e3.top > t2.bottom || e3.width + e3.left < t2.left || e3.left > t2.right) {
            return true;
          }
        }
        return false;
      }
      function lt(e3, t2) {
        var r3 = G * 2;
        return t2 !== "none" && e3 != null && h()(e3) ? e3 - r3 : e3 || null;
      }
      var ct = {};
      function ut(e3) {
        var t2, o2;
        var a2 = e3.align, i2 = a2 === void 0 ? "center" : a2, c2 = e3.anchor, u2 = e3.animation, f2 = u2 === void 0 ? true : u2, s2 = e3.animationConfig, p2 = s2 === void 0 ? ct : s2, d2 = e3.appearance, h2 = d2 === void 0 ? "normal" : d2, m2 = e3.autoCloseWhenOffScreen, g2 = m2 === void 0 ? true : m2, w2 = e3.canCoverAnchor, S2 = e3.children, O2 = e3.closeReasons, E2 = O2 === void 0 ? Ze : O2, x2 = e3.defaultPlacement, A2 = x2 === void 0 ? "below" : x2, R2 = e3.elementRef, q2 = e3.hideArrow, H2 = e3.hitAreaRef, I2 = e3.id, N2 = e3.onRequestClose, L2 = e3.open, D2 = e3.outerRef, F2 = e3.pointTo, $2 = e3.repositionMode, _2 = $2 === void 0 ? "flip" : $2, V2 = e3.retainFocus, z2 = V2 === void 0 ? true : V2, X2 = e3.takeFocus, B2 = e3.toggleId, Y2 = Je(e3, ["align", "anchor", "animation", "animationConfig", "appearance", "autoCloseWhenOffScreen", "canCoverAnchor", "children", "closeReasons", "defaultPlacement", "elementRef", "hideArrow", "hitAreaRef", "id", "onRequestClose", "open", "outerRef", "pointTo", "repositionMode", "retainFocus", "takeFocus", "toggleId"]);
        Ne({
          componentName: "Popover",
          deprecatedPropValue: "inverted",
          propName: "appearance",
          propValue: h2
        });
        var U2 = (0, r2.useState)(L2), Q2 = Ke(U2, 2), re2 = Q2[0], ne2 = Q2[1];
        var oe2 = (0, r2.useState)(false), ae2 = Ke(oe2, 2), ie2 = ae2[0], le2 = ae2[1];
        if (L2 !== ie2) {
          ne2(f2);
          le2(L2);
        }
        var ce2 = (0, r2.useState)({}), ue2 = Ke(ce2, 2), fe2 = ue2[0], se2 = ue2[1];
        var de2 = (0, r2.useRef)(true);
        var he2 = (0, r2.useRef)(false);
        var me2 = (0, r2.useRef)(null);
        var be2 = (0, r2.useRef)(null);
        var ge2 = (0, r2.useRef)(null);
        var ye2 = {
          anchorHeight: ((t2 = fe2.anchorPos) === null || t2 === void 0 ? void 0 : t2.height) || null,
          anchorWidth: ((o2 = fe2.anchorPos) === null || o2 === void 0 ? void 0 : o2.width) || null,
          placement: fe2.placement || null,
          maxHeight: lt(fe2.maxHeight, h2),
          maxWidth: lt(fe2.maxWidth, h2),
          toggleId: B2
        };
        var we2 = (0, r2.useMemo)((function() {
          return f2 ? {
            opacity: L2 ? 1 : 0
          } : {
            opacity: 1
          };
        }), [f2, L2]);
        var Se2 = Pe();
        var Oe2 = L2 || re2;
        var Ce2 = (0, r2.useContext)(T()) || Se2;
        var Ee2 = Ce2 !== Se2;
        var je2 = (0, r2.useContext)(ve), xe2 = je2.allowPropagation, ke2 = je2.hideArrow;
        var Ae2 = q2 !== null && q2 !== void 0 ? q2 : ke2;
        (0, r2.useEffect)((function() {
          if (false) {
          }
        }), [c2]);
        var Te2 = (0, r2.useCallback)((function(e4) {
          if (L2 && (E2 === null || E2 === void 0 ? void 0 : E2.includes(e4.reason))) {
            N2 === null || N2 === void 0 ? void 0 : N2(e4);
          }
        }), [E2, L2, N2]);
        var Re2 = (0, r2.useCallback)((function(e4, t3) {
          var r3 = it(e4, t3);
          if (r3) {
            Te2({
              reason: "offScreen"
            });
          }
          return r3;
        }), [Te2]);
        var Me2 = M()(), qe2 = Me2.borderRadius, He2 = Me2.spacingXSmall;
        var Ie2 = parseInt(qe2, 10);
        var Le2 = parseInt(He2, 10);
        var Fe2 = Ae2 ? Le2 : G;
        var _e2 = (0, r2.useCallback)((function(e4) {
          se2((function(t3) {
            var r3, n2;
            if (!L2 || !ge2.current || !c2) {
              return t3;
            }
            var o3 = ot({
              anchorEl: c2,
              pointTo: F2
            });
            var a3 = ot({
              anchorEl: c2,
              offsets: true,
              pointTo: F2
            });
            var l2 = at(Ce2) ? ot({
              anchorEl: Ce2,
              pointTo: F2
            }) : void 0;
            if (e4 && g2) {
              if (Re2(o3, l2)) {
                return t3;
              }
            }
            var u3 = K({
              align: i2,
              anchorPos: a3,
              scrollContainerPos: l2,
              canCoverAnchor: w2,
              defaultPlacement: A2,
              repositionMode: _2,
              outerContainerEl: ge2.current,
              padding: Fe2,
              windowWidth: Se2.innerWidth,
              windowHeight: Se2.innerHeight
            }), f3 = u3.placement, s3 = u3.outerContainerStyle, p3 = u3.maxHeight, v2 = u3.maxWidth;
            var d3 = rt(a3, t3.anchorPos) && rt(s3, t3.outerContainerStyle) && f3 === t3.placement && p3 === t3.maxHeight && v2 === t3.maxWidth;
            var h3 = true;
            var m3 = {};
            var b2;
            if (me2.current) {
              var P2 = nt({
                anchorPos: a3,
                borderRadius: Ie2,
                outerContainerStyle: s3,
                placement: f3,
                outerContainerEl: ge2.current
              });
              var S3 = Ke(P2, 2);
              m3 = S3[0];
              b2 = S3[1];
            }
            h3 = rt(y()(m3, "transform"), y()(t3.arrowStyle, "transform")) && rt((r3 = b2) !== null && r3 !== void 0 ? r3 : {}, (n2 = t3.arrowStyleTransformMeta) !== null && n2 !== void 0 ? n2 : {});
            if (d3 && h3) {
              return t3;
            }
            return {
              anchorPos: a3,
              arrowStyle: m3,
              arrowStyleTransformMeta: b2,
              outerContainerStyle: s3,
              placement: f3,
              maxHeight: p3,
              maxWidth: v2
            };
          }));
        }), [i2, c2, g2, Ie2, Fe2, w2, Re2, A2, L2, F2, _2, Ce2, Se2.innerHeight, Se2.innerWidth]);
        var Ve2 = (0, r2.useMemo)((function() {
          return P()(_e2.bind(null, true), 0);
        }), [_e2]);
        var ze2 = (0, r2.useMemo)((function() {
          return P()(_e2.bind(null, true), 0);
        }), [_e2]);
        var Xe2 = (0, r2.useMemo)((function() {
          return P()(_e2, 0, {
            leading: false
          });
        }), [_e2]);
        (0, r2.useEffect)((function() {
          if (!be2.current) {
            return;
          }
          if (L2 || re2) {
            Xe2();
          }
        }));
        (0, r2.useEffect)((function() {
          if (X2 && L2 && be2.current && fe2.placement != null && !he2.current) {
            he2.current = true;
            (0, W.takeFocus)(be2.current);
          }
        }), [L2, fe2.placement, X2]);
        (0, r2.useEffect)((function() {
          de2.current = true;
          return function() {
            Xe2.cancel();
            Ve2.cancel();
            ze2.cancel();
            de2.current = false;
          };
        }), []);
        var Be2 = Oe2 ? n().createElement(n().Fragment, null, Ee2 && n().createElement(j(), {
          target: Ce2,
          eventType: "scroll",
          listener: Ve2,
          options: tt,
          key: "eventListener"
        }), n().createElement(j(), {
          target: Se2,
          eventType: "resize",
          listener: Xe2,
          key: "eventListenerOnWindowResize"
        }), n().createElement(j(), {
          target: Se2,
          eventType: "scroll",
          listener: ze2,
          options: tt,
          key: "eventListenerOnWindowScroll"
        })) : null;
        var Ye2 = (0, r2.useCallback)((function() {
          if (de2.current) {
            ne2(false);
          }
        }), []);
        var Ue2 = (0, r2.useCallback)((function(e4) {
          be2.current = e4;
          if (e4 && X2) {
            l()(W.takeFocus, e4);
          }
          We(R2, e4);
        }), [R2, X2]);
        var Ge2 = (0, r2.useCallback)((function(e4) {
          ge2.current = e4;
          We(D2, e4);
        }), [D2]);
        var Qe2 = (0, r2.useCallback)((function(e4) {
          if (be2.current) {
            if (z2) {
              (0, W.handleTab)(be2.current, e4);
            } else if ((0, W.isTabKey)(e4)) {
              var t3 = (0, W.getSortedTabbableElements)(be2.current);
              if (t3.length > 0) {
                var r3 = e4.shiftKey ? t3[0] : t3[t3.length - 1];
                if (r3 === e4.target) {
                  Te2({
                    event: e4,
                    reason: "tabKey"
                  });
                }
              }
            }
          }
        }), [Te2, z2]);
        var et2 = (0, r2.useCallback)((function(e4) {
          if (!xe2) {
            e4.stopPropagation();
          }
        }), [xe2]);
        var ut2 = (0, r2.useMemo)((function() {
          return {
            opacity: f2 ? 0 : 1
          };
        }), [f2]);
        var ft2 = (0, r2.useMemo)((function() {
          return $e({
            tension: 300,
            friction: 20,
            clamp: true
          }, p2);
        }), [p2]);
        var st2 = (0, C.useAnimation)({
          from: ut2,
          to: we2,
          // Setting clamp to true will stop animating at the point it hit's it's goal value.
          // This will prevent click through while animating out (SUI-6618).
          config: ft2,
          onRest: Ye2
        });
        var pt = (0, r2.useMemo)((function() {
          return $e($e({}, fe2.outerContainerStyle), st2);
        }), [fe2.outerContainerStyle, st2]);
        var vt = (0, r2.useMemo)((function() {
          return v()(E2 === null || E2 === void 0 ? void 0 : E2.filter((function(e4) {
            return e4 !== "offScreen";
          })), k().possibleCloseReasons);
        }), [E2]);
        var dt = b()(S2) ? S2(ye2) : S2;
        return n().createElement(n().Fragment, null, Be2, n().createElement(k(), {
          closeReasons: vt,
          open: Oe2,
          onRequestClose: Te2,
          key: "Layer"
        }, Oe2 && be2.current && H2 && n().createElement(pe, {
          anchorRect: fe2.anchorPos,
          popoverEl: be2.current,
          popoverPlacement: fe2.placement,
          ref: H2
        }), Oe2 && n().createElement(J, {
          "data-test": "outer-popover",
          style: pt,
          ref: Ge2
        }, n().createElement(Z, De({
          $appearance: h2,
          $boxPadding: Fe2,
          $open: L2,
          "data-test": "popover",
          ref: Ue2,
          id: I2,
          onKeyDown: Qe2
        }, Y2), n().createElement(n().Fragment, null, h2 === "none" && dt, h2 !== "none" && !Ae2 && n().createElement(te, {
          "data-test": "popover-arrow",
          $appearance: h2,
          onClick: et2,
          ref: me2,
          style: fe2.arrowStyle
        }), h2 !== "none" && n().createElement(ee, {
          $appearance: h2,
          onClick: et2
        }, dt))))));
      }
      ut.propTypes = et;
      ut.possibleCloseReasons = Ze;
      const ft = ut;
      var st = (0, r2.createContext)({});
      module.exports = t;
    })();
  }
});

// node_modules/@splunk/react-ui/Tooltip.js
var require_Tooltip = __commonJS({
  "node_modules/@splunk/react-ui/Tooltip.js"(exports, module) {
    var import_dist10 = __toESM(require_dist());
    var import_dist11 = __toESM(require_dist2());
    var import_dist12 = __toESM(require_dist3());
    (() => {
      "use strict";
      var e2 = {};
      (() => {
        e2.n = (n2) => {
          var r3 = n2 && n2.__esModule ? (
            /******/
            () => n2["default"]
          ) : () => n2;
          e2.d(r3, {
            a: r3
          });
          return r3;
        };
      })();
      (() => {
        e2.d = (n2, r3) => {
          for (var t2 in r3) {
            if (e2.o(r3, t2) && !e2.o(n2, t2)) {
              Object.defineProperty(n2, t2, {
                enumerable: true,
                get: r3[t2]
              });
            }
          }
        };
      })();
      (() => {
        e2.o = (e3, n2) => Object.prototype.hasOwnProperty.call(e3, n2);
      })();
      (() => {
        e2.r = (e3) => {
          if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
            Object.defineProperty(e3, Symbol.toStringTag, {
              value: "Module"
            });
          }
          Object.defineProperty(e3, "__esModule", {
            value: true
          });
        };
      })();
      var n = {};
      e2.r(n);
      e2.d(n, {
        default: () => (
          /* reexport */
          Y
        )
      });
      const r2 = require_react();
      var t = e2.n(r2);
      const o = require_throttle();
      var a = e2.n(o);
      const l = require_prop_types();
      var i = e2.n(l);
      const u = require_InformationCircle();
      var s = e2.n(u);
      const c = require_Popover();
      var f = e2.n(c);
      const p = require_ScreenReaderContent();
      var v = e2.n(p);
      const d = require_useControlled();
      var m = e2.n(d);
      const b = require_i18n();
      const y = require_id();
      const g = (init_styled_components_esm(), __toCommonJS(styled_components_esm_exports));
      var O = e2.n(g);
      const h = require_Button();
      var S = e2.n(h);
      const C = require_themes();
      var k = O().span.withConfig({
        displayName: "TooltipStyles__Styled",
        componentId: "sc-67fvgm-0"
      })(["", ";position:relative;"], C.mixins.reset("block"));
      var E = O().span.withConfig({
        displayName: "TooltipStyles__StyledInline",
        componentId: "sc-67fvgm-1"
      })(["", ";position:relative;"], C.mixins.reset("inline-block"));
      var T = O().span.withConfig({
        displayName: "TooltipStyles__StyledToggle",
        componentId: "sc-67fvgm-2"
      })(["display:block;"]);
      var P = O().span.withConfig({
        displayName: "TooltipStyles__StyledToggleInline",
        componentId: "sc-67fvgm-3"
      })(["display:inline-block;"]);
      var j = O().div.withConfig({
        displayName: "TooltipStyles__StyledContent",
        componentId: "sc-67fvgm-4"
      })(["", ";padding:", ";user-select:none;"], C.mixins.typography("smallBody", {
        color: "active"
      }), C.variables.spacingSmall);
      var w = O()(S()).withConfig({
        displayName: "TooltipStyles__StyledButton",
        componentId: "sc-67fvgm-5"
      })(["cursor:help;border-radius:50%;"]);
      function R(e3, n2) {
        if (e3) {
          if (typeof e3 === "function") {
            e3(n2);
          } else {
            e3.current = n2;
          }
        }
      }
      function L(e3) {
        "@babel/helpers - typeof";
        return L = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
          return typeof e4;
        } : function(e4) {
          return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
        }, L(e3);
      }
      function q() {
        return q = Object.assign ? Object.assign.bind() : function(e3) {
          for (var n2 = 1; n2 < arguments.length; n2++) {
            var r3 = arguments[n2];
            for (var t2 in r3) {
              ({}).hasOwnProperty.call(r3, t2) && (e3[t2] = r3[t2]);
            }
          }
          return e3;
        }, q.apply(null, arguments);
      }
      function I(e3, n2) {
        var r3 = Object.keys(e3);
        if (Object.getOwnPropertySymbols) {
          var t2 = Object.getOwnPropertySymbols(e3);
          n2 && (t2 = t2.filter((function(n3) {
            return Object.getOwnPropertyDescriptor(e3, n3).enumerable;
          }))), r3.push.apply(r3, t2);
        }
        return r3;
      }
      function A(e3) {
        for (var n2 = 1; n2 < arguments.length; n2++) {
          var r3 = null != arguments[n2] ? arguments[n2] : {};
          n2 % 2 ? I(Object(r3), true).forEach((function(n3) {
            _(e3, n3, r3[n3]);
          })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(r3)) : I(Object(r3)).forEach((function(n3) {
            Object.defineProperty(e3, n3, Object.getOwnPropertyDescriptor(r3, n3));
          }));
        }
        return e3;
      }
      function _(e3, n2, r3) {
        return (n2 = D(n2)) in e3 ? Object.defineProperty(e3, n2, {
          value: r3,
          enumerable: true,
          configurable: true,
          writable: true
        }) : e3[n2] = r3, e3;
      }
      function D(e3) {
        var n2 = M(e3, "string");
        return "symbol" == L(n2) ? n2 : n2 + "";
      }
      function M(e3, n2) {
        if ("object" != L(e3) || !e3) return e3;
        var r3 = e3[Symbol.toPrimitive];
        if (void 0 !== r3) {
          var t2 = r3.call(e3, n2 || "default");
          if ("object" != L(t2)) return t2;
          throw new TypeError("@@toPrimitive must return a primitive value.");
        }
        return ("string" === n2 ? String : Number)(e3);
      }
      function N(e3, n2) {
        return K(e3) || F(e3, n2) || B(e3, n2) || x();
      }
      function x() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      function B(e3, n2) {
        if (e3) {
          if ("string" == typeof e3) return H(e3, n2);
          var r3 = {}.toString.call(e3).slice(8, -1);
          return "Object" === r3 && e3.constructor && (r3 = e3.constructor.name), "Map" === r3 || "Set" === r3 ? Array.from(e3) : "Arguments" === r3 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r3) ? H(e3, n2) : void 0;
        }
      }
      function H(e3, n2) {
        (null == n2 || n2 > e3.length) && (n2 = e3.length);
        for (var r3 = 0, t2 = Array(n2); r3 < n2; r3++) {
          t2[r3] = e3[r3];
        }
        return t2;
      }
      function F(e3, n2) {
        var r3 = null == e3 ? null : "undefined" != typeof Symbol && e3[Symbol.iterator] || e3["@@iterator"];
        if (null != r3) {
          var t2, o2, a2, l2, i2 = [], u2 = true, s2 = false;
          try {
            if (a2 = (r3 = r3.call(e3)).next, 0 === n2) {
              if (Object(r3) !== r3) return;
              u2 = false;
            } else for (; !(u2 = (t2 = a2.call(r3)).done) && (i2.push(t2.value), i2.length !== n2); u2 = true) {
            }
          } catch (e4) {
            s2 = true, o2 = e4;
          } finally {
            try {
              if (!u2 && null != r3["return"] && (l2 = r3["return"](), Object(l2) !== l2)) return;
            } finally {
              if (s2) throw o2;
            }
          }
          return i2;
        }
      }
      function K(e3) {
        if (Array.isArray(e3)) return e3;
      }
      function W(e3, n2) {
        if (null == e3) return {};
        var r3, t2, o2 = V(e3, n2);
        if (Object.getOwnPropertySymbols) {
          var a2 = Object.getOwnPropertySymbols(e3);
          for (t2 = 0; t2 < a2.length; t2++) {
            r3 = a2[t2], -1 === n2.indexOf(r3) && {}.propertyIsEnumerable.call(e3, r3) && (o2[r3] = e3[r3]);
          }
        }
        return o2;
      }
      function V(e3, n2) {
        if (null == e3) return {};
        var r3 = {};
        for (var t2 in e3) {
          if ({}.hasOwnProperty.call(e3, t2)) {
            if (-1 !== n2.indexOf(t2)) continue;
            r3[t2] = e3[t2];
          }
        }
        return r3;
      }
      var U = ["focusToggle", "mouseEnterPopover", "mouseEnterToggle", "mouseEnterHitArea"];
      var $ = ["blurToggle", "clickAway", "escapeKey", "mouseLeaveHitArea", "mouseLeavePopover", "mouseLeaveToggle", "mouseStopHitArea", "offScreen", "tabKey", "toggleClick"];
      var z = {
        /** @private */
        appearance: i().string,
        /** @private */
        append: i().bool,
        children: i().node,
        closeDelay: i().number,
        /** @private */
        closeWhen: i().oneOf(["default", "notOnClick"]),
        content: i().node,
        contentRelationship: i().oneOf(["label", "description"]),
        defaultPlacement: i().oneOf(["above", "below", "left", "right"]),
        elementRef: i().oneOfType([i().func, i().object]),
        inline: i().bool,
        onRequestClose: i().func,
        onRequestOpen: i().func,
        open: i().bool,
        openDelay: i().oneOfType([i().oneOf(["primary", "secondary"]), i().number]),
        /** @private */
        prepend: i().bool,
        renderAnchor: i().func
      };
      var G = {
        tension: 400
      };
      var J = ["offScreen", "escapeKey"];
      var Q = t().createElement(s(), null);
      function X(e3) {
        var n2 = e3.appearance, o2 = e3.append, l2 = e3.children, i2 = e3.closeDelay, u2 = i2 === void 0 ? 300 : i2, s2 = e3.closeWhen, c2 = s2 === void 0 ? "default" : s2, p2 = e3.content, d2 = e3.contentRelationship, g2 = e3.defaultPlacement, O2 = g2 === void 0 ? "above" : g2, h2 = e3.elementRef, S2 = e3.inline, C2 = S2 === void 0 ? true : S2, L2 = e3.onRequestClose, I2 = e3.onRequestOpen, _2 = e3.open, D2 = e3.openDelay, M2 = D2 === void 0 ? "primary" : D2, x2 = e3.renderAnchor, B2 = e3.prepend, H2 = W(e3, ["appearance", "append", "children", "closeDelay", "closeWhen", "content", "contentRelationship", "defaultPlacement", "elementRef", "inline", "onRequestClose", "onRequestOpen", "open", "openDelay", "renderAnchor", "prepend"]);
        var F2 = (0, r2.useState)(false), K2 = N(F2, 2), V2 = K2[0], U2 = K2[1];
        var $2 = (0, r2.useState)(null), z2 = N($2, 2), X2 = z2[0], Y2 = z2[1];
        var Z = (0, r2.useState)(null), ee = N(Z, 2), ne = ee[0], re = ee[1];
        var te = (0, r2.useState)(null), oe = N(te, 2), ae = oe[0], le = oe[1];
        var ie = (0, r2.useState)(null), ue = N(ie, 2), se = ue[0], ce = ue[1];
        var fe = (0, r2.useState)((function() {
          return {
            ariaId: (0, y.createDOMID)("aria-id"),
            popoverId: (0, y.createDOMID)("popover")
          };
        })), pe = N(fe, 1), ve = pe[0], de = ve.ariaId, me = ve.popoverId;
        var be = m()({
          componentName: "Tooltip",
          /* eslint-disable-next-line prefer-rest-params */
          componentProps: arguments[0],
          // see SUI-7028
          defaultValuePropName: "defaultOpen",
          valuePropName: "open"
        });
        var ye = (0, r2.useMemo)((function() {
          var e4 = !!p2;
          return !!X2 && be ? _2 : e4 && V2;
        }), [X2, p2, be, V2, _2]);
        var ge = (0, r2.useRef)();
        (0, r2.useEffect)((function() {
          return function() {
            if (ge.current !== void 0) {
              clearTimeout(ge.current);
            }
          };
        }), []);
        var Oe = (0, r2.useCallback)((function(e4, n3) {
          if (ge.current !== void 0) {
            clearTimeout(ge.current);
          }
          ge.current = setTimeout((function() {
            if (!be) {
              U2(false);
            }
            L2 === null || L2 === void 0 ? void 0 : L2(e4, n3);
          }), u2);
        }), [u2, be, L2]);
        var he = (0, r2.useCallback)((function(e4, n3) {
          var r3 = M2 === "primary" ? 300 : 750;
          var t2 = typeof M2 === "number" ? M2 : r3;
          if (ge.current !== void 0) {
            clearTimeout(ge.current);
          }
          ge.current = setTimeout((function() {
            var r4 = ye;
            if (!be) {
              U2(true);
            }
            if (!r4) {
              I2 === null || I2 === void 0 ? void 0 : I2(e4, n3);
            }
          }), t2);
        }), [be, ye, I2, M2]);
        var Se = (0, r2.useCallback)((function(e4) {
          he(e4, {
            reason: "mouseEnterToggle"
          });
        }), [he]);
        var Ce = (0, r2.useCallback)((function(e4) {
          he(e4, {
            reason: "mouseEnterPopover"
          });
        }), [he]);
        var ke = (0, r2.useCallback)((function(e4) {
          he(e4, {
            reason: "mouseEnterHitArea"
          });
        }), [he]);
        var Ee = (0, r2.useCallback)((function(e4) {
          var n3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "mouseLeaveToggle";
          if (e4.relatedTarget == null || e4.relatedTarget !== ae && e4.relatedTarget !== se) {
            Oe(e4, {
              reason: n3
            });
          }
        }), [Oe, ae, se]);
        var Te = (0, r2.useCallback)((function(e4) {
          Ee(e4, "mouseLeavePopover");
        }), [Ee]);
        var Pe = (0, r2.useCallback)((function(e4) {
          Ee(e4, "mouseLeaveHitArea");
        }), [Ee]);
        var je = (0, r2.useCallback)((function(e4) {
          Oe(e4, {
            reason: "mouseStopHitArea"
          });
        }), [Oe]);
        var we = a()(je, 10);
        var Re = (0, r2.useCallback)((function(e4) {
          if (e4) {
            e4.addEventListener("mouseenter", Se);
            e4.addEventListener("mouseleave", Ee);
          } else if (X2) {
            X2.removeEventListener("mouseenter", Se);
            X2.removeEventListener("mouseleave", Ee);
          }
          Y2(e4);
        }), [X2, Se, Ee]);
        var Le = (0, r2.useCallback)((function(e4) {
          if (e4) {
            e4.addEventListener("mouseenter", Ce);
            e4.addEventListener("mouseleave", Te);
          } else if (ae) {
            ae.removeEventListener("mouseenter", Ce);
            ae.removeEventListener("mouseleave", Te);
          }
          le(e4);
        }), [Ce, Te, ae]);
        var qe = (0, r2.useCallback)((function(e4) {
          ce(e4);
        }), []);
        var Ie = (0, r2.useCallback)((function(e4) {
          if (e4) {
            e4.addEventListener("mouseenter", ke);
            e4.addEventListener("mousemove", we);
            e4.addEventListener("mouseleave", Pe);
          } else if (ne) {
            ne.removeEventListener("mouseenter", ke);
            ne.removeEventListener("mousemove", we);
            ne.removeEventListener("mouseleave", Pe);
          }
          re(e4);
        }), [ke, Pe, we, ne]);
        var Ae = (0, r2.useCallback)((function(e4) {
          if (c2 !== "notOnClick") {
            Oe(e4, {
              reason: "toggleClick"
            });
          }
        }), [c2, Oe]);
        var _e = (0, r2.useCallback)((function(e4) {
          he(e4, {
            reason: "focusToggle"
          });
        }), [he]);
        var De = (0, r2.useCallback)((function(e4) {
          Oe(e4, {
            reason: "blurToggle"
          });
        }), [Oe]);
        var Me = (0, r2.useCallback)((function(e4) {
          Oe(null, e4);
        }), [Oe]);
        var Ne = (0, r2.useCallback)((function(e4) {
          Re(e4);
          R(h2, e4);
        }), [h2, Re]);
        var xe = (0, r2.useMemo)((function() {
          return {
            "data-test": "toggle",
            elementRef: Ne,
            onBlur: De,
            onClick: Ae,
            onFocus: _e
          };
        }), [De, Ae, _e, Ne]);
        var Be = (0, r2.useMemo)((function() {
          return d2 === "label" ? {
            "aria-labelledby": de,
            labelledBy: de
          } : {
            "aria-describedby": de,
            describedBy: de
          };
        }), [d2, de]);
        var He = (0, r2.useMemo)((function() {
          return {
            append: o2,
            prepend: B2
          };
        }), [o2, B2]);
        var Fe = (0, r2.useMemo)((function() {
          return A(A(A({}, Be), xe), He);
        }), [Be, xe, He]);
        var Ke = (0, r2.useMemo)((function() {
          return A(A({}, Be), He);
        }), [Be, He]);
        var We = (0, r2.useCallback)((function() {
          if (false) {
          }
          return x2 === null || x2 === void 0 ? void 0 : x2(A(A(A({}, Fe), Be), He));
        }), [Be, Fe, l2, He, x2]);
        var Ve = (0, r2.useCallback)((function() {
          var e4;
          if ((0, r2.isValidElement)(l2)) {
            e4 = (0, r2.cloneElement)(l2, Ke);
          } else if (l2) {
            e4 = l2;
          } else {
            e4 = t().createElement(w, {
              appearance: "subtle",
              "aria-describedby": de,
              "aria-label": (0, b._)("More info"),
              icon: Q
            });
          }
          var n3 = C2 ? P : T;
          return t().createElement(n3, {
            "data-test": "toggle",
            onClick: Ae,
            onFocus: _e,
            onBlur: De,
            ref: Re
          }, e4);
        }), [l2, C2, Ae, _e, De, Re, Ke, de]);
        var Ue = C2 ? E : k;
        var $e = !!p2 && t().createElement(v(), {
          "aria-hidden": "true",
          id: de
        }, p2);
        var ze = t().createElement(f(), {
          role: "tooltip",
          align: "center",
          anchor: X2,
          animationConfig: G,
          appearance: n2,
          closeReasons: J,
          defaultPlacement: O2,
          id: me,
          open: ye,
          onRequestClose: Me,
          elementRef: Le,
          hitAreaRef: Ie,
          outerRef: qe
        }, t().createElement(j, null, p2));
        if (x2) {
          return t().createElement(t().Fragment, null, We(), $e, ze);
        }
        return t().createElement(Ue, q({
          "data-test": "tooltip",
          "data-test-open": ye,
          "data-test-popover-id": me,
          ref: h2
        }, H2), Ve(), $e, ze);
      }
      X.propTypes = z;
      X.possibleOpenReasons = U;
      X.possibleCloseReasons = $;
      const Y = X;
      module.exports = n;
    })();
  }
});

export {
  require_usePrevious,
  require_Box,
  require_defer,
  require_cjs6 as require_cjs,
  require_AnimationToggle,
  require_Animation,
  dequal,
  init_dist,
  require_EventListener,
  require_Layer,
  require_ScrollContainerContext,
  require_sortBy,
  require_focus,
  require_Popover,
  require_useControlled,
  require_Tooltip
};
//# sourceMappingURL=chunk-G6OHCFVG.js.map
