{
  "version": 3,
  "sources": ["../../@splunk/datasources/src/CloudSearch.ts", "../../@splunk/datasources/rxjs", "../../@splunk/datasources/lodash", "../../@splunk/datasources/memoize-one", "../../@splunk/datasources/moment", "../../@splunk/datasources/@splunkdev/cloud-sdk/services/search", "../../@splunk/datasources/@splunkdev/cloud-sdk/client", "../../@splunk/datasources/@splunk/datasource-utils", "../../@splunk/datasources/@splunk/ui-utils/i18n", "../../@splunk/datasources/@splunk/dashboard-utils", "../../@splunk/datasources/src/DataSource.ts", "../../@splunk/datasources/src/utils/addLeadingSearchCommand.ts", "../../@splunk/datasources/src/utils/SimpleScheduler.ts", "../../@splunk/datasources/src/CloudSearchOptionsSchema.ts", "../../@splunk/datasources/@splunk/dashboard-definition", "../../@splunk/datasources/src/utils/SearchConfigUtils.js"],
  "sourcesContent": ["import { Observable } from 'rxjs';\nimport type { Subscriber } from 'rxjs';\nimport { pick, isEqual } from 'lodash';\nimport memoizeOne from 'memoize-one';\nimport moment from 'moment';\nimport { SearchService } from '@splunkdev/cloud-sdk/services/search';\nimport type {\n    Message,\n    SearchJob,\n    UpdateJob,\n} from '@splunkdev/cloud-sdk/services/search';\nimport {\n    ServiceClient,\n    RequestQueueManagerParams,\n} from '@splunkdev/cloud-sdk/client';\nimport type { QueryArgs } from '@splunkdev/cloud-sdk/client';\nimport { DataSet, DS_STATUS } from '@splunk/datasource-utils';\nimport { _ } from '@splunk/ui-utils/i18n';\nimport type { SplunkAuthClient } from '@splunkdev/cloud-auth-client';\nimport type {\n    DataSourceConfigMeta,\n    FieldObj,\n    JSONArray,\n    RequestParams,\n    DataSourceMeta,\n    JobStatus,\n} from '@splunk/dashboard-types';\nimport { getDefaultDataSourceName, wait } from '@splunk/dashboard-utils';\nimport DataSource from './DataSource';\nimport addLeadingSearchCommand from './utils/addLeadingSearchCommand';\nimport SimpleScheduler from './utils/SimpleScheduler';\nimport CloudSearchOptionsSchema from './CloudSearchOptionsSchema';\nimport { getDefaultOptionsForSearchQuery } from './utils/SearchConfigUtils';\nimport type { ObservableData } from './types';\n\n// This is not exported from the cloud-sdk/client for use\ninterface RequestQueueParams {\n    initialTimeout: number;\n    exponent: number;\n    retries: number;\n    maxInFlight: number;\n    // currently unused by udf\n    enableRetryHeader?: boolean;\n}\n\nexport interface CloudSearchOptions {\n    query: string;\n    queryParameters: {\n        earliest: string;\n        latest: string;\n    };\n    requiredFreshness?: number;\n    module?: string;\n    sid?: string;\n    [key: string]: unknown;\n}\n\nexport interface CloudSearchContextConfig {\n    cloudApiUrl?: string;\n    accessToken?: string;\n    authClient: InstanceType<typeof SplunkAuthClient>;\n    tenantId: string;\n    searchSubmitQueueParams?: Partial<RequestQueueParams>;\n    searchQueueParams?: Partial<RequestQueueParams>;\n    requestQueueManagerParams?: Partial<RequestQueueParams>;\n    defaultModule?: string;\n    [key: string]: unknown;\n}\n\ninterface PageData extends JSONArray {\n    nextLink?: string;\n    wait?: string;\n}\n\ninterface QueryParameters {\n    earliest: string;\n    earliestTime: string;\n    // eslint-disable-next-line camelcase\n    earliest_time: string;\n    latest: string;\n    latestTime: string;\n    // eslint-disable-next-line camelcase\n    latest_time: string;\n    timezone: string;\n}\n\ninterface NormalizedQueryParameters {\n    earliest: string;\n    latest: string;\n    timezone: string;\n}\n\ntype CurrentJob = Awaited<ReturnType<SearchService['getJob']>> | null;\n\nexport type CloudSearchConfigMeta = DataSourceConfigMeta<\n    typeof CloudSearchOptionsSchema\n>;\n\n/**\n * Get status message based on search job properties\n * @private\n */\nexport const getStatusMessage = ({\n    status,\n    totalCount,\n}: {\n    status?: JobStatus | null;\n    totalCount?: number;\n}): string => {\n    if (status === DS_STATUS.RUNNING && totalCount === 0) {\n        return _(\n            'Search is running, but not enough data to render visualization'\n        );\n    }\n\n    if (status === DS_STATUS.DONE && totalCount === 0) {\n        return _('Search ran successfully, but no results were returned');\n    }\n\n    if (!status) {\n        return _('Search is not yet running, queued on client');\n    }\n\n    return '';\n};\n\n/**\n * get sdk client\n * @param {String} cloudApiUrl cloud api url\n * @param {String} accessToken access token as string\n * @param {CloudAuthClient} authClient cloud-auth instance\n * @param {String} tenantId tenant id\n */\nconst getSdkClient = ({\n    cloudApiUrl,\n    accessToken,\n    authClient,\n    tenantId,\n    searchSubmitQueueParams = {},\n    searchQueueParams = {},\n}: CloudSearchContextConfig) => {\n    const serviceClient = new ServiceClient({\n        urls: cloudApiUrl ? { api: cloudApiUrl } : undefined,\n        tokenSource: async () => accessToken || authClient.getAccessToken(),\n        defaultTenant: tenantId,\n        requestQueueManagerParams: new RequestQueueManagerParams(\n            {\n                // These are taken from overrides in DefaultQueueManagerParams (https://github.com/splunk/splunk-cloud-sdk-js) (src/client.ts)\n                retries: 6,\n                initialTimeout: 1000,\n                exponent: 1.6,\n                maxInFlight: 3,\n            },\n            // FYI 'search-submit' queue is to start search job while 'search' queue is for search status and results requests.\n            new Map([\n                [\n                    'search-submit', // SEARCH_SUBMIT_QUEUE is not exported (https://github.com/splunk/splunk-cloud-sdk-js) (src/client.ts)\n                    {\n                        retries: searchSubmitQueueParams?.retries ?? 10,\n                        initialTimeout:\n                            searchSubmitQueueParams?.initialTimeout ?? 1000,\n                        exponent: searchSubmitQueueParams?.exponent ?? 1.6,\n                        maxInFlight: searchSubmitQueueParams?.maxInFlight ?? 10,\n                    },\n                ],\n                [\n                    'search',\n                    {\n                        retries: searchQueueParams?.retries ?? 10,\n                        initialTimeout:\n                            searchQueueParams?.initialTimeout ?? 500,\n                        exponent: searchQueueParams?.exponent ?? 2,\n                        maxInFlight: searchQueueParams?.maxInFlight ?? 10,\n                    },\n                ],\n            ])\n        ),\n    });\n    return new SearchService(serviceClient);\n};\n\n/**\n * a cached version of getSdkClient;\n */\nconst getCachedSdkClient = memoizeOne(getSdkClient, isEqual);\n\n/**\n * polling intervals\n */\nconst JOB_POLLING_INTERVAL = 400;\nconst RESULTS_POLLING_INTERVAL = 500;\nconst OTHER_SEARCH_PARAMS = [\n    'extractAllFields',\n    'timeFormat',\n    'maxTime',\n    'timeOfSearch',\n    'enablePreview',\n    'requiredFreshness',\n];\n\n/**\n * Find message in job status\n * @param {Array} messages\n * @param {String} type\n */\nconst findMessages = (messages: Message[] = [], type = 'INFO') =>\n    messages.filter((m) => m.type === type);\n\n/**\n * Extract error message from messages lists\n */\nconst extractErrorMessage = (messages: Message[] = []) =>\n    findMessages(messages, 'ERROR')\n        .map((m: Message) => m.text)\n        .join(',');\n\n/**\n * check if job is done\n * @param {Object} job job properties\n */\nexport const isJobDone = (job?: SearchJob | null): boolean =>\n    job?.status === DS_STATUS.DONE;\n\n/**\n * check if job is failed\n * @param {Object} job job instance\n * @returns {Boolean}\n */\nexport const isJobFailed = (job?: SearchJob | null): boolean =>\n    job?.status === DS_STATUS.FAILED;\n\n/**\n * check if job is either done or failed\n * @param {Object} job job instance\n * @returns {Boolean}\n */\nexport const isJobCompleted = (job?: SearchJob | null): boolean =>\n    !!job && (isJobDone(job) || isJobFailed(job));\n\n/**\n * should update job stats\n * @param {Object} job job instance\n * @returns {Boolean}\n */\nexport const shouldUpdateJob = (job?: SearchJob | null): boolean =>\n    !job || !isJobCompleted(job);\n\n/**\n * return true if we need to fetch current result.\n * @param {Object} job job instance\n * @param {Boolean} [progress=true] whether allow fetching intermediate data\n * @private\n */\nexport const shouldFetch = (job: SearchJob, progress = true): boolean => {\n    // disable fetch when search is running\n    return progress || isJobDone(job);\n};\n\nconst normalizeEarliest = (\n    queryParameters: Partial<QueryParameters>\n): string => {\n    let earliest =\n        queryParameters.earliest ||\n        queryParameters.earliestTime ||\n        queryParameters.earliest_time ||\n        // another normalization to make both customers and search service API happy\n        '0';\n\n    // this is to be compliant with the `v2beta1` version of SCP search API, sigh...\n    // here's its requirement: \"When specifying an absolute time specify either UNIX time, or UTC in seconds using the ISO-8601 (%FT%T.%Q) format. For example 2019-01-25T13:15:30Z. GMT is the default timezone. You must specify GMT when you specify UTC. Any offset specified is ignored.\"\n    // so basically it is saying if the time format is ISO it must ends with 'Z'\n    // additionally, SCP doesn't support user timezone setting, so we agreed on setting to browser's timezone!\n    if (\n        moment(earliest, moment.ISO_8601, true).isValid() &&\n        !earliest.endsWith('Z')\n    ) {\n        earliest = moment(earliest).toISOString();\n    }\n\n    return earliest;\n};\n\nconst normalizeLatest = (queryParameters: Partial<QueryParameters>): string => {\n    let latest =\n        queryParameters.latest ||\n        queryParameters.latestTime ||\n        queryParameters.latest_time ||\n        // This is to make sure current react time range picker works. Remove at your own peril!\n        'now';\n\n    // this is to be compliant with the `v2beta1` version of SCP search API, sigh...\n    // here's its requirement: \"When specifying an absolute time specify either UNIX time, or UTC in seconds using the ISO-8601 (%FT%T.%Q) format. For example 2019-01-25T13:15:30Z. GMT is the default timezone. You must specify GMT when you specify UTC. Any offset specified is ignored.\"\n    // so basically it is saying if the time format is ISO it must ends with 'Z'\n    // additionally, SCP doesn't support user timezone setting, so we agreed on setting to browser's timezone!\n    if (\n        moment(latest, moment.ISO_8601, true).isValid() &&\n        !latest.endsWith('Z')\n    ) {\n        latest = moment(latest).toISOString();\n    }\n\n    return latest;\n};\n\nconst normalizeTimezone = (queryParameters: Partial<QueryParameters>): string =>\n    queryParameters.timezone ||\n    Intl.DateTimeFormat().resolvedOptions().timeZone;\n\n/**\n * Normalize queryParameters so that search API v1beta1 doesn't throw error\n * @param {Object} queryParameters\n */\nexport const normalizeQueryParameters = (\n    queryParameters: Partial<QueryParameters> = {}\n): NormalizedQueryParameters => ({\n    earliest: normalizeEarliest(queryParameters),\n    latest: normalizeLatest(queryParameters),\n    timezone: normalizeTimezone(queryParameters),\n});\n\n/**\n * an object with supported time durations and their multiplier\n * to convert to milliseconds. don't expect wait time to be > minutes\n */\nconst supportedTimeDurations: Record<string, number> = {\n    ms: 1,\n    s: 1000,\n    m: 60000,\n};\n\nconst numberUnitRegex = /(\\d+)(\\w+)/;\n/**\n * convert the wait string returned by the endpoint to milliseconds\n * @param {String} wait time as string e.g. '5s' is 5 seconds, '500ms' is 500 milliseconds\n */\nexport const getWaitTimeInMs = (waitStr?: string): number => {\n    if (!waitStr) {\n        return 0;\n    }\n    const matches = numberUnitRegex.exec(waitStr);\n    if (!matches || matches.length !== 3) {\n        return 0;\n    }\n    const unit = matches[2]; // this assumes we always have a unit\n    const time = parseInt(matches[1], 10);\n    if (supportedTimeDurations[unit]) {\n        return time * supportedTimeDurations[unit];\n    }\n    return time;\n};\n\n/**\n * Split a relative url into pathname and query string parts\n * @param {String} relativeUrl A relative url\n * @returns {Object} { url, query }\n */\nconst parseNextLink = (relativeUrl: string) => {\n    if (!URL.canParse(relativeUrl)) {\n        if (!relativeUrl.includes('?')) {\n            return { url: relativeUrl, query: {} };\n        }\n\n        const [url, query] = relativeUrl.split('?', 2);\n        const searchParams = new URLSearchParams(query);\n        return { url, query: Object.fromEntries(searchParams.entries()) };\n    }\n\n    const { origin, pathname, searchParams } = URL.parse(relativeUrl) as URL;\n    return {\n        url: pathname ? `${origin}${pathname}` : origin,\n        query: Object.fromEntries(searchParams.entries()),\n    };\n};\n\n/**\n * fetch paged data or data that is not ready yet\n *\n * @param {SDKClient} client sdk client\n * @param {String} link to page to be fetched\n * @param {Number} time to wait in milliseconds (if result set is not ready yet)\n */\nexport const fetchPagedData = async (\n    client: ServiceClient,\n    link: string,\n    timeToWait = 0,\n    queryData: QueryArgs = {}\n): Promise<JSONArray> => {\n    if (timeToWait) {\n        await wait(timeToWait);\n    }\n    // sdk is using { query: {} } to instruct query parameters lol.\n    const pageResponse = await client.get('api', link, { query: queryData });\n    // Casting here is sketchy as the client code doesn't really specify this very well.\n    const pageData = pageResponse.body as PageData;\n    let { fields = [], results = [] } = pageData;\n    if (pageData.nextLink) {\n        const { url, query } = parseNextLink(pageData.nextLink);\n        const nextPageData = await fetchPagedData(\n            client,\n            url,\n            getWaitTimeInMs(pageData.wait),\n            query\n        );\n\n        results = results.concat(nextPageData.results);\n        fields = fields || nextPageData.fields;\n    }\n    return {\n        fields,\n        results,\n    };\n};\n\n/**\n * fetch actual data from 'source' endpoint.\n * @param {SDKClient} client search service sdk client\n * @param {Object} requestParams requestParams from request function.\n * @param {Object} job search job\n */\nexport const fetchData = async (\n    searchServiceClient: SearchService,\n    requestParams: RequestParams,\n    job: CurrentJob\n): Promise<DataSet | null> => {\n    // bail if we haven't started a job\n    if (!job?.sid) {\n        return null;\n    }\n    let data: DataSet | null = null;\n\n    const fetchParams = pick(requestParams, [\n        'offset',\n        'count',\n        'field',\n        'search',\n    ]);\n\n    const fetchResultFn = job.enablePreview\n        ? searchServiceClient.listPreviewResults\n        : searchServiceClient.listResults;\n    const response = await fetchResultFn(job.sid, fetchParams);\n    let { fields = [], results = [] } = response;\n    // if there is a nextLink\n    // the result set either exceeds the maximum page size or is not ready yet\n    // https://confluence.splunk.com/display/PROD/Implementation+of+Server+Driven+Paging+for+Search+Service\n    if (response.nextLink) {\n        const { url, query } = parseNextLink(response.nextLink);\n        const pageData = await fetchPagedData(\n            searchServiceClient.client,\n            url,\n            getWaitTimeInMs(response.wait),\n            query\n        );\n\n        fields = fields.length ? fields : pageData.fields;\n        results = results.concat(pageData.results);\n    }\n    // We will emit data out when\n    // 1) response contains data (fields.length && results.length)\n    // 2) job is complete, in this case we need to emit dataset even it's empty\n    if (isJobCompleted(job) || (fields.length && results.length)) {\n        data = DataSet.fromJSONArray(fields as FieldObj[], results);\n    }\n    return data;\n};\n\n/**\n * pick datasource metadata from job properties.\n * @param {Object} job job properties\n * @returns {Object} job metadata object normalized as per go/search-job-metadata\n */\nexport const fetchMetaData = (job: SearchJob): DataSourceMeta => {\n    const jobProperties = pick(job, [\n        'status',\n        'sid',\n        'percentComplete',\n    ]) as DataSourceMeta;\n    // we always include totalCount to show warning on viz if 0 results returned\n    jobProperties.totalCount = job.resultsAvailable ?? 0;\n    // Enterprise has real-time searches, SCS does not so always set to false.\n    jobProperties.isRealTimeSearch = false;\n    jobProperties.statusMessage = getStatusMessage(\n        pick(jobProperties, ['status', 'totalCount', 'isRealTimeSearch'])\n    );\n    jobProperties.lastUpdated = job?.completionTime || job?.dispatchTime;\n    return jobProperties;\n};\n\nconst CloudSearchConfig: CloudSearchConfigMeta = {\n    title: _('Search'),\n    displayDataSourceItemListByDefault: true,\n    canCreateDataSource: true,\n    dataSourceRemoveVerb: 'delete',\n    isDataSourceNameEditable: true,\n    getDataSourceName: getDefaultDataSourceName,\n    defaultOptions: ({ definition }) =>\n        getDefaultOptionsForSearchQuery(definition),\n    editorConfig: [],\n    optionsSchema: CloudSearchOptionsSchema,\n};\n\n/**\n * Create a new `CloudSearch` datasource instance. Datasource is a module that provides data into a visualization.\n * One datasource can bind to multiple viz while one viz can be powered by multiple datasources.\n * This is specific to SDC search framework and use js-sdk search framework.\n * Examples:\n * ```js\n *      try {\n *          const datasource = new CloudSearch(options, context);\n *      } catch (e) {\n *          // Handle error here.\n *      }\n *```\n * @param {Object} options - Search parameters.\n * @param {String} options.query - The search string. This is the only required search param.\n * @param {String} options.queryParameters.earliestTime - earliest time of the query\n * @param {String} options.queryParameters.latestTime - latest time of the query\n * @param {String} options.requiredFreshness - freshness of search used for search job caching\n * @param {String} options.module - search module\n * @param {Object} context - ssc config parameters.\n * @param {Object} context.authClient - instance of @splunk/ssc-auth\n * @param {String} context.tenantId - current user tenantId to make the request to sdc search service\n * @returns {CloudSearch} A new CloudSearch datasource instance.\n * @public\n */\nclass CloudSearch extends DataSource<\n    CloudSearchOptions,\n    CloudSearchContextConfig\n> {\n    static readonly schema = CloudSearchOptionsSchema;\n\n    static readonly config = CloudSearchConfig;\n\n    private client: ReturnType<typeof getSdkClient> | null = null;\n\n    private currentJob: CurrentJob;\n\n    caughtError: string | null;\n\n    isTeardown: boolean;\n\n    private jobId: string | undefined;\n\n    private updateJobScheduler: InstanceType<typeof SimpleScheduler> | null =\n        null;\n\n    constructor(\n        options: CloudSearchOptions = {} as CloudSearchOptions,\n        context: CloudSearchContextConfig = {} as CloudSearchContextConfig\n    ) {\n        super(options, context);\n        this.currentJob = null;\n        this.caughtError = null;\n        this.isTeardown = false;\n        this.updateJob = this.updateJob.bind(this);\n\n        if (!this.options.query && !this.options.sid) {\n            throw Error('search string or sid is required!');\n        }\n        if (!this.context.tenantId) {\n            throw Error('tenantId is required');\n        }\n        if (\n            this.context.accessToken == null &&\n            this.context.authClient == null\n        ) {\n            throw Error('authClient or accessToken is required');\n        }\n    }\n\n    /**\n     * create a sdk client\n     */\n    getServiceClient(): ReturnType<typeof getSdkClient> {\n        if (this.client === null) {\n            const {\n                cloudApiUrl,\n                accessToken,\n                authClient,\n                tenantId,\n                cacheClient = true,\n                searchQueueParams,\n            } = this.context;\n            // For backwards compatibility, previously it was 'requestQueueManagerParams'. Now it's renamed since we have 2 queues with diff params.\n            const searchSubmitQueueParams:\n                | Partial<RequestQueueParams>\n                | undefined =\n                this.context.searchSubmitQueueParams ||\n                this.context.requestQueueManagerParams;\n\n            const getFn = cacheClient ? getCachedSdkClient : getSdkClient;\n            this.client = getFn({\n                cloudApiUrl,\n                accessToken,\n                authClient,\n                tenantId,\n                searchSubmitQueueParams,\n                searchQueueParams,\n            });\n        }\n\n        return this.client;\n    }\n\n    /**\n     * Creates a search job and returns a jobId.\n     *\n     * Examples:\n     * ```js\n     *      const datasource = new CloudSearch(options, context);\n     *      const sid = await datasource.setup();\n     *```\n     * @throws {error} If request to sdk endpoint fails\n     * @returns {Promise<string>} The SID of created search.\n     * @public\n     */\n    async setup(): Promise<string | null> {\n        // Must do an explicit undefined check to allow the user specified default module value of empty string \"\"\n        const module =\n            this.options.module === undefined\n                ? this.context.defaultModule\n                : this.options.module;\n\n        const jobParams: SearchJob = {\n            // we by default enable preview unless user set `enablePreview` to false in options\n            enablePreview: true,\n            ...pick(this.options, OTHER_SEARCH_PARAMS),\n            module,\n            // When a sid is passed, it may not have a query\n            query: this.options.query\n                ? addLeadingSearchCommand(this.options.query)\n                : this.options.query,\n        };\n\n        if (this.options.queryParameters) {\n            jobParams.queryParameters = normalizeQueryParameters(\n                this.options.queryParameters\n            );\n        }\n\n        try {\n            const job = this.options.sid\n                ? await this.getServiceClient().getJob(this.options.sid)\n                : await this.getServiceClient().createJob(jobParams);\n            if (!job) {\n                throw new Error(\n                    this.options.sid ? 'job not found' : 'unknown error'\n                );\n            }\n            this.jobId = job.sid;\n            this.updateJobScheduler = SimpleScheduler.createScheduler(\n                this.updateJob\n            );\n            this.updateJobScheduler.start();\n        } catch (ex) {\n            if (this.options.sid) {\n                // eslint-disable-next-line no-console\n                console.error('failed to retrieve search job:', ex);\n            } else {\n                // eslint-disable-next-line no-console\n                console.error('failed to create search job:', ex);\n            }\n            this.caughtError = (ex as Error).message;\n            return null;\n        }\n\n        return this.jobId ?? null;\n    }\n\n    /**\n     * Compute the next fetch interval, return false to terminal the loop\n     */\n    computeNextFetchDelay = (): false | number => {\n        if (isJobCompleted(this.currentJob) || this.isTeardown) {\n            return false; // no next fetch;\n        }\n        return RESULTS_POLLING_INTERVAL;\n    };\n\n    /**\n     * Update observer based on current job status. Has side-effects due to api fetch\n     * @param {Subscriber<ObservableData>} obj.observer\n     * @param {RequestParams} obj.requestParams\n     */\n    private async handleJobRequest({\n        observer,\n        requestParams,\n    }: {\n        observer: Subscriber<ObservableData>;\n        requestParams: RequestParams;\n    }): Promise<void> {\n        // Bail if there is no job to fetch data from\n        if (!this.currentJob) {\n            return;\n        }\n        const params = {\n            offset: 0,\n            count: 0,\n            progress: true,\n            ...requestParams,\n        };\n        let data: Awaited<ReturnType<typeof fetchData>> = null;\n\n        switch (this.currentJob.status) {\n            case DS_STATUS.FAILED:\n                observer.error({\n                    level: 'error',\n                    message: extractErrorMessage(this.currentJob.messages),\n                });\n                break;\n            case DS_STATUS.RUNNING:\n            case DS_STATUS.DONE:\n                if (shouldFetch(this.currentJob, params.progress)) {\n                    data = await fetchData(\n                        this.getServiceClient(),\n                        params,\n                        this.currentJob\n                    );\n                    if (data) {\n                        observer.next({\n                            data,\n                            meta: fetchMetaData(this.currentJob),\n                        });\n                    }\n                }\n                break;\n            default:\n                break;\n        }\n        if (isJobDone(this.currentJob)) {\n            observer.complete();\n        }\n    }\n\n    /**\n     * Supports getResults as exposed\n     * by [@splunk/cloud-sdk](https://github.com/splunk/splunk-cloud-sdk-js) (src/search.ts)\n     *\n     * Examples:\n     * ```js\n     *      const datasource = new CloudSearch(options, context);\n     *      datasource.setup().then(() => {\n     *          datasource.request().subscribe({\n     *              complete() {\n     *                 // search completed\n     *              },\n     *              next(obj) {\n     *                  // Process results\n     *              },\n     *              error() {\n     *                  // Handle error\n     *              },\n     *         });\n     *     });\n     * ```\n     * @param {Object} requestParams search request parameters.\n     * @param {Number} requestParams.offset data offset.\n     * @param {Number} requestParams.count data count.\n     * @param {String} requestParams.progress whether to return intermediate search result\n     * @returns {function(*)}\n     * @public\n     */\n    request(requestParams: RequestParams = {}): Observable<ObservableData> {\n        return Observable.create((observer: Subscriber<ObservableData>) => {\n            let resultScheduler: InstanceType<typeof SimpleScheduler> | null =\n                null;\n            if (this.caughtError) {\n                observer.error({\n                    level: 'error',\n                    message: this.caughtError,\n                });\n            } else {\n                resultScheduler = SimpleScheduler.createScheduler(async () => {\n                    try {\n                        /**\n                         * This function will perform following tasks in order:\n                         * 1. given the latest job state, fetch results and compute metadata\n                         * 2. compute the next fetch delay or stop the scheduler\n                         */\n                        await this.handleJobRequest({\n                            observer,\n                            requestParams,\n                        });\n                        return this.computeNextFetchDelay();\n                    } catch (ex) {\n                        observer.error({\n                            level: 'error',\n                            message: (ex as Error).message,\n                        });\n                        return false; // stop next fetch once we have error\n                    }\n                });\n                // kick off the loop\n                resultScheduler.start();\n            }\n            return () => {\n                // clean up function when no consumer subscribe to this observable\n                if (resultScheduler) {\n                    resultScheduler.stop();\n                    resultScheduler = null;\n                }\n            };\n        });\n    }\n\n    /**\n     * This is how the search sdk expects delete to work,\n     * but it is commented out on ssc-search spec which means that this method can't really be used right now.\n     * When available to use, it will delete the search job with the given jobId\n     *\n     * Examples:\n     * ```js\n     *   const response = await datasource.teardown().then(\n     *      value => {\n     *          console.log(`Should have deleted the job: ${value}`);\n     *          },\n     *      reason => {\n     *          console.log(`Failed to delete the job: ${reason}`);\n     *         }\n     *   );\n     *```\n     * @returns {Promise<*>}\n     * @public\n     */\n    async teardown(): Promise<null> {\n        if (this.updateJobScheduler) {\n            this.updateJobScheduler.stop();\n        }\n        /**\n         * cancelling a non-running search will return 400... i'm sick with search service\n         * that push all server state to client that make the system complicated as HELL\n         */\n        if (this.jobId && !isJobCompleted(this.currentJob)) {\n            await this.getServiceClient().updateJob(this.jobId, {\n                status: DS_STATUS.CANCELED,\n            } as UpdateJob);\n        }\n        this.isTeardown = true;\n        return null;\n    }\n\n    /**\n     * Given the job id, update the job stats and compute the next update delay\n     */\n    async updateJob(): Promise<false | number> {\n        try {\n            if (this.jobId && shouldUpdateJob(this.currentJob)) {\n                this.currentJob = (await this.getServiceClient().getJob(\n                    this.jobId\n                )) as CurrentJob;\n                return JOB_POLLING_INTERVAL;\n            }\n        } catch (ex) {\n            this.caughtError = (ex as Error).message;\n        }\n        return false;\n    }\n}\n\nexport default CloudSearch;\n", "\nimport * as defaultImport from \"rxjs\";\nexport * from \"rxjs\";\nexport default ('default' in defaultImport ? defaultImport.default : defaultImport);\n", "\nimport * as defaultImport from \"lodash\";\nexport * from \"lodash\";\nexport default ('default' in defaultImport ? defaultImport.default : defaultImport);\n", "\nimport * as defaultImport from \"memoize-one\";\nexport * from \"memoize-one\";\nexport default ('default' in defaultImport ? defaultImport.default : defaultImport);\n", "\nimport * as defaultImport from \"moment\";\nexport * from \"moment\";\nexport default ('default' in defaultImport ? defaultImport.default : defaultImport);\n", "\nimport * as defaultImport from \"@splunkdev/cloud-sdk/services/search\";\nexport * from \"@splunkdev/cloud-sdk/services/search\";\nexport default ('default' in defaultImport ? defaultImport.default : defaultImport);\n", "\nimport * as defaultImport from \"@splunkdev/cloud-sdk/client\";\nexport * from \"@splunkdev/cloud-sdk/client\";\nexport default ('default' in defaultImport ? defaultImport.default : defaultImport);\n", "\nimport * as defaultImport from \"@splunk/datasource-utils\";\nexport * from \"@splunk/datasource-utils\";\nexport default ('default' in defaultImport ? defaultImport.default : defaultImport);\n", "\nimport * as defaultImport from \"@splunk/ui-utils/i18n\";\nexport * from \"@splunk/ui-utils/i18n\";\nexport default ('default' in defaultImport ? defaultImport.default : defaultImport);\n", "\nimport * as defaultImport from \"@splunk/dashboard-utils\";\nexport * from \"@splunk/dashboard-utils\";\nexport default ('default' in defaultImport ? defaultImport.default : defaultImport);\n", "/* eslint-disable class-methods-use-this,no-unused-vars, @typescript-eslint/no-unused-vars */\nimport { isEqual } from 'lodash';\nimport type {\n    ExtendableDataSourceDefinition,\n    RequestParams,\n    DSTypes,\n} from '@splunk/dashboard-types';\nimport type { Subscriber } from 'rxjs';\n\ntype DefaultOptions = Record<string, unknown>;\ntype DefaultContext = Record<string, unknown>;\n\n/**\n * Base class of a DataSource\n */\nexport default class DataSource<O = DefaultOptions, C = DefaultContext> {\n    options: O;\n\n    context: C;\n\n    // deprecated property\n    meta?: Record<string, unknown>;\n\n    // deprecated property\n    baseChainModel?: Record<string, ExtendableDataSourceDefinition>;\n\n    /**\n     * Create a new DataSource instance\n     * @param {Object} options DataSource options such as search string, earliest/latest time\n     * @param {Object} context contextual information such as api key or scope\n     * @param {Object} meta metadata of this datasource\n     * @param {Object} baseChainModel base chain definition\n     */\n    constructor(\n        options: O = {} as O,\n        context: C = {} as C,\n        meta = {},\n        baseChainModel = {}\n    ) {\n        this.options = options;\n        this.context = context;\n        this.meta = meta;\n        this.baseChainModel = baseChainModel;\n    }\n\n    /**\n     * Setup the DataSource, create a connection or search job.\n     * setup() will be called only once per DataSource.\n     * Returns null by default; override to implement custom setup logic.\n     *\n     * @return {Promise}\n     * @public\n     */\n    setup(): DSTypes['setup'] {\n        return Promise.resolve(null);\n    }\n\n    /**\n     * Request a Data Stream represent by an Observable.\n     * Once the Observable was created and returned,\n     * it's the DataSource itself responsible for 'pushing' the data out via Observable.next() function.\n     * Override this function to implement your own data fetching logic.\n     *\n     * @param {Object} [requestParams] RequestParams\n     * @param {Number} [requestParams.offset] result offset\n     * @param {Number} [requestParams.count] result count, use with offset to return data in pages\n     * @param {Object} [requestParams.sort] result sorting, key indicate the sorting fields and value must be one of ['none', 'asc', 'desc']\n     * @param {Boolean} [requestParams.requireTotalCount] true if TotalCount is required in meta\n     * @param {Boolean} [requestParams.progress] true to emit progress data, false to only return data when search is finalized\n     * @return {Observable}\n     * @public\n     */\n    request(requestParams?: RequestParams): DSTypes['request'] {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return (observer?: Subscriber<any>) => {\n            if (observer) {\n                observer.complete();\n            }\n            return () => {\n                // cleanup\n            };\n        };\n    }\n\n    /**\n     * Halt updates to results, if supported\n     * @return {Promise}\n     * @public\n     */\n    async pause?(): DSTypes['pause'] {\n        return Promise.resolve(null);\n    }\n\n    /**\n     * Resume previously-halted updates to results, if supported\n     * @return {Promise}\n     * @public\n     */\n    async resume?(): DSTypes['resume'] {\n        return Promise.resolve(null);\n    }\n\n    /**\n     * Reports whether pause and resume controls are supported for the class instance\n     * @return {Boolean} true if the DataSource supports pause and resume actions\n     * @public\n     */\n    supportsControlActions?(): DSTypes['supportsControlActions'] {\n        return false;\n    }\n\n    /**\n     * Teardown the DataSource, clean up the connection or other resources.\n     * Returns null by default; override to implement custom teardown logic.\n     *\n     * @return {Promise}\n     * @public\n     */\n    teardown(): DSTypes['teardown'] {\n        return Promise.resolve(null);\n    }\n\n    /**\n     * @param {DataSource} another another DataSource to compare with\n     * @return {Boolean} true if the these two DataSources are considered equal.\n     * @public\n     */\n    equals(another: DataSource): DSTypes['equals'] {\n        return (\n            this.constructor === another.constructor &&\n            isEqual(this.options, another.options)\n        );\n    }\n\n    /**\n     * Return an observer that can be used for chaining with other DataSources\n     *\n     * @return {Object}\n     * @public\n     */\n    getObserver(): DSTypes['getObserver'] {\n        return {\n            next({ requestParams, data, meta }) {\n                // next\n            },\n            error({ level, message }) {\n                // error\n            },\n            complete() {\n                // complete\n            },\n        };\n    }\n\n    /**\n     * Flag used to indicate whether the subscription for this DataSource should be refreshed\n     *\n     * @return {Boolean}\n     * @public\n     */\n    shouldRefreshSubscription(): DSTypes['shouldRefreshSubscription'] {\n        return false;\n    }\n}\n", "/**\n * Returns a fully qualified search string by prepending the 'search'\n * command of unqualified searches.  This method deems strings as unqualified\n * if it does not start with a '|', 'search ', or 'from '\n *\n * @param {String} search - The search string.\n * @returns {String}\n * @public\n */\nexport default function addLeadingSearchCommand(search: string): string {\n    const trimmedSearch = search.trim();\n    if (trimmedSearch.startsWith('|')) {\n        return search;\n    }\n    if (\n        (trimmedSearch.startsWith('search ') && trimmedSearch.length > 7) ||\n        (trimmedSearch.startsWith('from ') && trimmedSearch.length > 5)\n    ) {\n        return search;\n    }\n    return `search ${trimmedSearch}`;\n}\n", "import { isNumber } from 'lodash';\nimport { noop } from '@splunk/dashboard-utils';\n\ntype TickFn = (resultScheduler: SimpleScheduler) => Promise<number | false>;\ninterface SchedulerOptions {\n    minDelay?: number;\n}\n\n/**\n * A Simple task scheduler\n */\nclass SimpleScheduler {\n    static createScheduler(tickFunc: TickFn, options?: SchedulerOptions) {\n        return new SimpleScheduler(tickFunc, options);\n    }\n\n    private readonly tickFunc: TickFn;\n\n    private readonly minDelay: number;\n\n    private t: ReturnType<typeof setTimeout> | null;\n\n    private stopped: boolean;\n\n    /**\n     *\n     * @param {*} tickFunc a function that will be executed by scheduler, its return value will be used to schedule next execution.\n     * return false from this function will stop the execution\n     * @param {*} options\n     */\n    constructor(tickFunc: TickFn = noop, options: SchedulerOptions = {}) {\n        this.tickFunc = tickFunc;\n        this.minDelay = options.minDelay ?? 0;\n        this.loop = this.loop.bind(this);\n        this.t = null;\n        this.stopped = false;\n    }\n\n    /**\n     * execute tick function and stop next execution if error caught\n     */\n    async tick() {\n        try {\n            return await this.tickFunc(this);\n        } catch {\n            return false;\n        }\n    }\n\n    /**\n     * start scheduler\n     */\n    async start() {\n        this.stopped = false;\n        await this.loop();\n    }\n\n    async loop() {\n        const delay = await this.tick();\n        if (!this.stopped && delay !== false && isNumber(delay)) {\n            this.t = setTimeout(this.loop, Math.max(this.minDelay, delay));\n        }\n    }\n\n    /**\n     * stop scheduler\n     */\n    stop() {\n        this.stopped = true;\n        if (this.t) {\n            clearTimeout(this.t);\n            this.t = null;\n        }\n    }\n}\n\nexport default SimpleScheduler;\n", "export default {\n    query: {\n        type: 'string',\n        description: 'An SPL search string.',\n    },\n    queryParameters: {\n        type: 'object',\n        properties: {\n            earliest: {\n                type: 'string',\n                description: 'Specify the earliest time to search for events.',\n            },\n            latest: {\n                type: 'string',\n                description: 'Specify the latest time to search for events.',\n            },\n            timezone: {\n                type: 'string',\n                description: 'Specify the timezone.',\n            },\n        },\n        additionalProperties: false,\n        description: 'SPL query parameters.',\n    },\n    refresh: {\n        anyOf: [\n            {\n                type: 'number',\n                minimum: 0,\n            },\n            {\n                type: 'string',\n            },\n        ],\n        description:\n            'Specify the refresh interval in seconds or with a time expression.',\n    },\n    refreshType: {\n        type: 'string',\n        enum: ['delay', 'interval'],\n        default: 'delay',\n        description:\n            'Indicate the starting time for counting down to a refresh. Use delay to start counting when the search is done. Use interval to count down when the search is dispatched.',\n    },\n    requiredFreshness: {\n        type: 'number',\n        description:\n            'Specify the freshness range in seconds to enable search job caching',\n    },\n    module: {\n        type: 'string',\n        description: 'Dataset module for search isolation',\n    },\n};\n", "\nimport * as defaultImport from \"@splunk/dashboard-definition\";\nexport * from \"@splunk/dashboard-definition\";\nexport default ('default' in defaultImport ? defaultImport.default : defaultImport);\n", "import { memoize } from 'lodash';\nimport { DashboardDefinition } from '@splunk/dashboard-definition';\n\nexport const getDefaultOptionsForSearchQuery = memoize(\n    (definition) => {\n        const def = DashboardDefinition.fromJSON(definition);\n\n        const timeRange = def.getDefaultTimeRangeForNewSearch();\n\n        if (timeRange.earliest || timeRange.latest) {\n            return {\n                queryParameters: {\n                    ...timeRange,\n                },\n            };\n        }\n\n        return {};\n    },\n    // note: this is the resolver function that uses a dirty trick to avoid re-creating the object\n    (definition) => {\n        const def = DashboardDefinition.fromJSON(definition);\n\n        const timeRange = def.getDefaultTimeRangeForNewSearch();\n        return JSON.stringify(timeRange);\n    }\n);\n"],
  "mappings": "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",
  "names": ["__toCommonJS", "__toESM", "defaultImport", "searchParams", "module"]
}
