import __buffer_polyfill from 'vite-plugin-node-polyfills/shims/buffer'
globalThis.Buffer = globalThis.Buffer || __buffer_polyfill
import __global_polyfill from 'vite-plugin-node-polyfills/shims/global'
globalThis.global = globalThis.global || __global_polyfill
import __process_polyfill from 'vite-plugin-node-polyfills/shims/process'
globalThis.process = globalThis.process || __process_polyfill

import {
  require_Anchor
} from "./chunk-LAV6YKZU.js";
import {
  require_times
} from "./chunk-RWX5KT5Q.js";
import {
  init_modifiers_esm,
  modifiers_esm_exports,
  require_Prose
} from "./chunk-OARYEIS3.js";
import {
  require_DotsThreeVertical
} from "./chunk-6DX5PQFN.js";
import {
  require_ChevronRight,
  require_Divider,
  require_Heading,
  require_List,
  require_NonInteractiveCheckbox,
  require_Paragraph,
  require_castArray,
  require_extend,
  require_without
} from "./chunk-A5UOW6LZ.js";
import {
  require_pickBy
} from "./chunk-3HEKB24Y.js";
import {
  require_Link
} from "./chunk-KFNV76KJ.js";
import {
  require_Dropdown
} from "./chunk-2MABM7SQ.js";
import {
  dequal,
  init_dist,
  require_Box,
  require_EventListener,
  require_Popover,
  require_ScrollContainerContext,
  require_Tooltip,
  require_useControlled,
  require_usePrevious
} from "./chunk-G6OHCFVG.js";
import {
  require_throttle
} from "./chunk-27LK67HU.js";
import {
  CSS,
  KeyboardCode,
  closestCorners,
  core_esm_exports,
  getClientRect,
  getFirstCollision,
  getScrollableAncestors,
  init_core_esm,
  init_utilities_esm,
  isKeyboardEvent,
  require_forEach,
  subtract,
  useCombinedRefs,
  useDndContext,
  useDraggable,
  useDroppable,
  useIsomorphicLayoutEffect,
  useUniqueId,
  utilities_esm_exports
} from "./chunk-AIIXJTVL.js";
import {
  require_InformationCircle,
  require_includes,
  require_isEqual
} from "./chunk-E2Z3JYKW.js";
import {
  require_Button,
  require_ButtonSimple,
  require_CaretSmallDown
} from "./chunk-ICO5BW3R.js";
import {
  require_Clickable,
  require_flatten,
  require_omit
} from "./chunk-62I7WT4R.js";
import {
  require_IconProvider,
  require_SVG
} from "./chunk-2FMSEQJ6.js";
import {
  require_merge,
  require_themes
} from "./chunk-CHFSHVDX.js";
import {
  require_getTheme
} from "./chunk-OXWLTD4R.js";
import {
  init_styled_components_esm,
  require_react_is,
  styled_components_esm_exports
} from "./chunk-3A7H6U64.js";
import {
  require_prop_types
} from "./chunk-QNBKYQLU.js";
import {
  require_cjs,
  require_moment
} from "./chunk-XH2XD4WE.js";
import {
  require_format,
  require_isNumber,
  require_repeat
} from "./chunk-6CXBXVKR.js";
import {
  require_baseIndexOf,
  require_id,
  require_isFinite
} from "./chunk-ADRYVMRQ.js";
import {
  require_toInteger
} from "./chunk-LPGHV4NL.js";
import {
  require_has,
  require_keys
} from "./chunk-PYQODTGJ.js";
import {
  require_i18n,
  require_isString
} from "./chunk-SFZFMFKO.js";
import {
  require_isFunction
} from "./chunk-WZ5QAOVA.js";
import {
  require_util
} from "./chunk-WJRY3YLW.js";
import {
  require_lodash
} from "./chunk-FUC7W543.js";
import {
  require_react
} from "./chunk-ACNULIE3.js";
import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS,
  __toESM,
  require_dist,
  require_dist2,
  require_dist3
} from "./chunk-2RF6DQJU.js";

// node_modules/@splunk/visualization-color-palettes/index.js
var require_visualization_color_palettes = __commonJS({
  "node_modules/@splunk/visualization-color-palettes/index.js"(exports, module) {
    var import_dist466 = __toESM(require_dist());
    var import_dist467 = __toESM(require_dist2());
    var import_dist468 = __toESM(require_dist3());
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export2 = (target, all3) => {
      for (var name in all3)
        __defProp(target, name, { get: all3[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export2(src_exports, {
      CATEGORICAL: () => CATEGORICAL,
      ENTERPRISE_CATEGORICAL: () => ENTERPRISE_CATEGORICAL,
      SCP_CATEGORICAL: () => SCP_CATEGORICAL,
      VIZ_CATEGORICAL: () => VIZ_CATEGORICAL
    });
    module.exports = __toCommonJS2(src_exports);
    var SCP_CATEGORICAL = [
      "#A9F5E7",
      "#A870EF",
      "#1E6271",
      "#45D4BA",
      "#602CA1",
      "#9AE6F7",
      "#6CD0F0",
      "#2F8AA7",
      "#422879",
      "#F29BAC",
      "#E85B79",
      "#C6335F",
      "#FDAF93",
      "#FB865C",
      "#E9643A",
      "#7EEFDA",
      "#26AA92",
      "#207865",
      "#C093F9",
      "#8747DA",
      "#4EB2D2",
      "#912344",
      "#AD3F20",
      "#D44C20",
      "#FFC34E",
      "#95651D",
      "#C0891E",
      "#ECAE11",
      "#FCD9A4",
      "#78062A"
    ];
    var ENTERPRISE_CATEGORICAL = ["#1E93C6", "#F2B827", "#D6563C", "#6A5C9E", "#31A35F"];
    var CATEGORICAL = [
      "#7B56DB",
      "#0089CF",
      "#00CDAF",
      "#DD9900",
      "#FF677B",
      "#CB2196",
      "#813193",
      "#0051B5",
      "#008C80",
      "#99B100",
      "#FFA476",
      "#FF6ACE",
      "#AE8CFF",
      "#00689D",
      "#00490A",
      "#465D00",
      "#9D6300",
      "#F6540B",
      "#FF969E",
      "#E47BFE"
    ];
    var VIZ_CATEGORICAL = [
      "#7B56DB",
      "#009CEB",
      "#00CDAF",
      "#DD9900",
      "#FF677B",
      "#CB2196",
      "#813193",
      "#0051B5",
      "#008C80",
      "#99B100",
      "#FFA476",
      "#FF6ACE",
      "#AE8CFF",
      "#00689D",
      "#00490A",
      "#465D00",
      "#9D6300",
      "#F6540B",
      "#FF969E",
      "#E47BFE"
    ];
  }
});

// node_modules/@splunk/visualizations-shared/style.js
var require_style = __commonJS({
  "node_modules/@splunk/visualizations-shared/style.js"(exports, module) {
    var import_dist466 = __toESM(require_dist());
    var import_dist467 = __toESM(require_dist2());
    var import_dist468 = __toESM(require_dist3());
    var __create = Object.create;
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __getProtoOf = Object.getPrototypeOf;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export2 = (target, all3) => {
      for (var name in all3)
        __defProp(target, name, { get: all3[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
    var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
      // If the importer is in node compatibility mode or this is not an ESM
      // file that has been converted to a CommonJS file using a Babel-
      // compatible transform (i.e. "__esModule" has not been set), then set
      // "default" to the CommonJS "module.exports" for node compatibility.
      isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
      mod
    ));
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var style_exports = {};
    __export2(style_exports, {
      arrayToCSSProp: () => arrayToCSSProp,
      toDimension: () => toDimension,
      toMargin: () => toMargin,
      toPadding: () => toPadding,
      toPx: () => toPx
    });
    module.exports = __toCommonJS2(style_exports);
    var isNumber_exports = {};
    __export2(isNumber_exports, {
      default: () => isNumber_default
    });
    var defaultImport = __toESM2(require_isNumber());
    __reExport(isNumber_exports, require_isNumber());
    var isNumber_default = "default" in defaultImport ? defaultImport.default : defaultImport;
    var toPx = (number2, defaultNumber = 0) => isNumber_default(number2) ? `${number2}px` : number2 || toPx(defaultNumber);
    var toDimension = ({ width, height }) => {
      let css = "";
      if (width) {
        css = `width: ${toPx(width)};`;
      }
      if (height) {
        css = `${css}${width ? "\n" : ""}height: ${toPx(height)};`;
      }
      return css;
    };
    var arrayToCSSProp = (prop, vals = [0, 0, 0, 0]) => {
      if (Array.isArray(vals)) {
        return `
            ${prop}: ${toPx(vals[0])} ${toPx(vals[1])} ${toPx(vals[2])} ${toPx(vals[3])};
        `;
      }
      return `${prop}: ${toPx(vals)};`;
    };
    var toMargin = (margins = [0, 0, 0, 0]) => arrayToCSSProp("margin", margins);
    var toPadding = (paddings = [0, 0, 0, 0]) => arrayToCSSProp("padding", paddings);
  }
});

// node_modules/@splunk/visualization-encoding/utils/colorUtils.js
var require_colorUtils = __commonJS({
  "node_modules/@splunk/visualization-encoding/utils/colorUtils.js"(exports, module) {
    var import_dist466 = __toESM(require_dist());
    var import_dist467 = __toESM(require_dist2());
    var import_dist468 = __toESM(require_dist3());
    var __create = Object.create;
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __getProtoOf = Object.getPrototypeOf;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export2 = (target, all3) => {
      for (var name in all3)
        __defProp(target, name, { get: all3[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
    var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
      // If the importer is in node compatibility mode or this is not an ESM
      // file that has been converted to a CommonJS file using a Babel-
      // compatible transform (i.e. "__esModule" has not been set), then set
      // "default" to the CommonJS "module.exports" for node compatibility.
      isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
      mod
    ));
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var colorUtils_exports = {};
    __export2(colorUtils_exports, {
      isArrayOfColors: () => isArrayOfColors,
      isColor: () => isColor,
      sanitizeArrayOfColors: () => sanitizeArrayOfColors
    });
    module.exports = __toCommonJS2(colorUtils_exports);
    var visualization_schemas_exports = {};
    __export2(visualization_schemas_exports, {
      default: () => visualization_schemas_default
    });
    var defaultImport = __toESM2(require_cjs());
    __reExport(visualization_schemas_exports, require_cjs());
    var visualization_schemas_default = "default" in defaultImport ? defaultImport.default : defaultImport;
    var namedColors_default = [
      "transparent",
      "aliceblue",
      "antiquewhite",
      "aqua",
      "aquamarine",
      "azure",
      "beige",
      "bisque",
      "black",
      "blanchedalmond",
      "blue",
      "blueviolet",
      "brown",
      "burlywood",
      "cadetblue",
      "chartreuse",
      "chocolate",
      "coral",
      "cornflowerblue",
      "cornsilk",
      "crimson",
      "cyan",
      "darkblue",
      "darkcyan",
      "darkgoldenrod",
      "darkgray",
      "darkgreen",
      "darkgrey",
      "darkkhaki",
      "darkmagenta",
      "darkolivegreen",
      "darkorange",
      "darkorchid",
      "darkred",
      "darksalmon",
      "darkseagreen",
      "darkslateblue",
      "darkslategray",
      "darkslategrey",
      "darkturquoise",
      "darkviolet",
      "deeppink",
      "deepskyblue",
      "dimgray",
      "dimgrey",
      "dodgerblue",
      "firebrick",
      "floralwhite",
      "forestgreen",
      "fuchsia",
      "gainsboro",
      "ghostwhite",
      "gold",
      "goldenrod",
      "gray",
      "green",
      "greenyellow",
      "grey",
      "honeydew",
      "hotpink",
      "indianred",
      "indigo",
      "ivory",
      "khaki",
      "lavender",
      "lavenderblush",
      "lawngreen",
      "lemonchiffon",
      "lightblue",
      "lightcoral",
      "lightcyan",
      "lightgoldenrodyellow",
      "lightgray",
      "lightgreen",
      "lightgrey",
      "lightpink",
      "lightsalmon",
      "lightseagreen",
      "lightskyblue",
      "lightslategray",
      "lightslategrey",
      "lightsteelblue",
      "lightyellow",
      "lime",
      "limegreen",
      "linen",
      "magenta",
      "maroon",
      "mediumaquamarine",
      "mediumblue",
      "mediumorchid",
      "mediumpurple",
      "mediumseagreen",
      "mediumslateblue",
      "mediumspringgreen",
      "mediumturquoise",
      "mediumvioletred",
      "midnightblue",
      "mintcream",
      "mistyrose",
      "moccasin",
      "navajowhite",
      "navy",
      "oldlace",
      "olive",
      "olivedrab",
      "orange",
      "orangered",
      "orchid",
      "palegoldenrod",
      "palegreen",
      "paleturquoise",
      "palevioletred",
      "papayawhip",
      "peachpuff",
      "peru",
      "pink",
      "plum",
      "powderblue",
      "purple",
      "rebeccapurple",
      "red",
      "rosybrown",
      "royalblue",
      "saddlebrown",
      "salmon",
      "sandybrown",
      "seagreen",
      "seashell",
      "sienna",
      "silver",
      "skyblue",
      "slateblue",
      "slategray",
      "slategrey",
      "snow",
      "springgreen",
      "steelblue",
      "tan",
      "teal",
      "thistle",
      "tomato",
      "turquoise",
      "violet",
      "wheat",
      "white",
      "whitesmoke",
      "yellow",
      "yellowgreen"
    ];
    function isColor(color2 = "") {
      if (typeof color2 !== "string") {
        return false;
      }
      if (color2.startsWith("#")) {
        color2 = color2.substring(1);
        return [3, 4, 6, 8].indexOf(color2.length) > -1 && !Number.isNaN(parseInt(color2, 16));
      }
      const trimmedColor = color2.trim();
      if (visualization_schemas_exports.rgbColorPattern.test(trimmedColor) || visualization_schemas_exports.rgbaColorPattern.test(trimmedColor)) {
        return true;
      }
      return namedColors_default.includes(color2.toLowerCase());
    }
    var isArrayOfColors = (colors2) => Array.isArray(colors2) && colors2.every(isColor);
    var sanitizeArrayOfColors = (arr, fallback) => {
      return arr.map((entry) => isColor(entry) ? entry : fallback);
    };
  }
});

// node_modules/@splunk/visualizations-shared/colorUtils.js
var require_colorUtils2 = __commonJS({
  "node_modules/@splunk/visualizations-shared/colorUtils.js"(exports, module) {
    var import_dist466 = __toESM(require_dist());
    var import_dist467 = __toESM(require_dist2());
    var import_dist468 = __toESM(require_dist3());
    var __create = Object.create;
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __getProtoOf = Object.getPrototypeOf;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export2 = (target, all3) => {
      for (var name in all3)
        __defProp(target, name, { get: all3[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
    var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
      // If the importer is in node compatibility mode or this is not an ESM
      // file that has been converted to a CommonJS file using a Babel-
      // compatible transform (i.e. "__esModule" has not been set), then set
      // "default" to the CommonJS "module.exports" for node compatibility.
      isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
      mod
    ));
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var colorUtils_exports2 = {};
    __export2(colorUtils_exports2, {
      isArrayOfColors: () => colorUtils_exports.isArrayOfColors,
      isColor: () => colorUtils_exports.isColor,
      sanitizeArrayOfColors: () => colorUtils_exports.sanitizeArrayOfColors
    });
    module.exports = __toCommonJS2(colorUtils_exports2);
    var colorUtils_exports = {};
    __export2(colorUtils_exports, {
      default: () => colorUtils_default
    });
    var defaultImport = __toESM2(require_colorUtils());
    __reExport(colorUtils_exports, require_colorUtils());
    var colorUtils_default = "default" in defaultImport ? defaultImport.default : defaultImport;
  }
});

// node_modules/@splunk/visualizations-shared/trellisUtils.js
var require_trellisUtils = __commonJS({
  "node_modules/@splunk/visualizations-shared/trellisUtils.js"(exports, module) {
    var import_dist466 = __toESM(require_dist());
    var import_dist467 = __toESM(require_dist2());
    var import_dist468 = __toESM(require_dist3());
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export2 = (target, all3) => {
      for (var name in all3)
        __defProp(target, name, { get: all3[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var trellisUtils_exports = {};
    __export2(trellisUtils_exports, {
      CHART: () => CHART,
      STATS: () => STATS,
      TIMECHART: () => TIMECHART,
      UNKNOWN: () => UNKNOWN,
      checkForTrellisFieldMetaInfo: () => checkForTrellisFieldMetaInfo,
      extractAllAggregationKeysChart: () => extractAllAggregationKeysChart,
      extractDataSourceAggregationKeysChart: () => extractDataSourceAggregationKeysChart,
      extractDataSourceAggregationKeysStats: () => extractDataSourceAggregationKeysStats,
      extractSplitByFieldsChartFields: () => extractSplitByFieldsChartFields,
      extractSplitByFieldsForStats: () => extractSplitByFieldsForStats,
      extractSplitByFieldsForUnknown: () => extractSplitByFieldsForUnknown,
      getAllPossibleSplitByFields: () => getAllPossibleSplitByFields,
      getTrellisDataSplitterMode: () => getTrellisDataSplitterMode,
      isChartCmdData: () => isChartCmdData,
      isStatsCmdData: () => isStatsCmdData,
      isTimeChartCmdData: () => isTimeChartCmdData
    });
    module.exports = __toCommonJS2(trellisUtils_exports);
    var CHART = "chart";
    var TIMECHART = "timechart";
    var STATS = "stats";
    var UNKNOWN = "unknown";
    var getTrellisDataSplitterMode = (fields) => {
      if (!fields) {
        return UNKNOWN;
      }
      if (isTimeChartCmdData(fields)) {
        return TIMECHART;
      }
      if (isChartCmdData(fields)) {
        return CHART;
      }
      if (isStatsCmdData(fields)) {
        return STATS;
      }
      return UNKNOWN;
    };
    var isTimeChartCmdData = (fields) => {
      return fields && fields.length > 0 && fields[0] && fields[0].name === "_time" && fields[0].groupby_rank === "0";
    };
    var isChartCmdData = (fields) => {
      if (!fields || !fields.length) {
        return false;
      }
      if (!checkForTrellisFieldMetaInfo(fields)) {
        return false;
      }
      if (fields.length > 1) {
        return fields[0].name !== "_time" && fields[0].groupby_rank === "0" && !fields[1].groupby_rank;
      }
      for (let i = 1; i < fields.length; i += 1) {
        if (!fields[i].splitby_field) {
          return false;
        }
      }
      return true;
    };
    var isStatsCmdData = (fields) => {
      if (!fields || !fields.length) {
        return false;
      }
      if (!checkForTrellisFieldMetaInfo(fields)) {
        return false;
      }
      const groupByRanks = [];
      for (let i = 0; i < fields.length; i += 1) {
        if (fields[i].splitby_field) {
          return false;
        }
        if (fields[i].groupby_rank) {
          groupByRanks.push(fields[i].groupby_rank);
        }
      }
      return groupByRanks.length > 0 && groupByRanks.length < fields.length;
    };
    var checkForTrellisFieldMetaInfo = (fields) => {
      if (!fields || !fields.length) {
        return false;
      }
      for (let i = 0; i < fields.length; i += 1) {
        if (fields[i].groupby_rank || fields[i].splitby_field || fields[i].splitby_value || fields[i].data_source) {
          return true;
        }
      }
      return false;
    };
    var extractSplitByFieldsChartFields = (fields) => {
      const fieldsWithoutTime = fields.filter(({ name }) => name !== "_time");
      const splitByFields = [];
      fieldsWithoutTime.forEach((field) => {
        if (field.splitby_field) {
          splitByFields.push(field.splitby_field);
        }
      });
      return isTimeChartCmdData(fields) ? [...new Set(splitByFields)] : [fields[0].name, ...new Set(splitByFields)];
    };
    var extractDataSourceAggregationKeysChart = (fields) => {
      const fieldsWithoutTime = fields.filter(({ name }) => name !== "_time");
      const aggregations = [];
      fieldsWithoutTime.forEach((field) => {
        if (field.data_source) {
          aggregations.push(field.data_source);
        }
      });
      return [...new Set(aggregations)];
    };
    var extractAllAggregationKeysChart = (fields) => {
      let aggregations = [];
      aggregations = extractDataSourceAggregationKeysChart(fields);
      if (aggregations && aggregations.length) {
        return aggregations;
      }
      if ((!aggregations || !aggregations.length) && fields.length > 1) {
        for (let i = 1; i < fields.length; i += 1) {
          const fieldName = fields[i].name;
          if (!fieldName.startsWith("_")) {
            aggregations.push(fieldName);
          }
        }
      }
      return aggregations;
    };
    var extractDataSourceAggregationKeysStats = (fields) => {
      const aggregations = [];
      fields.forEach((field) => {
        if (field.groupby_rank === void 0) {
          aggregations.push(field.name);
        }
      });
      return aggregations;
    };
    var extractSplitByFieldsForStats = (fields) => {
      if (!fields) {
        return [];
      }
      const fieldsWithGroupByRank = fields.filter((field) => field.groupby_rank);
      return fieldsWithGroupByRank.map((field) => field.name);
    };
    var extractSplitByFieldsForUnknown = (fields) => {
      if (!fields) {
        return [];
      }
      return fields.filter((field) => !(field == null ? void 0 : field.name.startsWith("_"))).map((field) => field.name);
    };
    var getAllPossibleSplitByFields = (fields) => {
      const result = { fields: [], aggregations: [] };
      if (!fields || !fields.length) {
        return result;
      }
      const splitMode = getTrellisDataSplitterMode(fields);
      if (splitMode === TIMECHART || splitMode === CHART) {
        return {
          fields: extractSplitByFieldsChartFields(fields),
          aggregations: extractAllAggregationKeysChart(fields)
        };
      }
      if (splitMode === STATS) {
        return {
          fields: [...extractSplitByFieldsForStats(fields)],
          aggregations: [...extractDataSourceAggregationKeysStats(fields)]
        };
      }
      if (splitMode === UNKNOWN) {
        const fieldNames = extractSplitByFieldsForUnknown(fields);
        return fieldNames.length === 1 ? {
          fields: [],
          aggregations: [...fieldNames]
          // only populate the aggregation
        } : {
          fields: [...fieldNames],
          aggregations: [...fieldNames]
        };
      }
      return result;
    };
  }
});

// node_modules/@splunk/visualizations-shared/dataSourceUtils.js
var require_dataSourceUtils = __commonJS({
  "node_modules/@splunk/visualizations-shared/dataSourceUtils.js"(exports, module) {
    var import_dist466 = __toESM(require_dist());
    var import_dist467 = __toESM(require_dist2());
    var import_dist468 = __toESM(require_dist3());
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export2 = (target, all3) => {
      for (var name in all3)
        __defProp(target, name, { get: all3[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var dataSourceUtils_exports = {};
    __export2(dataSourceUtils_exports, {
      DataSourceState: () => DataSourceState,
      getDataSourceStateInfo: () => getDataSourceStateInfo
    });
    module.exports = __toCommonJS2(dataSourceUtils_exports);
    var DataSourceState = ((DataSourceState2) => {
      DataSourceState2[DataSourceState2["NONEXISTENT"] = 0] = "NONEXISTENT";
      DataSourceState2[DataSourceState2["ERROR"] = 1] = "ERROR";
      DataSourceState2[DataSourceState2["LOADING"] = 2] = "LOADING";
      DataSourceState2[DataSourceState2["OK"] = 3] = "OK";
      return DataSourceState2;
    })(DataSourceState || {});
    var getDataSourceState = (dataSource) => {
      if (!dataSource) {
        return 0;
      }
      const { error, data } = dataSource;
      if (dataSource.error) {
        return 1;
      }
      if (error == null && data == null) {
        return 2;
      }
      return 3;
    };
    var getDataSourceStateInfo = (dataSource) => {
      const dataSourceState = getDataSourceState(dataSource);
      return {
        hasError: dataSourceState === 1,
        isMissing: dataSourceState === 0,
        isLoading: dataSourceState === 2
        /* LOADING */
      };
    };
  }
});

// node_modules/@splunk/react-ui/node_modules/@dnd-kit/sortable/dist/sortable.esm.js
var sortable_esm_exports = {};
__export(sortable_esm_exports, {
  SortableContext: () => SortableContext,
  arrayMove: () => arrayMove,
  arraySwap: () => arraySwap,
  defaultAnimateLayoutChanges: () => defaultAnimateLayoutChanges,
  defaultNewIndexGetter: () => defaultNewIndexGetter,
  hasSortableData: () => hasSortableData,
  horizontalListSortingStrategy: () => horizontalListSortingStrategy,
  rectSortingStrategy: () => rectSortingStrategy,
  rectSwappingStrategy: () => rectSwappingStrategy,
  sortableKeyboardCoordinates: () => sortableKeyboardCoordinates,
  useSortable: () => useSortable,
  verticalListSortingStrategy: () => verticalListSortingStrategy
});
function arrayMove(array, from, to) {
  const newArray = array.slice();
  newArray.splice(to < 0 ? newArray.length + to : to, 0, newArray.splice(from, 1)[0]);
  return newArray;
}
function arraySwap(array, from, to) {
  const newArray = array.slice();
  newArray[from] = array[to];
  newArray[to] = array[from];
  return newArray;
}
function getSortedRects(items, rects) {
  return items.reduce((accumulator, id, index2) => {
    const rect = rects.get(id);
    if (rect) {
      accumulator[index2] = rect;
    }
    return accumulator;
  }, Array(items.length));
}
function isValidIndex(index2) {
  return index2 !== null && index2 >= 0;
}
function itemsEqual(a, b) {
  if (a === b) {
    return true;
  }
  if (a.length !== b.length) {
    return false;
  }
  for (let i = 0; i < a.length; i++) {
    if (a[i] !== b[i]) {
      return false;
    }
  }
  return true;
}
function normalizeDisabled(disabled) {
  if (typeof disabled === "boolean") {
    return {
      draggable: disabled,
      droppable: disabled
    };
  }
  return disabled;
}
function getItemGap(rects, index2, activeIndex) {
  const currentRect = rects[index2];
  const previousRect = rects[index2 - 1];
  const nextRect = rects[index2 + 1];
  if (!currentRect || !previousRect && !nextRect) {
    return 0;
  }
  if (activeIndex < index2) {
    return previousRect ? currentRect.left - (previousRect.left + previousRect.width) : nextRect.left - (currentRect.left + currentRect.width);
  }
  return nextRect ? nextRect.left - (currentRect.left + currentRect.width) : currentRect.left - (previousRect.left + previousRect.width);
}
function getItemGap$1(clientRects, index2, activeIndex) {
  const currentRect = clientRects[index2];
  const previousRect = clientRects[index2 - 1];
  const nextRect = clientRects[index2 + 1];
  if (!currentRect) {
    return 0;
  }
  if (activeIndex < index2) {
    return previousRect ? currentRect.top - (previousRect.top + previousRect.height) : nextRect ? nextRect.top - (currentRect.top + currentRect.height) : 0;
  }
  return nextRect ? nextRect.top - (currentRect.top + currentRect.height) : previousRect ? currentRect.top - (previousRect.top + previousRect.height) : 0;
}
function SortableContext(_ref) {
  let {
    children,
    id,
    items: userDefinedItems,
    strategy = rectSortingStrategy,
    disabled: disabledProp = false
  } = _ref;
  const {
    active,
    dragOverlay,
    droppableRects,
    over,
    measureDroppableContainers
  } = useDndContext();
  const containerId = useUniqueId(ID_PREFIX, id);
  const useDragOverlay = Boolean(dragOverlay.rect !== null);
  const items = (0, import_react.useMemo)(() => userDefinedItems.map((item) => typeof item === "object" && "id" in item ? item.id : item), [userDefinedItems]);
  const isDragging = active != null;
  const activeIndex = active ? items.indexOf(active.id) : -1;
  const overIndex = over ? items.indexOf(over.id) : -1;
  const previousItemsRef = (0, import_react.useRef)(items);
  const itemsHaveChanged = !itemsEqual(items, previousItemsRef.current);
  const disableTransforms = overIndex !== -1 && activeIndex === -1 || itemsHaveChanged;
  const disabled = normalizeDisabled(disabledProp);
  useIsomorphicLayoutEffect(() => {
    if (itemsHaveChanged && isDragging) {
      measureDroppableContainers(items);
    }
  }, [itemsHaveChanged, items, isDragging, measureDroppableContainers]);
  (0, import_react.useEffect)(() => {
    previousItemsRef.current = items;
  }, [items]);
  const contextValue = (0, import_react.useMemo)(
    () => ({
      activeIndex,
      containerId,
      disabled,
      disableTransforms,
      items,
      overIndex,
      useDragOverlay,
      sortedRects: getSortedRects(items, droppableRects),
      strategy
    }),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [activeIndex, containerId, disabled.draggable, disabled.droppable, disableTransforms, items, overIndex, droppableRects, useDragOverlay, strategy]
  );
  return import_react.default.createElement(Context.Provider, {
    value: contextValue
  }, children);
}
function useDerivedTransform(_ref) {
  let {
    disabled,
    index: index2,
    node: node2,
    rect
  } = _ref;
  const [derivedTransform, setDerivedtransform] = (0, import_react.useState)(null);
  const previousIndex = (0, import_react.useRef)(index2);
  useIsomorphicLayoutEffect(() => {
    if (!disabled && index2 !== previousIndex.current && node2.current) {
      const initial = rect.current;
      if (initial) {
        const current = getClientRect(node2.current, {
          ignoreTransform: true
        });
        const delta = {
          x: initial.left - current.left,
          y: initial.top - current.top,
          scaleX: initial.width / current.width,
          scaleY: initial.height / current.height
        };
        if (delta.x || delta.y) {
          setDerivedtransform(delta);
        }
      }
    }
    if (index2 !== previousIndex.current) {
      previousIndex.current = index2;
    }
  }, [disabled, index2, node2, rect]);
  (0, import_react.useEffect)(() => {
    if (derivedTransform) {
      setDerivedtransform(null);
    }
  }, [derivedTransform]);
  return derivedTransform;
}
function useSortable(_ref) {
  let {
    animateLayoutChanges = defaultAnimateLayoutChanges,
    attributes: userDefinedAttributes,
    disabled: localDisabled,
    data: customData,
    getNewIndex = defaultNewIndexGetter,
    id,
    strategy: localStrategy,
    resizeObserverConfig,
    transition = defaultTransition
  } = _ref;
  const {
    items,
    containerId,
    activeIndex,
    disabled: globalDisabled,
    disableTransforms,
    sortedRects,
    overIndex,
    useDragOverlay,
    strategy: globalStrategy
  } = (0, import_react.useContext)(Context);
  const disabled = normalizeLocalDisabled(localDisabled, globalDisabled);
  const index2 = items.indexOf(id);
  const data = (0, import_react.useMemo)(() => ({
    sortable: {
      containerId,
      index: index2,
      items
    },
    ...customData
  }), [containerId, customData, index2, items]);
  const itemsAfterCurrentSortable = (0, import_react.useMemo)(() => items.slice(items.indexOf(id)), [items, id]);
  const {
    rect,
    node: node2,
    isOver,
    setNodeRef: setDroppableNodeRef
  } = useDroppable({
    id,
    data,
    disabled: disabled.droppable,
    resizeObserverConfig: {
      updateMeasurementsFor: itemsAfterCurrentSortable,
      ...resizeObserverConfig
    }
  });
  const {
    active,
    activatorEvent,
    activeNodeRect,
    attributes,
    setNodeRef: setDraggableNodeRef,
    listeners,
    isDragging,
    over,
    setActivatorNodeRef,
    transform
  } = useDraggable({
    id,
    data,
    attributes: {
      ...defaultAttributes,
      ...userDefinedAttributes
    },
    disabled: disabled.draggable
  });
  const setNodeRef = useCombinedRefs(setDroppableNodeRef, setDraggableNodeRef);
  const isSorting = Boolean(active);
  const displaceItem = isSorting && !disableTransforms && isValidIndex(activeIndex) && isValidIndex(overIndex);
  const shouldDisplaceDragSource = !useDragOverlay && isDragging;
  const dragSourceDisplacement = shouldDisplaceDragSource && displaceItem ? transform : null;
  const strategy = localStrategy != null ? localStrategy : globalStrategy;
  const finalTransform = displaceItem ? dragSourceDisplacement != null ? dragSourceDisplacement : strategy({
    rects: sortedRects,
    activeNodeRect,
    activeIndex,
    overIndex,
    index: index2
  }) : null;
  const newIndex = isValidIndex(activeIndex) && isValidIndex(overIndex) ? getNewIndex({
    id,
    items,
    activeIndex,
    overIndex
  }) : index2;
  const activeId = active == null ? void 0 : active.id;
  const previous2 = (0, import_react.useRef)({
    activeId,
    items,
    newIndex,
    containerId
  });
  const itemsHaveChanged = items !== previous2.current.items;
  const shouldAnimateLayoutChanges = animateLayoutChanges({
    active,
    containerId,
    isDragging,
    isSorting,
    id,
    index: index2,
    items,
    newIndex: previous2.current.newIndex,
    previousItems: previous2.current.items,
    previousContainerId: previous2.current.containerId,
    transition,
    wasDragging: previous2.current.activeId != null
  });
  const derivedTransform = useDerivedTransform({
    disabled: !shouldAnimateLayoutChanges,
    index: index2,
    node: node2,
    rect
  });
  (0, import_react.useEffect)(() => {
    if (isSorting && previous2.current.newIndex !== newIndex) {
      previous2.current.newIndex = newIndex;
    }
    if (containerId !== previous2.current.containerId) {
      previous2.current.containerId = containerId;
    }
    if (items !== previous2.current.items) {
      previous2.current.items = items;
    }
  }, [isSorting, newIndex, containerId, items]);
  (0, import_react.useEffect)(() => {
    if (activeId === previous2.current.activeId) {
      return;
    }
    if (activeId && !previous2.current.activeId) {
      previous2.current.activeId = activeId;
      return;
    }
    const timeoutId = setTimeout(() => {
      previous2.current.activeId = activeId;
    }, 50);
    return () => clearTimeout(timeoutId);
  }, [activeId]);
  return {
    active,
    activeIndex,
    attributes,
    data,
    rect,
    index: index2,
    newIndex,
    items,
    isOver,
    isSorting,
    isDragging,
    listeners,
    node: node2,
    overIndex,
    over,
    setNodeRef,
    setActivatorNodeRef,
    setDroppableNodeRef,
    setDraggableNodeRef,
    transform: derivedTransform != null ? derivedTransform : finalTransform,
    transition: getTransition()
  };
  function getTransition() {
    if (
      // Temporarily disable transitions for a single frame to set up derived transforms
      derivedTransform || // Or to prevent items jumping to back to their "new" position when items change
      itemsHaveChanged && previous2.current.newIndex === index2
    ) {
      return disabledTransition;
    }
    if (shouldDisplaceDragSource && !isKeyboardEvent(activatorEvent) || !transition) {
      return void 0;
    }
    if (isSorting || shouldAnimateLayoutChanges) {
      return CSS.Transition.toString({
        ...transition,
        property: transitionProperty
      });
    }
    return void 0;
  }
}
function normalizeLocalDisabled(localDisabled, globalDisabled) {
  var _localDisabled$dragga, _localDisabled$droppa;
  if (typeof localDisabled === "boolean") {
    return {
      draggable: localDisabled,
      // Backwards compatibility
      droppable: false
    };
  }
  return {
    draggable: (_localDisabled$dragga = localDisabled == null ? void 0 : localDisabled.draggable) != null ? _localDisabled$dragga : globalDisabled.draggable,
    droppable: (_localDisabled$droppa = localDisabled == null ? void 0 : localDisabled.droppable) != null ? _localDisabled$droppa : globalDisabled.droppable
  };
}
function hasSortableData(entry) {
  if (!entry) {
    return false;
  }
  const data = entry.data.current;
  if (data && "sortable" in data && typeof data.sortable === "object" && "containerId" in data.sortable && "items" in data.sortable && "index" in data.sortable) {
    return true;
  }
  return false;
}
function isSameContainer(a, b) {
  if (!hasSortableData(a) || !hasSortableData(b)) {
    return false;
  }
  return a.data.current.sortable.containerId === b.data.current.sortable.containerId;
}
function isAfter(a, b) {
  if (!hasSortableData(a) || !hasSortableData(b)) {
    return false;
  }
  if (!isSameContainer(a, b)) {
    return false;
  }
  return a.data.current.sortable.index < b.data.current.sortable.index;
}
var import_dist, import_dist2, import_dist3, import_react, defaultScale, horizontalListSortingStrategy, rectSortingStrategy, rectSwappingStrategy, defaultScale$1, verticalListSortingStrategy, ID_PREFIX, Context, defaultNewIndexGetter, defaultAnimateLayoutChanges, defaultTransition, transitionProperty, disabledTransition, defaultAttributes, directions, sortableKeyboardCoordinates;
var init_sortable_esm = __esm({
  "node_modules/@splunk/react-ui/node_modules/@dnd-kit/sortable/dist/sortable.esm.js"() {
    import_dist = __toESM(require_dist());
    import_dist2 = __toESM(require_dist2());
    import_dist3 = __toESM(require_dist3());
    import_react = __toESM(require_react());
    init_core_esm();
    init_utilities_esm();
    defaultScale = {
      scaleX: 1,
      scaleY: 1
    };
    horizontalListSortingStrategy = (_ref) => {
      var _rects$activeIndex;
      let {
        rects,
        activeNodeRect: fallbackActiveRect,
        activeIndex,
        overIndex,
        index: index2
      } = _ref;
      const activeNodeRect = (_rects$activeIndex = rects[activeIndex]) != null ? _rects$activeIndex : fallbackActiveRect;
      if (!activeNodeRect) {
        return null;
      }
      const itemGap = getItemGap(rects, index2, activeIndex);
      if (index2 === activeIndex) {
        const newIndexRect = rects[overIndex];
        if (!newIndexRect) {
          return null;
        }
        return {
          x: activeIndex < overIndex ? newIndexRect.left + newIndexRect.width - (activeNodeRect.left + activeNodeRect.width) : newIndexRect.left - activeNodeRect.left,
          y: 0,
          ...defaultScale
        };
      }
      if (index2 > activeIndex && index2 <= overIndex) {
        return {
          x: -activeNodeRect.width - itemGap,
          y: 0,
          ...defaultScale
        };
      }
      if (index2 < activeIndex && index2 >= overIndex) {
        return {
          x: activeNodeRect.width + itemGap,
          y: 0,
          ...defaultScale
        };
      }
      return {
        x: 0,
        y: 0,
        ...defaultScale
      };
    };
    rectSortingStrategy = (_ref) => {
      let {
        rects,
        activeIndex,
        overIndex,
        index: index2
      } = _ref;
      const newRects = arrayMove(rects, overIndex, activeIndex);
      const oldRect = rects[index2];
      const newRect = newRects[index2];
      if (!newRect || !oldRect) {
        return null;
      }
      return {
        x: newRect.left - oldRect.left,
        y: newRect.top - oldRect.top,
        scaleX: newRect.width / oldRect.width,
        scaleY: newRect.height / oldRect.height
      };
    };
    rectSwappingStrategy = (_ref) => {
      let {
        activeIndex,
        index: index2,
        rects,
        overIndex
      } = _ref;
      let oldRect;
      let newRect;
      if (index2 === activeIndex) {
        oldRect = rects[index2];
        newRect = rects[overIndex];
      }
      if (index2 === overIndex) {
        oldRect = rects[index2];
        newRect = rects[activeIndex];
      }
      if (!newRect || !oldRect) {
        return null;
      }
      return {
        x: newRect.left - oldRect.left,
        y: newRect.top - oldRect.top,
        scaleX: newRect.width / oldRect.width,
        scaleY: newRect.height / oldRect.height
      };
    };
    defaultScale$1 = {
      scaleX: 1,
      scaleY: 1
    };
    verticalListSortingStrategy = (_ref) => {
      var _rects$activeIndex;
      let {
        activeIndex,
        activeNodeRect: fallbackActiveRect,
        index: index2,
        rects,
        overIndex
      } = _ref;
      const activeNodeRect = (_rects$activeIndex = rects[activeIndex]) != null ? _rects$activeIndex : fallbackActiveRect;
      if (!activeNodeRect) {
        return null;
      }
      if (index2 === activeIndex) {
        const overIndexRect = rects[overIndex];
        if (!overIndexRect) {
          return null;
        }
        return {
          x: 0,
          y: activeIndex < overIndex ? overIndexRect.top + overIndexRect.height - (activeNodeRect.top + activeNodeRect.height) : overIndexRect.top - activeNodeRect.top,
          ...defaultScale$1
        };
      }
      const itemGap = getItemGap$1(rects, index2, activeIndex);
      if (index2 > activeIndex && index2 <= overIndex) {
        return {
          x: 0,
          y: -activeNodeRect.height - itemGap,
          ...defaultScale$1
        };
      }
      if (index2 < activeIndex && index2 >= overIndex) {
        return {
          x: 0,
          y: activeNodeRect.height + itemGap,
          ...defaultScale$1
        };
      }
      return {
        x: 0,
        y: 0,
        ...defaultScale$1
      };
    };
    ID_PREFIX = "Sortable";
    Context = import_react.default.createContext({
      activeIndex: -1,
      containerId: ID_PREFIX,
      disableTransforms: false,
      items: [],
      overIndex: -1,
      useDragOverlay: false,
      sortedRects: [],
      strategy: rectSortingStrategy,
      disabled: {
        draggable: false,
        droppable: false
      }
    });
    defaultNewIndexGetter = (_ref) => {
      let {
        id,
        items,
        activeIndex,
        overIndex
      } = _ref;
      return arrayMove(items, activeIndex, overIndex).indexOf(id);
    };
    defaultAnimateLayoutChanges = (_ref2) => {
      let {
        containerId,
        isSorting,
        wasDragging,
        index: index2,
        items,
        newIndex,
        previousItems,
        previousContainerId,
        transition
      } = _ref2;
      if (!transition || !wasDragging) {
        return false;
      }
      if (previousItems !== items && index2 === newIndex) {
        return false;
      }
      if (isSorting) {
        return true;
      }
      return newIndex !== index2 && containerId === previousContainerId;
    };
    defaultTransition = {
      duration: 200,
      easing: "ease"
    };
    transitionProperty = "transform";
    disabledTransition = CSS.Transition.toString({
      property: transitionProperty,
      duration: 0,
      easing: "linear"
    });
    defaultAttributes = {
      roleDescription: "sortable"
    };
    directions = [KeyboardCode.Down, KeyboardCode.Right, KeyboardCode.Up, KeyboardCode.Left];
    sortableKeyboardCoordinates = (event, _ref) => {
      let {
        context: {
          active,
          collisionRect,
          droppableRects,
          droppableContainers,
          over,
          scrollableAncestors
        }
      } = _ref;
      if (directions.includes(event.code)) {
        event.preventDefault();
        if (!active || !collisionRect) {
          return;
        }
        const filteredContainers = [];
        droppableContainers.getEnabled().forEach((entry) => {
          if (!entry || entry != null && entry.disabled) {
            return;
          }
          const rect = droppableRects.get(entry.id);
          if (!rect) {
            return;
          }
          switch (event.code) {
            case KeyboardCode.Down:
              if (collisionRect.top < rect.top) {
                filteredContainers.push(entry);
              }
              break;
            case KeyboardCode.Up:
              if (collisionRect.top > rect.top) {
                filteredContainers.push(entry);
              }
              break;
            case KeyboardCode.Left:
              if (collisionRect.left > rect.left) {
                filteredContainers.push(entry);
              }
              break;
            case KeyboardCode.Right:
              if (collisionRect.left < rect.left) {
                filteredContainers.push(entry);
              }
              break;
          }
        });
        const collisions = closestCorners({
          active,
          collisionRect,
          droppableRects,
          droppableContainers: filteredContainers,
          pointerCoordinates: null
        });
        let closestId = getFirstCollision(collisions, "id");
        if (closestId === (over == null ? void 0 : over.id) && collisions.length > 1) {
          closestId = collisions[1].id;
        }
        if (closestId != null) {
          const activeDroppable = droppableContainers.get(active.id);
          const newDroppable = droppableContainers.get(closestId);
          const newRect = newDroppable ? droppableRects.get(newDroppable.id) : null;
          const newNode = newDroppable == null ? void 0 : newDroppable.node.current;
          if (newNode && newRect && activeDroppable && newDroppable) {
            const newScrollAncestors = getScrollableAncestors(newNode);
            const hasDifferentScrollAncestors = newScrollAncestors.some((element2, index2) => scrollableAncestors[index2] !== element2);
            const hasSameContainer = isSameContainer(activeDroppable, newDroppable);
            const isAfterActive = isAfter(activeDroppable, newDroppable);
            const offset = hasDifferentScrollAncestors || !hasSameContainer ? {
              x: 0,
              y: 0
            } : {
              x: isAfterActive ? collisionRect.width - newRect.width : 0,
              y: isAfterActive ? collisionRect.height - newRect.height : 0
            };
            const rectCoordinates = {
              x: newRect.left,
              y: newRect.top
            };
            const newCoordinates = offset.x && offset.y ? rectCoordinates : subtract(rectCoordinates, offset);
            return newCoordinates;
          }
        }
      }
      return void 0;
    };
  }
});

// node_modules/@splunk/react-icons/ParallelDots.js
var require_ParallelDots = __commonJS({
  "node_modules/@splunk/react-icons/ParallelDots.js"(exports, module) {
    var import_dist466 = __toESM(require_dist());
    var import_dist467 = __toESM(require_dist2());
    var import_dist468 = __toESM(require_dist3());
    (() => {
      "use strict";
      var e = {};
      (() => {
        e.n = (r2) => {
          var t2 = r2 && r2.__esModule ? (
            /******/
            () => r2["default"]
          ) : () => r2;
          e.d(t2, {
            a: t2
          });
          return t2;
        };
      })();
      (() => {
        e.d = (r2, t2) => {
          for (var n2 in t2) {
            if (e.o(t2, n2) && !e.o(r2, n2)) {
              Object.defineProperty(r2, n2, {
                enumerable: true,
                get: t2[n2]
              });
            }
          }
        };
      })();
      (() => {
        e.o = (e2, r2) => Object.prototype.hasOwnProperty.call(e2, r2);
      })();
      (() => {
        e.r = (e2) => {
          if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
            Object.defineProperty(e2, Symbol.toStringTag, {
              value: "Module"
            });
          }
          Object.defineProperty(e2, "__esModule", {
            value: true
          });
        };
      })();
      var r = {};
      e.r(r);
      e.d(r, {
        default: () => (
          /* binding */
          p
        )
      });
      const t = require_react();
      var n = e.n(t);
      const a = require_IconProvider();
      const o = require_SVG();
      var l = e.n(o);
      function u(e2, r2) {
        if (null == e2) return {};
        var t2, n2, a2 = c(e2, r2);
        if (Object.getOwnPropertySymbols) {
          var o2 = Object.getOwnPropertySymbols(e2);
          for (n2 = 0; n2 < o2.length; n2++) {
            t2 = o2[n2], -1 === r2.indexOf(t2) && {}.propertyIsEnumerable.call(e2, t2) && (a2[t2] = e2[t2]);
          }
        }
        return a2;
      }
      function c(e2, r2) {
        if (null == e2) return {};
        var t2 = {};
        for (var n2 in e2) {
          if ({}.hasOwnProperty.call(e2, n2)) {
            if (-1 !== r2.indexOf(n2)) continue;
            t2[n2] = e2[n2];
          }
        }
        return t2;
      }
      var i = /* @__PURE__ */ new Map();
      i.set("outlined", (function() {
        return n().createElement(n().Fragment, null, n().createElement("path", {
          d: "M16.9732 4.63636C16.9732 5.5401 16.2406 6.27273 15.3369 6.27273C14.4331 6.27273 13.7005 5.5401 13.7005 4.63636C13.7005 3.73263 14.4331 3 15.3369 3C16.2406 3 16.9732 3.73263 16.9732 4.63636Z"
        }), n().createElement("path", {
          d: "M16.9732 12C16.9732 12.9038 16.2406 13.6364 15.3369 13.6364C14.4331 13.6364 13.7005 12.9038 13.7005 12C13.7005 11.0963 14.4331 10.3636 15.3369 10.3636C16.2406 10.3636 16.9732 11.0963 16.9732 12Z"
        }), n().createElement("path", {
          d: "M8.63685 21C9.54059 21 10.2732 20.2674 10.2732 19.3637C10.2732 18.4599 9.54059 17.7273 8.63685 17.7273C7.73311 17.7273 7.00049 18.4599 7.00049 19.3637C7.00049 20.2674 7.73311 21 8.63685 21Z"
        }), n().createElement("path", {
          d: "M15.3369 21C16.2406 21 16.9732 20.2674 16.9732 19.3637C16.9732 18.4599 16.2406 17.7273 15.3369 17.7273C14.4331 17.7273 13.7005 18.4599 13.7005 19.3637C13.7005 20.2674 14.4331 21 15.3369 21Z"
        }), n().createElement("path", {
          d: "M8.63685 13.6364C9.54059 13.6364 10.2732 12.9038 10.2732 12C10.2732 11.0963 9.54059 10.3636 8.63685 10.3636C7.73311 10.3636 7.00049 11.0963 7.00049 12C7.00049 12.9038 7.73311 13.6364 8.63685 13.6364Z"
        }), n().createElement("path", {
          d: "M8.63685 6.27273C9.54059 6.27273 10.2732 5.5401 10.2732 4.63636C10.2732 3.73263 9.54059 3 8.63685 3C7.73311 3 7.00049 3.73263 7.00049 4.63636C7.00049 5.5401 7.73311 6.27273 8.63685 6.27273Z"
        }));
      }));
      var d = ["default", "outlined"];
      var f = function e2(r2) {
        return d.indexOf(r2) >= 0;
      };
      var v = function e2(r2) {
        return r2 === "default" || r2 && !f(r2) ? "outlined" : r2;
      };
      var C = function e2(r2) {
        var o2 = r2.children, c2 = r2.variant, d2 = c2 === void 0 ? "default" : c2, f2 = u(r2, ["children", "variant"]);
        var C2 = v(d2);
        var p2 = "paralleldots-".concat(C2);
        var s = (0, t.useContext)(a.IconContext);
        var m = i.get(C2);
        if (false) {
        }
        if (s && m) {
          var y = s.toRender, b = s.addIcon;
          b(p2, m());
          if (!y) {
            return null;
          }
        }
        return n().createElement(l(), f2, o2, s ? n().createElement("use", {
          href: "#".concat(p2)
        }) : !!m && m());
      };
      const p = C;
      module.exports = r;
    })();
  }
});

// node_modules/lodash/indexOf.js
var require_indexOf = __commonJS({
  "node_modules/lodash/indexOf.js"(exports, module) {
    var import_dist466 = __toESM(require_dist());
    var import_dist467 = __toESM(require_dist2());
    var import_dist468 = __toESM(require_dist3());
    var baseIndexOf = require_baseIndexOf();
    var toInteger = require_toInteger();
    var nativeMax = Math.max;
    function indexOf(array, value, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index2 = fromIndex == null ? 0 : toInteger(fromIndex);
      if (index2 < 0) {
        index2 = nativeMax(length + index2, 0);
      }
      return baseIndexOf(array, value, index2);
    }
    module.exports = indexOf;
  }
});

// node_modules/@splunk/react-ui/useResizeObserver.js
var require_useResizeObserver = __commonJS({
  "node_modules/@splunk/react-ui/useResizeObserver.js"(exports, module) {
    var import_dist466 = __toESM(require_dist());
    var import_dist467 = __toESM(require_dist2());
    var import_dist468 = __toESM(require_dist3());
    (() => {
      "use strict";
      var e = {
        /***/
        9497: (
          /***/
          (e2) => {
            e2.exports = require_react();
          }
        )
      };
      var r = {};
      function t(n2) {
        var i = r[n2];
        if (i !== void 0) {
          return i.exports;
        }
        var o = r[n2] = {
          /******/
          // no module.id needed
          /******/
          // no module.loaded needed
          /******/
          exports: {}
          /******/
        };
        e[n2](o, o.exports, t);
        return o.exports;
      }
      (() => {
        t.d = (e2, r2) => {
          for (var n2 in r2) {
            if (t.o(r2, n2) && !t.o(e2, n2)) {
              Object.defineProperty(e2, n2, {
                enumerable: true,
                get: r2[n2]
              });
            }
          }
        };
      })();
      (() => {
        t.o = (e2, r2) => Object.prototype.hasOwnProperty.call(e2, r2);
      })();
      (() => {
        t.r = (e2) => {
          if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
            Object.defineProperty(e2, Symbol.toStringTag, {
              value: "Module"
            });
          }
          Object.defineProperty(e2, "__esModule", {
            value: true
          });
        };
      })();
      var n = {};
      (() => {
        t.r(n);
        t.d(n, {
          default: () => (
            /* reexport */
            c
          )
        });
        var e2 = t(9497);
        function r2(e3, r3) {
          return a(e3) || l(e3, r3) || o(e3, r3) || i();
        }
        function i() {
          throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        function o(e3, r3) {
          if (e3) {
            if ("string" == typeof e3) return u(e3, r3);
            var t2 = {}.toString.call(e3).slice(8, -1);
            return "Object" === t2 && e3.constructor && (t2 = e3.constructor.name), "Map" === t2 || "Set" === t2 ? Array.from(e3) : "Arguments" === t2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t2) ? u(e3, r3) : void 0;
          }
        }
        function u(e3, r3) {
          (null == r3 || r3 > e3.length) && (r3 = e3.length);
          for (var t2 = 0, n2 = Array(r3); t2 < r3; t2++) {
            n2[t2] = e3[t2];
          }
          return n2;
        }
        function l(e3, r3) {
          var t2 = null == e3 ? null : "undefined" != typeof Symbol && e3[Symbol.iterator] || e3["@@iterator"];
          if (null != t2) {
            var n2, i2, o2, u2, l2 = [], a2 = true, f2 = false;
            try {
              if (o2 = (t2 = t2.call(e3)).next, 0 === r3) {
                if (Object(t2) !== t2) return;
                a2 = false;
              } else for (; !(a2 = (n2 = o2.call(t2)).done) && (l2.push(n2.value), l2.length !== r3); a2 = true) {
              }
            } catch (e4) {
              f2 = true, i2 = e4;
            } finally {
              try {
                if (!a2 && null != t2["return"] && (u2 = t2["return"](), Object(u2) !== u2)) return;
              } finally {
                if (f2) throw i2;
              }
            }
            return l2;
          }
        }
        function a(e3) {
          if (Array.isArray(e3)) return e3;
        }
        var f = function t2(n2, i2) {
          var o2 = (0, e2.useState)({
            width: 0,
            height: 0
          }), u2 = r2(o2, 2), l2 = u2[0], a2 = u2[1];
          (0, e2.useEffect)((function() {
            var e3 = n2.current;
            if (typeof window !== "undefined" && window.ResizeObserver) {
              var r3 = new ResizeObserver((function(e4) {
                if (e4[0]) {
                  var r4, t3;
                  var o3 = {
                    width: (n2 === null || n2 === void 0 ? void 0 : (r4 = n2.current) === null || r4 === void 0 ? void 0 : r4.getBoundingClientRect().width) || 0,
                    height: (n2 === null || n2 === void 0 ? void 0 : (t3 = n2.current) === null || t3 === void 0 ? void 0 : t3.getBoundingClientRect().height) || 0
                  };
                  a2((function(e5) {
                    if (e5.height !== o3.height || e5.width !== o3.width) {
                      i2 === null || i2 === void 0 ? void 0 : i2(o3);
                      return o3;
                    }
                    return e5;
                  }));
                }
              }));
              if (e3) {
                r3.observe(e3);
              }
              return function() {
                if (e3) {
                  r3.unobserve(e3);
                }
              };
            }
            return function() {
            };
          }), [i2, n2]);
          return l2;
        };
        const c = f;
      })();
      module.exports = n;
    })();
  }
});

// node_modules/@splunk/react-icons/ArrowDown.js
var require_ArrowDown = __commonJS({
  "node_modules/@splunk/react-icons/ArrowDown.js"(exports, module) {
    var import_dist466 = __toESM(require_dist());
    var import_dist467 = __toESM(require_dist2());
    var import_dist468 = __toESM(require_dist3());
    (() => {
      "use strict";
      var e = {};
      (() => {
        e.n = (r2) => {
          var t2 = r2 && r2.__esModule ? (
            /******/
            () => r2["default"]
          ) : () => r2;
          e.d(t2, {
            a: t2
          });
          return t2;
        };
      })();
      (() => {
        e.d = (r2, t2) => {
          for (var n2 in t2) {
            if (e.o(t2, n2) && !e.o(r2, n2)) {
              Object.defineProperty(r2, n2, {
                enumerable: true,
                get: t2[n2]
              });
            }
          }
        };
      })();
      (() => {
        e.o = (e2, r2) => Object.prototype.hasOwnProperty.call(e2, r2);
      })();
      (() => {
        e.r = (e2) => {
          if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
            Object.defineProperty(e2, Symbol.toStringTag, {
              value: "Module"
            });
          }
          Object.defineProperty(e2, "__esModule", {
            value: true
          });
        };
      })();
      var r = {};
      e.r(r);
      e.d(r, {
        default: () => (
          /* binding */
          p
        )
      });
      const t = require_react();
      var n = e.n(t);
      const a = require_IconProvider();
      const o = require_SVG();
      var u = e.n(o);
      function l(e2, r2) {
        if (null == e2) return {};
        var t2, n2, a2 = i(e2, r2);
        if (Object.getOwnPropertySymbols) {
          var o2 = Object.getOwnPropertySymbols(e2);
          for (n2 = 0; n2 < o2.length; n2++) {
            t2 = o2[n2], -1 === r2.indexOf(t2) && {}.propertyIsEnumerable.call(e2, t2) && (a2[t2] = e2[t2]);
          }
        }
        return a2;
      }
      function i(e2, r2) {
        if (null == e2) return {};
        var t2 = {};
        for (var n2 in e2) {
          if ({}.hasOwnProperty.call(e2, n2)) {
            if (-1 !== r2.indexOf(n2)) continue;
            t2[n2] = e2[n2];
          }
        }
        return t2;
      }
      var c = /* @__PURE__ */ new Map();
      c.set("outlined", (function() {
        return n().createElement(n().Fragment, null, n().createElement("path", {
          d: "M6.55086 12.3369C6.16033 11.9464 5.52717 11.9464 5.13664 12.3369C4.74612 12.7275 4.74612 13.3606 5.13664 13.7512L10.9391 19.5536C11.5249 20.1394 12.4746 20.1394 13.0604 19.5536L18.8628 13.7512C19.2534 13.3606 19.2534 12.7275 18.8628 12.3369C18.4723 11.9464 17.8391 11.9464 17.4486 12.3369L13 16.7855V5.00234C13 4.45006 12.5523 4.00234 12 4.00234C11.4477 4.00234 11 4.45006 11 5.00234V16.7861L6.55086 12.3369Z"
        }));
      }));
      var f = ["default", "outlined"];
      var d = function e2(r2) {
        return f.indexOf(r2) >= 0;
      };
      var v = function e2(r2) {
        return r2 === "default" || r2 && !d(r2) ? "outlined" : r2;
      };
      var s = function e2(r2) {
        var o2 = r2.children, i2 = r2.variant, f2 = i2 === void 0 ? "default" : i2, d2 = l(r2, ["children", "variant"]);
        var s2 = v(f2);
        var p2 = "arrowdown-".concat(s2);
        var y = (0, t.useContext)(a.IconContext);
        var b = c.get(s2);
        if (false) {
        }
        if (y && b) {
          var m = y.toRender, O = y.addIcon;
          O(p2, b());
          if (!m) {
            return null;
          }
        }
        return n().createElement(u(), d2, o2, y ? n().createElement("use", {
          href: "#".concat(p2)
        }) : !!b && b());
      };
      const p = s;
      module.exports = r;
    })();
  }
});

// node_modules/@splunk/react-icons/ArrowUp.js
var require_ArrowUp = __commonJS({
  "node_modules/@splunk/react-icons/ArrowUp.js"(exports, module) {
    var import_dist466 = __toESM(require_dist());
    var import_dist467 = __toESM(require_dist2());
    var import_dist468 = __toESM(require_dist3());
    (() => {
      "use strict";
      var e = {};
      (() => {
        e.n = (r2) => {
          var t2 = r2 && r2.__esModule ? (
            /******/
            () => r2["default"]
          ) : () => r2;
          e.d(t2, {
            a: t2
          });
          return t2;
        };
      })();
      (() => {
        e.d = (r2, t2) => {
          for (var n2 in t2) {
            if (e.o(t2, n2) && !e.o(r2, n2)) {
              Object.defineProperty(r2, n2, {
                enumerable: true,
                get: t2[n2]
              });
            }
          }
        };
      })();
      (() => {
        e.o = (e2, r2) => Object.prototype.hasOwnProperty.call(e2, r2);
      })();
      (() => {
        e.r = (e2) => {
          if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
            Object.defineProperty(e2, Symbol.toStringTag, {
              value: "Module"
            });
          }
          Object.defineProperty(e2, "__esModule", {
            value: true
          });
        };
      })();
      var r = {};
      e.r(r);
      e.d(r, {
        default: () => (
          /* binding */
          p
        )
      });
      const t = require_react();
      var n = e.n(t);
      const a = require_IconProvider();
      const o = require_SVG();
      var u = e.n(o);
      function l(e2, r2) {
        if (null == e2) return {};
        var t2, n2, a2 = i(e2, r2);
        if (Object.getOwnPropertySymbols) {
          var o2 = Object.getOwnPropertySymbols(e2);
          for (n2 = 0; n2 < o2.length; n2++) {
            t2 = o2[n2], -1 === r2.indexOf(t2) && {}.propertyIsEnumerable.call(e2, t2) && (a2[t2] = e2[t2]);
          }
        }
        return a2;
      }
      function i(e2, r2) {
        if (null == e2) return {};
        var t2 = {};
        for (var n2 in e2) {
          if ({}.hasOwnProperty.call(e2, n2)) {
            if (-1 !== r2.indexOf(n2)) continue;
            t2[n2] = e2[n2];
          }
        }
        return t2;
      }
      var c = /* @__PURE__ */ new Map();
      c.set("outlined", (function() {
        return n().createElement(n().Fragment, null, n().createElement("path", {
          d: "M6.55135 11.6631C6.16082 12.0536 5.52766 12.0536 5.13713 11.6631C4.74661 11.2725 4.74661 10.6394 5.13713 10.2488L10.9396 4.44642C11.5253 3.86064 12.4751 3.86063 13.0609 4.44642L18.8633 10.2488C19.2538 10.6394 19.2538 11.2725 18.8633 11.6631C18.4728 12.0536 17.8396 12.0536 17.4491 11.6631L13 7.21397V19.0009C13 19.5532 12.5523 20.0009 12 20.0009C11.4477 20.0009 11 19.5532 11 19.0009V7.21441L6.55135 11.6631Z"
        }));
      }));
      var f = ["default", "outlined"];
      var d = function e2(r2) {
        return f.indexOf(r2) >= 0;
      };
      var v = function e2(r2) {
        return r2 === "default" || r2 && !d(r2) ? "outlined" : r2;
      };
      var s = function e2(r2) {
        var o2 = r2.children, i2 = r2.variant, f2 = i2 === void 0 ? "default" : i2, d2 = l(r2, ["children", "variant"]);
        var s2 = v(f2);
        var p2 = "arrowup-".concat(s2);
        var y = (0, t.useContext)(a.IconContext);
        var b = c.get(s2);
        if (false) {
        }
        if (y && b) {
          var m = y.toRender, O = y.addIcon;
          O(p2, b());
          if (!m) {
            return null;
          }
        }
        return n().createElement(u(), d2, o2, y ? n().createElement("use", {
          href: "#".concat(p2)
        }) : !!b && b());
      };
      const p = s;
      module.exports = r;
    })();
  }
});

// node_modules/@splunk/react-icons/ArrowUpDown.js
var require_ArrowUpDown = __commonJS({
  "node_modules/@splunk/react-icons/ArrowUpDown.js"(exports, module) {
    var import_dist466 = __toESM(require_dist());
    var import_dist467 = __toESM(require_dist2());
    var import_dist468 = __toESM(require_dist3());
    (() => {
      "use strict";
      var e = {};
      (() => {
        e.n = (r2) => {
          var t2 = r2 && r2.__esModule ? (
            /******/
            () => r2["default"]
          ) : () => r2;
          e.d(t2, {
            a: t2
          });
          return t2;
        };
      })();
      (() => {
        e.d = (r2, t2) => {
          for (var n2 in t2) {
            if (e.o(t2, n2) && !e.o(r2, n2)) {
              Object.defineProperty(r2, n2, {
                enumerable: true,
                get: t2[n2]
              });
            }
          }
        };
      })();
      (() => {
        e.o = (e2, r2) => Object.prototype.hasOwnProperty.call(e2, r2);
      })();
      (() => {
        e.r = (e2) => {
          if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
            Object.defineProperty(e2, Symbol.toStringTag, {
              value: "Module"
            });
          }
          Object.defineProperty(e2, "__esModule", {
            value: true
          });
        };
      })();
      var r = {};
      e.r(r);
      e.d(r, {
        default: () => (
          /* binding */
          p
        )
      });
      const t = require_react();
      var n = e.n(t);
      const a = require_IconProvider();
      const o = require_SVG();
      var u = e.n(o);
      function l(e2, r2) {
        if (null == e2) return {};
        var t2, n2, a2 = i(e2, r2);
        if (Object.getOwnPropertySymbols) {
          var o2 = Object.getOwnPropertySymbols(e2);
          for (n2 = 0; n2 < o2.length; n2++) {
            t2 = o2[n2], -1 === r2.indexOf(t2) && {}.propertyIsEnumerable.call(e2, t2) && (a2[t2] = e2[t2]);
          }
        }
        return a2;
      }
      function i(e2, r2) {
        if (null == e2) return {};
        var t2 = {};
        for (var n2 in e2) {
          if ({}.hasOwnProperty.call(e2, n2)) {
            if (-1 !== r2.indexOf(n2)) continue;
            t2[n2] = e2[n2];
          }
        }
        return t2;
      }
      var c = /* @__PURE__ */ new Map();
      c.set("outlined", (function() {
        return n().createElement(n().Fragment, null, n().createElement("path", {
          d: "M11 6.9142L8.20711 9.70709C7.81658 10.0976 7.18342 10.0976 6.79289 9.70709C6.40237 9.31657 6.40237 8.6834 6.79289 8.29288L10.9393 4.14643C11.5251 3.56064 12.4749 3.56065 13.0607 4.14643L17.2071 8.29288C17.5976 8.6834 17.5976 9.31657 17.2071 9.70709C16.8166 10.0976 16.1834 10.0976 15.7929 9.70709L13 6.9142V17.0858L15.7929 14.2929C16.1834 13.9024 16.8166 13.9024 17.2071 14.2929C17.5976 14.6834 17.5976 15.3166 17.2071 15.7071L13.0607 19.8535C12.4749 20.4393 11.5251 20.4393 10.9393 19.8535L6.79289 15.7071C6.40237 15.3166 6.40237 14.6834 6.79289 14.2929C7.18342 13.9024 7.81658 13.9024 8.20711 14.2929L11 17.0858V6.9142Z"
        }));
      }));
      var f = ["default", "outlined"];
      var d = function e2(r2) {
        return f.indexOf(r2) >= 0;
      };
      var v = function e2(r2) {
        return r2 === "default" || r2 && !d(r2) ? "outlined" : r2;
      };
      var s = function e2(r2) {
        var o2 = r2.children, i2 = r2.variant, f2 = i2 === void 0 ? "default" : i2, d2 = l(r2, ["children", "variant"]);
        var s2 = v(f2);
        var p2 = "arrowupdown-".concat(s2);
        var y = (0, t.useContext)(a.IconContext);
        var b = c.get(s2);
        if (false) {
        }
        if (y && b) {
          var m = y.toRender, O = y.addIcon;
          O(p2, b());
          if (!m) {
            return null;
          }
        }
        return n().createElement(u(), d2, o2, y ? n().createElement("use", {
          href: "#".concat(p2)
        }) : !!b && b());
      };
      const p = s;
      module.exports = r;
    })();
  }
});

// node_modules/@splunk/react-ui/Table.js
var require_Table = __commonJS({
  "node_modules/@splunk/react-ui/Table.js"(exports, module) {
    var import_dist466 = __toESM(require_dist());
    var import_dist467 = __toESM(require_dist2());
    var import_dist468 = __toESM(require_dist3());
    (() => {
      "use strict";
      var e = {};
      (() => {
        e.n = (n2) => {
          var t2 = n2 && n2.__esModule ? (
            /******/
            () => n2["default"]
          ) : () => n2;
          e.d(t2, {
            a: t2
          });
          return t2;
        };
      })();
      (() => {
        e.d = (n2, t2) => {
          for (var r2 in t2) {
            if (e.o(t2, r2) && !e.o(n2, r2)) {
              Object.defineProperty(n2, r2, {
                enumerable: true,
                get: t2[r2]
              });
            }
          }
        };
      })();
      (() => {
        e.o = (e2, n2) => Object.prototype.hasOwnProperty.call(e2, n2);
      })();
      (() => {
        e.r = (e2) => {
          if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
            Object.defineProperty(e2, Symbol.toStringTag, {
              value: "Module"
            });
          }
          Object.defineProperty(e2, "__esModule", {
            value: true
          });
        };
      })();
      var n = {};
      e.r(n);
      e.d(n, {
        Body: () => (
          /* reexport */
          Q
        ),
        Caption: () => (
          /* reexport */
          fe
        ),
        Cell: () => (
          /* reexport */
          Se
        ),
        Head: () => (
          /* reexport */
          nr
        ),
        HeadCell: () => (
          /* reexport */
          Mn
        ),
        HeadDropdownCell: () => (
          /* reexport */
          Sr
        ),
        Row: () => (
          /* reexport */
          Wt
        ),
        default: () => (
          /* reexport */
          Zo
        )
      });
      const t = require_react();
      var r = e.n(t);
      const o = (init_core_esm(), __toCommonJS(core_esm_exports));
      const i = (init_modifiers_esm(), __toCommonJS(modifiers_esm_exports));
      const a = (init_sortable_esm(), __toCommonJS(sortable_esm_exports));
      const l = require_forEach();
      var u = e.n(l);
      const s = require_has();
      var c = e.n(s);
      const d = require_indexOf();
      var f = e.n(d);
      const v = require_isEqual();
      var p = e.n(v);
      const m = require_isNumber();
      const b = require_omit();
      var h = e.n(b);
      const y = require_throttle();
      var g = e.n(y);
      const w = require_prop_types();
      var C = e.n(w);
      const x = require_EventListener();
      var S = e.n(x);
      const O = require_ScrollContainerContext();
      const k = require_usePrevious();
      var R = e.n(k);
      const E = require_useResizeObserver();
      var I = e.n(E);
      const T = require_format();
      const j = require_i18n();
      const D = require_id();
      const q = require_includes();
      var A = e.n(q);
      const P = require_without();
      var _ = e.n(P);
      const z = (init_styled_components_esm(), __toCommonJS(styled_components_esm_exports));
      var M = e.n(z);
      const $2 = require_themes();
      var N = M().tbody.withConfig({
        displayName: "BodyStyles__Styled",
        componentId: "sc-1k5p6pq-0"
      })(["", " z-index:0;"], $2.mixins.reset("table-row-group"));
      function L(e2, n2) {
        if (e2) {
          if (typeof e2 === "function") {
            e2(n2);
          } else {
            e2.current = n2;
          }
        }
      }
      function W() {
        return W = Object.assign ? Object.assign.bind() : function(e2) {
          for (var n2 = 1; n2 < arguments.length; n2++) {
            var t2 = arguments[n2];
            for (var r2 in t2) {
              ({}).hasOwnProperty.call(t2, r2) && (e2[r2] = t2[r2]);
            }
          }
          return e2;
        }, W.apply(null, arguments);
      }
      function H(e2, n2) {
        return U(e2) || F(e2, n2) || B(e2, n2) || K();
      }
      function K() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      function B(e2, n2) {
        if (e2) {
          if ("string" == typeof e2) return V(e2, n2);
          var t2 = {}.toString.call(e2).slice(8, -1);
          return "Object" === t2 && e2.constructor && (t2 = e2.constructor.name), "Map" === t2 || "Set" === t2 ? Array.from(e2) : "Arguments" === t2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t2) ? V(e2, n2) : void 0;
        }
      }
      function V(e2, n2) {
        (null == n2 || n2 > e2.length) && (n2 = e2.length);
        for (var t2 = 0, r2 = Array(n2); t2 < n2; t2++) {
          r2[t2] = e2[t2];
        }
        return r2;
      }
      function F(e2, n2) {
        var t2 = null == e2 ? null : "undefined" != typeof Symbol && e2[Symbol.iterator] || e2["@@iterator"];
        if (null != t2) {
          var r2, o2, i2, a2, l2 = [], u2 = true, s2 = false;
          try {
            if (i2 = (t2 = t2.call(e2)).next, 0 === n2) {
              if (Object(t2) !== t2) return;
              u2 = false;
            } else for (; !(u2 = (r2 = i2.call(t2)).done) && (l2.push(r2.value), l2.length !== n2); u2 = true) {
            }
          } catch (e3) {
            s2 = true, o2 = e3;
          } finally {
            try {
              if (!u2 && null != t2["return"] && (a2 = t2["return"](), Object(a2) !== a2)) return;
            } finally {
              if (s2) throw o2;
            }
          }
          return l2;
        }
      }
      function U(e2) {
        if (Array.isArray(e2)) return e2;
      }
      function X(e2, n2) {
        if (null == e2) return {};
        var t2, r2, o2 = Y(e2, n2);
        if (Object.getOwnPropertySymbols) {
          var i2 = Object.getOwnPropertySymbols(e2);
          for (r2 = 0; r2 < i2.length; r2++) {
            t2 = i2[r2], -1 === n2.indexOf(t2) && {}.propertyIsEnumerable.call(e2, t2) && (o2[t2] = e2[t2]);
          }
        }
        return o2;
      }
      function Y(e2, n2) {
        if (null == e2) return {};
        var t2 = {};
        for (var r2 in e2) {
          if ({}.hasOwnProperty.call(e2, r2)) {
            if (-1 !== n2.indexOf(r2)) continue;
            t2[r2] = e2[r2];
          }
        }
        return t2;
      }
      var G = {
        /** @private. Generally passed by Table rather than added directly. */
        actions: C().bool,
        children: C().node,
        elementRef: C().oneOfType([C().func, C().object]),
        /** @private. Generally passed by Table rather than added directly. */
        movableColumns: C().bool,
        /** @private. Generally passed by Table rather than added directly. */
        rowExpansion: C().oneOf(["single", "multi", "none", "controlled"]),
        /** @private. Generally passed by Table rather than added directly. */
        onRequestMoveRow: C().func,
        /** @private. Generally passed by Table rather than added directly. */
        primaryColumnIndex: C().number,
        /** @private. Generally passed by Table rather than added directly. */
        stripeRows: C().bool
      };
      function J(e2) {
        var n2 = e2.actions, o2 = e2.children, i2 = e2.elementRef, a2 = e2.movableColumns, l2 = e2.onRequestMoveRow, u2 = e2.rowExpansion, s2 = u2 === void 0 ? "none" : u2, c2 = e2.primaryColumnIndex, d2 = e2.stripeRows, f2 = X(e2, ["actions", "children", "elementRef", "movableColumns", "onRequestMoveRow", "rowExpansion", "primaryColumnIndex", "stripeRows"]);
        var v2 = [];
        var p2 = (0, t.useState)([]), m2 = H(p2, 2), b2 = m2[0], h2 = m2[1];
        var y2 = (0, t.useRef)(null);
        var g2 = (0, t.useCallback)((function(e3) {
          y2.current = e3;
          L(i2, e3);
        }), [i2, y2]);
        var w2 = function e3(n3, t2, r2) {
          var o3 = b2;
          if (s2 === "single") {
            if (A()(o3, t2)) {
              h2([]);
            } else {
              h2([t2]);
            }
          } else if (s2 === "multi") {
            if (A()(o3, t2)) {
              h2(_()(o3, t2));
            } else {
              h2(o3 === null || o3 === void 0 ? void 0 : o3.concat(t2));
            }
          }
          r2 === null || r2 === void 0 ? void 0 : r2(n3);
        };
        var C2 = t.Children.toArray(o2).filter(t.isValidElement);
        var x2 = (0, t.useState)(/* @__PURE__ */ new Map()), S2 = H(x2, 2), O2 = S2[0], k2 = S2[1];
        r().useEffect((function() {
          k2((function(e3) {
            var n3 = new Map(e3);
            var r2 = false;
            C2.forEach((function(o3) {
              var i3;
              if (!o3.props.expansionRow) return;
              var a3 = (i3 = o3.key) !== null && i3 !== void 0 ? i3 : C2.indexOf(o3);
              var l3 = t.Children.count(o3.props.expansionRow);
              var u3 = e3.get(a3);
              if (!u3 || u3.length !== l3) {
                n3.set(a3, Array.from({
                  length: l3
                }, (function() {
                  return (0, D.createDOMID)();
                })));
                r2 = true;
              }
            }));
            return r2 ? n3 : e3;
          }));
        }), [C2]);
        C2.forEach((function(e3, r2) {
          if (e3) {
            var o3, i3;
            if (false) {
            }
            var u3 = (o3 = e3.key) !== null && o3 !== void 0 ? o3 : r2;
            var f3 = r2 % 2 ? "even" : "odd";
            var p3 = d2 ? f3 : "none";
            var m3 = s2 === "controlled" ? e3.props.expanded : A()(b2, u3);
            var h3 = function n3(t2) {
              w2(t2, u3, e3.props.onExpansion);
            };
            var y3 = e3.props.expansionRow ? (i3 = O2.get(u3)) === null || i3 === void 0 ? void 0 : i3.join(" ") : void 0;
            v2.push((0, t.cloneElement)(e3, {
              stripe: p3,
              actions: n2,
              expanded: m3,
              expansionRowIds: y3,
              expandable: s2 !== "none",
              isDraggable: !!l2,
              movableColumns: a2,
              primaryColumnIndex: c2,
              onExpansion: h3,
              key: e3.key || r2
            }));
            if (m3 && e3.props.expansionRow) {
              t.Children.forEach(e3.props.expansionRow, (function(e4, n3) {
                var r3;
                var o4 = (r3 = O2.get(u3)) === null || r3 === void 0 ? void 0 : r3[n3];
                v2.push((0, t.cloneElement)(e4, {
                  key: o4,
                  id: o4,
                  stripe: p3,
                  movableColumns: a2,
                  "data-expansion-row": "true"
                }));
              }));
            }
          }
        }));
        if (v2.length === 0) {
          return null;
        }
        return r().createElement(N, W({
          "data-test": "body"
        }, f2, {
          ref: g2
        }), v2);
      }
      J.propTypes = G;
      J.splunkUiType = "Table.Body";
      const Q = J;
      var Z = M().div.withConfig({
        displayName: "TableStyles__Styled",
        componentId: "sc-1cmfss7-0"
      })(["", ";max-width:100%;position:relative;z-index:1;@media print{max-height:none !important;}"], $2.mixins.reset("block"));
      var ee = M().div.withConfig({
        displayName: "TableStyles__StyledTableContainer",
        componentId: "sc-1cmfss7-1"
      })(["overflow:auto;", " &::before{content:'';width:100%;height:0;top:0;position:absolute;}"], (function(e2) {
        var n2 = e2.$dragging;
        return n2 && (0, z.css)(["overflow:hidden;"]);
      }));
      var ne = M().table.withConfig({
        displayName: "TableStyles__StyledTable",
        componentId: "sc-1cmfss7-2"
      })(["", ";position:relative;border-collapse:collapse;border-spacing:0;min-width:100%;z-index:0;height:1px;&[data-fixed-column='true']{table-layout:fixed;min-width:0;width:0;}", " @media print{width:100%;max-width:100%;table-layout:auto;}"], $2.mixins.reset("table"), (function(e2) {
        var n2 = e2.$resizableFillLayout;
        return n2 && (0, z.css)(["width:100%;min-width:100%;table-layout:fixed;"]);
      }));
      var te = M().div.withConfig({
        displayName: "TableStyles__StyledDockedScrollbar",
        componentId: "sc-1cmfss7-3"
      })(["position:fixed;bottom:0;overflow:auto;z-index:calc(", " + 1);"], $2.variables.zindexFixedNavbar);
      var re = M().div.withConfig({
        displayName: "TableStyles__StyledDockedScrollbarContent",
        componentId: "sc-1cmfss7-4"
      })(["height:1px;"]);
      var oe = M().caption.withConfig({
        displayName: "TableStyles__StyledTableCaption",
        componentId: "sc-1cmfss7-5"
      })(["padding:", " 0;font-size:", ";caption-side:", ";"], $2.variables.spacingXSmall, $2.variables.fontSizeLarge, (function(e2) {
        var n2 = e2.side;
        return n2;
      }));
      var ie = M().table.withConfig({
        displayName: "TableStyles__StyledDragShadowTable",
        componentId: "sc-1cmfss7-6"
      })(["display:block;background:", ";border-collapse:collapse;height:", ";width:", ";"], $2.variables.interactiveColorOverlayDrag, (function(e2) {
        var n2 = e2.$height;
        return "".concat(n2, "px");
      }), (function(e2) {
        var n2 = e2.$width;
        return "".concat(n2, "px");
      }));
      var ae = M().div.withConfig({
        displayName: "TableStyles__StyledGuideLine",
        componentId: "sc-1cmfss7-7"
      })(["position:absolute;width:1px;left:", ";top:0;height:", ";pointer-events:none;background-color:", ";"], (function(e2) {
        var n2 = e2.$left;
        return "".concat(n2, "px");
      }), (function(e2) {
        var n2 = e2.$height;
        return "".concat(n2, "px");
      }), $2.variables.interactiveColorAccent);
      function le() {
        return le = Object.assign ? Object.assign.bind() : function(e2) {
          for (var n2 = 1; n2 < arguments.length; n2++) {
            var t2 = arguments[n2];
            for (var r2 in t2) {
              ({}).hasOwnProperty.call(t2, r2) && (e2[r2] = t2[r2]);
            }
          }
          return e2;
        }, le.apply(null, arguments);
      }
      function ue(e2, n2) {
        if (null == e2) return {};
        var t2, r2, o2 = se(e2, n2);
        if (Object.getOwnPropertySymbols) {
          var i2 = Object.getOwnPropertySymbols(e2);
          for (r2 = 0; r2 < i2.length; r2++) {
            t2 = i2[r2], -1 === n2.indexOf(t2) && {}.propertyIsEnumerable.call(e2, t2) && (o2[t2] = e2[t2]);
          }
        }
        return o2;
      }
      function se(e2, n2) {
        if (null == e2) return {};
        var t2 = {};
        for (var r2 in e2) {
          if ({}.hasOwnProperty.call(e2, r2)) {
            if (-1 !== n2.indexOf(r2)) continue;
            t2[r2] = e2[r2];
          }
        }
        return t2;
      }
      var ce = {
        children: C().node.isRequired,
        side: C().oneOf(["top", "bottom"])
      };
      function de(e2) {
        var n2 = e2.children, t2 = e2.side, o2 = t2 === void 0 ? "top" : t2, i2 = ue(e2, ["children", "side"]);
        return r().createElement(oe, le({
          "data-test": "caption",
          side: o2
        }, i2), n2);
      }
      de.propTypes = ce;
      de.splunkUiType = "Table.Caption";
      const fe = de;
      const ve = require_ButtonSimple();
      var pe = "2px";
      var me = (0, z.css)(["box-shadow:", ";"], $2.variables.focusShadowInset);
      var be = M().td.withConfig({
        displayName: "CellStyles__Styled",
        componentId: "sc-1955xk2-0"
      })(["", " line-height:", ";padding:", " ", ";border-left:0 solid transparent;border-right:0 solid transparent;color:", ";word-wrap:break-word;vertical-align:top;*:where(button):focus,&& *:is(:has(> input:focus)):not([disabled]){box-shadow:", ";}padding-block:", ";padding-inline:", ";", " ", " ", " [data-expansion-row='true'] > &:first-child{padding-top:8px;}[data-expansion-row='true'] > &:last-child{padding-bottom:14px;}"], $2.mixins.reset("table-cell"), $2.variables.lineHeightSpacious, pe, $2.variables.spacingSmall, $2.variables.contentColorDefault, $2.variables.focusShadowInset, (0, $2.pick)({
        comfortable: "8px",
        compact: "6px"
      }), $2.variables.spacingSmall, (0, $2.pickVariant)("$variant", {
        expand: (0, z.css)(["height:100%;padding:0;"]),
        toggle: (0, z.css)(["height:100%;padding:0;"])
      }), (function(e2) {
        var n2 = e2.$variant, t2 = e2.$isPrimaryCell;
        return (0, $2.pickVariant)("$appearance", {
          data: (0, z.css)(["", ""], n2 === "actions" && (0, z.css)(["cursor:default;padding-block:", ";padding-inline:", ";*:where(button){", " &:focus{box-shadow:", ";}}"], pe, $2.variables.spacingSmall, (0, ve.buttonMixin)("subtle", {
            color: $2.variables.contentColorDefault
          }), $2.variables.focusShadowInset)),
          rowLink: (0, z.css)(["color:", ";*:hover > &&{cursor:pointer;", "}"], $2.variables.contentColorActive, t2 && (0, z.css)(["text-decoration:underline;"])),
          link: (0, z.css)(["color:", ";&:hover{cursor:pointer;text-decoration:underline;}&:focus{text-decoration:underline;box-shadow:", ";}"], $2.variables.contentColorLink, $2.variables.focusShadowInset)
        });
      }), (function(e2) {
        var n2 = e2.$clickable, t2 = e2.$focusWithin, r2 = e2.$stripe;
        return n2 && (0, z.css)(["cursor:pointer;&:hover{background-color:", ";}&:focus{", " background-color:", ";}", ""], r2 === "even" ? $2.variables.neutral300 : $2.variables.neutral100, me, r2 === "even" ? $2.variables.neutral300 : $2.variables.neutral100, t2 && (0, z.css)(["&:focus-within{", " background-color:", ";}"], me, r2 === "even" ? $2.variables.neutral300 : $2.variables.neutral100));
      }));
      var he = M().div.withConfig({
        displayName: "CellStyles__StyledCellContent",
        componentId: "sc-1955xk2-1"
      })(["display:flex;align-items:flex-start;word-break:break-word;", " ", ""], (0, $2.pickVariant)("$variant", {
        expand: (0, z.css)(["height:100%;"]),
        toggle: (0, z.css)(["height:100%;"])
      }), (function(e2) {
        var n2 = e2.$variant, t2 = e2.$align;
        return n2 ? (0, z.css)(["display:block;text-align:", ";"], t2) : (0, z.css)(["justify-content:", ";text-align:", ";"], t2, t2);
      }));
      function ye() {
        return ye = Object.assign ? Object.assign.bind() : function(e2) {
          for (var n2 = 1; n2 < arguments.length; n2++) {
            var t2 = arguments[n2];
            for (var r2 in t2) {
              ({}).hasOwnProperty.call(t2, r2) && (e2[r2] = t2[r2]);
            }
          }
          return e2;
        }, ye.apply(null, arguments);
      }
      function ge(e2, n2) {
        if (null == e2) return {};
        var t2, r2, o2 = we(e2, n2);
        if (Object.getOwnPropertySymbols) {
          var i2 = Object.getOwnPropertySymbols(e2);
          for (r2 = 0; r2 < i2.length; r2++) {
            t2 = i2[r2], -1 === n2.indexOf(t2) && {}.propertyIsEnumerable.call(e2, t2) && (o2[t2] = e2[t2]);
          }
        }
        return o2;
      }
      function we(e2, n2) {
        if (null == e2) return {};
        var t2 = {};
        for (var r2 in e2) {
          if ({}.hasOwnProperty.call(e2, r2)) {
            if (-1 !== n2.indexOf(r2)) continue;
            t2[r2] = e2[r2];
          }
        }
        return t2;
      }
      var Ce = {
        align: C().oneOf(["left", "center", "right"]),
        /** @private */
        appearance: C().oneOf(["data", "link", "rowLink"]),
        /** @private Used to set the $clickable appearance without an onClick */
        appearClickable: C().bool,
        children: C().node,
        data: C().any,
        elementRef: C().oneOfType([C().func, C().object]),
        /** @private */
        isPrimaryCell: C().bool,
        onClick: C().func,
        /** @private */
        onKeyDown: C().func,
        /** @private */
        disabled: C().bool,
        /** @private. */
        expand: C().bool,
        /** @private. */
        stripe: C().oneOf(["odd", "even", "none"]),
        /** @private. */
        variant: C().oneOf(["toggle", "expand", "drag", "actions"])
      };
      function xe(e2) {
        var n2 = e2.align, o2 = n2 === void 0 ? "left" : n2, i2 = e2.appearance, a2 = e2.appearClickable, l2 = e2.children, u2 = e2.data, s2 = e2.disabled, c2 = e2.elementRef, d2 = e2.isPrimaryCell, f2 = e2.onClick, v2 = e2.onKeyDown, p2 = e2.stripe, m2 = e2.variant, b2 = ge(e2, ["align", "appearance", "appearClickable", "children", "data", "disabled", "elementRef", "isPrimaryCell", "onClick", "onKeyDown", "stripe", "variant"]);
        var h2 = f2 !== void 0;
        var y2 = a2 || h2;
        var g2 = y2 ? "link" : "data";
        var w2 = (0, t.useCallback)((function(e3) {
          L(c2, e3);
        }), [c2]);
        var C2 = (0, t.useCallback)((function(e3) {
          if (m2 === "actions") {
            e3.stopPropagation();
          }
          f2 === null || f2 === void 0 ? void 0 : f2(e3, u2);
        }), [u2, f2, m2]);
        var x2 = (0, t.useCallback)((function(e3) {
          if (e3.key === "Enter") {
            f2 === null || f2 === void 0 ? void 0 : f2(e3, u2);
          }
          v2 === null || v2 === void 0 ? void 0 : v2(e3);
        }), [u2, f2, v2]);
        return r().createElement(be, ye({
          "data-test": "cell",
          $appearance: i2 || g2,
          $clickable: y2 ? true : void 0,
          $disabled: !!s2,
          $focusWithin: a2,
          $isPrimaryCell: d2,
          $stripe: p2,
          $variant: m2,
          onClick: C2,
          onKeyDown: x2,
          ref: w2,
          tabIndex: h2 ? 0 : void 0
        }, b2), r().createElement(he, {
          $align: o2,
          $variant: m2
        }, l2));
      }
      xe.propTypes = Ce;
      xe.splunkUiType = "Table.Cell";
      const Se = xe;
      const Oe = require_isString();
      var ke = e.n(Oe);
      const Re = require_merge();
      var Ee = e.n(Re);
      const Ie = require_ParallelDots();
      var Te = e.n(Ie);
      const je = require_Tooltip();
      var De = e.n(je);
      const qe = require_Divider();
      var Ae = e.n(qe);
      var Pe = 4;
      var _e = Pe;
      var ze = (0, z.css)(["display:inline-flex;align-items:center;grid-row:1;height:1lh;"]);
      var Me = M().span.withConfig({
        displayName: "HeadInnerStyles__StyledIcon",
        componentId: "sc-1sa0wng-0"
      })(["", " grid-column:icon;"], ze);
      var $e = M().span.withConfig({
        displayName: "HeadInnerStyles__StyledTooltipIcon",
        componentId: "sc-1sa0wng-1"
      })(["", " grid-column:tooltip;"], ze);
      var Ne = M().span.withConfig({
        displayName: "HeadInnerStyles__StyledLabel",
        componentId: "sc-1sa0wng-2"
      })(["grid-column:label;grid-row:1 / -1;position:relative;height:100%;", " ", " ", " ", ""], (function(e2) {
        var n2 = e2.$variant;
        return n2 === "toggleAll" && (0, z.css)(["grid-column:1 / -1;"]);
      }), (function(e2) {
        var n2 = e2.$labelLength;
        return n2 && n2 > _e && (0, z.css)(["word-wrap:break-word;word-break:break-word;"]);
      }), (function(e2) {
        var n2 = e2.$truncate, t2 = e2.$labelLength;
        return n2 && t2 && t2 > Pe && (0, z.css)(["", " min-width:4ch;"], $2.mixins.ellipsis());
      }), (0, $2.pickVariant)("$align", {
        right: (0, z.css)(["& > &{text-align:right;}"]),
        left: (0, z.css)(["& > &{text-align:left;}"]),
        center: (0, z.css)(["& > &{text-align:center;}"])
      }));
      var Le = (0, z.css)(["box-shadow:", ";outline:none;color:", ";text-decoration:underline;"], $2.variables.focusShadowInset, $2.variables.contentColorActive);
      var We = M().div.withConfig({
        displayName: "HeadInnerStyles__Styled",
        componentId: "sc-1sa0wng-3"
      })(["", ";", ";", ";position:relative;", " grid-template-rows:1lh auto;align-items:start;flex-grow:1;height:100%;padding-block:", ";padding-inline:", ";justify-content:", ";", " ", " @media print{background-image:none;}", ""], $2.mixins.reset("grid"), $2.mixins.clearfix(), $2.mixins.typography("body", {
        weight: "bold"
      }), (function(e2) {
        var n2 = e2.$hasTooltip, t2 = e2.$hasIcon;
        return (0, z.css)(["grid-template-columns:[label] auto ", " ", ";column-gap:", ";"], n2 ? "[tooltip] min-content" : "", t2 ? "[icon] min-content" : "", n2 || t2 ? $2.variables.spacingXSmall : 0);
      }), (0, $2.pick)({
        comfortable: "8px",
        compact: "6px"
      }), $2.variables.spacingSmall, (0, $2.pickVariant)("$align", {
        center: "center",
        left: "flex-start",
        right: "flex-end"
      }), (function(e2) {
        var n2 = e2.$variant;
        return n2 && (0, z.css)(["grid-template-columns:1fr;grid-template-rows:1fr;"]);
      }), (0, $2.pickVariant)("$variant", {
        toggleAll: (0, z.css)(["padding:0;"]),
        actions: (0, z.css)(["padding-block:2px;"])
      }), (function(e2) {
        var n2 = e2.$clickable, t2 = e2.$focusWithin;
        return n2 && (0, z.css)(["cursor:pointer;&:focus{", "}", " &:hover{outline:none;text-decoration:underline;color:", ";}"], Le, t2 && (0, z.css)(["&:focus-within{", "}"], Le), $2.variables.contentColorActive);
      }));
      var He = M()(Ae()).withConfig({
        displayName: "HeadInnerStyles__StyledResize",
        componentId: "sc-1sa0wng-4"
      })(
        ["", ";position:absolute;right:-5px;width:9px;top:0;bottom:0;z-index:1;cursor:col-resize;th:last-child > div > ", " > &{right:1px;width:4px;}&:hover{outline:none;&::before{content:'';background:", ";position:absolute;left:4px;width:1px;top:0;bottom:0;}}&:focus{outline:none;&::before{content:'';position:absolute;background:", ";box-shadow:", ";left:4px;width:1px;top:0;bottom:0;}}"],
        $2.mixins.reset("block"),
        /* sc-sel */
        We,
        $2.variables.borderColorStrong,
        $2.variables.focusColor,
        $2.variables.focusShadow
      );
      var Ke = M().div.withConfig({
        displayName: "HeadCellStyles__StyledInnerWrapper",
        componentId: "sc-1hj81sa-0"
      })(["display:flex;height:100%;align-items:flex-start;"]);
      var Be = M().th.withConfig({
        displayName: "HeadCellStyles__Styled",
        componentId: "sc-1hj81sa-1"
      })(
        ["", " line-height:", ";background-color:", ";box-sizing:content-box;text-align:left;vertical-align:", ";position:relative;height:100%;&:not(:first-child,:has(", ")){", "{border-left:1px solid ", ";}}&:has(", "){", "{border-right:1px solid ", ";}}&:nth-last-child(2):has(", ") + &:last-child{", "{border-left:none;}}*:where(button):focus{box-shadow:", ";}", " ", " ", ""],
        $2.mixins.reset("table-cell"),
        $2.variables.lineHeightSpacious,
        $2.variables.neutral100,
        (function(e2) {
          var n2 = e2.$variant;
          return n2 ? "middle" : "top";
        }),
        He,
        /* sc-sel */
        Ke,
        $2.variables.borderColorWeak,
        He,
        /* sc-sel */
        Ke,
        $2.variables.borderColor,
        He,
        /* sc-sel */
        Ke,
        $2.variables.focusShadowInset,
        (function(e2) {
          var n2 = e2.$isDragging;
          return n2 && (0, z.css)(["background-color:", ";&:focus{box-shadow:none;}"], $2.variables.backgroundColorPage);
        }),
        (function(e2) {
          var n2 = e2.$variant;
          return n2 && (0, z.css)(["&:first-child + &{", "{border-left:1px solid ", ";}}"], Ke, $2.variables.borderColorWeak);
        }),
        (0, $2.pickVariant)("$variant", {
          actions: (0, z.css)(["*:where(button){", " &:focus{box-shadow:", ";}}"], (0, ve.buttonMixin)("subtle", {
            color: $2.variables.contentColorDefault
          }), $2.variables.focusShadowInset)
        })
      );
      var Ve = M().div.withConfig({
        displayName: "HeadCellStyles__StyledIcon",
        componentId: "sc-1hj81sa-2"
      })(["display:inline-flex;align-items:center;height:1lh;"]);
      var Fe = M().div.withConfig({
        displayName: "HeadCellStyles__StyledDragHandler",
        componentId: "sc-1hj81sa-3"
      })(["display:inline-flex;align-items:start;align-self:stretch;justify-content:center;min-width:20px;cursor:move;padding-block:", ";-webkit-user-select:none;-moz-user-select:none;user-select:none;&:hover{background:", ";color:", ";}&:focus{background:", ";box-shadow:", ";color:", ";}"], (0, $2.pick)({
        comfortable: "8px",
        compact: "6px"
      }), $2.variables.interactiveColorOverlayHover, $2.variables.contentColorActive, $2.variables.interactiveColorOverlayDrag, $2.variables.focusShadowInset, $2.variables.contentColorActive);
      const Ue = require_ArrowDown();
      var Xe = e.n(Ue);
      const Ye = require_ArrowUp();
      var Ge = e.n(Ye);
      const Je = require_ArrowUpDown();
      var Qe = e.n(Je);
      const Ze = require_CaretSmallDown();
      var en = e.n(Ze);
      const nn = require_InformationCircle();
      var tn = e.n(nn);
      var rn = {
        body: {
          appendChild: function e2() {
            return [];
          }
        },
        addEventListener: function e2() {
        },
        removeEventListener: function e2() {
        },
        activeElement: {
          blur: function e2() {
          },
          nodeName: ""
        },
        querySelector: function e2() {
          return null;
        },
        querySelectorAll: function e2() {
          return [];
        },
        getElementById: function e2() {
          return null;
        },
        createEvent: function e2() {
          return {
            initEvent: function e3() {
            }
          };
        },
        createElement: function e2() {
          return {
            children: [],
            childNodes: [],
            style: {},
            setAttribute: function e3() {
            },
            getElementsByTagName: function e3() {
              return [];
            }
          };
        },
        createElementNS: function e2() {
          return {};
        },
        importNode: function e2() {
          return null;
        },
        location: {
          hash: "",
          host: "",
          hostname: "",
          href: "",
          origin: "",
          pathname: "",
          protocol: "",
          search: ""
        }
      };
      function on() {
        var e2 = typeof document !== "undefined" ? document : rn;
        return e2;
      }
      var an = on();
      const ln = (
        /* unused pure expression or super */
        null
      );
      var un = {
        document: rn,
        navigator: {
          userAgent: ""
        },
        location: {
          hash: "",
          host: "",
          hostname: "",
          href: "",
          origin: "",
          pathname: "",
          protocol: "",
          search: ""
        },
        history: {
          replaceState: function e2() {
          },
          pushState: function e2() {
          },
          go: function e2() {
          },
          back: function e2() {
          }
        },
        CustomEvent: function e2() {
          return this;
        },
        addEventListener: function e2() {
        },
        removeEventListener: function e2() {
        },
        getComputedStyle: function e2() {
          return {
            getPropertyValue: function e3() {
              return "";
            }
          };
        },
        Image: function e2() {
        },
        Date: function e2() {
        },
        screen: {},
        setTimeout: function e2() {
        },
        clearTimeout: function e2() {
        },
        matchMedia: function e2() {
          return {};
        },
        requestAnimationFrame: function e2(n2) {
          if (typeof setTimeout === "undefined") {
            n2();
            return null;
          }
          return setTimeout(n2, 0);
        },
        cancelAnimationFrame: function e2(n2) {
          if (typeof setTimeout === "undefined") {
            return;
          }
          clearTimeout(n2);
        }
      };
      function sn() {
        var e2 = typeof window !== "undefined" ? window : un;
        return e2;
      }
      var cn = sn();
      const dn = (
        /* unused pure expression or super */
        null
      );
      function fn() {
        return fn = Object.assign ? Object.assign.bind() : function(e2) {
          for (var n2 = 1; n2 < arguments.length; n2++) {
            var t2 = arguments[n2];
            for (var r2 in t2) {
              ({}).hasOwnProperty.call(t2, r2) && (e2[r2] = t2[r2]);
            }
          }
          return e2;
        }, fn.apply(null, arguments);
      }
      function vn(e2) {
        return bn(e2) || mn(e2) || gn(e2) || pn();
      }
      function pn() {
        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      function mn(e2) {
        if ("undefined" != typeof Symbol && null != e2[Symbol.iterator] || null != e2["@@iterator"]) return Array.from(e2);
      }
      function bn(e2) {
        if (Array.isArray(e2)) return wn(e2);
      }
      function hn(e2, n2) {
        return xn(e2) || Cn(e2, n2) || gn(e2, n2) || yn();
      }
      function yn() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      function gn(e2, n2) {
        if (e2) {
          if ("string" == typeof e2) return wn(e2, n2);
          var t2 = {}.toString.call(e2).slice(8, -1);
          return "Object" === t2 && e2.constructor && (t2 = e2.constructor.name), "Map" === t2 || "Set" === t2 ? Array.from(e2) : "Arguments" === t2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t2) ? wn(e2, n2) : void 0;
        }
      }
      function wn(e2, n2) {
        (null == n2 || n2 > e2.length) && (n2 = e2.length);
        for (var t2 = 0, r2 = Array(n2); t2 < n2; t2++) {
          r2[t2] = e2[t2];
        }
        return r2;
      }
      function Cn(e2, n2) {
        var t2 = null == e2 ? null : "undefined" != typeof Symbol && e2[Symbol.iterator] || e2["@@iterator"];
        if (null != t2) {
          var r2, o2, i2, a2, l2 = [], u2 = true, s2 = false;
          try {
            if (i2 = (t2 = t2.call(e2)).next, 0 === n2) {
              if (Object(t2) !== t2) return;
              u2 = false;
            } else for (; !(u2 = (r2 = i2.call(t2)).done) && (l2.push(r2.value), l2.length !== n2); u2 = true) {
            }
          } catch (e3) {
            s2 = true, o2 = e3;
          } finally {
            try {
              if (!u2 && null != t2["return"] && (a2 = t2["return"](), Object(a2) !== a2)) return;
            } finally {
              if (s2) throw o2;
            }
          }
          return l2;
        }
      }
      function xn(e2) {
        if (Array.isArray(e2)) return e2;
      }
      function Sn(e2, n2) {
        if (null == e2) return {};
        var t2, r2, o2 = On(e2, n2);
        if (Object.getOwnPropertySymbols) {
          var i2 = Object.getOwnPropertySymbols(e2);
          for (r2 = 0; r2 < i2.length; r2++) {
            t2 = i2[r2], -1 === n2.indexOf(t2) && {}.propertyIsEnumerable.call(e2, t2) && (o2[t2] = e2[t2]);
          }
        }
        return o2;
      }
      function On(e2, n2) {
        if (null == e2) return {};
        var t2 = {};
        for (var r2 in e2) {
          if ({}.hasOwnProperty.call(e2, r2)) {
            if (-1 !== n2.indexOf(r2)) continue;
            t2[r2] = e2[r2];
          }
        }
        return t2;
      }
      var kn = {
        align: C().oneOf(["left", "center", "right"]),
        cellId: C().string,
        clickable: C().bool,
        columnId: C().string,
        elementRef: C().oneOfType([C().func, C().object]),
        focusWithin: C().bool,
        hasTooltip: C().bool,
        index: C().number,
        isMenu: C().bool,
        label: C().node,
        onAutosizeColumn: C().func,
        onRequestResize: C().func,
        resizable: C().bool,
        sortDir: C().oneOf(["none", "asc", "desc"]),
        truncate: C().bool,
        width: C().oneOfType([C().number, C().oneOf(["auto"])]),
        variant: C().oneOf(["toggleAll", "info", "actions"])
      };
      var Rn = /* @__PURE__ */ new Set(["none", "asc", "desc"]);
      var En = Object.freeze({
        none: (0, j._)("Click to sort"),
        asc: (0, j._)("Press to sort descending"),
        desc: (0, j._)("Press to sort ascending")
      });
      var In = Object.freeze({
        none: Qe(),
        asc: Ge(),
        desc: Xe()
      });
      function Tn(e2) {
        var n2 = e2.align, o2 = n2 === void 0 ? "left" : n2, i2 = e2.clickable, a2 = e2.cellId, l2 = e2.columnId, u2 = e2.elementRef, s2 = e2.focusWithin, c2 = e2.hasTooltip, d2 = e2.index, f2 = e2.isMenu, v2 = e2.label, p2 = e2.onAutosizeColumn, m2 = e2.onRequestResize, b2 = e2.resizable, y2 = b2 === void 0 ? true : b2, g2 = e2.sortDir, w2 = e2.truncate, C2 = w2 === void 0 ? true : w2, x2 = e2.variant, O2 = e2.width, k2 = Sn(e2, ["align", "clickable", "cellId", "columnId", "elementRef", "focusWithin", "hasTooltip", "index", "isMenu", "label", "onAutosizeColumn", "onRequestResize", "resizable", "sortDir", "truncate", "variant", "width"]);
        var R2 = (0, j._)("Click to open menu");
        var E2 = (0, t.useMemo)((function() {
          return typeof v2 === "string" ? v2.length : 0;
        }), [v2]);
        var I2 = (0, t.useState)(false), D2 = hn(I2, 2), q2 = D2[0], A2 = D2[1];
        var P2 = (0, t.useState)(0), _2 = hn(P2, 2), z2 = _2[0], M2 = _2[1];
        var $3 = (0, t.useState)(0), N2 = hn($3, 2), W2 = N2[0], H2 = N2[1];
        var K2 = (0, t.useRef)(null);
        var B2 = (0, t.useRef)(O2 === "auto" ? void 0 : O2);
        var V2;
        var F2;
        if (g2 !== void 0 && Rn.has(g2)) {
          V2 = In[g2];
          F2 = En[g2];
        }
        if (O2 === "auto") {
          var U2;
          var X2 = K2.current;
          var Y2 = X2 === null || X2 === void 0 ? void 0 : (U2 = X2.parentElement) === null || U2 === void 0 ? void 0 : U2.getBoundingClientRect();
          B2.current = Y2 === null || Y2 === void 0 ? void 0 : Y2.width;
        } else {
          B2.current = O2;
        }
        var G2 = (0, t.useCallback)((function(e3) {
          K2.current = e3;
          L(u2, e3);
        }), [u2, K2]);
        var J2 = (0, t.useCallback)((function(e3) {
          var n3 = e3.key;
          if (m2 === void 0 || d2 === void 0) {
            return;
          }
          if (O2 === "auto") {
            var t2;
            var r2 = K2.current;
            var o3 = r2 === null || r2 === void 0 ? void 0 : (t2 = r2.parentElement) === null || t2 === void 0 ? void 0 : t2.getBoundingClientRect();
            B2.current = o3 === null || o3 === void 0 ? void 0 : o3.width;
          } else {
            B2.current = O2;
          }
          if (B2.current === void 0) {
            return;
          }
          if (n3 === "ArrowLeft") {
            e3.preventDefault();
            var i3 = Math.max(B2.current - 10, 20);
            m2(e3, {
              index: d2,
              columnId: l2,
              id: a2,
              width: i3
            });
          }
          if (n3 === "ArrowRight") {
            e3.preventDefault();
            var u3 = B2.current + 10;
            m2(e3, {
              index: d2,
              columnId: l2,
              id: a2,
              width: u3
            });
          }
          if (n3 === "Enter") {
            e3.preventDefault();
          }
        }), [l2, a2, d2, m2, O2]);
        var Q2 = (0, t.useCallback)((function(e3) {
          if (O2 === "auto") {
            var n3;
            var t2 = K2.current;
            var r2 = t2 === null || t2 === void 0 ? void 0 : (n3 = t2.parentElement) === null || n3 === void 0 ? void 0 : n3.getBoundingClientRect();
            B2.current = r2 === null || r2 === void 0 ? void 0 : r2.width;
          } else {
            B2.current = O2;
          }
          if (B2.current === void 0) {
            return;
          }
          e3.preventDefault();
          M2(e3.clientX);
          H2(B2.current || 0);
          A2(true);
        }), [O2]);
        var Z2 = function e3(n3) {
          var t2 = z2 - n3.clientX;
          var r2 = Math.max(W2 - t2, 16);
          if (d2 !== void 0) {
            m2 === null || m2 === void 0 ? void 0 : m2(n3, {
              index: d2,
              columnId: l2,
              id: a2,
              width: r2
            });
          }
        };
        var ee2 = function e3() {
          A2(false);
        };
        var ne2 = (0, t.useCallback)((function(e3) {
          if (d2 !== void 0) {
            p2 === null || p2 === void 0 ? void 0 : p2(e3, {
              index: d2,
              columnId: l2,
              id: a2
            });
          }
        }), [a2, l2, d2, p2]);
        var te2 = sn();
        var re2 = B2.current ? (0, T.sprintf)((0, j._)("%(width)d pixels"), {
          width: B2.current
        }) : void 0;
        return r().createElement(We, fn({
          as: i2 ? "button" : "div",
          ref: G2,
          $align: o2,
          $clickable: i2,
          $focusWithin: s2,
          $hasIcon: !!f2 || !!g2,
          $hasTooltip: !!c2,
          $variant: x2,
          $labelLength: E2
        }, h()(k2, [].concat(vn(Object.keys(Tn.propTypes)), ["id"]))), q2 && r().createElement(r().Fragment, null, r().createElement(S(), {
          target: te2,
          eventType: "mouseup",
          listener: ee2
        }), r().createElement(S(), {
          target: te2,
          eventType: "mousemove",
          listener: Z2
        })), m2 && y2 && r().createElement(He, {
          "aria-label": (0, T.sprintf)((0, j._)("Resize %(label)s"), {
            label: v2
          }),
          "aria-controls": a2,
          "aria-valuetext": re2,
          "data-test": "resize",
          onMouseDown: Q2,
          onDoubleClick: ne2,
          onKeyDown: J2,
          orientation: "vertical",
          tabIndex: 0
        }), r().createElement(Ne, {
          $align: o2,
          $truncate: C2,
          $variant: x2,
          $labelLength: E2
        }, v2), c2 && r().createElement($e, null, r().createElement(tn(), {
          "data-test": "tooltip-icon"
        })), f2 && r().createElement(Me, null, r().createElement(en(), {
          "data-test": "caret-down",
          "aria-label": R2
        })), g2 && r().createElement(Me, null, V2 !== void 0 && r().createElement(V2, {
          "aria-hidden": false,
          "aria-label": F2
        })));
      }
      Tn.propTypes = kn;
      const jn = Tn;
      function Dn() {
        return Dn = Object.assign ? Object.assign.bind() : function(e2) {
          for (var n2 = 1; n2 < arguments.length; n2++) {
            var t2 = arguments[n2];
            for (var r2 in t2) {
              ({}).hasOwnProperty.call(t2, r2) && (e2[r2] = t2[r2]);
            }
          }
          return e2;
        }, Dn.apply(null, arguments);
      }
      function qn(e2, n2) {
        if (null == e2) return {};
        var t2, r2, o2 = An(e2, n2);
        if (Object.getOwnPropertySymbols) {
          var i2 = Object.getOwnPropertySymbols(e2);
          for (r2 = 0; r2 < i2.length; r2++) {
            t2 = i2[r2], -1 === n2.indexOf(t2) && {}.propertyIsEnumerable.call(e2, t2) && (o2[t2] = e2[t2]);
          }
        }
        return o2;
      }
      function An(e2, n2) {
        if (null == e2) return {};
        var t2 = {};
        for (var r2 in e2) {
          if ({}.hasOwnProperty.call(e2, r2)) {
            if (-1 !== n2.indexOf(r2)) continue;
            t2[r2] = e2[r2];
          }
        }
        return t2;
      }
      var Pn = {
        align: C().oneOf(["left", "center", "right"]),
        /** @private Used to set the $clickable appearance without an onClick */
        appearClickable: C().bool,
        children: C().node,
        columnId: C().string,
        /** @private. */
        dragId: C().oneOfType([C().string, C().number]),
        elementRef: C().oneOfType([C().func, C().object]),
        headCellScreenReaderText: C().string,
        /** @private The index of the cell, skipping the info column. */
        index: C().number,
        /** @private. */
        onAutosizeColumn: C().func,
        /** @private. */
        onClick: C().func,
        /**
        * @private. Passed through and works as expected.
        */
        onKeyDown: C().func,
        /** @private. */
        onRequestMoveColumn: C().func,
        /** @private. */
        onRequestResize: C().func,
        onSort: C().func,
        resizable: C().bool,
        sortDir: C().oneOf(["asc", "desc", "none"]),
        sortKey: C().string,
        tooltip: C().node,
        truncate: C().bool,
        /** @private. */
        variant: C().oneOf(["toggleAll", "info", "actions"]),
        /**
        * Used internally to suppress focus and id when this `HeadCell` is superseded by one in an
        * overlaid `HeadTable` for user interactions.
        * @private
        */
        visible: C().bool,
        width: C().oneOfType([C().number, C().oneOf(["auto"])])
      };
      var _n = {
        asc: "ascending",
        desc: "descending",
        none: "none"
      };
      function zn(e2) {
        var n2;
        var o2 = e2.align, i2 = o2 === void 0 ? "left" : o2, l2 = e2.appearClickable, u2 = e2.children, s2 = e2.columnId, c2 = e2.elementRef, d2 = e2.dragId, f2 = e2.headCellScreenReaderText, v2 = e2.id, p2 = e2.index, m2 = e2.onAutosizeColumn, b2 = e2.onClick, h2 = e2.onKeyDown, y2 = e2.onRequestMoveColumn, g2 = e2.onRequestResize, w2 = e2.onSort, C2 = e2.resizable, x2 = C2 === void 0 ? true : C2, S2 = e2.sortDir, O2 = S2 === void 0 ? "none" : S2, k2 = e2.sortKey, R2 = e2.style, E2 = e2.tooltip, I2 = e2.truncate, q2 = I2 === void 0 ? true : I2, A2 = e2.variant, P2 = e2.visible, _2 = P2 === void 0 ? true : P2, z2 = e2.width, M2 = qn(e2, ["align", "appearClickable", "children", "columnId", "elementRef", "dragId", "headCellScreenReaderText", "id", "index", "onAutosizeColumn", "onClick", "onKeyDown", "onRequestMoveColumn", "onRequestResize", "onSort", "resizable", "sortDir", "sortKey", "style", "tooltip", "truncate", "variant", "visible", "width"]);
        var $3 = !!y2;
        var N2 = (0, a.useSortable)({
          // dragId is optional in HeadCell but required by useSortable
          // since it is always set in Table, use a type assertion here to avoid TypeScript error
          id: d2
        }), W2 = N2.attributes, H2 = N2.isDragging, K2 = N2.listeners, B2 = N2.setNodeRef;
        var V2 = (0, t.useCallback)((function(e3) {
          L(c2, e3);
          if ($3) {
            B2(e3);
          }
        }), [$3, c2, B2]);
        var F2 = (0, t.useCallback)((function(e3) {
          if (e3.target.getAttribute("data-test") !== "resize" && w2 && p2 !== void 0) {
            w2(e3, {
              sortKey: k2,
              sortDir: O2,
              id: v2,
              columnId: s2,
              index: p2
            });
          }
          b2 === null || b2 === void 0 ? void 0 : b2();
        }), [s2, v2, p2, b2, w2, O2, k2]);
        var U2 = (0, t.useCallback)((function(e3) {
          if (p2 !== void 0) {
            h2 === null || h2 === void 0 ? void 0 : h2(e3, {
              index: p2,
              columnId: s2
            });
          }
        }), [s2, p2, h2]);
        var X2 = !!w2 && !!O2;
        var Y2 = b2 !== void 0;
        var G2 = A2 === "actions" ? false : q2;
        var J2 = (0, t.useMemo)((function() {
          return Ee()({}, R2, {
            width: z2
          });
        }), [R2, z2]);
        var Q2;
        if (f2) {
          Q2 = f2;
        } else if (ke()(u2)) {
          Q2 = u2;
        }
        var Z2 = (n2 = v2 !== null && v2 !== void 0 ? v2 : s2) !== null && n2 !== void 0 ? n2 : (0, D.createDOMID)("headCellId-");
        var ee2 = (0, t.useMemo)((function() {
          return {
            align: i2,
            clickable: l2 || X2 || Y2,
            columnId: s2,
            focusWithin: l2,
            label: u2,
            cellId: Z2,
            index: p2,
            onAutosizeColumn: m2,
            onClick: w2 || Y2 ? F2 : void 0,
            onKeyDown: w2 || Y2 ? U2 : void 0,
            onRequestResize: g2,
            resizable: _2 && x2,
            sortDir: w2 && O2,
            truncate: G2,
            variant: A2,
            width: z2
          };
        }), [i2, l2, X2, Y2, s2, u2, Z2, p2, m2, w2, F2, U2, g2, _2, x2, O2, G2, A2, z2]);
        var ne2 = (0, t.useCallback)((function(e3) {
          return r().createElement(jn, Dn({}, e3, ee2, {
            hasTooltip: true
          }));
        }), [ee2]);
        return r().createElement(Be, Dn({
          style: J2,
          ref: V2,
          "aria-sort": w2 && (_n[O2] || "none"),
          "data-test": "head-cell",
          "data-test-label": ke()(u2) ? u2 : void 0,
          "data-test-sort-dir": w2 && O2,
          id: _2 ? Z2 : void 0,
          $isDragging: $3 && H2,
          $variant: A2
        }, M2), r().createElement(Ke, null, $3 && r().createElement(Fe, Dn({
          "aria-label": (0, T.sprintf)((0, j._)("Reorder %(labelString)s"), {
            labelString: Q2
          }),
          "data-test": "drag",
          draggable: true
        }, W2, K2), r().createElement(Ve, null, r().createElement(Te(), null))), E2 ? r().createElement(De(), {
          content: E2,
          renderAnchor: ne2
        }) : r().createElement(jn, ee2)));
      }
      zn.propTypes = Pn;
      zn.splunkUiType = "Table.HeadCell";
      const Mn = zn;
      var $n = M().thead.withConfig({
        displayName: "HeadStyles__Styled",
        componentId: "iap21t-0"
      })(["", ";", ""], $2.mixins.reset("table-header-group"), (function(e2) {
        var n2 = e2.$isFixed, t2 = e2.$zIndex;
        return n2 && (0, z.css)(["position:sticky;top:0;z-index:", ";"], t2);
      }));
      var Nn = M()(Mn).withConfig({
        displayName: "HeadStyles__StyledToggleAll",
        componentId: "iap21t-1"
      })(["width:32px;"]);
      var Ln = M()(Mn).withConfig({
        displayName: "HeadStyles__StyledInfo",
        componentId: "iap21t-2"
      })(["width:32px;"]);
      var Wn = M()(Mn).withConfig({
        displayName: "HeadStyles__StyledDragRow",
        componentId: "iap21t-3"
      })(["width:32px;"]);
      const Hn = (init_utilities_esm(), __toCommonJS(utilities_esm_exports));
      const Kn = require_DotsThreeVertical();
      var Bn = e.n(Kn);
      const Vn = require_Button();
      var Fn = e.n(Vn);
      const Un = require_Dropdown();
      var Xn = e.n(Un);
      const Yn = require_ChevronRight();
      var Gn = e.n(Yn);
      var Jn = M().button.withConfig({
        displayName: "ExpandButtonStyles__StyledButton",
        componentId: "sc-7nlw5q-0"
      })(["", ";height:100%;width:100%;cursor:pointer;justify-content:center;color:", ";&:hover{color:", ";}&:focus{color:", ";box-shadow:", ";}"], $2.mixins.reset("flex"), $2.variables.contentColorDefault, $2.variables.contentColorActive, $2.variables.contentColorActive, $2.variables.focusShadowInset);
      var Qn = M()(Gn()).withConfig({
        displayName: "ExpandButtonStyles__StyledChevron",
        componentId: "sc-7nlw5q-1"
      })(["padding-block:", ";transition:transform 200ms;", ""], (0, $2.pick)({
        comfortable: "10px",
        compact: "8px"
      }), (function(e2) {
        var n2 = e2.$expanded;
        return n2 && (0, z.css)(["transform:rotate(90deg);"]);
      }));
      function Zn() {
        return Zn = Object.assign ? Object.assign.bind() : function(e2) {
          for (var n2 = 1; n2 < arguments.length; n2++) {
            var t2 = arguments[n2];
            for (var r2 in t2) {
              ({}).hasOwnProperty.call(t2, r2) && (e2[r2] = t2[r2]);
            }
          }
          return e2;
        }, Zn.apply(null, arguments);
      }
      function et(e2, n2) {
        if (null == e2) return {};
        var t2, r2, o2 = nt(e2, n2);
        if (Object.getOwnPropertySymbols) {
          var i2 = Object.getOwnPropertySymbols(e2);
          for (r2 = 0; r2 < i2.length; r2++) {
            t2 = i2[r2], -1 === n2.indexOf(t2) && {}.propertyIsEnumerable.call(e2, t2) && (o2[t2] = e2[t2]);
          }
        }
        return o2;
      }
      function nt(e2, n2) {
        if (null == e2) return {};
        var t2 = {};
        for (var r2 in e2) {
          if ({}.hasOwnProperty.call(e2, r2)) {
            if (-1 !== n2.indexOf(r2)) continue;
            t2[r2] = e2[r2];
          }
        }
        return t2;
      }
      var tt = {
        expanded: C().bool
      };
      var rt = function e2(n2) {
        var t2 = n2.expanded, o2 = et(n2, ["expanded"]);
        return r().createElement(Jn, Zn({
          title: t2 ? (0, j._)("Collapse row") : (0, j._)("Expand row")
        }, o2), r().createElement(Qn, {
          $expanded: t2
        }));
      };
      rt.propTypes = tt;
      const ot = rt;
      var it = M().td.withConfig({
        displayName: "RowDragCellStyles__StyledCell",
        componentId: "sc-9kbaj2-0"
      })(["", " cursor:move;touch-action:none;position:relative;vertical-align:middle;"], $2.mixins.reset("table-cell"));
      var at = M().div.withConfig({
        displayName: "RowDragCellStyles__StyledDrag",
        componentId: "sc-9kbaj2-1"
      })(["", " ", ";justify-content:center;cursor:move;-webkit-user-drag:element;user-select:none;align-items:center;position:absolute;width:100%;top:0;bottom:0;&:focus{outline:0;box-shadow:", ";}&:hover{background-color:", ";outline:none;}&:active{background-color:", ";box-shadow:", ";}& > div{margin:0;}@media print{background-image:none;}"], $2.mixins.reset("flex"), $2.mixins.clearfix(), $2.variables.focusShadowInset, $2.variables.interactiveColorOverlayDrag, $2.variables.interactiveColorOverlayActive, $2.variables.focusShadowInset);
      function lt() {
        return lt = Object.assign ? Object.assign.bind() : function(e2) {
          for (var n2 = 1; n2 < arguments.length; n2++) {
            var t2 = arguments[n2];
            for (var r2 in t2) {
              ({}).hasOwnProperty.call(t2, r2) && (e2[r2] = t2[r2]);
            }
          }
          return e2;
        }, lt.apply(null, arguments);
      }
      function ut(e2, n2) {
        if (null == e2) return {};
        var t2, r2, o2 = st(e2, n2);
        if (Object.getOwnPropertySymbols) {
          var i2 = Object.getOwnPropertySymbols(e2);
          for (r2 = 0; r2 < i2.length; r2++) {
            t2 = i2[r2], -1 === n2.indexOf(t2) && {}.propertyIsEnumerable.call(e2, t2) && (o2[t2] = e2[t2]);
          }
        }
        return o2;
      }
      function st(e2, n2) {
        if (null == e2) return {};
        var t2 = {};
        for (var r2 in e2) {
          if ({}.hasOwnProperty.call(e2, r2)) {
            if (-1 !== n2.indexOf(r2)) continue;
            t2[r2] = e2[r2];
          }
        }
        return t2;
      }
      var ct = {
        setActivatorNodeRef: C().func.isRequired,
        listeners: C().objectOf(C().func)
      };
      function dt(e2) {
        var n2 = e2.listeners, t2 = e2.setActivatorNodeRef, o2 = ut(e2, ["listeners", "setActivatorNodeRef"]);
        return r().createElement(it, {
          "data-helper": true
        }, r().createElement(at, lt({
          "data-test": "drag",
          draggable: true,
          ref: t2,
          tabIndex: 0
        }, n2, o2), r().createElement(Te(), null)));
      }
      dt.propTypes = ct;
      const ft = dt;
      var vt = M().tr.withConfig({
        displayName: "RowStyles__StyledStripeNone",
        componentId: "f0igqq-0"
      })(["", ";", ";", " @media print{background-color:none;}"], $2.mixins.reset("table-row"), (function(e2) {
        var n2 = e2.$clickable;
        return n2 && (0, z.css)(["cursor:pointer;&:hover{background-color:", ";}&:focus{background-color:", ";box-shadow:", ";}"], $2.variables.neutral100, $2.variables.neutral100, $2.variables.focusShadowInset);
      }), (function(e2) {
        var n2 = e2.disabled, t2 = e2.$expandable, r2 = e2.$isDraggable;
        return !n2 && !t2 && r2 && (0, z.css)(["&:hover{background-color:", ";}"], $2.variables.interactiveColorOverlayHover);
      }));
      var pt = M()(vt).withConfig({
        displayName: "RowStyles__StyledStripeEven",
        componentId: "f0igqq-1"
      })(["background-color:", ";", ";"], $2.variables.neutral50, (function(e2) {
        var n2 = e2.$clickable;
        return n2 && (0, z.css)(["cursor:pointer;&:hover,&:focus{background-color:", ";}"], $2.variables.neutral300);
      }));
      const mt = require_Clickable();
      var bt = e.n(mt);
      const ht = require_NonInteractiveCheckbox();
      var yt = e.n(ht);
      var gt = M()(bt()).withConfig({
        displayName: "ToggleStyles__StyledClickable",
        componentId: "sc-1x3ikch-0"
      })(["height:100%;width:100%;display:flex;justify-content:center;&[disabled]{cursor:not-allowed;}"]);
      var wt = M()(yt()).withConfig({
        displayName: "ToggleStyles__StyledNonInteractiveCheckbox",
        componentId: "sc-1x3ikch-1"
      })(["align-items:flex-start;padding-block:", ";"], (0, $2.pick)({
        comfortable: "8px",
        compact: "6px"
      }));
      function Ct() {
        return Ct = Object.assign ? Object.assign.bind() : function(e2) {
          for (var n2 = 1; n2 < arguments.length; n2++) {
            var t2 = arguments[n2];
            for (var r2 in t2) {
              ({}).hasOwnProperty.call(t2, r2) && (e2[r2] = t2[r2]);
            }
          }
          return e2;
        }, Ct.apply(null, arguments);
      }
      function xt(e2, n2) {
        if (null == e2) return {};
        var t2, r2, o2 = St(e2, n2);
        if (Object.getOwnPropertySymbols) {
          var i2 = Object.getOwnPropertySymbols(e2);
          for (r2 = 0; r2 < i2.length; r2++) {
            t2 = i2[r2], -1 === n2.indexOf(t2) && {}.propertyIsEnumerable.call(e2, t2) && (o2[t2] = e2[t2]);
          }
        }
        return o2;
      }
      function St(e2, n2) {
        if (null == e2) return {};
        var t2 = {};
        for (var r2 in e2) {
          if ({}.hasOwnProperty.call(e2, r2)) {
            if (-1 !== n2.indexOf(r2)) continue;
            t2[r2] = e2[r2];
          }
        }
        return t2;
      }
      var Ot = {
        disabled: C().bool,
        onClick: C().func,
        selected: C().oneOf([true, false, "some"])
      };
      function kt(e2) {
        var n2 = e2.disabled, t2 = e2.onClick, o2 = e2.selected, i2 = xt(e2, ["disabled", "onClick", "selected"]);
        var a2 = n2 === true ? "disabled" : void 0;
        return r().createElement(gt, Ct({
          "aria-checked": o2 === "some" ? "mixed" : o2,
          disabled: a2,
          onClick: t2,
          role: "checkbox"
        }, i2), r().createElement(wt, {
          disabled: !!a2,
          selected: o2
        }));
      }
      kt.propTypes = Ot;
      const Rt = kt;
      function Et(e2) {
        "@babel/helpers - typeof";
        return Et = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e3) {
          return typeof e3;
        } : function(e3) {
          return e3 && "function" == typeof Symbol && e3.constructor === Symbol && e3 !== Symbol.prototype ? "symbol" : typeof e3;
        }, Et(e2);
      }
      function It(e2, n2) {
        var t2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var r2 = Object.getOwnPropertySymbols(e2);
          n2 && (r2 = r2.filter((function(n3) {
            return Object.getOwnPropertyDescriptor(e2, n3).enumerable;
          }))), t2.push.apply(t2, r2);
        }
        return t2;
      }
      function Tt(e2) {
        for (var n2 = 1; n2 < arguments.length; n2++) {
          var t2 = null != arguments[n2] ? arguments[n2] : {};
          n2 % 2 ? It(Object(t2), true).forEach((function(n3) {
            jt(e2, n3, t2[n3]);
          })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : It(Object(t2)).forEach((function(n3) {
            Object.defineProperty(e2, n3, Object.getOwnPropertyDescriptor(t2, n3));
          }));
        }
        return e2;
      }
      function jt(e2, n2, t2) {
        return (n2 = Dt(n2)) in e2 ? Object.defineProperty(e2, n2, {
          value: t2,
          enumerable: true,
          configurable: true,
          writable: true
        }) : e2[n2] = t2, e2;
      }
      function Dt(e2) {
        var n2 = qt(e2, "string");
        return "symbol" == Et(n2) ? n2 : n2 + "";
      }
      function qt(e2, n2) {
        if ("object" != Et(e2) || !e2) return e2;
        var t2 = e2[Symbol.toPrimitive];
        if (void 0 !== t2) {
          var r2 = t2.call(e2, n2 || "default");
          if ("object" != Et(r2)) return r2;
          throw new TypeError("@@toPrimitive must return a primitive value.");
        }
        return ("string" === n2 ? String : Number)(e2);
      }
      function At(e2, n2) {
        if (null == e2) return {};
        var t2, r2, o2 = Pt(e2, n2);
        if (Object.getOwnPropertySymbols) {
          var i2 = Object.getOwnPropertySymbols(e2);
          for (r2 = 0; r2 < i2.length; r2++) {
            t2 = i2[r2], -1 === n2.indexOf(t2) && {}.propertyIsEnumerable.call(e2, t2) && (o2[t2] = e2[t2]);
          }
        }
        return o2;
      }
      function Pt(e2, n2) {
        if (null == e2) return {};
        var t2 = {};
        for (var r2 in e2) {
          if ({}.hasOwnProperty.call(e2, r2)) {
            if (-1 !== n2.indexOf(r2)) continue;
            t2[r2] = e2[r2];
          }
        }
        return t2;
      }
      function _t() {
        return _t = Object.assign ? Object.assign.bind() : function(e2) {
          for (var n2 = 1; n2 < arguments.length; n2++) {
            var t2 = arguments[n2];
            for (var r2 in t2) {
              ({}).hasOwnProperty.call(t2, r2) && (e2[r2] = t2[r2]);
            }
          }
          return e2;
        }, _t.apply(null, arguments);
      }
      var zt = {
        odd: vt,
        even: pt,
        none: vt
      };
      var Mt = {
        /** @private. Generally passed by Table rather than added directly. */
        activeElementId: C().string,
        actionPrimary: C().element,
        actionsSecondary: C().element,
        children: C().node,
        data: C().any,
        disabled: C().bool,
        /** @private. Generally passed by Table rather than added directly. */
        isDraggable: C().bool,
        /** @private. Generally passed by Table rather than added directly. */
        dragId: C().oneOfType([C().string, C().number]),
        elementRef: C().oneOfType([C().func, C().object]),
        /** @private. */
        expandable: C().bool,
        expanded: C().bool,
        /** @private. Identifies the unique id (or ids) for an expanded row (or rows). In expandable rows `ExpansionRowIcon` uses `expansionRowId` for accessibility aria attributes. */
        expansionRowIds: C().string,
        expansionRow: C().oneOfType([C().element, C().arrayOf(C().element)]),
        /** @private. Indicates whether the table has an actions column. */
        actions: C().bool,
        /** @private. Generally passed by `Table` rather than added directly. */
        index: C().number,
        /** @private. Generally passed by `Table` rather than added directly. */
        movableColumns: C().bool,
        onClick: C().func,
        onExpansion: C().func,
        /** @private. This is passed through and works as expected. */
        onKeyDown: C().func,
        /** @private. Generally passed by `Table` rather than added directly. */
        onRequestMoveRow: C().func,
        onRequestToggle: C().func,
        /** @private. Generally passed by `Table` rather than added directly. */
        primaryColumnIndex: C().number,
        rowScreenReaderText: C().string,
        selected: C().bool,
        /** @private. */
        stripe: C().oneOf(["odd", "even", "none"])
      };
      var $t = r().createElement(Bn(), null);
      var Nt = r().forwardRef((function(e2, n2) {
        return r().createElement(De(), _t({
          content: (0, j._)("Actions"),
          contentRelationship: "label"
        }, e2), r().createElement(Fn(), {
          appearance: "subtle",
          "data-test": "actions-secondary-toggle",
          icon: $t,
          elementRef: n2
        }));
      }));
      function Lt(e2) {
        var n2;
        var o2 = e2.actions, i2 = e2.actionPrimary, l2 = e2.actionsSecondary, u2 = e2.children, s2 = e2.data, c2 = e2.dragId, d2 = e2.disabled, f2 = e2.isDraggable, v2 = e2.elementRef, p2 = e2.expandable, m2 = e2.expanded, b2 = e2.expansionRowIds, y2 = e2.expansionRow, g2 = e2.index, w2 = e2.movableColumns, C2 = e2.onClick, x2 = e2.onExpansion, S2 = e2.onKeyDown, O2 = e2.onRequestToggle, k2 = e2.primaryColumnIndex, R2 = k2 === void 0 ? 0 : k2, E2 = e2.rowScreenReaderText, I2 = e2.selected, q2 = e2.stripe, A2 = q2 === void 0 ? "none" : q2, P2 = e2.style, _2 = At(e2, ["actions", "actionPrimary", "actionsSecondary", "children", "data", "dragId", "disabled", "isDraggable", "elementRef", "expandable", "expanded", "expansionRowIds", "expansionRow", "index", "movableColumns", "onClick", "onExpansion", "onKeyDown", "onRequestToggle", "primaryColumnIndex", "rowScreenReaderText", "selected", "stripe", "style"]);
        var z2 = (0, t.useMemo)((function() {
          return {
            id: f2 ? c2 : (0, D.createGUID)(),
            disabled: !f2
          };
        }), [f2, c2]);
        var M2 = (0, a.useSortable)(z2), $3 = M2.attributes, N2 = M2.listeners, W2 = M2.transform, H2 = M2.transition, K2 = M2.setNodeRef, B2 = M2.setActivatorNodeRef;
        var V2 = (0, t.useMemo)((function() {
          return f2 ? Tt(Tt({}, P2), {}, {
            transform: Hn.CSS.Translate.toString(W2),
            transition: H2
          }) : P2;
        }), [f2, W2, H2, P2]);
        var F2 = (0, t.useRef)(null);
        var U2 = (0, t.useCallback)((function(e3) {
          var n3 = e3.target;
          while (n3) {
            if (F2.current === n3) {
              break;
            }
            if (n3.tagName === "BUTTON" || n3.tagName === "A") {
              return;
            }
            n3 = n3.parentNode;
          }
          if (!e3.defaultPrevented) {
            C2 === null || C2 === void 0 ? void 0 : C2(e3, s2);
          }
        }), [s2, C2]);
        var X2 = (0, t.useCallback)((function(e3) {
          if (e3.key === "Enter" && C2) {
            C2(e3, s2);
          }
          S2 === null || S2 === void 0 ? void 0 : S2(e3);
        }), [s2, C2, S2]);
        var Y2 = (0, t.useCallback)((function(e3) {
          if (!d2) {
            e3.preventDefault();
            O2 === null || O2 === void 0 ? void 0 : O2(e3, s2);
          }
        }), [s2, d2, O2]);
        var G2 = (0, t.useCallback)((function(e3) {
          e3.preventDefault();
          x2 === null || x2 === void 0 ? void 0 : x2(e3, s2);
        }), [s2, x2]);
        var J2 = function n3() {
          if (i2 && i2.props.onClick) {
            return (0, t.cloneElement)(i2, {
              onClick: function n4(t2) {
                var r2, o3;
                t2.preventDefault();
                return (r2 = (o3 = i2.props).onClick) === null || r2 === void 0 ? void 0 : r2.call(o3, t2, e2.data);
              }
            });
          }
          return i2;
        };
        var Q2 = function n3() {
          if (l2 && l2.props.children) {
            var r2 = t.Children.toArray(l2.props.children).filter(t.isValidElement);
            var o3 = r2.map((function(n4) {
              if (n4.props.onClick) {
                return (0, t.cloneElement)(n4, {
                  onClick: function t2(r3) {
                    var o4, i3;
                    r3.preventDefault();
                    return (o4 = (i3 = n4.props).onClick) === null || o4 === void 0 ? void 0 : o4.call(i3, r3, e2.data);
                  }
                });
              }
              return n4;
            }));
            return (0, t.cloneElement)(l2, {
              children: o3
            });
          }
          return l2;
        };
        function Z2(e3) {
          F2.current = e3;
          L(v2, e3);
          if (f2) {
            K2(e3);
          }
        }
        var ee2 = t.Children.toArray(u2).map((function(e3, n3) {
          return (0, t.cloneElement)(e3, {
            appearance: C2 ? "rowLink" : e3.props.appearance,
            disabled: d2,
            isPrimaryCell: R2 === n3,
            stripe: A2
          });
        }));
        var ne2;
        if (E2) {
          ne2 = E2;
        } else if ((n2 = ee2[R2]) === null || n2 === void 0 ? void 0 : n2.props.children) {
          var te2;
          ne2 = "".concat((te2 = ee2[R2]) === null || te2 === void 0 ? void 0 : te2.props.children);
        } else {
          var re2;
          ne2 = "".concat((re2 = ee2[0]) === null || re2 === void 0 ? void 0 : re2.props.children);
          if (false) {
          }
        }
        var oe2 = (0, T.sprintf)((0, j._)("%(selected)s"), {
          selected: I2 ? "selected" : "unselected"
        });
        var ie2 = zt[A2];
        var ae2 = m2 ? t.Children.count(y2) + 1 : void 0;
        var le2 = w2 ? "false" : void 0;
        var ue2 = function e3() {
          return r().createElement(Nt, null);
        };
        var se2 = (0, T.sprintf)((0, j._)("Collapse row - %(rowLabelValue)s"), {
          rowLabelValue: ne2
        });
        var ce2 = (0, T.sprintf)((0, j._)("Expand row - %(rowLabelValue)s"), {
          rowLabelValue: ne2
        });
        return r().createElement(ie2, _t({
          "data-test": "row",
          "data-test-selected": O2 ? I2 : void 0,
          $clickable: !!C2,
          "data-has-movable-columns": w2 ? "true" : void 0,
          disabled: !!d2,
          $expandable: !!p2,
          $isDraggable: !!f2,
          ref: Z2,
          tabIndex: C2 ? 0 : void 0
        }, h()(_2, "data"), {
          onClick: C2 ? U2 : void 0,
          onKeyDown: X2,
          $rowSelected: !!(O2 && I2),
          style: V2
        }), f2 && g2 != null && r().createElement(ft, _t({
          "aria-label": (0, T.sprintf)((0, j._)("Reorder %(rowLabelValue)s"), {
            rowLabelValue: ne2
          }),
          setActivatorNodeRef: B2,
          listeners: N2
        }, $3)), O2 && r().createElement(Se, {
          align: "center",
          appearance: C2 ? "rowLink" : "data",
          disabled: d2,
          variant: "toggle",
          "data-movable-column": le2,
          rowSpan: ae2,
          "data-test": "toggle"
        }, r().createElement(Rt, {
          "aria-label": (0, T.sprintf)((0, j._)("%(rowLabelValue)s %(selectedString)s"), {
            rowLabelValue: ne2,
            selectedString: oe2
          }),
          disabled: d2,
          onClick: Y2,
          selected: I2
        })), p2 && y2 && r().createElement(Se, {
          align: "center",
          appearance: "data",
          "data-movable-column": le2,
          "data-test": "expand",
          expand: m2,
          rowSpan: ae2,
          variant: "expand"
        }, r().createElement(ot, {
          expanded: m2,
          onClick: G2,
          title: m2 ? se2 : ce2,
          "aria-controls": m2 ? b2 : void 0,
          "aria-expanded": m2
        })), p2 && !y2 && r().createElement(Se, {
          variant: "expand",
          "data-movable-column": le2
        }), ee2, o2 && !i2 && !l2 && r().createElement(Se, {
          align: "right",
          appearance: C2 ? "rowLink" : "data",
          "data-test": "row-actions",
          variant: "actions",
          "data-movable-column": le2
        }), (i2 || l2) && r().createElement(Se, {
          align: "right",
          appearance: "data",
          "data-test": "row-actions",
          variant: "actions",
          "data-movable-column": le2
        }, i2 && J2(), l2 && r().createElement(Xn(), {
          toggle: ue2()
        }, Q2())));
      }
      Lt.propTypes = Mt;
      Lt.splunkUiType = "Table.Row";
      const Wt = Lt;
      var Ht = (0, t.createContext)({});
      Ht.displayName = "Table";
      const Kt = Ht;
      function Bt() {
        return Bt = Object.assign ? Object.assign.bind() : function(e2) {
          for (var n2 = 1; n2 < arguments.length; n2++) {
            var t2 = arguments[n2];
            for (var r2 in t2) {
              ({}).hasOwnProperty.call(t2, r2) && (e2[r2] = t2[r2]);
            }
          }
          return e2;
        }, Bt.apply(null, arguments);
      }
      function Vt(e2, n2) {
        if (null == e2) return {};
        var t2, r2, o2 = Ft(e2, n2);
        if (Object.getOwnPropertySymbols) {
          var i2 = Object.getOwnPropertySymbols(e2);
          for (r2 = 0; r2 < i2.length; r2++) {
            t2 = i2[r2], -1 === n2.indexOf(t2) && {}.propertyIsEnumerable.call(e2, t2) && (o2[t2] = e2[t2]);
          }
        }
        return o2;
      }
      function Ft(e2, n2) {
        if (null == e2) return {};
        var t2 = {};
        for (var r2 in e2) {
          if ({}.hasOwnProperty.call(e2, r2)) {
            if (-1 !== n2.indexOf(r2)) continue;
            t2[r2] = e2[r2];
          }
        }
        return t2;
      }
      var Ut = {
        /** @private. */
        actions: C().arrayOf(C().node),
        /** @private. */
        actionsColumnWidth: C().number,
        /** @private */
        cellMinWidth: C().number,
        children: C().node,
        elementRef: C().oneOfType([C().func, C().object]),
        /** @private. */
        hasDragColumn: C().bool,
        /** @private. */
        hasInfoColumn: C().bool,
        /** @private. */
        onAutosizeColumn: C().func,
        /** @private. */
        onRequestMoveColumn: C().func,
        /** @private. */
        onRequestResizeColumn: C().func,
        /** @private. */
        onRequestToggleAllRows: C().func,
        /** @private. */
        rowSelection: C().oneOf(["all", "some", "none"])
      };
      var Xt = 1;
      var Yt = {
        all: true,
        none: false,
        some: "some"
      };
      var Gt = (0, j._)("No rows selected");
      var Jt = (0, j._)("Some rows selected");
      var Qt = (0, j._)("All rows selected");
      var Zt = function e2(n2) {
        var t2, r2;
        var o2 = sn();
        if (!n2) {
          return [];
        }
        return Array.from((t2 = (r2 = n2.firstElementChild) === null || r2 === void 0 ? void 0 : r2.children) !== null && t2 !== void 0 ? t2 : []).map((function(e3) {
          var n3 = o2.getComputedStyle(e3);
          return e3.clientWidth - parseFloat(n3.getPropertyValue("padding-right")) - parseFloat(n3.getPropertyValue("padding-left"));
        }));
      };
      function er(e2) {
        var n2 = e2.actions, o2 = n2 === void 0 ? [] : n2, i2 = e2.actionsColumnWidth, a2 = e2.cellMinWidth, l2 = a2 === void 0 ? 60 : a2, u2 = e2.children, s2 = e2.elementRef, c2 = e2.hasDragColumn, d2 = e2.hasInfoColumn, f2 = e2.onAutosizeColumn, v2 = e2.onRequestMoveColumn, p2 = e2.onRequestResizeColumn, m2 = e2.onRequestToggleAllRows, b2 = e2.rowSelection, h2 = Vt(e2, ["actions", "actionsColumnWidth", "cellMinWidth", "children", "elementRef", "hasDragColumn", "hasInfoColumn", "onAutosizeColumn", "onRequestMoveColumn", "onRequestResizeColumn", "onRequestToggleAllRows", "rowSelection"]);
        var y2 = (0, t.useContext)(Kt), g2 = y2.headType, w2 = y2.tableContainerWidthWithoutBorders, C2 = y2.resizableFillLayout;
        var x2 = (0, t.useRef)(null);
        var S2 = (0, t.useRef)([]);
        (0, t.useEffect)((function() {
          if (false) {
            var e3;
          }
        }), [u2, p2, C2]);
        var O2 = (0, t.useCallback)((function(e3) {
          var n3 = e3.fromIndex, r2 = e3.toIndex;
          if (r2 < t.Children.toArray(u2).length) {
            v2 === null || v2 === void 0 ? void 0 : v2({
              fromIndex: n3,
              toIndex: r2
            });
          }
        }), [u2, v2]);
        var k2 = (0, t.useCallback)((function(e3, n3) {
          var t2 = n3.columnId, r2 = n3.id, o3 = n3.index, i3 = n3.width;
          var a3 = Zt(x2.current);
          if (o3 >= a3.length) {
            p2 === null || p2 === void 0 ? void 0 : p2(e3, n3);
            return;
          }
          var u3 = a3[o3];
          var s3 = i3 - u3;
          if (s3 <= 0) {
            if (i3 >= l2) {
              p2 === null || p2 === void 0 ? void 0 : p2(e3, n3);
            } else {
              p2 === null || p2 === void 0 ? void 0 : p2(e3, {
                columnId: t2,
                id: r2,
                index: o3,
                width: l2
              });
            }
          } else {
            var c3 = [];
            var d3 = 0;
            var f3 = true;
            if (S2.current.length !== a3.length) {
              p2 === null || p2 === void 0 ? void 0 : p2(e3, n3);
              return;
            }
            S2.current.forEach((function(e4, n4) {
              if (e4 === "auto") {
                d3 += 1;
                c3.push(n4);
              }
            }));
            if (d3 > 0) {
              var v3 = s3 / d3;
              c3.every((function(e4) {
                if (e4 < a3.length && a3[e4] - v3 < l2) {
                  f3 = false;
                  return false;
                }
                return true;
              }));
              if (f3) {
                p2 === null || p2 === void 0 ? void 0 : p2(e3, n3);
              } else {
                var m3 = 0;
                c3.forEach((function(e4) {
                  if (e4 < a3.length) {
                    m3 += Math.max(a3[e4] - l2, 0);
                  }
                }));
                var b3 = a3[o3] + m3;
                p2 === null || p2 === void 0 ? void 0 : p2(e3, {
                  columnId: t2,
                  id: r2,
                  index: o3,
                  width: b3
                });
              }
            } else if (w2 != null) {
              var h3 = a3.slice(0, a3.length - 1);
              var y3 = h3.reduce((function(e4, n4) {
                return e4 + n4;
              }));
              var g3 = w2 - y3;
              if (g3 - s3 >= l2) {
                p2 === null || p2 === void 0 ? void 0 : p2(e3, n3);
              } else {
                var C3 = g3 - l2;
                var O3 = u3 + C3;
                p2 === null || p2 === void 0 ? void 0 : p2(e3, {
                  columnId: t2,
                  id: r2,
                  index: o3,
                  width: O3
                });
              }
            } else {
              p2 === null || p2 === void 0 ? void 0 : p2(e3, n3);
            }
          }
        }), [l2, p2, w2]);
        var R2 = (0, t.useCallback)((function(e3) {
          L(s2, e3);
          x2.current = e3;
        }), [s2]);
        var E2 = (0, t.useMemo)((function() {
          return t.Children.toArray(u2).filter(t.isValidElement);
        }), [u2]);
        var I2 = E2.length + (o2.length || i2 ? 1 : 0);
        var T2 = (0, t.useMemo)((function() {
          var e3 = [];
          var n3 = E2.map((function(n4, r2) {
            e3.push(n4.props.width);
            return (0, t.cloneElement)(n4, {
              index: r2,
              onRequestResize: C2 ? k2 : p2,
              onRequestMoveColumn: v2 ? O2 : void 0,
              onAutosizeColumn: f2,
              key: n4.key || n4.props.columnId || r2
            });
          }));
          S2.current = e3;
          return n3;
        }), [E2, C2, k2, p2, v2, O2, f2]);
        var j2 = b2 === void 0 ? void 0 : Yt[b2];
        var D2 = i2 || 48;
        var q2 = g2 === "fixed" ? "fixed-head" : "head";
        var A2;
        if (j2 === "some") {
          A2 = Jt;
        } else if (j2) {
          A2 = Qt;
        } else {
          A2 = Gt;
        }
        var P2 = (0, t.useMemo)((function() {
          return {
            minWidth: D2
          };
        }), [D2]);
        var _2 = (0, t.useMemo)((function() {
          return {
            minWidth: i2
          };
        }), [i2]);
        return r().createElement($n, Bt({
          ref: R2,
          "data-test": q2,
          $isFixed: g2 === "fixed",
          $zIndex: I2 + Xt
        }, h2), r().createElement(Wt, null, c2 && r().createElement(Wn, {
          key: "drag_rows_head_cell",
          "data-test": "drag-rows-head-cell",
          align: "center",
          resizable: false
        }), m2 && r().createElement(Nn, {
          key: "toggle_all",
          resizable: false,
          align: "center",
          variant: "toggleAll",
          truncate: false,
          "data-test": "toggle-all"
        }, r().createElement(Rt, {
          "aria-label": A2,
          onClick: m2,
          selected: j2
        })), d2 && r().createElement(Ln, {
          key: "more_info_head_cell",
          "data-test": "more-info-head-cell",
          resizable: false,
          variant: "info"
        }), T2, o2.length > 0 && r().createElement(Mn, {
          key: "actions_head_cell",
          "data-test": "actions-head-cell",
          align: "right",
          resizable: false,
          width: D2,
          style: P2,
          variant: "actions"
        }, o2), o2.length === 0 && i2 && r().createElement(Mn, {
          key: "actions_head_cell",
          "data-test": "actions-head-cell",
          align: "right",
          resizable: false,
          width: i2,
          style: _2,
          variant: "actions"
        }, " ")));
      }
      er.propTypes = Ut;
      er.splunkUiType = "Table.Head";
      const nr = er;
      const tr = require_isFinite();
      var rr = e.n(tr);
      const or = require_isFunction();
      var ir = e.n(or);
      const ar = require_Popover();
      var lr = e.n(ar);
      const ur = require_useControlled();
      var sr = e.n(ur);
      function cr() {
        return cr = Object.assign ? Object.assign.bind() : function(e2) {
          for (var n2 = 1; n2 < arguments.length; n2++) {
            var t2 = arguments[n2];
            for (var r2 in t2) {
              ({}).hasOwnProperty.call(t2, r2) && (e2[r2] = t2[r2]);
            }
          }
          return e2;
        }, cr.apply(null, arguments);
      }
      function dr(e2, n2) {
        return br(e2) || mr(e2, n2) || vr(e2, n2) || fr();
      }
      function fr() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      function vr(e2, n2) {
        if (e2) {
          if ("string" == typeof e2) return pr(e2, n2);
          var t2 = {}.toString.call(e2).slice(8, -1);
          return "Object" === t2 && e2.constructor && (t2 = e2.constructor.name), "Map" === t2 || "Set" === t2 ? Array.from(e2) : "Arguments" === t2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t2) ? pr(e2, n2) : void 0;
        }
      }
      function pr(e2, n2) {
        (null == n2 || n2 > e2.length) && (n2 = e2.length);
        for (var t2 = 0, r2 = Array(n2); t2 < n2; t2++) {
          r2[t2] = e2[t2];
        }
        return r2;
      }
      function mr(e2, n2) {
        var t2 = null == e2 ? null : "undefined" != typeof Symbol && e2[Symbol.iterator] || e2["@@iterator"];
        if (null != t2) {
          var r2, o2, i2, a2, l2 = [], u2 = true, s2 = false;
          try {
            if (i2 = (t2 = t2.call(e2)).next, 0 === n2) {
              if (Object(t2) !== t2) return;
              u2 = false;
            } else for (; !(u2 = (r2 = i2.call(t2)).done) && (l2.push(r2.value), l2.length !== n2); u2 = true) {
            }
          } catch (e3) {
            s2 = true, o2 = e3;
          } finally {
            try {
              if (!u2 && null != t2["return"] && (a2 = t2["return"](), Object(a2) !== a2)) return;
            } finally {
              if (s2) throw o2;
            }
          }
          return l2;
        }
      }
      function br(e2) {
        if (Array.isArray(e2)) return e2;
      }
      function hr(e2, n2) {
        if (null == e2) return {};
        var t2, r2, o2 = yr(e2, n2);
        if (Object.getOwnPropertySymbols) {
          var i2 = Object.getOwnPropertySymbols(e2);
          for (r2 = 0; r2 < i2.length; r2++) {
            t2 = i2[r2], -1 === n2.indexOf(t2) && {}.propertyIsEnumerable.call(e2, t2) && (o2[t2] = e2[t2]);
          }
        }
        return o2;
      }
      function yr(e2, n2) {
        if (null == e2) return {};
        var t2 = {};
        for (var r2 in e2) {
          if ({}.hasOwnProperty.call(e2, r2)) {
            if (-1 !== n2.indexOf(r2)) continue;
            t2[r2] = e2[r2];
          }
        }
        return t2;
      }
      var gr = ["clickAway", "contentClick", "escapeKey", "offScreen", "tabKey", "toggleClick"];
      var wr = {
        align: C().oneOf(["left", "center", "right"]),
        buttonRef: C().oneOfType([C().func, C().object]),
        canCoverHead: C().bool,
        children: C().node.isRequired,
        closeReasons: C().arrayOf(C().oneOf(gr)),
        columnId: C().string,
        /** @private. */
        dragId: C().oneOfType([C().string, C().number]),
        elementRef: C().oneOfType([C().func, C().object]),
        headCellScreenReaderText: C().string,
        focusToggleReasons: C().arrayOf(C().oneOf(gr)),
        /** @private The index of the cell, skipping the info column. */
        index: C().number,
        label: C().node,
        /** @private. */
        onAutosizeColumn: C().func,
        /**
        * @private. This will be passed through, and will work as expected.
        */
        onKeyDown: C().func,
        onRequestClose: C().func,
        /** @private. */
        onRequestMoveColumn: C().func,
        onRequestOpen: C().func,
        /** @private. */
        onRequestResize: C().func,
        open: C().bool,
        repositionMode: C().oneOf(["none", "flip", "any"]),
        resizable: C().bool,
        retainFocus: C().bool,
        takeFocus: C().bool,
        truncate: C().bool,
        /**
        * @private
        * Used internally to suppress focus when this `HeadDropdownCell` is superseded by one in an
        * overlaid `HeadTable` for user interactions.
        */
        visible: C().bool,
        width: C().number,
        /** @private. */
        variant: C().oneOf(["toggleAll", "info", "actions"])
      };
      var Cr = ["contentClick", "escapeKey", "toggleClick"];
      function xr(e2) {
        var n2;
        var o2 = e2.align, i2 = o2 === void 0 ? "left" : o2, l2 = e2.buttonRef, u2 = e2.canCoverHead, s2 = u2 === void 0 ? true : u2, c2 = e2.children, d2 = e2.closeReasons, f2 = d2 === void 0 ? gr : d2, v2 = e2.columnId, p2 = e2.dragId, m2 = e2.elementRef, b2 = e2.headCellScreenReaderText, h2 = e2.focusToggleReasons, y2 = h2 === void 0 ? Cr : h2, g2 = e2.id, w2 = e2.index, C2 = e2.label, x2 = e2.onAutosizeColumn, S2 = e2.onKeyDown, O2 = e2.onRequestClose, k2 = e2.onRequestMoveColumn, E2 = e2.onRequestOpen, I2 = e2.onRequestResize, q2 = e2.open, P2 = e2.repositionMode, _2 = P2 === void 0 ? "flip" : P2, z2 = e2.resizable, M2 = z2 === void 0 ? true : z2, $3 = e2.retainFocus, N2 = e2.style, W2 = e2.takeFocus, H2 = W2 === void 0 ? true : W2, K2 = e2.truncate, B2 = K2 === void 0 ? true : K2, V2 = e2.variant, F2 = e2.visible, U2 = F2 === void 0 ? true : F2, X2 = e2.width, Y2 = hr(e2, ["align", "buttonRef", "canCoverHead", "children", "closeReasons", "columnId", "dragId", "elementRef", "headCellScreenReaderText", "focusToggleReasons", "id", "index", "label", "onAutosizeColumn", "onKeyDown", "onRequestClose", "onRequestMoveColumn", "onRequestOpen", "onRequestResize", "open", "repositionMode", "resizable", "retainFocus", "style", "takeFocus", "truncate", "variant", "visible", "width"]);
        var G2 = sr()({
          componentName: "HeadDropdownCell",
          /* eslint-disable-next-line prefer-rest-params */
          componentProps: arguments[0],
          // see SUI-7028
          valuePropName: "open"
        });
        var J2 = (0, t.useState)(), Q2 = dr(J2, 2), Z2 = Q2[0], ee2 = Q2[1];
        var ne2 = (0, t.useState)(null), te2 = dr(ne2, 2), re2 = te2[0], oe2 = te2[1];
        var ie2 = (0, t.useState)(null), ae2 = dr(ie2, 2), le2 = ae2[0], ue2 = ae2[1];
        var se2 = (0, t.useState)(false), ce2 = dr(se2, 2), de2 = ce2[0], fe2 = ce2[1];
        var ve2 = (0, D.createDOMID)("popover");
        var pe2 = !!k2;
        var me2 = (0, a.useSortable)({
          // dragId is optional in HeadCell but required by useSortable
          // since it is always set in Table, use a type assertion here to avoid TypeScript error
          id: p2
        }), be2 = me2.attributes, he2 = me2.listeners, ye2 = me2.setNodeRef, ge2 = me2.isDragging;
        var we2 = (0, t.useMemo)((function() {
          return G2 ? q2 : de2;
        }), [G2, de2, q2]);
        var Ce2 = R()(U2);
        var xe2 = (n2 = g2 !== null && g2 !== void 0 ? g2 : v2) !== null && n2 !== void 0 ? n2 : (0, D.createDOMID)("headCellId-");
        (0, t.useEffect)((function() {
          if (false) {
          }
        }), [I2, B2]);
        var Se2 = (0, t.useCallback)((function(e3) {
          var n3 = e3.reason, t2 = e3.event;
          if (n3 === "clickAway" && t2 !== void 0) {
            var r2 = t2.target;
            while (r2) {
              if (r2 === le2) {
                return;
              }
              r2 = r2.parentNode;
            }
          }
          if (we2 && A()(f2, n3) && w2 !== void 0) {
            if (A()(y2, n3)) {
              le2 === null || le2 === void 0 ? void 0 : le2.focus();
            }
            if (!G2) {
              fe2(false);
            }
            O2 === null || O2 === void 0 ? void 0 : O2(t2, {
              index: w2,
              reason: n3,
              columnId: v2
            });
          }
        }), [f2, v2, y2, w2, le2, G2, we2, O2]);
        (0, t.useEffect)((function() {
          if (Ce2 && !U2) {
            Se2({
              reason: "offScreen"
            });
          }
        }), [Se2, Ce2, U2]);
        var Oe2 = (0, t.useCallback)((function(e3) {
          L(m2, e3);
          if (pe2) {
            ye2(e3);
          }
        }), [pe2, m2, ye2]);
        var ke2 = (0, t.useCallback)((function(e3) {
          ue2(e3);
          oe2(e3);
          L(l2, e3);
        }), [l2]);
        var Re2 = (0, t.useCallback)((function(e3) {
          e3.stopPropagation();
          if (e3.target.getAttribute("data-test") === "resize") {
            return;
          }
          if (!we2) {
            ee2(e3.clientX || void 0);
          }
          if (we2) {
            Se2 === null || Se2 === void 0 ? void 0 : Se2({
              reason: "toggleClick",
              event: e3
            });
          } else if (w2 !== void 0) {
            E2 === null || E2 === void 0 ? void 0 : E2(e3, {
              reason: "toggleClick",
              columnId: v2,
              index: w2
            });
            if (!G2) {
              fe2(true);
            }
          }
        }), [v2, Se2, w2, G2, we2, E2]);
        var Ie2 = (0, t.useCallback)((function(e3) {
          if (w2 !== void 0) {
            S2 === null || S2 === void 0 ? void 0 : S2(e3, {
              index: w2,
              columnId: v2
            });
          }
        }), [v2, w2, S2]);
        var je2 = (0, t.useCallback)((function(e3) {
          Se2({
            reason: "contentClick",
            event: e3
          });
        }), [Se2]);
        var De2 = (0, t.useMemo)((function() {
          if (Z2 !== void 0 && rr()(Z2)) {
            var e3;
            return {
              x: Z2 - ((e3 = re2 === null || re2 === void 0 ? void 0 : re2.getBoundingClientRect().left) !== null && e3 !== void 0 ? e3 : 0)
            };
          }
          return void 0;
        }), [Z2, re2]);
        var qe2 = (0, t.useMemo)((function() {
          return Ee()({}, N2, {
            width: X2
          });
        }), [N2, X2]);
        var Ae2;
        if (b2) {
          Ae2 = b2;
        } else if (typeof C2 === "string") {
          Ae2 = C2;
        }
        return r().createElement(Be, cr({
          style: qe2,
          "data-test": "head-cell",
          $isDragging: pe2 && ge2,
          $variant: V2,
          id: U2 ? xe2 : void 0,
          ref: Oe2
        }, Y2), r().createElement(Ke, null, pe2 && r().createElement(Fe, cr({
          "aria-label": (0, T.sprintf)((0, j._)("Reorder %(labelString)s"), {
            labelString: Ae2
          }),
          "data-test": "drag"
        }, be2, he2), r().createElement(Ve, null, r().createElement(Te(), null))), r().createElement(jn, {
          align: i2,
          "aria-expanded": we2,
          "aria-haspopup": true,
          "aria-owns": ve2,
          clickable: true,
          columnId: v2,
          elementRef: ke2,
          cellId: xe2,
          index: w2,
          isMenu: true,
          label: C2,
          resizable: U2 && M2,
          onAutosizeColumn: x2,
          onRequestResize: I2,
          onClick: Re2,
          onKeyDown: Ie2,
          truncate: B2,
          width: X2,
          "data-test": "inner"
        }), r().createElement(lr(), {
          align: "center",
          anchor: re2,
          "aria-labelledby": xe2,
          autoCloseWhenOffScreen: A()(f2, "offScreen"),
          canCoverAnchor: s2,
          defaultPlacement: "below",
          id: ve2,
          onRequestClose: Se2,
          open: !!re2 && we2,
          pointTo: De2,
          repositionMode: _2,
          retainFocus: $3,
          takeFocus: H2
        }, ir()(c2) ? function() {
          return r().createElement("div", {
            onClick: je2
          }, c2.apply(void 0, arguments));
        } : (
          // eslint-disable-next-line jsx-a11y/click-events-have-key-events, jsx-a11y/no-static-element-interactions
          r().createElement("div", {
            onClick: je2
          }, c2)
        ))));
      }
      xr.propTypes = wr;
      xr.splunkUiType = "Table.HeadDropdownCell";
      xr.possibleCloseReasons = gr;
      const Sr = xr;
      const Or = require_extend();
      var kr = e.n(Or);
      var Rr = M()(ne).withConfig({
        displayName: "HeadTableStyles__Styled",
        componentId: "g85wgf-0"
      })(["min-width:0;table-layout:fixed;"]);
      var Er = M().div.withConfig({
        displayName: "HeadTableStyles__StyledDockedContainer",
        componentId: "g85wgf-1"
      })(["overflow:hidden;position:fixed;z-index:", ";@media print{display:none;}"], $2.variables.zindexFixedNavbar);
      var Ir = M()(Er).withConfig({
        displayName: "HeadTableStyles__StyledFixedContainer",
        componentId: "g85wgf-2"
      })(["position:absolute;box-shadow:none;z-index:1;"]);
      function Tr() {
        return Tr = Object.assign ? Object.assign.bind() : function(e2) {
          for (var n2 = 1; n2 < arguments.length; n2++) {
            var t2 = arguments[n2];
            for (var r2 in t2) {
              ({}).hasOwnProperty.call(t2, r2) && (e2[r2] = t2[r2]);
            }
          }
          return e2;
        }, Tr.apply(null, arguments);
      }
      function jr(e2, n2) {
        if (null == e2) return {};
        var t2, r2, o2 = Dr(e2, n2);
        if (Object.getOwnPropertySymbols) {
          var i2 = Object.getOwnPropertySymbols(e2);
          for (r2 = 0; r2 < i2.length; r2++) {
            t2 = i2[r2], -1 === n2.indexOf(t2) && {}.propertyIsEnumerable.call(e2, t2) && (o2[t2] = e2[t2]);
          }
        }
        return o2;
      }
      function Dr(e2, n2) {
        if (null == e2) return {};
        var t2 = {};
        for (var r2 in e2) {
          if ({}.hasOwnProperty.call(e2, r2)) {
            if (-1 !== n2.indexOf(r2)) continue;
            t2[r2] = e2[r2];
          }
        }
        return t2;
      }
      var qr = {
        cellWidths: C().arrayOf(C().number).isRequired,
        dragIndex: C().number,
        elementRef: C().oneOfType([C().func, C().object]),
        hasDragColumn: C().bool,
        hasRowExpansion: C().bool,
        hasRowSelection: C().bool,
        headType: C().oneOf(["docked", "fixed"]).isRequired,
        horizontalOffset: C().number,
        isFixedColumn: C().bool,
        rowSelection: C().oneOf(["all", "some", "none"]),
        tableStyle: C().object,
        tableWidth: C().number.isRequired,
        tHead: C().element.isRequired,
        top: C().number.isRequired,
        width: C().number.isRequired
      };
      function Ar(e2) {
        var n2 = e2.cellWidths, o2 = e2.elementRef, i2 = e2.hasDragColumn, a2 = e2.hasRowExpansion, l2 = e2.hasRowSelection, u2 = e2.headType, s2 = e2.horizontalOffset, c2 = s2 === void 0 ? 0 : s2, d2 = e2.isFixedColumn, f2 = e2.tableStyle, v2 = e2.tableWidth, p2 = e2.tHead, m2 = e2.top, b2 = e2.width, y2 = jr(e2, ["cellWidths", "elementRef", "hasDragColumn", "hasRowExpansion", "hasRowSelection", "headType", "horizontalOffset", "isFixedColumn", "tableStyle", "tableWidth", "tHead", "top", "width"]);
        var g2 = u2 === "docked";
        var w2 = g2 ? Er : Ir;
        var C2 = (0, t.useRef)(null);
        var x2 = (0, t.useCallback)((function(e3) {
          L(C2, e3);
        }), [C2]);
        var S2 = 0;
        if (a2) {
          S2 += 1;
        }
        if (l2) {
          S2 += 1;
        }
        if (i2) {
          S2 += 1;
        }
        var O2 = (0, t.useMemo)((function() {
          return t.Children.toArray(p2.props.children);
        }), [p2.props.children]);
        var k2 = (0, t.useMemo)((function() {
          if (d2) {
            return O2;
          }
          return O2.filter(t.isValidElement).map((function(e3, r2) {
            return (0, t.cloneElement)(e3, {
              style: kr()({}, e3.props.style, {
                width: n2[r2 + S2]
              })
            });
          }));
        }), [n2, S2, d2, O2]);
        var R2 = (0, t.cloneElement)(p2, {
          elementRef: x2,
          "data-test": "".concat(u2, "-head")
        }, k2);
        var E2 = (0, t.useMemo)((function() {
          return {
            top: m2,
            width: b2
          };
        }), [m2, b2]);
        return r().createElement(w2, {
          style: E2,
          ref: o2
        }, r().createElement(Rr, Tr({
          "data-test": "".concat(u2, "-head-table"),
          "data-fixed-column": d2 ? "true" : void 0,
          style: kr()({}, f2, {
            marginLeft: c2,
            width: d2 ? void 0 : v2
          })
        }, h()(y2, "dragIndex")), R2));
      }
      Ar.propTypes = qr;
      const Pr = Ar;
      function _r(e2) {
        "@babel/helpers - typeof";
        return _r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e3) {
          return typeof e3;
        } : function(e3) {
          return e3 && "function" == typeof Symbol && e3.constructor === Symbol && e3 !== Symbol.prototype ? "symbol" : typeof e3;
        }, _r(e2);
      }
      function zr(e2, n2) {
        return Nr(e2) || $r(e2, n2) || Hr(e2, n2) || Mr();
      }
      function Mr() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      function $r(e2, n2) {
        var t2 = null == e2 ? null : "undefined" != typeof Symbol && e2[Symbol.iterator] || e2["@@iterator"];
        if (null != t2) {
          var r2, o2, i2, a2, l2 = [], u2 = true, s2 = false;
          try {
            if (i2 = (t2 = t2.call(e2)).next, 0 === n2) {
              if (Object(t2) !== t2) return;
              u2 = false;
            } else for (; !(u2 = (r2 = i2.call(t2)).done) && (l2.push(r2.value), l2.length !== n2); u2 = true) {
            }
          } catch (e3) {
            s2 = true, o2 = e3;
          } finally {
            try {
              if (!u2 && null != t2["return"] && (a2 = t2["return"](), Object(a2) !== a2)) return;
            } finally {
              if (s2) throw o2;
            }
          }
          return l2;
        }
      }
      function Nr(e2) {
        if (Array.isArray(e2)) return e2;
      }
      function Lr(e2) {
        return Br(e2) || Kr(e2) || Hr(e2) || Wr();
      }
      function Wr() {
        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      function Hr(e2, n2) {
        if (e2) {
          if ("string" == typeof e2) return Vr(e2, n2);
          var t2 = {}.toString.call(e2).slice(8, -1);
          return "Object" === t2 && e2.constructor && (t2 = e2.constructor.name), "Map" === t2 || "Set" === t2 ? Array.from(e2) : "Arguments" === t2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t2) ? Vr(e2, n2) : void 0;
        }
      }
      function Kr(e2) {
        if ("undefined" != typeof Symbol && null != e2[Symbol.iterator] || null != e2["@@iterator"]) return Array.from(e2);
      }
      function Br(e2) {
        if (Array.isArray(e2)) return Vr(e2);
      }
      function Vr(e2, n2) {
        (null == n2 || n2 > e2.length) && (n2 = e2.length);
        for (var t2 = 0, r2 = Array(n2); t2 < n2; t2++) {
          r2[t2] = e2[t2];
        }
        return r2;
      }
      function Fr(e2, n2) {
        if (!(e2 instanceof n2)) throw new TypeError("Cannot call a class as a function");
      }
      function Ur(e2, n2) {
        for (var t2 = 0; t2 < n2.length; t2++) {
          var r2 = n2[t2];
          r2.enumerable = r2.enumerable || false, r2.configurable = true, "value" in r2 && (r2.writable = true), Object.defineProperty(e2, Gr(r2.key), r2);
        }
      }
      function Xr(e2, n2, t2) {
        return n2 && Ur(e2.prototype, n2), t2 && Ur(e2, t2), Object.defineProperty(e2, "prototype", {
          writable: false
        }), e2;
      }
      function Yr(e2, n2, t2) {
        return (n2 = Gr(n2)) in e2 ? Object.defineProperty(e2, n2, {
          value: t2,
          enumerable: true,
          configurable: true,
          writable: true
        }) : e2[n2] = t2, e2;
      }
      function Gr(e2) {
        var n2 = Jr(e2, "string");
        return "symbol" == _r(n2) ? n2 : n2 + "";
      }
      function Jr(e2, n2) {
        if ("object" != _r(e2) || !e2) return e2;
        var t2 = e2[Symbol.toPrimitive];
        if (void 0 !== t2) {
          var r2 = t2.call(e2, n2 || "default");
          if ("object" != _r(r2)) return r2;
          throw new TypeError("@@toPrimitive must return a primitive value.");
        }
        return ("string" === n2 ? String : Number)(e2);
      }
      var Qr = (function() {
        function e2(n2) {
          var t2 = this;
          Fr(this, e2);
          Yr(this, "listeners", []);
          Yr(this, "removeAll", (function() {
            t2.listeners.forEach((function(e3) {
              var n3;
              return (n3 = t2.target) === null || n3 === void 0 ? void 0 : n3.removeEventListener.apply(n3, Lr(e3));
            }));
          }));
          this.target = n2;
          this.target = n2;
        }
        Xr(e2, [{
          key: "add",
          value: function e3(n2, t2, r2) {
            var o2;
            (o2 = this.target) === null || o2 === void 0 ? void 0 : o2.addEventListener(n2, t2, r2);
            this.listeners.push([n2, t2, r2]);
          }
        }]);
        return e2;
      })();
      function Zr(e2) {
        if (e2.startsWith("matrix3d(")) {
          var n2 = e2.slice(9, -1).split(/, /);
          return {
            x: +n2[12],
            y: +n2[13],
            scaleX: +n2[0],
            scaleY: +n2[5]
          };
        }
        if (e2.startsWith("matrix(")) {
          var t2 = e2.slice(7, -1).split(/, /);
          return {
            x: +t2[4],
            y: +t2[5],
            scaleX: +t2[0],
            scaleY: +t2[3]
          };
        }
        return null;
      }
      function eo(e2, n2, t2) {
        var r2 = Zr(n2);
        if (!r2) {
          return e2;
        }
        var o2 = r2.scaleX, i2 = r2.scaleY, a2 = r2.x, l2 = r2.y;
        var u2 = e2.left - a2 - (1 - o2) * parseFloat(t2);
        var s2 = e2.top - l2 - (1 - i2) * parseFloat(t2.slice(t2.indexOf(" ") + 1));
        var c2 = o2 ? e2.width / o2 : e2.width;
        var d2 = i2 ? e2.height / i2 : e2.height;
        return {
          width: c2,
          height: d2,
          top: s2,
          right: u2 + c2,
          bottom: s2 + d2,
          left: u2
        };
      }
      var no = {
        ignoreTransform: false
      };
      function to(e2) {
        var n2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : no;
        var t2 = e2.getBoundingClientRect();
        if (n2.ignoreTransform) {
          var r2 = (0, Hn.getWindow)(e2).getComputedStyle(e2), o2 = r2.transform, i2 = r2.transformOrigin;
          if (o2) {
            t2 = eo(t2, o2, i2);
          }
        }
        var a2 = t2, l2 = a2.top, u2 = a2.left, s2 = a2.width, c2 = a2.height, d2 = a2.bottom, f2 = a2.right;
        return {
          top: l2,
          left: u2,
          width: s2,
          height: c2,
          bottom: d2,
          right: f2
        };
      }
      function ro(e2) {
        if (e2 === document.scrollingElement) {
          var n2 = window, t2 = n2.innerWidth, r2 = n2.innerHeight;
          return {
            top: 0,
            left: 0,
            right: t2,
            bottom: r2,
            width: t2,
            height: r2
          };
        }
        var o2 = e2.getBoundingClientRect(), i2 = o2.top, a2 = o2.left, l2 = o2.right, u2 = o2.bottom;
        return {
          top: i2,
          left: a2,
          right: l2,
          bottom: u2,
          width: e2.clientWidth,
          height: e2.clientHeight
        };
      }
      function oo(e2) {
        if (!Hn.canUseDOM || !e2) {
          return false;
        }
        return e2 === document.scrollingElement;
      }
      function io(e2) {
        var n2 = {
          x: 0,
          y: 0
        };
        var t2 = oo(e2) ? {
          height: window.innerHeight,
          width: window.innerWidth
        } : {
          height: e2.clientHeight,
          width: e2.clientWidth
        };
        var r2 = {
          x: e2.scrollWidth - t2.width,
          y: e2.scrollHeight - t2.height
        };
        var o2 = e2.scrollTop <= n2.y;
        var i2 = e2.scrollLeft <= n2.x;
        var a2 = e2.scrollTop >= r2.y;
        var l2 = e2.scrollLeft >= r2.x;
        return {
          isTop: o2,
          isLeft: i2,
          isBottom: a2,
          isRight: l2,
          maxScroll: r2,
          minScroll: n2
        };
      }
      var ao = {
        x: 0,
        y: 0
      };
      function lo(e2) {
        var n2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : (0, Hn.getWindow)(e2).getComputedStyle(e2);
        return n2.position === "fixed";
      }
      function uo(e2) {
        var n2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : (0, Hn.getWindow)(e2).getComputedStyle(e2);
        var t2 = /(auto|scroll|overlay)/;
        var r2 = ["overflow", "overflowX", "overflowY"];
        return r2.some((function(e3) {
          var r3 = n2[e3];
          return typeof r3 === "string" ? t2.test(r3) : false;
        }));
      }
      function so(e2, n2) {
        var t2 = [];
        function r2(o2) {
          if (n2 != null && t2.length >= n2) {
            return t2;
          }
          if (!o2) {
            return t2;
          }
          if ((0, Hn.isDocument)(o2) && o2.scrollingElement != null && !t2.includes(o2.scrollingElement)) {
            t2.push(o2.scrollingElement);
            return t2;
          }
          if (!(0, Hn.isHTMLElement)(o2) || (0, Hn.isSVGElement)(o2)) {
            return t2;
          }
          if (t2.includes(o2)) {
            return t2;
          }
          var i2 = (0, Hn.getWindow)(e2).getComputedStyle(o2);
          if (o2 !== e2) {
            if (uo(o2, i2)) {
              t2.push(o2);
            }
          }
          if (lo(o2, i2)) {
            return t2;
          }
          return r2(o2.parentNode);
        }
        if (!e2) {
          return t2;
        }
        return r2(e2);
      }
      function co(e2) {
        var n2 = so(e2, 1), t2 = zr(n2, 1), r2 = t2[0];
        return r2 !== null && r2 !== void 0 ? r2 : null;
      }
      var fo = {
        start: [o.KeyboardCode.Space, o.KeyboardCode.Enter],
        cancel: [o.KeyboardCode.Esc],
        end: [o.KeyboardCode.Space, o.KeyboardCode.Enter]
      };
      function vo(e2) {
        var n2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : to;
        if (!e2) {
          return;
        }
        var t2 = n2(e2), r2 = t2.top, o2 = t2.left, i2 = t2.bottom, a2 = t2.right;
        var l2 = co(e2);
        if (!l2) {
          return;
        }
        if (i2 <= 0 || a2 <= 0 || r2 >= window.innerHeight || o2 >= window.innerWidth) {
          e2.scrollIntoView({
            block: "center",
            inline: "center"
          });
        }
      }
      var po = (function() {
        function e2(n2) {
          Fr(this, e2);
          Yr(this, "autoScrollEnabled", false);
          Yr(this, "referenceCoordinates", void 0);
          Yr(this, "listeners", void 0);
          Yr(this, "windowListeners", void 0);
          this.props = n2;
          var t2 = n2.event.target;
          this.props = n2;
          this.listeners = new Qr((0, Hn.getOwnerDocument)(t2));
          this.windowListeners = new Qr((0, Hn.getWindow)(t2));
          this.handleKeyDown = this.handleKeyDown.bind(this);
          this.handleCancel = this.handleCancel.bind(this);
          this.attach();
        }
        Xr(e2, [{
          key: "attach",
          value: function e3() {
            var n2 = this;
            this.handleStart();
            this.windowListeners.add("resize", this.handleCancel);
            this.windowListeners.add("visibilitychange", this.handleCancel);
            setTimeout((function() {
              return n2.listeners.add("keydown", n2.handleKeyDown);
            }));
          }
        }, {
          key: "handleStart",
          value: function e3() {
            var n2 = this.props, t2 = n2.activeNode, r2 = n2.onStart;
            var o2 = t2.node.current;
            if (o2) {
              vo(o2);
            }
            r2(ao);
          }
        }, {
          key: "handleKeyDown",
          value: function e3(n2) {
            if ((0, Hn.isKeyboardEvent)(n2)) {
              var t2 = this.props, r2 = t2.active, i2 = t2.context, a2 = t2.options;
              var l2 = a2.keyboardCodes, u2 = l2 === void 0 ? fo : l2, s2 = a2.coordinateGetter, c2 = a2.scrollBehavior, d2 = c2 === void 0 ? "smooth" : c2;
              var f2 = n2.code;
              if (u2.end.includes(f2)) {
                this.handleEnd(n2);
                return;
              }
              if (u2.cancel.includes(f2)) {
                this.handleCancel(n2);
                return;
              }
              var v2 = i2.current.collisionRect;
              var p2 = v2 ? {
                x: v2.left,
                y: v2.top
              } : ao;
              if (!this.referenceCoordinates) {
                this.referenceCoordinates = p2;
              }
              var m2 = s2(n2, {
                active: r2,
                context: i2.current,
                currentCoordinates: p2
              });
              if (m2) {
                var b2 = (0, Hn.subtract)(m2, p2);
                var h2 = {
                  x: 0,
                  y: 0
                };
                var y2 = i2.current.scrollableAncestors;
                for (var g2 = 0; g2 < y2.length; g2 += 1) {
                  var w2 = y2[g2];
                  var C2 = n2.code;
                  var x2 = io(w2), S2 = x2.isTop, O2 = x2.isRight, k2 = x2.isLeft, R2 = x2.isBottom, E2 = x2.maxScroll, I2 = x2.minScroll;
                  var T2 = ro(w2);
                  var j2 = T2.top <= m2.y && T2.bottom >= m2.y + ((v2 === null || v2 === void 0 ? void 0 : v2.height) || 0);
                  var D2 = T2.left <= m2.x && T2.right >= m2.x + ((v2 === null || v2 === void 0 ? void 0 : v2.width) || 0);
                  var q2 = (C2 === o.KeyboardCode.Right && !O2 || C2 === o.KeyboardCode.Left && !k2) && !D2;
                  var A2 = (C2 === o.KeyboardCode.Down && !R2 || C2 === o.KeyboardCode.Up && !S2) && !j2;
                  if (q2) {
                    var P2 = w2.scrollLeft + b2.x;
                    var _2 = C2 === o.KeyboardCode.Right && P2 <= E2.x || C2 === o.KeyboardCode.Left && P2 >= I2.x;
                    if (_2 && !b2.y) {
                      w2.scrollTo({
                        left: P2,
                        behavior: d2
                      });
                      return;
                    }
                    if (_2) {
                      h2.x = w2.scrollLeft - P2;
                    } else {
                      h2.x = C2 === o.KeyboardCode.Right ? w2.scrollLeft - E2.x : w2.scrollLeft - I2.x;
                    }
                    if (h2.x) {
                      w2.scrollBy({
                        left: -h2.x,
                        behavior: d2
                      });
                    }
                    break;
                  } else if (A2) {
                    var z2 = w2.scrollTop + b2.y;
                    var M2 = C2 === o.KeyboardCode.Down && z2 <= E2.y || C2 === o.KeyboardCode.Up && z2 >= I2.y;
                    if (M2 && !b2.x) {
                      w2.scrollTo({
                        top: z2,
                        behavior: d2
                      });
                      return;
                    }
                    if (M2) {
                      h2.y = w2.scrollTop - z2;
                    } else {
                      h2.y = C2 === o.KeyboardCode.Down ? w2.scrollTop - E2.y : w2.scrollTop - I2.y;
                    }
                    if (h2.y) {
                      w2.scrollBy({
                        top: -h2.y,
                        behavior: d2
                      });
                    }
                    break;
                  }
                }
                this.handleMove(n2, (0, Hn.add)((0, Hn.subtract)(m2, this.referenceCoordinates), h2));
              }
            }
          }
        }, {
          key: "handleMove",
          value: function e3(n2, t2) {
            var r2 = this.props.onMove;
            n2.preventDefault();
            r2(t2);
          }
        }, {
          key: "handleEnd",
          value: function e3(n2) {
            var t2 = this.props.onEnd;
            n2.preventDefault();
            this.detach();
            t2();
          }
        }, {
          key: "handleCancel",
          value: function e3(n2) {
            var t2 = this.props.onCancel;
            n2.preventDefault();
            this.detach();
            t2();
          }
        }, {
          key: "detach",
          value: function e3() {
            this.listeners.removeAll();
            this.windowListeners.removeAll();
          }
        }]);
        return e2;
      })();
      Yr(po, "activators", [{
        eventName: "onKeyDown",
        handler: function e2(n2, t2, r2) {
          var o2 = t2.keyboardCodes, i2 = o2 === void 0 ? fo : o2, a2 = t2.onActivation;
          var l2 = r2.active;
          var u2 = n2.nativeEvent.code;
          if (i2.start.includes(u2)) {
            var s2 = l2.activatorNode.current;
            if (s2 && n2.target !== s2) {
              return false;
            }
            n2.preventDefault();
            a2 === null || a2 === void 0 ? void 0 : a2({
              event: n2.nativeEvent
            });
            return true;
          }
          return false;
        }
      }]);
      function mo(e2) {
        "@babel/helpers - typeof";
        return mo = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e3) {
          return typeof e3;
        } : function(e3) {
          return e3 && "function" == typeof Symbol && e3.constructor === Symbol && e3 !== Symbol.prototype ? "symbol" : typeof e3;
        }, mo(e2);
      }
      function bo(e2, n2) {
        var t2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var r2 = Object.getOwnPropertySymbols(e2);
          n2 && (r2 = r2.filter((function(n3) {
            return Object.getOwnPropertyDescriptor(e2, n3).enumerable;
          }))), t2.push.apply(t2, r2);
        }
        return t2;
      }
      function ho(e2) {
        for (var n2 = 1; n2 < arguments.length; n2++) {
          var t2 = null != arguments[n2] ? arguments[n2] : {};
          n2 % 2 ? bo(Object(t2), true).forEach((function(n3) {
            yo(e2, n3, t2[n3]);
          })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : bo(Object(t2)).forEach((function(n3) {
            Object.defineProperty(e2, n3, Object.getOwnPropertyDescriptor(t2, n3));
          }));
        }
        return e2;
      }
      function yo(e2, n2, t2) {
        return (n2 = go(n2)) in e2 ? Object.defineProperty(e2, n2, {
          value: t2,
          enumerable: true,
          configurable: true,
          writable: true
        }) : e2[n2] = t2, e2;
      }
      function go(e2) {
        var n2 = wo(e2, "string");
        return "symbol" == mo(n2) ? n2 : n2 + "";
      }
      function wo(e2, n2) {
        if ("object" != mo(e2) || !e2) return e2;
        var t2 = e2[Symbol.toPrimitive];
        if (void 0 !== t2) {
          var r2 = t2.call(e2, n2 || "default");
          if ("object" != mo(r2)) return r2;
          throw new TypeError("@@toPrimitive must return a primitive value.");
        }
        return ("string" === n2 ? String : Number)(e2);
      }
      function Co() {
        return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
      }
      function xo(e2) {
        return ho(ho({}, e2), {}, {
          top: e2.y,
          left: e2.x,
          right: e2.x + e2.width,
          bottom: e2.y + e2.height
        });
      }
      function So(e2, n2) {
        var t2, r2;
        var o2 = e2.getBoundingClientRect();
        var i2 = Co();
        if (!n2 || !i2) {
          return o2;
        }
        var a2 = sn();
        var l2 = o2.left + (((t2 = a2.visualViewport) === null || t2 === void 0 ? void 0 : t2.offsetLeft) || 0);
        var u2 = o2.top + (((r2 = a2.visualViewport) === null || r2 === void 0 ? void 0 : r2.offsetTop) || 0);
        var s2 = o2.width, c2 = o2.height;
        return xo({
          width: s2,
          height: c2,
          x: l2,
          y: u2
        });
      }
      function Oo(e2, n2) {
        if (e2 === void 0 || e2 === null) {
          throw new Error(n2 !== null && n2 !== void 0 ? n2 : "Unexpected undefined or null");
        }
      }
      function ko() {
        return ko = Object.assign ? Object.assign.bind() : function(e2) {
          for (var n2 = 1; n2 < arguments.length; n2++) {
            var t2 = arguments[n2];
            for (var r2 in t2) {
              ({}).hasOwnProperty.call(t2, r2) && (e2[r2] = t2[r2]);
            }
          }
          return e2;
        }, ko.apply(null, arguments);
      }
      function Ro(e2) {
        return To(e2) || Io(e2) || qo(e2) || Eo();
      }
      function Eo() {
        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      function Io(e2) {
        if ("undefined" != typeof Symbol && null != e2[Symbol.iterator] || null != e2["@@iterator"]) return Array.from(e2);
      }
      function To(e2) {
        if (Array.isArray(e2)) return Ao(e2);
      }
      function jo(e2, n2) {
        return _o(e2) || Po(e2, n2) || qo(e2, n2) || Do();
      }
      function Do() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      function qo(e2, n2) {
        if (e2) {
          if ("string" == typeof e2) return Ao(e2, n2);
          var t2 = {}.toString.call(e2).slice(8, -1);
          return "Object" === t2 && e2.constructor && (t2 = e2.constructor.name), "Map" === t2 || "Set" === t2 ? Array.from(e2) : "Arguments" === t2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t2) ? Ao(e2, n2) : void 0;
        }
      }
      function Ao(e2, n2) {
        (null == n2 || n2 > e2.length) && (n2 = e2.length);
        for (var t2 = 0, r2 = Array(n2); t2 < n2; t2++) {
          r2[t2] = e2[t2];
        }
        return r2;
      }
      function Po(e2, n2) {
        var t2 = null == e2 ? null : "undefined" != typeof Symbol && e2[Symbol.iterator] || e2["@@iterator"];
        if (null != t2) {
          var r2, o2, i2, a2, l2 = [], u2 = true, s2 = false;
          try {
            if (i2 = (t2 = t2.call(e2)).next, 0 === n2) {
              if (Object(t2) !== t2) return;
              u2 = false;
            } else for (; !(u2 = (r2 = i2.call(t2)).done) && (l2.push(r2.value), l2.length !== n2); u2 = true) {
            }
          } catch (e3) {
            s2 = true, o2 = e3;
          } finally {
            try {
              if (!u2 && null != t2["return"] && (a2 = t2["return"](), Object(a2) !== a2)) return;
            } finally {
              if (s2) throw o2;
            }
          }
          return l2;
        }
      }
      function _o(e2) {
        if (Array.isArray(e2)) return e2;
      }
      function zo(e2, n2) {
        if (null == e2) return {};
        var t2, r2, o2 = Mo(e2, n2);
        if (Object.getOwnPropertySymbols) {
          var i2 = Object.getOwnPropertySymbols(e2);
          for (r2 = 0; r2 < i2.length; r2++) {
            t2 = i2[r2], -1 === n2.indexOf(t2) && {}.propertyIsEnumerable.call(e2, t2) && (o2[t2] = e2[t2]);
          }
        }
        return o2;
      }
      function Mo(e2, n2) {
        if (null == e2) return {};
        var t2 = {};
        for (var r2 in e2) {
          if ({}.hasOwnProperty.call(e2, r2)) {
            if (-1 !== n2.indexOf(r2)) continue;
            t2[r2] = e2[r2];
          }
        }
        return t2;
      }
      var $o = {
        actions: C().arrayOf(C().element),
        actionsColumnWidth: C().number,
        children: C().node,
        dockOffset: C().number,
        dockScrollBar: C().bool,
        elementRef: C().oneOfType([C().func, C().object]),
        headType: C().oneOf(["docked", "fixed", "inline"]),
        innerStyle: C().object,
        onRequestToggleAllRows: C().func,
        onScroll: C().func,
        outerStyle: C().object,
        primaryColumnIndex: C().number,
        rowExpansion: C().oneOf(["single", "multi", "controlled", "none"]),
        rowSelection: C().oneOf(["all", "some", "none"]),
        stripeRows: C().bool,
        tableStyle: C().object,
        onRequestMoveColumn: C().func,
        onRequestMoveRow: C().func,
        onRequestResizeColumn: C().func,
        resizableFillLayout: C().bool
      };
      var No = function e2(n2) {
        return n2 === "inline";
      };
      var Lo = function e2(n2) {
        return n2 === "docked";
      };
      var Wo = function e2(n2) {
        return n2 === "fixed";
      };
      var Ho = function e2(n2) {
        var t2 = sn();
        var r2 = So(n2);
        return {
          top: r2.top + t2.pageYOffset,
          left: r2.left + t2.pageXOffset
        };
      };
      var Ko = function e2(n2) {
        var t2 = on();
        if (n2 === void 0 || n2 === null) {
          return void 0;
        }
        var r2 = n2.children[0].children;
        var o2 = f()(r2, t2.activeElement);
        if (o2 > -1) {
          return {
            target: "headCell",
            index: o2
          };
        }
        var i2 = n2.querySelectorAll("[data-test=resize]");
        var a2 = f()(i2, t2.activeElement);
        if (a2 > -1) {
          return {
            target: "resizeButton",
            index: a2
          };
        }
        return void 0;
      };
      var Bo = function e2(n2, t2) {
        return n2.indexOf(t2) + 1;
      };
      var Vo = function e2(n2, t2) {
        return n2.indexOf(t2) + 1;
      };
      var Fo = {
        coordinateGetter: a.sortableKeyboardCoordinates
      };
      var Uo = {
        draggable: (0, j._)("To pick up a sortable row, press space or enter.\n            Use the up and down arrow keys to update the position of the row.\n            Press space or enter again to drop the row in its new position, or press escape to cancel.")
      };
      var Xo = {
        draggable: (0, j._)("To pick up a sortable column, press space or enter.\n            Use the left and right arrow keys to update the position of the column.\n            Press space or enter again to drop the column in its new position, or press escape to cancel.")
      };
      function Yo(e2, n2) {
        var t2, r2;
        var o2 = n2.target, i2 = n2.index;
        if (false) {
        }
        var a2;
        if (o2 === "headCell") {
          a2 = e2 === null || e2 === void 0 ? void 0 : e2.children[0].children[i2];
        } else if (o2 === "resizeButton") {
          a2 = e2 === null || e2 === void 0 ? void 0 : e2.querySelectorAll("[data-test=resize]")[i2];
        }
        if (false) {
        }
        (t2 = a2) === null || t2 === void 0 ? void 0 : (r2 = t2.focus) === null || r2 === void 0 ? void 0 : r2.call(t2);
      }
      var Go = {
        passive: false,
        capture: true
      };
      var Jo = [];
      function Qo(e2) {
        var n2 = e2.actions, l2 = n2 === void 0 ? Jo : n2, s2 = e2.actionsColumnWidth, d2 = e2.children, f2 = e2.dockOffset, v2 = f2 === void 0 ? 0 : f2, m2 = e2.dockScrollBar, b2 = e2.elementRef, y2 = e2.headType, w2 = y2 === void 0 ? "inline" : y2, C2 = e2.innerStyle, x2 = e2.onRequestMoveColumn, k2 = e2.onRequestMoveRow, E2 = e2.onRequestResizeColumn, q2 = e2.onRequestToggleAllRows, A2 = e2.onScroll, P2 = e2.outerStyle, _2 = e2.primaryColumnIndex, z2 = _2 === void 0 ? 0 : _2, M2 = e2.resizableFillLayout, $3 = e2.rowExpansion, N2 = $3 === void 0 ? "none" : $3, W2 = e2.rowSelection, H2 = W2 === void 0 ? "none" : W2, K2 = e2.stripeRows, B2 = e2.tableStyle, V2 = zo(e2, ["actions", "actionsColumnWidth", "children", "dockOffset", "dockScrollBar", "elementRef", "headType", "innerStyle", "onRequestMoveColumn", "onRequestMoveRow", "onRequestResizeColumn", "onRequestToggleAllRows", "onScroll", "outerStyle", "primaryColumnIndex", "resizableFillLayout", "rowExpansion", "rowSelection", "stripeRows", "tableStyle"]);
        var F2 = (0, t.useState)([]), U2 = jo(F2, 2), X2 = U2[0], Y2 = U2[1];
        var G2 = (0, t.useState)(), J2 = jo(G2, 2), Q2 = J2[0], oe2 = J2[1];
        var le2 = (0, t.useState)(), ue2 = jo(le2, 2), se2 = ue2[0], ce2 = ue2[1];
        var de2 = (0, t.useState)(), fe2 = jo(de2, 2), ve2 = fe2[0], pe2 = fe2[1];
        var me2 = (0, t.useState)(), be2 = jo(me2, 2), he2 = be2[0], ye2 = be2[1];
        var ge2 = (0, t.useRef)(true);
        var we2 = (0, t.useContext)(O.ScrollContainerContext);
        var Ce2 = (0, o.useSensors)((0, o.useSensor)(o.MouseSensor, {}), (0, o.useSensor)(o.TouchSensor, {}), (0, o.useSensor)(po, Fo));
        var xe2 = (0, t.useState)([]), Se2 = jo(xe2, 2), Oe2 = Se2[0], ke2 = Se2[1];
        var Re2 = (0, t.useState)(-1), Ee2 = jo(Re2, 2), Ie2 = Ee2[0], Te2 = Ee2[1];
        var je2 = (0, t.useRef)();
        var De2 = (0, t.useRef)();
        var qe2 = (0, t.useState)(), Ae2 = jo(qe2, 2), Pe2 = Ae2[0], _e2 = Ae2[1];
        var ze2 = (0, t.useRef)(null);
        var Me2 = (0, t.useRef)(null);
        var $e2 = (0, t.useRef)();
        var Ne2 = (0, t.useRef)(null);
        var Le2 = (0, t.useRef)();
        var We2 = (0, t.useRef)(null);
        var He2 = (0, t.useRef)(null);
        var Ke2 = R()(w2);
        var Be2 = (0, t.useRef)([]);
        var Ve2 = (0, t.useRef)([]);
        var Fe2 = (0, t.useRef)([]);
        var Ue2 = (0, t.useRef)([]);
        var Xe2 = Ve2.current;
        var Ye2 = Be2.current;
        var Ge2 = Ue2.current;
        var Je2 = (0, t.useCallback)((function() {
          var e3;
          var n3 = sn();
          if (No(w2)) {
            return;
          }
          var t2 = He2.current;
          var r2 = Me2.current;
          var o2 = We2.current;
          if (!o2 || !r2) {
            return;
          }
          var i2 = Zt(Me2.current);
          var a2 = (e3 = Me2.current) === null || e3 === void 0 ? void 0 : e3.clientHeight;
          var l3 = Ho(o2).top - n3.pageYOffset - (a2 || 0) + o2.offsetHeight;
          var u2 = Math.min(l3, Number(v2));
          ye2(t2 === null || t2 === void 0 ? void 0 : t2.clientWidth);
          ce2(o2 === null || o2 === void 0 ? void 0 : o2.clientWidth);
          Y2(i2);
          pe2(u2);
        }), [v2, w2]);
        (0, t.useEffect)((function() {
          var e3 = Me2.current;
          var n3 = Ne2.current;
          if (e3 && n3) {
            var t2 = Zt(Me2.current);
            if (!p()(X2, t2)) {
              Je2();
            }
          }
          if (Ke2 === "inline" && w2 === "inline") {
            Je2();
          }
          if (false) {
          }
        }), [X2, w2, Ke2, e2, Je2]);
        var Qe2 = (0, t.useCallback)((function(e3) {
          var n3 = He2.current;
          A2 === null || A2 === void 0 ? void 0 : A2(e3);
          if ((Wo(w2) || Lo(w2)) && n3) {
            oe2(-n3.scrollLeft);
          }
          if (ze2.current && Le2.current !== "dockedScrollBar" && n3) {
            Le2.current = "container";
            ze2.current.scrollLeft = n3.scrollLeft;
          } else {
            Le2.current = void 0;
          }
        }), [w2, A2]);
        var Ze2 = function e3() {
          var n3 = He2.current;
          if (Le2.current !== "container" && n3 && ze2.current) {
            Le2.current = "dockedScrollBar";
            n3.scrollLeft = ze2.current.scrollLeft;
          } else {
            Le2.current = void 0;
          }
        };
        var en2 = g()(Je2, 0);
        var nn2 = (0, t.useCallback)((function() {
          Je2();
        }), [Je2]);
        var tn2 = (0, t.useMemo)((function() {
          return g()(nn2, 50);
        }), [nn2]);
        I()(He2, tn2);
        (0, t.useEffect)((function() {
          return function() {
            en2.cancel();
            tn2.cancel();
          };
        }));
        var rn2 = function e3(n3) {
          return function(e4) {
            Me2.current = e4;
            L(n3.props.elementRef, e4);
          };
        };
        var an2 = function e3(n3) {
          if (n3) {
            if ($e2.current) {
              Yo(Ne2.current, $e2.current);
              $e2.current = void 0;
            }
          } else {
            var t2 = Ko(Ne2.current);
            if (t2) {
              Yo(Me2.current, t2);
            }
          }
          Ne2.current = n3;
        };
        var ln2 = function e3(n3) {
          var t2 = He2.current;
          if (!Ne2.current || !t2 || n3.key !== "Tab") {
            return;
          }
          var r2 = Ne2.current.scrollLeft;
          if (r2 !== 0) {
            Ne2.current.scrollLeft = 0;
            t2.scrollLeft += r2;
          }
        };
        var un2 = function e3(n3, t2) {
          var r2, o2;
          var i2 = t2.columnId, a2 = t2.index, l3 = t2.id;
          var s3 = on();
          if (a2 === void 0) {
            return;
          }
          var c2 = N2 === "none" ? 1 : 2;
          var d3 = (r2 = He2.current) === null || r2 === void 0 ? void 0 : r2.querySelectorAll("thead th:nth-child(".concat(a2 + c2, "), tbody td:nth-child(").concat(a2 + c2, ")"));
          var f3 = s3.createElement("div");
          f3.style["float"] = "left";
          f3.style.position = "fixed";
          f3.style.top = "-100";
          f3.style.left = "0";
          f3.style.maxHeight = "10px";
          f3.style.overflow = "hidden";
          u()(d3, (function(e4) {
            var n4 = e4.cloneNode(true);
            n4.style.display = "block";
            n4.style.width = "auto";
            f3.appendChild(n4);
          }));
          s3.body.appendChild(f3);
          E2 === null || E2 === void 0 ? void 0 : E2(n3, {
            columnId: i2,
            id: l3,
            index: a2,
            width: f3.clientWidth + 1
          });
          (o2 = f3.parentNode) === null || o2 === void 0 ? void 0 : o2.removeChild(f3);
        };
        var cn2 = (0, t.useCallback)((function(e3) {
          var n3 = e3.active;
          var t2 = n3.id;
          je2.current = Ge2.indexOf(t2);
          _e2(t2);
        }), [Ge2]);
        var dn2 = (0, t.useCallback)((function(e3) {
          if (e3.over) {
            var n3 = e3.over.id;
            var t2 = Ge2.indexOf(n3);
            var r2 = t2;
            if (je2.current !== void 0 && t2 > je2.current) {
              r2 = t2 + 1;
            }
            Te2(r2);
          } else {
            Te2(-1);
          }
        }), [Ge2]);
        var fn2 = (0, t.useMemo)((function() {
          return g()(dn2, 100);
        }), [dn2]);
        (0, t.useEffect)((function() {
          return function() {
            fn2.cancel();
          };
        }), [fn2]);
        var vn2 = (0, t.useCallback)((function(e3) {
          var n3 = e3.active, t2 = e3.over;
          if (t2 && n3.id !== t2.id) {
            var r2 = Ge2.indexOf(n3.id);
            var o2 = Ge2.indexOf(t2 === null || t2 === void 0 ? void 0 : t2.id);
            x2 === null || x2 === void 0 ? void 0 : x2({
              fromIndex: r2,
              toIndex: o2
            });
          }
          _e2(void 0);
          Te2(-1);
          De2.current = void 0;
          je2.current = void 0;
        }), [Ge2, x2]);
        var pn2 = (0, t.useCallback)((function(e3) {
          var n3 = e3.active, t2 = e3.over;
          ge2.current = true;
          if (t2 && n3.id !== t2.id) {
            var r2 = Xe2.indexOf(n3.id);
            var o2 = Xe2.indexOf(t2 === null || t2 === void 0 ? void 0 : t2.id);
            k2 === null || k2 === void 0 ? void 0 : k2({
              fromIndex: r2,
              toIndex: o2
            });
          }
        }), [Xe2, k2]);
        var mn2 = (0, t.useCallback)((function() {
          ge2.current = true;
        }), []);
        var bn2 = (0, t.useRef)({});
        var hn2 = function e3(n3) {
          var r2 = [];
          var o2 = [];
          var i2 = t.Children.toArray(n3.props.children).filter(t.isValidElement).map((function(e4, n4) {
            var i3 = e4;
            var a3 = i3.key || (0, D.createDOMID)("col-");
            a3 = String(a3);
            if (!a3.startsWith("col-")) {
              a3 = "col-".concat(a3);
            }
            r2.push(i3);
            o2.push(a3);
            return (0, t.cloneElement)(i3, {
              index: n4,
              dragId: a3,
              elementRef: function e5(n5) {
                bn2.current[a3] = n5;
                L(i3.props.elementRef, n5);
              }
            });
          }));
          Fe2.current = r2;
          Ge2 = o2;
          var a2 = l2 === null || l2 === void 0 ? void 0 : l2.filter(t.isValidElement);
          var u2 = (0, t.cloneElement)(n3, {
            actions: a2,
            actionsColumnWidth: s2,
            hasInfoColumn: N2 !== "none",
            hasDragColumn: !!k2,
            onAutosizeColumn: un2,
            onRequestMoveColumn: x2,
            onRequestResizeColumn: E2,
            onRequestToggleAllRows: q2,
            elementRef: rn2(n3),
            rowSelection: H2
          }, i2);
          return u2;
        };
        var yn2 = (0, t.useMemo)((function() {
          var e3, n3;
          if (Ie2 === -1 || !Me2.current || !He2.current) return null;
          var t2 = !!k2;
          var o2 = N2 !== "none";
          var i2 = Array.from((e3 = (n3 = Me2.current.firstElementChild) === null || n3 === void 0 ? void 0 : n3.children) !== null && e3 !== void 0 ? e3 : []).slice(o2 ? 1 : 0).slice(t2 ? 1 : 0).slice(q2 ? 1 : 0);
          var a2;
          if (Ie2 === 0) {
            var l3;
            a2 = ((l3 = i2[0]) === null || l3 === void 0 ? void 0 : l3.offsetLeft) || 0;
          } else if (Ie2 >= i2.length) {
            var u2 = i2[i2.length - 1];
            a2 = ((u2 === null || u2 === void 0 ? void 0 : u2.offsetLeft) || 0) + ((u2 === null || u2 === void 0 ? void 0 : u2.offsetWidth) || 0) - 1;
          } else {
            var s3;
            a2 = ((s3 = i2[Ie2]) === null || s3 === void 0 ? void 0 : s3.offsetLeft) || 0;
          }
          return r().createElement(ae, {
            $height: He2.current.clientHeight,
            $left: a2
          });
        }), [Ie2, k2, N2, q2]);
        var gn2 = function e3(n3) {
          var r2 = (l2 === null || l2 === void 0 ? void 0 : l2.filter(t.isValidElement).length) > 0;
          var o2 = false;
          var i2 = [];
          var a2 = [];
          t.Children.toArray(n3 === null || n3 === void 0 ? void 0 : n3.props.children).filter(t.isValidElement).forEach((function(e4, n4) {
            var r3, l3;
            if (((r3 = e4.props) === null || r3 === void 0 ? void 0 : r3.actionPrimary) || ((l3 = e4.props) === null || l3 === void 0 ? void 0 : l3.actionsSecondary)) {
              o2 = true;
            }
            var u3 = e4.key || (0, D.createDOMID)("row-");
            u3 = String(u3);
            if (!u3.startsWith("row-")) {
              u3 = "row-".concat(u3);
            }
            i2.push((0, t.cloneElement)(e4, {
              index: n4,
              dragId: u3
            }));
            a2.push(u3);
          }));
          var u2 = r2 || o2 || !!s2;
          Ye2 = i2;
          Xe2 = a2;
          return (0, t.cloneElement)(n3, {
            actions: u2,
            movableColumns: !!x2,
            onRequestMoveRow: k2,
            primaryColumnIndex: z2,
            rowExpansion: N2,
            stripeRows: K2
          }, Ye2);
        };
        var wn2 = function e3() {
          var n3 = He2.current;
          var t2 = sn();
          if (!Lo(w2) || !We2.current || !Me2.current || !n3) {
            return false;
          }
          var r2 = Ho(n3).top;
          return t2.pageYOffset >= r2 - (v2 || 0);
        };
        var Cn2 = function e3() {
          var n3 = sn();
          var t2 = He2.current;
          if (!m2 || !We2.current || !t2) {
            return false;
          }
          var r2 = So(t2);
          return r2.bottom > n3.innerHeight && r2.top < n3.innerHeight;
        };
        var xn2 = function e3(n3, o2) {
          if (wn2()) {
            $e2.current = Ko(Me2.current);
            if (X2 === void 0 || se2 === void 0 || ve2 === void 0 || he2 === void 0) {
              return false;
            }
            var i2 = (0, t.cloneElement)(n3);
            return r().createElement(Pr, {
              headType: "docked",
              tHead: i2,
              cellWidths: X2,
              horizontalOffset: Q2,
              tableWidth: se2,
              top: ve2,
              width: he2,
              tableStyle: B2,
              isFixedColumn: o2,
              onKeyUp: ln2,
              elementRef: an2,
              hasDragColumn: !!k2,
              hasRowExpansion: N2 !== "none",
              hasRowSelection: !!q2
            });
          }
          return false;
        };
        var Sn2 = (0, t.useMemo)((function() {
          var e3, n3, t2;
          if (!ze2.current || !Me2.current || !We2.current) {
            return 0;
          }
          var r2 = sn();
          var o2 = (e3 = So(We2.current).top) !== null && e3 !== void 0 ? e3 : 0;
          var i2 = (n3 = (t2 = Me2.current) === null || t2 === void 0 ? void 0 : t2.offsetHeight) !== null && n3 !== void 0 ? n3 : 0;
          var a2 = r2.innerHeight - o2 - i2;
          return Math.min(a2 - ze2.current.offsetHeight, 0);
        }), []);
        var On2 = (0, t.useMemo)((function() {
          return {
            width: he2,
            marginBottom: Sn2
          };
        }), [he2, Sn2]);
        var kn2 = (0, t.useMemo)((function() {
          return {
            width: se2
          };
        }), [se2]);
        var Rn2 = function e3() {
          if (!Cn2()) {
            return false;
          }
          return r().createElement(te, {
            style: On2,
            onScroll: Ze2,
            "data-test": "docked-scroll-bar",
            ref: ze2
          }, r().createElement(re, {
            style: kn2,
            "data-test": "docked-scroll-content"
          }));
        };
        var En2 = function e3() {
          var n3 = Me2.current;
          var t2 = He2.current;
          if (n3) {
            var r2 = Zt(Me2.current);
            var o2 = r2 === null || r2 === void 0 ? void 0 : r2.length;
            var i2 = t2 === null || t2 === void 0 ? void 0 : t2.clientWidth;
            if (i2 != null) {
              var a2 = Math.max(0, o2 - 1);
              return i2 - a2;
            }
          }
          return null;
        };
        var In2;
        var Tn2;
        var jn2;
        var Dn2 = !!E2;
        t.Children.toArray(d2).forEach((function(e3) {
          var n3 = e3.type.splunkUiType;
          if (n3 === "Table.Head") {
            In2 = hn2(e3);
            if (!Dn2) {
              Dn2 = !t.Children.toArray(e3.props.children).filter(t.isValidElement).some((function(e4) {
                return !c()(e4.props, "width");
              }));
            }
          } else if (n3 === "Table.Body") {
            Tn2 = gn2(e3);
          } else if (n3 === "Table.Caption") {
            jn2 = e3;
          }
        }));
        Oo(In2, "A Table.Head is required.");
        var qn2 = xn2(In2, Dn2);
        var An2 = t.Children.toArray(In2.props.children).filter(t.isValidElement).map((function(e3) {
          return (0, t.cloneElement)(e3, {
            visible: !qn2
          });
        }));
        In2 = (0, t.cloneElement)(In2, {}, An2);
        var Pn2 = we2 || sn();
        var _n2 = Wo(w2) ? He2.current : Pn2;
        if (M2) {
          Dn2 = false;
        }
        var zn2 = En2();
        var Mn2 = (0, t.useMemo)((function() {
          return {
            headType: w2,
            resizableFillLayout: M2,
            tableContainerWidthWithoutBorders: zn2
          };
        }), [w2, M2, zn2]);
        var $n2 = (0, t.useMemo)((function() {
          if (!k2) {
            return {
              onDragStart: function e3() {
                return void 0;
              },
              onDragOver: function e3() {
                return void 0;
              },
              onDragEnd: function e3() {
                return void 0;
              },
              onDragCancel: function e3() {
                return void 0;
              }
            };
          }
          return {
            onDragStart: function e3(n3) {
              var t2 = n3.active.id;
              if (t2 === void 0) {
                return void 0;
              }
              var r2 = Bo(Xe2, t2);
              return typeof r2 === "number" ? (0, T.sprintf)((0, j._)("Picked up sortable row in position %(pos)d of %(total)d."), {
                pos: r2,
                total: Xe2.length
              }) : void 0;
            },
            onDragOver: function e3(n3) {
              var t2 = n3.active, r2 = n3.over;
              if (ge2.current) {
                ge2.current = false;
                return void 0;
              }
              if (!t2.id || !(r2 === null || r2 === void 0 ? void 0 : r2.id)) {
                return void 0;
              }
              var o2 = Bo(Xe2, t2.id);
              var i2 = Bo(Xe2, r2.id);
              return (0, T.sprintf)((0, j._)("Row moved from position %(from)d to position %(to)d of %(total)d."), {
                from: o2,
                to: i2,
                total: Xe2.length
              });
            },
            onDragEnd: function e3(n3) {
              var t2 = n3.over;
              if (!(t2 === null || t2 === void 0 ? void 0 : t2.id)) {
                return void 0;
              }
              var r2 = Bo(Xe2, t2.id);
              return typeof r2 === "number" ? (0, T.sprintf)((0, j._)("Row dropped at position %(pos)d of %(total)d."), {
                pos: r2,
                total: Xe2.length
              }) : void 0;
            },
            onDragCancel: function e3(n3) {
              var t2 = n3.active.id;
              if (t2 === void 0) {
                return void 0;
              }
              var r2 = Bo(Xe2, t2);
              return typeof r2 === "number" ? (0, T.sprintf)((0, j._)("Row returned to its starting position of %(pos)d."), {
                pos: r2
              }) : void 0;
            }
          };
        }), [Xe2, k2]);
        var Nn2 = (0, t.useMemo)((function() {
          if (!x2) {
            return {
              onDragStart: function e3() {
                return void 0;
              },
              onDragOver: function e3() {
                return void 0;
              },
              onDragEnd: function e3() {
                return void 0;
              },
              onDragCancel: function e3() {
                return void 0;
              }
            };
          }
          return {
            onDragStart: function e3(n3) {
              var t2 = n3.active.id;
              if (t2 === void 0) {
                return void 0;
              }
              var r2 = Vo(Ge2, t2);
              return typeof r2 === "number" ? (0, T.sprintf)((0, j._)("Picked up sortable column in position %(pos)d of %(total)d."), {
                pos: r2,
                total: Ge2.length
              }) : void 0;
            },
            onDragOver: function e3(n3) {
              var t2 = n3.active, r2 = n3.over;
              if (ge2.current) {
                ge2.current = false;
                return void 0;
              }
              if (!t2.id || !(r2 === null || r2 === void 0 ? void 0 : r2.id)) {
                return void 0;
              }
              var o2 = Vo(Ge2, t2.id);
              var i2 = Vo(Ge2, r2.id);
              if (typeof o2 !== "number" || typeof i2 !== "number") return void 0;
              return (0, T.sprintf)((0, j._)("Column moved from position %(from)d to position %(to)d of %(total)d."), {
                from: o2,
                to: i2,
                total: Ge2.length
              });
            },
            onDragEnd: function e3(n3) {
              var t2 = n3.over;
              if (!(t2 === null || t2 === void 0 ? void 0 : t2.id)) {
                return void 0;
              }
              var r2 = Vo(Ge2, t2.id);
              return typeof r2 === "number" ? (0, T.sprintf)((0, j._)("Column dropped at position %(pos)d of %(total)d."), {
                pos: r2,
                total: Ge2.length
              }) : void 0;
            },
            onDragCancel: function e3(n3) {
              var t2 = n3.active.id;
              if (t2 === void 0) {
                return void 0;
              }
              var r2 = Vo(Ge2, t2);
              return typeof r2 === "number" ? (0, T.sprintf)((0, j._)("Column returned to its starting position of %(pos)d."), {
                pos: r2
              }) : void 0;
            }
          };
        }), [Ge2, x2]);
        var Ln2 = (0, t.useMemo)((function() {
          return {
            screenReaderInstructions: k2 ? Uo : Xo,
            announcements: k2 ? $n2 : Nn2
          };
        }), [$n2, Nn2, k2]);
        var Wn2 = (0, t.useCallback)((function(e3) {
          var n3 = e3.active.id;
          if (n3.startsWith("col-") && x2) {
            ke2([i.restrictToHorizontalAxis]);
            cn2(e3);
          } else if (n3.startsWith("row-") && k2) {
            ke2([i.restrictToVerticalAxis]);
          }
        }), [x2, k2, cn2]);
        var Hn2 = (0, t.useCallback)((function(e3) {
          ke2([]);
          var n3 = e3.active.id;
          if (n3.startsWith("col-") && x2) {
            vn2(e3);
          } else if (n3.startsWith("row-") && k2) {
            pn2(e3);
          }
        }), [vn2, pn2, x2, k2]);
        var Kn2 = (0, t.useCallback)((function(e3) {
          var n3 = e3.active.id;
          if (n3.startsWith("col-") && x2) {
            fn2(e3);
          }
        }), [fn2, x2]);
        var Bn2 = (0, t.useCallback)((function(e3) {
          ke2([]);
          var n3 = e3.active.id;
          if (n3.startsWith("row-") && k2) {
            mn2();
          }
        }), [mn2, k2]);
        var Vn2 = (0, t.useMemo)((function() {
          return function(e3) {
            var n3 = (0, o.pointerWithin)(e3);
            if (n3.length > 0) {
              return n3;
            }
            return (0, o.rectIntersection)(e3);
          };
        }), []);
        var Fn2 = Pe2 ? bn2.current[Pe2] : null;
        var Un2 = Fn2 ? So(Fn2).width : void 0;
        var Xn2 = He2.current ? So(He2.current).height : void 0;
        return r().createElement(Z, ko({
          "data-test": "table",
          ref: b2,
          style: P2,
          "data-test-row-selection": q2 ? H2 : void 0
        }, h()(V2, [].concat(Ro(Object.keys($o)), ["style"]))), r().createElement(S(), {
          target: sn(),
          eventType: "scroll",
          listener: en2,
          options: Go
        }), r().createElement(Kt.Provider, {
          value: Mn2
        }, qn2, r().createElement(ee, {
          "data-test": "scroll-container",
          onScroll: Qe2,
          ref: He2,
          style: C2,
          $dragging: !!Pe2
        }, r().createElement(O.ScrollContainerProvider, {
          value: _n2
        }, r().createElement(o.DndContext, {
          accessibility: Ln2,
          collisionDetection: Vn2,
          modifiers: Oe2,
          onDragCancel: Bn2,
          onDragEnd: Hn2,
          onDragOver: Kn2,
          onDragStart: Wn2,
          sensors: Ce2
        }, r().createElement(ne, {
          ref: We2,
          "data-test": "main-table",
          style: B2,
          "data-fixed-column": Dn2 ? "true" : void 0,
          $resizableFillLayout: M2
        }, jn2, x2 ? r().createElement(a.SortableContext, {
          items: Ge2,
          strategy: a.horizontalListSortingStrategy
        }, In2) : In2, k2 ? r().createElement(a.SortableContext, {
          items: Xe2,
          strategy: a.verticalListSortingStrategy
        }, Tn2) : Tn2), Pe2 && r().createElement(o.DragOverlay, null, r().createElement(ie, {
          $width: Un2,
          $height: Xn2
        })), Pe2 && yn2))), Rn2()));
      }
      Qo.propTypes = $o;
      Qo.Body = Q;
      Qo.Caption = fe;
      Qo.Cell = Se;
      Qo.Head = nr;
      Qo.HeadCell = Mn;
      Qo.HeadDropdownCell = Sr;
      Qo.Row = Wt;
      const Zo = Qo;
      module.exports = n;
    })();
  }
});

// node_modules/@splunk/react-ui/TextArea.js
var require_TextArea = __commonJS({
  "node_modules/@splunk/react-ui/TextArea.js"(exports, module) {
    var import_dist466 = __toESM(require_dist());
    var import_dist467 = __toESM(require_dist2());
    var import_dist468 = __toESM(require_dist3());
    (() => {
      "use strict";
      var e = {
        /***/
        3639: (
          /***/
          (e2, r2, t2) => {
            t2.d(r2, {
              default: () => (
                /* reexport */
                s
              )
            });
            var n2 = t2(9497);
            const o = require_isEqual();
            var a = t2(5919);
            var i = t2.n(a);
            function l(e3) {
              return e3 === null || e3 === void 0 || typeof e3 === "boolean" || typeof e3 === "string" || typeof e3 === "number";
            }
            function u(e3) {
              if (l(e3)) {
                return true;
              }
              if (Array.isArray(e3)) {
                return e3.every(l);
              }
              return false;
            }
            function c(e3) {
              var r3 = e3.componentProps, t3 = e3.componentName, o2 = t3 === void 0 ? "this component" : t3, a2 = e3.defaultValuePropName, l2 = a2 === void 0 ? "defaultValue" : a2, u2 = e3.valuePropName, c2 = u2 === void 0 ? "value" : u2;
              var s2 = (0, n2.useRef)(i()(r3, c2));
              var d = (0, n2.useRef)(r3[l2]);
              (0, n2.useEffect)((function() {
                if (false) {
                }
              }), [o2, r3, l2, c2]);
              (0, n2.useEffect)((function() {
                if (false) {
                }
                if (false) {
                }
                if (false) {
                }
              }), [o2, r3, l2, c2]);
              return s2.current;
            }
            const s = c;
          }
        ),
        /***/
        5919: (
          /***/
          (e2) => {
            e2.exports = require_has();
          }
        ),
        /***/
        9497: (
          /***/
          (e2) => {
            e2.exports = require_react();
          }
        )
      };
      var r = {};
      function t(n2) {
        var o = r[n2];
        if (o !== void 0) {
          return o.exports;
        }
        var a = r[n2] = {
          /******/
          // no module.id needed
          /******/
          // no module.loaded needed
          /******/
          exports: {}
          /******/
        };
        e[n2](a, a.exports, t);
        return a.exports;
      }
      (() => {
        t.n = (e2) => {
          var r2 = e2 && e2.__esModule ? (
            /******/
            () => e2["default"]
          ) : () => e2;
          t.d(r2, {
            a: r2
          });
          return r2;
        };
      })();
      (() => {
        t.d = (e2, r2) => {
          for (var n2 in r2) {
            if (t.o(r2, n2) && !t.o(e2, n2)) {
              Object.defineProperty(e2, n2, {
                enumerable: true,
                get: r2[n2]
              });
            }
          }
        };
      })();
      (() => {
        t.o = (e2, r2) => Object.prototype.hasOwnProperty.call(e2, r2);
      })();
      (() => {
        t.r = (e2) => {
          if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
            Object.defineProperty(e2, Symbol.toStringTag, {
              value: "Module"
            });
          }
          Object.defineProperty(e2, "__esModule", {
            value: true
          });
        };
      })();
      var n = {};
      (() => {
        t.r(n);
        t.d(n, {
          default: () => (
            /* reexport */
            ue
          )
        });
        var e2 = t(9497);
        var r2 = t.n(e2);
        const o = require_keys();
        var a = t.n(o);
        const i = require_omit();
        var l = t.n(i);
        const u = require_pickBy();
        var c = t.n(u);
        const s = require_throttle();
        var d = t.n(s);
        const f = require_prop_types();
        var p = t.n(f);
        const v = require_EventListener();
        var b = t.n(v);
        function m(e3) {
          var r3 = e3.height, t2 = e3.rowsMax, n2 = e3.rowsMin, o2 = e3.shadow;
          if (o2) {
            var a2 = window.getComputedStyle(o2);
            var i2 = a2.getPropertyValue("line-height");
            if (i2 === "inherit" || i2 === "normal") {
              return false;
            }
            var l2 = parseInt(i2, 10);
            var u2 = parseInt(a2.getPropertyValue("padding-top"), 10);
            var c2 = parseInt(a2.getPropertyValue("padding-bottom"), 10);
            var s2 = parseInt(a2.getPropertyValue("border-top-width"), 10);
            var d2 = parseInt(a2.getPropertyValue("border-bottom-width"), 10);
            var f2 = o2.scrollHeight + s2 + d2;
            if (f2 === void 0 || isNaN(f2)) {
              return false;
            }
            if (t2 >= n2) {
              var p2 = t2 * l2 + u2 + c2 + s2 + d2;
              f2 = Math.min(p2, f2);
            }
            var v2 = n2 * l2 + u2 + c2 + s2 + d2;
            f2 = Math.max(v2, f2);
            if (r3 !== f2) {
              return f2;
            }
          }
          return false;
        }
        const y = (init_styled_components_esm(), __toCommonJS(styled_components_esm_exports));
        var h = t.n(y);
        const g = require_Box();
        var x = t.n(g);
        const w = require_themes();
        var C = "230px";
        var S = w.variables.spacingSmall;
        var O = "5px";
        var A = h()(x()).withConfig({
          displayName: "TextAreaStyles__StyledBox",
          componentId: "gfy8yp-0"
        })(["", " display:flex;justify-content:space-between;flex-grow:1;flex-shrink:1;position:relative;min-height:", ";overflow:hidden;border:", " solid ", ";border-radius:", ";box-sizing:border-box;background-color:", ";box-shadow:inset 0 1px 1px rgba(0,0,0,0.075);align-items:center;gap:", ";padding:0 ", ";&:hover:not([disabled]){border-color:", ";}&:not([disabled]):has(textarea:focus){box-shadow:", ";color:", ";}", " ", " ", " ", " &[data-inline]{width:", ";flex-basis:", ";}"], w.mixins.reset("inline-flex"), w.variables.inputHeight, w.variables.inputBorderWidth, w.variables.interactiveColorBorder, w.variables.borderRadius, w.variables.interactiveColorBackground, w.variables.spacingSmall, S, w.variables.interactiveColorBorderHover, w.variables.focusShadow, w.variables.contentColorActive, (function(e3) {
          var r3 = e3.$error;
          return r3 && (0, y.css)(["border-color:", ";&:hover:not([disabled]){border-color:", ";}"], w.variables.interactiveColorAccentError, w.variables.interactiveColorAccentErrorStrong);
        }), (function(e3) {
          var r3 = e3.$append;
          return r3 && (0, y.css)(["margin-right:-1px;border-top-right-radius:0;border-bottom-right-radius:0;border-right:none;"]);
        }), (function(e3) {
          var r3 = e3.$prepend;
          return r3 && (0, y.css)(["border-top-left-radius:0;border-bottom-left-radius:0;"]);
        }), (function(e3) {
          var r3 = e3.disabled;
          return r3 && (0, y.css)(["background-color:", ";border-color:", ";box-shadow:inset 0 1px 2px rgba(0,0,0,0.025);"], w.variables.interactiveColorBackgroundDisabled, w.variables.interactiveColorBorderDisabled);
        }), C, C);
        var E = h().div.withConfig({
          displayName: "TextAreaStyles__StyledTextAreaAndShadowWrapper",
          componentId: "gfy8yp-1"
        })(["", ";position:relative;overflow:hidden;flex-grow:1;"], w.mixins.reset("inline-flex"));
        var j = h().textarea.withConfig({
          displayName: "TextAreaStyles__StyledTextArea",
          componentId: "gfy8yp-2"
        })(["", ";color:", ";position:relative;resize:none;overflow:auto;white-space:pre-wrap;width:100%;line-height:20px;padding-top:", ";padding-bottom:", ";&::placeholder{color:", ";opacity:1;}&[disabled]{cursor:not-allowed;color:", ";&::placeholder{color:", ";}}"], w.mixins.reset(), w.variables.contentColorActive, O, O, w.variables.contentColorMuted, w.variables.contentColorDisabled, w.variables.contentColorDisabled);
        var I = h()(j).withConfig({
          displayName: "TextAreaStyles__StyledTextAreaShadow",
          componentId: "gfy8yp-3"
        })(["position:absolute;overflow:hidden;left:-10000px;top:-10000px;visibility:hidden;pointer-events:none;"]);
        var k = h().div.withConfig({
          displayName: "TextAreaStyles__StyledAdornment",
          componentId: "gfy8yp-4"
        })(["align-self:flex-start;display:inline-flex;align-items:center;justify-content:center;pointer-events:none;color:", ";padding:", " 0;", ";"], w.variables.contentColorMuted, O, (function(e3) {
          var r3 = e3.$disabled;
          return r3 && (0, y.css)(["cursor:not-allowed;color:", ";"], w.variables.contentColorDisabled);
        }));
        var P = t(3639);
        var T = {
          body: {
            appendChild: function e3() {
              return [];
            }
          },
          addEventListener: function e3() {
          },
          removeEventListener: function e3() {
          },
          activeElement: {
            blur: function e3() {
            },
            nodeName: ""
          },
          querySelector: function e3() {
            return null;
          },
          querySelectorAll: function e3() {
            return [];
          },
          getElementById: function e3() {
            return null;
          },
          createEvent: function e3() {
            return {
              initEvent: function e4() {
              }
            };
          },
          createElement: function e3() {
            return {
              children: [],
              childNodes: [],
              style: {},
              setAttribute: function e4() {
              },
              getElementsByTagName: function e4() {
                return [];
              }
            };
          },
          createElementNS: function e3() {
            return {};
          },
          importNode: function e3() {
            return null;
          },
          location: {
            hash: "",
            host: "",
            hostname: "",
            href: "",
            origin: "",
            pathname: "",
            protocol: "",
            search: ""
          }
        };
        function B() {
          var e3 = typeof document !== "undefined" ? document : T;
          return e3;
        }
        var N = B();
        const q = (
          /* unused pure expression or super */
          null
        );
        var M = {
          document: T,
          navigator: {
            userAgent: ""
          },
          location: {
            hash: "",
            host: "",
            hostname: "",
            href: "",
            origin: "",
            pathname: "",
            protocol: "",
            search: ""
          },
          history: {
            replaceState: function e3() {
            },
            pushState: function e3() {
            },
            go: function e3() {
            },
            back: function e3() {
            }
          },
          CustomEvent: function e3() {
            return this;
          },
          addEventListener: function e3() {
          },
          removeEventListener: function e3() {
          },
          getComputedStyle: function e3() {
            return {
              getPropertyValue: function e4() {
                return "";
              }
            };
          },
          Image: function e3() {
          },
          Date: function e3() {
          },
          screen: {},
          setTimeout: function e3() {
          },
          clearTimeout: function e3() {
          },
          matchMedia: function e3() {
            return {};
          },
          requestAnimationFrame: function e3(r3) {
            if (typeof setTimeout === "undefined") {
              r3();
              return null;
            }
            return setTimeout(r3, 0);
          },
          cancelAnimationFrame: function e3(r3) {
            if (typeof setTimeout === "undefined") {
              return;
            }
            clearTimeout(r3);
          }
        };
        function D() {
          var e3 = typeof window !== "undefined" ? window : M;
          return e3;
        }
        var _ = D();
        const R = _;
        function F(e3, r3) {
          if (e3) {
            if (typeof e3 === "function") {
              e3(r3);
            } else {
              e3.current = r3;
            }
          }
        }
        function V(e3) {
          "@babel/helpers - typeof";
          return V = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
            return typeof e4;
          } : function(e4) {
            return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
          }, V(e3);
        }
        function $2() {
          return $2 = Object.assign ? Object.assign.bind() : function(e3) {
            for (var r3 = 1; r3 < arguments.length; r3++) {
              var t2 = arguments[r3];
              for (var n2 in t2) {
                ({}).hasOwnProperty.call(t2, n2) && (e3[n2] = t2[n2]);
              }
            }
            return e3;
          }, $2.apply(null, arguments);
        }
        function L(e3) {
          return H(e3) || K(e3) || Z(e3) || z();
        }
        function z() {
          throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        function K(e3) {
          if ("undefined" != typeof Symbol && null != e3[Symbol.iterator] || null != e3["@@iterator"]) return Array.from(e3);
        }
        function H(e3) {
          if (Array.isArray(e3)) return ee(e3);
        }
        function W(e3, r3) {
          var t2 = Object.keys(e3);
          if (Object.getOwnPropertySymbols) {
            var n2 = Object.getOwnPropertySymbols(e3);
            r3 && (n2 = n2.filter((function(r4) {
              return Object.getOwnPropertyDescriptor(e3, r4).enumerable;
            }))), t2.push.apply(t2, n2);
          }
          return t2;
        }
        function U(e3) {
          for (var r3 = 1; r3 < arguments.length; r3++) {
            var t2 = null != arguments[r3] ? arguments[r3] : {};
            r3 % 2 ? W(Object(t2), true).forEach((function(r4) {
              G(e3, r4, t2[r4]);
            })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t2)) : W(Object(t2)).forEach((function(r4) {
              Object.defineProperty(e3, r4, Object.getOwnPropertyDescriptor(t2, r4));
            }));
          }
          return e3;
        }
        function G(e3, r3, t2) {
          return (r3 = J(r3)) in e3 ? Object.defineProperty(e3, r3, {
            value: t2,
            enumerable: true,
            configurable: true,
            writable: true
          }) : e3[r3] = t2, e3;
        }
        function J(e3) {
          var r3 = Q(e3, "string");
          return "symbol" == V(r3) ? r3 : r3 + "";
        }
        function Q(e3, r3) {
          if ("object" != V(e3) || !e3) return e3;
          var t2 = e3[Symbol.toPrimitive];
          if (void 0 !== t2) {
            var n2 = t2.call(e3, r3 || "default");
            if ("object" != V(n2)) return n2;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return ("string" === r3 ? String : Number)(e3);
        }
        function X(e3, r3) {
          return te(e3) || re(e3, r3) || Z(e3, r3) || Y();
        }
        function Y() {
          throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        function Z(e3, r3) {
          if (e3) {
            if ("string" == typeof e3) return ee(e3, r3);
            var t2 = {}.toString.call(e3).slice(8, -1);
            return "Object" === t2 && e3.constructor && (t2 = e3.constructor.name), "Map" === t2 || "Set" === t2 ? Array.from(e3) : "Arguments" === t2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t2) ? ee(e3, r3) : void 0;
          }
        }
        function ee(e3, r3) {
          (null == r3 || r3 > e3.length) && (r3 = e3.length);
          for (var t2 = 0, n2 = Array(r3); t2 < r3; t2++) {
            n2[t2] = e3[t2];
          }
          return n2;
        }
        function re(e3, r3) {
          var t2 = null == e3 ? null : "undefined" != typeof Symbol && e3[Symbol.iterator] || e3["@@iterator"];
          if (null != t2) {
            var n2, o2, a2, i2, l2 = [], u2 = true, c2 = false;
            try {
              if (a2 = (t2 = t2.call(e3)).next, 0 === r3) {
                if (Object(t2) !== t2) return;
                u2 = false;
              } else for (; !(u2 = (n2 = a2.call(t2)).done) && (l2.push(n2.value), l2.length !== r3); u2 = true) {
              }
            } catch (e4) {
              c2 = true, o2 = e4;
            } finally {
              try {
                if (!u2 && null != t2["return"] && (i2 = t2["return"](), Object(i2) !== i2)) return;
              } finally {
                if (c2) throw o2;
              }
            }
            return l2;
          }
        }
        function te(e3) {
          if (Array.isArray(e3)) return e3;
        }
        function ne(e3, r3) {
          if (null == e3) return {};
          var t2, n2, o2 = oe(e3, r3);
          if (Object.getOwnPropertySymbols) {
            var a2 = Object.getOwnPropertySymbols(e3);
            for (n2 = 0; n2 < a2.length; n2++) {
              t2 = a2[n2], -1 === r3.indexOf(t2) && {}.propertyIsEnumerable.call(e3, t2) && (o2[t2] = e3[t2]);
            }
          }
          return o2;
        }
        function oe(e3, r3) {
          if (null == e3) return {};
          var t2 = {};
          for (var n2 in e3) {
            if ({}.hasOwnProperty.call(e3, n2)) {
              if (-1 !== r3.indexOf(n2)) continue;
              t2[n2] = e3[n2];
            }
          }
          return t2;
        }
        var ae = {
          append: p().bool,
          autoCapitalize: p().string,
          autoComplete: p().string,
          autoCorrect: p().string,
          autoFocus: p().bool,
          children: p().node,
          defaultValue: p().string,
          describedBy: p().string,
          disabled: p().bool,
          elementRef: p().oneOfType([p().func, p().object]),
          endAdornment: p().node,
          error: p().bool,
          inline: p().bool,
          /** @private. */
          inputClassName: p().string,
          inputId: p().string,
          inputRef: p().oneOfType([p().func, p().object]),
          labelledBy: p().string,
          maxLength: p().number,
          name: p().string,
          onBlur: p().func,
          onChange: p().func,
          onFocus: p().func,
          onKeyDown: p().func,
          onSelect: p().func,
          onInputClick: p().func,
          prepend: p().bool,
          /** @private. */
          required: p().bool,
          rowsMax: p().number,
          rowsMin: p().number,
          spellCheck: p().bool,
          tabIndex: p().number,
          startAdornment: p().node,
          value: p().string
        };
        var ie = function e3() {
        };
        function le(t2) {
          var n2 = t2.append, o2 = n2 === void 0 ? false : n2, i2 = t2.autoCapitalize, u2 = t2.autoComplete, s2 = t2.autoCorrect, f2 = t2.autoFocus, p2 = f2 === void 0 ? false : f2, v2 = t2.children, y2 = t2.disabled, h2 = y2 === void 0 ? false : y2, g2 = t2.describedBy, x2 = t2.defaultValue, w2 = t2.elementRef, C2 = t2.error, S2 = C2 === void 0 ? false : C2, O2 = t2.endAdornment, T2 = t2.inline, B2 = T2 === void 0 ? false : T2, N2 = t2.inputClassName, q2 = t2.inputId, M2 = t2.inputRef, D2 = t2.labelledBy, _2 = t2.maxLength, V2 = t2.name, z2 = t2.onBlur, K2 = t2.onChange, H2 = t2.onFocus, W2 = t2.onInputClick, G2 = t2.onKeyDown, J2 = t2.onSelect, Q2 = t2.placeholder, Y2 = t2.prepend, Z2 = Y2 === void 0 ? false : Y2, ee2 = t2.required, re2 = t2.rowsMin, te2 = re2 === void 0 ? 2 : re2, oe2 = t2.rowsMax, ae2 = oe2 === void 0 ? 8 : oe2, le2 = t2.spellCheck, ue2 = t2.startAdornment, ce = t2.tabIndex, se = ce === void 0 ? 0 : ce, de = t2.value, fe = ne(t2, ["append", "autoCapitalize", "autoComplete", "autoCorrect", "autoFocus", "children", "disabled", "describedBy", "defaultValue", "elementRef", "error", "endAdornment", "inline", "inputClassName", "inputId", "inputRef", "labelledBy", "maxLength", "name", "onBlur", "onChange", "onFocus", "onInputClick", "onKeyDown", "onSelect", "placeholder", "prepend", "required", "rowsMin", "rowsMax", "spellCheck", "startAdornment", "tabIndex", "value"]);
          (0, e2.useEffect)((function() {
            if (false) {
            }
          }), [te2, ae2]);
          var pe = (0, P["default"])({
            componentName: "TextArea",
            /* eslint-disable-next-line prefer-rest-params */
            componentProps: arguments[0]
          });
          var ve = (0, e2.useState)(x2 || ""), be = X(ve, 2), me = be[0], ye = be[1];
          var he = (0, e2.useState)(), ge = X(he, 2), xe = ge[0], we = ge[1];
          var Ce = (0, e2.useRef)(null);
          var Se = (0, e2.useRef)(null);
          var Oe = pe ? de : me;
          var Ae = (0, e2.useCallback)((function(e3) {
            Ce.current = e3;
            F(M2, e3);
          }), [M2, Ce]);
          var Ee = (0, e2.useCallback)((function(e3) {
            G2 === null || G2 === void 0 ? void 0 : G2(e3);
          }), [G2]);
          var je = (0, e2.useCallback)((function(e3) {
            J2 === null || J2 === void 0 ? void 0 : J2(e3);
          }), [J2]);
          var Ie = (0, e2.useCallback)((function(e3) {
            W2 === null || W2 === void 0 ? void 0 : W2(e3);
          }), [W2]);
          var ke = (0, e2.useCallback)((function(e3) {
            var r3 = e3.target.value;
            H2 === null || H2 === void 0 ? void 0 : H2(e3, {
              value: r3,
              name: V2
            });
          }), [V2, H2]);
          var Pe = (0, e2.useCallback)((function(e3) {
            var r3 = e3.target.value;
            z2 === null || z2 === void 0 ? void 0 : z2(e3, {
              value: r3,
              name: V2
            });
          }), [V2, z2]);
          var Te = (0, e2.useCallback)((function(e3) {
            var r3 = e3.target.value;
            if (!pe) {
              ye(r3);
            }
            K2 === null || K2 === void 0 ? void 0 : K2(e3, {
              value: r3,
              name: V2
            });
          }), [K2, ye, pe, V2]);
          var Be = (0, e2.useCallback)((function() {
            var e3 = m({
              height: xe,
              rowsMax: ae2,
              rowsMin: te2,
              shadow: Se.current
            });
            if (e3 !== false) {
              we(e3);
            }
          }), [we, Se, ae2, te2, xe]);
          var Ne = (0, e2.useMemo)((function() {
            return d()(Be, 100);
          }), [Be]);
          (0, e2.useLayoutEffect)((function() {
            Be();
          }));
          var qe = U(U({}, c()(fe, (function(e3, r3) {
            return r3 === "role" || r3.indexOf("aria-") === 0;
          }))), {}, {
            "aria-describedby": g2,
            "aria-labelledby": D2,
            "aria-invalid": S2 || void 0
          });
          var Me = l()(fe, ["inputRef", "onBlur", "onChange", "onFocus", "onKeyDown", "onSelect", "onInputClick"].concat(L(a()(qe))));
          var De = {
            $append: o2 || void 0,
            $error: S2,
            $prepend: Z2 || void 0
          };
          var _e = U(U({}, qe), {}, {
            "data-test": "textbox",
            autoCapitalize: i2,
            autoComplete: u2,
            autoCorrect: s2,
            autoFocus: p2,
            className: N2,
            disabled: h2,
            id: q2,
            maxLength: _2,
            name: V2,
            onBlur: Pe,
            onChange: Te,
            onFocus: ke,
            onKeyDown: Ee,
            onSelect: je,
            onClick: Ie,
            placeholder: Q2,
            // support HTML attribute
            ref: Ae,
            required: ee2,
            spellCheck: le2,
            style: {
              height: xe
            },
            tabIndex: se,
            value: Oe,
            $error: S2
          });
          return r2().createElement(r2().Fragment, null, r2().createElement(A, $2({
            tabIndex: -1,
            "data-test": "text-area",
            "data-test-value": Oe,
            "data-test-disabled": h2 ? "disabled" : void 0,
            elementRef: w2,
            flex: true,
            inline: B2,
            disabled: h2
          }, Me, De), ue2 && r2().createElement(k, {
            $disabled: !!h2
          }, ue2), r2().createElement(E, null, r2().createElement(I, {
            "aria-hidden": "true",
            tabIndex: -1,
            onChange: ie,
            rows: te2,
            ref: Se,
            value: Q2 && !Oe ? Q2 : Oe
          }), r2().createElement(j, _e)), v2, O2 && r2().createElement(k, {
            $disabled: !!h2
          }, O2)), r2().createElement(b(), {
            target: R,
            eventType: "resize",
            listener: Ne
          }));
        }
        le.propTypes = ae;
        le.componentType = "TextArea";
        const ue = le;
      })();
      module.exports = n;
    })();
  }
});

// node_modules/@splunk/react-ui/Code.js
var require_Code = __commonJS({
  "node_modules/@splunk/react-ui/Code.js"(exports, module) {
    var import_dist466 = __toESM(require_dist());
    var import_dist467 = __toESM(require_dist2());
    var import_dist468 = __toESM(require_dist3());
    (() => {
      var e = {
        /***/
        6283: (
          /***/
          (e2, t2, n2) => {
            "use strict";
            n2.d(t2, {
              default: () => (
                /* reexport */
                p
              )
            });
            var r2 = n2(9497);
            function a(e3, t3) {
              return u(e3) || l(e3, t3) || s(e3, t3) || i();
            }
            function i() {
              throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            function s(e3, t3) {
              if (e3) {
                if ("string" == typeof e3) return o(e3, t3);
                var n3 = {}.toString.call(e3).slice(8, -1);
                return "Object" === n3 && e3.constructor && (n3 = e3.constructor.name), "Map" === n3 || "Set" === n3 ? Array.from(e3) : "Arguments" === n3 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n3) ? o(e3, t3) : void 0;
              }
            }
            function o(e3, t3) {
              (null == t3 || t3 > e3.length) && (t3 = e3.length);
              for (var n3 = 0, r3 = Array(t3); n3 < t3; n3++) {
                r3[n3] = e3[n3];
              }
              return r3;
            }
            function l(e3, t3) {
              var n3 = null == e3 ? null : "undefined" != typeof Symbol && e3[Symbol.iterator] || e3["@@iterator"];
              if (null != n3) {
                var r3, a2, i2, s2, o2 = [], l2 = true, u2 = false;
                try {
                  if (i2 = (n3 = n3.call(e3)).next, 0 === t3) {
                    if (Object(n3) !== n3) return;
                    l2 = false;
                  } else for (; !(l2 = (r3 = i2.call(n3)).done) && (o2.push(r3.value), o2.length !== t3); l2 = true) {
                  }
                } catch (e4) {
                  u2 = true, a2 = e4;
                } finally {
                  try {
                    if (!l2 && null != n3["return"] && (s2 = n3["return"](), Object(s2) !== s2)) return;
                  } finally {
                    if (u2) throw a2;
                  }
                }
                return o2;
              }
            }
            function u(e3) {
              if (Array.isArray(e3)) return e3;
            }
            var c = function e3(t3, n3) {
              var i2 = (0, r2.useState)({
                width: 0,
                height: 0
              }), s2 = a(i2, 2), o2 = s2[0], l2 = s2[1];
              (0, r2.useEffect)((function() {
                var e4 = t3.current;
                if (typeof window !== "undefined" && window.ResizeObserver) {
                  var r3 = new ResizeObserver((function(e5) {
                    if (e5[0]) {
                      var r4, a2;
                      var i3 = {
                        width: (t3 === null || t3 === void 0 ? void 0 : (r4 = t3.current) === null || r4 === void 0 ? void 0 : r4.getBoundingClientRect().width) || 0,
                        height: (t3 === null || t3 === void 0 ? void 0 : (a2 = t3.current) === null || a2 === void 0 ? void 0 : a2.getBoundingClientRect().height) || 0
                      };
                      l2((function(e6) {
                        if (e6.height !== i3.height || e6.width !== i3.width) {
                          n3 === null || n3 === void 0 ? void 0 : n3(i3);
                          return i3;
                        }
                        return e6;
                      }));
                    }
                  }));
                  if (e4) {
                    r3.observe(e4);
                  }
                  return function() {
                    if (e4) {
                      r3.unobserve(e4);
                    }
                  };
                }
                return function() {
                };
              }), [n3, t3]);
              return o2;
            };
            const p = c;
          }
        ),
        /***/
        74: (
          /***/
          (e2) => {
            (function() {
              var t2 = void 0;
              var n2 = void 0;
              var r2 = typeof t2 !== "undefined" ? t2 : typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope ? self : {};
              var a = (function(e3) {
                var n3 = /(?:^|\s)lang(?:uage)?-([\w-]+)(?=\s|$)/i;
                var r3 = 0;
                var a2 = {};
                var i = {
                  /**
                  * By default, Prism will attempt to highlight all code elements (by calling {@link Prism.highlightAll}) on the
                  * current page after the page finished loading. This might be a problem if e.g. you wanted to asynchronously load
                  * additional languages or plugins yourself.
                  *
                  * By setting this value to `true`, Prism will not automatically highlight all code elements on the page.
                  *
                  * You obviously have to change this value before the automatic highlighting started. To do this, you can add an
                  * empty Prism object into the global scope before loading the Prism script like this:
                  *
                  * ```js
                  * window.Prism = window.Prism || {};
                  * Prism.manual = true;
                  * // add a new <script> to load Prism's script
                  * ```
                  *
                  * @default false
                  * @type {boolean}
                  * @memberof Prism
                  * @public
                  */
                  manual: e3.Prism && e3.Prism.manual,
                  /**
                  * By default, if Prism is in a web worker, it assumes that it is in a worker it created itself, so it uses
                  * `addEventListener` to communicate with its parent instance. However, if you're using Prism manually in your
                  * own worker, you don't want it to do this.
                  *
                  * By setting this value to `true`, Prism will not add its own listeners to the worker.
                  *
                  * You obviously have to change this value before Prism executes. To do this, you can add an
                  * empty Prism object into the global scope before loading the Prism script like this:
                  *
                  * ```js
                  * window.Prism = window.Prism || {};
                  * Prism.disableWorkerMessageHandler = true;
                  * // Load Prism's script
                  * ```
                  *
                  * @default false
                  * @type {boolean}
                  * @memberof Prism
                  * @public
                  */
                  disableWorkerMessageHandler: e3.Prism && e3.Prism.disableWorkerMessageHandler,
                  /**
                  * A namespace for utility methods.
                  *
                  * All function in this namespace that are not explicitly marked as _public_ are for __internal use only__ and may
                  * change or disappear at any time.
                  *
                  * @namespace
                  * @memberof Prism
                  */
                  util: {
                    encode: function e4(t3) {
                      if (t3 instanceof s) {
                        return new s(t3.type, e4(t3.content), t3.alias);
                      } else if (Array.isArray(t3)) {
                        return t3.map(e4);
                      } else {
                        return t3.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ");
                      }
                    },
                    /**
                    * Returns the name of the type of the given value.
                    *
                    * @param {any} o
                    * @returns {string}
                    * @example
                    * type(null)      === 'Null'
                    * type(undefined) === 'Undefined'
                    * type(123)       === 'Number'
                    * type('foo')     === 'String'
                    * type(true)      === 'Boolean'
                    * type([1, 2])    === 'Array'
                    * type({})        === 'Object'
                    * type(String)    === 'Function'
                    * type(/abc+/)    === 'RegExp'
                    */
                    type: function(e4) {
                      return Object.prototype.toString.call(e4).slice(8, -1);
                    },
                    /**
                    * Returns a unique number for the given object. Later calls will still return the same number.
                    *
                    * @param {Object} obj
                    * @returns {number}
                    */
                    objId: function(e4) {
                      if (!e4["__id"]) {
                        Object.defineProperty(e4, "__id", {
                          value: ++r3
                        });
                      }
                      return e4["__id"];
                    },
                    /**
                    * Creates a deep clone of the given object.
                    *
                    * The main intended use of this function is to clone language definitions.
                    *
                    * @param {T} o
                    * @param {Record<number, any>} [visited]
                    * @returns {T}
                    * @template T
                    */
                    clone: function e4(t3, n4) {
                      n4 = n4 || {};
                      var r4;
                      var a3;
                      switch (i.util.type(t3)) {
                        case "Object":
                          a3 = i.util.objId(t3);
                          if (n4[a3]) {
                            return n4[a3];
                          }
                          r4 = /** @type {Record<string, any>} */
                          {};
                          n4[a3] = r4;
                          for (var s2 in t3) {
                            if (t3.hasOwnProperty(s2)) {
                              r4[s2] = e4(t3[s2], n4);
                            }
                          }
                          return r4;
                        case "Array":
                          a3 = i.util.objId(t3);
                          if (n4[a3]) {
                            return n4[a3];
                          }
                          r4 = [];
                          n4[a3] = r4;
                          t3.forEach((function(t4, a4) {
                            r4[a4] = e4(t4, n4);
                          }));
                          return r4;
                        default:
                          return t3;
                      }
                    },
                    /**
                    * Returns the Prism language of the given element set by a `language-xxxx` or `lang-xxxx` class.
                    *
                    * If no language is set for the element or the element is `null` or `undefined`, `none` will be returned.
                    *
                    * @param {Element} element
                    * @returns {string}
                    */
                    getLanguage: function(e4) {
                      while (e4) {
                        var t3 = n3.exec(e4.className);
                        if (t3) {
                          return t3[1].toLowerCase();
                        }
                        e4 = e4.parentElement;
                      }
                      return "none";
                    },
                    /**
                    * Sets the Prism `language-xxxx` class of the given element.
                    *
                    * @param {Element} element
                    * @param {string} language
                    * @returns {void}
                    */
                    setLanguage: function(e4, t3) {
                      e4.className = e4.className.replace(RegExp(n3, "gi"), "");
                      e4.classList.add("language-" + t3);
                    },
                    /**
                    * Returns the script element that is currently executing.
                    *
                    * This does __not__ work for line script element.
                    *
                    * @returns {HTMLScriptElement | null}
                    */
                    currentScript: function() {
                      if (typeof document === "undefined") {
                        return null;
                      }
                      if ("currentScript" in document && 1 < 2) {
                        return document.currentScript;
                      }
                      try {
                        throw new Error();
                      } catch (r4) {
                        var e4 = (/at [^(\r\n]*\((.*):[^:]+:[^:]+\)$/i.exec(r4.stack) || [])[1];
                        if (e4) {
                          var t3 = document.getElementsByTagName("script");
                          for (var n4 in t3) {
                            if (t3[n4].src == e4) {
                              return t3[n4];
                            }
                          }
                        }
                        return null;
                      }
                    },
                    /**
                    * Returns whether a given class is active for `element`.
                    *
                    * The class can be activated if `element` or one of its ancestors has the given class and it can be deactivated
                    * if `element` or one of its ancestors has the negated version of the given class. The _negated version_ of the
                    * given class is just the given class with a `no-` prefix.
                    *
                    * Whether the class is active is determined by the closest ancestor of `element` (where `element` itself is
                    * closest ancestor) that has the given class or the negated version of it. If neither `element` nor any of its
                    * ancestors have the given class or the negated version of it, then the default activation will be returned.
                    *
                    * In the paradoxical situation where the closest ancestor contains __both__ the given class and the negated
                    * version of it, the class is considered active.
                    *
                    * @param {Element} element
                    * @param {string} className
                    * @param {boolean} [defaultActivation=false]
                    * @returns {boolean}
                    */
                    isActive: function(e4, t3, n4) {
                      var r4 = "no-" + t3;
                      while (e4) {
                        var a3 = e4.classList;
                        if (a3.contains(t3)) {
                          return true;
                        }
                        if (a3.contains(r4)) {
                          return false;
                        }
                        e4 = e4.parentElement;
                      }
                      return !!n4;
                    }
                  },
                  /**
                  * This namespace contains all currently loaded languages and the some helper functions to create and modify languages.
                  *
                  * @namespace
                  * @memberof Prism
                  * @public
                  */
                  languages: {
                    /**
                    * The grammar for plain, unformatted text.
                    */
                    plain: a2,
                    plaintext: a2,
                    text: a2,
                    txt: a2,
                    /**
                    * Creates a deep copy of the language with the given id and appends the given tokens.
                    *
                    * If a token in `redef` also appears in the copied language, then the existing token in the copied language
                    * will be overwritten at its original position.
                    *
                    * ## Best practices
                    *
                    * Since the position of overwriting tokens (token in `redef` that overwrite tokens in the copied language)
                    * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to
                    * understand the language definition because, normally, the order of tokens matters in Prism grammars.
                    *
                    * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.
                    * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.
                    *
                    * @param {string} id The id of the language to extend. This has to be a key in `Prism.languages`.
                    * @param {Grammar} redef The new tokens to append.
                    * @returns {Grammar} The new language created.
                    * @public
                    * @example
                    * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {
                    *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token
                    *     // at its original position
                    *     'comment': { ... },
                    *     // CSS doesn't have a 'color' token, so this token will be appended
                    *     'color': /\b(?:red|green|blue)\b/
                    * });
                    */
                    extend: function(e4, t3) {
                      var n4 = i.util.clone(i.languages[e4]);
                      for (var r4 in t3) {
                        n4[r4] = t3[r4];
                      }
                      return n4;
                    },
                    /**
                    * Inserts tokens _before_ another token in a language definition or any other grammar.
                    *
                    * ## Usage
                    *
                    * This helper method makes it easy to modify existing languages. For example, the CSS language definition
                    * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded
                    * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the
                    * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do
                    * this:
                    *
                    * ```js
                    * Prism.languages.markup.style = {
                    *     // token
                    * };
                    * ```
                    *
                    * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens
                    * before existing tokens. For the CSS example above, you would use it like this:
                    *
                    * ```js
                    * Prism.languages.insertBefore('markup', 'cdata', {
                    *     'style': {
                    *         // token
                    *     }
                    * });
                    * ```
                    *
                    * ## Special cases
                    *
                    * If the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar
                    * will be ignored.
                    *
                    * This behavior can be used to insert tokens after `before`:
                    *
                    * ```js
                    * Prism.languages.insertBefore('markup', 'comment', {
                    *     'comment': Prism.languages.markup.comment,
                    *     // tokens after 'comment'
                    * });
                    * ```
                    *
                    * ## Limitations
                    *
                    * The main problem `insertBefore` has to solve is iteration order. Since ES2015, the iteration order for object
                    * properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave
                    * differently when keys are deleted and re-inserted. So `insertBefore` can't be implemented by temporarily
                    * deleting properties which is necessary to insert at arbitrary positions.
                    *
                    * To solve this problem, `insertBefore` doesn't actually insert the given tokens into the target object.
                    * Instead, it will create a new object and replace all references to the target object with the new one. This
                    * can be done without temporarily deleting properties, so the iteration order is well-defined.
                    *
                    * However, only references that can be reached from `Prism.languages` or `insert` will be replaced. I.e. if
                    * you hold the target object in a variable, then the value of the variable will not change.
                    *
                    * ```js
                    * var oldMarkup = Prism.languages.markup;
                    * var newMarkup = Prism.languages.insertBefore('markup', 'comment', { ... });
                    *
                    * assert(oldMarkup !== Prism.languages.markup);
                    * assert(newMarkup === Prism.languages.markup);
                    * ```
                    *
                    * @param {string} inside The property of `root` (e.g. a language id in `Prism.languages`) that contains the
                    * object to be modified.
                    * @param {string} before The key to insert before.
                    * @param {Grammar} insert An object containing the key-value pairs to be inserted.
                    * @param {Object<string, any>} [root] The object containing `inside`, i.e. the object that contains the
                    * object to be modified.
                    *
                    * Defaults to `Prism.languages`.
                    * @returns {Grammar} The new grammar object.
                    * @public
                    */
                    insertBefore: function(e4, t3, n4, r4) {
                      r4 = r4 || /** @type {any} */
                      i.languages;
                      var a3 = r4[e4];
                      var s2 = {};
                      for (var o2 in a3) {
                        if (a3.hasOwnProperty(o2)) {
                          if (o2 == t3) {
                            for (var l2 in n4) {
                              if (n4.hasOwnProperty(l2)) {
                                s2[l2] = n4[l2];
                              }
                            }
                          }
                          if (!n4.hasOwnProperty(o2)) {
                            s2[o2] = a3[o2];
                          }
                        }
                      }
                      var u2 = r4[e4];
                      r4[e4] = s2;
                      i.languages.DFS(i.languages, (function(t4, n5) {
                        if (n5 === u2 && t4 != e4) {
                          this[t4] = s2;
                        }
                      }));
                      return s2;
                    },
                    // Traverse a language definition with Depth First Search
                    DFS: function e4(t3, n4, r4, a3) {
                      a3 = a3 || {};
                      var s2 = i.util.objId;
                      for (var o2 in t3) {
                        if (t3.hasOwnProperty(o2)) {
                          n4.call(t3, o2, t3[o2], r4 || o2);
                          var l2 = t3[o2];
                          var u2 = i.util.type(l2);
                          if (u2 === "Object" && !a3[s2(l2)]) {
                            a3[s2(l2)] = true;
                            e4(l2, n4, null, a3);
                          } else if (u2 === "Array" && !a3[s2(l2)]) {
                            a3[s2(l2)] = true;
                            e4(l2, n4, o2, a3);
                          }
                        }
                      }
                    }
                  },
                  plugins: {},
                  /**
                  * This is the most high-level function in Prisms API.
                  * It fetches all the elements that have a `.language-xxxx` class and then calls {@link Prism.highlightElement} on
                  * each one of them.
                  *
                  * This is equivalent to `Prism.highlightAllUnder(document, async, callback)`.
                  *
                  * @param {boolean} [async=false] Same as in {@link Prism.highlightAllUnder}.
                  * @param {HighlightCallback} [callback] Same as in {@link Prism.highlightAllUnder}.
                  * @memberof Prism
                  * @public
                  */
                  highlightAll: function(e4, t3) {
                    i.highlightAllUnder(document, e4, t3);
                  },
                  /**
                  * Fetches all the descendants of `container` that have a `.language-xxxx` class and then calls
                  * {@link Prism.highlightElement} on each one of them.
                  *
                  * The following hooks will be run:
                  * 1. `before-highlightall`
                  * 2. `before-all-elements-highlight`
                  * 3. All hooks of {@link Prism.highlightElement} for each element.
                  *
                  * @param {ParentNode} container The root element, whose descendants that have a `.language-xxxx` class will be highlighted.
                  * @param {boolean} [async=false] Whether each element is to be highlighted asynchronously using Web Workers.
                  * @param {HighlightCallback} [callback] An optional callback to be invoked on each element after its highlighting is done.
                  * @memberof Prism
                  * @public
                  */
                  highlightAllUnder: function(e4, t3, n4) {
                    var r4 = {
                      callback: n4,
                      container: e4,
                      selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
                    };
                    i.hooks.run("before-highlightall", r4);
                    r4.elements = Array.prototype.slice.apply(r4.container.querySelectorAll(r4.selector));
                    i.hooks.run("before-all-elements-highlight", r4);
                    for (var a3 = 0, s2; s2 = r4.elements[a3++]; ) {
                      i.highlightElement(s2, t3 === true, r4.callback);
                    }
                  },
                  /**
                  * Highlights the code inside a single element.
                  *
                  * The following hooks will be run:
                  * 1. `before-sanity-check`
                  * 2. `before-highlight`
                  * 3. All hooks of {@link Prism.highlight}. These hooks will be run by an asynchronous worker if `async` is `true`.
                  * 4. `before-insert`
                  * 5. `after-highlight`
                  * 6. `complete`
                  *
                  * Some the above hooks will be skipped if the element doesn't contain any text or there is no grammar loaded for
                  * the element's language.
                  *
                  * @param {Element} element The element containing the code.
                  * It must have a class of `language-xxxx` to be processed, where `xxxx` is a valid language identifier.
                  * @param {boolean} [async=false] Whether the element is to be highlighted asynchronously using Web Workers
                  * to improve performance and avoid blocking the UI when highlighting very large chunks of code. This option is
                  * [disabled by default](https://prismjs.com/faq.html#why-is-asynchronous-highlighting-disabled-by-default).
                  *
                  * Note: All language definitions required to highlight the code must be included in the main `prism.js` file for
                  * asynchronous highlighting to work. You can build your own bundle on the
                  * [Download page](https://prismjs.com/download.html).
                  * @param {HighlightCallback} [callback] An optional callback to be invoked after the highlighting is done.
                  * Mostly useful when `async` is `true`, since in that case, the highlighting is done asynchronously.
                  * @memberof Prism
                  * @public
                  */
                  highlightElement: function(t3, n4, r4) {
                    var a3 = i.util.getLanguage(t3);
                    var s2 = i.languages[a3];
                    i.util.setLanguage(t3, a3);
                    var o2 = t3.parentElement;
                    if (o2 && o2.nodeName.toLowerCase() === "pre") {
                      i.util.setLanguage(o2, a3);
                    }
                    var l2 = t3.textContent;
                    var u2 = {
                      element: t3,
                      language: a3,
                      grammar: s2,
                      code: l2
                    };
                    function c2(e4) {
                      u2.highlightedCode = e4;
                      i.hooks.run("before-insert", u2);
                      u2.element.innerHTML = u2.highlightedCode;
                      i.hooks.run("after-highlight", u2);
                      i.hooks.run("complete", u2);
                      r4 && r4.call(u2.element);
                    }
                    i.hooks.run("before-sanity-check", u2);
                    o2 = u2.element.parentElement;
                    if (o2 && o2.nodeName.toLowerCase() === "pre" && !o2.hasAttribute("tabindex")) {
                      o2.setAttribute("tabindex", "0");
                    }
                    if (!u2.code) {
                      i.hooks.run("complete", u2);
                      r4 && r4.call(u2.element);
                      return;
                    }
                    i.hooks.run("before-highlight", u2);
                    if (!u2.grammar) {
                      c2(i.util.encode(u2.code));
                      return;
                    }
                    if (n4 && e3.Worker) {
                      var p2 = new Worker(i.filename);
                      p2.onmessage = function(e4) {
                        c2(e4.data);
                      };
                      p2.postMessage(JSON.stringify({
                        language: u2.language,
                        code: u2.code,
                        immediateClose: true
                      }));
                    } else {
                      c2(i.highlight(u2.code, u2.grammar, u2.language));
                    }
                  },
                  /**
                  * Low-level function, only use if you know what youre doing. It accepts a string of text as input
                  * and the language definitions to use, and returns a string with the HTML produced.
                  *
                  * The following hooks will be run:
                  * 1. `before-tokenize`
                  * 2. `after-tokenize`
                  * 3. `wrap`: On each {@link Token}.
                  *
                  * @param {string} text A string with the code to be highlighted.
                  * @param {Grammar} grammar An object containing the tokens to use.
                  *
                  * Usually a language definition like `Prism.languages.markup`.
                  * @param {string} language The name of the language definition passed to `grammar`.
                  * @returns {string} The highlighted HTML.
                  * @memberof Prism
                  * @public
                  * @example
                  * Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');
                  */
                  highlight: function(e4, t3, n4) {
                    var r4 = {
                      code: e4,
                      grammar: t3,
                      language: n4
                    };
                    i.hooks.run("before-tokenize", r4);
                    if (!r4.grammar) {
                      throw new Error('The language "' + r4.language + '" has no grammar.');
                    }
                    r4.tokens = i.tokenize(r4.code, r4.grammar);
                    i.hooks.run("after-tokenize", r4);
                    return s.stringify(i.util.encode(r4.tokens), r4.language);
                  },
                  /**
                  * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input
                  * and the language definitions to use, and returns an array with the tokenized code.
                  *
                  * When the language definition includes nested tokens, the function is called recursively on each of these tokens.
                  *
                  * This method could be useful in other contexts as well, as a very crude parser.
                  *
                  * @param {string} text A string with the code to be highlighted.
                  * @param {Grammar} grammar An object containing the tokens to use.
                  *
                  * Usually a language definition like `Prism.languages.markup`.
                  * @returns {TokenStream} An array of strings and tokens, a token stream.
                  * @memberof Prism
                  * @public
                  * @example
                  * let code = `var foo = 0;`;
                  * let tokens = Prism.tokenize(code, Prism.languages.javascript);
                  * tokens.forEach(token => {
                  *     if (token instanceof Prism.Token && token.type === 'number') {
                  *         console.log(`Found numeric literal: ${token.content}`);
                  *     }
                  * });
                  */
                  tokenize: function(e4, t3) {
                    var n4 = t3.rest;
                    if (n4) {
                      for (var r4 in n4) {
                        t3[r4] = n4[r4];
                      }
                      delete t3.rest;
                    }
                    var a3 = new u();
                    c(a3, a3.head, e4);
                    l(e4, a3, t3, a3.head, 0);
                    return d(a3);
                  },
                  /**
                  * @namespace
                  * @memberof Prism
                  * @public
                  */
                  hooks: {
                    all: {},
                    /**
                    * Adds the given callback to the list of callbacks for the given hook.
                    *
                    * The callback will be invoked when the hook it is registered for is run.
                    * Hooks are usually directly run by a highlight function but you can also run hooks yourself.
                    *
                    * One callback function can be registered to multiple hooks and the same hook multiple times.
                    *
                    * @param {string} name The name of the hook.
                    * @param {HookCallback} callback The callback function which is given environment variables.
                    * @public
                    */
                    add: function(e4, t3) {
                      var n4 = i.hooks.all;
                      n4[e4] = n4[e4] || [];
                      n4[e4].push(t3);
                    },
                    /**
                    * Runs a hook invoking all registered callbacks with the given environment variables.
                    *
                    * Callbacks will be invoked synchronously and in the order in which they were registered.
                    *
                    * @param {string} name The name of the hook.
                    * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.
                    * @public
                    */
                    run: function(e4, t3) {
                      var n4 = i.hooks.all[e4];
                      if (!n4 || !n4.length) {
                        return;
                      }
                      for (var r4 = 0, a3; a3 = n4[r4++]; ) {
                        a3(t3);
                      }
                    }
                  },
                  Token: s
                };
                e3.Prism = i;
                function s(e4, t3, n4, r4) {
                  this.type = e4;
                  this.content = t3;
                  this.alias = n4;
                  this.length = (r4 || "").length | 0;
                }
                s.stringify = function e4(t3, n4) {
                  if (typeof t3 == "string") {
                    return t3;
                  }
                  if (Array.isArray(t3)) {
                    var r4 = "";
                    t3.forEach((function(t4) {
                      r4 += e4(t4, n4);
                    }));
                    return r4;
                  }
                  var a3 = {
                    type: t3.type,
                    content: e4(t3.content, n4),
                    tag: "span",
                    classes: ["token", t3.type],
                    attributes: {},
                    language: n4
                  };
                  var s2 = t3.alias;
                  if (s2) {
                    if (Array.isArray(s2)) {
                      Array.prototype.push.apply(a3.classes, s2);
                    } else {
                      a3.classes.push(s2);
                    }
                  }
                  i.hooks.run("wrap", a3);
                  var o2 = "";
                  for (var l2 in a3.attributes) {
                    o2 += " " + l2 + '="' + (a3.attributes[l2] || "").replace(/"/g, "&quot;") + '"';
                  }
                  return "<" + a3.tag + ' class="' + a3.classes.join(" ") + '"' + o2 + ">" + a3.content + "</" + a3.tag + ">";
                };
                function o(e4, t3, n4, r4) {
                  e4.lastIndex = t3;
                  var a3 = e4.exec(n4);
                  if (a3 && r4 && a3[1]) {
                    var i2 = a3[1].length;
                    a3.index += i2;
                    a3[0] = a3[0].slice(i2);
                  }
                  return a3;
                }
                function l(e4, t3, n4, r4, a3, u2) {
                  for (var d2 in n4) {
                    if (!n4.hasOwnProperty(d2) || !n4[d2]) {
                      continue;
                    }
                    var g2 = n4[d2];
                    g2 = Array.isArray(g2) ? g2 : [g2];
                    for (var f2 = 0; f2 < g2.length; ++f2) {
                      if (u2 && u2.cause == d2 + "," + f2) {
                        return;
                      }
                      var m2 = g2[f2];
                      var h = m2.inside;
                      var v = !!m2.lookbehind;
                      var E = !!m2.greedy;
                      var b = m2.alias;
                      if (E && !m2.pattern.global) {
                        var y = m2.pattern.toString().match(/[imsuy]*$/)[0];
                        m2.pattern = RegExp(m2.pattern.source, y + "g");
                      }
                      var S = m2.pattern || m2;
                      for (var A = r4.next, T = a3; A !== t3.tail; T += A.value.length, A = A.next) {
                        if (u2 && T >= u2.reach) {
                          break;
                        }
                        var I = A.value;
                        if (t3.length > e4.length) {
                          return;
                        }
                        if (I instanceof s) {
                          continue;
                        }
                        var O = 1;
                        var N;
                        if (E) {
                          N = o(S, T, e4, v);
                          if (!N || N.index >= e4.length) {
                            break;
                          }
                          var x = N.index;
                          var R = N.index + N[0].length;
                          var k = T;
                          k += A.value.length;
                          while (x >= k) {
                            A = A.next;
                            k += A.value.length;
                          }
                          k -= A.value.length;
                          T = k;
                          if (A.value instanceof s) {
                            continue;
                          }
                          for (var L = A; L !== t3.tail && (k < R || typeof L.value === "string"); L = L.next) {
                            O++;
                            k += L.value.length;
                          }
                          O--;
                          I = e4.slice(T, k);
                          N.index -= T;
                        } else {
                          N = o(S, 0, I, v);
                          if (!N) {
                            continue;
                          }
                        }
                        var x = N.index;
                        var F = N[0];
                        var w = I.slice(0, x);
                        var C = I.slice(x + F.length);
                        var D = T + I.length;
                        if (u2 && D > u2.reach) {
                          u2.reach = D;
                        }
                        var P = A.prev;
                        if (w) {
                          P = c(t3, P, w);
                          T += w.length;
                        }
                        p(t3, P, O);
                        var _ = new s(d2, h ? i.tokenize(F, h) : F, b, F);
                        A = c(t3, P, _);
                        if (C) {
                          c(t3, A, C);
                        }
                        if (O > 1) {
                          var $2 = {
                            cause: d2 + "," + f2,
                            reach: D
                          };
                          l(e4, t3, n4, A.prev, T, $2);
                          if (u2 && $2.reach > u2.reach) {
                            u2.reach = $2.reach;
                          }
                        }
                      }
                    }
                  }
                }
                function u() {
                  var e4 = {
                    value: null,
                    prev: null,
                    next: null
                  };
                  var t3 = {
                    value: null,
                    prev: e4,
                    next: null
                  };
                  e4.next = t3;
                  this.head = e4;
                  this.tail = t3;
                  this.length = 0;
                }
                function c(e4, t3, n4) {
                  var r4 = t3.next;
                  var a3 = {
                    value: n4,
                    prev: t3,
                    next: r4
                  };
                  t3.next = a3;
                  r4.prev = a3;
                  e4.length++;
                  return a3;
                }
                function p(e4, t3, n4) {
                  var r4 = t3.next;
                  for (var a3 = 0; a3 < n4 && r4 !== e4.tail; a3++) {
                    r4 = r4.next;
                  }
                  t3.next = r4;
                  r4.prev = t3;
                  e4.length -= a3;
                }
                function d(e4) {
                  var t3 = [];
                  var n4 = e4.head.next;
                  while (n4 !== e4.tail) {
                    t3.push(n4.value);
                    n4 = n4.next;
                  }
                  return t3;
                }
                if (!e3.document) {
                  if (!e3.addEventListener) {
                    return i;
                  }
                  if (!i.disableWorkerMessageHandler) {
                    e3.addEventListener("message", (function(t3) {
                      var n4 = JSON.parse(t3.data);
                      var r4 = n4.language;
                      var a3 = n4.code;
                      var s2 = n4.immediateClose;
                      e3.postMessage(i.highlight(a3, i.languages[r4], r4));
                      if (s2) {
                        e3.close();
                      }
                    }), false);
                  }
                  return i;
                }
                var g = i.util.currentScript();
                if (g) {
                  i.filename = g.src;
                  if (g.hasAttribute("data-manual")) {
                    i.manual = true;
                  }
                }
                function f() {
                  if (!i.manual) {
                    i.highlightAll();
                  }
                }
                if (!i.manual) {
                  var m = document.readyState;
                  if (m === "loading" || m === "interactive" && g && g.defer) {
                    document.addEventListener("DOMContentLoaded", f);
                  } else {
                    if (t2.requestAnimationFrame) {
                      t2.requestAnimationFrame(f);
                    } else {
                      t2.setTimeout(f, 16);
                    }
                  }
                }
                return i;
              })(r2);
              if (e2.exports) {
                e2.exports = a;
              }
              if (typeof n2 !== "undefined") {
                n2.Prism = a;
              }
              a.languages.json = {
                property: {
                  pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?=\s*:)/,
                  lookbehind: true,
                  greedy: true
                },
                string: {
                  pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?!\s*:)/,
                  lookbehind: true,
                  greedy: true
                },
                comment: {
                  pattern: /\/\/.*|\/\*[\s\S]*?(?:\*\/|$)/,
                  greedy: true
                },
                number: /-?\b\d+(?:\.\d+)?(?:e[+-]?\d+)?\b/i,
                punctuation: /[{}[\],]/,
                operator: /:/,
                boolean: /\b(?:false|true)\b/,
                null: {
                  pattern: /\bnull\b/,
                  alias: "keyword"
                }
              };
              a.languages.webmanifest = a.languages.json;
              a.languages.markup = {
                comment: {
                  pattern: /<!--(?:(?!<!--)[\s\S])*?-->/,
                  greedy: true
                },
                prolog: {
                  pattern: /<\?[\s\S]+?\?>/,
                  greedy: true
                },
                doctype: {
                  // https://www.w3.org/TR/xml/#NT-doctypedecl
                  pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
                  greedy: true,
                  inside: {
                    "internal-subset": {
                      pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
                      lookbehind: true,
                      greedy: true,
                      inside: null
                    },
                    string: {
                      pattern: /"[^"]*"|'[^']*'/,
                      greedy: true
                    },
                    punctuation: /^<!|>$|[[\]]/,
                    "doctype-tag": /^DOCTYPE/i,
                    name: /[^\s<>'"]+/
                  }
                },
                cdata: {
                  pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
                  greedy: true
                },
                tag: {
                  pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
                  greedy: true,
                  inside: {
                    tag: {
                      pattern: /^<\/?[^\s>\/]+/,
                      inside: {
                        punctuation: /^<\/?/,
                        namespace: /^[^\s>\/:]+:/
                      }
                    },
                    "special-attr": [],
                    "attr-value": {
                      pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
                      inside: {
                        punctuation: [{
                          pattern: /^=/,
                          alias: "attr-equals"
                        }, {
                          pattern: /^(\s*)["']|["']$/,
                          lookbehind: true
                        }]
                      }
                    },
                    punctuation: /\/?>/,
                    "attr-name": {
                      pattern: /[^\s>\/]+/,
                      inside: {
                        namespace: /^[^\s>\/:]+:/
                      }
                    }
                  }
                },
                entity: [{
                  pattern: /&[\da-z]{1,8};/i,
                  alias: "named-entity"
                }, /&#x?[\da-f]{1,8};/i]
              };
              a.languages.markup["tag"].inside["attr-value"].inside["entity"] = a.languages.markup["entity"];
              a.languages.markup["doctype"].inside["internal-subset"].inside = a.languages.markup;
              a.hooks.add("wrap", (function(e3) {
                if (e3.type === "entity") {
                  e3.attributes["title"] = e3.content.replace(/&amp;/, "&");
                }
              }));
              Object.defineProperty(a.languages.markup.tag, "addInlined", {
                /**
                * Adds an inlined language to markup.
                *
                * An example of an inlined language is CSS with `<style>` tags.
                *
                * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as
                * case insensitive.
                * @param {string} lang The language key.
                * @example
                * addInlined('style', 'css');
                */
                value: function e3(t3, n3) {
                  var r3 = {};
                  r3["language-" + n3] = {
                    pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
                    lookbehind: true,
                    inside: a.languages[n3]
                  };
                  r3["cdata"] = /^<!\[CDATA\[|\]\]>$/i;
                  var i = {
                    "included-cdata": {
                      pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
                      inside: r3
                    }
                  };
                  i["language-" + n3] = {
                    pattern: /[\s\S]+/,
                    inside: a.languages[n3]
                  };
                  var s = {};
                  s[t3] = {
                    pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, (function() {
                      return t3;
                    })), "i"),
                    lookbehind: true,
                    greedy: true,
                    inside: i
                  };
                  a.languages.insertBefore("markup", "cdata", s);
                }
              });
              Object.defineProperty(a.languages.markup.tag, "addAttribute", {
                /**
                * Adds an pattern to highlight languages embedded in HTML attributes.
                *
                * An example of an inlined language is CSS with `style` attributes.
                *
                * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as
                * case insensitive.
                * @param {string} lang The language key.
                * @example
                * addAttribute('style', 'css');
                */
                value: function(e3, t3) {
                  a.languages.markup.tag.inside["special-attr"].push({
                    pattern: RegExp(/(^|["'\s])/.source + "(?:" + e3 + ")" + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source, "i"),
                    lookbehind: true,
                    inside: {
                      "attr-name": /^[^\s=]+/,
                      "attr-value": {
                        pattern: /=[\s\S]+/,
                        inside: {
                          value: {
                            pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
                            lookbehind: true,
                            alias: [t3, "language-" + t3],
                            inside: a.languages[t3]
                          },
                          punctuation: [{
                            pattern: /^=/,
                            alias: "attr-equals"
                          }, /"|'/]
                        }
                      }
                    }
                  });
                }
              });
              a.languages.html = a.languages.markup;
              a.languages.mathml = a.languages.markup;
              a.languages.svg = a.languages.markup;
              a.languages.xml = a.languages.extend("markup", {});
              a.languages.ssml = a.languages.xml;
              a.languages.atom = a.languages.xml;
              a.languages.rss = a.languages.xml;
              a.languages.clike = {
                comment: [{
                  pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
                  lookbehind: true,
                  greedy: true
                }, {
                  pattern: /(^|[^\\:])\/\/.*/,
                  lookbehind: true,
                  greedy: true
                }],
                string: {
                  pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
                  greedy: true
                },
                "class-name": {
                  pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
                  lookbehind: true,
                  inside: {
                    punctuation: /[.\\]/
                  }
                },
                keyword: /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
                boolean: /\b(?:false|true)\b/,
                function: /\b\w+(?=\()/,
                number: /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
                operator: /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
                punctuation: /[{}[\];(),.:]/
              };
              a.languages.javascript = a.languages.extend("clike", {
                "class-name": [a.languages.clike["class-name"], {
                  pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,
                  lookbehind: true
                }],
                keyword: [{
                  pattern: /((?:^|\})\s*)catch\b/,
                  lookbehind: true
                }, {
                  pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
                  lookbehind: true
                }],
                // Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
                function: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
                number: {
                  pattern: RegExp(/(^|[^\w$])/.source + "(?:" + // constant
                  (/NaN|Infinity/.source + "|" + // binary integer
                  /0[bB][01]+(?:_[01]+)*n?/.source + "|" + // octal integer
                  /0[oO][0-7]+(?:_[0-7]+)*n?/.source + "|" + // hexadecimal integer
                  /0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source + "|" + // decimal bigint
                  /\d+(?:_\d+)*n/.source + "|" + // decimal number (integer or float) but no bigint
                  /(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source) + ")" + /(?![\w$])/.source),
                  lookbehind: true
                },
                operator: /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
              });
              a.languages.javascript["class-name"][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/;
              a.languages.insertBefore("javascript", "keyword", {
                regex: {
                  pattern: RegExp(
                    // lookbehind
                    // eslint-disable-next-line regexp/no-dupe-characters-character-class
                    /((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)/.source + // Regex pattern:
                    // There are 2 regex patterns here. The RegExp set notation proposal added support for nested character
                    // classes if the `v` flag is present. Unfortunately, nested CCs are both context-free and incompatible
                    // with the only syntax, so we have to define 2 different regex patterns.
                    /\//.source + "(?:" + /(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}/.source + "|" + // `v` flag syntax. This supports 3 levels of nested character classes.
                    /(?:\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.)*\])*\])*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source + ")" + // lookahead
                    /(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/.source
                  ),
                  lookbehind: true,
                  greedy: true,
                  inside: {
                    "regex-source": {
                      pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
                      lookbehind: true,
                      alias: "language-regex",
                      inside: a.languages.regex
                    },
                    "regex-delimiter": /^\/|\/$/,
                    "regex-flags": /^[a-z]+$/
                  }
                },
                // This must be declared before keyword because we use "function" inside the look-forward
                "function-variable": {
                  pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
                  alias: "function"
                },
                parameter: [{
                  pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
                  lookbehind: true,
                  inside: a.languages.javascript
                }, {
                  pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
                  lookbehind: true,
                  inside: a.languages.javascript
                }, {
                  pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
                  lookbehind: true,
                  inside: a.languages.javascript
                }, {
                  pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
                  lookbehind: true,
                  inside: a.languages.javascript
                }],
                constant: /\b[A-Z](?:[A-Z_]|\dx?)*\b/
              });
              a.languages.insertBefore("javascript", "string", {
                hashbang: {
                  pattern: /^#!.*/,
                  greedy: true,
                  alias: "comment"
                },
                "template-string": {
                  pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
                  greedy: true,
                  inside: {
                    "template-punctuation": {
                      pattern: /^`|`$/,
                      alias: "string"
                    },
                    interpolation: {
                      pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
                      lookbehind: true,
                      inside: {
                        "interpolation-punctuation": {
                          pattern: /^\$\{|\}$/,
                          alias: "punctuation"
                        },
                        rest: a.languages.javascript
                      }
                    },
                    string: /[\s\S]+/
                  }
                },
                "string-property": {
                  pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
                  lookbehind: true,
                  greedy: true,
                  alias: "property"
                }
              });
              a.languages.insertBefore("javascript", "operator", {
                "literal-property": {
                  pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
                  lookbehind: true,
                  alias: "property"
                }
              });
              if (a.languages.markup) {
                a.languages.markup.tag.addInlined("script", "javascript");
                a.languages.markup.tag.addAttribute(/on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source, "javascript");
              }
              a.languages.js = a.languages.javascript;
              (function(e3) {
                var t3 = e3.util.clone(e3.languages.javascript);
                var n3 = /(?:\s|\/\/.*(?!.)|\/\*(?:[^*]|\*(?!\/))\*\/)/.source;
                var r3 = /(?:\{(?:\{(?:\{[^{}]*\}|[^{}])*\}|[^{}])*\})/.source;
                var a2 = /(?:\{<S>*\.{3}(?:[^{}]|<BRACES>)*\})/.source;
                function i(e4, t4) {
                  e4 = e4.replace(/<S>/g, (function() {
                    return n3;
                  })).replace(/<BRACES>/g, (function() {
                    return r3;
                  })).replace(/<SPREAD>/g, (function() {
                    return a2;
                  }));
                  return RegExp(e4, t4);
                }
                a2 = i(a2).source;
                e3.languages.jsx = e3.languages.extend("markup", t3);
                e3.languages.jsx.tag.pattern = i(/<\/?(?:[\w.:-]+(?:<S>+(?:[\w.:$-]+(?:=(?:"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*'|[^\s{'"/>=]+|<BRACES>))?|<SPREAD>))*<S>*\/?)?>/.source);
                e3.languages.jsx.tag.inside["tag"].pattern = /^<\/?[^\s>\/]*/;
                e3.languages.jsx.tag.inside["attr-value"].pattern = /=(?!\{)(?:"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*'|[^\s'">]+)/;
                e3.languages.jsx.tag.inside["tag"].inside["class-name"] = /^[A-Z]\w*(?:\.[A-Z]\w*)*$/;
                e3.languages.jsx.tag.inside["comment"] = t3["comment"];
                e3.languages.insertBefore("inside", "attr-name", {
                  spread: {
                    pattern: i(/<SPREAD>/.source),
                    inside: e3.languages.jsx
                  }
                }, e3.languages.jsx.tag);
                e3.languages.insertBefore("inside", "special-attr", {
                  script: {
                    // Allow for two levels of nesting
                    pattern: i(/=<BRACES>/.source),
                    alias: "language-javascript",
                    inside: {
                      "script-punctuation": {
                        pattern: /^=(?=\{)/,
                        alias: "punctuation"
                      },
                      rest: e3.languages.jsx
                    }
                  }
                }, e3.languages.jsx.tag);
                var s = function(e4) {
                  if (!e4) {
                    return "";
                  }
                  if (typeof e4 === "string") {
                    return e4;
                  }
                  if (typeof e4.content === "string") {
                    return e4.content;
                  }
                  return e4.content.map(s).join("");
                };
                var o = function(t4) {
                  var n4 = [];
                  for (var r4 = 0; r4 < t4.length; r4++) {
                    var a3 = t4[r4];
                    var i2 = false;
                    if (typeof a3 !== "string") {
                      if (a3.type === "tag" && a3.content[0] && a3.content[0].type === "tag") {
                        if (a3.content[0].content[0].content === "</") {
                          if (n4.length > 0 && n4[n4.length - 1].tagName === s(a3.content[0].content[1])) {
                            n4.pop();
                          }
                        } else {
                          if (a3.content[a3.content.length - 1].content === "/>") {
                          } else {
                            n4.push({
                              tagName: s(a3.content[0].content[1]),
                              openedBraces: 0
                            });
                          }
                        }
                      } else if (n4.length > 0 && a3.type === "punctuation" && a3.content === "{") {
                        n4[n4.length - 1].openedBraces++;
                      } else if (n4.length > 0 && n4[n4.length - 1].openedBraces > 0 && a3.type === "punctuation" && a3.content === "}") {
                        n4[n4.length - 1].openedBraces--;
                      } else {
                        i2 = true;
                      }
                    }
                    if (i2 || typeof a3 === "string") {
                      if (n4.length > 0 && n4[n4.length - 1].openedBraces === 0) {
                        var l = s(a3);
                        if (r4 < t4.length - 1 && (typeof t4[r4 + 1] === "string" || t4[r4 + 1].type === "plain-text")) {
                          l += s(t4[r4 + 1]);
                          t4.splice(r4 + 1, 1);
                        }
                        if (r4 > 0 && (typeof t4[r4 - 1] === "string" || t4[r4 - 1].type === "plain-text")) {
                          l = s(t4[r4 - 1]) + l;
                          t4.splice(r4 - 1, 1);
                          r4--;
                        }
                        t4[r4] = new e3.Token("plain-text", l, null, l);
                      }
                    }
                    if (a3.content && typeof a3.content !== "string") {
                      o(a3.content);
                    }
                  }
                };
                e3.hooks.add("after-tokenize", (function(e4) {
                  if (e4.language !== "jsx" && e4.language !== "tsx") {
                    return;
                  }
                  o(e4.tokens);
                }));
              })(a);
              (function(e3) {
                e3.languages.typescript = e3.languages.extend("javascript", {
                  "class-name": {
                    pattern: /(\b(?:class|extends|implements|instanceof|interface|new|type)\s+)(?!keyof\b)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?:\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>)?/,
                    lookbehind: true,
                    greedy: true,
                    inside: null
                  },
                  builtin: /\b(?:Array|Function|Promise|any|boolean|console|never|number|string|symbol|unknown)\b/
                });
                e3.languages.typescript.keyword.push(
                  /\b(?:abstract|declare|is|keyof|readonly|require)\b/,
                  // keywords that have to be followed by an identifier
                  /\b(?:asserts|infer|interface|module|namespace|type)\b(?=\s*(?:[{_$a-zA-Z\xA0-\uFFFF]|$))/,
                  // This is for `import type *, {}`
                  /\btype\b(?=\s*(?:[\{*]|$))/
                );
                delete e3.languages.typescript["parameter"];
                delete e3.languages.typescript["literal-property"];
                var t3 = e3.languages.extend("typescript", {});
                delete t3["class-name"];
                e3.languages.typescript["class-name"].inside = t3;
                e3.languages.insertBefore("typescript", "function", {
                  decorator: {
                    pattern: /@[$\w\xA0-\uFFFF]+/,
                    inside: {
                      at: {
                        pattern: /^@/,
                        alias: "operator"
                      },
                      function: /^[\s\S]+/
                    }
                  },
                  "generic-function": {
                    // e.g. foo<T extends "bar" | "baz">( ...
                    pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>(?=\s*\()/,
                    greedy: true,
                    inside: {
                      function: /^#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*/,
                      generic: {
                        pattern: /<[\s\S]+/,
                        // everything after the first <
                        alias: "class-name",
                        inside: t3
                      }
                    }
                  }
                });
                e3.languages.ts = e3.languages.typescript;
              })(a);
              (function(e3) {
                var t3 = e3.util.clone(e3.languages.typescript);
                e3.languages.tsx = e3.languages.extend("jsx", t3);
                delete e3.languages.tsx["parameter"];
                delete e3.languages.tsx["literal-property"];
                var n3 = e3.languages.tsx.tag;
                n3.pattern = RegExp(/(^|[^\w$]|(?=<\/))/.source + "(?:" + n3.pattern.source + ")", n3.pattern.flags);
                n3.lookbehind = true;
              })(a);
              (function(e3) {
                var t3 = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;
                e3.languages.css = {
                  comment: /\/\*[\s\S]*?\*\//,
                  atrule: {
                    pattern: RegExp("@[\\w-](?:" + /[^;{\s"']|\s+(?!\s)/.source + "|" + t3.source + ")*?" + /(?:;|(?=\s*\{))/.source),
                    inside: {
                      rule: /^@[\w-]+/,
                      "selector-function-argument": {
                        pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
                        lookbehind: true,
                        alias: "selector"
                      },
                      keyword: {
                        pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
                        lookbehind: true
                      }
                    }
                  },
                  url: {
                    // https://drafts.csswg.org/css-values-3/#urls
                    pattern: RegExp("\\burl\\((?:" + t3.source + "|" + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ")\\)", "i"),
                    greedy: true,
                    inside: {
                      function: /^url/i,
                      punctuation: /^\(|\)$/,
                      string: {
                        pattern: RegExp("^" + t3.source + "$"),
                        alias: "url"
                      }
                    }
                  },
                  selector: {
                    pattern: RegExp(`(^|[{}\\s])[^{}\\s](?:[^{};"'\\s]|\\s+(?![\\s{])|` + t3.source + ")*(?=\\s*\\{)"),
                    lookbehind: true
                  },
                  string: {
                    pattern: t3,
                    greedy: true
                  },
                  property: {
                    pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
                    lookbehind: true
                  },
                  important: /!important\b/i,
                  function: {
                    pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
                    lookbehind: true
                  },
                  punctuation: /[(){};:,]/
                };
                e3.languages.css["atrule"].inside.rest = e3.languages.css;
                var n3 = e3.languages.markup;
                if (n3) {
                  n3.tag.addInlined("style", "css");
                  n3.tag.addAttribute("style", "css");
                }
              })(a);
              (function(e3) {
                var t3 = "\\b(?:BASH|BASHOPTS|BASH_ALIASES|BASH_ARGC|BASH_ARGV|BASH_CMDS|BASH_COMPLETION_COMPAT_DIR|BASH_LINENO|BASH_REMATCH|BASH_SOURCE|BASH_VERSINFO|BASH_VERSION|COLORTERM|COLUMNS|COMP_WORDBREAKS|DBUS_SESSION_BUS_ADDRESS|DEFAULTS_PATH|DESKTOP_SESSION|DIRSTACK|DISPLAY|EUID|GDMSESSION|GDM_LANG|GNOME_KEYRING_CONTROL|GNOME_KEYRING_PID|GPG_AGENT_INFO|GROUPS|HISTCONTROL|HISTFILE|HISTFILESIZE|HISTSIZE|HOME|HOSTNAME|HOSTTYPE|IFS|INSTANCE|JOB|LANG|LANGUAGE|LC_ADDRESS|LC_ALL|LC_IDENTIFICATION|LC_MEASUREMENT|LC_MONETARY|LC_NAME|LC_NUMERIC|LC_PAPER|LC_TELEPHONE|LC_TIME|LESSCLOSE|LESSOPEN|LINES|LOGNAME|LS_COLORS|MACHTYPE|MAILCHECK|MANDATORY_PATH|NO_AT_BRIDGE|OLDPWD|OPTERR|OPTIND|ORBIT_SOCKETDIR|OSTYPE|PAPERSIZE|PATH|PIPESTATUS|PPID|PS1|PS2|PS3|PS4|PWD|RANDOM|REPLY|SECONDS|SELINUX_INIT|SESSION|SESSIONTYPE|SESSION_MANAGER|SHELL|SHELLOPTS|SHLVL|SSH_AUTH_SOCK|TERM|UID|UPSTART_EVENTS|UPSTART_INSTANCE|UPSTART_JOB|UPSTART_SESSION|USER|WINDOWID|XAUTHORITY|XDG_CONFIG_DIRS|XDG_CURRENT_DESKTOP|XDG_DATA_DIRS|XDG_GREETER_DATA_DIR|XDG_MENU_PREFIX|XDG_RUNTIME_DIR|XDG_SEAT|XDG_SEAT_PATH|XDG_SESSION_DESKTOP|XDG_SESSION_ID|XDG_SESSION_PATH|XDG_SESSION_TYPE|XDG_VTNR|XMODIFIERS)\\b";
                var n3 = {
                  pattern: /(^(["']?)\w+\2)[ \t]+\S.*/,
                  lookbehind: true,
                  alias: "punctuation",
                  // this looks reasonably well in all themes
                  inside: null
                };
                var r3 = {
                  bash: n3,
                  environment: {
                    pattern: RegExp("\\$" + t3),
                    alias: "constant"
                  },
                  variable: [
                    // [0]: Arithmetic Environment
                    {
                      pattern: /\$?\(\([\s\S]+?\)\)/,
                      greedy: true,
                      inside: {
                        // If there is a $ sign at the beginning highlight $(( and )) as variable
                        variable: [{
                          pattern: /(^\$\(\([\s\S]+)\)\)/,
                          lookbehind: true
                        }, /^\$\(\(/],
                        number: /\b0x[\dA-Fa-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee]-?\d+)?/,
                        // Operators according to https://www.gnu.org/software/bash/manual/bashref.html#Shell-Arithmetic
                        operator: /--|\+\+|\*\*=?|<<=?|>>=?|&&|\|\||[=!+\-*/%<>^&|]=?|[?~:]/,
                        // If there is no $ sign at the beginning highlight (( and )) as punctuation
                        punctuation: /\(\(?|\)\)?|,|;/
                      }
                    },
                    // [1]: Command Substitution
                    {
                      pattern: /\$\((?:\([^)]+\)|[^()])+\)|`[^`]+`/,
                      greedy: true,
                      inside: {
                        variable: /^\$\(|^`|\)$|`$/
                      }
                    },
                    // [2]: Brace expansion
                    {
                      pattern: /\$\{[^}]+\}/,
                      greedy: true,
                      inside: {
                        operator: /:[-=?+]?|[!\/]|##?|%%?|\^\^?|,,?/,
                        punctuation: /[\[\]]/,
                        environment: {
                          pattern: RegExp("(\\{)" + t3),
                          lookbehind: true,
                          alias: "constant"
                        }
                      }
                    },
                    /\$(?:\w+|[#?*!@$])/
                  ],
                  // Escape sequences from echo and printf's manuals, and escaped quotes.
                  entity: /\\(?:[abceEfnrtv\\"]|O?[0-7]{1,3}|U[0-9a-fA-F]{8}|u[0-9a-fA-F]{4}|x[0-9a-fA-F]{1,2})/
                };
                e3.languages.bash = {
                  shebang: {
                    pattern: /^#!\s*\/.*/,
                    alias: "important"
                  },
                  comment: {
                    pattern: /(^|[^"{\\$])#.*/,
                    lookbehind: true
                  },
                  "function-name": [
                    // a) function foo {
                    // b) foo() {
                    // c) function foo() {
                    // but not foo {
                    {
                      // a) and c)
                      pattern: /(\bfunction\s+)[\w-]+(?=(?:\s*\(?:\s*\))?\s*\{)/,
                      lookbehind: true,
                      alias: "function"
                    },
                    {
                      // b)
                      pattern: /\b[\w-]+(?=\s*\(\s*\)\s*\{)/,
                      alias: "function"
                    }
                  ],
                  // Highlight variable names as variables in for and select beginnings.
                  "for-or-select": {
                    pattern: /(\b(?:for|select)\s+)\w+(?=\s+in\s)/,
                    alias: "variable",
                    lookbehind: true
                  },
                  // Highlight variable names as variables in the left-hand part
                  // of assignments (= and +=).
                  "assign-left": {
                    pattern: /(^|[\s;|&]|[<>]\()\w+(?:\.\w+)*(?=\+?=)/,
                    inside: {
                      environment: {
                        pattern: RegExp("(^|[\\s;|&]|[<>]\\()" + t3),
                        lookbehind: true,
                        alias: "constant"
                      }
                    },
                    alias: "variable",
                    lookbehind: true
                  },
                  // Highlight parameter names as variables
                  parameter: {
                    pattern: /(^|\s)-{1,2}(?:\w+:[+-]?)?\w+(?:\.\w+)*(?=[=\s]|$)/,
                    alias: "variable",
                    lookbehind: true
                  },
                  string: [
                    // Support for Here-documents https://en.wikipedia.org/wiki/Here_document
                    {
                      pattern: /((?:^|[^<])<<-?\s*)(\w+)\s[\s\S]*?(?:\r?\n|\r)\2/,
                      lookbehind: true,
                      greedy: true,
                      inside: r3
                    },
                    // Here-document with quotes around the tag
                    //  No expansion (so no inside).
                    {
                      pattern: /((?:^|[^<])<<-?\s*)(["'])(\w+)\2\s[\s\S]*?(?:\r?\n|\r)\3/,
                      lookbehind: true,
                      greedy: true,
                      inside: {
                        bash: n3
                      }
                    },
                    // Normal string
                    {
                      // https://www.gnu.org/software/bash/manual/html_node/Double-Quotes.html
                      pattern: /(^|[^\\](?:\\\\)*)"(?:\\[\s\S]|\$\([^)]+\)|\$(?!\()|`[^`]+`|[^"\\`$])*"/,
                      lookbehind: true,
                      greedy: true,
                      inside: r3
                    },
                    {
                      // https://www.gnu.org/software/bash/manual/html_node/Single-Quotes.html
                      pattern: /(^|[^$\\])'[^']*'/,
                      lookbehind: true,
                      greedy: true
                    },
                    {
                      // https://www.gnu.org/software/bash/manual/html_node/ANSI_002dC-Quoting.html
                      pattern: /\$'(?:[^'\\]|\\[\s\S])*'/,
                      greedy: true,
                      inside: {
                        entity: r3.entity
                      }
                    }
                  ],
                  environment: {
                    pattern: RegExp("\\$?" + t3),
                    alias: "constant"
                  },
                  variable: r3.variable,
                  function: {
                    pattern: /(^|[\s;|&]|[<>]\()(?:add|apropos|apt|apt-cache|apt-get|aptitude|aspell|automysqlbackup|awk|basename|bash|bc|bconsole|bg|bzip2|cal|cargo|cat|cfdisk|chgrp|chkconfig|chmod|chown|chroot|cksum|clear|cmp|column|comm|composer|cp|cron|crontab|csplit|curl|cut|date|dc|dd|ddrescue|debootstrap|df|diff|diff3|dig|dir|dircolors|dirname|dirs|dmesg|docker|docker-compose|du|egrep|eject|env|ethtool|expand|expect|expr|fdformat|fdisk|fg|fgrep|file|find|fmt|fold|format|free|fsck|ftp|fuser|gawk|git|gparted|grep|groupadd|groupdel|groupmod|groups|grub-mkconfig|gzip|halt|head|hg|history|host|hostname|htop|iconv|id|ifconfig|ifdown|ifup|import|install|ip|java|jobs|join|kill|killall|less|link|ln|locate|logname|logrotate|look|lpc|lpr|lprint|lprintd|lprintq|lprm|ls|lsof|lynx|make|man|mc|mdadm|mkconfig|mkdir|mke2fs|mkfifo|mkfs|mkisofs|mknod|mkswap|mmv|more|most|mount|mtools|mtr|mutt|mv|nano|nc|netstat|nice|nl|node|nohup|notify-send|npm|nslookup|op|open|parted|passwd|paste|pathchk|ping|pkill|pnpm|podman|podman-compose|popd|pr|printcap|printenv|ps|pushd|pv|quota|quotacheck|quotactl|ram|rar|rcp|reboot|remsync|rename|renice|rev|rm|rmdir|rpm|rsync|scp|screen|sdiff|sed|sendmail|seq|service|sftp|sh|shellcheck|shuf|shutdown|sleep|slocate|sort|split|ssh|stat|strace|su|sudo|sum|suspend|swapon|sync|sysctl|tac|tail|tar|tee|time|timeout|top|touch|tr|traceroute|tsort|tty|umount|uname|unexpand|uniq|units|unrar|unshar|unzip|update-grub|uptime|useradd|userdel|usermod|users|uudecode|uuencode|v|vcpkg|vdir|vi|vim|virsh|vmstat|wait|watch|wc|wget|whereis|which|who|whoami|write|xargs|xdg-open|yarn|yes|zenity|zip|zsh|zypper)(?=$|[)\s;|&])/,
                    lookbehind: true
                  },
                  keyword: {
                    pattern: /(^|[\s;|&]|[<>]\()(?:case|do|done|elif|else|esac|fi|for|function|if|in|select|then|until|while)(?=$|[)\s;|&])/,
                    lookbehind: true
                  },
                  // https://www.gnu.org/software/bash/manual/html_node/Shell-Builtin-Commands.html
                  builtin: {
                    pattern: /(^|[\s;|&]|[<>]\()(?:\.|:|alias|bind|break|builtin|caller|cd|command|continue|declare|echo|enable|eval|exec|exit|export|getopts|hash|help|let|local|logout|mapfile|printf|pwd|read|readarray|readonly|return|set|shift|shopt|source|test|times|trap|type|typeset|ulimit|umask|unalias|unset)(?=$|[)\s;|&])/,
                    lookbehind: true,
                    // Alias added to make those easier to distinguish from strings.
                    alias: "class-name"
                  },
                  boolean: {
                    pattern: /(^|[\s;|&]|[<>]\()(?:false|true)(?=$|[)\s;|&])/,
                    lookbehind: true
                  },
                  "file-descriptor": {
                    pattern: /\B&\d\b/,
                    alias: "important"
                  },
                  operator: {
                    // Lots of redirections here, but not just that.
                    pattern: /\d?<>|>\||\+=|=[=~]?|!=?|<<[<-]?|[&\d]?>>|\d[<>]&?|[<>][&=]?|&[>&]?|\|[&|]?/,
                    inside: {
                      "file-descriptor": {
                        pattern: /^\d/,
                        alias: "important"
                      }
                    }
                  },
                  punctuation: /\$?\(\(?|\)\)?|\.\.|[{}[\];\\]/,
                  number: {
                    pattern: /(^|\s)(?:[1-9]\d*|0)(?:[.,]\d+)?\b/,
                    lookbehind: true
                  }
                };
                n3.inside = e3.languages.bash;
                var a2 = ["comment", "function-name", "for-or-select", "assign-left", "parameter", "string", "environment", "function", "keyword", "builtin", "boolean", "file-descriptor", "operator", "punctuation", "number"];
                var i = r3.variable[1].inside;
                for (var s = 0; s < a2.length; s++) {
                  i[a2[s]] = e3.languages.bash[a2[s]];
                }
                e3.languages.sh = e3.languages.bash;
                e3.languages.shell = e3.languages.bash;
              })(a);
              (function(e3) {
                var t3 = /[*&][^\s[\]{},]+/;
                var n3 = /!(?:<[\w\-%#;/?:@&=+$,.!~*'()[\]]+>|(?:[a-zA-Z\d-]*!)?[\w\-%#;/?:@&=+$.~*'()]+)?/;
                var r3 = "(?:" + n3.source + "(?:[ 	]+" + t3.source + ")?|" + t3.source + "(?:[ 	]+" + n3.source + ")?)";
                var a2 = /(?:[^\s\x00-\x08\x0e-\x1f!"#%&'*,\-:>?@[\]`{|}\x7f-\x84\x86-\x9f\ud800-\udfff\ufffe\uffff]|[?:-]<PLAIN>)(?:[ \t]*(?:(?![#:])<PLAIN>|:<PLAIN>))*/.source.replace(/<PLAIN>/g, (function() {
                  return /[^\s\x00-\x08\x0e-\x1f,[\]{}\x7f-\x84\x86-\x9f\ud800-\udfff\ufffe\uffff]/.source;
                }));
                var i = /"(?:[^"\\\r\n]|\\.)*"|'(?:[^'\\\r\n]|\\.)*'/.source;
                function s(e4, t4) {
                  t4 = (t4 || "").replace(/m/g, "") + "m";
                  var n4 = /([:\-,[{]\s*(?:\s<<prop>>[ \t]+)?)(?:<<value>>)(?=[ \t]*(?:$|,|\]|\}|(?:[\r\n]\s*)?#))/.source.replace(/<<prop>>/g, (function() {
                    return r3;
                  })).replace(/<<value>>/g, (function() {
                    return e4;
                  }));
                  return RegExp(n4, t4);
                }
                e3.languages.yaml = {
                  scalar: {
                    pattern: RegExp(/([\-:]\s*(?:\s<<prop>>[ \t]+)?[|>])[ \t]*(?:((?:\r?\n|\r)[ \t]+)\S[^\r\n]*(?:\2[^\r\n]+)*)/.source.replace(/<<prop>>/g, (function() {
                      return r3;
                    }))),
                    lookbehind: true,
                    alias: "string"
                  },
                  comment: /#.*/,
                  key: {
                    pattern: RegExp(/((?:^|[:\-,[{\r\n?])[ \t]*(?:<<prop>>[ \t]+)?)<<key>>(?=\s*:\s)/.source.replace(/<<prop>>/g, (function() {
                      return r3;
                    })).replace(/<<key>>/g, (function() {
                      return "(?:" + a2 + "|" + i + ")";
                    }))),
                    lookbehind: true,
                    greedy: true,
                    alias: "atrule"
                  },
                  directive: {
                    pattern: /(^[ \t]*)%.+/m,
                    lookbehind: true,
                    alias: "important"
                  },
                  datetime: {
                    pattern: s(/\d{4}-\d\d?-\d\d?(?:[tT]|[ \t]+)\d\d?:\d{2}:\d{2}(?:\.\d*)?(?:[ \t]*(?:Z|[-+]\d\d?(?::\d{2})?))?|\d{4}-\d{2}-\d{2}|\d\d?:\d{2}(?::\d{2}(?:\.\d*)?)?/.source),
                    lookbehind: true,
                    alias: "number"
                  },
                  boolean: {
                    pattern: s(/false|true/.source, "i"),
                    lookbehind: true,
                    alias: "important"
                  },
                  null: {
                    pattern: s(/null|~/.source, "i"),
                    lookbehind: true,
                    alias: "important"
                  },
                  string: {
                    pattern: s(i),
                    lookbehind: true,
                    greedy: true
                  },
                  number: {
                    pattern: s(/[+-]?(?:0x[\da-f]+|0o[0-7]+|(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?|\.inf|\.nan)/.source, "i"),
                    lookbehind: true
                  },
                  tag: n3,
                  important: t3,
                  punctuation: /---|[:[\]{}\-,|>?]|\.\.\./
                };
                e3.languages.yml = e3.languages.yaml;
              })(a);
              a.languages["splunk-spl"] = {
                comment: /`comment\("(?:\\.|[^\\"])*"\)`/,
                string: {
                  pattern: /"(?:\\.|[^\\"])*"/,
                  greedy: true
                },
                // https://docs.splunk.com/Documentation/Splunk/7.3.0/SearchReference/ListOfSearchCommands
                keyword: /\b(?:abstract|accum|addcoltotals|addinfo|addtotals|analyzefields|anomalies|anomalousvalue|anomalydetection|append|appendcols|appendcsv|appendlookup|appendpipe|arules|associate|audit|autoregress|bin|bucket|bucketdir|chart|cluster|cofilter|collect|concurrency|contingency|convert|correlate|datamodel|dbinspect|dedup|delete|delta|diff|erex|eval|eventcount|eventstats|extract|fieldformat|fields|fieldsummary|filldown|fillnull|findtypes|folderize|foreach|format|from|gauge|gentimes|geom|geomfilter|geostats|head|highlight|history|iconify|input|inputcsv|inputlookup|iplocation|join|kmeans|kv|kvform|loadjob|localize|localop|lookup|makecontinuous|makemv|makeresults|map|mcollect|metadata|metasearch|meventcollect|mstats|multikv|multisearch|mvcombine|mvexpand|nomv|outlier|outputcsv|outputlookup|outputtext|overlap|pivot|predict|rangemap|rare|regex|relevancy|reltime|rename|replace|rest|return|reverse|rex|rtorder|run|savedsearch|script|scrub|search|searchtxn|selfjoin|sendemail|set|setfields|sichart|sirare|sistats|sitimechart|sitop|sort|spath|stats|strcat|streamstats|table|tags|tail|timechart|timewrap|top|transaction|transpose|trendline|tscollect|tstats|typeahead|typelearner|typer|union|uniq|untable|where|x11|xmlkv|xmlunescape|xpath|xyseries)\b/i,
                "operator-word": {
                  pattern: /\b(?:and|as|by|not|or|xor)\b/i,
                  alias: "operator"
                },
                function: /\b\w+(?=\s*\()/,
                property: /\b\w+(?=\s*=(?!=))/,
                date: {
                  // MM/DD/YYYY(:HH:MM:SS)?
                  pattern: /\b\d{1,2}\/\d{1,2}\/\d{1,4}(?:(?::\d{1,2}){3})?\b/,
                  alias: "number"
                },
                number: /\b\d+(?:\.\d+)?\b/,
                boolean: /\b(?:f|false|t|true)\b/i,
                operator: /[<>=]=?|[-+*/%|]/,
                punctuation: /[()[\],]/
              };
              a.languages.sql = {
                comment: {
                  pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|(?:--|\/\/|#).*)/,
                  lookbehind: true
                },
                variable: [{
                  pattern: /@(["'`])(?:\\[\s\S]|(?!\1)[^\\])+\1/,
                  greedy: true
                }, /@[\w.$]+/],
                string: {
                  pattern: /(^|[^@\\])("|')(?:\\[\s\S]|(?!\2)[^\\]|\2\2)*\2/,
                  greedy: true,
                  lookbehind: true
                },
                identifier: {
                  pattern: /(^|[^@\\])`(?:\\[\s\S]|[^`\\]|``)*`/,
                  greedy: true,
                  lookbehind: true,
                  inside: {
                    punctuation: /^`|`$/
                  }
                },
                function: /\b(?:AVG|COUNT|FIRST|FORMAT|LAST|LCASE|LEN|MAX|MID|MIN|MOD|NOW|ROUND|SUM|UCASE)(?=\s*\()/i,
                // Should we highlight user defined functions too?
                keyword: /\b(?:ACTION|ADD|AFTER|ALGORITHM|ALL|ALTER|ANALYZE|ANY|APPLY|AS|ASC|AUTHORIZATION|AUTO_INCREMENT|BACKUP|BDB|BEGIN|BERKELEYDB|BIGINT|BINARY|BIT|BLOB|BOOL|BOOLEAN|BREAK|BROWSE|BTREE|BULK|BY|CALL|CASCADED?|CASE|CHAIN|CHAR(?:ACTER|SET)?|CHECK(?:POINT)?|CLOSE|CLUSTERED|COALESCE|COLLATE|COLUMNS?|COMMENT|COMMIT(?:TED)?|COMPUTE|CONNECT|CONSISTENT|CONSTRAINT|CONTAINS(?:TABLE)?|CONTINUE|CONVERT|CREATE|CROSS|CURRENT(?:_DATE|_TIME|_TIMESTAMP|_USER)?|CURSOR|CYCLE|DATA(?:BASES?)?|DATE(?:TIME)?|DAY|DBCC|DEALLOCATE|DEC|DECIMAL|DECLARE|DEFAULT|DEFINER|DELAYED|DELETE|DELIMITERS?|DENY|DESC|DESCRIBE|DETERMINISTIC|DISABLE|DISCARD|DISK|DISTINCT|DISTINCTROW|DISTRIBUTED|DO|DOUBLE|DROP|DUMMY|DUMP(?:FILE)?|DUPLICATE|ELSE(?:IF)?|ENABLE|ENCLOSED|END|ENGINE|ENUM|ERRLVL|ERRORS|ESCAPED?|EXCEPT|EXEC(?:UTE)?|EXISTS|EXIT|EXPLAIN|EXTENDED|FETCH|FIELDS|FILE|FILLFACTOR|FIRST|FIXED|FLOAT|FOLLOWING|FOR(?: EACH ROW)?|FORCE|FOREIGN|FREETEXT(?:TABLE)?|FROM|FULL|FUNCTION|GEOMETRY(?:COLLECTION)?|GLOBAL|GOTO|GRANT|GROUP|HANDLER|HASH|HAVING|HOLDLOCK|HOUR|IDENTITY(?:COL|_INSERT)?|IF|IGNORE|IMPORT|INDEX|INFILE|INNER|INNODB|INOUT|INSERT|INT|INTEGER|INTERSECT|INTERVAL|INTO|INVOKER|ISOLATION|ITERATE|JOIN|KEYS?|KILL|LANGUAGE|LAST|LEAVE|LEFT|LEVEL|LIMIT|LINENO|LINES|LINESTRING|LOAD|LOCAL|LOCK|LONG(?:BLOB|TEXT)|LOOP|MATCH(?:ED)?|MEDIUM(?:BLOB|INT|TEXT)|MERGE|MIDDLEINT|MINUTE|MODE|MODIFIES|MODIFY|MONTH|MULTI(?:LINESTRING|POINT|POLYGON)|NATIONAL|NATURAL|NCHAR|NEXT|NO|NONCLUSTERED|NULLIF|NUMERIC|OFF?|OFFSETS?|ON|OPEN(?:DATASOURCE|QUERY|ROWSET)?|OPTIMIZE|OPTION(?:ALLY)?|ORDER|OUT(?:ER|FILE)?|OVER|PARTIAL|PARTITION|PERCENT|PIVOT|PLAN|POINT|POLYGON|PRECEDING|PRECISION|PREPARE|PREV|PRIMARY|PRINT|PRIVILEGES|PROC(?:EDURE)?|PUBLIC|PURGE|QUICK|RAISERROR|READS?|REAL|RECONFIGURE|REFERENCES|RELEASE|RENAME|REPEAT(?:ABLE)?|REPLACE|REPLICATION|REQUIRE|RESIGNAL|RESTORE|RESTRICT|RETURN(?:ING|S)?|REVOKE|RIGHT|ROLLBACK|ROUTINE|ROW(?:COUNT|GUIDCOL|S)?|RTREE|RULE|SAVE(?:POINT)?|SCHEMA|SECOND|SELECT|SERIAL(?:IZABLE)?|SESSION(?:_USER)?|SET(?:USER)?|SHARE|SHOW|SHUTDOWN|SIMPLE|SMALLINT|SNAPSHOT|SOME|SONAME|SQL|START(?:ING)?|STATISTICS|STATUS|STRIPED|SYSTEM_USER|TABLES?|TABLESPACE|TEMP(?:ORARY|TABLE)?|TERMINATED|TEXT(?:SIZE)?|THEN|TIME(?:STAMP)?|TINY(?:BLOB|INT|TEXT)|TOP?|TRAN(?:SACTIONS?)?|TRIGGER|TRUNCATE|TSEQUAL|TYPES?|UNBOUNDED|UNCOMMITTED|UNDEFINED|UNION|UNIQUE|UNLOCK|UNPIVOT|UNSIGNED|UPDATE(?:TEXT)?|USAGE|USE|USER|USING|VALUES?|VAR(?:BINARY|CHAR|CHARACTER|YING)|VIEW|WAITFOR|WARNINGS|WHEN|WHERE|WHILE|WITH(?: ROLLUP|IN)?|WORK|WRITE(?:TEXT)?|YEAR)\b/i,
                boolean: /\b(?:FALSE|NULL|TRUE)\b/i,
                number: /\b0x[\da-f]+\b|\b\d+(?:\.\d*)?|\B\.\d+\b/i,
                operator: /[-+*\/=%^~]|&&?|\|\|?|!=?|<(?:=>?|<|>)?|>[>=]?|\b(?:AND|BETWEEN|DIV|ILIKE|IN|IS|LIKE|NOT|OR|REGEXP|RLIKE|SOUNDS LIKE|XOR)\b/i,
                punctuation: /[;[\]()`,.]/
              };
            })();
          }
        ),
        /***/
        9497: (
          /***/
          (e2) => {
            "use strict";
            e2.exports = require_react();
          }
        )
      };
      var t = {};
      function n(r2) {
        var a = t[r2];
        if (a !== void 0) {
          return a.exports;
        }
        var i = t[r2] = {
          /******/
          // no module.id needed
          /******/
          // no module.loaded needed
          /******/
          exports: {}
          /******/
        };
        e[r2](i, i.exports, n);
        return i.exports;
      }
      (() => {
        n.n = (e2) => {
          var t2 = e2 && e2.__esModule ? (
            /******/
            () => e2["default"]
          ) : () => e2;
          n.d(t2, {
            a: t2
          });
          return t2;
        };
      })();
      (() => {
        n.d = (e2, t2) => {
          for (var r2 in t2) {
            if (n.o(t2, r2) && !n.o(e2, r2)) {
              Object.defineProperty(e2, r2, {
                enumerable: true,
                get: t2[r2]
              });
            }
          }
        };
      })();
      (() => {
        n.o = (e2, t2) => Object.prototype.hasOwnProperty.call(e2, t2);
      })();
      (() => {
        n.r = (e2) => {
          if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
            Object.defineProperty(e2, Symbol.toStringTag, {
              value: "Module"
            });
          }
          Object.defineProperty(e2, "__esModule", {
            value: true
          });
        };
      })();
      var r = {};
      (() => {
        "use strict";
        n.r(r);
        n.d(r, {
          default: () => (
            /* reexport */
            re
          )
        });
        var e2 = n(9497);
        var t2 = n.n(e2);
        const a = require_castArray();
        var i = n.n(a);
        const s = require_flatten();
        var o = n.n(s);
        const l = require_indexOf();
        var u = n.n(l);
        const c = require_repeat();
        var p = n.n(c);
        const d = require_times();
        var g = n.n(d);
        const f = require_prop_types();
        var m = n.n(f);
        const h = (init_styled_components_esm(), __toCommonJS(styled_components_esm_exports));
        var v = n.n(h);
        const E = require_themes();
        var b = "1.429em";
        var y = v().pre.withConfig({
          displayName: "CodeStyles__StyledPre",
          componentId: "sc-1eq4k68-0"
        })(["", ";", ";line-height:", ";position:relative;gap:", ";text-align:left;tab-size:4;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;hyphens:none;overflow-x:auto;&:focus-visible{box-shadow:", ";}", ""], E.mixins.reset("grid"), E.mixins.typography("monoBody"), b, E.variables.spacingMedium, E.variables.focusShadow, (function(e3) {
          var t3 = e3.$showLineNumbers, n2 = e3.$counterReset;
          return t3 && (0, h.css)(["grid-template-columns:min-content auto;counter-reset:linenumber ", ";"], n2);
        }));
        var S = v().code.withConfig({
          displayName: "CodeStyles__StyledCode",
          componentId: "sc-1eq4k68-1"
        })(["font-family:", ";position:relative;z-index:1;", ";"], E.variables.monoFontFamily, (function(e3) {
          var t3 = e3.$isPlaintext;
          return !t3 && (0, h.css)(["color:", ";"], E.variables.syntaxTeal);
        }));
        var A = v().span.withConfig({
          displayName: "CodeStyles__StyledIndent",
          componentId: "sc-1eq4k68-2"
        })(["&:not(:last-child){background-image:linear-gradient( to left,", " 1px,transparent 1px,transparent );}"], E.variables.syntaxGray);
        var T = {
          comment: E.variables.syntaxGray,
          prolog: E.variables.syntaxGray,
          doctype: E.variables.syntaxGray,
          cdata: E.variables.syntaxGray,
          punctuation: E.variables.syntaxGray,
          property: E.variables.syntaxPurple,
          tag: E.variables.syntaxPurple,
          boolean: E.variables.syntaxPurple,
          number: E.variables.syntaxPurple,
          constant: E.variables.syntaxPurple,
          symbol: E.variables.syntaxPurple,
          deleted: E.variables.syntaxPurple,
          key: E.variables.syntaxPurple,
          selector: E.variables.syntaxGreen,
          "attr-name": E.variables.syntaxGreen,
          string: E.variables.syntaxGreen,
          char: E.variables.syntaxGreen,
          builtin: E.variables.syntaxGreen,
          inserted: E.variables.syntaxGreen,
          operator: E.variables.syntaxBrown,
          entity: E.variables.syntaxBrown,
          url: E.variables.syntaxBrown,
          atrule: E.variables.syntaxBlue,
          "attr-value": E.variables.syntaxBlue,
          keyword: E.variables.syntaxBlue,
          function: E.variables.syntaxRed,
          regex: E.variables.syntaxOrange,
          important: E.variables.syntaxOrange,
          variable: E.variables.syntaxOrange
        };
        var I = v().span.withConfig({
          displayName: "CodeStyles__StyledToken",
          componentId: "sc-1eq4k68-3"
        })(["color:", ";cursor:", ";opacity:", ";font-style:", ";font-weight:", ";"], (function(e3) {
          var t3 = e3.partType;
          return T[t3];
        }), (function(e3) {
          var t3 = e3.partType;
          return t3 === "entity" ? "help" : null;
        }), (function(e3) {
          var t3 = e3.partType;
          return t3 === "namespace" ? 0.7 : null;
        }), (function(e3) {
          var t3 = e3.partType;
          return t3 === "italic" ? "italic" : null;
        }), (function(e3) {
          var t3 = e3.partType;
          return t3 === "important" || t3 === "bold" ? E.variables.fontWeightBold : null;
        }));
        var O = v().div.withConfig({
          displayName: "LineHighlightsStyles__StyledLineHighlight",
          componentId: "sc-1x2b02z-0"
        })(["position:absolute;left:0;height:1lh;background:", ";border-left:2px solid ", ";pointer-events:none;line-height:inherit;top:", ";width:", "px;"], E.variables.notificationColorInfoWeak, E.variables.notificationColorInfo, (function(e3) {
          var t3 = e3.$lineNum;
          return "calc(".concat(t3 - 1, "  * ").concat(b, ")");
        }), (function(e3) {
          var t3 = e3.$width;
          return t3;
        }));
        function N(e3, t3) {
          return F(e3) || L(e3, t3) || R(e3, t3) || x();
        }
        function x() {
          throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        function R(e3, t3) {
          if (e3) {
            if ("string" == typeof e3) return k(e3, t3);
            var n2 = {}.toString.call(e3).slice(8, -1);
            return "Object" === n2 && e3.constructor && (n2 = e3.constructor.name), "Map" === n2 || "Set" === n2 ? Array.from(e3) : "Arguments" === n2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2) ? k(e3, t3) : void 0;
          }
        }
        function k(e3, t3) {
          (null == t3 || t3 > e3.length) && (t3 = e3.length);
          for (var n2 = 0, r2 = Array(t3); n2 < t3; n2++) {
            r2[n2] = e3[n2];
          }
          return r2;
        }
        function L(e3, t3) {
          var n2 = null == e3 ? null : "undefined" != typeof Symbol && e3[Symbol.iterator] || e3["@@iterator"];
          if (null != n2) {
            var r2, a2, i2, s2, o2 = [], l2 = true, u2 = false;
            try {
              if (i2 = (n2 = n2.call(e3)).next, 0 === t3) {
                if (Object(n2) !== n2) return;
                l2 = false;
              } else for (; !(l2 = (r2 = i2.call(n2)).done) && (o2.push(r2.value), o2.length !== t3); l2 = true) {
              }
            } catch (e4) {
              u2 = true, a2 = e4;
            } finally {
              try {
                if (!l2 && null != n2["return"] && (s2 = n2["return"](), Object(s2) !== s2)) return;
              } finally {
                if (u2) throw a2;
              }
            }
            return o2;
          }
        }
        function F(e3) {
          if (Array.isArray(e3)) return e3;
        }
        var w = function e3(t3) {
          return t3.replace(/\s+/g, "").split(",").filter(Boolean).map((function(e4) {
            var t4 = e4.split("-").map(Number), n2 = N(t4, 2), r2 = n2[0], a2 = n2[1];
            return [r2, a2 || r2];
          }));
        };
        var C = function e3(t3) {
          var n2 = t3.map((function(e4) {
            var t4 = N(e4, 2), n3 = t4[0], r2 = t4[1];
            return Array.from({
              length: r2 - n3 + 1
            }, (function(e5, t5) {
              return n3 + t5;
            }));
          })).reduce((function(e4, t4) {
            return e4.concat(t4);
          }), []);
          return Array.from(new Set(n2));
        };
        var D = function e3(n2) {
          var r2 = n2.highlight, a2 = n2.width;
          var i2 = w(r2);
          var s2 = C(i2);
          return t2().createElement(t2().Fragment, null, s2.map((function(e4) {
            return t2().createElement(O, {
              key: e4,
              className: "line-highlight",
              "aria-hidden": "true",
              $lineNum: e4,
              $width: a2
            });
          })));
        };
        const P = D;
        var _ = v().span.withConfig({
          displayName: "LineNumbersStyles__StyledLineNumberRows",
          componentId: "sc-1h4k3dh-0"
        })(["pointer-events:none;user-select:none;border-right:1px solid ", ";z-index:1;& > span{display:block;counter-increment:linenumber;&::before{display:block;content:counter(linenumber);color:", ";padding-inline-end:", ";text-align:right;}}"], E.variables.borderColor, E.variables.syntaxGray, E.variables.spacingSmall);
        function $2(e3) {
          var n2 = e3.value, r2 = n2 === void 0 ? "" : n2;
          var a2 = r2.match(/\n(?!$)/g);
          var i2 = a2 ? a2.length + 1 : 1;
          var s2 = Array.from({
            length: i2
          }, (function(e4, n3) {
            return t2().createElement("span", {
              key: n3
            });
          }));
          return t2().createElement(_, {
            "aria-hidden": true
          }, s2);
        }
        const U = $2;
        var M = n(6283);
        var B = n(74);
        var G = n.n(B);
        function j(e3, t3) {
          if (e3) {
            if (typeof e3 === "function") {
              e3(t3);
            } else {
              e3.current = t3;
            }
          }
        }
        function H() {
          return H = Object.assign ? Object.assign.bind() : function(e3) {
            for (var t3 = 1; t3 < arguments.length; t3++) {
              var n2 = arguments[t3];
              for (var r2 in n2) {
                ({}).hasOwnProperty.call(n2, r2) && (e3[r2] = n2[r2]);
              }
            }
            return e3;
          }, H.apply(null, arguments);
        }
        function z(e3, t3) {
          return K(e3) || q(e3, t3) || X(e3, t3) || Y();
        }
        function Y() {
          throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        function X(e3, t3) {
          if (e3) {
            if ("string" == typeof e3) return W(e3, t3);
            var n2 = {}.toString.call(e3).slice(8, -1);
            return "Object" === n2 && e3.constructor && (n2 = e3.constructor.name), "Map" === n2 || "Set" === n2 ? Array.from(e3) : "Arguments" === n2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2) ? W(e3, t3) : void 0;
          }
        }
        function W(e3, t3) {
          (null == t3 || t3 > e3.length) && (t3 = e3.length);
          for (var n2 = 0, r2 = Array(t3); n2 < t3; n2++) {
            r2[n2] = e3[n2];
          }
          return r2;
        }
        function q(e3, t3) {
          var n2 = null == e3 ? null : "undefined" != typeof Symbol && e3[Symbol.iterator] || e3["@@iterator"];
          if (null != n2) {
            var r2, a2, i2, s2, o2 = [], l2 = true, u2 = false;
            try {
              if (i2 = (n2 = n2.call(e3)).next, 0 === t3) {
                if (Object(n2) !== n2) return;
                l2 = false;
              } else for (; !(l2 = (r2 = i2.call(n2)).done) && (o2.push(r2.value), o2.length !== t3); l2 = true) {
              }
            } catch (e4) {
              u2 = true, a2 = e4;
            } finally {
              try {
                if (!l2 && null != n2["return"] && (s2 = n2["return"](), Object(s2) !== s2)) return;
              } finally {
                if (u2) throw a2;
              }
            }
            return o2;
          }
        }
        function K(e3) {
          if (Array.isArray(e3)) return e3;
        }
        function V(e3, t3) {
          if (null == e3) return {};
          var n2, r2, a2 = Z(e3, t3);
          if (Object.getOwnPropertySymbols) {
            var i2 = Object.getOwnPropertySymbols(e3);
            for (r2 = 0; r2 < i2.length; r2++) {
              n2 = i2[r2], -1 === t3.indexOf(n2) && {}.propertyIsEnumerable.call(e3, n2) && (a2[n2] = e3[n2]);
            }
          }
          return a2;
        }
        function Z(e3, t3) {
          if (null == e3) return {};
          var n2 = {};
          for (var r2 in e3) {
            if ({}.hasOwnProperty.call(e3, r2)) {
              if (-1 !== t3.indexOf(r2)) continue;
              n2[r2] = e3[r2];
            }
          }
          return n2;
        }
        var Q = ["bash", "clike", "css", "html", "json", "javascript", "js", "jsx", "typescript", "ts", "tsx", "markup", "mathml", "plain", "plaintext", "splunk-spl", "sql", "svg", "text", "txt", "xml", "yaml", "yml"];
        function J(e3) {
          return ["plain", "plaintext", "text", "txt"].includes(e3);
        }
        function ee(e3, t3) {
          if (J(t3)) {
            return G().tokenize(e3, {});
          }
          return G().tokenize(e3, G().languages[t3]);
        }
        var te = {
          elementRef: m().oneOfType([m().func, m().object]),
          indentChars: m().number,
          language: m().oneOf(Q),
          languageFallback: m().oneOf(Q),
          lineHighlights: m().string,
          lineNumberStart: m().number,
          showIndentGuide: m().bool,
          showLineNumbers: m().bool,
          value: m().string
        };
        function ne(n2) {
          var r2 = n2.elementRef, a2 = n2.indentChars, s2 = a2 === void 0 ? 4 : a2, l2 = n2.language, c2 = n2.languageFallback, d2 = c2 === void 0 ? "javascript" : c2, f2 = n2.lineHighlights, m2 = n2.lineNumberStart, h2 = n2.showIndentGuide, v2 = h2 === void 0 ? true : h2, E2 = n2.showLineNumbers, b2 = n2.value, T2 = b2 === void 0 ? "" : b2, O2 = V(n2, ["elementRef", "indentChars", "language", "languageFallback", "lineHighlights", "lineNumberStart", "showIndentGuide", "showLineNumbers", "value"]);
          var N2 = (0, e2.useRef)(null);
          var x2 = (0, e2.useState)(void 0), R2 = z(x2, 2), k2 = R2[0], L2 = R2[1];
          var F2 = (0, M["default"])(N2), w2 = F2.width, C2 = F2.height;
          var D2 = (0, e2.useCallback)((function(e3) {
            j(N2, e3);
            j(r2, e3);
          }), [r2]);
          (0, e2.useEffect)((function() {
            var e3 = N2.current;
            if (e3) {
              var t3 = e3.scrollHeight > Math.round(C2);
              var n3 = e3.scrollWidth > Math.round(w2);
              var r3 = t3 || n3;
              L2(r3 ? 0 : void 0);
            }
          }), [N2, w2, C2]);
          var _2 = p()(" ", s2);
          var $3 = function e3(n3) {
            var r3 = Math.floor(n3 / s2);
            var a3 = n3 % s2;
            var i2 = g()(r3, (function(e4) {
              return t2().createElement(A, {
                key: e4.toString()
              }, _2);
            }));
            if (a3) {
              i2.push(p()(" ", a3));
            }
            return i2;
          };
          var B2 = u()(Q, l2) > -1;
          (0, e2.useEffect)((function() {
            if (false) {
            }
          }), [B2, l2, d2]);
          var G2 = B2 && l2 ? l2 : d2;
          var Y2 = ee(T2, G2);
          var X2 = J(G2);
          var W2 = function e3(n3) {
            return i()(n3).map((function(n4, r3) {
              if (typeof n4 === "string") {
                if (!v2) {
                  return n4;
                }
                var a3 = n4.split("\n");
                if (a3.length === 1) {
                  return n4;
                }
                return o()(a3.map((function(e4, n5) {
                  var a4 = n5 === 0 ? [] : ["\n"];
                  var i3 = e4.match(/^(\s+)(.*)/);
                  if (!i3) {
                    a4.push(e4);
                  } else {
                    a4.push(t2().createElement("span", {
                      key: "".concat(r3.toString(), ":").concat(n5.toString())
                    }, $3(i3[1].length)), i3[2]);
                  }
                  return a4;
                })));
              }
              var i2 = typeof n4.content === "string" ? n4.content : e3(n4.content);
              return t2().createElement(I, {
                "data-part-type": n4.type,
                partType: n4.type,
                key: r3.toString()
              }, i2);
            }));
          };
          var q2 = W2(Y2);
          return t2().createElement(y, H({
            "data-test": "code",
            ref: D2,
            tabIndex: k2,
            $showLineNumbers: E2,
            $counterReset: m2 && m2 - 1
          }, O2), E2 && t2().createElement(U, {
            value: T2
          }), t2().createElement(S, {
            className: "language-".concat(G2),
            $isPlaintext: X2
          }, q2), f2 && t2().createElement(P, {
            width: w2,
            highlight: f2
          }));
        }
        ne.propTypes = te;
        const re = ne;
      })();
      module.exports = r;
    })();
  }
});

// node_modules/react-markdown/lib/uri-transformer.js
function uriTransformer(uri) {
  const url = (uri || "").trim();
  const first = url.charAt(0);
  if (first === "#" || first === "/") {
    return url;
  }
  const colon = url.indexOf(":");
  if (colon === -1) {
    return url;
  }
  let index2 = -1;
  while (++index2 < protocols.length) {
    const protocol = protocols[index2];
    if (colon === protocol.length && url.slice(0, protocol.length).toLowerCase() === protocol) {
      return url;
    }
  }
  index2 = url.indexOf("?");
  if (index2 !== -1 && colon > index2) {
    return url;
  }
  index2 = url.indexOf("#");
  if (index2 !== -1 && colon > index2) {
    return url;
  }
  return "javascript:void(0)";
}
var import_dist4, import_dist5, import_dist6, protocols;
var init_uri_transformer = __esm({
  "node_modules/react-markdown/lib/uri-transformer.js"() {
    import_dist4 = __toESM(require_dist(), 1);
    import_dist5 = __toESM(require_dist2(), 1);
    import_dist6 = __toESM(require_dist3(), 1);
    protocols = ["http", "https", "mailto", "tel"];
  }
});

// node_modules/is-buffer/index.js
var require_is_buffer = __commonJS({
  "node_modules/is-buffer/index.js"(exports, module) {
    var import_dist466 = __toESM(require_dist());
    var import_dist467 = __toESM(require_dist2());
    var import_dist468 = __toESM(require_dist3());
    module.exports = function isBuffer2(obj) {
      return obj != null && obj.constructor != null && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
    };
  }
});

// node_modules/unist-util-stringify-position/lib/index.js
function stringifyPosition(value) {
  if (!value || typeof value !== "object") {
    return "";
  }
  if ("position" in value || "type" in value) {
    return position(value.position);
  }
  if ("start" in value || "end" in value) {
    return position(value);
  }
  if ("line" in value || "column" in value) {
    return point(value);
  }
  return "";
}
function point(point4) {
  return index(point4 && point4.line) + ":" + index(point4 && point4.column);
}
function position(pos) {
  return point(pos && pos.start) + "-" + point(pos && pos.end);
}
function index(value) {
  return value && typeof value === "number" ? value : 1;
}
var import_dist7, import_dist8, import_dist9;
var init_lib = __esm({
  "node_modules/unist-util-stringify-position/lib/index.js"() {
    import_dist7 = __toESM(require_dist(), 1);
    import_dist8 = __toESM(require_dist2(), 1);
    import_dist9 = __toESM(require_dist3(), 1);
  }
});

// node_modules/unist-util-stringify-position/index.js
var import_dist10, import_dist11, import_dist12;
var init_unist_util_stringify_position = __esm({
  "node_modules/unist-util-stringify-position/index.js"() {
    import_dist10 = __toESM(require_dist());
    import_dist11 = __toESM(require_dist2());
    import_dist12 = __toESM(require_dist3());
    init_lib();
  }
});

// node_modules/vfile-message/lib/index.js
var import_dist13, import_dist14, import_dist15, VFileMessage;
var init_lib2 = __esm({
  "node_modules/vfile-message/lib/index.js"() {
    import_dist13 = __toESM(require_dist(), 1);
    import_dist14 = __toESM(require_dist2(), 1);
    import_dist15 = __toESM(require_dist3(), 1);
    init_unist_util_stringify_position();
    VFileMessage = class extends Error {
      /**
       * Create a message for `reason` at `place` from `origin`.
       *
       * When an error is passed in as `reason`, the `stack` is copied.
       *
       * @param {string | Error | VFileMessage} reason
       *   Reason for message, uses the stack and message of the error if given.
       *
       *   >  **Note**: you should use markdown.
       * @param {Node | NodeLike | Position | Point | null | undefined} [place]
       *   Place in file where the message occurred.
       * @param {string | null | undefined} [origin]
       *   Place in code where the message originates (example:
       *   `'my-package:my-rule'` or `'my-rule'`).
       * @returns
       *   Instance of `VFileMessage`.
       */
      // To do: next major: expose `undefined` everywhere instead of `null`.
      constructor(reason, place, origin) {
        const parts = [null, null];
        let position3 = {
          // @ts-expect-error: we always follows the structure of `position`.
          start: { line: null, column: null },
          // @ts-expect-error: "
          end: { line: null, column: null }
        };
        super();
        if (typeof place === "string") {
          origin = place;
          place = void 0;
        }
        if (typeof origin === "string") {
          const index2 = origin.indexOf(":");
          if (index2 === -1) {
            parts[1] = origin;
          } else {
            parts[0] = origin.slice(0, index2);
            parts[1] = origin.slice(index2 + 1);
          }
        }
        if (place) {
          if ("type" in place || "position" in place) {
            if (place.position) {
              position3 = place.position;
            }
          } else if ("start" in place || "end" in place) {
            position3 = place;
          } else if ("line" in place || "column" in place) {
            position3.start = place;
          }
        }
        this.name = stringifyPosition(place) || "1:1";
        this.message = typeof reason === "object" ? reason.message : reason;
        this.stack = "";
        if (typeof reason === "object" && reason.stack) {
          this.stack = reason.stack;
        }
        this.reason = this.message;
        this.fatal;
        this.line = position3.start.line;
        this.column = position3.start.column;
        this.position = position3;
        this.source = parts[0];
        this.ruleId = parts[1];
        this.file;
        this.actual;
        this.expected;
        this.url;
        this.note;
      }
    };
    VFileMessage.prototype.file = "";
    VFileMessage.prototype.name = "";
    VFileMessage.prototype.reason = "";
    VFileMessage.prototype.message = "";
    VFileMessage.prototype.stack = "";
    VFileMessage.prototype.fatal = null;
    VFileMessage.prototype.column = null;
    VFileMessage.prototype.line = null;
    VFileMessage.prototype.source = null;
    VFileMessage.prototype.ruleId = null;
    VFileMessage.prototype.position = null;
  }
});

// node_modules/vfile-message/index.js
var import_dist16, import_dist17, import_dist18;
var init_vfile_message = __esm({
  "node_modules/vfile-message/index.js"() {
    import_dist16 = __toESM(require_dist());
    import_dist17 = __toESM(require_dist2());
    import_dist18 = __toESM(require_dist3());
    init_lib2();
  }
});

// node_modules/vfile/lib/minpath.browser.js
function basename(path2, ext) {
  if (ext !== void 0 && typeof ext !== "string") {
    throw new TypeError('"ext" argument must be a string');
  }
  assertPath(path2);
  let start = 0;
  let end = -1;
  let index2 = path2.length;
  let seenNonSlash;
  if (ext === void 0 || ext.length === 0 || ext.length > path2.length) {
    while (index2--) {
      if (path2.charCodeAt(index2) === 47) {
        if (seenNonSlash) {
          start = index2 + 1;
          break;
        }
      } else if (end < 0) {
        seenNonSlash = true;
        end = index2 + 1;
      }
    }
    return end < 0 ? "" : path2.slice(start, end);
  }
  if (ext === path2) {
    return "";
  }
  let firstNonSlashEnd = -1;
  let extIndex = ext.length - 1;
  while (index2--) {
    if (path2.charCodeAt(index2) === 47) {
      if (seenNonSlash) {
        start = index2 + 1;
        break;
      }
    } else {
      if (firstNonSlashEnd < 0) {
        seenNonSlash = true;
        firstNonSlashEnd = index2 + 1;
      }
      if (extIndex > -1) {
        if (path2.charCodeAt(index2) === ext.charCodeAt(extIndex--)) {
          if (extIndex < 0) {
            end = index2;
          }
        } else {
          extIndex = -1;
          end = firstNonSlashEnd;
        }
      }
    }
  }
  if (start === end) {
    end = firstNonSlashEnd;
  } else if (end < 0) {
    end = path2.length;
  }
  return path2.slice(start, end);
}
function dirname(path2) {
  assertPath(path2);
  if (path2.length === 0) {
    return ".";
  }
  let end = -1;
  let index2 = path2.length;
  let unmatchedSlash;
  while (--index2) {
    if (path2.charCodeAt(index2) === 47) {
      if (unmatchedSlash) {
        end = index2;
        break;
      }
    } else if (!unmatchedSlash) {
      unmatchedSlash = true;
    }
  }
  return end < 0 ? path2.charCodeAt(0) === 47 ? "/" : "." : end === 1 && path2.charCodeAt(0) === 47 ? "//" : path2.slice(0, end);
}
function extname(path2) {
  assertPath(path2);
  let index2 = path2.length;
  let end = -1;
  let startPart = 0;
  let startDot = -1;
  let preDotState = 0;
  let unmatchedSlash;
  while (index2--) {
    const code2 = path2.charCodeAt(index2);
    if (code2 === 47) {
      if (unmatchedSlash) {
        startPart = index2 + 1;
        break;
      }
      continue;
    }
    if (end < 0) {
      unmatchedSlash = true;
      end = index2 + 1;
    }
    if (code2 === 46) {
      if (startDot < 0) {
        startDot = index2;
      } else if (preDotState !== 1) {
        preDotState = 1;
      }
    } else if (startDot > -1) {
      preDotState = -1;
    }
  }
  if (startDot < 0 || end < 0 || // We saw a non-dot character immediately before the dot.
  preDotState === 0 || // The (right-most) trimmed path component is exactly `..`.
  preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return "";
  }
  return path2.slice(startDot, end);
}
function join(...segments) {
  let index2 = -1;
  let joined;
  while (++index2 < segments.length) {
    assertPath(segments[index2]);
    if (segments[index2]) {
      joined = joined === void 0 ? segments[index2] : joined + "/" + segments[index2];
    }
  }
  return joined === void 0 ? "." : normalize(joined);
}
function normalize(path2) {
  assertPath(path2);
  const absolute = path2.charCodeAt(0) === 47;
  let value = normalizeString(path2, !absolute);
  if (value.length === 0 && !absolute) {
    value = ".";
  }
  if (value.length > 0 && path2.charCodeAt(path2.length - 1) === 47) {
    value += "/";
  }
  return absolute ? "/" + value : value;
}
function normalizeString(path2, allowAboveRoot) {
  let result = "";
  let lastSegmentLength = 0;
  let lastSlash = -1;
  let dots = 0;
  let index2 = -1;
  let code2;
  let lastSlashIndex;
  while (++index2 <= path2.length) {
    if (index2 < path2.length) {
      code2 = path2.charCodeAt(index2);
    } else if (code2 === 47) {
      break;
    } else {
      code2 = 47;
    }
    if (code2 === 47) {
      if (lastSlash === index2 - 1 || dots === 1) {
      } else if (lastSlash !== index2 - 1 && dots === 2) {
        if (result.length < 2 || lastSegmentLength !== 2 || result.charCodeAt(result.length - 1) !== 46 || result.charCodeAt(result.length - 2) !== 46) {
          if (result.length > 2) {
            lastSlashIndex = result.lastIndexOf("/");
            if (lastSlashIndex !== result.length - 1) {
              if (lastSlashIndex < 0) {
                result = "";
                lastSegmentLength = 0;
              } else {
                result = result.slice(0, lastSlashIndex);
                lastSegmentLength = result.length - 1 - result.lastIndexOf("/");
              }
              lastSlash = index2;
              dots = 0;
              continue;
            }
          } else if (result.length > 0) {
            result = "";
            lastSegmentLength = 0;
            lastSlash = index2;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          result = result.length > 0 ? result + "/.." : "..";
          lastSegmentLength = 2;
        }
      } else {
        if (result.length > 0) {
          result += "/" + path2.slice(lastSlash + 1, index2);
        } else {
          result = path2.slice(lastSlash + 1, index2);
        }
        lastSegmentLength = index2 - lastSlash - 1;
      }
      lastSlash = index2;
      dots = 0;
    } else if (code2 === 46 && dots > -1) {
      dots++;
    } else {
      dots = -1;
    }
  }
  return result;
}
function assertPath(path2) {
  if (typeof path2 !== "string") {
    throw new TypeError(
      "Path must be a string. Received " + JSON.stringify(path2)
    );
  }
}
var import_dist19, import_dist20, import_dist21, path;
var init_minpath_browser = __esm({
  "node_modules/vfile/lib/minpath.browser.js"() {
    import_dist19 = __toESM(require_dist(), 1);
    import_dist20 = __toESM(require_dist2(), 1);
    import_dist21 = __toESM(require_dist3(), 1);
    path = { basename, dirname, extname, join, sep: "/" };
  }
});

// node_modules/vfile/lib/minproc.browser.js
function cwd() {
  return "/";
}
var import_dist22, import_dist23, import_dist24, proc;
var init_minproc_browser = __esm({
  "node_modules/vfile/lib/minproc.browser.js"() {
    import_dist22 = __toESM(require_dist(), 1);
    import_dist23 = __toESM(require_dist2(), 1);
    import_dist24 = __toESM(require_dist3(), 1);
    proc = { cwd };
  }
});

// node_modules/vfile/lib/minurl.shared.js
function isUrl(fileUrlOrPath) {
  return fileUrlOrPath !== null && typeof fileUrlOrPath === "object" && // @ts-expect-error: indexable.
  fileUrlOrPath.href && // @ts-expect-error: indexable.
  fileUrlOrPath.origin;
}
var import_dist25, import_dist26, import_dist27;
var init_minurl_shared = __esm({
  "node_modules/vfile/lib/minurl.shared.js"() {
    import_dist25 = __toESM(require_dist(), 1);
    import_dist26 = __toESM(require_dist2(), 1);
    import_dist27 = __toESM(require_dist3(), 1);
  }
});

// node_modules/vfile/lib/minurl.browser.js
function urlToPath(path2) {
  if (typeof path2 === "string") {
    path2 = new URL(path2);
  } else if (!isUrl(path2)) {
    const error = new TypeError(
      'The "path" argument must be of type string or an instance of URL. Received `' + path2 + "`"
    );
    error.code = "ERR_INVALID_ARG_TYPE";
    throw error;
  }
  if (path2.protocol !== "file:") {
    const error = new TypeError("The URL must be of scheme file");
    error.code = "ERR_INVALID_URL_SCHEME";
    throw error;
  }
  return getPathFromURLPosix(path2);
}
function getPathFromURLPosix(url) {
  if (url.hostname !== "") {
    const error = new TypeError(
      'File URL host must be "localhost" or empty on darwin'
    );
    error.code = "ERR_INVALID_FILE_URL_HOST";
    throw error;
  }
  const pathname = url.pathname;
  let index2 = -1;
  while (++index2 < pathname.length) {
    if (pathname.charCodeAt(index2) === 37 && pathname.charCodeAt(index2 + 1) === 50) {
      const third = pathname.charCodeAt(index2 + 2);
      if (third === 70 || third === 102) {
        const error = new TypeError(
          "File URL path must not include encoded / characters"
        );
        error.code = "ERR_INVALID_FILE_URL_PATH";
        throw error;
      }
    }
  }
  return decodeURIComponent(pathname);
}
var import_dist28, import_dist29, import_dist30;
var init_minurl_browser = __esm({
  "node_modules/vfile/lib/minurl.browser.js"() {
    import_dist28 = __toESM(require_dist(), 1);
    import_dist29 = __toESM(require_dist2(), 1);
    import_dist30 = __toESM(require_dist3(), 1);
    init_minurl_shared();
    init_minurl_shared();
  }
});

// node_modules/vfile/lib/index.js
function assertPart(part, name) {
  if (part && part.includes(path.sep)) {
    throw new Error(
      "`" + name + "` cannot be a path: did not expect `" + path.sep + "`"
    );
  }
}
function assertNonEmpty(part, name) {
  if (!part) {
    throw new Error("`" + name + "` cannot be empty");
  }
}
function assertPath2(path2, name) {
  if (!path2) {
    throw new Error("Setting `" + name + "` requires `path` to be set too");
  }
}
function buffer(value) {
  return (0, import_is_buffer.default)(value);
}
var import_dist31, import_dist32, import_dist33, import_is_buffer, order, VFile;
var init_lib3 = __esm({
  "node_modules/vfile/lib/index.js"() {
    import_dist31 = __toESM(require_dist(), 1);
    import_dist32 = __toESM(require_dist2(), 1);
    import_dist33 = __toESM(require_dist3(), 1);
    import_is_buffer = __toESM(require_is_buffer(), 1);
    init_vfile_message();
    init_minpath_browser();
    init_minproc_browser();
    init_minurl_browser();
    order = ["history", "path", "basename", "stem", "extname", "dirname"];
    VFile = class {
      /**
       * Create a new virtual file.
       *
       * `options` is treated as:
       *
       * *   `string` or `Buffer`  `{value: options}`
       * *   `URL`  `{path: options}`
       * *   `VFile`  shallow copies its data over to the new file
       * *   `object`  all fields are shallow copied over to the new file
       *
       * Path related fields are set in the following order (least specific to
       * most specific): `history`, `path`, `basename`, `stem`, `extname`,
       * `dirname`.
       *
       * You cannot set `dirname` or `extname` without setting either `history`,
       * `path`, `basename`, or `stem` too.
       *
       * @param {Compatible | null | undefined} [value]
       *   File value.
       * @returns
       *   New instance.
       */
      constructor(value) {
        let options;
        if (!value) {
          options = {};
        } else if (typeof value === "string" || buffer(value)) {
          options = { value };
        } else if (isUrl(value)) {
          options = { path: value };
        } else {
          options = value;
        }
        this.data = {};
        this.messages = [];
        this.history = [];
        this.cwd = proc.cwd();
        this.value;
        this.stored;
        this.result;
        this.map;
        let index2 = -1;
        while (++index2 < order.length) {
          const prop2 = order[index2];
          if (prop2 in options && options[prop2] !== void 0 && options[prop2] !== null) {
            this[prop2] = prop2 === "history" ? [...options[prop2]] : options[prop2];
          }
        }
        let prop;
        for (prop in options) {
          if (!order.includes(prop)) {
            this[prop] = options[prop];
          }
        }
      }
      /**
       * Get the full path (example: `'~/index.min.js'`).
       *
       * @returns {string}
       */
      get path() {
        return this.history[this.history.length - 1];
      }
      /**
       * Set the full path (example: `'~/index.min.js'`).
       *
       * Cannot be nullified.
       * You can set a file URL (a `URL` object with a `file:` protocol) which will
       * be turned into a path with `url.fileURLToPath`.
       *
       * @param {string | URL} path
       */
      set path(path2) {
        if (isUrl(path2)) {
          path2 = urlToPath(path2);
        }
        assertNonEmpty(path2, "path");
        if (this.path !== path2) {
          this.history.push(path2);
        }
      }
      /**
       * Get the parent path (example: `'~'`).
       */
      get dirname() {
        return typeof this.path === "string" ? path.dirname(this.path) : void 0;
      }
      /**
       * Set the parent path (example: `'~'`).
       *
       * Cannot be set if theres no `path` yet.
       */
      set dirname(dirname2) {
        assertPath2(this.basename, "dirname");
        this.path = path.join(dirname2 || "", this.basename);
      }
      /**
       * Get the basename (including extname) (example: `'index.min.js'`).
       */
      get basename() {
        return typeof this.path === "string" ? path.basename(this.path) : void 0;
      }
      /**
       * Set basename (including extname) (`'index.min.js'`).
       *
       * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
       * on windows).
       * Cannot be nullified (use `file.path = file.dirname` instead).
       */
      set basename(basename2) {
        assertNonEmpty(basename2, "basename");
        assertPart(basename2, "basename");
        this.path = path.join(this.dirname || "", basename2);
      }
      /**
       * Get the extname (including dot) (example: `'.js'`).
       */
      get extname() {
        return typeof this.path === "string" ? path.extname(this.path) : void 0;
      }
      /**
       * Set the extname (including dot) (example: `'.js'`).
       *
       * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
       * on windows).
       * Cannot be set if theres no `path` yet.
       */
      set extname(extname2) {
        assertPart(extname2, "extname");
        assertPath2(this.dirname, "extname");
        if (extname2) {
          if (extname2.charCodeAt(0) !== 46) {
            throw new Error("`extname` must start with `.`");
          }
          if (extname2.includes(".", 1)) {
            throw new Error("`extname` cannot contain multiple dots");
          }
        }
        this.path = path.join(this.dirname, this.stem + (extname2 || ""));
      }
      /**
       * Get the stem (basename w/o extname) (example: `'index.min'`).
       */
      get stem() {
        return typeof this.path === "string" ? path.basename(this.path, this.extname) : void 0;
      }
      /**
       * Set the stem (basename w/o extname) (example: `'index.min'`).
       *
       * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
       * on windows).
       * Cannot be nullified (use `file.path = file.dirname` instead).
       */
      set stem(stem) {
        assertNonEmpty(stem, "stem");
        assertPart(stem, "stem");
        this.path = path.join(this.dirname || "", stem + (this.extname || ""));
      }
      /**
       * Serialize the file.
       *
       * @param {BufferEncoding | null | undefined} [encoding='utf8']
       *   Character encoding to understand `value` as when its a `Buffer`
       *   (default: `'utf8'`).
       * @returns {string}
       *   Serialized file.
       */
      toString(encoding) {
        return (this.value || "").toString(encoding || void 0);
      }
      /**
       * Create a warning message associated with the file.
       *
       * Its `fatal` is set to `false` and `file` is set to the current file path.
       * Its added to `file.messages`.
       *
       * @param {string | Error | VFileMessage} reason
       *   Reason for message, uses the stack and message of the error if given.
       * @param {Node | NodeLike | Position | Point | null | undefined} [place]
       *   Place in file where the message occurred.
       * @param {string | null | undefined} [origin]
       *   Place in code where the message originates (example:
       *   `'my-package:my-rule'` or `'my-rule'`).
       * @returns {VFileMessage}
       *   Message.
       */
      message(reason, place, origin) {
        const message = new VFileMessage(reason, place, origin);
        if (this.path) {
          message.name = this.path + ":" + message.name;
          message.file = this.path;
        }
        message.fatal = false;
        this.messages.push(message);
        return message;
      }
      /**
       * Create an info message associated with the file.
       *
       * Its `fatal` is set to `null` and `file` is set to the current file path.
       * Its added to `file.messages`.
       *
       * @param {string | Error | VFileMessage} reason
       *   Reason for message, uses the stack and message of the error if given.
       * @param {Node | NodeLike | Position | Point | null | undefined} [place]
       *   Place in file where the message occurred.
       * @param {string | null | undefined} [origin]
       *   Place in code where the message originates (example:
       *   `'my-package:my-rule'` or `'my-rule'`).
       * @returns {VFileMessage}
       *   Message.
       */
      info(reason, place, origin) {
        const message = this.message(reason, place, origin);
        message.fatal = null;
        return message;
      }
      /**
       * Create a fatal error associated with the file.
       *
       * Its `fatal` is set to `true` and `file` is set to the current file path.
       * Its added to `file.messages`.
       *
       * >  **Note**: a fatal error means that a file is no longer processable.
       *
       * @param {string | Error | VFileMessage} reason
       *   Reason for message, uses the stack and message of the error if given.
       * @param {Node | NodeLike | Position | Point | null | undefined} [place]
       *   Place in file where the message occurred.
       * @param {string | null | undefined} [origin]
       *   Place in code where the message originates (example:
       *   `'my-package:my-rule'` or `'my-rule'`).
       * @returns {never}
       *   Message.
       * @throws {VFileMessage}
       *   Message.
       */
      fail(reason, place, origin) {
        const message = this.message(reason, place, origin);
        message.fatal = true;
        throw message;
      }
    };
  }
});

// node_modules/vfile/index.js
var import_dist34, import_dist35, import_dist36;
var init_vfile = __esm({
  "node_modules/vfile/index.js"() {
    import_dist34 = __toESM(require_dist());
    import_dist35 = __toESM(require_dist2());
    import_dist36 = __toESM(require_dist3());
    init_lib3();
  }
});

// node_modules/bail/index.js
function bail(error) {
  if (error) {
    throw error;
  }
}
var import_dist37, import_dist38, import_dist39;
var init_bail = __esm({
  "node_modules/bail/index.js"() {
    import_dist37 = __toESM(require_dist());
    import_dist38 = __toESM(require_dist2());
    import_dist39 = __toESM(require_dist3());
  }
});

// node_modules/extend/index.js
var require_extend2 = __commonJS({
  "node_modules/extend/index.js"(exports, module) {
    "use strict";
    var import_dist466 = __toESM(require_dist());
    var import_dist467 = __toESM(require_dist2());
    var import_dist468 = __toESM(require_dist3());
    var hasOwn = Object.prototype.hasOwnProperty;
    var toStr = Object.prototype.toString;
    var defineProperty = Object.defineProperty;
    var gOPD = Object.getOwnPropertyDescriptor;
    var isArray = function isArray2(arr) {
      if (typeof Array.isArray === "function") {
        return Array.isArray(arr);
      }
      return toStr.call(arr) === "[object Array]";
    };
    var isPlainObject2 = function isPlainObject3(obj) {
      if (!obj || toStr.call(obj) !== "[object Object]") {
        return false;
      }
      var hasOwnConstructor = hasOwn.call(obj, "constructor");
      var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, "isPrototypeOf");
      if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
        return false;
      }
      var key;
      for (key in obj) {
      }
      return typeof key === "undefined" || hasOwn.call(obj, key);
    };
    var setProperty = function setProperty2(target, options) {
      if (defineProperty && options.name === "__proto__") {
        defineProperty(target, options.name, {
          enumerable: true,
          configurable: true,
          value: options.newValue,
          writable: true
        });
      } else {
        target[options.name] = options.newValue;
      }
    };
    var getProperty = function getProperty2(obj, name) {
      if (name === "__proto__") {
        if (!hasOwn.call(obj, name)) {
          return void 0;
        } else if (gOPD) {
          return gOPD(obj, name).value;
        }
      }
      return obj[name];
    };
    module.exports = function extend2() {
      var options, name, src, copy, copyIsArray, clone;
      var target = arguments[0];
      var i = 1;
      var length = arguments.length;
      var deep = false;
      if (typeof target === "boolean") {
        deep = target;
        target = arguments[1] || {};
        i = 2;
      }
      if (target == null || typeof target !== "object" && typeof target !== "function") {
        target = {};
      }
      for (; i < length; ++i) {
        options = arguments[i];
        if (options != null) {
          for (name in options) {
            src = getProperty(target, name);
            copy = getProperty(options, name);
            if (target !== copy) {
              if (deep && copy && (isPlainObject2(copy) || (copyIsArray = isArray(copy)))) {
                if (copyIsArray) {
                  copyIsArray = false;
                  clone = src && isArray(src) ? src : [];
                } else {
                  clone = src && isPlainObject2(src) ? src : {};
                }
                setProperty(target, { name, newValue: extend2(deep, clone, copy) });
              } else if (typeof copy !== "undefined") {
                setProperty(target, { name, newValue: copy });
              }
            }
          }
        }
      }
      return target;
    };
  }
});

// node_modules/is-plain-obj/index.js
function isPlainObject(value) {
  if (typeof value !== "object" || value === null) {
    return false;
  }
  const prototype = Object.getPrototypeOf(value);
  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);
}
var import_dist40, import_dist41, import_dist42;
var init_is_plain_obj = __esm({
  "node_modules/is-plain-obj/index.js"() {
    import_dist40 = __toESM(require_dist());
    import_dist41 = __toESM(require_dist2());
    import_dist42 = __toESM(require_dist3());
  }
});

// node_modules/trough/lib/index.js
function trough() {
  const fns = [];
  const pipeline = { run: run2, use };
  return pipeline;
  function run2(...values2) {
    let middlewareIndex = -1;
    const callback = values2.pop();
    if (typeof callback !== "function") {
      throw new TypeError("Expected function as last argument, not " + callback);
    }
    next(null, ...values2);
    function next(error, ...output) {
      const fn = fns[++middlewareIndex];
      let index2 = -1;
      if (error) {
        callback(error);
        return;
      }
      while (++index2 < values2.length) {
        if (output[index2] === null || output[index2] === void 0) {
          output[index2] = values2[index2];
        }
      }
      values2 = output;
      if (fn) {
        wrap(fn, next)(...output);
      } else {
        callback(null, ...output);
      }
    }
  }
  function use(middelware) {
    if (typeof middelware !== "function") {
      throw new TypeError(
        "Expected `middelware` to be a function, not " + middelware
      );
    }
    fns.push(middelware);
    return pipeline;
  }
}
function wrap(middleware, callback) {
  let called;
  return wrapped;
  function wrapped(...parameters) {
    const fnExpectsCallback = middleware.length > parameters.length;
    let result;
    if (fnExpectsCallback) {
      parameters.push(done);
    }
    try {
      result = middleware.apply(this, parameters);
    } catch (error) {
      const exception = (
        /** @type {Error} */
        error
      );
      if (fnExpectsCallback && called) {
        throw exception;
      }
      return done(exception);
    }
    if (!fnExpectsCallback) {
      if (result && result.then && typeof result.then === "function") {
        result.then(then, done);
      } else if (result instanceof Error) {
        done(result);
      } else {
        then(result);
      }
    }
  }
  function done(error, ...output) {
    if (!called) {
      called = true;
      callback(error, ...output);
    }
  }
  function then(value) {
    done(null, value);
  }
}
var import_dist43, import_dist44, import_dist45;
var init_lib4 = __esm({
  "node_modules/trough/lib/index.js"() {
    import_dist43 = __toESM(require_dist(), 1);
    import_dist44 = __toESM(require_dist2(), 1);
    import_dist45 = __toESM(require_dist3(), 1);
  }
});

// node_modules/trough/index.js
var import_dist46, import_dist47, import_dist48;
var init_trough = __esm({
  "node_modules/trough/index.js"() {
    import_dist46 = __toESM(require_dist());
    import_dist47 = __toESM(require_dist2());
    import_dist48 = __toESM(require_dist3());
    init_lib4();
  }
});

// node_modules/unified/lib/index.js
function base() {
  const transformers = trough();
  const attachers = [];
  let namespace = {};
  let frozen;
  let freezeIndex = -1;
  processor.data = data;
  processor.Parser = void 0;
  processor.Compiler = void 0;
  processor.freeze = freeze;
  processor.attachers = attachers;
  processor.use = use;
  processor.parse = parse2;
  processor.stringify = stringify4;
  processor.run = run2;
  processor.runSync = runSync;
  processor.process = process2;
  processor.processSync = processSync;
  return processor;
  function processor() {
    const destination = base();
    let index2 = -1;
    while (++index2 < attachers.length) {
      destination.use(...attachers[index2]);
    }
    destination.data((0, import_extend.default)(true, {}, namespace));
    return destination;
  }
  function data(key, value) {
    if (typeof key === "string") {
      if (arguments.length === 2) {
        assertUnfrozen("data", frozen);
        namespace[key] = value;
        return processor;
      }
      return own.call(namespace, key) && namespace[key] || null;
    }
    if (key) {
      assertUnfrozen("data", frozen);
      namespace = key;
      return processor;
    }
    return namespace;
  }
  function freeze() {
    if (frozen) {
      return processor;
    }
    while (++freezeIndex < attachers.length) {
      const [attacher, ...options] = attachers[freezeIndex];
      if (options[0] === false) {
        continue;
      }
      if (options[0] === true) {
        options[0] = void 0;
      }
      const transformer = attacher.call(processor, ...options);
      if (typeof transformer === "function") {
        transformers.use(transformer);
      }
    }
    frozen = true;
    freezeIndex = Number.POSITIVE_INFINITY;
    return processor;
  }
  function use(value, ...options) {
    let settings;
    assertUnfrozen("use", frozen);
    if (value === null || value === void 0) {
    } else if (typeof value === "function") {
      addPlugin(value, ...options);
    } else if (typeof value === "object") {
      if (Array.isArray(value)) {
        addList(value);
      } else {
        addPreset(value);
      }
    } else {
      throw new TypeError("Expected usable value, not `" + value + "`");
    }
    if (settings) {
      namespace.settings = Object.assign(namespace.settings || {}, settings);
    }
    return processor;
    function add(value2) {
      if (typeof value2 === "function") {
        addPlugin(value2);
      } else if (typeof value2 === "object") {
        if (Array.isArray(value2)) {
          const [plugin, ...options2] = value2;
          addPlugin(plugin, ...options2);
        } else {
          addPreset(value2);
        }
      } else {
        throw new TypeError("Expected usable value, not `" + value2 + "`");
      }
    }
    function addPreset(result) {
      addList(result.plugins);
      if (result.settings) {
        settings = Object.assign(settings || {}, result.settings);
      }
    }
    function addList(plugins) {
      let index2 = -1;
      if (plugins === null || plugins === void 0) {
      } else if (Array.isArray(plugins)) {
        while (++index2 < plugins.length) {
          const thing = plugins[index2];
          add(thing);
        }
      } else {
        throw new TypeError("Expected a list of plugins, not `" + plugins + "`");
      }
    }
    function addPlugin(plugin, value2) {
      let index2 = -1;
      let entry;
      while (++index2 < attachers.length) {
        if (attachers[index2][0] === plugin) {
          entry = attachers[index2];
          break;
        }
      }
      if (entry) {
        if (isPlainObject(entry[1]) && isPlainObject(value2)) {
          value2 = (0, import_extend.default)(true, entry[1], value2);
        }
        entry[1] = value2;
      } else {
        attachers.push([...arguments]);
      }
    }
  }
  function parse2(doc) {
    processor.freeze();
    const file = vfile(doc);
    const Parser = processor.Parser;
    assertParser("parse", Parser);
    if (newable(Parser, "parse")) {
      return new Parser(String(file), file).parse();
    }
    return Parser(String(file), file);
  }
  function stringify4(node2, doc) {
    processor.freeze();
    const file = vfile(doc);
    const Compiler = processor.Compiler;
    assertCompiler("stringify", Compiler);
    assertNode(node2);
    if (newable(Compiler, "compile")) {
      return new Compiler(node2, file).compile();
    }
    return Compiler(node2, file);
  }
  function run2(node2, doc, callback) {
    assertNode(node2);
    processor.freeze();
    if (!callback && typeof doc === "function") {
      callback = doc;
      doc = void 0;
    }
    if (!callback) {
      return new Promise(executor);
    }
    executor(null, callback);
    function executor(resolve, reject) {
      transformers.run(node2, vfile(doc), done);
      function done(error, tree, file) {
        tree = tree || node2;
        if (error) {
          reject(error);
        } else if (resolve) {
          resolve(tree);
        } else {
          callback(null, tree, file);
        }
      }
    }
  }
  function runSync(node2, file) {
    let result;
    let complete;
    processor.run(node2, file, done);
    assertDone("runSync", "run", complete);
    return result;
    function done(error, tree) {
      bail(error);
      result = tree;
      complete = true;
    }
  }
  function process2(doc, callback) {
    processor.freeze();
    assertParser("process", processor.Parser);
    assertCompiler("process", processor.Compiler);
    if (!callback) {
      return new Promise(executor);
    }
    executor(null, callback);
    function executor(resolve, reject) {
      const file = vfile(doc);
      processor.run(processor.parse(file), file, (error, tree, file2) => {
        if (error || !tree || !file2) {
          done(error);
        } else {
          const result = processor.stringify(tree, file2);
          if (result === void 0 || result === null) {
          } else if (looksLikeAVFileValue(result)) {
            file2.value = result;
          } else {
            file2.result = result;
          }
          done(error, file2);
        }
      });
      function done(error, file2) {
        if (error || !file2) {
          reject(error);
        } else if (resolve) {
          resolve(file2);
        } else {
          callback(null, file2);
        }
      }
    }
  }
  function processSync(doc) {
    let complete;
    processor.freeze();
    assertParser("processSync", processor.Parser);
    assertCompiler("processSync", processor.Compiler);
    const file = vfile(doc);
    processor.process(file, done);
    assertDone("processSync", "process", complete);
    return file;
    function done(error) {
      complete = true;
      bail(error);
    }
  }
}
function newable(value, name) {
  return typeof value === "function" && // Prototypes do exist.
  // type-coverage:ignore-next-line
  value.prototype && // A function with keys in its prototype is probably a constructor.
  // Classes prototype methods are not enumerable, so we check if some value
  // exists in the prototype.
  // type-coverage:ignore-next-line
  (keys(value.prototype) || name in value.prototype);
}
function keys(value) {
  let key;
  for (key in value) {
    if (own.call(value, key)) {
      return true;
    }
  }
  return false;
}
function assertParser(name, value) {
  if (typeof value !== "function") {
    throw new TypeError("Cannot `" + name + "` without `Parser`");
  }
}
function assertCompiler(name, value) {
  if (typeof value !== "function") {
    throw new TypeError("Cannot `" + name + "` without `Compiler`");
  }
}
function assertUnfrozen(name, frozen) {
  if (frozen) {
    throw new Error(
      "Cannot call `" + name + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`."
    );
  }
}
function assertNode(node2) {
  if (!isPlainObject(node2) || typeof node2.type !== "string") {
    throw new TypeError("Expected node, got `" + node2 + "`");
  }
}
function assertDone(name, asyncName, complete) {
  if (!complete) {
    throw new Error(
      "`" + name + "` finished async. Use `" + asyncName + "` instead"
    );
  }
}
function vfile(value) {
  return looksLikeAVFile(value) ? value : new VFile(value);
}
function looksLikeAVFile(value) {
  return Boolean(
    value && typeof value === "object" && "message" in value && "messages" in value
  );
}
function looksLikeAVFileValue(value) {
  return typeof value === "string" || (0, import_is_buffer2.default)(value);
}
var import_dist49, import_dist50, import_dist51, import_is_buffer2, import_extend, unified, own;
var init_lib5 = __esm({
  "node_modules/unified/lib/index.js"() {
    import_dist49 = __toESM(require_dist(), 1);
    import_dist50 = __toESM(require_dist2(), 1);
    import_dist51 = __toESM(require_dist3(), 1);
    init_bail();
    import_is_buffer2 = __toESM(require_is_buffer(), 1);
    import_extend = __toESM(require_extend2(), 1);
    init_is_plain_obj();
    init_trough();
    init_vfile();
    unified = base().freeze();
    own = {}.hasOwnProperty;
  }
});

// node_modules/unified/index.js
var import_dist52, import_dist53, import_dist54;
var init_unified = __esm({
  "node_modules/unified/index.js"() {
    import_dist52 = __toESM(require_dist());
    import_dist53 = __toESM(require_dist2());
    import_dist54 = __toESM(require_dist3());
    init_lib5();
  }
});

// node_modules/kleur/index.mjs
function run(arr, str) {
  let i = 0, tmp, beg = "", end = "";
  for (; i < arr.length; i++) {
    tmp = arr[i];
    beg += tmp.open;
    end += tmp.close;
    if (!!~str.indexOf(tmp.close)) {
      str = str.replace(tmp.rgx, tmp.close + tmp.open);
    }
  }
  return beg + str + end;
}
function chain(has, keys2) {
  let ctx = { has, keys: keys2 };
  ctx.reset = $.reset.bind(ctx);
  ctx.bold = $.bold.bind(ctx);
  ctx.dim = $.dim.bind(ctx);
  ctx.italic = $.italic.bind(ctx);
  ctx.underline = $.underline.bind(ctx);
  ctx.inverse = $.inverse.bind(ctx);
  ctx.hidden = $.hidden.bind(ctx);
  ctx.strikethrough = $.strikethrough.bind(ctx);
  ctx.black = $.black.bind(ctx);
  ctx.red = $.red.bind(ctx);
  ctx.green = $.green.bind(ctx);
  ctx.yellow = $.yellow.bind(ctx);
  ctx.blue = $.blue.bind(ctx);
  ctx.magenta = $.magenta.bind(ctx);
  ctx.cyan = $.cyan.bind(ctx);
  ctx.white = $.white.bind(ctx);
  ctx.gray = $.gray.bind(ctx);
  ctx.grey = $.grey.bind(ctx);
  ctx.bgBlack = $.bgBlack.bind(ctx);
  ctx.bgRed = $.bgRed.bind(ctx);
  ctx.bgGreen = $.bgGreen.bind(ctx);
  ctx.bgYellow = $.bgYellow.bind(ctx);
  ctx.bgBlue = $.bgBlue.bind(ctx);
  ctx.bgMagenta = $.bgMagenta.bind(ctx);
  ctx.bgCyan = $.bgCyan.bind(ctx);
  ctx.bgWhite = $.bgWhite.bind(ctx);
  return ctx;
}
function init(open, close) {
  let blk = {
    open: `\x1B[${open}m`,
    close: `\x1B[${close}m`,
    rgx: new RegExp(`\\x1b\\[${close}m`, "g")
  };
  return function(txt) {
    if (this !== void 0 && this.has !== void 0) {
      !!~this.has.indexOf(open) || (this.has.push(open), this.keys.push(blk));
      return txt === void 0 ? this : $.enabled ? run(this.keys, txt + "") : txt + "";
    }
    return txt === void 0 ? chain([open], [blk]) : $.enabled ? run([blk], txt + "") : txt + "";
  };
}
var import_dist55, import_dist56, import_dist57, FORCE_COLOR, NODE_DISABLE_COLORS, NO_COLOR, TERM, isTTY, $, kleur_default;
var init_kleur = __esm({
  "node_modules/kleur/index.mjs"() {
    "use strict";
    import_dist55 = __toESM(require_dist(), 1);
    import_dist56 = __toESM(require_dist2(), 1);
    import_dist57 = __toESM(require_dist3(), 1);
    isTTY = true;
    if (typeof process !== "undefined") {
      ({ FORCE_COLOR, NODE_DISABLE_COLORS, NO_COLOR, TERM } = process.env || {});
      isTTY = process.stdout && process.stdout.isTTY;
    }
    $ = {
      enabled: !NODE_DISABLE_COLORS && NO_COLOR == null && TERM !== "dumb" && (FORCE_COLOR != null && FORCE_COLOR !== "0" || isTTY),
      // modifiers
      reset: init(0, 0),
      bold: init(1, 22),
      dim: init(2, 22),
      italic: init(3, 23),
      underline: init(4, 24),
      inverse: init(7, 27),
      hidden: init(8, 28),
      strikethrough: init(9, 29),
      // colors
      black: init(30, 39),
      red: init(31, 39),
      green: init(32, 39),
      yellow: init(33, 39),
      blue: init(34, 39),
      magenta: init(35, 39),
      cyan: init(36, 39),
      white: init(37, 39),
      gray: init(90, 39),
      grey: init(90, 39),
      // background colors
      bgBlack: init(40, 49),
      bgRed: init(41, 49),
      bgGreen: init(42, 49),
      bgYellow: init(43, 49),
      bgBlue: init(44, 49),
      bgMagenta: init(45, 49),
      bgCyan: init(46, 49),
      bgWhite: init(47, 49)
    };
    kleur_default = $;
  }
});

// node_modules/diff/lib/index.mjs
function Diff() {
}
function buildValues(diff2, lastComponent, newString, oldString, useLongestToken) {
  var components = [];
  var nextComponent;
  while (lastComponent) {
    components.push(lastComponent);
    nextComponent = lastComponent.previousComponent;
    delete lastComponent.previousComponent;
    lastComponent = nextComponent;
  }
  components.reverse();
  var componentPos = 0, componentLen = components.length, newPos = 0, oldPos = 0;
  for (; componentPos < componentLen; componentPos++) {
    var component = components[componentPos];
    if (!component.removed) {
      if (!component.added && useLongestToken) {
        var value = newString.slice(newPos, newPos + component.count);
        value = value.map(function(value2, i) {
          var oldValue = oldString[oldPos + i];
          return oldValue.length > value2.length ? oldValue : value2;
        });
        component.value = diff2.join(value);
      } else {
        component.value = diff2.join(newString.slice(newPos, newPos + component.count));
      }
      newPos += component.count;
      if (!component.added) {
        oldPos += component.count;
      }
    } else {
      component.value = diff2.join(oldString.slice(oldPos, oldPos + component.count));
      oldPos += component.count;
      if (componentPos && components[componentPos - 1].added) {
        var tmp = components[componentPos - 1];
        components[componentPos - 1] = components[componentPos];
        components[componentPos] = tmp;
      }
    }
  }
  var finalComponent = components[componentLen - 1];
  if (componentLen > 1 && typeof finalComponent.value === "string" && (finalComponent.added || finalComponent.removed) && diff2.equals("", finalComponent.value)) {
    components[componentLen - 2].value += finalComponent.value;
    components.pop();
  }
  return components;
}
function diffChars(oldStr, newStr, options) {
  return characterDiff.diff(oldStr, newStr, options);
}
function diffLines(oldStr, newStr, callback) {
  return lineDiff.diff(oldStr, newStr, callback);
}
function _typeof(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof = function(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof(obj);
}
function canonicalize(obj, stack, replacementStack, replacer, key) {
  stack = stack || [];
  replacementStack = replacementStack || [];
  if (replacer) {
    obj = replacer(key, obj);
  }
  var i;
  for (i = 0; i < stack.length; i += 1) {
    if (stack[i] === obj) {
      return replacementStack[i];
    }
  }
  var canonicalizedObj;
  if ("[object Array]" === objectPrototypeToString.call(obj)) {
    stack.push(obj);
    canonicalizedObj = new Array(obj.length);
    replacementStack.push(canonicalizedObj);
    for (i = 0; i < obj.length; i += 1) {
      canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack, replacer, key);
    }
    stack.pop();
    replacementStack.pop();
    return canonicalizedObj;
  }
  if (obj && obj.toJSON) {
    obj = obj.toJSON();
  }
  if (_typeof(obj) === "object" && obj !== null) {
    stack.push(obj);
    canonicalizedObj = {};
    replacementStack.push(canonicalizedObj);
    var sortedKeys = [], _key;
    for (_key in obj) {
      if (obj.hasOwnProperty(_key)) {
        sortedKeys.push(_key);
      }
    }
    sortedKeys.sort();
    for (i = 0; i < sortedKeys.length; i += 1) {
      _key = sortedKeys[i];
      canonicalizedObj[_key] = canonicalize(obj[_key], stack, replacementStack, replacer, _key);
    }
    stack.pop();
    replacementStack.pop();
  } else {
    canonicalizedObj = obj;
  }
  return canonicalizedObj;
}
function diffArrays(oldArr, newArr, callback) {
  return arrayDiff.diff(oldArr, newArr, callback);
}
var import_dist58, import_dist59, import_dist60, characterDiff, extendedWordChars, reWhitespace, wordDiff, lineDiff, sentenceDiff, cssDiff, objectPrototypeToString, jsonDiff, arrayDiff;
var init_lib6 = __esm({
  "node_modules/diff/lib/index.mjs"() {
    import_dist58 = __toESM(require_dist(), 1);
    import_dist59 = __toESM(require_dist2(), 1);
    import_dist60 = __toESM(require_dist3(), 1);
    Diff.prototype = {
      diff: function diff(oldString, newString) {
        var _options$timeout;
        var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        var callback = options.callback;
        if (typeof options === "function") {
          callback = options;
          options = {};
        }
        this.options = options;
        var self2 = this;
        function done(value) {
          if (callback) {
            setTimeout(function() {
              callback(void 0, value);
            }, 0);
            return true;
          } else {
            return value;
          }
        }
        oldString = this.castInput(oldString);
        newString = this.castInput(newString);
        oldString = this.removeEmpty(this.tokenize(oldString));
        newString = this.removeEmpty(this.tokenize(newString));
        var newLen = newString.length, oldLen = oldString.length;
        var editLength = 1;
        var maxEditLength = newLen + oldLen;
        if (options.maxEditLength) {
          maxEditLength = Math.min(maxEditLength, options.maxEditLength);
        }
        var maxExecutionTime = (_options$timeout = options.timeout) !== null && _options$timeout !== void 0 ? _options$timeout : Infinity;
        var abortAfterTimestamp = Date.now() + maxExecutionTime;
        var bestPath = [{
          oldPos: -1,
          lastComponent: void 0
        }];
        var newPos = this.extractCommon(bestPath[0], newString, oldString, 0);
        if (bestPath[0].oldPos + 1 >= oldLen && newPos + 1 >= newLen) {
          return done([{
            value: this.join(newString),
            count: newString.length
          }]);
        }
        var minDiagonalToConsider = -Infinity, maxDiagonalToConsider = Infinity;
        function execEditLength() {
          for (var diagonalPath = Math.max(minDiagonalToConsider, -editLength); diagonalPath <= Math.min(maxDiagonalToConsider, editLength); diagonalPath += 2) {
            var basePath = void 0;
            var removePath = bestPath[diagonalPath - 1], addPath = bestPath[diagonalPath + 1];
            if (removePath) {
              bestPath[diagonalPath - 1] = void 0;
            }
            var canAdd = false;
            if (addPath) {
              var addPathNewPos = addPath.oldPos - diagonalPath;
              canAdd = addPath && 0 <= addPathNewPos && addPathNewPos < newLen;
            }
            var canRemove = removePath && removePath.oldPos + 1 < oldLen;
            if (!canAdd && !canRemove) {
              bestPath[diagonalPath] = void 0;
              continue;
            }
            if (!canRemove || canAdd && removePath.oldPos + 1 < addPath.oldPos) {
              basePath = self2.addToPath(addPath, true, void 0, 0);
            } else {
              basePath = self2.addToPath(removePath, void 0, true, 1);
            }
            newPos = self2.extractCommon(basePath, newString, oldString, diagonalPath);
            if (basePath.oldPos + 1 >= oldLen && newPos + 1 >= newLen) {
              return done(buildValues(self2, basePath.lastComponent, newString, oldString, self2.useLongestToken));
            } else {
              bestPath[diagonalPath] = basePath;
              if (basePath.oldPos + 1 >= oldLen) {
                maxDiagonalToConsider = Math.min(maxDiagonalToConsider, diagonalPath - 1);
              }
              if (newPos + 1 >= newLen) {
                minDiagonalToConsider = Math.max(minDiagonalToConsider, diagonalPath + 1);
              }
            }
          }
          editLength++;
        }
        if (callback) {
          (function exec() {
            setTimeout(function() {
              if (editLength > maxEditLength || Date.now() > abortAfterTimestamp) {
                return callback();
              }
              if (!execEditLength()) {
                exec();
              }
            }, 0);
          })();
        } else {
          while (editLength <= maxEditLength && Date.now() <= abortAfterTimestamp) {
            var ret = execEditLength();
            if (ret) {
              return ret;
            }
          }
        }
      },
      addToPath: function addToPath(path2, added, removed, oldPosInc) {
        var last = path2.lastComponent;
        if (last && last.added === added && last.removed === removed) {
          return {
            oldPos: path2.oldPos + oldPosInc,
            lastComponent: {
              count: last.count + 1,
              added,
              removed,
              previousComponent: last.previousComponent
            }
          };
        } else {
          return {
            oldPos: path2.oldPos + oldPosInc,
            lastComponent: {
              count: 1,
              added,
              removed,
              previousComponent: last
            }
          };
        }
      },
      extractCommon: function extractCommon(basePath, newString, oldString, diagonalPath) {
        var newLen = newString.length, oldLen = oldString.length, oldPos = basePath.oldPos, newPos = oldPos - diagonalPath, commonCount = 0;
        while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {
          newPos++;
          oldPos++;
          commonCount++;
        }
        if (commonCount) {
          basePath.lastComponent = {
            count: commonCount,
            previousComponent: basePath.lastComponent
          };
        }
        basePath.oldPos = oldPos;
        return newPos;
      },
      equals: function equals(left, right) {
        if (this.options.comparator) {
          return this.options.comparator(left, right);
        } else {
          return left === right || this.options.ignoreCase && left.toLowerCase() === right.toLowerCase();
        }
      },
      removeEmpty: function removeEmpty(array) {
        var ret = [];
        for (var i = 0; i < array.length; i++) {
          if (array[i]) {
            ret.push(array[i]);
          }
        }
        return ret;
      },
      castInput: function castInput(value) {
        return value;
      },
      tokenize: function tokenize(value) {
        return value.split("");
      },
      join: function join2(chars2) {
        return chars2.join("");
      }
    };
    characterDiff = new Diff();
    extendedWordChars = /^[A-Za-z\xC0-\u02C6\u02C8-\u02D7\u02DE-\u02FF\u1E00-\u1EFF]+$/;
    reWhitespace = /\S/;
    wordDiff = new Diff();
    wordDiff.equals = function(left, right) {
      if (this.options.ignoreCase) {
        left = left.toLowerCase();
        right = right.toLowerCase();
      }
      return left === right || this.options.ignoreWhitespace && !reWhitespace.test(left) && !reWhitespace.test(right);
    };
    wordDiff.tokenize = function(value) {
      var tokens = value.split(/([^\S\r\n]+|[()[\]{}'"\r\n]|\b)/);
      for (var i = 0; i < tokens.length - 1; i++) {
        if (!tokens[i + 1] && tokens[i + 2] && extendedWordChars.test(tokens[i]) && extendedWordChars.test(tokens[i + 2])) {
          tokens[i] += tokens[i + 2];
          tokens.splice(i + 1, 2);
          i--;
        }
      }
      return tokens;
    };
    lineDiff = new Diff();
    lineDiff.tokenize = function(value) {
      if (this.options.stripTrailingCr) {
        value = value.replace(/\r\n/g, "\n");
      }
      var retLines = [], linesAndNewlines = value.split(/(\n|\r\n)/);
      if (!linesAndNewlines[linesAndNewlines.length - 1]) {
        linesAndNewlines.pop();
      }
      for (var i = 0; i < linesAndNewlines.length; i++) {
        var line2 = linesAndNewlines[i];
        if (i % 2 && !this.options.newlineIsToken) {
          retLines[retLines.length - 1] += line2;
        } else {
          if (this.options.ignoreWhitespace) {
            line2 = line2.trim();
          }
          retLines.push(line2);
        }
      }
      return retLines;
    };
    sentenceDiff = new Diff();
    sentenceDiff.tokenize = function(value) {
      return value.split(/(\S.+?[.!?])(?=\s+|$)/);
    };
    cssDiff = new Diff();
    cssDiff.tokenize = function(value) {
      return value.split(/([{}:;,]|\s+)/);
    };
    objectPrototypeToString = Object.prototype.toString;
    jsonDiff = new Diff();
    jsonDiff.useLongestToken = true;
    jsonDiff.tokenize = lineDiff.tokenize;
    jsonDiff.castInput = function(value) {
      var _this$options = this.options, undefinedReplacement = _this$options.undefinedReplacement, _this$options$stringi = _this$options.stringifyReplacer, stringifyReplacer = _this$options$stringi === void 0 ? function(k, v) {
        return typeof v === "undefined" ? undefinedReplacement : v;
      } : _this$options$stringi;
      return typeof value === "string" ? value : JSON.stringify(canonicalize(value, null, null, stringifyReplacer), stringifyReplacer, "  ");
    };
    jsonDiff.equals = function(left, right) {
      return Diff.prototype.equals.call(jsonDiff, left.replace(/,([\r\n])/g, "$1"), right.replace(/,([\r\n])/g, "$1"));
    };
    arrayDiff = new Diff();
    arrayDiff.tokenize = function(value) {
      return value.slice();
    };
    arrayDiff.join = arrayDiff.removeEmpty = function(value) {
      return value;
    };
  }
});

// node_modules/uvu/diff/index.mjs
function line(obj, prev, pad) {
  let char = obj.removed ? "--" : obj.added ? "++" : "";
  let arr = obj.value.replace(/\r?\n$/, "").split("\n");
  let i = 0, tmp, out = "";
  if (obj.added) out += colors[char]().underline(TITLE("Expected:")) + "\n";
  else if (obj.removed) out += colors[char]().underline(TITLE("Actual:")) + "\n";
  for (; i < arr.length; i++) {
    tmp = arr[i];
    if (tmp != null) {
      if (prev) out += LINE(prev + i, pad);
      out += LOG(char, tmp || "\n");
    }
  }
  return out;
}
function arrays(input, expect) {
  let arr = diffArrays(input, expect);
  let i = 0, j = 0, k = 0, tmp, val, char, isObj, str;
  let out = LOG("", "[");
  for (; i < arr.length; i++) {
    char = (tmp = arr[i]).removed ? "--" : tmp.added ? "++" : "";
    if (tmp.added) {
      out += colors[char]().underline(TITLE("Expected:")) + "\n";
    } else if (tmp.removed) {
      out += colors[char]().underline(TITLE("Actual:")) + "\n";
    }
    for (j = 0; j < tmp.value.length; j++) {
      isObj = tmp.value[j] && typeof tmp.value[j] === "object";
      val = stringify(tmp.value[j]).split(/\r?\n/g);
      for (k = 0; k < val.length; ) {
        str = "  " + val[k++] + (isObj ? "" : ",");
        if (isObj && k === val.length && j + 1 < tmp.value.length) str += ",";
        out += LOG(char, str);
      }
    }
  }
  return out + LOG("", "]");
}
function lines(input, expect, linenum = 0) {
  let i = 0, tmp, output = "";
  let arr = diffLines(input, expect);
  let pad = String(expect.split(/\r?\n/g).length - linenum).length;
  for (; i < arr.length; i++) {
    output += line(tmp = arr[i], linenum, pad);
    if (linenum && !tmp.removed) linenum += tmp.count;
  }
  return output;
}
function chars(input, expect) {
  let arr = diffChars(input, expect);
  let i = 0, output = "", tmp;
  let l1 = input.length;
  let l2 = expect.length;
  let p1 = PRETTY(input);
  let p2 = PRETTY(expect);
  tmp = arr[i];
  if (l1 === l2) {
  } else if (tmp.removed && arr[i + 1]) {
    let del = tmp.count - arr[i + 1].count;
    if (del == 0) {
    } else if (del > 0) {
      expect = " ".repeat(del) + expect;
      p2 = " ".repeat(del) + p2;
      l2 += del;
    } else if (del < 0) {
      input = " ".repeat(-del) + input;
      p1 = " ".repeat(-del) + p1;
      l1 += -del;
    }
  }
  output += direct(p1, p2, l1, l2);
  if (l1 === l2) {
    for (tmp = "  "; i < l1; i++) {
      tmp += input[i] === expect[i] ? " " : "^";
    }
  } else {
    for (tmp = "  "; i < arr.length; i++) {
      tmp += (arr[i].added || arr[i].removed ? "^" : " ").repeat(Math.max(arr[i].count, 0));
      if (i + 1 < arr.length && (arr[i].added && arr[i + 1].removed || arr[i].removed && arr[i + 1].added)) {
        arr[i + 1].count -= arr[i].count;
      }
    }
  }
  return output + kleur_default.red(tmp);
}
function direct(input, expect, lenA = String(input).length, lenB = String(expect).length) {
  let gutter = 4;
  let lenC = Math.max(lenA, lenB);
  let typeA = typeof input, typeB = typeof expect;
  if (typeA !== typeB) {
    gutter = 2;
    let delA = gutter + lenC - lenA;
    let delB = gutter + lenC - lenB;
    input += " ".repeat(delA) + kleur_default.dim(`[${typeA}]`);
    expect += " ".repeat(delB) + kleur_default.dim(`[${typeB}]`);
    lenA += delA + typeA.length + 2;
    lenB += delB + typeB.length + 2;
    lenC = Math.max(lenA, lenB);
  }
  let output = colors["++"]("++" + expect + " ".repeat(gutter + lenC - lenB) + TITLE("(Expected)")) + "\n";
  return output + colors["--"]("--" + input + " ".repeat(gutter + lenC - lenA) + TITLE("(Actual)")) + "\n";
}
function sort(input, expect) {
  var k, i = 0, tmp, isArr = Array.isArray(input);
  var keys2 = [], out = isArr ? Array(input.length) : {};
  if (isArr) {
    for (i = 0; i < out.length; i++) {
      tmp = input[i];
      if (!tmp || typeof tmp !== "object") out[i] = tmp;
      else out[i] = sort(tmp, expect[i]);
    }
  } else {
    for (k in expect)
      keys2.push(k);
    for (; i < keys2.length; i++) {
      if (Object.prototype.hasOwnProperty.call(input, k = keys2[i])) {
        if (!(tmp = input[k]) || typeof tmp !== "object") out[k] = tmp;
        else out[k] = sort(tmp, expect[k]);
      }
    }
    for (k in input) {
      if (!out.hasOwnProperty(k)) {
        out[k] = input[k];
      }
    }
  }
  return out;
}
function circular() {
  var cache = /* @__PURE__ */ new Set();
  return function print(key, val) {
    if (val === void 0) return "[__VOID__]";
    if (typeof val === "number" && val !== val) return "[__NAN__]";
    if (typeof val === "bigint") return val.toString();
    if (!val || typeof val !== "object") return val;
    if (cache.has(val)) return "[Circular]";
    cache.add(val);
    return val;
  };
}
function stringify(input) {
  return JSON.stringify(input, circular(), 2).replace(/"\[__NAN__\]"/g, "NaN").replace(/"\[__VOID__\]"/g, "undefined");
}
function compare(input, expect) {
  if (Array.isArray(expect) && Array.isArray(input)) return arrays(input, expect);
  if (expect instanceof RegExp) return chars("" + input, "" + expect);
  let isA = input && typeof input == "object";
  let isB = expect && typeof expect == "object";
  if (isA && isB) input = sort(input, expect);
  if (isB) expect = stringify(expect);
  if (isA) input = stringify(input);
  if (expect && typeof expect == "object") {
    input = stringify(sort(input, expect));
    expect = stringify(expect);
  }
  isA = typeof input == "string";
  isB = typeof expect == "string";
  if (isA && /\r?\n/.test(input)) return lines(input, "" + expect);
  if (isB && /\r?\n/.test(expect)) return lines("" + input, expect);
  if (isA && isB) return chars(input, expect);
  return direct(input, expect);
}
var import_dist61, import_dist62, import_dist63, colors, TITLE, TAB, SPACE, NL, LOG, LINE, PRETTY;
var init_diff = __esm({
  "node_modules/uvu/diff/index.mjs"() {
    import_dist61 = __toESM(require_dist(), 1);
    import_dist62 = __toESM(require_dist2(), 1);
    import_dist63 = __toESM(require_dist3(), 1);
    init_kleur();
    init_lib6();
    colors = {
      "--": kleur_default.red,
      "": kleur_default.grey,
      "++": kleur_default.green
    };
    TITLE = kleur_default.dim().italic;
    TAB = kleur_default.dim("");
    SPACE = kleur_default.dim("");
    NL = kleur_default.dim("");
    LOG = (sym, str) => colors[sym](sym + PRETTY(str)) + "\n";
    LINE = (num, x) => kleur_default.dim("L" + String(num).padStart(x, "0") + " ");
    PRETTY = (str) => str.replace(/[ ]/g, SPACE).replace(/\t/g, TAB).replace(/(\r?\n)/g, NL);
  }
});

// node_modules/uvu/assert/index.mjs
function dedent(str) {
  str = str.replace(/\r?\n/g, "\n");
  let arr = str.match(/^[ \t]*(?=\S)/gm);
  let i = 0, min = 1 / 0, len = (arr || []).length;
  for (; i < len; i++) min = Math.min(min, arr[i].length);
  return len && min ? str.replace(new RegExp(`^[ \\t]{${min}}`, "gm"), "") : str;
}
function assert(bool, actual, expects, operator, detailer, backup, msg) {
  if (bool) return;
  let message = msg || backup;
  if (msg instanceof Error) throw msg;
  let details = detailer && detailer(actual, expects);
  throw new Assertion({ actual, expects, operator, message, details, generated: !msg });
}
function ok(val, msg) {
  assert(!!val, false, true, "ok", false, "Expected value to be truthy", msg);
}
function is(val, exp, msg) {
  assert(val === exp, val, exp, "is", compare, "Expected values to be strictly equal:", msg);
}
function not(val, msg) {
  assert(!val, true, false, "not", false, "Expected value to be falsey", msg);
}
var import_dist64, import_dist65, import_dist66, Assertion;
var init_assert = __esm({
  "node_modules/uvu/assert/index.mjs"() {
    import_dist64 = __toESM(require_dist(), 1);
    import_dist65 = __toESM(require_dist2(), 1);
    import_dist66 = __toESM(require_dist3(), 1);
    init_dist();
    init_diff();
    Assertion = class extends Error {
      constructor(opts = {}) {
        super(opts.message);
        this.name = "Assertion";
        this.code = "ERR_ASSERTION";
        if (Error.captureStackTrace) {
          Error.captureStackTrace(this, this.constructor);
        }
        this.details = opts.details || false;
        this.generated = !!opts.generated;
        this.operator = opts.operator;
        this.expects = opts.expects;
        this.actual = opts.actual;
      }
    };
    not.ok = not;
    is.not = function(val, exp, msg) {
      assert(val !== exp, val, exp, "is.not", false, "Expected values not to be strictly equal", msg);
    };
    not.equal = function(val, exp, msg) {
      assert(!dequal(val, exp), val, exp, "not.equal", false, "Expected values not to be deeply equal", msg);
    };
    not.type = function(val, exp, msg) {
      let tmp = typeof val;
      assert(tmp !== exp, tmp, exp, "not.type", false, `Expected "${tmp}" not to be "${exp}"`, msg);
    };
    not.instance = function(val, exp, msg) {
      let name = "`" + (exp.name || exp.constructor.name) + "`";
      assert(!(val instanceof exp), val, exp, "not.instance", false, `Expected value not to be an instance of ${name}`, msg);
    };
    not.snapshot = function(val, exp, msg) {
      val = dedent(val);
      exp = dedent(exp);
      assert(val !== exp, val, exp, "not.snapshot", false, "Expected value not to match snapshot", msg);
    };
    not.fixture = function(val, exp, msg) {
      val = dedent(val);
      exp = dedent(exp);
      assert(val !== exp, val, exp, "not.fixture", false, "Expected value not to match fixture", msg);
    };
    not.match = function(val, exp, msg) {
      if (typeof exp === "string") {
        assert(!val.includes(exp), val, exp, "not.match", false, `Expected value not to include "${exp}" substring`, msg);
      } else {
        assert(!exp.test(val), val, exp, "not.match", false, `Expected value not to match \`${String(exp)}\` pattern`, msg);
      }
    };
    not.throws = function(blk, exp, msg) {
      if (!msg && typeof exp === "string") {
        msg = exp;
        exp = null;
      }
      try {
        blk();
      } catch (err) {
        if (typeof exp === "function") {
          assert(!exp(err), true, false, "not.throws", false, "Expected function not to throw matching exception", msg);
        } else if (exp instanceof RegExp) {
          assert(!exp.test(err.message), true, false, "not.throws", false, `Expected function not to throw exception matching \`${String(exp)}\` pattern`, msg);
        } else if (!exp) {
          assert(false, true, false, "not.throws", false, "Expected function not to throw", msg);
        }
      }
    };
  }
});

// node_modules/mdast-util-from-markdown/node_modules/mdast-util-to-string/lib/index.js
function toString(value, options) {
  const settings = options || emptyOptions;
  const includeImageAlt = typeof settings.includeImageAlt === "boolean" ? settings.includeImageAlt : true;
  const includeHtml = typeof settings.includeHtml === "boolean" ? settings.includeHtml : true;
  return one(value, includeImageAlt, includeHtml);
}
function one(value, includeImageAlt, includeHtml) {
  if (node(value)) {
    if ("value" in value) {
      return value.type === "html" && !includeHtml ? "" : value.value;
    }
    if (includeImageAlt && "alt" in value && value.alt) {
      return value.alt;
    }
    if ("children" in value) {
      return all(value.children, includeImageAlt, includeHtml);
    }
  }
  if (Array.isArray(value)) {
    return all(value, includeImageAlt, includeHtml);
  }
  return "";
}
function all(values2, includeImageAlt, includeHtml) {
  const result = [];
  let index2 = -1;
  while (++index2 < values2.length) {
    result[index2] = one(values2[index2], includeImageAlt, includeHtml);
  }
  return result.join("");
}
function node(value) {
  return Boolean(value && typeof value === "object");
}
var import_dist67, import_dist68, import_dist69, emptyOptions;
var init_lib7 = __esm({
  "node_modules/mdast-util-from-markdown/node_modules/mdast-util-to-string/lib/index.js"() {
    import_dist67 = __toESM(require_dist(), 1);
    import_dist68 = __toESM(require_dist2(), 1);
    import_dist69 = __toESM(require_dist3(), 1);
    emptyOptions = {};
  }
});

// node_modules/mdast-util-from-markdown/node_modules/mdast-util-to-string/index.js
var import_dist70, import_dist71, import_dist72;
var init_mdast_util_to_string = __esm({
  "node_modules/mdast-util-from-markdown/node_modules/mdast-util-to-string/index.js"() {
    import_dist70 = __toESM(require_dist());
    import_dist71 = __toESM(require_dist2());
    import_dist72 = __toESM(require_dist3());
    init_lib7();
  }
});

// node_modules/micromark-util-symbol/constants.js
var import_dist73, import_dist74, import_dist75, constants;
var init_constants = __esm({
  "node_modules/micromark-util-symbol/constants.js"() {
    import_dist73 = __toESM(require_dist());
    import_dist74 = __toESM(require_dist2());
    import_dist75 = __toESM(require_dist3());
    constants = /** @type {const} */
    {
      attentionSideBefore: 1,
      // Symbol to mark an attention sequence as before content: `*a`
      attentionSideAfter: 2,
      // Symbol to mark an attention sequence as after content: `a*`
      atxHeadingOpeningFenceSizeMax: 6,
      // 6 number signs is fine, 7 isnt.
      autolinkDomainSizeMax: 63,
      // 63 characters is fine, 64 is too many.
      autolinkSchemeSizeMax: 32,
      // 32 characters is fine, 33 is too many.
      cdataOpeningString: "CDATA[",
      // And preceded by `<![`.
      characterGroupWhitespace: 1,
      // Symbol used to indicate a character is whitespace
      characterGroupPunctuation: 2,
      // Symbol used to indicate a character is punctuation
      characterReferenceDecimalSizeMax: 7,
      // `&#9999999;`.
      characterReferenceHexadecimalSizeMax: 6,
      // `&#xff9999;`.
      characterReferenceNamedSizeMax: 31,
      // `&CounterClockwiseContourIntegral;`.
      codeFencedSequenceSizeMin: 3,
      // At least 3 ticks or tildes are needed.
      contentTypeDocument: "document",
      contentTypeFlow: "flow",
      contentTypeContent: "content",
      contentTypeString: "string",
      contentTypeText: "text",
      hardBreakPrefixSizeMin: 2,
      // At least 2 trailing spaces are needed.
      htmlRaw: 1,
      // Symbol for `<script>`
      htmlComment: 2,
      // Symbol for `<!---->`
      htmlInstruction: 3,
      // Symbol for `<?php?>`
      htmlDeclaration: 4,
      // Symbol for `<!doctype>`
      htmlCdata: 5,
      // Symbol for `<![CDATA[]]>`
      htmlBasic: 6,
      // Symbol for `<div`
      htmlComplete: 7,
      // Symbol for `<x>`
      htmlRawSizeMax: 8,
      // Length of `textarea`.
      linkResourceDestinationBalanceMax: 32,
      // See: <https://spec.commonmark.org/0.30/#link-destination>, <https://github.com/remarkjs/react-markdown/issues/658#issuecomment-984345577>
      linkReferenceSizeMax: 999,
      // See: <https://spec.commonmark.org/0.30/#link-label>
      listItemValueSizeMax: 10,
      // See: <https://spec.commonmark.org/0.30/#ordered-list-marker>
      numericBaseDecimal: 10,
      numericBaseHexadecimal: 16,
      tabSize: 4,
      // Tabs have a hard-coded size of 4, per CommonMark.
      thematicBreakMarkerCountMin: 3,
      // At least 3 asterisks, dashes, or underscores are needed.
      v8MaxSafeChunkSize: 1e4
      // V8 (and potentially others) have problems injecting giant arrays into other arrays, hence we operate in chunks.
    };
  }
});

// node_modules/micromark-util-chunked/dev/index.js
function splice(list3, start, remove, items) {
  const end = list3.length;
  let chunkStart = 0;
  let parameters;
  if (start < 0) {
    start = -start > end ? 0 : end + start;
  } else {
    start = start > end ? end : start;
  }
  remove = remove > 0 ? remove : 0;
  if (items.length < constants.v8MaxSafeChunkSize) {
    parameters = Array.from(items);
    parameters.unshift(start, remove);
    list3.splice(...parameters);
  } else {
    if (remove) list3.splice(start, remove);
    while (chunkStart < items.length) {
      parameters = items.slice(
        chunkStart,
        chunkStart + constants.v8MaxSafeChunkSize
      );
      parameters.unshift(start, 0);
      list3.splice(...parameters);
      chunkStart += constants.v8MaxSafeChunkSize;
      start += constants.v8MaxSafeChunkSize;
    }
  }
}
function push(list3, items) {
  if (list3.length > 0) {
    splice(list3, list3.length, 0, items);
    return list3;
  }
  return items;
}
var import_dist76, import_dist77, import_dist78;
var init_dev = __esm({
  "node_modules/micromark-util-chunked/dev/index.js"() {
    import_dist76 = __toESM(require_dist());
    import_dist77 = __toESM(require_dist2());
    import_dist78 = __toESM(require_dist3());
    init_constants();
  }
});

// node_modules/micromark-util-combine-extensions/index.js
function combineExtensions(extensions) {
  const all3 = {};
  let index2 = -1;
  while (++index2 < extensions.length) {
    syntaxExtension(all3, extensions[index2]);
  }
  return all3;
}
function syntaxExtension(all3, extension2) {
  let hook;
  for (hook in extension2) {
    const maybe = hasOwnProperty.call(all3, hook) ? all3[hook] : void 0;
    const left = maybe || (all3[hook] = {});
    const right = extension2[hook];
    let code2;
    if (right) {
      for (code2 in right) {
        if (!hasOwnProperty.call(left, code2)) left[code2] = [];
        const value = right[code2];
        constructs(
          // @ts-expect-error Looks like a list.
          left[code2],
          Array.isArray(value) ? value : value ? [value] : []
        );
      }
    }
  }
}
function constructs(existing, list3) {
  let index2 = -1;
  const before = [];
  while (++index2 < list3.length) {
    ;
    (list3[index2].add === "after" ? existing : before).push(list3[index2]);
  }
  splice(existing, 0, 0, before);
}
var import_dist79, import_dist80, import_dist81, hasOwnProperty;
var init_micromark_util_combine_extensions = __esm({
  "node_modules/micromark-util-combine-extensions/index.js"() {
    import_dist79 = __toESM(require_dist());
    import_dist80 = __toESM(require_dist2());
    import_dist81 = __toESM(require_dist3());
    init_dev();
    hasOwnProperty = {}.hasOwnProperty;
  }
});

// node_modules/micromark-util-symbol/codes.js
var import_dist82, import_dist83, import_dist84, codes;
var init_codes = __esm({
  "node_modules/micromark-util-symbol/codes.js"() {
    import_dist82 = __toESM(require_dist());
    import_dist83 = __toESM(require_dist2());
    import_dist84 = __toESM(require_dist3());
    codes = /** @type {const} */
    {
      carriageReturn: -5,
      lineFeed: -4,
      carriageReturnLineFeed: -3,
      horizontalTab: -2,
      virtualSpace: -1,
      eof: null,
      nul: 0,
      soh: 1,
      stx: 2,
      etx: 3,
      eot: 4,
      enq: 5,
      ack: 6,
      bel: 7,
      bs: 8,
      ht: 9,
      // `\t`
      lf: 10,
      // `\n`
      vt: 11,
      // `\v`
      ff: 12,
      // `\f`
      cr: 13,
      // `\r`
      so: 14,
      si: 15,
      dle: 16,
      dc1: 17,
      dc2: 18,
      dc3: 19,
      dc4: 20,
      nak: 21,
      syn: 22,
      etb: 23,
      can: 24,
      em: 25,
      sub: 26,
      esc: 27,
      fs: 28,
      gs: 29,
      rs: 30,
      us: 31,
      space: 32,
      exclamationMark: 33,
      // `!`
      quotationMark: 34,
      // `"`
      numberSign: 35,
      // `#`
      dollarSign: 36,
      // `$`
      percentSign: 37,
      // `%`
      ampersand: 38,
      // `&`
      apostrophe: 39,
      // `'`
      leftParenthesis: 40,
      // `(`
      rightParenthesis: 41,
      // `)`
      asterisk: 42,
      // `*`
      plusSign: 43,
      // `+`
      comma: 44,
      // `,`
      dash: 45,
      // `-`
      dot: 46,
      // `.`
      slash: 47,
      // `/`
      digit0: 48,
      // `0`
      digit1: 49,
      // `1`
      digit2: 50,
      // `2`
      digit3: 51,
      // `3`
      digit4: 52,
      // `4`
      digit5: 53,
      // `5`
      digit6: 54,
      // `6`
      digit7: 55,
      // `7`
      digit8: 56,
      // `8`
      digit9: 57,
      // `9`
      colon: 58,
      // `:`
      semicolon: 59,
      // `;`
      lessThan: 60,
      // `<`
      equalsTo: 61,
      // `=`
      greaterThan: 62,
      // `>`
      questionMark: 63,
      // `?`
      atSign: 64,
      // `@`
      uppercaseA: 65,
      // `A`
      uppercaseB: 66,
      // `B`
      uppercaseC: 67,
      // `C`
      uppercaseD: 68,
      // `D`
      uppercaseE: 69,
      // `E`
      uppercaseF: 70,
      // `F`
      uppercaseG: 71,
      // `G`
      uppercaseH: 72,
      // `H`
      uppercaseI: 73,
      // `I`
      uppercaseJ: 74,
      // `J`
      uppercaseK: 75,
      // `K`
      uppercaseL: 76,
      // `L`
      uppercaseM: 77,
      // `M`
      uppercaseN: 78,
      // `N`
      uppercaseO: 79,
      // `O`
      uppercaseP: 80,
      // `P`
      uppercaseQ: 81,
      // `Q`
      uppercaseR: 82,
      // `R`
      uppercaseS: 83,
      // `S`
      uppercaseT: 84,
      // `T`
      uppercaseU: 85,
      // `U`
      uppercaseV: 86,
      // `V`
      uppercaseW: 87,
      // `W`
      uppercaseX: 88,
      // `X`
      uppercaseY: 89,
      // `Y`
      uppercaseZ: 90,
      // `Z`
      leftSquareBracket: 91,
      // `[`
      backslash: 92,
      // `\`
      rightSquareBracket: 93,
      // `]`
      caret: 94,
      // `^`
      underscore: 95,
      // `_`
      graveAccent: 96,
      // `` ` ``
      lowercaseA: 97,
      // `a`
      lowercaseB: 98,
      // `b`
      lowercaseC: 99,
      // `c`
      lowercaseD: 100,
      // `d`
      lowercaseE: 101,
      // `e`
      lowercaseF: 102,
      // `f`
      lowercaseG: 103,
      // `g`
      lowercaseH: 104,
      // `h`
      lowercaseI: 105,
      // `i`
      lowercaseJ: 106,
      // `j`
      lowercaseK: 107,
      // `k`
      lowercaseL: 108,
      // `l`
      lowercaseM: 109,
      // `m`
      lowercaseN: 110,
      // `n`
      lowercaseO: 111,
      // `o`
      lowercaseP: 112,
      // `p`
      lowercaseQ: 113,
      // `q`
      lowercaseR: 114,
      // `r`
      lowercaseS: 115,
      // `s`
      lowercaseT: 116,
      // `t`
      lowercaseU: 117,
      // `u`
      lowercaseV: 118,
      // `v`
      lowercaseW: 119,
      // `w`
      lowercaseX: 120,
      // `x`
      lowercaseY: 121,
      // `y`
      lowercaseZ: 122,
      // `z`
      leftCurlyBrace: 123,
      // `{`
      verticalBar: 124,
      // `|`
      rightCurlyBrace: 125,
      // `}`
      tilde: 126,
      // `~`
      del: 127,
      // Unicode Specials block.
      byteOrderMarker: 65279,
      // Unicode Specials block.
      replacementCharacter: 65533
      // ``
    };
  }
});

// node_modules/micromark-util-character/dev/lib/unicode-punctuation-regex.js
var import_dist85, import_dist86, import_dist87, unicodePunctuationRegex;
var init_unicode_punctuation_regex = __esm({
  "node_modules/micromark-util-character/dev/lib/unicode-punctuation-regex.js"() {
    import_dist85 = __toESM(require_dist(), 1);
    import_dist86 = __toESM(require_dist2(), 1);
    import_dist87 = __toESM(require_dist3(), 1);
    unicodePunctuationRegex = /[!-/:-@[-`{-~\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061D-\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1B7D\u1B7E\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u2E52-\u2E5D\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]/;
  }
});

// node_modules/micromark-util-character/dev/index.js
function asciiControl(code2) {
  return (
    // Special whitespace codes (which have negative values), C0 and Control
    // character DEL
    code2 !== null && (code2 < codes.space || code2 === codes.del)
  );
}
function markdownLineEnding(code2) {
  return code2 !== null && code2 < codes.horizontalTab;
}
function markdownLineEndingOrSpace(code2) {
  return code2 !== null && (code2 < codes.nul || code2 === codes.space);
}
function markdownSpace(code2) {
  return code2 === codes.horizontalTab || code2 === codes.virtualSpace || code2 === codes.space;
}
function regexCheck(regex) {
  return check;
  function check(code2) {
    return code2 !== null && regex.test(String.fromCharCode(code2));
  }
}
var import_dist88, import_dist89, import_dist90, asciiAlpha, asciiAlphanumeric, asciiAtext, asciiDigit, asciiHexDigit, asciiPunctuation, unicodePunctuation, unicodeWhitespace;
var init_dev2 = __esm({
  "node_modules/micromark-util-character/dev/index.js"() {
    import_dist88 = __toESM(require_dist());
    import_dist89 = __toESM(require_dist2());
    import_dist90 = __toESM(require_dist3());
    init_codes();
    init_unicode_punctuation_regex();
    asciiAlpha = regexCheck(/[A-Za-z]/);
    asciiAlphanumeric = regexCheck(/[\dA-Za-z]/);
    asciiAtext = regexCheck(/[#-'*+\--9=?A-Z^-~]/);
    asciiDigit = regexCheck(/\d/);
    asciiHexDigit = regexCheck(/[\dA-Fa-f]/);
    asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/);
    unicodePunctuation = regexCheck(unicodePunctuationRegex);
    unicodeWhitespace = regexCheck(/\s/);
  }
});

// node_modules/micromark-factory-space/dev/index.js
function factorySpace(effects, ok3, type, max) {
  const limit = max ? max - 1 : Number.POSITIVE_INFINITY;
  let size = 0;
  return start;
  function start(code2) {
    if (markdownSpace(code2)) {
      effects.enter(type);
      return prefix(code2);
    }
    return ok3(code2);
  }
  function prefix(code2) {
    if (markdownSpace(code2) && size++ < limit) {
      effects.consume(code2);
      return prefix;
    }
    effects.exit(type);
    return ok3(code2);
  }
}
var import_dist91, import_dist92, import_dist93;
var init_dev3 = __esm({
  "node_modules/micromark-factory-space/dev/index.js"() {
    import_dist91 = __toESM(require_dist());
    import_dist92 = __toESM(require_dist2());
    import_dist93 = __toESM(require_dist3());
    init_dev2();
  }
});

// node_modules/micromark-util-symbol/types.js
var import_dist94, import_dist95, import_dist96, types;
var init_types = __esm({
  "node_modules/micromark-util-symbol/types.js"() {
    import_dist94 = __toESM(require_dist());
    import_dist95 = __toESM(require_dist2());
    import_dist96 = __toESM(require_dist3());
    types = /** @type {const} */
    {
      // Generic type for data, such as in a title, a destination, etc.
      data: "data",
      // Generic type for syntactic whitespace (tabs, virtual spaces, spaces).
      // Such as, between a fenced code fence and an info string.
      whitespace: "whitespace",
      // Generic type for line endings (line feed, carriage return, carriage return +
      // line feed).
      lineEnding: "lineEnding",
      // A line ending, but ending a blank line.
      lineEndingBlank: "lineEndingBlank",
      // Generic type for whitespace (tabs, virtual spaces, spaces) at the start of a
      // line.
      linePrefix: "linePrefix",
      // Generic type for whitespace (tabs, virtual spaces, spaces) at the end of a
      // line.
      lineSuffix: "lineSuffix",
      // Whole ATX heading:
      //
      // ```markdown
      // #
      // ## Alpha
      // ### Bravo ###
      // ```
      //
      // Includes `atxHeadingSequence`, `whitespace`, `atxHeadingText`.
      atxHeading: "atxHeading",
      // Sequence of number signs in an ATX heading (`###`).
      atxHeadingSequence: "atxHeadingSequence",
      // Content in an ATX heading (`alpha`).
      // Includes text.
      atxHeadingText: "atxHeadingText",
      // Whole autolink (`<https://example.com>` or `<admin@example.com>`)
      // Includes `autolinkMarker` and `autolinkProtocol` or `autolinkEmail`.
      autolink: "autolink",
      // Email autolink w/o markers (`admin@example.com`)
      autolinkEmail: "autolinkEmail",
      // Marker around an `autolinkProtocol` or `autolinkEmail` (`<` or `>`).
      autolinkMarker: "autolinkMarker",
      // Protocol autolink w/o markers (`https://example.com`)
      autolinkProtocol: "autolinkProtocol",
      // A whole character escape (`\-`).
      // Includes `escapeMarker` and `characterEscapeValue`.
      characterEscape: "characterEscape",
      // The escaped character (`-`).
      characterEscapeValue: "characterEscapeValue",
      // A whole character reference (`&amp;`, `&#8800;`, or `&#x1D306;`).
      // Includes `characterReferenceMarker`, an optional
      // `characterReferenceMarkerNumeric`, in which case an optional
      // `characterReferenceMarkerHexadecimal`, and a `characterReferenceValue`.
      characterReference: "characterReference",
      // The start or end marker (`&` or `;`).
      characterReferenceMarker: "characterReferenceMarker",
      // Mark reference as numeric (`#`).
      characterReferenceMarkerNumeric: "characterReferenceMarkerNumeric",
      // Mark reference as numeric (`x` or `X`).
      characterReferenceMarkerHexadecimal: "characterReferenceMarkerHexadecimal",
      // Value of character reference w/o markers (`amp`, `8800`, or `1D306`).
      characterReferenceValue: "characterReferenceValue",
      // Whole fenced code:
      //
      // ````markdown
      // ```js
      // alert(1)
      // ```
      // ````
      codeFenced: "codeFenced",
      // A fenced code fence, including whitespace, sequence, info, and meta
      // (` ```js `).
      codeFencedFence: "codeFencedFence",
      // Sequence of grave accent or tilde characters (` ``` `) in a fence.
      codeFencedFenceSequence: "codeFencedFenceSequence",
      // Info word (`js`) in a fence.
      // Includes string.
      codeFencedFenceInfo: "codeFencedFenceInfo",
      // Meta words (`highlight="1"`) in a fence.
      // Includes string.
      codeFencedFenceMeta: "codeFencedFenceMeta",
      // A line of code.
      codeFlowValue: "codeFlowValue",
      // Whole indented code:
      //
      // ```markdown
      //     alert(1)
      // ```
      //
      // Includes `lineEnding`, `linePrefix`, and `codeFlowValue`.
      codeIndented: "codeIndented",
      // A text code (``` `alpha` ```).
      // Includes `codeTextSequence`, `codeTextData`, `lineEnding`, and can include
      // `codeTextPadding`.
      codeText: "codeText",
      codeTextData: "codeTextData",
      // A space or line ending right after or before a tick.
      codeTextPadding: "codeTextPadding",
      // A text code fence (` `` `).
      codeTextSequence: "codeTextSequence",
      // Whole content:
      //
      // ```markdown
      // [a]: b
      // c
      // =
      // d
      // ```
      //
      // Includes `paragraph` and `definition`.
      content: "content",
      // Whole definition:
      //
      // ```markdown
      // [micromark]: https://github.com/micromark/micromark
      // ```
      //
      // Includes `definitionLabel`, `definitionMarker`, `whitespace`,
      // `definitionDestination`, and optionally `lineEnding` and `definitionTitle`.
      definition: "definition",
      // Destination of a definition (`https://github.com/micromark/micromark` or
      // `<https://github.com/micromark/micromark>`).
      // Includes `definitionDestinationLiteral` or `definitionDestinationRaw`.
      definitionDestination: "definitionDestination",
      // Enclosed destination of a definition
      // (`<https://github.com/micromark/micromark>`).
      // Includes `definitionDestinationLiteralMarker` and optionally
      // `definitionDestinationString`.
      definitionDestinationLiteral: "definitionDestinationLiteral",
      // Markers of an enclosed definition destination (`<` or `>`).
      definitionDestinationLiteralMarker: "definitionDestinationLiteralMarker",
      // Unenclosed destination of a definition
      // (`https://github.com/micromark/micromark`).
      // Includes `definitionDestinationString`.
      definitionDestinationRaw: "definitionDestinationRaw",
      // Text in an destination (`https://github.com/micromark/micromark`).
      // Includes string.
      definitionDestinationString: "definitionDestinationString",
      // Label of a definition (`[micromark]`).
      // Includes `definitionLabelMarker` and `definitionLabelString`.
      definitionLabel: "definitionLabel",
      // Markers of a definition label (`[` or `]`).
      definitionLabelMarker: "definitionLabelMarker",
      // Value of a definition label (`micromark`).
      // Includes string.
      definitionLabelString: "definitionLabelString",
      // Marker between a label and a destination (`:`).
      definitionMarker: "definitionMarker",
      // Title of a definition (`"x"`, `'y'`, or `(z)`).
      // Includes `definitionTitleMarker` and optionally `definitionTitleString`.
      definitionTitle: "definitionTitle",
      // Marker around a title of a definition (`"`, `'`, `(`, or `)`).
      definitionTitleMarker: "definitionTitleMarker",
      // Data without markers in a title (`z`).
      // Includes string.
      definitionTitleString: "definitionTitleString",
      // Emphasis (`*alpha*`).
      // Includes `emphasisSequence` and `emphasisText`.
      emphasis: "emphasis",
      // Sequence of emphasis markers (`*` or `_`).
      emphasisSequence: "emphasisSequence",
      // Emphasis text (`alpha`).
      // Includes text.
      emphasisText: "emphasisText",
      // The character escape marker (`\`).
      escapeMarker: "escapeMarker",
      // A hard break created with a backslash (`\\n`).
      // Note: does not include the line ending.
      hardBreakEscape: "hardBreakEscape",
      // A hard break created with trailing spaces (`  \n`).
      // Does not include the line ending.
      hardBreakTrailing: "hardBreakTrailing",
      // Flow HTML:
      //
      // ```markdown
      // <div
      // ```
      //
      // Inlcudes `lineEnding`, `htmlFlowData`.
      htmlFlow: "htmlFlow",
      htmlFlowData: "htmlFlowData",
      // HTML in text (the tag in `a <i> b`).
      // Includes `lineEnding`, `htmlTextData`.
      htmlText: "htmlText",
      htmlTextData: "htmlTextData",
      // Whole image (`![alpha](bravo)`, `![alpha][bravo]`, `![alpha][]`, or
      // `![alpha]`).
      // Includes `label` and an optional `resource` or `reference`.
      image: "image",
      // Whole link label (`[*alpha*]`).
      // Includes `labelLink` or `labelImage`, `labelText`, and `labelEnd`.
      label: "label",
      // Text in an label (`*alpha*`).
      // Includes text.
      labelText: "labelText",
      // Start a link label (`[`).
      // Includes a `labelMarker`.
      labelLink: "labelLink",
      // Start an image label (`![`).
      // Includes `labelImageMarker` and `labelMarker`.
      labelImage: "labelImage",
      // Marker of a label (`[` or `]`).
      labelMarker: "labelMarker",
      // Marker to start an image (`!`).
      labelImageMarker: "labelImageMarker",
      // End a label (`]`).
      // Includes `labelMarker`.
      labelEnd: "labelEnd",
      // Whole link (`[alpha](bravo)`, `[alpha][bravo]`, `[alpha][]`, or `[alpha]`).
      // Includes `label` and an optional `resource` or `reference`.
      link: "link",
      // Whole paragraph:
      //
      // ```markdown
      // alpha
      // bravo.
      // ```
      //
      // Includes text.
      paragraph: "paragraph",
      // A reference (`[alpha]` or `[]`).
      // Includes `referenceMarker` and an optional `referenceString`.
      reference: "reference",
      // A reference marker (`[` or `]`).
      referenceMarker: "referenceMarker",
      // Reference text (`alpha`).
      // Includes string.
      referenceString: "referenceString",
      // A resource (`(https://example.com "alpha")`).
      // Includes `resourceMarker`, an optional `resourceDestination` with an optional
      // `whitespace` and `resourceTitle`.
      resource: "resource",
      // A resource destination (`https://example.com`).
      // Includes `resourceDestinationLiteral` or `resourceDestinationRaw`.
      resourceDestination: "resourceDestination",
      // A literal resource destination (`<https://example.com>`).
      // Includes `resourceDestinationLiteralMarker` and optionally
      // `resourceDestinationString`.
      resourceDestinationLiteral: "resourceDestinationLiteral",
      // A resource destination marker (`<` or `>`).
      resourceDestinationLiteralMarker: "resourceDestinationLiteralMarker",
      // A raw resource destination (`https://example.com`).
      // Includes `resourceDestinationString`.
      resourceDestinationRaw: "resourceDestinationRaw",
      // Resource destination text (`https://example.com`).
      // Includes string.
      resourceDestinationString: "resourceDestinationString",
      // A resource marker (`(` or `)`).
      resourceMarker: "resourceMarker",
      // A resource title (`"alpha"`, `'alpha'`, or `(alpha)`).
      // Includes `resourceTitleMarker` and optionally `resourceTitleString`.
      resourceTitle: "resourceTitle",
      // A resource title marker (`"`, `'`, `(`, or `)`).
      resourceTitleMarker: "resourceTitleMarker",
      // Resource destination title (`alpha`).
      // Includes string.
      resourceTitleString: "resourceTitleString",
      // Whole setext heading:
      //
      // ```markdown
      // alpha
      // bravo
      // =====
      // ```
      //
      // Includes `setextHeadingText`, `lineEnding`, `linePrefix`, and
      // `setextHeadingLine`.
      setextHeading: "setextHeading",
      // Content in a setext heading (`alpha\nbravo`).
      // Includes text.
      setextHeadingText: "setextHeadingText",
      // Underline in a setext heading, including whitespace suffix (`==`).
      // Includes `setextHeadingLineSequence`.
      setextHeadingLine: "setextHeadingLine",
      // Sequence of equals or dash characters in underline in a setext heading (`-`).
      setextHeadingLineSequence: "setextHeadingLineSequence",
      // Strong (`**alpha**`).
      // Includes `strongSequence` and `strongText`.
      strong: "strong",
      // Sequence of strong markers (`**` or `__`).
      strongSequence: "strongSequence",
      // Strong text (`alpha`).
      // Includes text.
      strongText: "strongText",
      // Whole thematic break:
      //
      // ```markdown
      // * * *
      // ```
      //
      // Includes `thematicBreakSequence` and `whitespace`.
      thematicBreak: "thematicBreak",
      // A sequence of one or more thematic break markers (`***`).
      thematicBreakSequence: "thematicBreakSequence",
      // Whole block quote:
      //
      // ```markdown
      // > a
      // >
      // > b
      // ```
      //
      // Includes `blockQuotePrefix` and flow.
      blockQuote: "blockQuote",
      // The `>` or `> ` of a block quote.
      blockQuotePrefix: "blockQuotePrefix",
      // The `>` of a block quote prefix.
      blockQuoteMarker: "blockQuoteMarker",
      // The optional ` ` of a block quote prefix.
      blockQuotePrefixWhitespace: "blockQuotePrefixWhitespace",
      // Whole unordered list:
      //
      // ```markdown
      // - a
      //   b
      // ```
      //
      // Includes `listItemPrefix`, flow, and optionally  `listItemIndent` on further
      // lines.
      listOrdered: "listOrdered",
      // Whole ordered list:
      //
      // ```markdown
      // 1. a
      //    b
      // ```
      //
      // Includes `listItemPrefix`, flow, and optionally  `listItemIndent` on further
      // lines.
      listUnordered: "listUnordered",
      // The indent of further list item lines.
      listItemIndent: "listItemIndent",
      // A marker, as in, `*`, `+`, `-`, `.`, or `)`.
      listItemMarker: "listItemMarker",
      // The thing that starts a list item, such as `1. `.
      // Includes `listItemValue` if ordered, `listItemMarker`, and
      // `listItemPrefixWhitespace` (unless followed by a line ending).
      listItemPrefix: "listItemPrefix",
      // The whitespace after a marker.
      listItemPrefixWhitespace: "listItemPrefixWhitespace",
      // The numerical value of an ordered item.
      listItemValue: "listItemValue",
      // Internal types used for subtokenizers, compiled away
      chunkDocument: "chunkDocument",
      chunkContent: "chunkContent",
      chunkFlow: "chunkFlow",
      chunkText: "chunkText",
      chunkString: "chunkString"
    };
  }
});

// node_modules/mdast-util-from-markdown/node_modules/micromark/dev/lib/initialize/content.js
function initializeContent(effects) {
  const contentStart = effects.attempt(
    this.parser.constructs.contentInitial,
    afterContentStartConstruct,
    paragraphInitial
  );
  let previous2;
  return contentStart;
  function afterContentStartConstruct(code2) {
    ok(
      code2 === codes.eof || markdownLineEnding(code2),
      "expected eol or eof"
    );
    if (code2 === codes.eof) {
      effects.consume(code2);
      return;
    }
    effects.enter(types.lineEnding);
    effects.consume(code2);
    effects.exit(types.lineEnding);
    return factorySpace(effects, contentStart, types.linePrefix);
  }
  function paragraphInitial(code2) {
    ok(
      code2 !== codes.eof && !markdownLineEnding(code2),
      "expected anything other than a line ending or EOF"
    );
    effects.enter(types.paragraph);
    return lineStart(code2);
  }
  function lineStart(code2) {
    const token = effects.enter(types.chunkText, {
      contentType: constants.contentTypeText,
      previous: previous2
    });
    if (previous2) {
      previous2.next = token;
    }
    previous2 = token;
    return data(code2);
  }
  function data(code2) {
    if (code2 === codes.eof) {
      effects.exit(types.chunkText);
      effects.exit(types.paragraph);
      effects.consume(code2);
      return;
    }
    if (markdownLineEnding(code2)) {
      effects.consume(code2);
      effects.exit(types.chunkText);
      return lineStart;
    }
    effects.consume(code2);
    return data;
  }
}
var import_dist97, import_dist98, import_dist99, content;
var init_content = __esm({
  "node_modules/mdast-util-from-markdown/node_modules/micromark/dev/lib/initialize/content.js"() {
    import_dist97 = __toESM(require_dist(), 1);
    import_dist98 = __toESM(require_dist2(), 1);
    import_dist99 = __toESM(require_dist3(), 1);
    init_dev3();
    init_dev2();
    init_codes();
    init_constants();
    init_types();
    init_assert();
    content = { tokenize: initializeContent };
  }
});

// node_modules/mdast-util-from-markdown/node_modules/micromark/dev/lib/initialize/document.js
function initializeDocument(effects) {
  const self2 = this;
  const stack = [];
  let continued = 0;
  let childFlow;
  let childToken;
  let lineStartOffset;
  return start;
  function start(code2) {
    if (continued < stack.length) {
      const item = stack[continued];
      self2.containerState = item[1];
      ok(
        item[0].continuation,
        "expected `continuation` to be defined on container construct"
      );
      return effects.attempt(
        item[0].continuation,
        documentContinue,
        checkNewContainers
      )(code2);
    }
    return checkNewContainers(code2);
  }
  function documentContinue(code2) {
    ok(
      self2.containerState,
      "expected `containerState` to be defined after continuation"
    );
    continued++;
    if (self2.containerState._closeFlow) {
      self2.containerState._closeFlow = void 0;
      if (childFlow) {
        closeFlow();
      }
      const indexBeforeExits = self2.events.length;
      let indexBeforeFlow = indexBeforeExits;
      let point4;
      while (indexBeforeFlow--) {
        if (self2.events[indexBeforeFlow][0] === "exit" && self2.events[indexBeforeFlow][1].type === types.chunkFlow) {
          point4 = self2.events[indexBeforeFlow][1].end;
          break;
        }
      }
      ok(point4, "could not find previous flow chunk");
      exitContainers(continued);
      let index2 = indexBeforeExits;
      while (index2 < self2.events.length) {
        self2.events[index2][1].end = Object.assign({}, point4);
        index2++;
      }
      splice(
        self2.events,
        indexBeforeFlow + 1,
        0,
        self2.events.slice(indexBeforeExits)
      );
      self2.events.length = index2;
      return checkNewContainers(code2);
    }
    return start(code2);
  }
  function checkNewContainers(code2) {
    if (continued === stack.length) {
      if (!childFlow) {
        return documentContinued(code2);
      }
      if (childFlow.currentConstruct && childFlow.currentConstruct.concrete) {
        return flowStart(code2);
      }
      self2.interrupt = Boolean(
        childFlow.currentConstruct && !childFlow._gfmTableDynamicInterruptHack
      );
    }
    self2.containerState = {};
    return effects.check(
      containerConstruct,
      thereIsANewContainer,
      thereIsNoNewContainer
    )(code2);
  }
  function thereIsANewContainer(code2) {
    if (childFlow) closeFlow();
    exitContainers(continued);
    return documentContinued(code2);
  }
  function thereIsNoNewContainer(code2) {
    self2.parser.lazy[self2.now().line] = continued !== stack.length;
    lineStartOffset = self2.now().offset;
    return flowStart(code2);
  }
  function documentContinued(code2) {
    self2.containerState = {};
    return effects.attempt(
      containerConstruct,
      containerContinue,
      flowStart
    )(code2);
  }
  function containerContinue(code2) {
    ok(
      self2.currentConstruct,
      "expected `currentConstruct` to be defined on tokenizer"
    );
    ok(
      self2.containerState,
      "expected `containerState` to be defined on tokenizer"
    );
    continued++;
    stack.push([self2.currentConstruct, self2.containerState]);
    return documentContinued(code2);
  }
  function flowStart(code2) {
    if (code2 === codes.eof) {
      if (childFlow) closeFlow();
      exitContainers(0);
      effects.consume(code2);
      return;
    }
    childFlow = childFlow || self2.parser.flow(self2.now());
    effects.enter(types.chunkFlow, {
      contentType: constants.contentTypeFlow,
      previous: childToken,
      _tokenizer: childFlow
    });
    return flowContinue(code2);
  }
  function flowContinue(code2) {
    if (code2 === codes.eof) {
      writeToChild(effects.exit(types.chunkFlow), true);
      exitContainers(0);
      effects.consume(code2);
      return;
    }
    if (markdownLineEnding(code2)) {
      effects.consume(code2);
      writeToChild(effects.exit(types.chunkFlow));
      continued = 0;
      self2.interrupt = void 0;
      return start;
    }
    effects.consume(code2);
    return flowContinue;
  }
  function writeToChild(token, eof) {
    ok(childFlow, "expected `childFlow` to be defined when continuing");
    const stream = self2.sliceStream(token);
    if (eof) stream.push(null);
    token.previous = childToken;
    if (childToken) childToken.next = token;
    childToken = token;
    childFlow.defineSkip(token.start);
    childFlow.write(stream);
    if (self2.parser.lazy[token.start.line]) {
      let index2 = childFlow.events.length;
      while (index2--) {
        if (
          // The token starts before the line ending
          childFlow.events[index2][1].start.offset < lineStartOffset && // and either is not ended yet
          (!childFlow.events[index2][1].end || // or ends after it.
          childFlow.events[index2][1].end.offset > lineStartOffset)
        ) {
          return;
        }
      }
      const indexBeforeExits = self2.events.length;
      let indexBeforeFlow = indexBeforeExits;
      let seen;
      let point4;
      while (indexBeforeFlow--) {
        if (self2.events[indexBeforeFlow][0] === "exit" && self2.events[indexBeforeFlow][1].type === types.chunkFlow) {
          if (seen) {
            point4 = self2.events[indexBeforeFlow][1].end;
            break;
          }
          seen = true;
        }
      }
      ok(point4, "could not find previous flow chunk");
      exitContainers(continued);
      index2 = indexBeforeExits;
      while (index2 < self2.events.length) {
        self2.events[index2][1].end = Object.assign({}, point4);
        index2++;
      }
      splice(
        self2.events,
        indexBeforeFlow + 1,
        0,
        self2.events.slice(indexBeforeExits)
      );
      self2.events.length = index2;
    }
  }
  function exitContainers(size) {
    let index2 = stack.length;
    while (index2-- > size) {
      const entry = stack[index2];
      self2.containerState = entry[1];
      ok(
        entry[0].exit,
        "expected `exit` to be defined on container construct"
      );
      entry[0].exit.call(self2, effects);
    }
    stack.length = size;
  }
  function closeFlow() {
    ok(
      self2.containerState,
      "expected `containerState` to be defined when closing flow"
    );
    ok(childFlow, "expected `childFlow` to be defined when closing it");
    childFlow.write([codes.eof]);
    childToken = void 0;
    childFlow = void 0;
    self2.containerState._closeFlow = void 0;
  }
}
function tokenizeContainer(effects, ok3, nok) {
  ok(
    this.parser.constructs.disable.null,
    "expected `disable.null` to be populated"
  );
  return factorySpace(
    effects,
    effects.attempt(this.parser.constructs.document, ok3, nok),
    types.linePrefix,
    this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : constants.tabSize
  );
}
var import_dist100, import_dist101, import_dist102, document2, containerConstruct;
var init_document = __esm({
  "node_modules/mdast-util-from-markdown/node_modules/micromark/dev/lib/initialize/document.js"() {
    import_dist100 = __toESM(require_dist(), 1);
    import_dist101 = __toESM(require_dist2(), 1);
    import_dist102 = __toESM(require_dist3(), 1);
    init_dev3();
    init_dev2();
    init_dev();
    init_codes();
    init_constants();
    init_types();
    init_assert();
    document2 = { tokenize: initializeDocument };
    containerConstruct = { tokenize: tokenizeContainer };
  }
});

// node_modules/micromark-util-classify-character/dev/index.js
function classifyCharacter(code2) {
  if (code2 === codes.eof || markdownLineEndingOrSpace(code2) || unicodeWhitespace(code2)) {
    return constants.characterGroupWhitespace;
  }
  if (unicodePunctuation(code2)) {
    return constants.characterGroupPunctuation;
  }
}
var import_dist103, import_dist104, import_dist105;
var init_dev4 = __esm({
  "node_modules/micromark-util-classify-character/dev/index.js"() {
    import_dist103 = __toESM(require_dist());
    import_dist104 = __toESM(require_dist2());
    import_dist105 = __toESM(require_dist3());
    init_dev2();
    init_codes();
    init_constants();
  }
});

// node_modules/micromark-util-resolve-all/index.js
function resolveAll(constructs2, events, context) {
  const called = [];
  let index2 = -1;
  while (++index2 < constructs2.length) {
    const resolve = constructs2[index2].resolveAll;
    if (resolve && !called.includes(resolve)) {
      events = resolve(events, context);
      called.push(resolve);
    }
  }
  return events;
}
var import_dist106, import_dist107, import_dist108;
var init_micromark_util_resolve_all = __esm({
  "node_modules/micromark-util-resolve-all/index.js"() {
    import_dist106 = __toESM(require_dist());
    import_dist107 = __toESM(require_dist2());
    import_dist108 = __toESM(require_dist3());
  }
});

// node_modules/micromark-core-commonmark/dev/lib/attention.js
function resolveAllAttention(events, context) {
  let index2 = -1;
  let open;
  let group;
  let text4;
  let openingSequence;
  let closingSequence;
  let use;
  let nextEvents;
  let offset;
  while (++index2 < events.length) {
    if (events[index2][0] === "enter" && events[index2][1].type === "attentionSequence" && events[index2][1]._close) {
      open = index2;
      while (open--) {
        if (events[open][0] === "exit" && events[open][1].type === "attentionSequence" && events[open][1]._open && // If the markers are the same:
        context.sliceSerialize(events[open][1]).charCodeAt(0) === context.sliceSerialize(events[index2][1]).charCodeAt(0)) {
          if ((events[open][1]._close || events[index2][1]._open) && (events[index2][1].end.offset - events[index2][1].start.offset) % 3 && !((events[open][1].end.offset - events[open][1].start.offset + events[index2][1].end.offset - events[index2][1].start.offset) % 3)) {
            continue;
          }
          use = events[open][1].end.offset - events[open][1].start.offset > 1 && events[index2][1].end.offset - events[index2][1].start.offset > 1 ? 2 : 1;
          const start = Object.assign({}, events[open][1].end);
          const end = Object.assign({}, events[index2][1].start);
          movePoint(start, -use);
          movePoint(end, use);
          openingSequence = {
            type: use > 1 ? types.strongSequence : types.emphasisSequence,
            start,
            end: Object.assign({}, events[open][1].end)
          };
          closingSequence = {
            type: use > 1 ? types.strongSequence : types.emphasisSequence,
            start: Object.assign({}, events[index2][1].start),
            end
          };
          text4 = {
            type: use > 1 ? types.strongText : types.emphasisText,
            start: Object.assign({}, events[open][1].end),
            end: Object.assign({}, events[index2][1].start)
          };
          group = {
            type: use > 1 ? types.strong : types.emphasis,
            start: Object.assign({}, openingSequence.start),
            end: Object.assign({}, closingSequence.end)
          };
          events[open][1].end = Object.assign({}, openingSequence.start);
          events[index2][1].start = Object.assign({}, closingSequence.end);
          nextEvents = [];
          if (events[open][1].end.offset - events[open][1].start.offset) {
            nextEvents = push(nextEvents, [
              ["enter", events[open][1], context],
              ["exit", events[open][1], context]
            ]);
          }
          nextEvents = push(nextEvents, [
            ["enter", group, context],
            ["enter", openingSequence, context],
            ["exit", openingSequence, context],
            ["enter", text4, context]
          ]);
          ok(
            context.parser.constructs.insideSpan.null,
            "expected `insideSpan` to be populated"
          );
          nextEvents = push(
            nextEvents,
            resolveAll(
              context.parser.constructs.insideSpan.null,
              events.slice(open + 1, index2),
              context
            )
          );
          nextEvents = push(nextEvents, [
            ["exit", text4, context],
            ["enter", closingSequence, context],
            ["exit", closingSequence, context],
            ["exit", group, context]
          ]);
          if (events[index2][1].end.offset - events[index2][1].start.offset) {
            offset = 2;
            nextEvents = push(nextEvents, [
              ["enter", events[index2][1], context],
              ["exit", events[index2][1], context]
            ]);
          } else {
            offset = 0;
          }
          splice(events, open - 1, index2 - open + 3, nextEvents);
          index2 = open + nextEvents.length - offset - 2;
          break;
        }
      }
    }
  }
  index2 = -1;
  while (++index2 < events.length) {
    if (events[index2][1].type === "attentionSequence") {
      events[index2][1].type = "data";
    }
  }
  return events;
}
function tokenizeAttention(effects, ok3) {
  const attentionMarkers2 = this.parser.constructs.attentionMarkers.null;
  const previous2 = this.previous;
  const before = classifyCharacter(previous2);
  let marker;
  return start;
  function start(code2) {
    ok(
      code2 === codes.asterisk || code2 === codes.underscore,
      "expected asterisk or underscore"
    );
    marker = code2;
    effects.enter("attentionSequence");
    return inside(code2);
  }
  function inside(code2) {
    if (code2 === marker) {
      effects.consume(code2);
      return inside;
    }
    const token = effects.exit("attentionSequence");
    const after = classifyCharacter(code2);
    ok(attentionMarkers2, "expected `attentionMarkers` to be populated");
    const open = !after || after === constants.characterGroupPunctuation && before || attentionMarkers2.includes(code2);
    const close = !before || before === constants.characterGroupPunctuation && after || attentionMarkers2.includes(previous2);
    token._open = Boolean(
      marker === codes.asterisk ? open : open && (before || !close)
    );
    token._close = Boolean(
      marker === codes.asterisk ? close : close && (after || !open)
    );
    return ok3(code2);
  }
}
function movePoint(point4, offset) {
  point4.column += offset;
  point4.offset += offset;
  point4._bufferIndex += offset;
}
var import_dist109, import_dist110, import_dist111, attention;
var init_attention = __esm({
  "node_modules/micromark-core-commonmark/dev/lib/attention.js"() {
    import_dist109 = __toESM(require_dist(), 1);
    import_dist110 = __toESM(require_dist2(), 1);
    import_dist111 = __toESM(require_dist3(), 1);
    init_dev();
    init_dev4();
    init_micromark_util_resolve_all();
    init_codes();
    init_constants();
    init_types();
    init_assert();
    attention = {
      name: "attention",
      tokenize: tokenizeAttention,
      resolveAll: resolveAllAttention
    };
  }
});

// node_modules/micromark-core-commonmark/dev/lib/autolink.js
function tokenizeAutolink(effects, ok3, nok) {
  let size = 0;
  return start;
  function start(code2) {
    ok(code2 === codes.lessThan, "expected `<`");
    effects.enter(types.autolink);
    effects.enter(types.autolinkMarker);
    effects.consume(code2);
    effects.exit(types.autolinkMarker);
    effects.enter(types.autolinkProtocol);
    return open;
  }
  function open(code2) {
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      return schemeOrEmailAtext;
    }
    return emailAtext(code2);
  }
  function schemeOrEmailAtext(code2) {
    if (code2 === codes.plusSign || code2 === codes.dash || code2 === codes.dot || asciiAlphanumeric(code2)) {
      size = 1;
      return schemeInsideOrEmailAtext(code2);
    }
    return emailAtext(code2);
  }
  function schemeInsideOrEmailAtext(code2) {
    if (code2 === codes.colon) {
      effects.consume(code2);
      size = 0;
      return urlInside;
    }
    if ((code2 === codes.plusSign || code2 === codes.dash || code2 === codes.dot || asciiAlphanumeric(code2)) && size++ < constants.autolinkSchemeSizeMax) {
      effects.consume(code2);
      return schemeInsideOrEmailAtext;
    }
    size = 0;
    return emailAtext(code2);
  }
  function urlInside(code2) {
    if (code2 === codes.greaterThan) {
      effects.exit(types.autolinkProtocol);
      effects.enter(types.autolinkMarker);
      effects.consume(code2);
      effects.exit(types.autolinkMarker);
      effects.exit(types.autolink);
      return ok3;
    }
    if (code2 === codes.eof || code2 === codes.space || code2 === codes.lessThan || asciiControl(code2)) {
      return nok(code2);
    }
    effects.consume(code2);
    return urlInside;
  }
  function emailAtext(code2) {
    if (code2 === codes.atSign) {
      effects.consume(code2);
      return emailAtSignOrDot;
    }
    if (asciiAtext(code2)) {
      effects.consume(code2);
      return emailAtext;
    }
    return nok(code2);
  }
  function emailAtSignOrDot(code2) {
    return asciiAlphanumeric(code2) ? emailLabel(code2) : nok(code2);
  }
  function emailLabel(code2) {
    if (code2 === codes.dot) {
      effects.consume(code2);
      size = 0;
      return emailAtSignOrDot;
    }
    if (code2 === codes.greaterThan) {
      effects.exit(types.autolinkProtocol).type = types.autolinkEmail;
      effects.enter(types.autolinkMarker);
      effects.consume(code2);
      effects.exit(types.autolinkMarker);
      effects.exit(types.autolink);
      return ok3;
    }
    return emailValue(code2);
  }
  function emailValue(code2) {
    if ((code2 === codes.dash || asciiAlphanumeric(code2)) && size++ < constants.autolinkDomainSizeMax) {
      const next = code2 === codes.dash ? emailValue : emailLabel;
      effects.consume(code2);
      return next;
    }
    return nok(code2);
  }
}
var import_dist112, import_dist113, import_dist114, autolink;
var init_autolink = __esm({
  "node_modules/micromark-core-commonmark/dev/lib/autolink.js"() {
    import_dist112 = __toESM(require_dist(), 1);
    import_dist113 = __toESM(require_dist2(), 1);
    import_dist114 = __toESM(require_dist3(), 1);
    init_dev2();
    init_codes();
    init_constants();
    init_types();
    init_assert();
    autolink = { name: "autolink", tokenize: tokenizeAutolink };
  }
});

// node_modules/micromark-core-commonmark/dev/lib/blank-line.js
function tokenizeBlankLine(effects, ok3, nok) {
  return start;
  function start(code2) {
    return markdownSpace(code2) ? factorySpace(effects, after, types.linePrefix)(code2) : after(code2);
  }
  function after(code2) {
    return code2 === codes.eof || markdownLineEnding(code2) ? ok3(code2) : nok(code2);
  }
}
var import_dist115, import_dist116, import_dist117, blankLine;
var init_blank_line = __esm({
  "node_modules/micromark-core-commonmark/dev/lib/blank-line.js"() {
    import_dist115 = __toESM(require_dist(), 1);
    import_dist116 = __toESM(require_dist2(), 1);
    import_dist117 = __toESM(require_dist3(), 1);
    init_dev3();
    init_dev2();
    init_codes();
    init_types();
    blankLine = { tokenize: tokenizeBlankLine, partial: true };
  }
});

// node_modules/micromark-core-commonmark/dev/lib/block-quote.js
function tokenizeBlockQuoteStart(effects, ok3, nok) {
  const self2 = this;
  return start;
  function start(code2) {
    if (code2 === codes.greaterThan) {
      const state = self2.containerState;
      ok(state, "expected `containerState` to be defined in container");
      if (!state.open) {
        effects.enter(types.blockQuote, { _container: true });
        state.open = true;
      }
      effects.enter(types.blockQuotePrefix);
      effects.enter(types.blockQuoteMarker);
      effects.consume(code2);
      effects.exit(types.blockQuoteMarker);
      return after;
    }
    return nok(code2);
  }
  function after(code2) {
    if (markdownSpace(code2)) {
      effects.enter(types.blockQuotePrefixWhitespace);
      effects.consume(code2);
      effects.exit(types.blockQuotePrefixWhitespace);
      effects.exit(types.blockQuotePrefix);
      return ok3;
    }
    effects.exit(types.blockQuotePrefix);
    return ok3(code2);
  }
}
function tokenizeBlockQuoteContinuation(effects, ok3, nok) {
  const self2 = this;
  return contStart;
  function contStart(code2) {
    if (markdownSpace(code2)) {
      ok(
        self2.parser.constructs.disable.null,
        "expected `disable.null` to be populated"
      );
      return factorySpace(
        effects,
        contBefore,
        types.linePrefix,
        self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : constants.tabSize
      )(code2);
    }
    return contBefore(code2);
  }
  function contBefore(code2) {
    return effects.attempt(blockQuote, ok3, nok)(code2);
  }
}
function exit(effects) {
  effects.exit(types.blockQuote);
}
var import_dist118, import_dist119, import_dist120, blockQuote;
var init_block_quote = __esm({
  "node_modules/micromark-core-commonmark/dev/lib/block-quote.js"() {
    import_dist118 = __toESM(require_dist(), 1);
    import_dist119 = __toESM(require_dist2(), 1);
    import_dist120 = __toESM(require_dist3(), 1);
    init_dev3();
    init_dev2();
    init_codes();
    init_constants();
    init_types();
    init_assert();
    blockQuote = {
      name: "blockQuote",
      tokenize: tokenizeBlockQuoteStart,
      continuation: { tokenize: tokenizeBlockQuoteContinuation },
      exit
    };
  }
});

// node_modules/micromark-core-commonmark/dev/lib/character-escape.js
function tokenizeCharacterEscape(effects, ok3, nok) {
  return start;
  function start(code2) {
    ok(code2 === codes.backslash, "expected `\\`");
    effects.enter(types.characterEscape);
    effects.enter(types.escapeMarker);
    effects.consume(code2);
    effects.exit(types.escapeMarker);
    return inside;
  }
  function inside(code2) {
    if (asciiPunctuation(code2)) {
      effects.enter(types.characterEscapeValue);
      effects.consume(code2);
      effects.exit(types.characterEscapeValue);
      effects.exit(types.characterEscape);
      return ok3;
    }
    return nok(code2);
  }
}
var import_dist121, import_dist122, import_dist123, characterEscape;
var init_character_escape = __esm({
  "node_modules/micromark-core-commonmark/dev/lib/character-escape.js"() {
    import_dist121 = __toESM(require_dist(), 1);
    import_dist122 = __toESM(require_dist2(), 1);
    import_dist123 = __toESM(require_dist3(), 1);
    init_dev2();
    init_codes();
    init_types();
    init_assert();
    characterEscape = {
      name: "characterEscape",
      tokenize: tokenizeCharacterEscape
    };
  }
});

// node_modules/decode-named-character-reference/index.dom.js
function decodeNamedCharacterReference(value) {
  const characterReference2 = "&" + value + ";";
  element.innerHTML = characterReference2;
  const character = element.textContent;
  if (
    // @ts-expect-error: TypeScript is wrong that `textContent` on elements can
    // yield `null`.
    character.charCodeAt(character.length - 1) === 59 && value !== "semi"
  ) {
    return false;
  }
  return character === characterReference2 ? false : character;
}
var import_dist124, import_dist125, import_dist126, element;
var init_index_dom = __esm({
  "node_modules/decode-named-character-reference/index.dom.js"() {
    import_dist124 = __toESM(require_dist());
    import_dist125 = __toESM(require_dist2());
    import_dist126 = __toESM(require_dist3());
    element = document.createElement("i");
  }
});

// node_modules/micromark-core-commonmark/dev/lib/character-reference.js
function tokenizeCharacterReference(effects, ok3, nok) {
  const self2 = this;
  let size = 0;
  let max;
  let test;
  return start;
  function start(code2) {
    ok(code2 === codes.ampersand, "expected `&`");
    effects.enter(types.characterReference);
    effects.enter(types.characterReferenceMarker);
    effects.consume(code2);
    effects.exit(types.characterReferenceMarker);
    return open;
  }
  function open(code2) {
    if (code2 === codes.numberSign) {
      effects.enter(types.characterReferenceMarkerNumeric);
      effects.consume(code2);
      effects.exit(types.characterReferenceMarkerNumeric);
      return numeric;
    }
    effects.enter(types.characterReferenceValue);
    max = constants.characterReferenceNamedSizeMax;
    test = asciiAlphanumeric;
    return value(code2);
  }
  function numeric(code2) {
    if (code2 === codes.uppercaseX || code2 === codes.lowercaseX) {
      effects.enter(types.characterReferenceMarkerHexadecimal);
      effects.consume(code2);
      effects.exit(types.characterReferenceMarkerHexadecimal);
      effects.enter(types.characterReferenceValue);
      max = constants.characterReferenceHexadecimalSizeMax;
      test = asciiHexDigit;
      return value;
    }
    effects.enter(types.characterReferenceValue);
    max = constants.characterReferenceDecimalSizeMax;
    test = asciiDigit;
    return value(code2);
  }
  function value(code2) {
    if (code2 === codes.semicolon && size) {
      const token = effects.exit(types.characterReferenceValue);
      if (test === asciiAlphanumeric && !decodeNamedCharacterReference(self2.sliceSerialize(token))) {
        return nok(code2);
      }
      effects.enter(types.characterReferenceMarker);
      effects.consume(code2);
      effects.exit(types.characterReferenceMarker);
      effects.exit(types.characterReference);
      return ok3;
    }
    if (test(code2) && size++ < max) {
      effects.consume(code2);
      return value;
    }
    return nok(code2);
  }
}
var import_dist127, import_dist128, import_dist129, characterReference;
var init_character_reference = __esm({
  "node_modules/micromark-core-commonmark/dev/lib/character-reference.js"() {
    import_dist127 = __toESM(require_dist(), 1);
    import_dist128 = __toESM(require_dist2(), 1);
    import_dist129 = __toESM(require_dist3(), 1);
    init_index_dom();
    init_dev2();
    init_codes();
    init_constants();
    init_types();
    init_assert();
    characterReference = {
      name: "characterReference",
      tokenize: tokenizeCharacterReference
    };
  }
});

// node_modules/micromark-core-commonmark/dev/lib/code-fenced.js
function tokenizeCodeFenced(effects, ok3, nok) {
  const self2 = this;
  const closeStart = { tokenize: tokenizeCloseStart, partial: true };
  let initialPrefix = 0;
  let sizeOpen = 0;
  let marker;
  return start;
  function start(code2) {
    return beforeSequenceOpen(code2);
  }
  function beforeSequenceOpen(code2) {
    ok(
      code2 === codes.graveAccent || code2 === codes.tilde,
      "expected `` ` `` or `~`"
    );
    const tail = self2.events[self2.events.length - 1];
    initialPrefix = tail && tail[1].type === types.linePrefix ? tail[2].sliceSerialize(tail[1], true).length : 0;
    marker = code2;
    effects.enter(types.codeFenced);
    effects.enter(types.codeFencedFence);
    effects.enter(types.codeFencedFenceSequence);
    return sequenceOpen(code2);
  }
  function sequenceOpen(code2) {
    if (code2 === marker) {
      sizeOpen++;
      effects.consume(code2);
      return sequenceOpen;
    }
    if (sizeOpen < constants.codeFencedSequenceSizeMin) {
      return nok(code2);
    }
    effects.exit(types.codeFencedFenceSequence);
    return markdownSpace(code2) ? factorySpace(effects, infoBefore, types.whitespace)(code2) : infoBefore(code2);
  }
  function infoBefore(code2) {
    if (code2 === codes.eof || markdownLineEnding(code2)) {
      effects.exit(types.codeFencedFence);
      return self2.interrupt ? ok3(code2) : effects.check(nonLazyContinuation, atNonLazyBreak, after)(code2);
    }
    effects.enter(types.codeFencedFenceInfo);
    effects.enter(types.chunkString, { contentType: constants.contentTypeString });
    return info(code2);
  }
  function info(code2) {
    if (code2 === codes.eof || markdownLineEnding(code2)) {
      effects.exit(types.chunkString);
      effects.exit(types.codeFencedFenceInfo);
      return infoBefore(code2);
    }
    if (markdownSpace(code2)) {
      effects.exit(types.chunkString);
      effects.exit(types.codeFencedFenceInfo);
      return factorySpace(effects, metaBefore, types.whitespace)(code2);
    }
    if (code2 === codes.graveAccent && code2 === marker) {
      return nok(code2);
    }
    effects.consume(code2);
    return info;
  }
  function metaBefore(code2) {
    if (code2 === codes.eof || markdownLineEnding(code2)) {
      return infoBefore(code2);
    }
    effects.enter(types.codeFencedFenceMeta);
    effects.enter(types.chunkString, { contentType: constants.contentTypeString });
    return meta(code2);
  }
  function meta(code2) {
    if (code2 === codes.eof || markdownLineEnding(code2)) {
      effects.exit(types.chunkString);
      effects.exit(types.codeFencedFenceMeta);
      return infoBefore(code2);
    }
    if (code2 === codes.graveAccent && code2 === marker) {
      return nok(code2);
    }
    effects.consume(code2);
    return meta;
  }
  function atNonLazyBreak(code2) {
    ok(markdownLineEnding(code2), "expected eol");
    return effects.attempt(closeStart, after, contentBefore)(code2);
  }
  function contentBefore(code2) {
    ok(markdownLineEnding(code2), "expected eol");
    effects.enter(types.lineEnding);
    effects.consume(code2);
    effects.exit(types.lineEnding);
    return contentStart;
  }
  function contentStart(code2) {
    return initialPrefix > 0 && markdownSpace(code2) ? factorySpace(
      effects,
      beforeContentChunk,
      types.linePrefix,
      initialPrefix + 1
    )(code2) : beforeContentChunk(code2);
  }
  function beforeContentChunk(code2) {
    if (code2 === codes.eof || markdownLineEnding(code2)) {
      return effects.check(nonLazyContinuation, atNonLazyBreak, after)(code2);
    }
    effects.enter(types.codeFlowValue);
    return contentChunk(code2);
  }
  function contentChunk(code2) {
    if (code2 === codes.eof || markdownLineEnding(code2)) {
      effects.exit(types.codeFlowValue);
      return beforeContentChunk(code2);
    }
    effects.consume(code2);
    return contentChunk;
  }
  function after(code2) {
    effects.exit(types.codeFenced);
    return ok3(code2);
  }
  function tokenizeCloseStart(effects2, ok4, nok2) {
    let size = 0;
    return startBefore;
    function startBefore(code2) {
      ok(markdownLineEnding(code2), "expected eol");
      effects2.enter(types.lineEnding);
      effects2.consume(code2);
      effects2.exit(types.lineEnding);
      return start2;
    }
    function start2(code2) {
      ok(
        self2.parser.constructs.disable.null,
        "expected `disable.null` to be populated"
      );
      effects2.enter(types.codeFencedFence);
      return markdownSpace(code2) ? factorySpace(
        effects2,
        beforeSequenceClose,
        types.linePrefix,
        self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : constants.tabSize
      )(code2) : beforeSequenceClose(code2);
    }
    function beforeSequenceClose(code2) {
      if (code2 === marker) {
        effects2.enter(types.codeFencedFenceSequence);
        return sequenceClose(code2);
      }
      return nok2(code2);
    }
    function sequenceClose(code2) {
      if (code2 === marker) {
        size++;
        effects2.consume(code2);
        return sequenceClose;
      }
      if (size >= sizeOpen) {
        effects2.exit(types.codeFencedFenceSequence);
        return markdownSpace(code2) ? factorySpace(effects2, sequenceCloseAfter, types.whitespace)(code2) : sequenceCloseAfter(code2);
      }
      return nok2(code2);
    }
    function sequenceCloseAfter(code2) {
      if (code2 === codes.eof || markdownLineEnding(code2)) {
        effects2.exit(types.codeFencedFence);
        return ok4(code2);
      }
      return nok2(code2);
    }
  }
}
function tokenizeNonLazyContinuation(effects, ok3, nok) {
  const self2 = this;
  return start;
  function start(code2) {
    if (code2 === codes.eof) {
      return nok(code2);
    }
    ok(markdownLineEnding(code2), "expected eol");
    effects.enter(types.lineEnding);
    effects.consume(code2);
    effects.exit(types.lineEnding);
    return lineStart;
  }
  function lineStart(code2) {
    return self2.parser.lazy[self2.now().line] ? nok(code2) : ok3(code2);
  }
}
var import_dist130, import_dist131, import_dist132, nonLazyContinuation, codeFenced;
var init_code_fenced = __esm({
  "node_modules/micromark-core-commonmark/dev/lib/code-fenced.js"() {
    import_dist130 = __toESM(require_dist(), 1);
    import_dist131 = __toESM(require_dist2(), 1);
    import_dist132 = __toESM(require_dist3(), 1);
    init_dev3();
    init_dev2();
    init_codes();
    init_constants();
    init_types();
    init_assert();
    nonLazyContinuation = {
      tokenize: tokenizeNonLazyContinuation,
      partial: true
    };
    codeFenced = {
      name: "codeFenced",
      tokenize: tokenizeCodeFenced,
      concrete: true
    };
  }
});

// node_modules/micromark-core-commonmark/dev/lib/code-indented.js
function tokenizeCodeIndented(effects, ok3, nok) {
  const self2 = this;
  return start;
  function start(code2) {
    ok(markdownSpace(code2));
    effects.enter(types.codeIndented);
    return factorySpace(
      effects,
      afterPrefix,
      types.linePrefix,
      constants.tabSize + 1
    )(code2);
  }
  function afterPrefix(code2) {
    const tail = self2.events[self2.events.length - 1];
    return tail && tail[1].type === types.linePrefix && tail[2].sliceSerialize(tail[1], true).length >= constants.tabSize ? atBreak(code2) : nok(code2);
  }
  function atBreak(code2) {
    if (code2 === codes.eof) {
      return after(code2);
    }
    if (markdownLineEnding(code2)) {
      return effects.attempt(furtherStart, atBreak, after)(code2);
    }
    effects.enter(types.codeFlowValue);
    return inside(code2);
  }
  function inside(code2) {
    if (code2 === codes.eof || markdownLineEnding(code2)) {
      effects.exit(types.codeFlowValue);
      return atBreak(code2);
    }
    effects.consume(code2);
    return inside;
  }
  function after(code2) {
    effects.exit(types.codeIndented);
    return ok3(code2);
  }
}
function tokenizeFurtherStart(effects, ok3, nok) {
  const self2 = this;
  return furtherStart2;
  function furtherStart2(code2) {
    if (self2.parser.lazy[self2.now().line]) {
      return nok(code2);
    }
    if (markdownLineEnding(code2)) {
      effects.enter(types.lineEnding);
      effects.consume(code2);
      effects.exit(types.lineEnding);
      return furtherStart2;
    }
    return factorySpace(
      effects,
      afterPrefix,
      types.linePrefix,
      constants.tabSize + 1
    )(code2);
  }
  function afterPrefix(code2) {
    const tail = self2.events[self2.events.length - 1];
    return tail && tail[1].type === types.linePrefix && tail[2].sliceSerialize(tail[1], true).length >= constants.tabSize ? ok3(code2) : markdownLineEnding(code2) ? furtherStart2(code2) : nok(code2);
  }
}
var import_dist133, import_dist134, import_dist135, codeIndented, furtherStart;
var init_code_indented = __esm({
  "node_modules/micromark-core-commonmark/dev/lib/code-indented.js"() {
    import_dist133 = __toESM(require_dist(), 1);
    import_dist134 = __toESM(require_dist2(), 1);
    import_dist135 = __toESM(require_dist3(), 1);
    init_dev3();
    init_dev2();
    init_codes();
    init_constants();
    init_types();
    init_assert();
    codeIndented = {
      name: "codeIndented",
      tokenize: tokenizeCodeIndented
    };
    furtherStart = { tokenize: tokenizeFurtherStart, partial: true };
  }
});

// node_modules/micromark-core-commonmark/dev/lib/code-text.js
function resolveCodeText(events) {
  let tailExitIndex = events.length - 4;
  let headEnterIndex = 3;
  let index2;
  let enter;
  if ((events[headEnterIndex][1].type === types.lineEnding || events[headEnterIndex][1].type === "space") && (events[tailExitIndex][1].type === types.lineEnding || events[tailExitIndex][1].type === "space")) {
    index2 = headEnterIndex;
    while (++index2 < tailExitIndex) {
      if (events[index2][1].type === types.codeTextData) {
        events[headEnterIndex][1].type = types.codeTextPadding;
        events[tailExitIndex][1].type = types.codeTextPadding;
        headEnterIndex += 2;
        tailExitIndex -= 2;
        break;
      }
    }
  }
  index2 = headEnterIndex - 1;
  tailExitIndex++;
  while (++index2 <= tailExitIndex) {
    if (enter === void 0) {
      if (index2 !== tailExitIndex && events[index2][1].type !== types.lineEnding) {
        enter = index2;
      }
    } else if (index2 === tailExitIndex || events[index2][1].type === types.lineEnding) {
      events[enter][1].type = types.codeTextData;
      if (index2 !== enter + 2) {
        events[enter][1].end = events[index2 - 1][1].end;
        events.splice(enter + 2, index2 - enter - 2);
        tailExitIndex -= index2 - enter - 2;
        index2 = enter + 2;
      }
      enter = void 0;
    }
  }
  return events;
}
function previous(code2) {
  return code2 !== codes.graveAccent || this.events[this.events.length - 1][1].type === types.characterEscape;
}
function tokenizeCodeText(effects, ok3, nok) {
  const self2 = this;
  let sizeOpen = 0;
  let size;
  let token;
  return start;
  function start(code2) {
    ok(code2 === codes.graveAccent, "expected `` ` ``");
    ok(previous.call(self2, self2.previous), "expected correct previous");
    effects.enter(types.codeText);
    effects.enter(types.codeTextSequence);
    return sequenceOpen(code2);
  }
  function sequenceOpen(code2) {
    if (code2 === codes.graveAccent) {
      effects.consume(code2);
      sizeOpen++;
      return sequenceOpen;
    }
    effects.exit(types.codeTextSequence);
    return between(code2);
  }
  function between(code2) {
    if (code2 === codes.eof) {
      return nok(code2);
    }
    if (code2 === codes.space) {
      effects.enter("space");
      effects.consume(code2);
      effects.exit("space");
      return between;
    }
    if (code2 === codes.graveAccent) {
      token = effects.enter(types.codeTextSequence);
      size = 0;
      return sequenceClose(code2);
    }
    if (markdownLineEnding(code2)) {
      effects.enter(types.lineEnding);
      effects.consume(code2);
      effects.exit(types.lineEnding);
      return between;
    }
    effects.enter(types.codeTextData);
    return data(code2);
  }
  function data(code2) {
    if (code2 === codes.eof || code2 === codes.space || code2 === codes.graveAccent || markdownLineEnding(code2)) {
      effects.exit(types.codeTextData);
      return between(code2);
    }
    effects.consume(code2);
    return data;
  }
  function sequenceClose(code2) {
    if (code2 === codes.graveAccent) {
      effects.consume(code2);
      size++;
      return sequenceClose;
    }
    if (size === sizeOpen) {
      effects.exit(types.codeTextSequence);
      effects.exit(types.codeText);
      return ok3(code2);
    }
    token.type = types.codeTextData;
    return data(code2);
  }
}
var import_dist136, import_dist137, import_dist138, codeText;
var init_code_text = __esm({
  "node_modules/micromark-core-commonmark/dev/lib/code-text.js"() {
    import_dist136 = __toESM(require_dist(), 1);
    import_dist137 = __toESM(require_dist2(), 1);
    import_dist138 = __toESM(require_dist3(), 1);
    init_dev2();
    init_codes();
    init_types();
    init_assert();
    codeText = {
      name: "codeText",
      tokenize: tokenizeCodeText,
      resolve: resolveCodeText,
      previous
    };
  }
});

// node_modules/micromark-util-subtokenize/dev/index.js
function subtokenize(events) {
  const jumps = {};
  let index2 = -1;
  let event;
  let lineIndex;
  let otherIndex;
  let otherEvent;
  let parameters;
  let subevents;
  let more;
  while (++index2 < events.length) {
    while (index2 in jumps) {
      index2 = jumps[index2];
    }
    event = events[index2];
    if (index2 && event[1].type === types.chunkFlow && events[index2 - 1][1].type === types.listItemPrefix) {
      ok(event[1]._tokenizer, "expected `_tokenizer` on subtokens");
      subevents = event[1]._tokenizer.events;
      otherIndex = 0;
      if (otherIndex < subevents.length && subevents[otherIndex][1].type === types.lineEndingBlank) {
        otherIndex += 2;
      }
      if (otherIndex < subevents.length && subevents[otherIndex][1].type === types.content) {
        while (++otherIndex < subevents.length) {
          if (subevents[otherIndex][1].type === types.content) {
            break;
          }
          if (subevents[otherIndex][1].type === types.chunkText) {
            subevents[otherIndex][1]._isInFirstContentOfListItem = true;
            otherIndex++;
          }
        }
      }
    }
    if (event[0] === "enter") {
      if (event[1].contentType) {
        Object.assign(jumps, subcontent(events, index2));
        index2 = jumps[index2];
        more = true;
      }
    } else if (event[1]._container) {
      otherIndex = index2;
      lineIndex = void 0;
      while (otherIndex--) {
        otherEvent = events[otherIndex];
        if (otherEvent[1].type === types.lineEnding || otherEvent[1].type === types.lineEndingBlank) {
          if (otherEvent[0] === "enter") {
            if (lineIndex) {
              events[lineIndex][1].type = types.lineEndingBlank;
            }
            otherEvent[1].type = types.lineEnding;
            lineIndex = otherIndex;
          }
        } else {
          break;
        }
      }
      if (lineIndex) {
        event[1].end = Object.assign({}, events[lineIndex][1].start);
        parameters = events.slice(lineIndex, index2);
        parameters.unshift(event);
        splice(events, lineIndex, index2 - lineIndex + 1, parameters);
      }
    }
  }
  return !more;
}
function subcontent(events, eventIndex) {
  const token = events[eventIndex][1];
  const context = events[eventIndex][2];
  let startPosition = eventIndex - 1;
  const startPositions = [];
  ok(token.contentType, "expected `contentType` on subtokens");
  const tokenizer = token._tokenizer || context.parser[token.contentType](token.start);
  const childEvents = tokenizer.events;
  const jumps = [];
  const gaps = {};
  let stream;
  let previous2;
  let index2 = -1;
  let current = token;
  let adjust = 0;
  let start = 0;
  const breaks = [start];
  while (current) {
    while (events[++startPosition][1] !== current) {
    }
    ok(
      !previous2 || current.previous === previous2,
      "expected previous to match"
    );
    ok(!previous2 || previous2.next === current, "expected next to match");
    startPositions.push(startPosition);
    if (!current._tokenizer) {
      stream = context.sliceStream(current);
      if (!current.next) {
        stream.push(codes.eof);
      }
      if (previous2) {
        tokenizer.defineSkip(current.start);
      }
      if (current._isInFirstContentOfListItem) {
        tokenizer._gfmTasklistFirstContentOfListItem = true;
      }
      tokenizer.write(stream);
      if (current._isInFirstContentOfListItem) {
        tokenizer._gfmTasklistFirstContentOfListItem = void 0;
      }
    }
    previous2 = current;
    current = current.next;
  }
  current = token;
  while (++index2 < childEvents.length) {
    if (
      // Find a void token that includes a break.
      childEvents[index2][0] === "exit" && childEvents[index2 - 1][0] === "enter" && childEvents[index2][1].type === childEvents[index2 - 1][1].type && childEvents[index2][1].start.line !== childEvents[index2][1].end.line
    ) {
      ok(current, "expected a current token");
      start = index2 + 1;
      breaks.push(start);
      current._tokenizer = void 0;
      current.previous = void 0;
      current = current.next;
    }
  }
  tokenizer.events = [];
  if (current) {
    current._tokenizer = void 0;
    current.previous = void 0;
    ok(!current.next, "expected no next token");
  } else {
    breaks.pop();
  }
  index2 = breaks.length;
  while (index2--) {
    const slice = childEvents.slice(breaks[index2], breaks[index2 + 1]);
    const start2 = startPositions.pop();
    ok(start2 !== void 0, "expected a start position when splicing");
    jumps.unshift([start2, start2 + slice.length - 1]);
    splice(events, start2, 2, slice);
  }
  index2 = -1;
  while (++index2 < jumps.length) {
    gaps[adjust + jumps[index2][0]] = adjust + jumps[index2][1];
    adjust += jumps[index2][1] - jumps[index2][0] - 1;
  }
  return gaps;
}
var import_dist139, import_dist140, import_dist141;
var init_dev5 = __esm({
  "node_modules/micromark-util-subtokenize/dev/index.js"() {
    import_dist139 = __toESM(require_dist());
    import_dist140 = __toESM(require_dist2());
    import_dist141 = __toESM(require_dist3());
    init_dev();
    init_codes();
    init_types();
    init_assert();
  }
});

// node_modules/micromark-core-commonmark/dev/lib/content.js
function resolveContent(events) {
  subtokenize(events);
  return events;
}
function tokenizeContent(effects, ok3) {
  let previous2;
  return chunkStart;
  function chunkStart(code2) {
    ok(
      code2 !== codes.eof && !markdownLineEnding(code2),
      "expected no eof or eol"
    );
    effects.enter(types.content);
    previous2 = effects.enter(types.chunkContent, {
      contentType: constants.contentTypeContent
    });
    return chunkInside(code2);
  }
  function chunkInside(code2) {
    if (code2 === codes.eof) {
      return contentEnd(code2);
    }
    if (markdownLineEnding(code2)) {
      return effects.check(
        continuationConstruct,
        contentContinue,
        contentEnd
      )(code2);
    }
    effects.consume(code2);
    return chunkInside;
  }
  function contentEnd(code2) {
    effects.exit(types.chunkContent);
    effects.exit(types.content);
    return ok3(code2);
  }
  function contentContinue(code2) {
    ok(markdownLineEnding(code2), "expected eol");
    effects.consume(code2);
    effects.exit(types.chunkContent);
    ok(previous2, "expected previous token");
    previous2.next = effects.enter(types.chunkContent, {
      contentType: constants.contentTypeContent,
      previous: previous2
    });
    previous2 = previous2.next;
    return chunkInside;
  }
}
function tokenizeContinuation(effects, ok3, nok) {
  const self2 = this;
  return startLookahead;
  function startLookahead(code2) {
    ok(markdownLineEnding(code2), "expected a line ending");
    effects.exit(types.chunkContent);
    effects.enter(types.lineEnding);
    effects.consume(code2);
    effects.exit(types.lineEnding);
    return factorySpace(effects, prefixed, types.linePrefix);
  }
  function prefixed(code2) {
    if (code2 === codes.eof || markdownLineEnding(code2)) {
      return nok(code2);
    }
    ok(
      self2.parser.constructs.disable.null,
      "expected `disable.null` to be populated"
    );
    const tail = self2.events[self2.events.length - 1];
    if (!self2.parser.constructs.disable.null.includes("codeIndented") && tail && tail[1].type === types.linePrefix && tail[2].sliceSerialize(tail[1], true).length >= constants.tabSize) {
      return ok3(code2);
    }
    return effects.interrupt(self2.parser.constructs.flow, nok, ok3)(code2);
  }
}
var import_dist142, import_dist143, import_dist144, content2, continuationConstruct;
var init_content2 = __esm({
  "node_modules/micromark-core-commonmark/dev/lib/content.js"() {
    import_dist142 = __toESM(require_dist(), 1);
    import_dist143 = __toESM(require_dist2(), 1);
    import_dist144 = __toESM(require_dist3(), 1);
    init_dev3();
    init_dev2();
    init_dev5();
    init_codes();
    init_constants();
    init_types();
    init_assert();
    content2 = { tokenize: tokenizeContent, resolve: resolveContent };
    continuationConstruct = { tokenize: tokenizeContinuation, partial: true };
  }
});

// node_modules/micromark-factory-destination/dev/index.js
function factoryDestination(effects, ok3, nok, type, literalType, literalMarkerType, rawType, stringType, max) {
  const limit = max || Number.POSITIVE_INFINITY;
  let balance = 0;
  return start;
  function start(code2) {
    if (code2 === codes.lessThan) {
      effects.enter(type);
      effects.enter(literalType);
      effects.enter(literalMarkerType);
      effects.consume(code2);
      effects.exit(literalMarkerType);
      return enclosedBefore;
    }
    if (code2 === codes.eof || code2 === codes.space || code2 === codes.rightParenthesis || asciiControl(code2)) {
      return nok(code2);
    }
    effects.enter(type);
    effects.enter(rawType);
    effects.enter(stringType);
    effects.enter(types.chunkString, { contentType: constants.contentTypeString });
    return raw(code2);
  }
  function enclosedBefore(code2) {
    if (code2 === codes.greaterThan) {
      effects.enter(literalMarkerType);
      effects.consume(code2);
      effects.exit(literalMarkerType);
      effects.exit(literalType);
      effects.exit(type);
      return ok3;
    }
    effects.enter(stringType);
    effects.enter(types.chunkString, { contentType: constants.contentTypeString });
    return enclosed(code2);
  }
  function enclosed(code2) {
    if (code2 === codes.greaterThan) {
      effects.exit(types.chunkString);
      effects.exit(stringType);
      return enclosedBefore(code2);
    }
    if (code2 === codes.eof || code2 === codes.lessThan || markdownLineEnding(code2)) {
      return nok(code2);
    }
    effects.consume(code2);
    return code2 === codes.backslash ? enclosedEscape : enclosed;
  }
  function enclosedEscape(code2) {
    if (code2 === codes.lessThan || code2 === codes.greaterThan || code2 === codes.backslash) {
      effects.consume(code2);
      return enclosed;
    }
    return enclosed(code2);
  }
  function raw(code2) {
    if (!balance && (code2 === codes.eof || code2 === codes.rightParenthesis || markdownLineEndingOrSpace(code2))) {
      effects.exit(types.chunkString);
      effects.exit(stringType);
      effects.exit(rawType);
      effects.exit(type);
      return ok3(code2);
    }
    if (balance < limit && code2 === codes.leftParenthesis) {
      effects.consume(code2);
      balance++;
      return raw;
    }
    if (code2 === codes.rightParenthesis) {
      effects.consume(code2);
      balance--;
      return raw;
    }
    if (code2 === codes.eof || code2 === codes.space || code2 === codes.leftParenthesis || asciiControl(code2)) {
      return nok(code2);
    }
    effects.consume(code2);
    return code2 === codes.backslash ? rawEscape : raw;
  }
  function rawEscape(code2) {
    if (code2 === codes.leftParenthesis || code2 === codes.rightParenthesis || code2 === codes.backslash) {
      effects.consume(code2);
      return raw;
    }
    return raw(code2);
  }
}
var import_dist145, import_dist146, import_dist147;
var init_dev6 = __esm({
  "node_modules/micromark-factory-destination/dev/index.js"() {
    import_dist145 = __toESM(require_dist());
    import_dist146 = __toESM(require_dist2());
    import_dist147 = __toESM(require_dist3());
    init_dev2();
    init_codes();
    init_constants();
    init_types();
  }
});

// node_modules/micromark-factory-label/dev/index.js
function factoryLabel(effects, ok3, nok, type, markerType, stringType) {
  const self2 = this;
  let size = 0;
  let seen;
  return start;
  function start(code2) {
    ok(code2 === codes.leftSquareBracket, "expected `[`");
    effects.enter(type);
    effects.enter(markerType);
    effects.consume(code2);
    effects.exit(markerType);
    effects.enter(stringType);
    return atBreak;
  }
  function atBreak(code2) {
    if (size > constants.linkReferenceSizeMax || code2 === codes.eof || code2 === codes.leftSquareBracket || code2 === codes.rightSquareBracket && !seen || // To do: remove in the future once weve switched from
    // `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,
    // which doesnt need this.
    // Hidden footnotes hook.
    /* c8 ignore next 3 */
    code2 === codes.caret && !size && "_hiddenFootnoteSupport" in self2.parser.constructs) {
      return nok(code2);
    }
    if (code2 === codes.rightSquareBracket) {
      effects.exit(stringType);
      effects.enter(markerType);
      effects.consume(code2);
      effects.exit(markerType);
      effects.exit(type);
      return ok3;
    }
    if (markdownLineEnding(code2)) {
      effects.enter(types.lineEnding);
      effects.consume(code2);
      effects.exit(types.lineEnding);
      return atBreak;
    }
    effects.enter(types.chunkString, { contentType: constants.contentTypeString });
    return labelInside(code2);
  }
  function labelInside(code2) {
    if (code2 === codes.eof || code2 === codes.leftSquareBracket || code2 === codes.rightSquareBracket || markdownLineEnding(code2) || size++ > constants.linkReferenceSizeMax) {
      effects.exit(types.chunkString);
      return atBreak(code2);
    }
    effects.consume(code2);
    if (!seen) seen = !markdownSpace(code2);
    return code2 === codes.backslash ? labelEscape : labelInside;
  }
  function labelEscape(code2) {
    if (code2 === codes.leftSquareBracket || code2 === codes.backslash || code2 === codes.rightSquareBracket) {
      effects.consume(code2);
      size++;
      return labelInside;
    }
    return labelInside(code2);
  }
}
var import_dist148, import_dist149, import_dist150;
var init_dev7 = __esm({
  "node_modules/micromark-factory-label/dev/index.js"() {
    import_dist148 = __toESM(require_dist());
    import_dist149 = __toESM(require_dist2());
    import_dist150 = __toESM(require_dist3());
    init_dev2();
    init_codes();
    init_constants();
    init_types();
    init_assert();
  }
});

// node_modules/micromark-factory-title/dev/index.js
function factoryTitle(effects, ok3, nok, type, markerType, stringType) {
  let marker;
  return start;
  function start(code2) {
    if (code2 === codes.quotationMark || code2 === codes.apostrophe || code2 === codes.leftParenthesis) {
      effects.enter(type);
      effects.enter(markerType);
      effects.consume(code2);
      effects.exit(markerType);
      marker = code2 === codes.leftParenthesis ? codes.rightParenthesis : code2;
      return begin;
    }
    return nok(code2);
  }
  function begin(code2) {
    if (code2 === marker) {
      effects.enter(markerType);
      effects.consume(code2);
      effects.exit(markerType);
      effects.exit(type);
      return ok3;
    }
    effects.enter(stringType);
    return atBreak(code2);
  }
  function atBreak(code2) {
    if (code2 === marker) {
      effects.exit(stringType);
      return begin(marker);
    }
    if (code2 === codes.eof) {
      return nok(code2);
    }
    if (markdownLineEnding(code2)) {
      effects.enter(types.lineEnding);
      effects.consume(code2);
      effects.exit(types.lineEnding);
      return factorySpace(effects, atBreak, types.linePrefix);
    }
    effects.enter(types.chunkString, { contentType: constants.contentTypeString });
    return inside(code2);
  }
  function inside(code2) {
    if (code2 === marker || code2 === codes.eof || markdownLineEnding(code2)) {
      effects.exit(types.chunkString);
      return atBreak(code2);
    }
    effects.consume(code2);
    return code2 === codes.backslash ? escape : inside;
  }
  function escape(code2) {
    if (code2 === marker || code2 === codes.backslash) {
      effects.consume(code2);
      return inside;
    }
    return inside(code2);
  }
}
var import_dist151, import_dist152, import_dist153;
var init_dev8 = __esm({
  "node_modules/micromark-factory-title/dev/index.js"() {
    import_dist151 = __toESM(require_dist());
    import_dist152 = __toESM(require_dist2());
    import_dist153 = __toESM(require_dist3());
    init_dev3();
    init_dev2();
    init_codes();
    init_constants();
    init_types();
  }
});

// node_modules/micromark-factory-whitespace/dev/index.js
function factoryWhitespace(effects, ok3) {
  let seen;
  return start;
  function start(code2) {
    if (markdownLineEnding(code2)) {
      effects.enter(types.lineEnding);
      effects.consume(code2);
      effects.exit(types.lineEnding);
      seen = true;
      return start;
    }
    if (markdownSpace(code2)) {
      return factorySpace(
        effects,
        start,
        seen ? types.linePrefix : types.lineSuffix
      )(code2);
    }
    return ok3(code2);
  }
}
var import_dist154, import_dist155, import_dist156;
var init_dev9 = __esm({
  "node_modules/micromark-factory-whitespace/dev/index.js"() {
    import_dist154 = __toESM(require_dist());
    import_dist155 = __toESM(require_dist2());
    import_dist156 = __toESM(require_dist3());
    init_dev3();
    init_dev2();
    init_types();
  }
});

// node_modules/micromark-util-symbol/values.js
var import_dist157, import_dist158, import_dist159, values;
var init_values = __esm({
  "node_modules/micromark-util-symbol/values.js"() {
    import_dist157 = __toESM(require_dist());
    import_dist158 = __toESM(require_dist2());
    import_dist159 = __toESM(require_dist3());
    values = /** @type {const} */
    {
      ht: "	",
      lf: "\n",
      cr: "\r",
      space: " ",
      exclamationMark: "!",
      quotationMark: '"',
      numberSign: "#",
      dollarSign: "$",
      percentSign: "%",
      ampersand: "&",
      apostrophe: "'",
      leftParenthesis: "(",
      rightParenthesis: ")",
      asterisk: "*",
      plusSign: "+",
      comma: ",",
      dash: "-",
      dot: ".",
      slash: "/",
      digit0: "0",
      digit1: "1",
      digit2: "2",
      digit3: "3",
      digit4: "4",
      digit5: "5",
      digit6: "6",
      digit7: "7",
      digit8: "8",
      digit9: "9",
      colon: ":",
      semicolon: ";",
      lessThan: "<",
      equalsTo: "=",
      greaterThan: ">",
      questionMark: "?",
      atSign: "@",
      uppercaseA: "A",
      uppercaseB: "B",
      uppercaseC: "C",
      uppercaseD: "D",
      uppercaseE: "E",
      uppercaseF: "F",
      uppercaseG: "G",
      uppercaseH: "H",
      uppercaseI: "I",
      uppercaseJ: "J",
      uppercaseK: "K",
      uppercaseL: "L",
      uppercaseM: "M",
      uppercaseN: "N",
      uppercaseO: "O",
      uppercaseP: "P",
      uppercaseQ: "Q",
      uppercaseR: "R",
      uppercaseS: "S",
      uppercaseT: "T",
      uppercaseU: "U",
      uppercaseV: "V",
      uppercaseW: "W",
      uppercaseX: "X",
      uppercaseY: "Y",
      uppercaseZ: "Z",
      leftSquareBracket: "[",
      backslash: "\\",
      rightSquareBracket: "]",
      caret: "^",
      underscore: "_",
      graveAccent: "`",
      lowercaseA: "a",
      lowercaseB: "b",
      lowercaseC: "c",
      lowercaseD: "d",
      lowercaseE: "e",
      lowercaseF: "f",
      lowercaseG: "g",
      lowercaseH: "h",
      lowercaseI: "i",
      lowercaseJ: "j",
      lowercaseK: "k",
      lowercaseL: "l",
      lowercaseM: "m",
      lowercaseN: "n",
      lowercaseO: "o",
      lowercaseP: "p",
      lowercaseQ: "q",
      lowercaseR: "r",
      lowercaseS: "s",
      lowercaseT: "t",
      lowercaseU: "u",
      lowercaseV: "v",
      lowercaseW: "w",
      lowercaseX: "x",
      lowercaseY: "y",
      lowercaseZ: "z",
      leftCurlyBrace: "{",
      verticalBar: "|",
      rightCurlyBrace: "}",
      tilde: "~",
      replacementCharacter: ""
    };
  }
});

// node_modules/micromark-util-normalize-identifier/dev/index.js
function normalizeIdentifier(value) {
  return value.replace(/[\t\n\r ]+/g, values.space).replace(/^ | $/g, "").toLowerCase().toUpperCase();
}
var import_dist160, import_dist161, import_dist162;
var init_dev10 = __esm({
  "node_modules/micromark-util-normalize-identifier/dev/index.js"() {
    import_dist160 = __toESM(require_dist());
    import_dist161 = __toESM(require_dist2());
    import_dist162 = __toESM(require_dist3());
    init_values();
  }
});

// node_modules/micromark-core-commonmark/dev/lib/definition.js
function tokenizeDefinition(effects, ok3, nok) {
  const self2 = this;
  let identifier;
  return start;
  function start(code2) {
    effects.enter(types.definition);
    return before(code2);
  }
  function before(code2) {
    ok(code2 === codes.leftSquareBracket, "expected `[`");
    return factoryLabel.call(
      self2,
      effects,
      labelAfter,
      // Note: we dont need to reset the way `markdown-rs` does.
      nok,
      types.definitionLabel,
      types.definitionLabelMarker,
      types.definitionLabelString
    )(code2);
  }
  function labelAfter(code2) {
    identifier = normalizeIdentifier(
      self2.sliceSerialize(self2.events[self2.events.length - 1][1]).slice(1, -1)
    );
    if (code2 === codes.colon) {
      effects.enter(types.definitionMarker);
      effects.consume(code2);
      effects.exit(types.definitionMarker);
      return markerAfter;
    }
    return nok(code2);
  }
  function markerAfter(code2) {
    return markdownLineEndingOrSpace(code2) ? factoryWhitespace(effects, destinationBefore)(code2) : destinationBefore(code2);
  }
  function destinationBefore(code2) {
    return factoryDestination(
      effects,
      destinationAfter,
      // Note: we dont need to reset the way `markdown-rs` does.
      nok,
      types.definitionDestination,
      types.definitionDestinationLiteral,
      types.definitionDestinationLiteralMarker,
      types.definitionDestinationRaw,
      types.definitionDestinationString
    )(code2);
  }
  function destinationAfter(code2) {
    return effects.attempt(titleBefore, after, after)(code2);
  }
  function after(code2) {
    return markdownSpace(code2) ? factorySpace(effects, afterWhitespace, types.whitespace)(code2) : afterWhitespace(code2);
  }
  function afterWhitespace(code2) {
    if (code2 === codes.eof || markdownLineEnding(code2)) {
      effects.exit(types.definition);
      self2.parser.defined.push(identifier);
      return ok3(code2);
    }
    return nok(code2);
  }
}
function tokenizeTitleBefore(effects, ok3, nok) {
  return titleBefore2;
  function titleBefore2(code2) {
    return markdownLineEndingOrSpace(code2) ? factoryWhitespace(effects, beforeMarker)(code2) : nok(code2);
  }
  function beforeMarker(code2) {
    return factoryTitle(
      effects,
      titleAfter,
      nok,
      types.definitionTitle,
      types.definitionTitleMarker,
      types.definitionTitleString
    )(code2);
  }
  function titleAfter(code2) {
    return markdownSpace(code2) ? factorySpace(
      effects,
      titleAfterOptionalWhitespace,
      types.whitespace
    )(code2) : titleAfterOptionalWhitespace(code2);
  }
  function titleAfterOptionalWhitespace(code2) {
    return code2 === codes.eof || markdownLineEnding(code2) ? ok3(code2) : nok(code2);
  }
}
var import_dist163, import_dist164, import_dist165, definition, titleBefore;
var init_definition = __esm({
  "node_modules/micromark-core-commonmark/dev/lib/definition.js"() {
    import_dist163 = __toESM(require_dist(), 1);
    import_dist164 = __toESM(require_dist2(), 1);
    import_dist165 = __toESM(require_dist3(), 1);
    init_dev6();
    init_dev7();
    init_dev3();
    init_dev8();
    init_dev9();
    init_dev2();
    init_dev10();
    init_codes();
    init_types();
    init_assert();
    definition = { name: "definition", tokenize: tokenizeDefinition };
    titleBefore = { tokenize: tokenizeTitleBefore, partial: true };
  }
});

// node_modules/micromark-core-commonmark/dev/lib/hard-break-escape.js
function tokenizeHardBreakEscape(effects, ok3, nok) {
  return start;
  function start(code2) {
    ok(code2 === codes.backslash, "expected `\\`");
    effects.enter(types.hardBreakEscape);
    effects.consume(code2);
    return after;
  }
  function after(code2) {
    if (markdownLineEnding(code2)) {
      effects.exit(types.hardBreakEscape);
      return ok3(code2);
    }
    return nok(code2);
  }
}
var import_dist166, import_dist167, import_dist168, hardBreakEscape;
var init_hard_break_escape = __esm({
  "node_modules/micromark-core-commonmark/dev/lib/hard-break-escape.js"() {
    import_dist166 = __toESM(require_dist(), 1);
    import_dist167 = __toESM(require_dist2(), 1);
    import_dist168 = __toESM(require_dist3(), 1);
    init_dev2();
    init_codes();
    init_types();
    init_assert();
    hardBreakEscape = {
      name: "hardBreakEscape",
      tokenize: tokenizeHardBreakEscape
    };
  }
});

// node_modules/micromark-core-commonmark/dev/lib/heading-atx.js
function resolveHeadingAtx(events, context) {
  let contentEnd = events.length - 2;
  let contentStart = 3;
  let content3;
  let text4;
  if (events[contentStart][1].type === types.whitespace) {
    contentStart += 2;
  }
  if (contentEnd - 2 > contentStart && events[contentEnd][1].type === types.whitespace) {
    contentEnd -= 2;
  }
  if (events[contentEnd][1].type === types.atxHeadingSequence && (contentStart === contentEnd - 1 || contentEnd - 4 > contentStart && events[contentEnd - 2][1].type === types.whitespace)) {
    contentEnd -= contentStart + 1 === contentEnd ? 2 : 4;
  }
  if (contentEnd > contentStart) {
    content3 = {
      type: types.atxHeadingText,
      start: events[contentStart][1].start,
      end: events[contentEnd][1].end
    };
    text4 = {
      type: types.chunkText,
      start: events[contentStart][1].start,
      end: events[contentEnd][1].end,
      contentType: constants.contentTypeText
    };
    splice(events, contentStart, contentEnd - contentStart + 1, [
      ["enter", content3, context],
      ["enter", text4, context],
      ["exit", text4, context],
      ["exit", content3, context]
    ]);
  }
  return events;
}
function tokenizeHeadingAtx(effects, ok3, nok) {
  let size = 0;
  return start;
  function start(code2) {
    effects.enter(types.atxHeading);
    return before(code2);
  }
  function before(code2) {
    ok(code2 === codes.numberSign, "expected `#`");
    effects.enter(types.atxHeadingSequence);
    return sequenceOpen(code2);
  }
  function sequenceOpen(code2) {
    if (code2 === codes.numberSign && size++ < constants.atxHeadingOpeningFenceSizeMax) {
      effects.consume(code2);
      return sequenceOpen;
    }
    if (code2 === codes.eof || markdownLineEndingOrSpace(code2)) {
      effects.exit(types.atxHeadingSequence);
      return atBreak(code2);
    }
    return nok(code2);
  }
  function atBreak(code2) {
    if (code2 === codes.numberSign) {
      effects.enter(types.atxHeadingSequence);
      return sequenceFurther(code2);
    }
    if (code2 === codes.eof || markdownLineEnding(code2)) {
      effects.exit(types.atxHeading);
      return ok3(code2);
    }
    if (markdownSpace(code2)) {
      return factorySpace(effects, atBreak, types.whitespace)(code2);
    }
    effects.enter(types.atxHeadingText);
    return data(code2);
  }
  function sequenceFurther(code2) {
    if (code2 === codes.numberSign) {
      effects.consume(code2);
      return sequenceFurther;
    }
    effects.exit(types.atxHeadingSequence);
    return atBreak(code2);
  }
  function data(code2) {
    if (code2 === codes.eof || code2 === codes.numberSign || markdownLineEndingOrSpace(code2)) {
      effects.exit(types.atxHeadingText);
      return atBreak(code2);
    }
    effects.consume(code2);
    return data;
  }
}
var import_dist169, import_dist170, import_dist171, headingAtx;
var init_heading_atx = __esm({
  "node_modules/micromark-core-commonmark/dev/lib/heading-atx.js"() {
    import_dist169 = __toESM(require_dist(), 1);
    import_dist170 = __toESM(require_dist2(), 1);
    import_dist171 = __toESM(require_dist3(), 1);
    init_dev3();
    init_dev2();
    init_dev();
    init_codes();
    init_constants();
    init_types();
    init_assert();
    headingAtx = {
      name: "headingAtx",
      tokenize: tokenizeHeadingAtx,
      resolve: resolveHeadingAtx
    };
  }
});

// node_modules/micromark-util-html-tag-name/index.js
var import_dist172, import_dist173, import_dist174, htmlBlockNames, htmlRawNames;
var init_micromark_util_html_tag_name = __esm({
  "node_modules/micromark-util-html-tag-name/index.js"() {
    import_dist172 = __toESM(require_dist());
    import_dist173 = __toESM(require_dist2());
    import_dist174 = __toESM(require_dist3());
    htmlBlockNames = [
      "address",
      "article",
      "aside",
      "base",
      "basefont",
      "blockquote",
      "body",
      "caption",
      "center",
      "col",
      "colgroup",
      "dd",
      "details",
      "dialog",
      "dir",
      "div",
      "dl",
      "dt",
      "fieldset",
      "figcaption",
      "figure",
      "footer",
      "form",
      "frame",
      "frameset",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "head",
      "header",
      "hr",
      "html",
      "iframe",
      "legend",
      "li",
      "link",
      "main",
      "menu",
      "menuitem",
      "nav",
      "noframes",
      "ol",
      "optgroup",
      "option",
      "p",
      "param",
      "search",
      "section",
      "summary",
      "table",
      "tbody",
      "td",
      "tfoot",
      "th",
      "thead",
      "title",
      "tr",
      "track",
      "ul"
    ];
    htmlRawNames = ["pre", "script", "style", "textarea"];
  }
});

// node_modules/micromark-core-commonmark/dev/lib/html-flow.js
function resolveToHtmlFlow(events) {
  let index2 = events.length;
  while (index2--) {
    if (events[index2][0] === "enter" && events[index2][1].type === types.htmlFlow) {
      break;
    }
  }
  if (index2 > 1 && events[index2 - 2][1].type === types.linePrefix) {
    events[index2][1].start = events[index2 - 2][1].start;
    events[index2 + 1][1].start = events[index2 - 2][1].start;
    events.splice(index2 - 2, 2);
  }
  return events;
}
function tokenizeHtmlFlow(effects, ok3, nok) {
  const self2 = this;
  let marker;
  let closingTag;
  let buffer2;
  let index2;
  let markerB;
  return start;
  function start(code2) {
    return before(code2);
  }
  function before(code2) {
    ok(code2 === codes.lessThan, "expected `<`");
    effects.enter(types.htmlFlow);
    effects.enter(types.htmlFlowData);
    effects.consume(code2);
    return open;
  }
  function open(code2) {
    if (code2 === codes.exclamationMark) {
      effects.consume(code2);
      return declarationOpen;
    }
    if (code2 === codes.slash) {
      effects.consume(code2);
      closingTag = true;
      return tagCloseStart;
    }
    if (code2 === codes.questionMark) {
      effects.consume(code2);
      marker = constants.htmlInstruction;
      return self2.interrupt ? ok3 : continuationDeclarationInside;
    }
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      buffer2 = String.fromCharCode(code2);
      return tagName;
    }
    return nok(code2);
  }
  function declarationOpen(code2) {
    if (code2 === codes.dash) {
      effects.consume(code2);
      marker = constants.htmlComment;
      return commentOpenInside;
    }
    if (code2 === codes.leftSquareBracket) {
      effects.consume(code2);
      marker = constants.htmlCdata;
      index2 = 0;
      return cdataOpenInside;
    }
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      marker = constants.htmlDeclaration;
      return self2.interrupt ? ok3 : continuationDeclarationInside;
    }
    return nok(code2);
  }
  function commentOpenInside(code2) {
    if (code2 === codes.dash) {
      effects.consume(code2);
      return self2.interrupt ? ok3 : continuationDeclarationInside;
    }
    return nok(code2);
  }
  function cdataOpenInside(code2) {
    const value = constants.cdataOpeningString;
    if (code2 === value.charCodeAt(index2++)) {
      effects.consume(code2);
      if (index2 === value.length) {
        return self2.interrupt ? ok3 : continuation;
      }
      return cdataOpenInside;
    }
    return nok(code2);
  }
  function tagCloseStart(code2) {
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      buffer2 = String.fromCharCode(code2);
      return tagName;
    }
    return nok(code2);
  }
  function tagName(code2) {
    if (code2 === codes.eof || code2 === codes.slash || code2 === codes.greaterThan || markdownLineEndingOrSpace(code2)) {
      const slash = code2 === codes.slash;
      const name = buffer2.toLowerCase();
      if (!slash && !closingTag && htmlRawNames.includes(name)) {
        marker = constants.htmlRaw;
        return self2.interrupt ? ok3(code2) : continuation(code2);
      }
      if (htmlBlockNames.includes(buffer2.toLowerCase())) {
        marker = constants.htmlBasic;
        if (slash) {
          effects.consume(code2);
          return basicSelfClosing;
        }
        return self2.interrupt ? ok3(code2) : continuation(code2);
      }
      marker = constants.htmlComplete;
      return self2.interrupt && !self2.parser.lazy[self2.now().line] ? nok(code2) : closingTag ? completeClosingTagAfter(code2) : completeAttributeNameBefore(code2);
    }
    if (code2 === codes.dash || asciiAlphanumeric(code2)) {
      effects.consume(code2);
      buffer2 += String.fromCharCode(code2);
      return tagName;
    }
    return nok(code2);
  }
  function basicSelfClosing(code2) {
    if (code2 === codes.greaterThan) {
      effects.consume(code2);
      return self2.interrupt ? ok3 : continuation;
    }
    return nok(code2);
  }
  function completeClosingTagAfter(code2) {
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return completeClosingTagAfter;
    }
    return completeEnd(code2);
  }
  function completeAttributeNameBefore(code2) {
    if (code2 === codes.slash) {
      effects.consume(code2);
      return completeEnd;
    }
    if (code2 === codes.colon || code2 === codes.underscore || asciiAlpha(code2)) {
      effects.consume(code2);
      return completeAttributeName;
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return completeAttributeNameBefore;
    }
    return completeEnd(code2);
  }
  function completeAttributeName(code2) {
    if (code2 === codes.dash || code2 === codes.dot || code2 === codes.colon || code2 === codes.underscore || asciiAlphanumeric(code2)) {
      effects.consume(code2);
      return completeAttributeName;
    }
    return completeAttributeNameAfter(code2);
  }
  function completeAttributeNameAfter(code2) {
    if (code2 === codes.equalsTo) {
      effects.consume(code2);
      return completeAttributeValueBefore;
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return completeAttributeNameAfter;
    }
    return completeAttributeNameBefore(code2);
  }
  function completeAttributeValueBefore(code2) {
    if (code2 === codes.eof || code2 === codes.lessThan || code2 === codes.equalsTo || code2 === codes.greaterThan || code2 === codes.graveAccent) {
      return nok(code2);
    }
    if (code2 === codes.quotationMark || code2 === codes.apostrophe) {
      effects.consume(code2);
      markerB = code2;
      return completeAttributeValueQuoted;
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return completeAttributeValueBefore;
    }
    return completeAttributeValueUnquoted(code2);
  }
  function completeAttributeValueQuoted(code2) {
    if (code2 === markerB) {
      effects.consume(code2);
      markerB = null;
      return completeAttributeValueQuotedAfter;
    }
    if (code2 === codes.eof || markdownLineEnding(code2)) {
      return nok(code2);
    }
    effects.consume(code2);
    return completeAttributeValueQuoted;
  }
  function completeAttributeValueUnquoted(code2) {
    if (code2 === codes.eof || code2 === codes.quotationMark || code2 === codes.apostrophe || code2 === codes.slash || code2 === codes.lessThan || code2 === codes.equalsTo || code2 === codes.greaterThan || code2 === codes.graveAccent || markdownLineEndingOrSpace(code2)) {
      return completeAttributeNameAfter(code2);
    }
    effects.consume(code2);
    return completeAttributeValueUnquoted;
  }
  function completeAttributeValueQuotedAfter(code2) {
    if (code2 === codes.slash || code2 === codes.greaterThan || markdownSpace(code2)) {
      return completeAttributeNameBefore(code2);
    }
    return nok(code2);
  }
  function completeEnd(code2) {
    if (code2 === codes.greaterThan) {
      effects.consume(code2);
      return completeAfter;
    }
    return nok(code2);
  }
  function completeAfter(code2) {
    if (code2 === codes.eof || markdownLineEnding(code2)) {
      return continuation(code2);
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return completeAfter;
    }
    return nok(code2);
  }
  function continuation(code2) {
    if (code2 === codes.dash && marker === constants.htmlComment) {
      effects.consume(code2);
      return continuationCommentInside;
    }
    if (code2 === codes.lessThan && marker === constants.htmlRaw) {
      effects.consume(code2);
      return continuationRawTagOpen;
    }
    if (code2 === codes.greaterThan && marker === constants.htmlDeclaration) {
      effects.consume(code2);
      return continuationClose;
    }
    if (code2 === codes.questionMark && marker === constants.htmlInstruction) {
      effects.consume(code2);
      return continuationDeclarationInside;
    }
    if (code2 === codes.rightSquareBracket && marker === constants.htmlCdata) {
      effects.consume(code2);
      return continuationCdataInside;
    }
    if (markdownLineEnding(code2) && (marker === constants.htmlBasic || marker === constants.htmlComplete)) {
      effects.exit(types.htmlFlowData);
      return effects.check(
        blankLineBefore,
        continuationAfter,
        continuationStart
      )(code2);
    }
    if (code2 === codes.eof || markdownLineEnding(code2)) {
      effects.exit(types.htmlFlowData);
      return continuationStart(code2);
    }
    effects.consume(code2);
    return continuation;
  }
  function continuationStart(code2) {
    return effects.check(
      nonLazyContinuationStart,
      continuationStartNonLazy,
      continuationAfter
    )(code2);
  }
  function continuationStartNonLazy(code2) {
    ok(markdownLineEnding(code2));
    effects.enter(types.lineEnding);
    effects.consume(code2);
    effects.exit(types.lineEnding);
    return continuationBefore;
  }
  function continuationBefore(code2) {
    if (code2 === codes.eof || markdownLineEnding(code2)) {
      return continuationStart(code2);
    }
    effects.enter(types.htmlFlowData);
    return continuation(code2);
  }
  function continuationCommentInside(code2) {
    if (code2 === codes.dash) {
      effects.consume(code2);
      return continuationDeclarationInside;
    }
    return continuation(code2);
  }
  function continuationRawTagOpen(code2) {
    if (code2 === codes.slash) {
      effects.consume(code2);
      buffer2 = "";
      return continuationRawEndTag;
    }
    return continuation(code2);
  }
  function continuationRawEndTag(code2) {
    if (code2 === codes.greaterThan) {
      const name = buffer2.toLowerCase();
      if (htmlRawNames.includes(name)) {
        effects.consume(code2);
        return continuationClose;
      }
      return continuation(code2);
    }
    if (asciiAlpha(code2) && buffer2.length < constants.htmlRawSizeMax) {
      effects.consume(code2);
      buffer2 += String.fromCharCode(code2);
      return continuationRawEndTag;
    }
    return continuation(code2);
  }
  function continuationCdataInside(code2) {
    if (code2 === codes.rightSquareBracket) {
      effects.consume(code2);
      return continuationDeclarationInside;
    }
    return continuation(code2);
  }
  function continuationDeclarationInside(code2) {
    if (code2 === codes.greaterThan) {
      effects.consume(code2);
      return continuationClose;
    }
    if (code2 === codes.dash && marker === constants.htmlComment) {
      effects.consume(code2);
      return continuationDeclarationInside;
    }
    return continuation(code2);
  }
  function continuationClose(code2) {
    if (code2 === codes.eof || markdownLineEnding(code2)) {
      effects.exit(types.htmlFlowData);
      return continuationAfter(code2);
    }
    effects.consume(code2);
    return continuationClose;
  }
  function continuationAfter(code2) {
    effects.exit(types.htmlFlow);
    return ok3(code2);
  }
}
function tokenizeNonLazyContinuationStart(effects, ok3, nok) {
  const self2 = this;
  return start;
  function start(code2) {
    if (markdownLineEnding(code2)) {
      effects.enter(types.lineEnding);
      effects.consume(code2);
      effects.exit(types.lineEnding);
      return after;
    }
    return nok(code2);
  }
  function after(code2) {
    return self2.parser.lazy[self2.now().line] ? nok(code2) : ok3(code2);
  }
}
function tokenizeBlankLineBefore(effects, ok3, nok) {
  return start;
  function start(code2) {
    ok(markdownLineEnding(code2), "expected a line ending");
    effects.enter(types.lineEnding);
    effects.consume(code2);
    effects.exit(types.lineEnding);
    return effects.attempt(blankLine, ok3, nok);
  }
}
var import_dist175, import_dist176, import_dist177, htmlFlow, blankLineBefore, nonLazyContinuationStart;
var init_html_flow = __esm({
  "node_modules/micromark-core-commonmark/dev/lib/html-flow.js"() {
    import_dist175 = __toESM(require_dist(), 1);
    import_dist176 = __toESM(require_dist2(), 1);
    import_dist177 = __toESM(require_dist3(), 1);
    init_dev2();
    init_micromark_util_html_tag_name();
    init_codes();
    init_constants();
    init_types();
    init_assert();
    init_blank_line();
    htmlFlow = {
      name: "htmlFlow",
      tokenize: tokenizeHtmlFlow,
      resolveTo: resolveToHtmlFlow,
      concrete: true
    };
    blankLineBefore = { tokenize: tokenizeBlankLineBefore, partial: true };
    nonLazyContinuationStart = {
      tokenize: tokenizeNonLazyContinuationStart,
      partial: true
    };
  }
});

// node_modules/micromark-core-commonmark/dev/lib/html-text.js
function tokenizeHtmlText(effects, ok3, nok) {
  const self2 = this;
  let marker;
  let index2;
  let returnState;
  return start;
  function start(code2) {
    ok(code2 === codes.lessThan, "expected `<`");
    effects.enter(types.htmlText);
    effects.enter(types.htmlTextData);
    effects.consume(code2);
    return open;
  }
  function open(code2) {
    if (code2 === codes.exclamationMark) {
      effects.consume(code2);
      return declarationOpen;
    }
    if (code2 === codes.slash) {
      effects.consume(code2);
      return tagCloseStart;
    }
    if (code2 === codes.questionMark) {
      effects.consume(code2);
      return instruction;
    }
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      return tagOpen;
    }
    return nok(code2);
  }
  function declarationOpen(code2) {
    if (code2 === codes.dash) {
      effects.consume(code2);
      return commentOpenInside;
    }
    if (code2 === codes.leftSquareBracket) {
      effects.consume(code2);
      index2 = 0;
      return cdataOpenInside;
    }
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      return declaration;
    }
    return nok(code2);
  }
  function commentOpenInside(code2) {
    if (code2 === codes.dash) {
      effects.consume(code2);
      return commentEnd;
    }
    return nok(code2);
  }
  function comment(code2) {
    if (code2 === codes.eof) {
      return nok(code2);
    }
    if (code2 === codes.dash) {
      effects.consume(code2);
      return commentClose;
    }
    if (markdownLineEnding(code2)) {
      returnState = comment;
      return lineEndingBefore(code2);
    }
    effects.consume(code2);
    return comment;
  }
  function commentClose(code2) {
    if (code2 === codes.dash) {
      effects.consume(code2);
      return commentEnd;
    }
    return comment(code2);
  }
  function commentEnd(code2) {
    return code2 === codes.greaterThan ? end(code2) : code2 === codes.dash ? commentClose(code2) : comment(code2);
  }
  function cdataOpenInside(code2) {
    const value = constants.cdataOpeningString;
    if (code2 === value.charCodeAt(index2++)) {
      effects.consume(code2);
      return index2 === value.length ? cdata : cdataOpenInside;
    }
    return nok(code2);
  }
  function cdata(code2) {
    if (code2 === codes.eof) {
      return nok(code2);
    }
    if (code2 === codes.rightSquareBracket) {
      effects.consume(code2);
      return cdataClose;
    }
    if (markdownLineEnding(code2)) {
      returnState = cdata;
      return lineEndingBefore(code2);
    }
    effects.consume(code2);
    return cdata;
  }
  function cdataClose(code2) {
    if (code2 === codes.rightSquareBracket) {
      effects.consume(code2);
      return cdataEnd;
    }
    return cdata(code2);
  }
  function cdataEnd(code2) {
    if (code2 === codes.greaterThan) {
      return end(code2);
    }
    if (code2 === codes.rightSquareBracket) {
      effects.consume(code2);
      return cdataEnd;
    }
    return cdata(code2);
  }
  function declaration(code2) {
    if (code2 === codes.eof || code2 === codes.greaterThan) {
      return end(code2);
    }
    if (markdownLineEnding(code2)) {
      returnState = declaration;
      return lineEndingBefore(code2);
    }
    effects.consume(code2);
    return declaration;
  }
  function instruction(code2) {
    if (code2 === codes.eof) {
      return nok(code2);
    }
    if (code2 === codes.questionMark) {
      effects.consume(code2);
      return instructionClose;
    }
    if (markdownLineEnding(code2)) {
      returnState = instruction;
      return lineEndingBefore(code2);
    }
    effects.consume(code2);
    return instruction;
  }
  function instructionClose(code2) {
    return code2 === codes.greaterThan ? end(code2) : instruction(code2);
  }
  function tagCloseStart(code2) {
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      return tagClose;
    }
    return nok(code2);
  }
  function tagClose(code2) {
    if (code2 === codes.dash || asciiAlphanumeric(code2)) {
      effects.consume(code2);
      return tagClose;
    }
    return tagCloseBetween(code2);
  }
  function tagCloseBetween(code2) {
    if (markdownLineEnding(code2)) {
      returnState = tagCloseBetween;
      return lineEndingBefore(code2);
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return tagCloseBetween;
    }
    return end(code2);
  }
  function tagOpen(code2) {
    if (code2 === codes.dash || asciiAlphanumeric(code2)) {
      effects.consume(code2);
      return tagOpen;
    }
    if (code2 === codes.slash || code2 === codes.greaterThan || markdownLineEndingOrSpace(code2)) {
      return tagOpenBetween(code2);
    }
    return nok(code2);
  }
  function tagOpenBetween(code2) {
    if (code2 === codes.slash) {
      effects.consume(code2);
      return end;
    }
    if (code2 === codes.colon || code2 === codes.underscore || asciiAlpha(code2)) {
      effects.consume(code2);
      return tagOpenAttributeName;
    }
    if (markdownLineEnding(code2)) {
      returnState = tagOpenBetween;
      return lineEndingBefore(code2);
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return tagOpenBetween;
    }
    return end(code2);
  }
  function tagOpenAttributeName(code2) {
    if (code2 === codes.dash || code2 === codes.dot || code2 === codes.colon || code2 === codes.underscore || asciiAlphanumeric(code2)) {
      effects.consume(code2);
      return tagOpenAttributeName;
    }
    return tagOpenAttributeNameAfter(code2);
  }
  function tagOpenAttributeNameAfter(code2) {
    if (code2 === codes.equalsTo) {
      effects.consume(code2);
      return tagOpenAttributeValueBefore;
    }
    if (markdownLineEnding(code2)) {
      returnState = tagOpenAttributeNameAfter;
      return lineEndingBefore(code2);
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return tagOpenAttributeNameAfter;
    }
    return tagOpenBetween(code2);
  }
  function tagOpenAttributeValueBefore(code2) {
    if (code2 === codes.eof || code2 === codes.lessThan || code2 === codes.equalsTo || code2 === codes.greaterThan || code2 === codes.graveAccent) {
      return nok(code2);
    }
    if (code2 === codes.quotationMark || code2 === codes.apostrophe) {
      effects.consume(code2);
      marker = code2;
      return tagOpenAttributeValueQuoted;
    }
    if (markdownLineEnding(code2)) {
      returnState = tagOpenAttributeValueBefore;
      return lineEndingBefore(code2);
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return tagOpenAttributeValueBefore;
    }
    effects.consume(code2);
    return tagOpenAttributeValueUnquoted;
  }
  function tagOpenAttributeValueQuoted(code2) {
    if (code2 === marker) {
      effects.consume(code2);
      marker = void 0;
      return tagOpenAttributeValueQuotedAfter;
    }
    if (code2 === codes.eof) {
      return nok(code2);
    }
    if (markdownLineEnding(code2)) {
      returnState = tagOpenAttributeValueQuoted;
      return lineEndingBefore(code2);
    }
    effects.consume(code2);
    return tagOpenAttributeValueQuoted;
  }
  function tagOpenAttributeValueUnquoted(code2) {
    if (code2 === codes.eof || code2 === codes.quotationMark || code2 === codes.apostrophe || code2 === codes.lessThan || code2 === codes.equalsTo || code2 === codes.graveAccent) {
      return nok(code2);
    }
    if (code2 === codes.slash || code2 === codes.greaterThan || markdownLineEndingOrSpace(code2)) {
      return tagOpenBetween(code2);
    }
    effects.consume(code2);
    return tagOpenAttributeValueUnquoted;
  }
  function tagOpenAttributeValueQuotedAfter(code2) {
    if (code2 === codes.slash || code2 === codes.greaterThan || markdownLineEndingOrSpace(code2)) {
      return tagOpenBetween(code2);
    }
    return nok(code2);
  }
  function end(code2) {
    if (code2 === codes.greaterThan) {
      effects.consume(code2);
      effects.exit(types.htmlTextData);
      effects.exit(types.htmlText);
      return ok3;
    }
    return nok(code2);
  }
  function lineEndingBefore(code2) {
    ok(returnState, "expected return state");
    ok(markdownLineEnding(code2), "expected eol");
    effects.exit(types.htmlTextData);
    effects.enter(types.lineEnding);
    effects.consume(code2);
    effects.exit(types.lineEnding);
    return lineEndingAfter;
  }
  function lineEndingAfter(code2) {
    ok(
      self2.parser.constructs.disable.null,
      "expected `disable.null` to be populated"
    );
    return markdownSpace(code2) ? factorySpace(
      effects,
      lineEndingAfterPrefix,
      types.linePrefix,
      self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : constants.tabSize
    )(code2) : lineEndingAfterPrefix(code2);
  }
  function lineEndingAfterPrefix(code2) {
    effects.enter(types.htmlTextData);
    return returnState(code2);
  }
}
var import_dist178, import_dist179, import_dist180, htmlText;
var init_html_text = __esm({
  "node_modules/micromark-core-commonmark/dev/lib/html-text.js"() {
    import_dist178 = __toESM(require_dist(), 1);
    import_dist179 = __toESM(require_dist2(), 1);
    import_dist180 = __toESM(require_dist3(), 1);
    init_dev3();
    init_dev2();
    init_codes();
    init_constants();
    init_types();
    init_assert();
    htmlText = { name: "htmlText", tokenize: tokenizeHtmlText };
  }
});

// node_modules/micromark-core-commonmark/dev/lib/label-end.js
function resolveAllLabelEnd(events) {
  let index2 = -1;
  while (++index2 < events.length) {
    const token = events[index2][1];
    if (token.type === types.labelImage || token.type === types.labelLink || token.type === types.labelEnd) {
      events.splice(index2 + 1, token.type === types.labelImage ? 4 : 2);
      token.type = types.data;
      index2++;
    }
  }
  return events;
}
function resolveToLabelEnd(events, context) {
  let index2 = events.length;
  let offset = 0;
  let token;
  let open;
  let close;
  let media;
  while (index2--) {
    token = events[index2][1];
    if (open) {
      if (token.type === types.link || token.type === types.labelLink && token._inactive) {
        break;
      }
      if (events[index2][0] === "enter" && token.type === types.labelLink) {
        token._inactive = true;
      }
    } else if (close) {
      if (events[index2][0] === "enter" && (token.type === types.labelImage || token.type === types.labelLink) && !token._balanced) {
        open = index2;
        if (token.type !== types.labelLink) {
          offset = 2;
          break;
        }
      }
    } else if (token.type === types.labelEnd) {
      close = index2;
    }
  }
  ok(open !== void 0, "`open` is supposed to be found");
  ok(close !== void 0, "`close` is supposed to be found");
  const group = {
    type: events[open][1].type === types.labelLink ? types.link : types.image,
    start: Object.assign({}, events[open][1].start),
    end: Object.assign({}, events[events.length - 1][1].end)
  };
  const label = {
    type: types.label,
    start: Object.assign({}, events[open][1].start),
    end: Object.assign({}, events[close][1].end)
  };
  const text4 = {
    type: types.labelText,
    start: Object.assign({}, events[open + offset + 2][1].end),
    end: Object.assign({}, events[close - 2][1].start)
  };
  media = [
    ["enter", group, context],
    ["enter", label, context]
  ];
  media = push(media, events.slice(open + 1, open + offset + 3));
  media = push(media, [["enter", text4, context]]);
  ok(
    context.parser.constructs.insideSpan.null,
    "expected `insideSpan.null` to be populated"
  );
  media = push(
    media,
    resolveAll(
      context.parser.constructs.insideSpan.null,
      events.slice(open + offset + 4, close - 3),
      context
    )
  );
  media = push(media, [
    ["exit", text4, context],
    events[close - 2],
    events[close - 1],
    ["exit", label, context]
  ]);
  media = push(media, events.slice(close + 1));
  media = push(media, [["exit", group, context]]);
  splice(events, open, events.length, media);
  return events;
}
function tokenizeLabelEnd(effects, ok3, nok) {
  const self2 = this;
  let index2 = self2.events.length;
  let labelStart;
  let defined;
  while (index2--) {
    if ((self2.events[index2][1].type === types.labelImage || self2.events[index2][1].type === types.labelLink) && !self2.events[index2][1]._balanced) {
      labelStart = self2.events[index2][1];
      break;
    }
  }
  return start;
  function start(code2) {
    ok(code2 === codes.rightSquareBracket, "expected `]`");
    if (!labelStart) {
      return nok(code2);
    }
    if (labelStart._inactive) {
      return labelEndNok(code2);
    }
    defined = self2.parser.defined.includes(
      normalizeIdentifier(
        self2.sliceSerialize({ start: labelStart.end, end: self2.now() })
      )
    );
    effects.enter(types.labelEnd);
    effects.enter(types.labelMarker);
    effects.consume(code2);
    effects.exit(types.labelMarker);
    effects.exit(types.labelEnd);
    return after;
  }
  function after(code2) {
    if (code2 === codes.leftParenthesis) {
      return effects.attempt(
        resourceConstruct,
        labelEndOk,
        defined ? labelEndOk : labelEndNok
      )(code2);
    }
    if (code2 === codes.leftSquareBracket) {
      return effects.attempt(
        referenceFullConstruct,
        labelEndOk,
        defined ? referenceNotFull : labelEndNok
      )(code2);
    }
    return defined ? labelEndOk(code2) : labelEndNok(code2);
  }
  function referenceNotFull(code2) {
    return effects.attempt(
      referenceCollapsedConstruct,
      labelEndOk,
      labelEndNok
    )(code2);
  }
  function labelEndOk(code2) {
    return ok3(code2);
  }
  function labelEndNok(code2) {
    labelStart._balanced = true;
    return nok(code2);
  }
}
function tokenizeResource(effects, ok3, nok) {
  return resourceStart;
  function resourceStart(code2) {
    ok(code2 === codes.leftParenthesis, "expected left paren");
    effects.enter(types.resource);
    effects.enter(types.resourceMarker);
    effects.consume(code2);
    effects.exit(types.resourceMarker);
    return resourceBefore;
  }
  function resourceBefore(code2) {
    return markdownLineEndingOrSpace(code2) ? factoryWhitespace(effects, resourceOpen)(code2) : resourceOpen(code2);
  }
  function resourceOpen(code2) {
    if (code2 === codes.rightParenthesis) {
      return resourceEnd(code2);
    }
    return factoryDestination(
      effects,
      resourceDestinationAfter,
      resourceDestinationMissing,
      types.resourceDestination,
      types.resourceDestinationLiteral,
      types.resourceDestinationLiteralMarker,
      types.resourceDestinationRaw,
      types.resourceDestinationString,
      constants.linkResourceDestinationBalanceMax
    )(code2);
  }
  function resourceDestinationAfter(code2) {
    return markdownLineEndingOrSpace(code2) ? factoryWhitespace(effects, resourceBetween)(code2) : resourceEnd(code2);
  }
  function resourceDestinationMissing(code2) {
    return nok(code2);
  }
  function resourceBetween(code2) {
    if (code2 === codes.quotationMark || code2 === codes.apostrophe || code2 === codes.leftParenthesis) {
      return factoryTitle(
        effects,
        resourceTitleAfter,
        nok,
        types.resourceTitle,
        types.resourceTitleMarker,
        types.resourceTitleString
      )(code2);
    }
    return resourceEnd(code2);
  }
  function resourceTitleAfter(code2) {
    return markdownLineEndingOrSpace(code2) ? factoryWhitespace(effects, resourceEnd)(code2) : resourceEnd(code2);
  }
  function resourceEnd(code2) {
    if (code2 === codes.rightParenthesis) {
      effects.enter(types.resourceMarker);
      effects.consume(code2);
      effects.exit(types.resourceMarker);
      effects.exit(types.resource);
      return ok3;
    }
    return nok(code2);
  }
}
function tokenizeReferenceFull(effects, ok3, nok) {
  const self2 = this;
  return referenceFull;
  function referenceFull(code2) {
    ok(code2 === codes.leftSquareBracket, "expected left bracket");
    return factoryLabel.call(
      self2,
      effects,
      referenceFullAfter,
      referenceFullMissing,
      types.reference,
      types.referenceMarker,
      types.referenceString
    )(code2);
  }
  function referenceFullAfter(code2) {
    return self2.parser.defined.includes(
      normalizeIdentifier(
        self2.sliceSerialize(self2.events[self2.events.length - 1][1]).slice(1, -1)
      )
    ) ? ok3(code2) : nok(code2);
  }
  function referenceFullMissing(code2) {
    return nok(code2);
  }
}
function tokenizeReferenceCollapsed(effects, ok3, nok) {
  return referenceCollapsedStart;
  function referenceCollapsedStart(code2) {
    ok(code2 === codes.leftSquareBracket, "expected left bracket");
    effects.enter(types.reference);
    effects.enter(types.referenceMarker);
    effects.consume(code2);
    effects.exit(types.referenceMarker);
    return referenceCollapsedOpen;
  }
  function referenceCollapsedOpen(code2) {
    if (code2 === codes.rightSquareBracket) {
      effects.enter(types.referenceMarker);
      effects.consume(code2);
      effects.exit(types.referenceMarker);
      effects.exit(types.reference);
      return ok3;
    }
    return nok(code2);
  }
}
var import_dist181, import_dist182, import_dist183, labelEnd, resourceConstruct, referenceFullConstruct, referenceCollapsedConstruct;
var init_label_end = __esm({
  "node_modules/micromark-core-commonmark/dev/lib/label-end.js"() {
    import_dist181 = __toESM(require_dist(), 1);
    import_dist182 = __toESM(require_dist2(), 1);
    import_dist183 = __toESM(require_dist3(), 1);
    init_dev6();
    init_dev7();
    init_dev8();
    init_dev9();
    init_dev2();
    init_dev();
    init_dev10();
    init_micromark_util_resolve_all();
    init_codes();
    init_constants();
    init_types();
    init_assert();
    labelEnd = {
      name: "labelEnd",
      tokenize: tokenizeLabelEnd,
      resolveTo: resolveToLabelEnd,
      resolveAll: resolveAllLabelEnd
    };
    resourceConstruct = { tokenize: tokenizeResource };
    referenceFullConstruct = { tokenize: tokenizeReferenceFull };
    referenceCollapsedConstruct = { tokenize: tokenizeReferenceCollapsed };
  }
});

// node_modules/micromark-core-commonmark/dev/lib/label-start-image.js
function tokenizeLabelStartImage(effects, ok3, nok) {
  const self2 = this;
  return start;
  function start(code2) {
    ok(code2 === codes.exclamationMark, "expected `!`");
    effects.enter(types.labelImage);
    effects.enter(types.labelImageMarker);
    effects.consume(code2);
    effects.exit(types.labelImageMarker);
    return open;
  }
  function open(code2) {
    if (code2 === codes.leftSquareBracket) {
      effects.enter(types.labelMarker);
      effects.consume(code2);
      effects.exit(types.labelMarker);
      effects.exit(types.labelImage);
      return after;
    }
    return nok(code2);
  }
  function after(code2) {
    return code2 === codes.caret && "_hiddenFootnoteSupport" in self2.parser.constructs ? nok(code2) : ok3(code2);
  }
}
var import_dist184, import_dist185, import_dist186, labelStartImage;
var init_label_start_image = __esm({
  "node_modules/micromark-core-commonmark/dev/lib/label-start-image.js"() {
    import_dist184 = __toESM(require_dist(), 1);
    import_dist185 = __toESM(require_dist2(), 1);
    import_dist186 = __toESM(require_dist3(), 1);
    init_codes();
    init_types();
    init_assert();
    init_label_end();
    labelStartImage = {
      name: "labelStartImage",
      tokenize: tokenizeLabelStartImage,
      resolveAll: labelEnd.resolveAll
    };
  }
});

// node_modules/micromark-core-commonmark/dev/lib/label-start-link.js
function tokenizeLabelStartLink(effects, ok3, nok) {
  const self2 = this;
  return start;
  function start(code2) {
    ok(code2 === codes.leftSquareBracket, "expected `[`");
    effects.enter(types.labelLink);
    effects.enter(types.labelMarker);
    effects.consume(code2);
    effects.exit(types.labelMarker);
    effects.exit(types.labelLink);
    return after;
  }
  function after(code2) {
    return code2 === codes.caret && "_hiddenFootnoteSupport" in self2.parser.constructs ? nok(code2) : ok3(code2);
  }
}
var import_dist187, import_dist188, import_dist189, labelStartLink;
var init_label_start_link = __esm({
  "node_modules/micromark-core-commonmark/dev/lib/label-start-link.js"() {
    import_dist187 = __toESM(require_dist(), 1);
    import_dist188 = __toESM(require_dist2(), 1);
    import_dist189 = __toESM(require_dist3(), 1);
    init_codes();
    init_types();
    init_assert();
    init_label_end();
    labelStartLink = {
      name: "labelStartLink",
      tokenize: tokenizeLabelStartLink,
      resolveAll: labelEnd.resolveAll
    };
  }
});

// node_modules/micromark-core-commonmark/dev/lib/line-ending.js
function tokenizeLineEnding(effects, ok3) {
  return start;
  function start(code2) {
    ok(markdownLineEnding(code2), "expected eol");
    effects.enter(types.lineEnding);
    effects.consume(code2);
    effects.exit(types.lineEnding);
    return factorySpace(effects, ok3, types.linePrefix);
  }
}
var import_dist190, import_dist191, import_dist192, lineEnding;
var init_line_ending = __esm({
  "node_modules/micromark-core-commonmark/dev/lib/line-ending.js"() {
    import_dist190 = __toESM(require_dist(), 1);
    import_dist191 = __toESM(require_dist2(), 1);
    import_dist192 = __toESM(require_dist3(), 1);
    init_dev3();
    init_dev2();
    init_types();
    init_assert();
    lineEnding = { name: "lineEnding", tokenize: tokenizeLineEnding };
  }
});

// node_modules/micromark-core-commonmark/dev/lib/thematic-break.js
function tokenizeThematicBreak(effects, ok3, nok) {
  let size = 0;
  let marker;
  return start;
  function start(code2) {
    effects.enter(types.thematicBreak);
    return before(code2);
  }
  function before(code2) {
    ok(
      code2 === codes.asterisk || code2 === codes.dash || code2 === codes.underscore,
      "expected `*`, `-`, or `_`"
    );
    marker = code2;
    return atBreak(code2);
  }
  function atBreak(code2) {
    if (code2 === marker) {
      effects.enter(types.thematicBreakSequence);
      return sequence(code2);
    }
    if (size >= constants.thematicBreakMarkerCountMin && (code2 === codes.eof || markdownLineEnding(code2))) {
      effects.exit(types.thematicBreak);
      return ok3(code2);
    }
    return nok(code2);
  }
  function sequence(code2) {
    if (code2 === marker) {
      effects.consume(code2);
      size++;
      return sequence;
    }
    effects.exit(types.thematicBreakSequence);
    return markdownSpace(code2) ? factorySpace(effects, atBreak, types.whitespace)(code2) : atBreak(code2);
  }
}
var import_dist193, import_dist194, import_dist195, thematicBreak;
var init_thematic_break = __esm({
  "node_modules/micromark-core-commonmark/dev/lib/thematic-break.js"() {
    import_dist193 = __toESM(require_dist(), 1);
    import_dist194 = __toESM(require_dist2(), 1);
    import_dist195 = __toESM(require_dist3(), 1);
    init_dev3();
    init_dev2();
    init_codes();
    init_constants();
    init_types();
    init_assert();
    thematicBreak = {
      name: "thematicBreak",
      tokenize: tokenizeThematicBreak
    };
  }
});

// node_modules/micromark-core-commonmark/dev/lib/list.js
function tokenizeListStart(effects, ok3, nok) {
  const self2 = this;
  const tail = self2.events[self2.events.length - 1];
  let initialSize = tail && tail[1].type === types.linePrefix ? tail[2].sliceSerialize(tail[1], true).length : 0;
  let size = 0;
  return start;
  function start(code2) {
    ok(self2.containerState, "expected state");
    const kind = self2.containerState.type || (code2 === codes.asterisk || code2 === codes.plusSign || code2 === codes.dash ? types.listUnordered : types.listOrdered);
    if (kind === types.listUnordered ? !self2.containerState.marker || code2 === self2.containerState.marker : asciiDigit(code2)) {
      if (!self2.containerState.type) {
        self2.containerState.type = kind;
        effects.enter(kind, { _container: true });
      }
      if (kind === types.listUnordered) {
        effects.enter(types.listItemPrefix);
        return code2 === codes.asterisk || code2 === codes.dash ? effects.check(thematicBreak, nok, atMarker)(code2) : atMarker(code2);
      }
      if (!self2.interrupt || code2 === codes.digit1) {
        effects.enter(types.listItemPrefix);
        effects.enter(types.listItemValue);
        return inside(code2);
      }
    }
    return nok(code2);
  }
  function inside(code2) {
    ok(self2.containerState, "expected state");
    if (asciiDigit(code2) && ++size < constants.listItemValueSizeMax) {
      effects.consume(code2);
      return inside;
    }
    if ((!self2.interrupt || size < 2) && (self2.containerState.marker ? code2 === self2.containerState.marker : code2 === codes.rightParenthesis || code2 === codes.dot)) {
      effects.exit(types.listItemValue);
      return atMarker(code2);
    }
    return nok(code2);
  }
  function atMarker(code2) {
    ok(self2.containerState, "expected state");
    ok(code2 !== codes.eof, "eof (`null`) is not a marker");
    effects.enter(types.listItemMarker);
    effects.consume(code2);
    effects.exit(types.listItemMarker);
    self2.containerState.marker = self2.containerState.marker || code2;
    return effects.check(
      blankLine,
      // Cant be empty when interrupting.
      self2.interrupt ? nok : onBlank,
      effects.attempt(
        listItemPrefixWhitespaceConstruct,
        endOfPrefix,
        otherPrefix
      )
    );
  }
  function onBlank(code2) {
    ok(self2.containerState, "expected state");
    self2.containerState.initialBlankLine = true;
    initialSize++;
    return endOfPrefix(code2);
  }
  function otherPrefix(code2) {
    if (markdownSpace(code2)) {
      effects.enter(types.listItemPrefixWhitespace);
      effects.consume(code2);
      effects.exit(types.listItemPrefixWhitespace);
      return endOfPrefix;
    }
    return nok(code2);
  }
  function endOfPrefix(code2) {
    ok(self2.containerState, "expected state");
    self2.containerState.size = initialSize + self2.sliceSerialize(effects.exit(types.listItemPrefix), true).length;
    return ok3(code2);
  }
}
function tokenizeListContinuation(effects, ok3, nok) {
  const self2 = this;
  ok(self2.containerState, "expected state");
  self2.containerState._closeFlow = void 0;
  return effects.check(blankLine, onBlank, notBlank);
  function onBlank(code2) {
    ok(self2.containerState, "expected state");
    ok(typeof self2.containerState.size === "number", "expected size");
    self2.containerState.furtherBlankLines = self2.containerState.furtherBlankLines || self2.containerState.initialBlankLine;
    return factorySpace(
      effects,
      ok3,
      types.listItemIndent,
      self2.containerState.size + 1
    )(code2);
  }
  function notBlank(code2) {
    ok(self2.containerState, "expected state");
    if (self2.containerState.furtherBlankLines || !markdownSpace(code2)) {
      self2.containerState.furtherBlankLines = void 0;
      self2.containerState.initialBlankLine = void 0;
      return notInCurrentItem(code2);
    }
    self2.containerState.furtherBlankLines = void 0;
    self2.containerState.initialBlankLine = void 0;
    return effects.attempt(indentConstruct, ok3, notInCurrentItem)(code2);
  }
  function notInCurrentItem(code2) {
    ok(self2.containerState, "expected state");
    self2.containerState._closeFlow = true;
    self2.interrupt = void 0;
    ok(
      self2.parser.constructs.disable.null,
      "expected `disable.null` to be populated"
    );
    return factorySpace(
      effects,
      effects.attempt(list, ok3, nok),
      types.linePrefix,
      self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : constants.tabSize
    )(code2);
  }
}
function tokenizeIndent(effects, ok3, nok) {
  const self2 = this;
  ok(self2.containerState, "expected state");
  ok(typeof self2.containerState.size === "number", "expected size");
  return factorySpace(
    effects,
    afterPrefix,
    types.listItemIndent,
    self2.containerState.size + 1
  );
  function afterPrefix(code2) {
    ok(self2.containerState, "expected state");
    const tail = self2.events[self2.events.length - 1];
    return tail && tail[1].type === types.listItemIndent && tail[2].sliceSerialize(tail[1], true).length === self2.containerState.size ? ok3(code2) : nok(code2);
  }
}
function tokenizeListEnd(effects) {
  ok(this.containerState, "expected state");
  ok(typeof this.containerState.type === "string", "expected type");
  effects.exit(this.containerState.type);
}
function tokenizeListItemPrefixWhitespace(effects, ok3, nok) {
  const self2 = this;
  ok(
    self2.parser.constructs.disable.null,
    "expected `disable.null` to be populated"
  );
  return factorySpace(
    effects,
    afterPrefix,
    types.listItemPrefixWhitespace,
    self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : constants.tabSize + 1
  );
  function afterPrefix(code2) {
    const tail = self2.events[self2.events.length - 1];
    return !markdownSpace(code2) && tail && tail[1].type === types.listItemPrefixWhitespace ? ok3(code2) : nok(code2);
  }
}
var import_dist196, import_dist197, import_dist198, list, listItemPrefixWhitespaceConstruct, indentConstruct;
var init_list = __esm({
  "node_modules/micromark-core-commonmark/dev/lib/list.js"() {
    import_dist196 = __toESM(require_dist(), 1);
    import_dist197 = __toESM(require_dist2(), 1);
    import_dist198 = __toESM(require_dist3(), 1);
    init_dev3();
    init_dev2();
    init_codes();
    init_constants();
    init_types();
    init_assert();
    init_blank_line();
    init_thematic_break();
    list = {
      name: "list",
      tokenize: tokenizeListStart,
      continuation: { tokenize: tokenizeListContinuation },
      exit: tokenizeListEnd
    };
    listItemPrefixWhitespaceConstruct = {
      tokenize: tokenizeListItemPrefixWhitespace,
      partial: true
    };
    indentConstruct = { tokenize: tokenizeIndent, partial: true };
  }
});

// node_modules/micromark-core-commonmark/dev/lib/setext-underline.js
function resolveToSetextUnderline(events, context) {
  let index2 = events.length;
  let content3;
  let text4;
  let definition2;
  while (index2--) {
    if (events[index2][0] === "enter") {
      if (events[index2][1].type === types.content) {
        content3 = index2;
        break;
      }
      if (events[index2][1].type === types.paragraph) {
        text4 = index2;
      }
    } else {
      if (events[index2][1].type === types.content) {
        events.splice(index2, 1);
      }
      if (!definition2 && events[index2][1].type === types.definition) {
        definition2 = index2;
      }
    }
  }
  ok(text4 !== void 0, "expected a `text` index to be found");
  ok(content3 !== void 0, "expected a `text` index to be found");
  const heading2 = {
    type: types.setextHeading,
    start: Object.assign({}, events[text4][1].start),
    end: Object.assign({}, events[events.length - 1][1].end)
  };
  events[text4][1].type = types.setextHeadingText;
  if (definition2) {
    events.splice(text4, 0, ["enter", heading2, context]);
    events.splice(definition2 + 1, 0, ["exit", events[content3][1], context]);
    events[content3][1].end = Object.assign({}, events[definition2][1].end);
  } else {
    events[content3][1] = heading2;
  }
  events.push(["exit", heading2, context]);
  return events;
}
function tokenizeSetextUnderline(effects, ok3, nok) {
  const self2 = this;
  let marker;
  return start;
  function start(code2) {
    let index2 = self2.events.length;
    let paragraph2;
    ok(
      code2 === codes.dash || code2 === codes.equalsTo,
      "expected `=` or `-`"
    );
    while (index2--) {
      if (self2.events[index2][1].type !== types.lineEnding && self2.events[index2][1].type !== types.linePrefix && self2.events[index2][1].type !== types.content) {
        paragraph2 = self2.events[index2][1].type === types.paragraph;
        break;
      }
    }
    if (!self2.parser.lazy[self2.now().line] && (self2.interrupt || paragraph2)) {
      effects.enter(types.setextHeadingLine);
      marker = code2;
      return before(code2);
    }
    return nok(code2);
  }
  function before(code2) {
    effects.enter(types.setextHeadingLineSequence);
    return inside(code2);
  }
  function inside(code2) {
    if (code2 === marker) {
      effects.consume(code2);
      return inside;
    }
    effects.exit(types.setextHeadingLineSequence);
    return markdownSpace(code2) ? factorySpace(effects, after, types.lineSuffix)(code2) : after(code2);
  }
  function after(code2) {
    if (code2 === codes.eof || markdownLineEnding(code2)) {
      effects.exit(types.setextHeadingLine);
      return ok3(code2);
    }
    return nok(code2);
  }
}
var import_dist199, import_dist200, import_dist201, setextUnderline;
var init_setext_underline = __esm({
  "node_modules/micromark-core-commonmark/dev/lib/setext-underline.js"() {
    import_dist199 = __toESM(require_dist(), 1);
    import_dist200 = __toESM(require_dist2(), 1);
    import_dist201 = __toESM(require_dist3(), 1);
    init_dev3();
    init_dev2();
    init_codes();
    init_types();
    init_assert();
    setextUnderline = {
      name: "setextUnderline",
      tokenize: tokenizeSetextUnderline,
      resolveTo: resolveToSetextUnderline
    };
  }
});

// node_modules/micromark-core-commonmark/dev/index.js
var import_dist202, import_dist203, import_dist204;
var init_dev11 = __esm({
  "node_modules/micromark-core-commonmark/dev/index.js"() {
    import_dist202 = __toESM(require_dist());
    import_dist203 = __toESM(require_dist2());
    import_dist204 = __toESM(require_dist3());
    init_attention();
    init_autolink();
    init_blank_line();
    init_block_quote();
    init_character_escape();
    init_character_reference();
    init_code_fenced();
    init_code_indented();
    init_code_text();
    init_content2();
    init_definition();
    init_hard_break_escape();
    init_heading_atx();
    init_html_flow();
    init_html_text();
    init_label_end();
    init_label_start_image();
    init_label_start_link();
    init_line_ending();
    init_list();
    init_setext_underline();
    init_thematic_break();
  }
});

// node_modules/mdast-util-from-markdown/node_modules/micromark/dev/lib/initialize/flow.js
function initializeFlow(effects) {
  const self2 = this;
  const initial = effects.attempt(
    // Try to parse a blank line.
    blankLine,
    atBlankEnding,
    // Try to parse initial flow (essentially, only code).
    effects.attempt(
      this.parser.constructs.flowInitial,
      afterConstruct,
      factorySpace(
        effects,
        effects.attempt(
          this.parser.constructs.flow,
          afterConstruct,
          effects.attempt(content2, afterConstruct)
        ),
        types.linePrefix
      )
    )
  );
  return initial;
  function atBlankEnding(code2) {
    ok(
      code2 === codes.eof || markdownLineEnding(code2),
      "expected eol or eof"
    );
    if (code2 === codes.eof) {
      effects.consume(code2);
      return;
    }
    effects.enter(types.lineEndingBlank);
    effects.consume(code2);
    effects.exit(types.lineEndingBlank);
    self2.currentConstruct = void 0;
    return initial;
  }
  function afterConstruct(code2) {
    ok(
      code2 === codes.eof || markdownLineEnding(code2),
      "expected eol or eof"
    );
    if (code2 === codes.eof) {
      effects.consume(code2);
      return;
    }
    effects.enter(types.lineEnding);
    effects.consume(code2);
    effects.exit(types.lineEnding);
    self2.currentConstruct = void 0;
    return initial;
  }
}
var import_dist205, import_dist206, import_dist207, flow;
var init_flow = __esm({
  "node_modules/mdast-util-from-markdown/node_modules/micromark/dev/lib/initialize/flow.js"() {
    import_dist205 = __toESM(require_dist(), 1);
    import_dist206 = __toESM(require_dist2(), 1);
    import_dist207 = __toESM(require_dist3(), 1);
    init_dev11();
    init_dev3();
    init_dev2();
    init_codes();
    init_types();
    init_assert();
    flow = { tokenize: initializeFlow };
  }
});

// node_modules/mdast-util-from-markdown/node_modules/micromark/dev/lib/initialize/text.js
function initializeFactory(field) {
  return {
    tokenize: initializeText,
    resolveAll: createResolver(
      field === "text" ? resolveAllLineSuffixes : void 0
    )
  };
  function initializeText(effects) {
    const self2 = this;
    const constructs2 = this.parser.constructs[field];
    const text4 = effects.attempt(constructs2, start, notText);
    return start;
    function start(code2) {
      return atBreak(code2) ? text4(code2) : notText(code2);
    }
    function notText(code2) {
      if (code2 === codes.eof) {
        effects.consume(code2);
        return;
      }
      effects.enter(types.data);
      effects.consume(code2);
      return data;
    }
    function data(code2) {
      if (atBreak(code2)) {
        effects.exit(types.data);
        return text4(code2);
      }
      effects.consume(code2);
      return data;
    }
    function atBreak(code2) {
      if (code2 === codes.eof) {
        return true;
      }
      const list3 = constructs2[code2];
      let index2 = -1;
      if (list3) {
        ok(Array.isArray(list3), "expected `disable.null` to be populated");
        while (++index2 < list3.length) {
          const item = list3[index2];
          if (!item.previous || item.previous.call(self2, self2.previous)) {
            return true;
          }
        }
      }
      return false;
    }
  }
}
function createResolver(extraResolver) {
  return resolveAllText;
  function resolveAllText(events, context) {
    let index2 = -1;
    let enter;
    while (++index2 <= events.length) {
      if (enter === void 0) {
        if (events[index2] && events[index2][1].type === types.data) {
          enter = index2;
          index2++;
        }
      } else if (!events[index2] || events[index2][1].type !== types.data) {
        if (index2 !== enter + 2) {
          events[enter][1].end = events[index2 - 1][1].end;
          events.splice(enter + 2, index2 - enter - 2);
          index2 = enter + 2;
        }
        enter = void 0;
      }
    }
    return extraResolver ? extraResolver(events, context) : events;
  }
}
function resolveAllLineSuffixes(events, context) {
  let eventIndex = 0;
  while (++eventIndex <= events.length) {
    if ((eventIndex === events.length || events[eventIndex][1].type === types.lineEnding) && events[eventIndex - 1][1].type === types.data) {
      const data = events[eventIndex - 1][1];
      const chunks = context.sliceStream(data);
      let index2 = chunks.length;
      let bufferIndex = -1;
      let size = 0;
      let tabs;
      while (index2--) {
        const chunk = chunks[index2];
        if (typeof chunk === "string") {
          bufferIndex = chunk.length;
          while (chunk.charCodeAt(bufferIndex - 1) === codes.space) {
            size++;
            bufferIndex--;
          }
          if (bufferIndex) break;
          bufferIndex = -1;
        } else if (chunk === codes.horizontalTab) {
          tabs = true;
          size++;
        } else if (chunk === codes.virtualSpace) {
        } else {
          index2++;
          break;
        }
      }
      if (size) {
        const token = {
          type: eventIndex === events.length || tabs || size < constants.hardBreakPrefixSizeMin ? types.lineSuffix : types.hardBreakTrailing,
          start: {
            line: data.end.line,
            column: data.end.column - size,
            offset: data.end.offset - size,
            _index: data.start._index + index2,
            _bufferIndex: index2 ? bufferIndex : data.start._bufferIndex + bufferIndex
          },
          end: Object.assign({}, data.end)
        };
        data.end = Object.assign({}, token.start);
        if (data.start.offset === data.end.offset) {
          Object.assign(data, token);
        } else {
          events.splice(
            eventIndex,
            0,
            ["enter", token, context],
            ["exit", token, context]
          );
          eventIndex += 2;
        }
      }
      eventIndex++;
    }
  }
  return events;
}
var import_dist208, import_dist209, import_dist210, resolver, string, text;
var init_text = __esm({
  "node_modules/mdast-util-from-markdown/node_modules/micromark/dev/lib/initialize/text.js"() {
    import_dist208 = __toESM(require_dist(), 1);
    import_dist209 = __toESM(require_dist2(), 1);
    import_dist210 = __toESM(require_dist3(), 1);
    init_codes();
    init_constants();
    init_types();
    init_assert();
    resolver = { resolveAll: createResolver() };
    string = initializeFactory("string");
    text = initializeFactory("text");
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports, module) {
    var import_dist466 = __toESM(require_dist());
    var import_dist467 = __toESM(require_dist2());
    var import_dist468 = __toESM(require_dist3());
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse2(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse2(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/debug/src/common.js"(exports, module) {
    var import_dist466 = __toESM(require_dist());
    var import_dist467 = __toESM(require_dist2());
    var import_dist468 = __toESM(require_dist3());
    function setup(env) {
      createDebug2.debug = createDebug2;
      createDebug2.default = createDebug2;
      createDebug2.coerce = coerce;
      createDebug2.disable = disable2;
      createDebug2.enable = enable;
      createDebug2.enabled = enabled;
      createDebug2.humanize = require_ms();
      createDebug2.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug2[key] = env[key];
      });
      createDebug2.names = [];
      createDebug2.skips = [];
      createDebug2.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug2.colors[Math.abs(hash) % createDebug2.colors.length];
      }
      createDebug2.selectColor = selectColor;
      function createDebug2(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug2(...args) {
          if (!debug2.enabled) {
            return;
          }
          const self2 = debug2;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug2.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index2 = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index2++;
            const formatter = createDebug2.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index2];
              match = formatter.call(self2, val);
              args.splice(index2, 1);
              index2--;
            }
            return match;
          });
          createDebug2.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug2.log;
          logFn.apply(self2, args);
        }
        debug2.namespace = namespace;
        debug2.useColors = createDebug2.useColors();
        debug2.color = createDebug2.selectColor(namespace);
        debug2.extend = extend2;
        debug2.destroy = createDebug2.destroy;
        Object.defineProperty(debug2, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug2.namespaces) {
              namespacesCache = createDebug2.namespaces;
              enabledCache = createDebug2.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug2.init === "function") {
          createDebug2.init(debug2);
        }
        return debug2;
      }
      function extend2(namespace, delimiter) {
        const newDebug = createDebug2(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug2.save(namespaces);
        createDebug2.namespaces = namespaces;
        createDebug2.names = [];
        createDebug2.skips = [];
        const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
        for (const ns of split) {
          if (ns[0] === "-") {
            createDebug2.skips.push(ns.slice(1));
          } else {
            createDebug2.names.push(ns);
          }
        }
      }
      function matchesTemplate(search2, template) {
        let searchIndex = 0;
        let templateIndex = 0;
        let starIndex = -1;
        let matchIndex = 0;
        while (searchIndex < search2.length) {
          if (templateIndex < template.length && (template[templateIndex] === search2[searchIndex] || template[templateIndex] === "*")) {
            if (template[templateIndex] === "*") {
              starIndex = templateIndex;
              matchIndex = searchIndex;
              templateIndex++;
            } else {
              searchIndex++;
              templateIndex++;
            }
          } else if (starIndex !== -1) {
            templateIndex = starIndex + 1;
            matchIndex++;
            searchIndex = matchIndex;
          } else {
            return false;
          }
        }
        while (templateIndex < template.length && template[templateIndex] === "*") {
          templateIndex++;
        }
        return templateIndex === template.length;
      }
      function disable2() {
        const namespaces = [
          ...createDebug2.names,
          ...createDebug2.skips.map((namespace) => "-" + namespace)
        ].join(",");
        createDebug2.enable("");
        return namespaces;
      }
      function enabled(name) {
        for (const skip of createDebug2.skips) {
          if (matchesTemplate(name, skip)) {
            return false;
          }
        }
        for (const ns of createDebug2.names) {
          if (matchesTemplate(name, ns)) {
            return true;
          }
        }
        return false;
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug2.enable(createDebug2.load());
      return createDebug2;
    }
    module.exports = setup;
  }
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/debug/src/browser.js"(exports, module) {
    var import_dist466 = __toESM(require_dist());
    var import_dist467 = __toESM(require_dist2());
    var import_dist468 = __toESM(require_dist3());
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index2 = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index2++;
        if (match === "%c") {
          lastC = index2;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports.storage.getItem("debug") || exports.storage.getItem("DEBUG");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module.exports = require_common()(exports);
    var { formatters } = module.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/tty-browserify/index.js
var require_tty_browserify = __commonJS({
  "node_modules/tty-browserify/index.js"(exports) {
    var import_dist466 = __toESM(require_dist());
    var import_dist467 = __toESM(require_dist2());
    var import_dist468 = __toESM(require_dist3());
    exports.isatty = function() {
      return false;
    };
    function ReadStream() {
      throw new Error("tty.ReadStream is not implemented");
    }
    exports.ReadStream = ReadStream;
    function WriteStream() {
      throw new Error("tty.WriteStream is not implemented");
    }
    exports.WriteStream = WriteStream;
  }
});

// node_modules/supports-color/browser.js
var require_browser2 = __commonJS({
  "node_modules/supports-color/browser.js"(exports, module) {
    "use strict";
    var import_dist466 = __toESM(require_dist());
    var import_dist467 = __toESM(require_dist2());
    var import_dist468 = __toESM(require_dist3());
    function getChromeVersion() {
      const matches = /(Chrome|Chromium)\/(?<chromeVersion>\d+)\./.exec(navigator.userAgent);
      if (!matches) {
        return;
      }
      return Number.parseInt(matches.groups.chromeVersion, 10);
    }
    var colorSupport = getChromeVersion() >= 69 ? {
      level: 1,
      hasBasic: true,
      has256: false,
      has16m: false
    } : false;
    module.exports = {
      stdout: colorSupport,
      stderr: colorSupport
    };
  }
});

// node_modules/debug/src/node.js
var require_node = __commonJS({
  "node_modules/debug/src/node.js"(exports, module) {
    var import_dist466 = __toESM(require_dist());
    var import_dist467 = __toESM(require_dist2());
    var import_dist468 = __toESM(require_dist3());
    var tty = require_tty_browserify();
    var util = require_util();
    exports.init = init2;
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.destroy = util.deprecate(
      () => {
      },
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    );
    exports.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = require_browser2();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error) {
    }
    exports.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const { namespace: name, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name} \x1B[0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = getDate() + name + " " + args[0];
      }
    }
    function getDate() {
      if (exports.inspectOpts.hideDate) {
        return "";
      }
      return (/* @__PURE__ */ new Date()).toISOString() + " ";
    }
    function log(...args) {
      return process.stderr.write(util.formatWithOptions(exports.inspectOpts, ...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function init2(debug2) {
      debug2.inspectOpts = {};
      const keys2 = Object.keys(exports.inspectOpts);
      for (let i = 0; i < keys2.length; i++) {
        debug2.inspectOpts[keys2[i]] = exports.inspectOpts[keys2[i]];
      }
    }
    module.exports = require_common()(exports);
    var { formatters } = module.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts);
    };
  }
});

// node_modules/debug/src/index.js
var require_src = __commonJS({
  "node_modules/debug/src/index.js"(exports, module) {
    var import_dist466 = __toESM(require_dist());
    var import_dist467 = __toESM(require_dist2());
    var import_dist468 = __toESM(require_dist3());
    if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
      module.exports = require_browser();
    } else {
      module.exports = require_node();
    }
  }
});

// node_modules/mdast-util-from-markdown/node_modules/micromark/dev/lib/create-tokenizer.js
function createTokenizer(parser, initialize, from) {
  let point4 = Object.assign(
    from ? Object.assign({}, from) : { line: 1, column: 1, offset: 0 },
    { _index: 0, _bufferIndex: -1 }
  );
  const columnStart = {};
  const resolveAllConstructs = [];
  let chunks = [];
  let stack = [];
  let consumed = true;
  const effects = {
    consume,
    enter,
    exit: exit2,
    attempt: constructFactory(onsuccessfulconstruct),
    check: constructFactory(onsuccessfulcheck),
    interrupt: constructFactory(onsuccessfulcheck, { interrupt: true })
  };
  const context = {
    previous: codes.eof,
    code: codes.eof,
    containerState: {},
    events: [],
    parser,
    sliceStream,
    sliceSerialize,
    now,
    defineSkip,
    write
  };
  let state = initialize.tokenize.call(context, effects);
  let expectedCode;
  if (initialize.resolveAll) {
    resolveAllConstructs.push(initialize);
  }
  return context;
  function write(slice) {
    chunks = push(chunks, slice);
    main();
    if (chunks[chunks.length - 1] !== codes.eof) {
      return [];
    }
    addResult(initialize, 0);
    context.events = resolveAll(resolveAllConstructs, context.events, context);
    return context.events;
  }
  function sliceSerialize(token, expandTabs) {
    return serializeChunks(sliceStream(token), expandTabs);
  }
  function sliceStream(token) {
    return sliceChunks(chunks, token);
  }
  function now() {
    const { line: line2, column, offset, _index, _bufferIndex } = point4;
    return { line: line2, column, offset, _index, _bufferIndex };
  }
  function defineSkip(value) {
    columnStart[value.line] = value.column;
    accountForPotentialSkip();
    debug("position: define skip: `%j`", point4);
  }
  function main() {
    let chunkIndex;
    while (point4._index < chunks.length) {
      const chunk = chunks[point4._index];
      if (typeof chunk === "string") {
        chunkIndex = point4._index;
        if (point4._bufferIndex < 0) {
          point4._bufferIndex = 0;
        }
        while (point4._index === chunkIndex && point4._bufferIndex < chunk.length) {
          go(chunk.charCodeAt(point4._bufferIndex));
        }
      } else {
        go(chunk);
      }
    }
  }
  function go(code2) {
    ok(consumed === true, "expected character to be consumed");
    consumed = void 0;
    debug("main: passing `%s` to %s", code2, state && state.name);
    expectedCode = code2;
    ok(typeof state === "function", "expected state");
    state = state(code2);
  }
  function consume(code2) {
    ok(code2 === expectedCode, "expected given code to equal expected code");
    debug("consume: `%s`", code2);
    ok(
      consumed === void 0,
      "expected code to not have been consumed: this might be because `return x(code)` instead of `return x` was used"
    );
    ok(
      code2 === null ? context.events.length === 0 || context.events[context.events.length - 1][0] === "exit" : context.events[context.events.length - 1][0] === "enter",
      "expected last token to be open"
    );
    if (markdownLineEnding(code2)) {
      point4.line++;
      point4.column = 1;
      point4.offset += code2 === codes.carriageReturnLineFeed ? 2 : 1;
      accountForPotentialSkip();
      debug("position: after eol: `%j`", point4);
    } else if (code2 !== codes.virtualSpace) {
      point4.column++;
      point4.offset++;
    }
    if (point4._bufferIndex < 0) {
      point4._index++;
    } else {
      point4._bufferIndex++;
      if (point4._bufferIndex === chunks[point4._index].length) {
        point4._bufferIndex = -1;
        point4._index++;
      }
    }
    context.previous = code2;
    consumed = true;
  }
  function enter(type, fields) {
    const token = fields || {};
    token.type = type;
    token.start = now();
    ok(typeof type === "string", "expected string type");
    ok(type.length > 0, "expected non-empty string");
    debug("enter: `%s`", type);
    context.events.push(["enter", token, context]);
    stack.push(token);
    return token;
  }
  function exit2(type) {
    ok(typeof type === "string", "expected string type");
    ok(type.length > 0, "expected non-empty string");
    const token = stack.pop();
    ok(token, "cannot close w/o open tokens");
    token.end = now();
    ok(type === token.type, "expected exit token to match current token");
    ok(
      !(token.start._index === token.end._index && token.start._bufferIndex === token.end._bufferIndex),
      "expected non-empty token (`" + type + "`)"
    );
    debug("exit: `%s`", token.type);
    context.events.push(["exit", token, context]);
    return token;
  }
  function onsuccessfulconstruct(construct, info) {
    addResult(construct, info.from);
  }
  function onsuccessfulcheck(_, info) {
    info.restore();
  }
  function constructFactory(onreturn, fields) {
    return hook;
    function hook(constructs2, returnState, bogusState) {
      let listOfConstructs;
      let constructIndex;
      let currentConstruct;
      let info;
      return Array.isArray(constructs2) ? (
        /* c8 ignore next 1 */
        handleListOfConstructs(constructs2)
      ) : "tokenize" in constructs2 ? (
        // @ts-expect-error Looks like a construct.
        handleListOfConstructs([constructs2])
      ) : handleMapOfConstructs(constructs2);
      function handleMapOfConstructs(map) {
        return start;
        function start(code2) {
          const def = code2 !== null && map[code2];
          const all3 = code2 !== null && map.null;
          const list3 = [
            // To do: add more extension tests.
            /* c8 ignore next 2 */
            ...Array.isArray(def) ? def : def ? [def] : [],
            ...Array.isArray(all3) ? all3 : all3 ? [all3] : []
          ];
          return handleListOfConstructs(list3)(code2);
        }
      }
      function handleListOfConstructs(list3) {
        listOfConstructs = list3;
        constructIndex = 0;
        if (list3.length === 0) {
          ok(bogusState, "expected `bogusState` to be given");
          return bogusState;
        }
        return handleConstruct(list3[constructIndex]);
      }
      function handleConstruct(construct) {
        return start;
        function start(code2) {
          info = store();
          currentConstruct = construct;
          if (!construct.partial) {
            context.currentConstruct = construct;
          }
          ok(
            context.parser.constructs.disable.null,
            "expected `disable.null` to be populated"
          );
          if (construct.name && context.parser.constructs.disable.null.includes(construct.name)) {
            return nok(code2);
          }
          return construct.tokenize.call(
            // If we do have fields, create an object w/ `context` as its
            // prototype.
            // This allows a live binding, which is needed for `interrupt`.
            fields ? Object.assign(Object.create(context), fields) : context,
            effects,
            ok3,
            nok
          )(code2);
        }
      }
      function ok3(code2) {
        ok(code2 === expectedCode, "expected code");
        consumed = true;
        onreturn(currentConstruct, info);
        return returnState;
      }
      function nok(code2) {
        ok(code2 === expectedCode, "expected code");
        consumed = true;
        info.restore();
        if (++constructIndex < listOfConstructs.length) {
          return handleConstruct(listOfConstructs[constructIndex]);
        }
        return bogusState;
      }
    }
  }
  function addResult(construct, from2) {
    if (construct.resolveAll && !resolveAllConstructs.includes(construct)) {
      resolveAllConstructs.push(construct);
    }
    if (construct.resolve) {
      splice(
        context.events,
        from2,
        context.events.length - from2,
        construct.resolve(context.events.slice(from2), context)
      );
    }
    if (construct.resolveTo) {
      context.events = construct.resolveTo(context.events, context);
    }
    ok(
      construct.partial || context.events.length === 0 || context.events[context.events.length - 1][0] === "exit",
      "expected last token to end"
    );
  }
  function store() {
    const startPoint = now();
    const startPrevious = context.previous;
    const startCurrentConstruct = context.currentConstruct;
    const startEventsIndex = context.events.length;
    const startStack = Array.from(stack);
    return { restore, from: startEventsIndex };
    function restore() {
      point4 = startPoint;
      context.previous = startPrevious;
      context.currentConstruct = startCurrentConstruct;
      context.events.length = startEventsIndex;
      stack = startStack;
      accountForPotentialSkip();
      debug("position: restore: `%j`", point4);
    }
  }
  function accountForPotentialSkip() {
    if (point4.line in columnStart && point4.column < 2) {
      point4.column = columnStart[point4.line];
      point4.offset += columnStart[point4.line] - 1;
    }
  }
}
function sliceChunks(chunks, token) {
  const startIndex = token.start._index;
  const startBufferIndex = token.start._bufferIndex;
  const endIndex = token.end._index;
  const endBufferIndex = token.end._bufferIndex;
  let view;
  if (startIndex === endIndex) {
    ok(endBufferIndex > -1, "expected non-negative end buffer index");
    ok(startBufferIndex > -1, "expected non-negative start buffer index");
    view = [chunks[startIndex].slice(startBufferIndex, endBufferIndex)];
  } else {
    view = chunks.slice(startIndex, endIndex);
    if (startBufferIndex > -1) {
      const head = view[0];
      if (typeof head === "string") {
        view[0] = head.slice(startBufferIndex);
      } else {
        ok(startBufferIndex === 0, "expected `startBufferIndex` to be `0`");
        view.shift();
      }
    }
    if (endBufferIndex > 0) {
      view.push(chunks[endIndex].slice(0, endBufferIndex));
    }
  }
  return view;
}
function serializeChunks(chunks, expandTabs) {
  let index2 = -1;
  const result = [];
  let atTab;
  while (++index2 < chunks.length) {
    const chunk = chunks[index2];
    let value;
    if (typeof chunk === "string") {
      value = chunk;
    } else
      switch (chunk) {
        case codes.carriageReturn: {
          value = values.cr;
          break;
        }
        case codes.lineFeed: {
          value = values.lf;
          break;
        }
        case codes.carriageReturnLineFeed: {
          value = values.cr + values.lf;
          break;
        }
        case codes.horizontalTab: {
          value = expandTabs ? values.space : values.ht;
          break;
        }
        case codes.virtualSpace: {
          if (!expandTabs && atTab) continue;
          value = values.space;
          break;
        }
        default: {
          ok(typeof chunk === "number", "expected number");
          value = String.fromCharCode(chunk);
        }
      }
    atTab = chunk === codes.horizontalTab;
    result.push(value);
  }
  return result.join("");
}
var import_dist211, import_dist212, import_dist213, import_debug, debug;
var init_create_tokenizer = __esm({
  "node_modules/mdast-util-from-markdown/node_modules/micromark/dev/lib/create-tokenizer.js"() {
    import_dist211 = __toESM(require_dist(), 1);
    import_dist212 = __toESM(require_dist2(), 1);
    import_dist213 = __toESM(require_dist3(), 1);
    import_debug = __toESM(require_src(), 1);
    init_dev2();
    init_dev();
    init_micromark_util_resolve_all();
    init_codes();
    init_values();
    init_assert();
    debug = (0, import_debug.default)("micromark");
  }
});

// node_modules/mdast-util-from-markdown/node_modules/micromark/dev/lib/constructs.js
var constructs_exports = {};
__export(constructs_exports, {
  attentionMarkers: () => attentionMarkers,
  contentInitial: () => contentInitial,
  disable: () => disable,
  document: () => document3,
  flow: () => flow2,
  flowInitial: () => flowInitial,
  insideSpan: () => insideSpan,
  string: () => string2,
  text: () => text2
});
var import_dist214, import_dist215, import_dist216, document3, contentInitial, flowInitial, flow2, string2, text2, insideSpan, attentionMarkers, disable;
var init_constructs = __esm({
  "node_modules/mdast-util-from-markdown/node_modules/micromark/dev/lib/constructs.js"() {
    import_dist214 = __toESM(require_dist(), 1);
    import_dist215 = __toESM(require_dist2(), 1);
    import_dist216 = __toESM(require_dist3(), 1);
    init_dev11();
    init_codes();
    init_text();
    document3 = {
      [codes.asterisk]: list,
      [codes.plusSign]: list,
      [codes.dash]: list,
      [codes.digit0]: list,
      [codes.digit1]: list,
      [codes.digit2]: list,
      [codes.digit3]: list,
      [codes.digit4]: list,
      [codes.digit5]: list,
      [codes.digit6]: list,
      [codes.digit7]: list,
      [codes.digit8]: list,
      [codes.digit9]: list,
      [codes.greaterThan]: blockQuote
    };
    contentInitial = {
      [codes.leftSquareBracket]: definition
    };
    flowInitial = {
      [codes.horizontalTab]: codeIndented,
      [codes.virtualSpace]: codeIndented,
      [codes.space]: codeIndented
    };
    flow2 = {
      [codes.numberSign]: headingAtx,
      [codes.asterisk]: thematicBreak,
      [codes.dash]: [setextUnderline, thematicBreak],
      [codes.lessThan]: htmlFlow,
      [codes.equalsTo]: setextUnderline,
      [codes.underscore]: thematicBreak,
      [codes.graveAccent]: codeFenced,
      [codes.tilde]: codeFenced
    };
    string2 = {
      [codes.ampersand]: characterReference,
      [codes.backslash]: characterEscape
    };
    text2 = {
      [codes.carriageReturn]: lineEnding,
      [codes.lineFeed]: lineEnding,
      [codes.carriageReturnLineFeed]: lineEnding,
      [codes.exclamationMark]: labelStartImage,
      [codes.ampersand]: characterReference,
      [codes.asterisk]: attention,
      [codes.lessThan]: [autolink, htmlText],
      [codes.leftSquareBracket]: labelStartLink,
      [codes.backslash]: [hardBreakEscape, characterEscape],
      [codes.rightSquareBracket]: labelEnd,
      [codes.underscore]: attention,
      [codes.graveAccent]: codeText
    };
    insideSpan = { null: [attention, resolver] };
    attentionMarkers = { null: [codes.asterisk, codes.underscore] };
    disable = { null: [] };
  }
});

// node_modules/mdast-util-from-markdown/node_modules/micromark/dev/lib/parse.js
function parse(options) {
  const settings = options || {};
  const constructs2 = (
    /** @type {FullNormalizedExtension} */
    combineExtensions([constructs_exports, ...settings.extensions || []])
  );
  const parser = {
    defined: [],
    lazy: {},
    constructs: constructs2,
    content: create2(content),
    document: create2(document2),
    flow: create2(flow),
    string: create2(string),
    text: create2(text)
  };
  return parser;
  function create2(initial) {
    return creator;
    function creator(from) {
      return createTokenizer(parser, initial, from);
    }
  }
}
var import_dist217, import_dist218, import_dist219;
var init_parse = __esm({
  "node_modules/mdast-util-from-markdown/node_modules/micromark/dev/lib/parse.js"() {
    import_dist217 = __toESM(require_dist());
    import_dist218 = __toESM(require_dist2());
    import_dist219 = __toESM(require_dist3());
    init_micromark_util_combine_extensions();
    init_content();
    init_document();
    init_flow();
    init_text();
    init_create_tokenizer();
    init_constructs();
  }
});

// node_modules/mdast-util-from-markdown/node_modules/micromark/dev/lib/preprocess.js
function preprocess() {
  let column = 1;
  let buffer2 = "";
  let start = true;
  let atCarriageReturn;
  return preprocessor;
  function preprocessor(value, encoding, end) {
    const chunks = [];
    let match;
    let next;
    let startPosition;
    let endPosition;
    let code2;
    value = buffer2 + value.toString(encoding);
    startPosition = 0;
    buffer2 = "";
    if (start) {
      if (value.charCodeAt(0) === codes.byteOrderMarker) {
        startPosition++;
      }
      start = void 0;
    }
    while (startPosition < value.length) {
      search.lastIndex = startPosition;
      match = search.exec(value);
      endPosition = match && match.index !== void 0 ? match.index : value.length;
      code2 = value.charCodeAt(endPosition);
      if (!match) {
        buffer2 = value.slice(startPosition);
        break;
      }
      if (code2 === codes.lf && startPosition === endPosition && atCarriageReturn) {
        chunks.push(codes.carriageReturnLineFeed);
        atCarriageReturn = void 0;
      } else {
        if (atCarriageReturn) {
          chunks.push(codes.carriageReturn);
          atCarriageReturn = void 0;
        }
        if (startPosition < endPosition) {
          chunks.push(value.slice(startPosition, endPosition));
          column += endPosition - startPosition;
        }
        switch (code2) {
          case codes.nul: {
            chunks.push(codes.replacementCharacter);
            column++;
            break;
          }
          case codes.ht: {
            next = Math.ceil(column / constants.tabSize) * constants.tabSize;
            chunks.push(codes.horizontalTab);
            while (column++ < next) chunks.push(codes.virtualSpace);
            break;
          }
          case codes.lf: {
            chunks.push(codes.lineFeed);
            column = 1;
            break;
          }
          default: {
            atCarriageReturn = true;
            column = 1;
          }
        }
      }
      startPosition = endPosition + 1;
    }
    if (end) {
      if (atCarriageReturn) chunks.push(codes.carriageReturn);
      if (buffer2) chunks.push(buffer2);
      chunks.push(codes.eof);
    }
    return chunks;
  }
}
var import_dist220, import_dist221, import_dist222, search;
var init_preprocess = __esm({
  "node_modules/mdast-util-from-markdown/node_modules/micromark/dev/lib/preprocess.js"() {
    import_dist220 = __toESM(require_dist());
    import_dist221 = __toESM(require_dist2());
    import_dist222 = __toESM(require_dist3());
    init_codes();
    init_constants();
    search = /[\0\t\n\r]/g;
  }
});

// node_modules/mdast-util-from-markdown/node_modules/micromark/dev/lib/postprocess.js
function postprocess(events) {
  while (!subtokenize(events)) {
  }
  return events;
}
var import_dist223, import_dist224, import_dist225;
var init_postprocess = __esm({
  "node_modules/mdast-util-from-markdown/node_modules/micromark/dev/lib/postprocess.js"() {
    import_dist223 = __toESM(require_dist());
    import_dist224 = __toESM(require_dist2());
    import_dist225 = __toESM(require_dist3());
    init_dev5();
  }
});

// node_modules/micromark-util-decode-numeric-character-reference/dev/index.js
function decodeNumericCharacterReference(value, base2) {
  const code2 = Number.parseInt(value, base2);
  if (
    // C0 except for HT, LF, FF, CR, space.
    code2 < codes.ht || code2 === codes.vt || code2 > codes.cr && code2 < codes.space || // Control character (DEL) of C0, and C1 controls.
    code2 > codes.tilde && code2 < 160 || // Lone high surrogates and low surrogates.
    code2 > 55295 && code2 < 57344 || // Noncharacters.
    code2 > 64975 && code2 < 65008 || /* eslint-disable no-bitwise */
    (code2 & 65535) === 65535 || (code2 & 65535) === 65534 || /* eslint-enable no-bitwise */
    // Out of range
    code2 > 1114111
  ) {
    return values.replacementCharacter;
  }
  return String.fromCharCode(code2);
}
var import_dist226, import_dist227, import_dist228;
var init_dev12 = __esm({
  "node_modules/micromark-util-decode-numeric-character-reference/dev/index.js"() {
    import_dist226 = __toESM(require_dist());
    import_dist227 = __toESM(require_dist2());
    import_dist228 = __toESM(require_dist3());
    init_codes();
    init_values();
  }
});

// node_modules/micromark-util-decode-string/dev/index.js
function decodeString(value) {
  return value.replace(characterEscapeOrReference, decode);
}
function decode($0, $1, $2) {
  if ($1) {
    return $1;
  }
  const head = $2.charCodeAt(0);
  if (head === codes.numberSign) {
    const head2 = $2.charCodeAt(1);
    const hex = head2 === codes.lowercaseX || head2 === codes.uppercaseX;
    return decodeNumericCharacterReference(
      $2.slice(hex ? 2 : 1),
      hex ? constants.numericBaseHexadecimal : constants.numericBaseDecimal
    );
  }
  return decodeNamedCharacterReference($2) || $0;
}
var import_dist229, import_dist230, import_dist231, characterEscapeOrReference;
var init_dev13 = __esm({
  "node_modules/micromark-util-decode-string/dev/index.js"() {
    import_dist229 = __toESM(require_dist());
    import_dist230 = __toESM(require_dist2());
    import_dist231 = __toESM(require_dist3());
    init_index_dom();
    init_dev12();
    init_codes();
    init_constants();
    characterEscapeOrReference = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
  }
});

// node_modules/mdast-util-from-markdown/dev/lib/index.js
function compiler(options) {
  const config = {
    transforms: [],
    canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"],
    enter: {
      autolink: opener(link2),
      autolinkProtocol: onenterdata,
      autolinkEmail: onenterdata,
      atxHeading: opener(heading2),
      blockQuote: opener(blockQuote2),
      characterEscape: onenterdata,
      characterReference: onenterdata,
      codeFenced: opener(codeFlow),
      codeFencedFenceInfo: buffer2,
      codeFencedFenceMeta: buffer2,
      codeIndented: opener(codeFlow, buffer2),
      codeText: opener(codeText2, buffer2),
      codeTextData: onenterdata,
      data: onenterdata,
      codeFlowValue: onenterdata,
      definition: opener(definition2),
      definitionDestinationString: buffer2,
      definitionLabelString: buffer2,
      definitionTitleString: buffer2,
      emphasis: opener(emphasis2),
      hardBreakEscape: opener(hardBreak2),
      hardBreakTrailing: opener(hardBreak2),
      htmlFlow: opener(html4, buffer2),
      htmlFlowData: onenterdata,
      htmlText: opener(html4, buffer2),
      htmlTextData: onenterdata,
      image: opener(image2),
      label: buffer2,
      link: opener(link2),
      listItem: opener(listItem2),
      listItemValue: onenterlistitemvalue,
      listOrdered: opener(list3, onenterlistordered),
      listUnordered: opener(list3),
      paragraph: opener(paragraph2),
      reference: onenterreference,
      referenceString: buffer2,
      resourceDestinationString: buffer2,
      resourceTitleString: buffer2,
      setextHeading: opener(heading2),
      strong: opener(strong2),
      thematicBreak: opener(thematicBreak3)
    },
    exit: {
      atxHeading: closer(),
      atxHeadingSequence: onexitatxheadingsequence,
      autolink: closer(),
      autolinkEmail: onexitautolinkemail,
      autolinkProtocol: onexitautolinkprotocol,
      blockQuote: closer(),
      characterEscapeValue: onexitdata,
      characterReferenceMarkerHexadecimal: onexitcharacterreferencemarker,
      characterReferenceMarkerNumeric: onexitcharacterreferencemarker,
      characterReferenceValue: onexitcharacterreferencevalue,
      codeFenced: closer(onexitcodefenced),
      codeFencedFence: onexitcodefencedfence,
      codeFencedFenceInfo: onexitcodefencedfenceinfo,
      codeFencedFenceMeta: onexitcodefencedfencemeta,
      codeFlowValue: onexitdata,
      codeIndented: closer(onexitcodeindented),
      codeText: closer(onexitcodetext),
      codeTextData: onexitdata,
      data: onexitdata,
      definition: closer(),
      definitionDestinationString: onexitdefinitiondestinationstring,
      definitionLabelString: onexitdefinitionlabelstring,
      definitionTitleString: onexitdefinitiontitlestring,
      emphasis: closer(),
      hardBreakEscape: closer(onexithardbreak),
      hardBreakTrailing: closer(onexithardbreak),
      htmlFlow: closer(onexithtmlflow),
      htmlFlowData: onexitdata,
      htmlText: closer(onexithtmltext),
      htmlTextData: onexitdata,
      image: closer(onexitimage),
      label: onexitlabel,
      labelText: onexitlabeltext,
      lineEnding: onexitlineending,
      link: closer(onexitlink),
      listItem: closer(),
      listOrdered: closer(),
      listUnordered: closer(),
      paragraph: closer(),
      referenceString: onexitreferencestring,
      resourceDestinationString: onexitresourcedestinationstring,
      resourceTitleString: onexitresourcetitlestring,
      resource: onexitresource,
      setextHeading: closer(onexitsetextheading),
      setextHeadingLineSequence: onexitsetextheadinglinesequence,
      setextHeadingText: onexitsetextheadingtext,
      strong: closer(),
      thematicBreak: closer()
    }
  };
  configure(config, (options || {}).mdastExtensions || []);
  const data = {};
  return compile;
  function compile(events) {
    let tree = { type: "root", children: [] };
    const context = {
      stack: [tree],
      tokenStack: [],
      config,
      enter,
      exit: exit2,
      buffer: buffer2,
      resume,
      setData,
      getData
    };
    const listStack = [];
    let index2 = -1;
    while (++index2 < events.length) {
      if (events[index2][1].type === types.listOrdered || events[index2][1].type === types.listUnordered) {
        if (events[index2][0] === "enter") {
          listStack.push(index2);
        } else {
          const tail = listStack.pop();
          ok(typeof tail === "number", "expected list ot be open");
          index2 = prepareList(events, tail, index2);
        }
      }
    }
    index2 = -1;
    while (++index2 < events.length) {
      const handler = config[events[index2][0]];
      if (own2.call(handler, events[index2][1].type)) {
        handler[events[index2][1].type].call(
          Object.assign(
            { sliceSerialize: events[index2][2].sliceSerialize },
            context
          ),
          events[index2][1]
        );
      }
    }
    if (context.tokenStack.length > 0) {
      const tail = context.tokenStack[context.tokenStack.length - 1];
      const handler = tail[1] || defaultOnError;
      handler.call(context, void 0, tail[0]);
    }
    tree.position = {
      start: point2(
        events.length > 0 ? events[0][1].start : { line: 1, column: 1, offset: 0 }
      ),
      end: point2(
        events.length > 0 ? events[events.length - 2][1].end : { line: 1, column: 1, offset: 0 }
      )
    };
    index2 = -1;
    while (++index2 < config.transforms.length) {
      tree = config.transforms[index2](tree) || tree;
    }
    return tree;
  }
  function prepareList(events, start, length) {
    let index2 = start - 1;
    let containerBalance = -1;
    let listSpread = false;
    let listItem3;
    let lineIndex;
    let firstBlankLineIndex;
    let atMarker;
    while (++index2 <= length) {
      const event = events[index2];
      if (event[1].type === types.listUnordered || event[1].type === types.listOrdered || event[1].type === types.blockQuote) {
        if (event[0] === "enter") {
          containerBalance++;
        } else {
          containerBalance--;
        }
        atMarker = void 0;
      } else if (event[1].type === types.lineEndingBlank) {
        if (event[0] === "enter") {
          if (listItem3 && !atMarker && !containerBalance && !firstBlankLineIndex) {
            firstBlankLineIndex = index2;
          }
          atMarker = void 0;
        }
      } else if (event[1].type === types.linePrefix || event[1].type === types.listItemValue || event[1].type === types.listItemMarker || event[1].type === types.listItemPrefix || event[1].type === types.listItemPrefixWhitespace) {
      } else {
        atMarker = void 0;
      }
      if (!containerBalance && event[0] === "enter" && event[1].type === types.listItemPrefix || containerBalance === -1 && event[0] === "exit" && (event[1].type === types.listUnordered || event[1].type === types.listOrdered)) {
        if (listItem3) {
          let tailIndex = index2;
          lineIndex = void 0;
          while (tailIndex--) {
            const tailEvent = events[tailIndex];
            if (tailEvent[1].type === types.lineEnding || tailEvent[1].type === types.lineEndingBlank) {
              if (tailEvent[0] === "exit") continue;
              if (lineIndex) {
                events[lineIndex][1].type = types.lineEndingBlank;
                listSpread = true;
              }
              tailEvent[1].type = types.lineEnding;
              lineIndex = tailIndex;
            } else if (tailEvent[1].type === types.linePrefix || tailEvent[1].type === types.blockQuotePrefix || tailEvent[1].type === types.blockQuotePrefixWhitespace || tailEvent[1].type === types.blockQuoteMarker || tailEvent[1].type === types.listItemIndent) {
            } else {
              break;
            }
          }
          if (firstBlankLineIndex && (!lineIndex || firstBlankLineIndex < lineIndex)) {
            listItem3._spread = true;
          }
          listItem3.end = Object.assign(
            {},
            lineIndex ? events[lineIndex][1].start : event[1].end
          );
          events.splice(lineIndex || index2, 0, ["exit", listItem3, event[2]]);
          index2++;
          length++;
        }
        if (event[1].type === types.listItemPrefix) {
          listItem3 = {
            type: "listItem",
            _spread: false,
            start: Object.assign({}, event[1].start),
            // @ts-expect-error: well add `end` in a second.
            end: void 0
          };
          events.splice(index2, 0, ["enter", listItem3, event[2]]);
          index2++;
          length++;
          firstBlankLineIndex = void 0;
          atMarker = true;
        }
      }
    }
    events[start][1]._spread = listSpread;
    return length;
  }
  function setData(key, value) {
    data[key] = value;
  }
  function getData(key) {
    return data[key];
  }
  function opener(create2, and) {
    return open;
    function open(token) {
      enter.call(this, create2(token), token);
      if (and) and.call(this, token);
    }
  }
  function buffer2() {
    this.stack.push({ type: "fragment", children: [] });
  }
  function enter(node2, token, errorHandler) {
    const parent = this.stack[this.stack.length - 1];
    ok(parent, "expected `parent`");
    ok("children" in parent, "expected `parent`");
    parent.children.push(node2);
    this.stack.push(node2);
    this.tokenStack.push([token, errorHandler]);
    node2.position = { start: point2(token.start) };
    return node2;
  }
  function closer(and) {
    return close;
    function close(token) {
      if (and) and.call(this, token);
      exit2.call(this, token);
    }
  }
  function exit2(token, onExitError) {
    const node2 = this.stack.pop();
    ok(node2, "expected `node`");
    const open = this.tokenStack.pop();
    if (!open) {
      throw new Error(
        "Cannot close `" + token.type + "` (" + stringifyPosition({ start: token.start, end: token.end }) + "): its not open"
      );
    } else if (open[0].type !== token.type) {
      if (onExitError) {
        onExitError.call(this, token, open[0]);
      } else {
        const handler = open[1] || defaultOnError;
        handler.call(this, token, open[0]);
      }
    }
    ok(node2.type !== "fragment", "unexpected fragment `exit`ed");
    ok(node2.position, "expected `position` to be defined");
    node2.position.end = point2(token.end);
    return node2;
  }
  function resume() {
    return toString(this.stack.pop());
  }
  function onenterlistordered() {
    setData("expectingFirstListItemValue", true);
  }
  function onenterlistitemvalue(token) {
    if (getData("expectingFirstListItemValue")) {
      const ancestor = this.stack[this.stack.length - 2];
      ok(ancestor, "expected nodes on stack");
      ok(ancestor.type === "list", "expected list on stack");
      ancestor.start = Number.parseInt(
        this.sliceSerialize(token),
        constants.numericBaseDecimal
      );
      setData("expectingFirstListItemValue");
    }
  }
  function onexitcodefencedfenceinfo() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "code", "expected code on stack");
    node2.lang = data2;
  }
  function onexitcodefencedfencemeta() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "code", "expected code on stack");
    node2.meta = data2;
  }
  function onexitcodefencedfence() {
    if (getData("flowCodeInside")) return;
    this.buffer();
    setData("flowCodeInside", true);
  }
  function onexitcodefenced() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "code", "expected code on stack");
    node2.value = data2.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, "");
    setData("flowCodeInside");
  }
  function onexitcodeindented() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "code", "expected code on stack");
    node2.value = data2.replace(/(\r?\n|\r)$/g, "");
  }
  function onexitdefinitionlabelstring(token) {
    const label = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "definition", "expected definition on stack");
    node2.label = label;
    node2.identifier = normalizeIdentifier(
      this.sliceSerialize(token)
    ).toLowerCase();
  }
  function onexitdefinitiontitlestring() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "definition", "expected definition on stack");
    node2.title = data2;
  }
  function onexitdefinitiondestinationstring() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "definition", "expected definition on stack");
    node2.url = data2;
  }
  function onexitatxheadingsequence(token) {
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "heading", "expected heading on stack");
    if (!node2.depth) {
      const depth = this.sliceSerialize(token).length;
      ok(
        depth === 1 || depth === 2 || depth === 3 || depth === 4 || depth === 5 || depth === 6,
        "expected `depth` between `1` and `6`"
      );
      node2.depth = depth;
    }
  }
  function onexitsetextheadingtext() {
    setData("setextHeadingSlurpLineEnding", true);
  }
  function onexitsetextheadinglinesequence(token) {
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "heading", "expected heading on stack");
    node2.depth = this.sliceSerialize(token).charCodeAt(0) === codes.equalsTo ? 1 : 2;
  }
  function onexitsetextheading() {
    setData("setextHeadingSlurpLineEnding");
  }
  function onenterdata(token) {
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok("children" in node2, "expected parent on stack");
    let tail = node2.children[node2.children.length - 1];
    if (!tail || tail.type !== "text") {
      tail = text4();
      tail.position = { start: point2(token.start) };
      node2.children.push(tail);
    }
    this.stack.push(tail);
  }
  function onexitdata(token) {
    const tail = this.stack.pop();
    ok(tail, "expected a `node` to be on the stack");
    ok("value" in tail, "expected a `literal` to be on the stack");
    ok(tail.position, "expected `node` to have an open position");
    tail.value += this.sliceSerialize(token);
    tail.position.end = point2(token.end);
  }
  function onexitlineending(token) {
    const context = this.stack[this.stack.length - 1];
    ok(context, "expected `node`");
    if (getData("atHardBreak")) {
      ok("children" in context, "expected `parent`");
      const tail = context.children[context.children.length - 1];
      ok(tail.position, "expected tail to have a starting position");
      tail.position.end = point2(token.end);
      setData("atHardBreak");
      return;
    }
    if (!getData("setextHeadingSlurpLineEnding") && config.canContainEols.includes(context.type)) {
      onenterdata.call(this, token);
      onexitdata.call(this, token);
    }
  }
  function onexithardbreak() {
    setData("atHardBreak", true);
  }
  function onexithtmlflow() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "html", "expected html on stack");
    node2.value = data2;
  }
  function onexithtmltext() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "html", "expected html on stack");
    node2.value = data2;
  }
  function onexitcodetext() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "inlineCode", "expected inline code on stack");
    node2.value = data2;
  }
  function onexitlink() {
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "link", "expected link on stack");
    if (getData("inReference")) {
      const referenceType = getData("referenceType") || "shortcut";
      node2.type += "Reference";
      node2.referenceType = referenceType;
      delete node2.url;
      delete node2.title;
    } else {
      delete node2.identifier;
      delete node2.label;
    }
    setData("referenceType");
  }
  function onexitimage() {
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "image", "expected image on stack");
    if (getData("inReference")) {
      const referenceType = getData("referenceType") || "shortcut";
      node2.type += "Reference";
      node2.referenceType = referenceType;
      delete node2.url;
      delete node2.title;
    } else {
      delete node2.identifier;
      delete node2.label;
    }
    setData("referenceType");
  }
  function onexitlabeltext(token) {
    const string3 = this.sliceSerialize(token);
    const ancestor = this.stack[this.stack.length - 2];
    ok(ancestor, "expected ancestor on stack");
    ok(
      ancestor.type === "image" || ancestor.type === "link",
      "expected image or link on stack"
    );
    ancestor.label = decodeString(string3);
    ancestor.identifier = normalizeIdentifier(string3).toLowerCase();
  }
  function onexitlabel() {
    const fragment = this.stack[this.stack.length - 1];
    ok(fragment, "expected node on stack");
    ok(fragment.type === "fragment", "expected fragment on stack");
    const value = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(
      node2.type === "image" || node2.type === "link",
      "expected image or link on stack"
    );
    setData("inReference", true);
    if (node2.type === "link") {
      const children = fragment.children;
      node2.children = children;
    } else {
      node2.alt = value;
    }
  }
  function onexitresourcedestinationstring() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(
      node2.type === "image" || node2.type === "link",
      "expected image or link on stack"
    );
    node2.url = data2;
  }
  function onexitresourcetitlestring() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(
      node2.type === "image" || node2.type === "link",
      "expected image or link on stack"
    );
    node2.title = data2;
  }
  function onexitresource() {
    setData("inReference");
  }
  function onenterreference() {
    setData("referenceType", "collapsed");
  }
  function onexitreferencestring(token) {
    const label = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(
      node2.type === "image" || node2.type === "link",
      "expected image reference or link reference on stack"
    );
    node2.label = label;
    node2.identifier = normalizeIdentifier(
      this.sliceSerialize(token)
    ).toLowerCase();
    setData("referenceType", "full");
  }
  function onexitcharacterreferencemarker(token) {
    ok(
      token.type === "characterReferenceMarkerNumeric" || token.type === "characterReferenceMarkerHexadecimal"
    );
    setData("characterReferenceType", token.type);
  }
  function onexitcharacterreferencevalue(token) {
    const data2 = this.sliceSerialize(token);
    const type = getData("characterReferenceType");
    let value;
    if (type) {
      value = decodeNumericCharacterReference(
        data2,
        type === types.characterReferenceMarkerNumeric ? constants.numericBaseDecimal : constants.numericBaseHexadecimal
      );
      setData("characterReferenceType");
    } else {
      const result = decodeNamedCharacterReference(data2);
      ok(result !== false, "expected reference to decode");
      value = result;
    }
    const tail = this.stack.pop();
    ok(tail, "expected `node`");
    ok(tail.position, "expected `node.position`");
    ok("value" in tail, "expected `node.value`");
    tail.value += value;
    tail.position.end = point2(token.end);
  }
  function onexitautolinkprotocol(token) {
    onexitdata.call(this, token);
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "link", "expected link on stack");
    node2.url = this.sliceSerialize(token);
  }
  function onexitautolinkemail(token) {
    onexitdata.call(this, token);
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "link", "expected link on stack");
    node2.url = "mailto:" + this.sliceSerialize(token);
  }
  function blockQuote2() {
    return { type: "blockquote", children: [] };
  }
  function codeFlow() {
    return { type: "code", lang: null, meta: null, value: "" };
  }
  function codeText2() {
    return { type: "inlineCode", value: "" };
  }
  function definition2() {
    return {
      type: "definition",
      identifier: "",
      label: null,
      title: null,
      url: ""
    };
  }
  function emphasis2() {
    return { type: "emphasis", children: [] };
  }
  function heading2() {
    return { type: "heading", depth: void 0, children: [] };
  }
  function hardBreak2() {
    return { type: "break" };
  }
  function html4() {
    return { type: "html", value: "" };
  }
  function image2() {
    return { type: "image", title: null, url: "", alt: null };
  }
  function link2() {
    return { type: "link", title: null, url: "", children: [] };
  }
  function list3(token) {
    return {
      type: "list",
      ordered: token.type === "listOrdered",
      start: null,
      spread: token._spread,
      children: []
    };
  }
  function listItem2(token) {
    return {
      type: "listItem",
      spread: token._spread,
      checked: null,
      children: []
    };
  }
  function paragraph2() {
    return { type: "paragraph", children: [] };
  }
  function strong2() {
    return { type: "strong", children: [] };
  }
  function text4() {
    return { type: "text", value: "" };
  }
  function thematicBreak3() {
    return { type: "thematicBreak" };
  }
}
function point2(d) {
  return { line: d.line, column: d.column, offset: d.offset };
}
function configure(combined, extensions) {
  let index2 = -1;
  while (++index2 < extensions.length) {
    const value = extensions[index2];
    if (Array.isArray(value)) {
      configure(combined, value);
    } else {
      extension(combined, value);
    }
  }
}
function extension(combined, extension2) {
  let key;
  for (key in extension2) {
    if (own2.call(extension2, key)) {
      if (key === "canContainEols") {
        const right = extension2[key];
        if (right) {
          combined[key].push(...right);
        }
      } else if (key === "transforms") {
        const right = extension2[key];
        if (right) {
          combined[key].push(...right);
        }
      } else if (key === "enter" || key === "exit") {
        const right = extension2[key];
        if (right) {
          Object.assign(combined[key], right);
        }
      }
    }
  }
}
function defaultOnError(left, right) {
  if (left) {
    throw new Error(
      "Cannot close `" + left.type + "` (" + stringifyPosition({ start: left.start, end: left.end }) + "): a different token (`" + right.type + "`, " + stringifyPosition({ start: right.start, end: right.end }) + ") is open"
    );
  } else {
    throw new Error(
      "Cannot close document, a token (`" + right.type + "`, " + stringifyPosition({ start: right.start, end: right.end }) + ") is still open"
    );
  }
}
var import_dist232, import_dist233, import_dist234, own2, fromMarkdown;
var init_lib8 = __esm({
  "node_modules/mdast-util-from-markdown/dev/lib/index.js"() {
    import_dist232 = __toESM(require_dist(), 1);
    import_dist233 = __toESM(require_dist2(), 1);
    import_dist234 = __toESM(require_dist3(), 1);
    init_assert();
    init_mdast_util_to_string();
    init_parse();
    init_preprocess();
    init_postprocess();
    init_dev12();
    init_dev13();
    init_dev10();
    init_codes();
    init_constants();
    init_types();
    init_index_dom();
    init_unist_util_stringify_position();
    own2 = {}.hasOwnProperty;
    fromMarkdown = /**
     * @type {(
     *   ((value: Value, encoding: Encoding, options?: Options | null | undefined) => Root) &
     *   ((value: Value, options?: Options | null | undefined) => Root)
     * )}
     */
    /**
     * @param {Value} value
     * @param {Encoding | Options | null | undefined} [encoding]
     * @param {Options | null | undefined} [options]
     * @returns {Root}
     */
    (function(value, encoding, options) {
      if (typeof encoding !== "string") {
        options = encoding;
        encoding = void 0;
      }
      return compiler(options)(
        postprocess(
          parse(options).document().write(preprocess()(value, encoding, true))
        )
      );
    });
  }
});

// node_modules/mdast-util-from-markdown/dev/index.js
var import_dist235, import_dist236, import_dist237;
var init_dev14 = __esm({
  "node_modules/mdast-util-from-markdown/dev/index.js"() {
    import_dist235 = __toESM(require_dist());
    import_dist236 = __toESM(require_dist2());
    import_dist237 = __toESM(require_dist3());
    init_lib8();
  }
});

// node_modules/remark-parse/lib/index.js
function remarkParse(options) {
  const parser = (doc) => {
    const settings = (
      /** @type {Options} */
      this.data("settings")
    );
    return fromMarkdown(
      doc,
      Object.assign({}, settings, options, {
        // Note: these options are not in the readme.
        // The goal is for them to be set by plugins on `data` instead of being
        // passed by users.
        extensions: this.data("micromarkExtensions") || [],
        mdastExtensions: this.data("fromMarkdownExtensions") || []
      })
    );
  };
  Object.assign(this, { Parser: parser });
}
var import_dist238, import_dist239, import_dist240;
var init_lib9 = __esm({
  "node_modules/remark-parse/lib/index.js"() {
    import_dist238 = __toESM(require_dist(), 1);
    import_dist239 = __toESM(require_dist2(), 1);
    import_dist240 = __toESM(require_dist3(), 1);
    init_dev14();
  }
});

// node_modules/remark-parse/index.js
var import_dist241, import_dist242, import_dist243;
var init_remark_parse = __esm({
  "node_modules/remark-parse/index.js"() {
    import_dist241 = __toESM(require_dist());
    import_dist242 = __toESM(require_dist2());
    import_dist243 = __toESM(require_dist3());
    init_lib9();
  }
});

// node_modules/mdast-util-to-hast/lib/handlers/blockquote.js
function blockquote(state, node2) {
  const result = {
    type: "element",
    tagName: "blockquote",
    properties: {},
    children: state.wrap(state.all(node2), true)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
var import_dist244, import_dist245, import_dist246;
var init_blockquote = __esm({
  "node_modules/mdast-util-to-hast/lib/handlers/blockquote.js"() {
    import_dist244 = __toESM(require_dist(), 1);
    import_dist245 = __toESM(require_dist2(), 1);
    import_dist246 = __toESM(require_dist3(), 1);
  }
});

// node_modules/mdast-util-to-hast/lib/handlers/break.js
function hardBreak(state, node2) {
  const result = { type: "element", tagName: "br", properties: {}, children: [] };
  state.patch(node2, result);
  return [state.applyData(node2, result), { type: "text", value: "\n" }];
}
var import_dist247, import_dist248, import_dist249;
var init_break = __esm({
  "node_modules/mdast-util-to-hast/lib/handlers/break.js"() {
    import_dist247 = __toESM(require_dist(), 1);
    import_dist248 = __toESM(require_dist2(), 1);
    import_dist249 = __toESM(require_dist3(), 1);
  }
});

// node_modules/mdast-util-to-hast/lib/handlers/code.js
function code(state, node2) {
  const value = node2.value ? node2.value + "\n" : "";
  const lang = node2.lang ? node2.lang.match(/^[^ \t]+(?=[ \t]|$)/) : null;
  const properties = {};
  if (lang) {
    properties.className = ["language-" + lang];
  }
  let result = {
    type: "element",
    tagName: "code",
    properties,
    children: [{ type: "text", value }]
  };
  if (node2.meta) {
    result.data = { meta: node2.meta };
  }
  state.patch(node2, result);
  result = state.applyData(node2, result);
  result = { type: "element", tagName: "pre", properties: {}, children: [result] };
  state.patch(node2, result);
  return result;
}
var import_dist250, import_dist251, import_dist252;
var init_code = __esm({
  "node_modules/mdast-util-to-hast/lib/handlers/code.js"() {
    import_dist250 = __toESM(require_dist(), 1);
    import_dist251 = __toESM(require_dist2(), 1);
    import_dist252 = __toESM(require_dist3(), 1);
  }
});

// node_modules/mdast-util-to-hast/lib/handlers/delete.js
function strikethrough(state, node2) {
  const result = {
    type: "element",
    tagName: "del",
    properties: {},
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
var import_dist253, import_dist254, import_dist255;
var init_delete = __esm({
  "node_modules/mdast-util-to-hast/lib/handlers/delete.js"() {
    import_dist253 = __toESM(require_dist(), 1);
    import_dist254 = __toESM(require_dist2(), 1);
    import_dist255 = __toESM(require_dist3(), 1);
  }
});

// node_modules/mdast-util-to-hast/lib/handlers/emphasis.js
function emphasis(state, node2) {
  const result = {
    type: "element",
    tagName: "em",
    properties: {},
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
var import_dist256, import_dist257, import_dist258;
var init_emphasis = __esm({
  "node_modules/mdast-util-to-hast/lib/handlers/emphasis.js"() {
    import_dist256 = __toESM(require_dist(), 1);
    import_dist257 = __toESM(require_dist2(), 1);
    import_dist258 = __toESM(require_dist3(), 1);
  }
});

// node_modules/micromark-util-encode/index.js
var import_dist259, import_dist260, import_dist261;
var init_micromark_util_encode = __esm({
  "node_modules/micromark-util-encode/index.js"() {
    import_dist259 = __toESM(require_dist());
    import_dist260 = __toESM(require_dist2());
    import_dist261 = __toESM(require_dist3());
  }
});

// node_modules/micromark-util-sanitize-uri/dev/index.js
function normalizeUri(value) {
  const result = [];
  let index2 = -1;
  let start = 0;
  let skip = 0;
  while (++index2 < value.length) {
    const code2 = value.charCodeAt(index2);
    let replace = "";
    if (code2 === codes.percentSign && asciiAlphanumeric(value.charCodeAt(index2 + 1)) && asciiAlphanumeric(value.charCodeAt(index2 + 2))) {
      skip = 2;
    } else if (code2 < 128) {
      if (!/[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(code2))) {
        replace = String.fromCharCode(code2);
      }
    } else if (code2 > 55295 && code2 < 57344) {
      const next = value.charCodeAt(index2 + 1);
      if (code2 < 56320 && next > 56319 && next < 57344) {
        replace = String.fromCharCode(code2, next);
        skip = 1;
      } else {
        replace = values.replacementCharacter;
      }
    } else {
      replace = String.fromCharCode(code2);
    }
    if (replace) {
      result.push(value.slice(start, index2), encodeURIComponent(replace));
      start = index2 + skip + 1;
      replace = "";
    }
    if (skip) {
      index2 += skip;
      skip = 0;
    }
  }
  return result.join("") + value.slice(start);
}
var import_dist262, import_dist263, import_dist264;
var init_dev15 = __esm({
  "node_modules/micromark-util-sanitize-uri/dev/index.js"() {
    import_dist262 = __toESM(require_dist());
    import_dist263 = __toESM(require_dist2());
    import_dist264 = __toESM(require_dist3());
    init_dev2();
    init_micromark_util_encode();
    init_codes();
    init_values();
  }
});

// node_modules/mdast-util-to-hast/lib/handlers/footnote-reference.js
function footnoteReference(state, node2) {
  const id = String(node2.identifier).toUpperCase();
  const safeId = normalizeUri(id.toLowerCase());
  const index2 = state.footnoteOrder.indexOf(id);
  let counter;
  if (index2 === -1) {
    state.footnoteOrder.push(id);
    state.footnoteCounts[id] = 1;
    counter = state.footnoteOrder.length;
  } else {
    state.footnoteCounts[id]++;
    counter = index2 + 1;
  }
  const reuseCounter = state.footnoteCounts[id];
  const link2 = {
    type: "element",
    tagName: "a",
    properties: {
      href: "#" + state.clobberPrefix + "fn-" + safeId,
      id: state.clobberPrefix + "fnref-" + safeId + (reuseCounter > 1 ? "-" + reuseCounter : ""),
      dataFootnoteRef: true,
      ariaDescribedBy: ["footnote-label"]
    },
    children: [{ type: "text", value: String(counter) }]
  };
  state.patch(node2, link2);
  const sup = {
    type: "element",
    tagName: "sup",
    properties: {},
    children: [link2]
  };
  state.patch(node2, sup);
  return state.applyData(node2, sup);
}
var import_dist265, import_dist266, import_dist267;
var init_footnote_reference = __esm({
  "node_modules/mdast-util-to-hast/lib/handlers/footnote-reference.js"() {
    import_dist265 = __toESM(require_dist(), 1);
    import_dist266 = __toESM(require_dist2(), 1);
    import_dist267 = __toESM(require_dist3(), 1);
    init_dev15();
  }
});

// node_modules/mdast-util-to-hast/lib/handlers/footnote.js
function footnote(state, node2) {
  const footnoteById = state.footnoteById;
  let no = 1;
  while (no in footnoteById) no++;
  const identifier = String(no);
  footnoteById[identifier] = {
    type: "footnoteDefinition",
    identifier,
    children: [{ type: "paragraph", children: node2.children }],
    position: node2.position
  };
  return footnoteReference(state, {
    type: "footnoteReference",
    identifier,
    position: node2.position
  });
}
var import_dist268, import_dist269, import_dist270;
var init_footnote = __esm({
  "node_modules/mdast-util-to-hast/lib/handlers/footnote.js"() {
    import_dist268 = __toESM(require_dist(), 1);
    import_dist269 = __toESM(require_dist2(), 1);
    import_dist270 = __toESM(require_dist3(), 1);
    init_footnote_reference();
  }
});

// node_modules/mdast-util-to-hast/lib/handlers/heading.js
function heading(state, node2) {
  const result = {
    type: "element",
    tagName: "h" + node2.depth,
    properties: {},
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
var import_dist271, import_dist272, import_dist273;
var init_heading = __esm({
  "node_modules/mdast-util-to-hast/lib/handlers/heading.js"() {
    import_dist271 = __toESM(require_dist(), 1);
    import_dist272 = __toESM(require_dist2(), 1);
    import_dist273 = __toESM(require_dist3(), 1);
  }
});

// node_modules/mdast-util-to-hast/lib/handlers/html.js
function html(state, node2) {
  if (state.dangerous) {
    const result = { type: "raw", value: node2.value };
    state.patch(node2, result);
    return state.applyData(node2, result);
  }
  return null;
}
var import_dist274, import_dist275, import_dist276;
var init_html = __esm({
  "node_modules/mdast-util-to-hast/lib/handlers/html.js"() {
    import_dist274 = __toESM(require_dist(), 1);
    import_dist275 = __toESM(require_dist2(), 1);
    import_dist276 = __toESM(require_dist3(), 1);
  }
});

// node_modules/mdast-util-to-hast/lib/revert.js
function revert(state, node2) {
  const subtype = node2.referenceType;
  let suffix = "]";
  if (subtype === "collapsed") {
    suffix += "[]";
  } else if (subtype === "full") {
    suffix += "[" + (node2.label || node2.identifier) + "]";
  }
  if (node2.type === "imageReference") {
    return { type: "text", value: "![" + node2.alt + suffix };
  }
  const contents = state.all(node2);
  const head = contents[0];
  if (head && head.type === "text") {
    head.value = "[" + head.value;
  } else {
    contents.unshift({ type: "text", value: "[" });
  }
  const tail = contents[contents.length - 1];
  if (tail && tail.type === "text") {
    tail.value += suffix;
  } else {
    contents.push({ type: "text", value: suffix });
  }
  return contents;
}
var import_dist277, import_dist278, import_dist279;
var init_revert = __esm({
  "node_modules/mdast-util-to-hast/lib/revert.js"() {
    import_dist277 = __toESM(require_dist(), 1);
    import_dist278 = __toESM(require_dist2(), 1);
    import_dist279 = __toESM(require_dist3(), 1);
  }
});

// node_modules/mdast-util-to-hast/lib/handlers/image-reference.js
function imageReference(state, node2) {
  const def = state.definition(node2.identifier);
  if (!def) {
    return revert(state, node2);
  }
  const properties = { src: normalizeUri(def.url || ""), alt: node2.alt };
  if (def.title !== null && def.title !== void 0) {
    properties.title = def.title;
  }
  const result = { type: "element", tagName: "img", properties, children: [] };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
var import_dist280, import_dist281, import_dist282;
var init_image_reference = __esm({
  "node_modules/mdast-util-to-hast/lib/handlers/image-reference.js"() {
    import_dist280 = __toESM(require_dist(), 1);
    import_dist281 = __toESM(require_dist2(), 1);
    import_dist282 = __toESM(require_dist3(), 1);
    init_dev15();
    init_revert();
  }
});

// node_modules/mdast-util-to-hast/lib/handlers/image.js
function image(state, node2) {
  const properties = { src: normalizeUri(node2.url) };
  if (node2.alt !== null && node2.alt !== void 0) {
    properties.alt = node2.alt;
  }
  if (node2.title !== null && node2.title !== void 0) {
    properties.title = node2.title;
  }
  const result = { type: "element", tagName: "img", properties, children: [] };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
var import_dist283, import_dist284, import_dist285;
var init_image = __esm({
  "node_modules/mdast-util-to-hast/lib/handlers/image.js"() {
    import_dist283 = __toESM(require_dist(), 1);
    import_dist284 = __toESM(require_dist2(), 1);
    import_dist285 = __toESM(require_dist3(), 1);
    init_dev15();
  }
});

// node_modules/mdast-util-to-hast/lib/handlers/inline-code.js
function inlineCode(state, node2) {
  const text4 = { type: "text", value: node2.value.replace(/\r?\n|\r/g, " ") };
  state.patch(node2, text4);
  const result = {
    type: "element",
    tagName: "code",
    properties: {},
    children: [text4]
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
var import_dist286, import_dist287, import_dist288;
var init_inline_code = __esm({
  "node_modules/mdast-util-to-hast/lib/handlers/inline-code.js"() {
    import_dist286 = __toESM(require_dist(), 1);
    import_dist287 = __toESM(require_dist2(), 1);
    import_dist288 = __toESM(require_dist3(), 1);
  }
});

// node_modules/mdast-util-to-hast/lib/handlers/link-reference.js
function linkReference(state, node2) {
  const def = state.definition(node2.identifier);
  if (!def) {
    return revert(state, node2);
  }
  const properties = { href: normalizeUri(def.url || "") };
  if (def.title !== null && def.title !== void 0) {
    properties.title = def.title;
  }
  const result = {
    type: "element",
    tagName: "a",
    properties,
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
var import_dist289, import_dist290, import_dist291;
var init_link_reference = __esm({
  "node_modules/mdast-util-to-hast/lib/handlers/link-reference.js"() {
    import_dist289 = __toESM(require_dist(), 1);
    import_dist290 = __toESM(require_dist2(), 1);
    import_dist291 = __toESM(require_dist3(), 1);
    init_dev15();
    init_revert();
  }
});

// node_modules/mdast-util-to-hast/lib/handlers/link.js
function link(state, node2) {
  const properties = { href: normalizeUri(node2.url) };
  if (node2.title !== null && node2.title !== void 0) {
    properties.title = node2.title;
  }
  const result = {
    type: "element",
    tagName: "a",
    properties,
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
var import_dist292, import_dist293, import_dist294;
var init_link = __esm({
  "node_modules/mdast-util-to-hast/lib/handlers/link.js"() {
    import_dist292 = __toESM(require_dist(), 1);
    import_dist293 = __toESM(require_dist2(), 1);
    import_dist294 = __toESM(require_dist3(), 1);
    init_dev15();
  }
});

// node_modules/mdast-util-to-hast/lib/handlers/list-item.js
function listItem(state, node2, parent) {
  const results = state.all(node2);
  const loose = parent ? listLoose(parent) : listItemLoose(node2);
  const properties = {};
  const children = [];
  if (typeof node2.checked === "boolean") {
    const head = results[0];
    let paragraph2;
    if (head && head.type === "element" && head.tagName === "p") {
      paragraph2 = head;
    } else {
      paragraph2 = { type: "element", tagName: "p", properties: {}, children: [] };
      results.unshift(paragraph2);
    }
    if (paragraph2.children.length > 0) {
      paragraph2.children.unshift({ type: "text", value: " " });
    }
    paragraph2.children.unshift({
      type: "element",
      tagName: "input",
      properties: { type: "checkbox", checked: node2.checked, disabled: true },
      children: []
    });
    properties.className = ["task-list-item"];
  }
  let index2 = -1;
  while (++index2 < results.length) {
    const child = results[index2];
    if (loose || index2 !== 0 || child.type !== "element" || child.tagName !== "p") {
      children.push({ type: "text", value: "\n" });
    }
    if (child.type === "element" && child.tagName === "p" && !loose) {
      children.push(...child.children);
    } else {
      children.push(child);
    }
  }
  const tail = results[results.length - 1];
  if (tail && (loose || tail.type !== "element" || tail.tagName !== "p")) {
    children.push({ type: "text", value: "\n" });
  }
  const result = { type: "element", tagName: "li", properties, children };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function listLoose(node2) {
  let loose = false;
  if (node2.type === "list") {
    loose = node2.spread || false;
    const children = node2.children;
    let index2 = -1;
    while (!loose && ++index2 < children.length) {
      loose = listItemLoose(children[index2]);
    }
  }
  return loose;
}
function listItemLoose(node2) {
  const spread = node2.spread;
  return spread === void 0 || spread === null ? node2.children.length > 1 : spread;
}
var import_dist295, import_dist296, import_dist297;
var init_list_item = __esm({
  "node_modules/mdast-util-to-hast/lib/handlers/list-item.js"() {
    import_dist295 = __toESM(require_dist(), 1);
    import_dist296 = __toESM(require_dist2(), 1);
    import_dist297 = __toESM(require_dist3(), 1);
  }
});

// node_modules/mdast-util-to-hast/lib/handlers/list.js
function list2(state, node2) {
  const properties = {};
  const results = state.all(node2);
  let index2 = -1;
  if (typeof node2.start === "number" && node2.start !== 1) {
    properties.start = node2.start;
  }
  while (++index2 < results.length) {
    const child = results[index2];
    if (child.type === "element" && child.tagName === "li" && child.properties && Array.isArray(child.properties.className) && child.properties.className.includes("task-list-item")) {
      properties.className = ["contains-task-list"];
      break;
    }
  }
  const result = {
    type: "element",
    tagName: node2.ordered ? "ol" : "ul",
    properties,
    children: state.wrap(results, true)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
var import_dist298, import_dist299, import_dist300;
var init_list2 = __esm({
  "node_modules/mdast-util-to-hast/lib/handlers/list.js"() {
    import_dist298 = __toESM(require_dist(), 1);
    import_dist299 = __toESM(require_dist2(), 1);
    import_dist300 = __toESM(require_dist3(), 1);
  }
});

// node_modules/mdast-util-to-hast/lib/handlers/paragraph.js
function paragraph(state, node2) {
  const result = {
    type: "element",
    tagName: "p",
    properties: {},
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
var import_dist301, import_dist302, import_dist303;
var init_paragraph = __esm({
  "node_modules/mdast-util-to-hast/lib/handlers/paragraph.js"() {
    import_dist301 = __toESM(require_dist(), 1);
    import_dist302 = __toESM(require_dist2(), 1);
    import_dist303 = __toESM(require_dist3(), 1);
  }
});

// node_modules/mdast-util-to-hast/lib/handlers/root.js
function root(state, node2) {
  const result = { type: "root", children: state.wrap(state.all(node2)) };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
var import_dist304, import_dist305, import_dist306;
var init_root = __esm({
  "node_modules/mdast-util-to-hast/lib/handlers/root.js"() {
    import_dist304 = __toESM(require_dist(), 1);
    import_dist305 = __toESM(require_dist2(), 1);
    import_dist306 = __toESM(require_dist3(), 1);
  }
});

// node_modules/mdast-util-to-hast/lib/handlers/strong.js
function strong(state, node2) {
  const result = {
    type: "element",
    tagName: "strong",
    properties: {},
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
var import_dist307, import_dist308, import_dist309;
var init_strong = __esm({
  "node_modules/mdast-util-to-hast/lib/handlers/strong.js"() {
    import_dist307 = __toESM(require_dist(), 1);
    import_dist308 = __toESM(require_dist2(), 1);
    import_dist309 = __toESM(require_dist3(), 1);
  }
});

// node_modules/unist-util-position/lib/index.js
function position2(node2) {
  return { start: pointStart(node2), end: pointEnd(node2) };
}
function point3(type) {
  return point4;
  function point4(node2) {
    const point5 = node2 && node2.position && node2.position[type] || {};
    return {
      // @ts-expect-error: in practice, null is allowed.
      line: point5.line || null,
      // @ts-expect-error: in practice, null is allowed.
      column: point5.column || null,
      // @ts-expect-error: in practice, null is allowed.
      offset: point5.offset > -1 ? point5.offset : null
    };
  }
}
var import_dist310, import_dist311, import_dist312, pointStart, pointEnd;
var init_lib10 = __esm({
  "node_modules/unist-util-position/lib/index.js"() {
    import_dist310 = __toESM(require_dist(), 1);
    import_dist311 = __toESM(require_dist2(), 1);
    import_dist312 = __toESM(require_dist3(), 1);
    pointStart = point3("start");
    pointEnd = point3("end");
  }
});

// node_modules/unist-util-position/index.js
var import_dist313, import_dist314, import_dist315;
var init_unist_util_position = __esm({
  "node_modules/unist-util-position/index.js"() {
    import_dist313 = __toESM(require_dist());
    import_dist314 = __toESM(require_dist2());
    import_dist315 = __toESM(require_dist3());
    init_lib10();
  }
});

// node_modules/mdast-util-to-hast/lib/handlers/table.js
function table(state, node2) {
  const rows = state.all(node2);
  const firstRow = rows.shift();
  const tableContent = [];
  if (firstRow) {
    const head = {
      type: "element",
      tagName: "thead",
      properties: {},
      children: state.wrap([firstRow], true)
    };
    state.patch(node2.children[0], head);
    tableContent.push(head);
  }
  if (rows.length > 0) {
    const body = {
      type: "element",
      tagName: "tbody",
      properties: {},
      children: state.wrap(rows, true)
    };
    const start = pointStart(node2.children[1]);
    const end = pointEnd(node2.children[node2.children.length - 1]);
    if (start.line && end.line) body.position = { start, end };
    tableContent.push(body);
  }
  const result = {
    type: "element",
    tagName: "table",
    properties: {},
    children: state.wrap(tableContent, true)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
var import_dist316, import_dist317, import_dist318;
var init_table = __esm({
  "node_modules/mdast-util-to-hast/lib/handlers/table.js"() {
    import_dist316 = __toESM(require_dist(), 1);
    import_dist317 = __toESM(require_dist2(), 1);
    import_dist318 = __toESM(require_dist3(), 1);
    init_unist_util_position();
  }
});

// node_modules/mdast-util-to-hast/lib/handlers/table-row.js
function tableRow(state, node2, parent) {
  const siblings = parent ? parent.children : void 0;
  const rowIndex = siblings ? siblings.indexOf(node2) : 1;
  const tagName = rowIndex === 0 ? "th" : "td";
  const align = parent && parent.type === "table" ? parent.align : void 0;
  const length = align ? align.length : node2.children.length;
  let cellIndex = -1;
  const cells = [];
  while (++cellIndex < length) {
    const cell = node2.children[cellIndex];
    const properties = {};
    const alignValue = align ? align[cellIndex] : void 0;
    if (alignValue) {
      properties.align = alignValue;
    }
    let result2 = { type: "element", tagName, properties, children: [] };
    if (cell) {
      result2.children = state.all(cell);
      state.patch(cell, result2);
      result2 = state.applyData(node2, result2);
    }
    cells.push(result2);
  }
  const result = {
    type: "element",
    tagName: "tr",
    properties: {},
    children: state.wrap(cells, true)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
var import_dist319, import_dist320, import_dist321;
var init_table_row = __esm({
  "node_modules/mdast-util-to-hast/lib/handlers/table-row.js"() {
    import_dist319 = __toESM(require_dist(), 1);
    import_dist320 = __toESM(require_dist2(), 1);
    import_dist321 = __toESM(require_dist3(), 1);
  }
});

// node_modules/mdast-util-to-hast/lib/handlers/table-cell.js
function tableCell(state, node2) {
  const result = {
    type: "element",
    tagName: "td",
    // Assume body cell.
    properties: {},
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
var import_dist322, import_dist323, import_dist324;
var init_table_cell = __esm({
  "node_modules/mdast-util-to-hast/lib/handlers/table-cell.js"() {
    import_dist322 = __toESM(require_dist(), 1);
    import_dist323 = __toESM(require_dist2(), 1);
    import_dist324 = __toESM(require_dist3(), 1);
  }
});

// node_modules/trim-lines/index.js
function trimLines(value) {
  const source = String(value);
  const search2 = /\r?\n|\r/g;
  let match = search2.exec(source);
  let last = 0;
  const lines2 = [];
  while (match) {
    lines2.push(
      trimLine(source.slice(last, match.index), last > 0, true),
      match[0]
    );
    last = match.index + match[0].length;
    match = search2.exec(source);
  }
  lines2.push(trimLine(source.slice(last), last > 0, false));
  return lines2.join("");
}
function trimLine(value, start, end) {
  let startIndex = 0;
  let endIndex = value.length;
  if (start) {
    let code2 = value.codePointAt(startIndex);
    while (code2 === tab || code2 === space) {
      startIndex++;
      code2 = value.codePointAt(startIndex);
    }
  }
  if (end) {
    let code2 = value.codePointAt(endIndex - 1);
    while (code2 === tab || code2 === space) {
      endIndex--;
      code2 = value.codePointAt(endIndex - 1);
    }
  }
  return endIndex > startIndex ? value.slice(startIndex, endIndex) : "";
}
var import_dist325, import_dist326, import_dist327, tab, space;
var init_trim_lines = __esm({
  "node_modules/trim-lines/index.js"() {
    import_dist325 = __toESM(require_dist());
    import_dist326 = __toESM(require_dist2());
    import_dist327 = __toESM(require_dist3());
    tab = 9;
    space = 32;
  }
});

// node_modules/mdast-util-to-hast/lib/handlers/text.js
function text3(state, node2) {
  const result = { type: "text", value: trimLines(String(node2.value)) };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
var import_dist328, import_dist329, import_dist330;
var init_text2 = __esm({
  "node_modules/mdast-util-to-hast/lib/handlers/text.js"() {
    import_dist328 = __toESM(require_dist(), 1);
    import_dist329 = __toESM(require_dist2(), 1);
    import_dist330 = __toESM(require_dist3(), 1);
    init_trim_lines();
  }
});

// node_modules/mdast-util-to-hast/lib/handlers/thematic-break.js
function thematicBreak2(state, node2) {
  const result = {
    type: "element",
    tagName: "hr",
    properties: {},
    children: []
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
var import_dist331, import_dist332, import_dist333;
var init_thematic_break2 = __esm({
  "node_modules/mdast-util-to-hast/lib/handlers/thematic-break.js"() {
    import_dist331 = __toESM(require_dist(), 1);
    import_dist332 = __toESM(require_dist2(), 1);
    import_dist333 = __toESM(require_dist3(), 1);
  }
});

// node_modules/mdast-util-to-hast/lib/handlers/index.js
function ignore() {
  return null;
}
var import_dist334, import_dist335, import_dist336, handlers;
var init_handlers = __esm({
  "node_modules/mdast-util-to-hast/lib/handlers/index.js"() {
    import_dist334 = __toESM(require_dist(), 1);
    import_dist335 = __toESM(require_dist2(), 1);
    import_dist336 = __toESM(require_dist3(), 1);
    init_blockquote();
    init_break();
    init_code();
    init_delete();
    init_emphasis();
    init_footnote_reference();
    init_footnote();
    init_heading();
    init_html();
    init_image_reference();
    init_image();
    init_inline_code();
    init_link_reference();
    init_link();
    init_list_item();
    init_list2();
    init_paragraph();
    init_root();
    init_strong();
    init_table();
    init_table_row();
    init_table_cell();
    init_text2();
    init_thematic_break2();
    handlers = {
      blockquote,
      break: hardBreak,
      code,
      delete: strikethrough,
      emphasis,
      footnoteReference,
      footnote,
      heading,
      html,
      imageReference,
      image,
      inlineCode,
      linkReference,
      link,
      listItem,
      list: list2,
      paragraph,
      root,
      strong,
      table,
      tableCell,
      tableRow,
      text: text3,
      thematicBreak: thematicBreak2,
      toml: ignore,
      yaml: ignore,
      definition: ignore,
      footnoteDefinition: ignore
    };
  }
});

// node_modules/unist-util-visit/node_modules/unist-util-is/lib/index.js
function anyFactory(tests) {
  const checks2 = [];
  let index2 = -1;
  while (++index2 < tests.length) {
    checks2[index2] = convert(tests[index2]);
  }
  return castFactory(any);
  function any(...parameters) {
    let index3 = -1;
    while (++index3 < checks2.length) {
      if (checks2[index3].call(this, ...parameters)) return true;
    }
    return false;
  }
}
function propsFactory(check) {
  return castFactory(all3);
  function all3(node2) {
    let key;
    for (key in check) {
      if (node2[key] !== check[key]) return false;
    }
    return true;
  }
}
function typeFactory(check) {
  return castFactory(type);
  function type(node2) {
    return node2 && node2.type === check;
  }
}
function castFactory(check) {
  return assertion;
  function assertion(node2, ...parameters) {
    return Boolean(
      node2 && typeof node2 === "object" && "type" in node2 && // @ts-expect-error: fine.
      Boolean(check.call(this, node2, ...parameters))
    );
  }
}
function ok2() {
  return true;
}
var import_dist337, import_dist338, import_dist339, convert;
var init_lib11 = __esm({
  "node_modules/unist-util-visit/node_modules/unist-util-is/lib/index.js"() {
    import_dist337 = __toESM(require_dist(), 1);
    import_dist338 = __toESM(require_dist2(), 1);
    import_dist339 = __toESM(require_dist3(), 1);
    convert = /**
     * @type {(
     *   (<Kind extends Node>(test: PredicateTest<Kind>) => AssertPredicate<Kind>) &
     *   ((test?: Test) => AssertAnything)
     * )}
     */
    /**
     * @param {Test} [test]
     * @returns {AssertAnything}
     */
    (function(test) {
      if (test === void 0 || test === null) {
        return ok2;
      }
      if (typeof test === "string") {
        return typeFactory(test);
      }
      if (typeof test === "object") {
        return Array.isArray(test) ? anyFactory(test) : propsFactory(test);
      }
      if (typeof test === "function") {
        return castFactory(test);
      }
      throw new Error("Expected function, string, or object as test");
    });
  }
});

// node_modules/unist-util-visit/node_modules/unist-util-is/index.js
var import_dist340, import_dist341, import_dist342;
var init_unist_util_is = __esm({
  "node_modules/unist-util-visit/node_modules/unist-util-is/index.js"() {
    import_dist340 = __toESM(require_dist());
    import_dist341 = __toESM(require_dist2());
    import_dist342 = __toESM(require_dist3());
    init_lib11();
  }
});

// node_modules/unist-util-visit/node_modules/unist-util-visit-parents/lib/color.browser.js
function color(d) {
  return d;
}
var import_dist343, import_dist344, import_dist345;
var init_color_browser = __esm({
  "node_modules/unist-util-visit/node_modules/unist-util-visit-parents/lib/color.browser.js"() {
    import_dist343 = __toESM(require_dist(), 1);
    import_dist344 = __toESM(require_dist2(), 1);
    import_dist345 = __toESM(require_dist3(), 1);
  }
});

// node_modules/unist-util-visit/node_modules/unist-util-visit-parents/lib/index.js
function toResult(value) {
  if (Array.isArray(value)) {
    return value;
  }
  if (typeof value === "number") {
    return [CONTINUE, value];
  }
  return [value];
}
var import_dist346, import_dist347, import_dist348, CONTINUE, EXIT, SKIP, visitParents;
var init_lib12 = __esm({
  "node_modules/unist-util-visit/node_modules/unist-util-visit-parents/lib/index.js"() {
    import_dist346 = __toESM(require_dist(), 1);
    import_dist347 = __toESM(require_dist2(), 1);
    import_dist348 = __toESM(require_dist3(), 1);
    init_unist_util_is();
    init_color_browser();
    CONTINUE = true;
    EXIT = false;
    SKIP = "skip";
    visitParents = /**
     * @type {(
     *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: BuildVisitor<Tree, Check>, reverse?: boolean | null | undefined) => void) &
     *   (<Tree extends Node>(tree: Tree, visitor: BuildVisitor<Tree>, reverse?: boolean | null | undefined) => void)
     * )}
     */
    /**
     * @param {Node} tree
     * @param {Test} test
     * @param {Visitor<Node>} visitor
     * @param {boolean | null | undefined} [reverse]
     * @returns {void}
     */
    (function(tree, test, visitor, reverse) {
      if (typeof test === "function" && typeof visitor !== "function") {
        reverse = visitor;
        visitor = test;
        test = null;
      }
      const is3 = convert(test);
      const step = reverse ? -1 : 1;
      factory(tree, void 0, [])();
      function factory(node2, index2, parents) {
        const value = node2 && typeof node2 === "object" ? node2 : {};
        if (typeof value.type === "string") {
          const name = (
            // `hast`
            typeof value.tagName === "string" ? value.tagName : (
              // `xast`
              typeof value.name === "string" ? value.name : void 0
            )
          );
          Object.defineProperty(visit2, "name", {
            value: "node (" + color(node2.type + (name ? "<" + name + ">" : "")) + ")"
          });
        }
        return visit2;
        function visit2() {
          let result = [];
          let subresult;
          let offset;
          let grandparents;
          if (!test || is3(node2, index2, parents[parents.length - 1] || null)) {
            result = toResult(visitor(node2, parents));
            if (result[0] === EXIT) {
              return result;
            }
          }
          if (node2.children && result[0] !== SKIP) {
            offset = (reverse ? node2.children.length : -1) + step;
            grandparents = parents.concat(node2);
            while (offset > -1 && offset < node2.children.length) {
              subresult = factory(node2.children[offset], offset, grandparents)();
              if (subresult[0] === EXIT) {
                return subresult;
              }
              offset = typeof subresult[1] === "number" ? subresult[1] : offset + step;
            }
          }
          return result;
        }
      }
    });
  }
});

// node_modules/unist-util-visit/node_modules/unist-util-visit-parents/index.js
var import_dist349, import_dist350, import_dist351;
var init_unist_util_visit_parents = __esm({
  "node_modules/unist-util-visit/node_modules/unist-util-visit-parents/index.js"() {
    import_dist349 = __toESM(require_dist());
    import_dist350 = __toESM(require_dist2());
    import_dist351 = __toESM(require_dist3());
    init_lib12();
  }
});

// node_modules/unist-util-visit/lib/index.js
var import_dist352, import_dist353, import_dist354, visit;
var init_lib13 = __esm({
  "node_modules/unist-util-visit/lib/index.js"() {
    import_dist352 = __toESM(require_dist(), 1);
    import_dist353 = __toESM(require_dist2(), 1);
    import_dist354 = __toESM(require_dist3(), 1);
    init_unist_util_visit_parents();
    init_unist_util_visit_parents();
    visit = /**
     * @type {(
     *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: BuildVisitor<Tree, Check>, reverse?: boolean | null | undefined) => void) &
     *   (<Tree extends Node>(tree: Tree, visitor: BuildVisitor<Tree>, reverse?: boolean | null | undefined) => void)
     * )}
     */
    /**
     * @param {Node} tree
     * @param {Test} test
     * @param {Visitor} visitor
     * @param {boolean | null | undefined} [reverse]
     * @returns {void}
     */
    (function(tree, test, visitor, reverse) {
      if (typeof test === "function" && typeof visitor !== "function") {
        reverse = visitor;
        visitor = test;
        test = null;
      }
      visitParents(tree, test, overload, reverse);
      function overload(node2, parents) {
        const parent = parents[parents.length - 1];
        return visitor(
          node2,
          parent ? parent.children.indexOf(node2) : null,
          parent
        );
      }
    });
  }
});

// node_modules/unist-util-visit/index.js
var import_dist355, import_dist356, import_dist357;
var init_unist_util_visit = __esm({
  "node_modules/unist-util-visit/index.js"() {
    import_dist355 = __toESM(require_dist());
    import_dist356 = __toESM(require_dist2());
    import_dist357 = __toESM(require_dist3());
    init_lib13();
  }
});

// node_modules/unist-util-generated/lib/index.js
function generated(node2) {
  return !node2 || !node2.position || !node2.position.start || !node2.position.start.line || !node2.position.start.column || !node2.position.end || !node2.position.end.line || !node2.position.end.column;
}
var import_dist358, import_dist359, import_dist360;
var init_lib14 = __esm({
  "node_modules/unist-util-generated/lib/index.js"() {
    import_dist358 = __toESM(require_dist(), 1);
    import_dist359 = __toESM(require_dist2(), 1);
    import_dist360 = __toESM(require_dist3(), 1);
  }
});

// node_modules/unist-util-generated/index.js
var import_dist361, import_dist362, import_dist363;
var init_unist_util_generated = __esm({
  "node_modules/unist-util-generated/index.js"() {
    import_dist361 = __toESM(require_dist());
    import_dist362 = __toESM(require_dist2());
    import_dist363 = __toESM(require_dist3());
    init_lib14();
  }
});

// node_modules/mdast-util-definitions/lib/index.js
function definitions(tree) {
  const cache = /* @__PURE__ */ Object.create(null);
  if (!tree || !tree.type) {
    throw new Error("mdast-util-definitions expected node");
  }
  visit(tree, "definition", (definition3) => {
    const id = clean(definition3.identifier);
    if (id && !own3.call(cache, id)) {
      cache[id] = definition3;
    }
  });
  return definition2;
  function definition2(identifier) {
    const id = clean(identifier);
    return id && own3.call(cache, id) ? cache[id] : null;
  }
}
function clean(value) {
  return String(value || "").toUpperCase();
}
var import_dist364, import_dist365, import_dist366, own3;
var init_lib15 = __esm({
  "node_modules/mdast-util-definitions/lib/index.js"() {
    import_dist364 = __toESM(require_dist(), 1);
    import_dist365 = __toESM(require_dist2(), 1);
    import_dist366 = __toESM(require_dist3(), 1);
    init_unist_util_visit();
    own3 = {}.hasOwnProperty;
  }
});

// node_modules/mdast-util-definitions/index.js
var import_dist367, import_dist368, import_dist369;
var init_mdast_util_definitions = __esm({
  "node_modules/mdast-util-definitions/index.js"() {
    import_dist367 = __toESM(require_dist());
    import_dist368 = __toESM(require_dist2());
    import_dist369 = __toESM(require_dist3());
    init_lib15();
  }
});

// node_modules/mdast-util-to-hast/lib/state.js
function createState(tree, options) {
  const settings = options || {};
  const dangerous = settings.allowDangerousHtml || false;
  const footnoteById = {};
  state.dangerous = dangerous;
  state.clobberPrefix = settings.clobberPrefix === void 0 || settings.clobberPrefix === null ? "user-content-" : settings.clobberPrefix;
  state.footnoteLabel = settings.footnoteLabel || "Footnotes";
  state.footnoteLabelTagName = settings.footnoteLabelTagName || "h2";
  state.footnoteLabelProperties = settings.footnoteLabelProperties || {
    className: ["sr-only"]
  };
  state.footnoteBackLabel = settings.footnoteBackLabel || "Back to content";
  state.unknownHandler = settings.unknownHandler;
  state.passThrough = settings.passThrough;
  state.handlers = { ...handlers, ...settings.handlers };
  state.definition = definitions(tree);
  state.footnoteById = footnoteById;
  state.footnoteOrder = [];
  state.footnoteCounts = {};
  state.patch = patch;
  state.applyData = applyData;
  state.one = oneBound;
  state.all = allBound;
  state.wrap = wrap2;
  state.augment = augment;
  visit(tree, "footnoteDefinition", (definition2) => {
    const id = String(definition2.identifier).toUpperCase();
    if (!own4.call(footnoteById, id)) {
      footnoteById[id] = definition2;
    }
  });
  return state;
  function augment(left, right) {
    if (left && "data" in left && left.data) {
      const data = left.data;
      if (data.hName) {
        if (right.type !== "element") {
          right = {
            type: "element",
            tagName: "",
            properties: {},
            children: []
          };
        }
        right.tagName = data.hName;
      }
      if (right.type === "element" && data.hProperties) {
        right.properties = { ...right.properties, ...data.hProperties };
      }
      if ("children" in right && right.children && data.hChildren) {
        right.children = data.hChildren;
      }
    }
    if (left) {
      const ctx = "type" in left ? left : { position: left };
      if (!generated(ctx)) {
        right.position = { start: pointStart(ctx), end: pointEnd(ctx) };
      }
    }
    return right;
  }
  function state(node2, tagName, props, children) {
    if (Array.isArray(props)) {
      children = props;
      props = {};
    }
    return augment(node2, {
      type: "element",
      tagName,
      properties: props || {},
      children: children || []
    });
  }
  function oneBound(node2, parent) {
    return one2(state, node2, parent);
  }
  function allBound(parent) {
    return all2(state, parent);
  }
}
function patch(from, to) {
  if (from.position) to.position = position2(from);
}
function applyData(from, to) {
  let result = to;
  if (from && from.data) {
    const hName = from.data.hName;
    const hChildren = from.data.hChildren;
    const hProperties = from.data.hProperties;
    if (typeof hName === "string") {
      if (result.type === "element") {
        result.tagName = hName;
      } else {
        result = {
          type: "element",
          tagName: hName,
          properties: {},
          children: []
        };
      }
    }
    if (result.type === "element" && hProperties) {
      result.properties = { ...result.properties, ...hProperties };
    }
    if ("children" in result && result.children && hChildren !== null && hChildren !== void 0) {
      result.children = hChildren;
    }
  }
  return result;
}
function one2(state, node2, parent) {
  const type = node2 && node2.type;
  if (!type) {
    throw new Error("Expected node, got `" + node2 + "`");
  }
  if (own4.call(state.handlers, type)) {
    return state.handlers[type](state, node2, parent);
  }
  if (state.passThrough && state.passThrough.includes(type)) {
    return "children" in node2 ? { ...node2, children: all2(state, node2) } : node2;
  }
  if (state.unknownHandler) {
    return state.unknownHandler(state, node2, parent);
  }
  return defaultUnknownHandler(state, node2);
}
function all2(state, parent) {
  const values2 = [];
  if ("children" in parent) {
    const nodes = parent.children;
    let index2 = -1;
    while (++index2 < nodes.length) {
      const result = one2(state, nodes[index2], parent);
      if (result) {
        if (index2 && nodes[index2 - 1].type === "break") {
          if (!Array.isArray(result) && result.type === "text") {
            result.value = result.value.replace(/^\s+/, "");
          }
          if (!Array.isArray(result) && result.type === "element") {
            const head = result.children[0];
            if (head && head.type === "text") {
              head.value = head.value.replace(/^\s+/, "");
            }
          }
        }
        if (Array.isArray(result)) {
          values2.push(...result);
        } else {
          values2.push(result);
        }
      }
    }
  }
  return values2;
}
function defaultUnknownHandler(state, node2) {
  const data = node2.data || {};
  const result = "value" in node2 && !(own4.call(data, "hProperties") || own4.call(data, "hChildren")) ? { type: "text", value: node2.value } : {
    type: "element",
    tagName: "div",
    properties: {},
    children: all2(state, node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function wrap2(nodes, loose) {
  const result = [];
  let index2 = -1;
  if (loose) {
    result.push({ type: "text", value: "\n" });
  }
  while (++index2 < nodes.length) {
    if (index2) result.push({ type: "text", value: "\n" });
    result.push(nodes[index2]);
  }
  if (loose && nodes.length > 0) {
    result.push({ type: "text", value: "\n" });
  }
  return result;
}
var import_dist370, import_dist371, import_dist372, own4;
var init_state = __esm({
  "node_modules/mdast-util-to-hast/lib/state.js"() {
    import_dist370 = __toESM(require_dist(), 1);
    import_dist371 = __toESM(require_dist2(), 1);
    import_dist372 = __toESM(require_dist3(), 1);
    init_unist_util_visit();
    init_unist_util_position();
    init_unist_util_generated();
    init_mdast_util_definitions();
    init_handlers();
    own4 = {}.hasOwnProperty;
  }
});

// node_modules/mdast-util-to-hast/lib/footer.js
function footer(state) {
  const listItems = [];
  let index2 = -1;
  while (++index2 < state.footnoteOrder.length) {
    const def = state.footnoteById[state.footnoteOrder[index2]];
    if (!def) {
      continue;
    }
    const content3 = state.all(def);
    const id = String(def.identifier).toUpperCase();
    const safeId = normalizeUri(id.toLowerCase());
    let referenceIndex = 0;
    const backReferences = [];
    while (++referenceIndex <= state.footnoteCounts[id]) {
      const backReference = {
        type: "element",
        tagName: "a",
        properties: {
          href: "#" + state.clobberPrefix + "fnref-" + safeId + (referenceIndex > 1 ? "-" + referenceIndex : ""),
          dataFootnoteBackref: true,
          className: ["data-footnote-backref"],
          ariaLabel: state.footnoteBackLabel
        },
        children: [{ type: "text", value: "" }]
      };
      if (referenceIndex > 1) {
        backReference.children.push({
          type: "element",
          tagName: "sup",
          children: [{ type: "text", value: String(referenceIndex) }]
        });
      }
      if (backReferences.length > 0) {
        backReferences.push({ type: "text", value: " " });
      }
      backReferences.push(backReference);
    }
    const tail = content3[content3.length - 1];
    if (tail && tail.type === "element" && tail.tagName === "p") {
      const tailTail = tail.children[tail.children.length - 1];
      if (tailTail && tailTail.type === "text") {
        tailTail.value += " ";
      } else {
        tail.children.push({ type: "text", value: " " });
      }
      tail.children.push(...backReferences);
    } else {
      content3.push(...backReferences);
    }
    const listItem2 = {
      type: "element",
      tagName: "li",
      properties: { id: state.clobberPrefix + "fn-" + safeId },
      children: state.wrap(content3, true)
    };
    state.patch(def, listItem2);
    listItems.push(listItem2);
  }
  if (listItems.length === 0) {
    return;
  }
  return {
    type: "element",
    tagName: "section",
    properties: { dataFootnotes: true, className: ["footnotes"] },
    children: [
      {
        type: "element",
        tagName: state.footnoteLabelTagName,
        properties: {
          // To do: use structured clone.
          ...JSON.parse(JSON.stringify(state.footnoteLabelProperties)),
          id: "footnote-label"
        },
        children: [{ type: "text", value: state.footnoteLabel }]
      },
      { type: "text", value: "\n" },
      {
        type: "element",
        tagName: "ol",
        properties: {},
        children: state.wrap(listItems, true)
      },
      { type: "text", value: "\n" }
    ]
  };
}
var import_dist373, import_dist374, import_dist375;
var init_footer = __esm({
  "node_modules/mdast-util-to-hast/lib/footer.js"() {
    import_dist373 = __toESM(require_dist(), 1);
    import_dist374 = __toESM(require_dist2(), 1);
    import_dist375 = __toESM(require_dist3(), 1);
    init_dev15();
  }
});

// node_modules/mdast-util-to-hast/lib/index.js
function toHast(tree, options) {
  const state = createState(tree, options);
  const node2 = state.one(tree, null);
  const foot = footer(state);
  if (foot) {
    node2.children.push({ type: "text", value: "\n" }, foot);
  }
  return Array.isArray(node2) ? { type: "root", children: node2 } : node2;
}
var import_dist376, import_dist377, import_dist378;
var init_lib16 = __esm({
  "node_modules/mdast-util-to-hast/lib/index.js"() {
    import_dist376 = __toESM(require_dist(), 1);
    import_dist377 = __toESM(require_dist2(), 1);
    import_dist378 = __toESM(require_dist3(), 1);
    init_footer();
    init_state();
  }
});

// node_modules/mdast-util-to-hast/index.js
var import_dist379, import_dist380, import_dist381;
var init_mdast_util_to_hast = __esm({
  "node_modules/mdast-util-to-hast/index.js"() {
    import_dist379 = __toESM(require_dist());
    import_dist380 = __toESM(require_dist2());
    import_dist381 = __toESM(require_dist3());
    init_handlers();
    init_state();
    init_lib16();
  }
});

// node_modules/remark-rehype/lib/index.js
function bridge(destination, options) {
  return (node2, file, next) => {
    destination.run(toHast(node2, options), file, (error) => {
      next(error);
    });
  };
}
function mutate(options) {
  return (node2) => toHast(node2, options);
}
var import_dist382, import_dist383, import_dist384, remarkRehype, lib_default;
var init_lib17 = __esm({
  "node_modules/remark-rehype/lib/index.js"() {
    import_dist382 = __toESM(require_dist(), 1);
    import_dist383 = __toESM(require_dist2(), 1);
    import_dist384 = __toESM(require_dist3(), 1);
    init_mdast_util_to_hast();
    remarkRehype = /** @type {(import('unified').Plugin<[Processor, Options?]|[null|undefined, Options?]|[Options]|[], MdastRoot>)} */
    (function(destination, options) {
      return destination && "run" in destination ? bridge(destination, options) : mutate(destination || options);
    });
    lib_default = remarkRehype;
  }
});

// node_modules/remark-rehype/index.js
var import_dist385, import_dist386, import_dist387;
var init_remark_rehype = __esm({
  "node_modules/remark-rehype/index.js"() {
    import_dist385 = __toESM(require_dist());
    import_dist386 = __toESM(require_dist2());
    import_dist387 = __toESM(require_dist3());
    init_mdast_util_to_hast();
    init_lib17();
  }
});

// node_modules/property-information/lib/util/schema.js
var import_dist388, import_dist389, import_dist390, Schema;
var init_schema = __esm({
  "node_modules/property-information/lib/util/schema.js"() {
    import_dist388 = __toESM(require_dist(), 1);
    import_dist389 = __toESM(require_dist2(), 1);
    import_dist390 = __toESM(require_dist3(), 1);
    Schema = class {
      /**
       * @constructor
       * @param {Properties} property
       * @param {Normal} normal
       * @param {string} [space]
       */
      constructor(property, normal, space2) {
        this.property = property;
        this.normal = normal;
        if (space2) {
          this.space = space2;
        }
      }
    };
    Schema.prototype.property = {};
    Schema.prototype.normal = {};
    Schema.prototype.space = null;
  }
});

// node_modules/property-information/lib/util/merge.js
function merge(definitions2, space2) {
  const property = {};
  const normal = {};
  let index2 = -1;
  while (++index2 < definitions2.length) {
    Object.assign(property, definitions2[index2].property);
    Object.assign(normal, definitions2[index2].normal);
  }
  return new Schema(property, normal, space2);
}
var import_dist391, import_dist392, import_dist393;
var init_merge = __esm({
  "node_modules/property-information/lib/util/merge.js"() {
    import_dist391 = __toESM(require_dist(), 1);
    import_dist392 = __toESM(require_dist2(), 1);
    import_dist393 = __toESM(require_dist3(), 1);
    init_schema();
  }
});

// node_modules/property-information/lib/normalize.js
function normalize2(value) {
  return value.toLowerCase();
}
var import_dist394, import_dist395, import_dist396;
var init_normalize = __esm({
  "node_modules/property-information/lib/normalize.js"() {
    import_dist394 = __toESM(require_dist(), 1);
    import_dist395 = __toESM(require_dist2(), 1);
    import_dist396 = __toESM(require_dist3(), 1);
  }
});

// node_modules/property-information/lib/util/info.js
var import_dist397, import_dist398, import_dist399, Info;
var init_info = __esm({
  "node_modules/property-information/lib/util/info.js"() {
    import_dist397 = __toESM(require_dist(), 1);
    import_dist398 = __toESM(require_dist2(), 1);
    import_dist399 = __toESM(require_dist3(), 1);
    Info = class {
      /**
       * @constructor
       * @param {string} property
       * @param {string} attribute
       */
      constructor(property, attribute) {
        this.property = property;
        this.attribute = attribute;
      }
    };
    Info.prototype.space = null;
    Info.prototype.boolean = false;
    Info.prototype.booleanish = false;
    Info.prototype.overloadedBoolean = false;
    Info.prototype.number = false;
    Info.prototype.commaSeparated = false;
    Info.prototype.spaceSeparated = false;
    Info.prototype.commaOrSpaceSeparated = false;
    Info.prototype.mustUseProperty = false;
    Info.prototype.defined = false;
  }
});

// node_modules/property-information/lib/util/types.js
var types_exports = {};
__export(types_exports, {
  boolean: () => boolean,
  booleanish: () => booleanish,
  commaOrSpaceSeparated: () => commaOrSpaceSeparated,
  commaSeparated: () => commaSeparated,
  number: () => number,
  overloadedBoolean: () => overloadedBoolean,
  spaceSeparated: () => spaceSeparated
});
function increment() {
  return 2 ** ++powers;
}
var import_dist400, import_dist401, import_dist402, powers, boolean, booleanish, overloadedBoolean, number, spaceSeparated, commaSeparated, commaOrSpaceSeparated;
var init_types2 = __esm({
  "node_modules/property-information/lib/util/types.js"() {
    import_dist400 = __toESM(require_dist(), 1);
    import_dist401 = __toESM(require_dist2(), 1);
    import_dist402 = __toESM(require_dist3(), 1);
    powers = 0;
    boolean = increment();
    booleanish = increment();
    overloadedBoolean = increment();
    number = increment();
    spaceSeparated = increment();
    commaSeparated = increment();
    commaOrSpaceSeparated = increment();
  }
});

// node_modules/property-information/lib/util/defined-info.js
function mark(values2, key, value) {
  if (value) {
    values2[key] = value;
  }
}
var import_dist403, import_dist404, import_dist405, checks, DefinedInfo;
var init_defined_info = __esm({
  "node_modules/property-information/lib/util/defined-info.js"() {
    import_dist403 = __toESM(require_dist(), 1);
    import_dist404 = __toESM(require_dist2(), 1);
    import_dist405 = __toESM(require_dist3(), 1);
    init_info();
    init_types2();
    checks = Object.keys(types_exports);
    DefinedInfo = class extends Info {
      /**
       * @constructor
       * @param {string} property
       * @param {string} attribute
       * @param {number|null} [mask]
       * @param {string} [space]
       */
      constructor(property, attribute, mask, space2) {
        let index2 = -1;
        super(property, attribute);
        mark(this, "space", space2);
        if (typeof mask === "number") {
          while (++index2 < checks.length) {
            const check = checks[index2];
            mark(this, checks[index2], (mask & types_exports[check]) === types_exports[check]);
          }
        }
      }
    };
    DefinedInfo.prototype.defined = true;
  }
});

// node_modules/property-information/lib/util/create.js
function create(definition2) {
  const property = {};
  const normal = {};
  let prop;
  for (prop in definition2.properties) {
    if (own5.call(definition2.properties, prop)) {
      const value = definition2.properties[prop];
      const info = new DefinedInfo(
        prop,
        definition2.transform(definition2.attributes || {}, prop),
        value,
        definition2.space
      );
      if (definition2.mustUseProperty && definition2.mustUseProperty.includes(prop)) {
        info.mustUseProperty = true;
      }
      property[prop] = info;
      normal[normalize2(prop)] = prop;
      normal[normalize2(info.attribute)] = prop;
    }
  }
  return new Schema(property, normal, definition2.space);
}
var import_dist406, import_dist407, import_dist408, own5;
var init_create = __esm({
  "node_modules/property-information/lib/util/create.js"() {
    import_dist406 = __toESM(require_dist(), 1);
    import_dist407 = __toESM(require_dist2(), 1);
    import_dist408 = __toESM(require_dist3(), 1);
    init_normalize();
    init_schema();
    init_defined_info();
    own5 = {}.hasOwnProperty;
  }
});

// node_modules/property-information/lib/xlink.js
var import_dist409, import_dist410, import_dist411, xlink;
var init_xlink = __esm({
  "node_modules/property-information/lib/xlink.js"() {
    import_dist409 = __toESM(require_dist(), 1);
    import_dist410 = __toESM(require_dist2(), 1);
    import_dist411 = __toESM(require_dist3(), 1);
    init_create();
    xlink = create({
      space: "xlink",
      transform(_, prop) {
        return "xlink:" + prop.slice(5).toLowerCase();
      },
      properties: {
        xLinkActuate: null,
        xLinkArcRole: null,
        xLinkHref: null,
        xLinkRole: null,
        xLinkShow: null,
        xLinkTitle: null,
        xLinkType: null
      }
    });
  }
});

// node_modules/property-information/lib/xml.js
var import_dist412, import_dist413, import_dist414, xml;
var init_xml = __esm({
  "node_modules/property-information/lib/xml.js"() {
    import_dist412 = __toESM(require_dist(), 1);
    import_dist413 = __toESM(require_dist2(), 1);
    import_dist414 = __toESM(require_dist3(), 1);
    init_create();
    xml = create({
      space: "xml",
      transform(_, prop) {
        return "xml:" + prop.slice(3).toLowerCase();
      },
      properties: { xmlLang: null, xmlBase: null, xmlSpace: null }
    });
  }
});

// node_modules/property-information/lib/util/case-sensitive-transform.js
function caseSensitiveTransform(attributes, attribute) {
  return attribute in attributes ? attributes[attribute] : attribute;
}
var import_dist415, import_dist416, import_dist417;
var init_case_sensitive_transform = __esm({
  "node_modules/property-information/lib/util/case-sensitive-transform.js"() {
    import_dist415 = __toESM(require_dist(), 1);
    import_dist416 = __toESM(require_dist2(), 1);
    import_dist417 = __toESM(require_dist3(), 1);
  }
});

// node_modules/property-information/lib/util/case-insensitive-transform.js
function caseInsensitiveTransform(attributes, property) {
  return caseSensitiveTransform(attributes, property.toLowerCase());
}
var import_dist418, import_dist419, import_dist420;
var init_case_insensitive_transform = __esm({
  "node_modules/property-information/lib/util/case-insensitive-transform.js"() {
    import_dist418 = __toESM(require_dist(), 1);
    import_dist419 = __toESM(require_dist2(), 1);
    import_dist420 = __toESM(require_dist3(), 1);
    init_case_sensitive_transform();
  }
});

// node_modules/property-information/lib/xmlns.js
var import_dist421, import_dist422, import_dist423, xmlns;
var init_xmlns = __esm({
  "node_modules/property-information/lib/xmlns.js"() {
    import_dist421 = __toESM(require_dist(), 1);
    import_dist422 = __toESM(require_dist2(), 1);
    import_dist423 = __toESM(require_dist3(), 1);
    init_create();
    init_case_insensitive_transform();
    xmlns = create({
      space: "xmlns",
      attributes: { xmlnsxlink: "xmlns:xlink" },
      transform: caseInsensitiveTransform,
      properties: { xmlns: null, xmlnsXLink: null }
    });
  }
});

// node_modules/property-information/lib/aria.js
var import_dist424, import_dist425, import_dist426, aria;
var init_aria = __esm({
  "node_modules/property-information/lib/aria.js"() {
    import_dist424 = __toESM(require_dist(), 1);
    import_dist425 = __toESM(require_dist2(), 1);
    import_dist426 = __toESM(require_dist3(), 1);
    init_types2();
    init_create();
    aria = create({
      transform(_, prop) {
        return prop === "role" ? prop : "aria-" + prop.slice(4).toLowerCase();
      },
      properties: {
        ariaActiveDescendant: null,
        ariaAtomic: booleanish,
        ariaAutoComplete: null,
        ariaBusy: booleanish,
        ariaChecked: booleanish,
        ariaColCount: number,
        ariaColIndex: number,
        ariaColSpan: number,
        ariaControls: spaceSeparated,
        ariaCurrent: null,
        ariaDescribedBy: spaceSeparated,
        ariaDetails: null,
        ariaDisabled: booleanish,
        ariaDropEffect: spaceSeparated,
        ariaErrorMessage: null,
        ariaExpanded: booleanish,
        ariaFlowTo: spaceSeparated,
        ariaGrabbed: booleanish,
        ariaHasPopup: null,
        ariaHidden: booleanish,
        ariaInvalid: null,
        ariaKeyShortcuts: null,
        ariaLabel: null,
        ariaLabelledBy: spaceSeparated,
        ariaLevel: number,
        ariaLive: null,
        ariaModal: booleanish,
        ariaMultiLine: booleanish,
        ariaMultiSelectable: booleanish,
        ariaOrientation: null,
        ariaOwns: spaceSeparated,
        ariaPlaceholder: null,
        ariaPosInSet: number,
        ariaPressed: booleanish,
        ariaReadOnly: booleanish,
        ariaRelevant: null,
        ariaRequired: booleanish,
        ariaRoleDescription: spaceSeparated,
        ariaRowCount: number,
        ariaRowIndex: number,
        ariaRowSpan: number,
        ariaSelected: booleanish,
        ariaSetSize: number,
        ariaSort: null,
        ariaValueMax: number,
        ariaValueMin: number,
        ariaValueNow: number,
        ariaValueText: null,
        role: null
      }
    });
  }
});

// node_modules/property-information/lib/html.js
var import_dist427, import_dist428, import_dist429, html2;
var init_html2 = __esm({
  "node_modules/property-information/lib/html.js"() {
    import_dist427 = __toESM(require_dist(), 1);
    import_dist428 = __toESM(require_dist2(), 1);
    import_dist429 = __toESM(require_dist3(), 1);
    init_types2();
    init_create();
    init_case_insensitive_transform();
    html2 = create({
      space: "html",
      attributes: {
        acceptcharset: "accept-charset",
        classname: "class",
        htmlfor: "for",
        httpequiv: "http-equiv"
      },
      transform: caseInsensitiveTransform,
      mustUseProperty: ["checked", "multiple", "muted", "selected"],
      properties: {
        // Standard Properties.
        abbr: null,
        accept: commaSeparated,
        acceptCharset: spaceSeparated,
        accessKey: spaceSeparated,
        action: null,
        allow: null,
        allowFullScreen: boolean,
        allowPaymentRequest: boolean,
        allowUserMedia: boolean,
        alt: null,
        as: null,
        async: boolean,
        autoCapitalize: null,
        autoComplete: spaceSeparated,
        autoFocus: boolean,
        autoPlay: boolean,
        blocking: spaceSeparated,
        capture: null,
        charSet: null,
        checked: boolean,
        cite: null,
        className: spaceSeparated,
        cols: number,
        colSpan: null,
        content: null,
        contentEditable: booleanish,
        controls: boolean,
        controlsList: spaceSeparated,
        coords: number | commaSeparated,
        crossOrigin: null,
        data: null,
        dateTime: null,
        decoding: null,
        default: boolean,
        defer: boolean,
        dir: null,
        dirName: null,
        disabled: boolean,
        download: overloadedBoolean,
        draggable: booleanish,
        encType: null,
        enterKeyHint: null,
        fetchPriority: null,
        form: null,
        formAction: null,
        formEncType: null,
        formMethod: null,
        formNoValidate: boolean,
        formTarget: null,
        headers: spaceSeparated,
        height: number,
        hidden: boolean,
        high: number,
        href: null,
        hrefLang: null,
        htmlFor: spaceSeparated,
        httpEquiv: spaceSeparated,
        id: null,
        imageSizes: null,
        imageSrcSet: null,
        inert: boolean,
        inputMode: null,
        integrity: null,
        is: null,
        isMap: boolean,
        itemId: null,
        itemProp: spaceSeparated,
        itemRef: spaceSeparated,
        itemScope: boolean,
        itemType: spaceSeparated,
        kind: null,
        label: null,
        lang: null,
        language: null,
        list: null,
        loading: null,
        loop: boolean,
        low: number,
        manifest: null,
        max: null,
        maxLength: number,
        media: null,
        method: null,
        min: null,
        minLength: number,
        multiple: boolean,
        muted: boolean,
        name: null,
        nonce: null,
        noModule: boolean,
        noValidate: boolean,
        onAbort: null,
        onAfterPrint: null,
        onAuxClick: null,
        onBeforeMatch: null,
        onBeforePrint: null,
        onBeforeToggle: null,
        onBeforeUnload: null,
        onBlur: null,
        onCancel: null,
        onCanPlay: null,
        onCanPlayThrough: null,
        onChange: null,
        onClick: null,
        onClose: null,
        onContextLost: null,
        onContextMenu: null,
        onContextRestored: null,
        onCopy: null,
        onCueChange: null,
        onCut: null,
        onDblClick: null,
        onDrag: null,
        onDragEnd: null,
        onDragEnter: null,
        onDragExit: null,
        onDragLeave: null,
        onDragOver: null,
        onDragStart: null,
        onDrop: null,
        onDurationChange: null,
        onEmptied: null,
        onEnded: null,
        onError: null,
        onFocus: null,
        onFormData: null,
        onHashChange: null,
        onInput: null,
        onInvalid: null,
        onKeyDown: null,
        onKeyPress: null,
        onKeyUp: null,
        onLanguageChange: null,
        onLoad: null,
        onLoadedData: null,
        onLoadedMetadata: null,
        onLoadEnd: null,
        onLoadStart: null,
        onMessage: null,
        onMessageError: null,
        onMouseDown: null,
        onMouseEnter: null,
        onMouseLeave: null,
        onMouseMove: null,
        onMouseOut: null,
        onMouseOver: null,
        onMouseUp: null,
        onOffline: null,
        onOnline: null,
        onPageHide: null,
        onPageShow: null,
        onPaste: null,
        onPause: null,
        onPlay: null,
        onPlaying: null,
        onPopState: null,
        onProgress: null,
        onRateChange: null,
        onRejectionHandled: null,
        onReset: null,
        onResize: null,
        onScroll: null,
        onScrollEnd: null,
        onSecurityPolicyViolation: null,
        onSeeked: null,
        onSeeking: null,
        onSelect: null,
        onSlotChange: null,
        onStalled: null,
        onStorage: null,
        onSubmit: null,
        onSuspend: null,
        onTimeUpdate: null,
        onToggle: null,
        onUnhandledRejection: null,
        onUnload: null,
        onVolumeChange: null,
        onWaiting: null,
        onWheel: null,
        open: boolean,
        optimum: number,
        pattern: null,
        ping: spaceSeparated,
        placeholder: null,
        playsInline: boolean,
        popover: null,
        popoverTarget: null,
        popoverTargetAction: null,
        poster: null,
        preload: null,
        readOnly: boolean,
        referrerPolicy: null,
        rel: spaceSeparated,
        required: boolean,
        reversed: boolean,
        rows: number,
        rowSpan: number,
        sandbox: spaceSeparated,
        scope: null,
        scoped: boolean,
        seamless: boolean,
        selected: boolean,
        shadowRootClonable: boolean,
        shadowRootDelegatesFocus: boolean,
        shadowRootMode: null,
        shape: null,
        size: number,
        sizes: null,
        slot: null,
        span: number,
        spellCheck: booleanish,
        src: null,
        srcDoc: null,
        srcLang: null,
        srcSet: null,
        start: number,
        step: null,
        style: null,
        tabIndex: number,
        target: null,
        title: null,
        translate: null,
        type: null,
        typeMustMatch: boolean,
        useMap: null,
        value: booleanish,
        width: number,
        wrap: null,
        writingSuggestions: null,
        // Legacy.
        // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
        align: null,
        // Several. Use CSS `text-align` instead,
        aLink: null,
        // `<body>`. Use CSS `a:active {color}` instead
        archive: spaceSeparated,
        // `<object>`. List of URIs to archives
        axis: null,
        // `<td>` and `<th>`. Use `scope` on `<th>`
        background: null,
        // `<body>`. Use CSS `background-image` instead
        bgColor: null,
        // `<body>` and table elements. Use CSS `background-color` instead
        border: number,
        // `<table>`. Use CSS `border-width` instead,
        borderColor: null,
        // `<table>`. Use CSS `border-color` instead,
        bottomMargin: number,
        // `<body>`
        cellPadding: null,
        // `<table>`
        cellSpacing: null,
        // `<table>`
        char: null,
        // Several table elements. When `align=char`, sets the character to align on
        charOff: null,
        // Several table elements. When `char`, offsets the alignment
        classId: null,
        // `<object>`
        clear: null,
        // `<br>`. Use CSS `clear` instead
        code: null,
        // `<object>`
        codeBase: null,
        // `<object>`
        codeType: null,
        // `<object>`
        color: null,
        // `<font>` and `<hr>`. Use CSS instead
        compact: boolean,
        // Lists. Use CSS to reduce space between items instead
        declare: boolean,
        // `<object>`
        event: null,
        // `<script>`
        face: null,
        // `<font>`. Use CSS instead
        frame: null,
        // `<table>`
        frameBorder: null,
        // `<iframe>`. Use CSS `border` instead
        hSpace: number,
        // `<img>` and `<object>`
        leftMargin: number,
        // `<body>`
        link: null,
        // `<body>`. Use CSS `a:link {color: *}` instead
        longDesc: null,
        // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
        lowSrc: null,
        // `<img>`. Use a `<picture>`
        marginHeight: number,
        // `<body>`
        marginWidth: number,
        // `<body>`
        noResize: boolean,
        // `<frame>`
        noHref: boolean,
        // `<area>`. Use no href instead of an explicit `nohref`
        noShade: boolean,
        // `<hr>`. Use background-color and height instead of borders
        noWrap: boolean,
        // `<td>` and `<th>`
        object: null,
        // `<applet>`
        profile: null,
        // `<head>`
        prompt: null,
        // `<isindex>`
        rev: null,
        // `<link>`
        rightMargin: number,
        // `<body>`
        rules: null,
        // `<table>`
        scheme: null,
        // `<meta>`
        scrolling: booleanish,
        // `<frame>`. Use overflow in the child context
        standby: null,
        // `<object>`
        summary: null,
        // `<table>`
        text: null,
        // `<body>`. Use CSS `color` instead
        topMargin: number,
        // `<body>`
        valueType: null,
        // `<param>`
        version: null,
        // `<html>`. Use a doctype.
        vAlign: null,
        // Several. Use CSS `vertical-align` instead
        vLink: null,
        // `<body>`. Use CSS `a:visited {color}` instead
        vSpace: number,
        // `<img>` and `<object>`
        // Non-standard Properties.
        allowTransparency: null,
        autoCorrect: null,
        autoSave: null,
        disablePictureInPicture: boolean,
        disableRemotePlayback: boolean,
        prefix: null,
        property: null,
        results: number,
        security: null,
        unselectable: null
      }
    });
  }
});

// node_modules/property-information/lib/svg.js
var import_dist430, import_dist431, import_dist432, svg;
var init_svg = __esm({
  "node_modules/property-information/lib/svg.js"() {
    import_dist430 = __toESM(require_dist(), 1);
    import_dist431 = __toESM(require_dist2(), 1);
    import_dist432 = __toESM(require_dist3(), 1);
    init_types2();
    init_create();
    init_case_sensitive_transform();
    svg = create({
      space: "svg",
      attributes: {
        accentHeight: "accent-height",
        alignmentBaseline: "alignment-baseline",
        arabicForm: "arabic-form",
        baselineShift: "baseline-shift",
        capHeight: "cap-height",
        className: "class",
        clipPath: "clip-path",
        clipRule: "clip-rule",
        colorInterpolation: "color-interpolation",
        colorInterpolationFilters: "color-interpolation-filters",
        colorProfile: "color-profile",
        colorRendering: "color-rendering",
        crossOrigin: "crossorigin",
        dataType: "datatype",
        dominantBaseline: "dominant-baseline",
        enableBackground: "enable-background",
        fillOpacity: "fill-opacity",
        fillRule: "fill-rule",
        floodColor: "flood-color",
        floodOpacity: "flood-opacity",
        fontFamily: "font-family",
        fontSize: "font-size",
        fontSizeAdjust: "font-size-adjust",
        fontStretch: "font-stretch",
        fontStyle: "font-style",
        fontVariant: "font-variant",
        fontWeight: "font-weight",
        glyphName: "glyph-name",
        glyphOrientationHorizontal: "glyph-orientation-horizontal",
        glyphOrientationVertical: "glyph-orientation-vertical",
        hrefLang: "hreflang",
        horizAdvX: "horiz-adv-x",
        horizOriginX: "horiz-origin-x",
        horizOriginY: "horiz-origin-y",
        imageRendering: "image-rendering",
        letterSpacing: "letter-spacing",
        lightingColor: "lighting-color",
        markerEnd: "marker-end",
        markerMid: "marker-mid",
        markerStart: "marker-start",
        navDown: "nav-down",
        navDownLeft: "nav-down-left",
        navDownRight: "nav-down-right",
        navLeft: "nav-left",
        navNext: "nav-next",
        navPrev: "nav-prev",
        navRight: "nav-right",
        navUp: "nav-up",
        navUpLeft: "nav-up-left",
        navUpRight: "nav-up-right",
        onAbort: "onabort",
        onActivate: "onactivate",
        onAfterPrint: "onafterprint",
        onBeforePrint: "onbeforeprint",
        onBegin: "onbegin",
        onCancel: "oncancel",
        onCanPlay: "oncanplay",
        onCanPlayThrough: "oncanplaythrough",
        onChange: "onchange",
        onClick: "onclick",
        onClose: "onclose",
        onCopy: "oncopy",
        onCueChange: "oncuechange",
        onCut: "oncut",
        onDblClick: "ondblclick",
        onDrag: "ondrag",
        onDragEnd: "ondragend",
        onDragEnter: "ondragenter",
        onDragExit: "ondragexit",
        onDragLeave: "ondragleave",
        onDragOver: "ondragover",
        onDragStart: "ondragstart",
        onDrop: "ondrop",
        onDurationChange: "ondurationchange",
        onEmptied: "onemptied",
        onEnd: "onend",
        onEnded: "onended",
        onError: "onerror",
        onFocus: "onfocus",
        onFocusIn: "onfocusin",
        onFocusOut: "onfocusout",
        onHashChange: "onhashchange",
        onInput: "oninput",
        onInvalid: "oninvalid",
        onKeyDown: "onkeydown",
        onKeyPress: "onkeypress",
        onKeyUp: "onkeyup",
        onLoad: "onload",
        onLoadedData: "onloadeddata",
        onLoadedMetadata: "onloadedmetadata",
        onLoadStart: "onloadstart",
        onMessage: "onmessage",
        onMouseDown: "onmousedown",
        onMouseEnter: "onmouseenter",
        onMouseLeave: "onmouseleave",
        onMouseMove: "onmousemove",
        onMouseOut: "onmouseout",
        onMouseOver: "onmouseover",
        onMouseUp: "onmouseup",
        onMouseWheel: "onmousewheel",
        onOffline: "onoffline",
        onOnline: "ononline",
        onPageHide: "onpagehide",
        onPageShow: "onpageshow",
        onPaste: "onpaste",
        onPause: "onpause",
        onPlay: "onplay",
        onPlaying: "onplaying",
        onPopState: "onpopstate",
        onProgress: "onprogress",
        onRateChange: "onratechange",
        onRepeat: "onrepeat",
        onReset: "onreset",
        onResize: "onresize",
        onScroll: "onscroll",
        onSeeked: "onseeked",
        onSeeking: "onseeking",
        onSelect: "onselect",
        onShow: "onshow",
        onStalled: "onstalled",
        onStorage: "onstorage",
        onSubmit: "onsubmit",
        onSuspend: "onsuspend",
        onTimeUpdate: "ontimeupdate",
        onToggle: "ontoggle",
        onUnload: "onunload",
        onVolumeChange: "onvolumechange",
        onWaiting: "onwaiting",
        onZoom: "onzoom",
        overlinePosition: "overline-position",
        overlineThickness: "overline-thickness",
        paintOrder: "paint-order",
        panose1: "panose-1",
        pointerEvents: "pointer-events",
        referrerPolicy: "referrerpolicy",
        renderingIntent: "rendering-intent",
        shapeRendering: "shape-rendering",
        stopColor: "stop-color",
        stopOpacity: "stop-opacity",
        strikethroughPosition: "strikethrough-position",
        strikethroughThickness: "strikethrough-thickness",
        strokeDashArray: "stroke-dasharray",
        strokeDashOffset: "stroke-dashoffset",
        strokeLineCap: "stroke-linecap",
        strokeLineJoin: "stroke-linejoin",
        strokeMiterLimit: "stroke-miterlimit",
        strokeOpacity: "stroke-opacity",
        strokeWidth: "stroke-width",
        tabIndex: "tabindex",
        textAnchor: "text-anchor",
        textDecoration: "text-decoration",
        textRendering: "text-rendering",
        transformOrigin: "transform-origin",
        typeOf: "typeof",
        underlinePosition: "underline-position",
        underlineThickness: "underline-thickness",
        unicodeBidi: "unicode-bidi",
        unicodeRange: "unicode-range",
        unitsPerEm: "units-per-em",
        vAlphabetic: "v-alphabetic",
        vHanging: "v-hanging",
        vIdeographic: "v-ideographic",
        vMathematical: "v-mathematical",
        vectorEffect: "vector-effect",
        vertAdvY: "vert-adv-y",
        vertOriginX: "vert-origin-x",
        vertOriginY: "vert-origin-y",
        wordSpacing: "word-spacing",
        writingMode: "writing-mode",
        xHeight: "x-height",
        // These were camelcased in Tiny. Now lowercased in SVG 2
        playbackOrder: "playbackorder",
        timelineBegin: "timelinebegin"
      },
      transform: caseSensitiveTransform,
      properties: {
        about: commaOrSpaceSeparated,
        accentHeight: number,
        accumulate: null,
        additive: null,
        alignmentBaseline: null,
        alphabetic: number,
        amplitude: number,
        arabicForm: null,
        ascent: number,
        attributeName: null,
        attributeType: null,
        azimuth: number,
        bandwidth: null,
        baselineShift: null,
        baseFrequency: null,
        baseProfile: null,
        bbox: null,
        begin: null,
        bias: number,
        by: null,
        calcMode: null,
        capHeight: number,
        className: spaceSeparated,
        clip: null,
        clipPath: null,
        clipPathUnits: null,
        clipRule: null,
        color: null,
        colorInterpolation: null,
        colorInterpolationFilters: null,
        colorProfile: null,
        colorRendering: null,
        content: null,
        contentScriptType: null,
        contentStyleType: null,
        crossOrigin: null,
        cursor: null,
        cx: null,
        cy: null,
        d: null,
        dataType: null,
        defaultAction: null,
        descent: number,
        diffuseConstant: number,
        direction: null,
        display: null,
        dur: null,
        divisor: number,
        dominantBaseline: null,
        download: boolean,
        dx: null,
        dy: null,
        edgeMode: null,
        editable: null,
        elevation: number,
        enableBackground: null,
        end: null,
        event: null,
        exponent: number,
        externalResourcesRequired: null,
        fill: null,
        fillOpacity: number,
        fillRule: null,
        filter: null,
        filterRes: null,
        filterUnits: null,
        floodColor: null,
        floodOpacity: null,
        focusable: null,
        focusHighlight: null,
        fontFamily: null,
        fontSize: null,
        fontSizeAdjust: null,
        fontStretch: null,
        fontStyle: null,
        fontVariant: null,
        fontWeight: null,
        format: null,
        fr: null,
        from: null,
        fx: null,
        fy: null,
        g1: commaSeparated,
        g2: commaSeparated,
        glyphName: commaSeparated,
        glyphOrientationHorizontal: null,
        glyphOrientationVertical: null,
        glyphRef: null,
        gradientTransform: null,
        gradientUnits: null,
        handler: null,
        hanging: number,
        hatchContentUnits: null,
        hatchUnits: null,
        height: null,
        href: null,
        hrefLang: null,
        horizAdvX: number,
        horizOriginX: number,
        horizOriginY: number,
        id: null,
        ideographic: number,
        imageRendering: null,
        initialVisibility: null,
        in: null,
        in2: null,
        intercept: number,
        k: number,
        k1: number,
        k2: number,
        k3: number,
        k4: number,
        kernelMatrix: commaOrSpaceSeparated,
        kernelUnitLength: null,
        keyPoints: null,
        // SEMI_COLON_SEPARATED
        keySplines: null,
        // SEMI_COLON_SEPARATED
        keyTimes: null,
        // SEMI_COLON_SEPARATED
        kerning: null,
        lang: null,
        lengthAdjust: null,
        letterSpacing: null,
        lightingColor: null,
        limitingConeAngle: number,
        local: null,
        markerEnd: null,
        markerMid: null,
        markerStart: null,
        markerHeight: null,
        markerUnits: null,
        markerWidth: null,
        mask: null,
        maskContentUnits: null,
        maskUnits: null,
        mathematical: null,
        max: null,
        media: null,
        mediaCharacterEncoding: null,
        mediaContentEncodings: null,
        mediaSize: number,
        mediaTime: null,
        method: null,
        min: null,
        mode: null,
        name: null,
        navDown: null,
        navDownLeft: null,
        navDownRight: null,
        navLeft: null,
        navNext: null,
        navPrev: null,
        navRight: null,
        navUp: null,
        navUpLeft: null,
        navUpRight: null,
        numOctaves: null,
        observer: null,
        offset: null,
        onAbort: null,
        onActivate: null,
        onAfterPrint: null,
        onBeforePrint: null,
        onBegin: null,
        onCancel: null,
        onCanPlay: null,
        onCanPlayThrough: null,
        onChange: null,
        onClick: null,
        onClose: null,
        onCopy: null,
        onCueChange: null,
        onCut: null,
        onDblClick: null,
        onDrag: null,
        onDragEnd: null,
        onDragEnter: null,
        onDragExit: null,
        onDragLeave: null,
        onDragOver: null,
        onDragStart: null,
        onDrop: null,
        onDurationChange: null,
        onEmptied: null,
        onEnd: null,
        onEnded: null,
        onError: null,
        onFocus: null,
        onFocusIn: null,
        onFocusOut: null,
        onHashChange: null,
        onInput: null,
        onInvalid: null,
        onKeyDown: null,
        onKeyPress: null,
        onKeyUp: null,
        onLoad: null,
        onLoadedData: null,
        onLoadedMetadata: null,
        onLoadStart: null,
        onMessage: null,
        onMouseDown: null,
        onMouseEnter: null,
        onMouseLeave: null,
        onMouseMove: null,
        onMouseOut: null,
        onMouseOver: null,
        onMouseUp: null,
        onMouseWheel: null,
        onOffline: null,
        onOnline: null,
        onPageHide: null,
        onPageShow: null,
        onPaste: null,
        onPause: null,
        onPlay: null,
        onPlaying: null,
        onPopState: null,
        onProgress: null,
        onRateChange: null,
        onRepeat: null,
        onReset: null,
        onResize: null,
        onScroll: null,
        onSeeked: null,
        onSeeking: null,
        onSelect: null,
        onShow: null,
        onStalled: null,
        onStorage: null,
        onSubmit: null,
        onSuspend: null,
        onTimeUpdate: null,
        onToggle: null,
        onUnload: null,
        onVolumeChange: null,
        onWaiting: null,
        onZoom: null,
        opacity: null,
        operator: null,
        order: null,
        orient: null,
        orientation: null,
        origin: null,
        overflow: null,
        overlay: null,
        overlinePosition: number,
        overlineThickness: number,
        paintOrder: null,
        panose1: null,
        path: null,
        pathLength: number,
        patternContentUnits: null,
        patternTransform: null,
        patternUnits: null,
        phase: null,
        ping: spaceSeparated,
        pitch: null,
        playbackOrder: null,
        pointerEvents: null,
        points: null,
        pointsAtX: number,
        pointsAtY: number,
        pointsAtZ: number,
        preserveAlpha: null,
        preserveAspectRatio: null,
        primitiveUnits: null,
        propagate: null,
        property: commaOrSpaceSeparated,
        r: null,
        radius: null,
        referrerPolicy: null,
        refX: null,
        refY: null,
        rel: commaOrSpaceSeparated,
        rev: commaOrSpaceSeparated,
        renderingIntent: null,
        repeatCount: null,
        repeatDur: null,
        requiredExtensions: commaOrSpaceSeparated,
        requiredFeatures: commaOrSpaceSeparated,
        requiredFonts: commaOrSpaceSeparated,
        requiredFormats: commaOrSpaceSeparated,
        resource: null,
        restart: null,
        result: null,
        rotate: null,
        rx: null,
        ry: null,
        scale: null,
        seed: null,
        shapeRendering: null,
        side: null,
        slope: null,
        snapshotTime: null,
        specularConstant: number,
        specularExponent: number,
        spreadMethod: null,
        spacing: null,
        startOffset: null,
        stdDeviation: null,
        stemh: null,
        stemv: null,
        stitchTiles: null,
        stopColor: null,
        stopOpacity: null,
        strikethroughPosition: number,
        strikethroughThickness: number,
        string: null,
        stroke: null,
        strokeDashArray: commaOrSpaceSeparated,
        strokeDashOffset: null,
        strokeLineCap: null,
        strokeLineJoin: null,
        strokeMiterLimit: number,
        strokeOpacity: number,
        strokeWidth: null,
        style: null,
        surfaceScale: number,
        syncBehavior: null,
        syncBehaviorDefault: null,
        syncMaster: null,
        syncTolerance: null,
        syncToleranceDefault: null,
        systemLanguage: commaOrSpaceSeparated,
        tabIndex: number,
        tableValues: null,
        target: null,
        targetX: number,
        targetY: number,
        textAnchor: null,
        textDecoration: null,
        textRendering: null,
        textLength: null,
        timelineBegin: null,
        title: null,
        transformBehavior: null,
        type: null,
        typeOf: commaOrSpaceSeparated,
        to: null,
        transform: null,
        transformOrigin: null,
        u1: null,
        u2: null,
        underlinePosition: number,
        underlineThickness: number,
        unicode: null,
        unicodeBidi: null,
        unicodeRange: null,
        unitsPerEm: number,
        values: null,
        vAlphabetic: number,
        vMathematical: number,
        vectorEffect: null,
        vHanging: number,
        vIdeographic: number,
        version: null,
        vertAdvY: number,
        vertOriginX: number,
        vertOriginY: number,
        viewBox: null,
        viewTarget: null,
        visibility: null,
        width: null,
        widths: null,
        wordSpacing: null,
        writingMode: null,
        x: null,
        x1: null,
        x2: null,
        xChannelSelector: null,
        xHeight: number,
        y: null,
        y1: null,
        y2: null,
        yChannelSelector: null,
        z: null,
        zoomAndPan: null
      }
    });
  }
});

// node_modules/property-information/lib/find.js
function find(schema, value) {
  const normal = normalize2(value);
  let prop = value;
  let Type = Info;
  if (normal in schema.normal) {
    return schema.property[schema.normal[normal]];
  }
  if (normal.length > 4 && normal.slice(0, 4) === "data" && valid.test(value)) {
    if (value.charAt(4) === "-") {
      const rest = value.slice(5).replace(dash, camelcase);
      prop = "data" + rest.charAt(0).toUpperCase() + rest.slice(1);
    } else {
      const rest = value.slice(4);
      if (!dash.test(rest)) {
        let dashes = rest.replace(cap, kebab);
        if (dashes.charAt(0) !== "-") {
          dashes = "-" + dashes;
        }
        value = "data" + dashes;
      }
    }
    Type = DefinedInfo;
  }
  return new Type(prop, value);
}
function kebab($0) {
  return "-" + $0.toLowerCase();
}
function camelcase($0) {
  return $0.charAt(1).toUpperCase();
}
var import_dist433, import_dist434, import_dist435, valid, dash, cap;
var init_find = __esm({
  "node_modules/property-information/lib/find.js"() {
    import_dist433 = __toESM(require_dist(), 1);
    import_dist434 = __toESM(require_dist2(), 1);
    import_dist435 = __toESM(require_dist3(), 1);
    init_normalize();
    init_defined_info();
    init_info();
    valid = /^data[-\w.:]+$/i;
    dash = /-[a-z]/g;
    cap = /[A-Z]/g;
  }
});

// node_modules/property-information/lib/hast-to-react.js
var import_dist436, import_dist437, import_dist438, hastToReact;
var init_hast_to_react = __esm({
  "node_modules/property-information/lib/hast-to-react.js"() {
    import_dist436 = __toESM(require_dist(), 1);
    import_dist437 = __toESM(require_dist2(), 1);
    import_dist438 = __toESM(require_dist3(), 1);
    hastToReact = {
      classId: "classID",
      dataType: "datatype",
      itemId: "itemID",
      strokeDashArray: "strokeDasharray",
      strokeDashOffset: "strokeDashoffset",
      strokeLineCap: "strokeLinecap",
      strokeLineJoin: "strokeLinejoin",
      strokeMiterLimit: "strokeMiterlimit",
      typeOf: "typeof",
      xLinkActuate: "xlinkActuate",
      xLinkArcRole: "xlinkArcrole",
      xLinkHref: "xlinkHref",
      xLinkRole: "xlinkRole",
      xLinkShow: "xlinkShow",
      xLinkTitle: "xlinkTitle",
      xLinkType: "xlinkType",
      xmlnsXLink: "xmlnsXlink"
    };
  }
});

// node_modules/property-information/index.js
var import_dist439, import_dist440, import_dist441, html3, svg2;
var init_property_information = __esm({
  "node_modules/property-information/index.js"() {
    import_dist439 = __toESM(require_dist());
    import_dist440 = __toESM(require_dist2());
    import_dist441 = __toESM(require_dist3());
    init_merge();
    init_xlink();
    init_xml();
    init_xmlns();
    init_aria();
    init_html2();
    init_svg();
    init_find();
    init_hast_to_react();
    init_normalize();
    html3 = merge([xml, xlink, xmlns, aria, html2], "html");
    svg2 = merge([xml, xlink, xmlns, aria, svg], "svg");
  }
});

// node_modules/react-markdown/lib/rehype-filter.js
function rehypeFilter(options) {
  if (options.allowedElements && options.disallowedElements) {
    throw new TypeError(
      "Only one of `allowedElements` and `disallowedElements` should be defined"
    );
  }
  if (options.allowedElements || options.disallowedElements || options.allowElement) {
    return (tree) => {
      visit(tree, "element", (node2, index2, parent_) => {
        const parent = (
          /** @type {Element|Root} */
          parent_
        );
        let remove;
        if (options.allowedElements) {
          remove = !options.allowedElements.includes(node2.tagName);
        } else if (options.disallowedElements) {
          remove = options.disallowedElements.includes(node2.tagName);
        }
        if (!remove && options.allowElement && typeof index2 === "number") {
          remove = !options.allowElement(node2, index2, parent);
        }
        if (remove && typeof index2 === "number") {
          if (options.unwrapDisallowed && node2.children) {
            parent.children.splice(index2, 1, ...node2.children);
          } else {
            parent.children.splice(index2, 1);
          }
          return index2;
        }
        return void 0;
      });
    };
  }
}
var import_dist442, import_dist443, import_dist444;
var init_rehype_filter = __esm({
  "node_modules/react-markdown/lib/rehype-filter.js"() {
    import_dist442 = __toESM(require_dist(), 1);
    import_dist443 = __toESM(require_dist2(), 1);
    import_dist444 = __toESM(require_dist3(), 1);
    init_unist_util_visit();
  }
});

// node_modules/hast-util-whitespace/index.js
function whitespace(thing) {
  const value = (
    // @ts-expect-error looks like a node.
    thing && typeof thing === "object" && thing.type === "text" ? (
      // @ts-expect-error looks like a text.
      thing.value || ""
    ) : thing
  );
  return typeof value === "string" && value.replace(/[ \t\n\f\r]/g, "") === "";
}
var import_dist445, import_dist446, import_dist447;
var init_hast_util_whitespace = __esm({
  "node_modules/hast-util-whitespace/index.js"() {
    import_dist445 = __toESM(require_dist());
    import_dist446 = __toESM(require_dist2());
    import_dist447 = __toESM(require_dist3());
  }
});

// node_modules/space-separated-tokens/index.js
function stringify2(values2) {
  return values2.join(" ").trim();
}
var import_dist448, import_dist449, import_dist450;
var init_space_separated_tokens = __esm({
  "node_modules/space-separated-tokens/index.js"() {
    import_dist448 = __toESM(require_dist());
    import_dist449 = __toESM(require_dist2());
    import_dist450 = __toESM(require_dist3());
  }
});

// node_modules/comma-separated-tokens/index.js
function stringify3(values2, options) {
  const settings = options || {};
  const input = values2[values2.length - 1] === "" ? [...values2, ""] : values2;
  return input.join(
    (settings.padRight ? " " : "") + "," + (settings.padLeft === false ? "" : " ")
  ).trim();
}
var import_dist451, import_dist452, import_dist453;
var init_comma_separated_tokens = __esm({
  "node_modules/comma-separated-tokens/index.js"() {
    import_dist451 = __toESM(require_dist());
    import_dist452 = __toESM(require_dist2());
    import_dist453 = __toESM(require_dist3());
  }
});

// node_modules/inline-style-parser/index.js
var require_inline_style_parser = __commonJS({
  "node_modules/inline-style-parser/index.js"(exports, module) {
    var import_dist466 = __toESM(require_dist());
    var import_dist467 = __toESM(require_dist2());
    var import_dist468 = __toESM(require_dist3());
    var COMMENT_REGEX = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g;
    var NEWLINE_REGEX = /\n/g;
    var WHITESPACE_REGEX = /^\s*/;
    var PROPERTY_REGEX = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/;
    var COLON_REGEX = /^:\s*/;
    var VALUE_REGEX = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/;
    var SEMICOLON_REGEX = /^[;\s]*/;
    var TRIM_REGEX = /^\s+|\s+$/g;
    var NEWLINE = "\n";
    var FORWARD_SLASH = "/";
    var ASTERISK = "*";
    var EMPTY_STRING = "";
    var TYPE_COMMENT = "comment";
    var TYPE_DECLARATION = "declaration";
    module.exports = function(style, options) {
      if (typeof style !== "string") {
        throw new TypeError("First argument must be a string");
      }
      if (!style) return [];
      options = options || {};
      var lineno = 1;
      var column = 1;
      function updatePosition(str) {
        var lines2 = str.match(NEWLINE_REGEX);
        if (lines2) lineno += lines2.length;
        var i = str.lastIndexOf(NEWLINE);
        column = ~i ? str.length - i : column + str.length;
      }
      function position3() {
        var start = { line: lineno, column };
        return function(node2) {
          node2.position = new Position(start);
          whitespace2();
          return node2;
        };
      }
      function Position(start) {
        this.start = start;
        this.end = { line: lineno, column };
        this.source = options.source;
      }
      Position.prototype.content = style;
      var errorsList = [];
      function error(msg) {
        var err = new Error(
          options.source + ":" + lineno + ":" + column + ": " + msg
        );
        err.reason = msg;
        err.filename = options.source;
        err.line = lineno;
        err.column = column;
        err.source = style;
        if (options.silent) {
          errorsList.push(err);
        } else {
          throw err;
        }
      }
      function match(re) {
        var m = re.exec(style);
        if (!m) return;
        var str = m[0];
        updatePosition(str);
        style = style.slice(str.length);
        return m;
      }
      function whitespace2() {
        match(WHITESPACE_REGEX);
      }
      function comments(rules) {
        var c;
        rules = rules || [];
        while (c = comment()) {
          if (c !== false) {
            rules.push(c);
          }
        }
        return rules;
      }
      function comment() {
        var pos = position3();
        if (FORWARD_SLASH != style.charAt(0) || ASTERISK != style.charAt(1)) return;
        var i = 2;
        while (EMPTY_STRING != style.charAt(i) && (ASTERISK != style.charAt(i) || FORWARD_SLASH != style.charAt(i + 1))) {
          ++i;
        }
        i += 2;
        if (EMPTY_STRING === style.charAt(i - 1)) {
          return error("End of comment missing");
        }
        var str = style.slice(2, i - 2);
        column += 2;
        updatePosition(str);
        style = style.slice(i);
        column += 2;
        return pos({
          type: TYPE_COMMENT,
          comment: str
        });
      }
      function declaration() {
        var pos = position3();
        var prop = match(PROPERTY_REGEX);
        if (!prop) return;
        comment();
        if (!match(COLON_REGEX)) return error("property missing ':'");
        var val = match(VALUE_REGEX);
        var ret = pos({
          type: TYPE_DECLARATION,
          property: trim(prop[0].replace(COMMENT_REGEX, EMPTY_STRING)),
          value: val ? trim(val[0].replace(COMMENT_REGEX, EMPTY_STRING)) : EMPTY_STRING
        });
        match(SEMICOLON_REGEX);
        return ret;
      }
      function declarations() {
        var decls = [];
        comments(decls);
        var decl;
        while (decl = declaration()) {
          if (decl !== false) {
            decls.push(decl);
            comments(decls);
          }
        }
        return decls;
      }
      whitespace2();
      return declarations();
    };
    function trim(str) {
      return str ? str.replace(TRIM_REGEX, EMPTY_STRING) : EMPTY_STRING;
    }
  }
});

// node_modules/style-to-object/index.js
var require_style_to_object = __commonJS({
  "node_modules/style-to-object/index.js"(exports, module) {
    var import_dist466 = __toESM(require_dist());
    var import_dist467 = __toESM(require_dist2());
    var import_dist468 = __toESM(require_dist3());
    var parse2 = require_inline_style_parser();
    function StyleToObject2(style, iterator) {
      var output = null;
      if (!style || typeof style !== "string") {
        return output;
      }
      var declaration;
      var declarations = parse2(style);
      var hasIterator = typeof iterator === "function";
      var property;
      var value;
      for (var i = 0, len = declarations.length; i < len; i++) {
        declaration = declarations[i];
        property = declaration.property;
        value = declaration.value;
        if (hasIterator) {
          iterator(property, value, declaration);
        } else if (value) {
          output || (output = {});
          output[property] = value;
        }
      }
      return output;
    }
    module.exports = StyleToObject2;
    module.exports.default = StyleToObject2;
  }
});

// node_modules/style-to-object/index.mjs
var import_dist454, import_dist455, import_dist456, import_index, style_to_object_default;
var init_style_to_object = __esm({
  "node_modules/style-to-object/index.mjs"() {
    import_dist454 = __toESM(require_dist(), 1);
    import_dist455 = __toESM(require_dist2(), 1);
    import_dist456 = __toESM(require_dist3(), 1);
    import_index = __toESM(require_style_to_object(), 1);
    style_to_object_default = import_index.default;
  }
});

// node_modules/react-markdown/lib/ast-to-react.js
function childrenToReact(context, node2) {
  const children = [];
  let childIndex = -1;
  let child;
  while (++childIndex < node2.children.length) {
    child = node2.children[childIndex];
    if (child.type === "element") {
      children.push(toReact(context, child, childIndex, node2));
    } else if (child.type === "text") {
      if (node2.type !== "element" || !tableElements.has(node2.tagName) || !whitespace(child)) {
        children.push(child.value);
      }
    } else if (child.type === "raw" && !context.options.skipHtml) {
      children.push(child.value);
    }
  }
  return children;
}
function toReact(context, node2, index2, parent) {
  const options = context.options;
  const transform = options.transformLinkUri === void 0 ? uriTransformer : options.transformLinkUri;
  const parentSchema = context.schema;
  const name = node2.tagName;
  const properties = {};
  let schema = parentSchema;
  let property;
  if (parentSchema.space === "html" && name === "svg") {
    schema = svg2;
    context.schema = schema;
  }
  if (node2.properties) {
    for (property in node2.properties) {
      if (own6.call(node2.properties, property)) {
        addProperty(properties, property, node2.properties[property], context);
      }
    }
  }
  if (name === "ol" || name === "ul") {
    context.listDepth++;
  }
  const children = childrenToReact(context, node2);
  if (name === "ol" || name === "ul") {
    context.listDepth--;
  }
  context.schema = parentSchema;
  const position3 = node2.position || {
    start: { line: null, column: null, offset: null },
    end: { line: null, column: null, offset: null }
  };
  const component = options.components && own6.call(options.components, name) ? options.components[name] : name;
  const basic = typeof component === "string" || component === import_react2.default.Fragment;
  if (!import_react_is.default.isValidElementType(component)) {
    throw new TypeError(
      `Component for name \`${name}\` not defined or is not renderable`
    );
  }
  properties.key = index2;
  if (name === "a" && options.linkTarget) {
    properties.target = typeof options.linkTarget === "function" ? options.linkTarget(
      String(properties.href || ""),
      node2.children,
      typeof properties.title === "string" ? properties.title : null
    ) : options.linkTarget;
  }
  if (name === "a" && transform) {
    properties.href = transform(
      String(properties.href || ""),
      node2.children,
      typeof properties.title === "string" ? properties.title : null
    );
  }
  if (!basic && name === "code" && parent.type === "element" && parent.tagName !== "pre") {
    properties.inline = true;
  }
  if (!basic && (name === "h1" || name === "h2" || name === "h3" || name === "h4" || name === "h5" || name === "h6")) {
    properties.level = Number.parseInt(name.charAt(1), 10);
  }
  if (name === "img" && options.transformImageUri) {
    properties.src = options.transformImageUri(
      String(properties.src || ""),
      String(properties.alt || ""),
      typeof properties.title === "string" ? properties.title : null
    );
  }
  if (!basic && name === "li" && parent.type === "element") {
    const input = getInputElement(node2);
    properties.checked = input && input.properties ? Boolean(input.properties.checked) : null;
    properties.index = getElementsBeforeCount(parent, node2);
    properties.ordered = parent.tagName === "ol";
  }
  if (!basic && (name === "ol" || name === "ul")) {
    properties.ordered = name === "ol";
    properties.depth = context.listDepth;
  }
  if (name === "td" || name === "th") {
    if (properties.align) {
      if (!properties.style) properties.style = {};
      properties.style.textAlign = properties.align;
      delete properties.align;
    }
    if (!basic) {
      properties.isHeader = name === "th";
    }
  }
  if (!basic && name === "tr" && parent.type === "element") {
    properties.isHeader = Boolean(parent.tagName === "thead");
  }
  if (options.sourcePos) {
    properties["data-sourcepos"] = flattenPosition(position3);
  }
  if (!basic && options.rawSourcePos) {
    properties.sourcePosition = node2.position;
  }
  if (!basic && options.includeElementIndex) {
    properties.index = getElementsBeforeCount(parent, node2);
    properties.siblingCount = getElementsBeforeCount(parent);
  }
  if (!basic) {
    properties.node = node2;
  }
  return children.length > 0 ? import_react2.default.createElement(component, properties, children) : import_react2.default.createElement(component, properties);
}
function getInputElement(node2) {
  let index2 = -1;
  while (++index2 < node2.children.length) {
    const child = node2.children[index2];
    if (child.type === "element" && child.tagName === "input") {
      return child;
    }
  }
  return null;
}
function getElementsBeforeCount(parent, node2) {
  let index2 = -1;
  let count = 0;
  while (++index2 < parent.children.length) {
    if (parent.children[index2] === node2) break;
    if (parent.children[index2].type === "element") count++;
  }
  return count;
}
function addProperty(props, prop, value, ctx) {
  const info = find(ctx.schema, prop);
  let result = value;
  if (result === null || result === void 0 || result !== result) {
    return;
  }
  if (Array.isArray(result)) {
    result = info.commaSeparated ? stringify3(result) : stringify2(result);
  }
  if (info.property === "style" && typeof result === "string") {
    result = parseStyle(result);
  }
  if (info.space && info.property) {
    props[own6.call(hastToReact, info.property) ? hastToReact[info.property] : info.property] = result;
  } else if (info.attribute) {
    props[info.attribute] = result;
  }
}
function parseStyle(value) {
  const result = {};
  try {
    style_to_object_default(value, iterator);
  } catch {
  }
  return result;
  function iterator(name, v) {
    const k = name.slice(0, 4) === "-ms-" ? `ms-${name.slice(4)}` : name;
    result[k.replace(/-([a-z])/g, styleReplacer)] = v;
  }
}
function styleReplacer(_, $1) {
  return $1.toUpperCase();
}
function flattenPosition(pos) {
  return [
    pos.start.line,
    ":",
    pos.start.column,
    "-",
    pos.end.line,
    ":",
    pos.end.column
  ].map(String).join("");
}
var import_dist457, import_dist458, import_dist459, import_react2, import_react_is, own6, tableElements;
var init_ast_to_react = __esm({
  "node_modules/react-markdown/lib/ast-to-react.js"() {
    import_dist457 = __toESM(require_dist(), 1);
    import_dist458 = __toESM(require_dist2(), 1);
    import_dist459 = __toESM(require_dist3(), 1);
    import_react2 = __toESM(require_react(), 1);
    import_react_is = __toESM(require_react_is(), 1);
    init_hast_util_whitespace();
    init_property_information();
    init_space_separated_tokens();
    init_comma_separated_tokens();
    init_style_to_object();
    init_uri_transformer();
    own6 = {}.hasOwnProperty;
    tableElements = /* @__PURE__ */ new Set(["table", "thead", "tbody", "tfoot", "tr"]);
  }
});

// node_modules/react-markdown/lib/react-markdown.js
function ReactMarkdown(options) {
  for (const key in deprecated) {
    if (own7.call(deprecated, key) && own7.call(options, key)) {
      const deprecation = deprecated[key];
      console.warn(
        `[react-markdown] Warning: please ${deprecation.to ? `use \`${deprecation.to}\` instead of` : "remove"} \`${key}\` (see <${changelog}#${deprecation.id}> for more info)`
      );
      delete deprecated[key];
    }
  }
  const processor = unified().use(remarkParse).use(options.remarkPlugins || []).use(lib_default, {
    ...options.remarkRehypeOptions,
    allowDangerousHtml: true
  }).use(options.rehypePlugins || []).use(rehypeFilter, options);
  const file = new VFile();
  if (typeof options.children === "string") {
    file.value = options.children;
  } else if (options.children !== void 0 && options.children !== null) {
    console.warn(
      `[react-markdown] Warning: please pass a string as \`children\` (not: \`${options.children}\`)`
    );
  }
  const hastNode = processor.runSync(processor.parse(file), file);
  if (hastNode.type !== "root") {
    throw new TypeError("Expected a `root` node");
  }
  let result = import_react3.default.createElement(
    import_react3.default.Fragment,
    {},
    childrenToReact({ options, schema: html3, listDepth: 0 }, hastNode)
  );
  if (options.className) {
    result = import_react3.default.createElement("div", { className: options.className }, result);
  }
  return result;
}
var import_dist460, import_dist461, import_dist462, import_react3, import_prop_types, own7, changelog, deprecated;
var init_react_markdown = __esm({
  "node_modules/react-markdown/lib/react-markdown.js"() {
    import_dist460 = __toESM(require_dist(), 1);
    import_dist461 = __toESM(require_dist2(), 1);
    import_dist462 = __toESM(require_dist3(), 1);
    import_react3 = __toESM(require_react(), 1);
    init_vfile();
    init_unified();
    init_remark_parse();
    init_remark_rehype();
    import_prop_types = __toESM(require_prop_types(), 1);
    init_property_information();
    init_rehype_filter();
    init_ast_to_react();
    own7 = {}.hasOwnProperty;
    changelog = "https://github.com/remarkjs/react-markdown/blob/main/changelog.md";
    deprecated = {
      plugins: { to: "remarkPlugins", id: "change-plugins-to-remarkplugins" },
      renderers: { to: "components", id: "change-renderers-to-components" },
      astPlugins: { id: "remove-buggy-html-in-markdown-parser" },
      allowDangerousHtml: { id: "remove-buggy-html-in-markdown-parser" },
      escapeHtml: { id: "remove-buggy-html-in-markdown-parser" },
      source: { to: "children", id: "change-source-to-children" },
      allowNode: {
        to: "allowElement",
        id: "replace-allownode-allowedtypes-and-disallowedtypes"
      },
      allowedTypes: {
        to: "allowedElements",
        id: "replace-allownode-allowedtypes-and-disallowedtypes"
      },
      disallowedTypes: {
        to: "disallowedElements",
        id: "replace-allownode-allowedtypes-and-disallowedtypes"
      },
      includeNodeIndex: {
        to: "includeElementIndex",
        id: "change-includenodeindex-to-includeelementindex"
      }
    };
    ReactMarkdown.propTypes = {
      // Core options:
      children: import_prop_types.default.string,
      // Layout options:
      className: import_prop_types.default.string,
      // Filter options:
      allowElement: import_prop_types.default.func,
      allowedElements: import_prop_types.default.arrayOf(import_prop_types.default.string),
      disallowedElements: import_prop_types.default.arrayOf(import_prop_types.default.string),
      unwrapDisallowed: import_prop_types.default.bool,
      // Plugin options:
      remarkPlugins: import_prop_types.default.arrayOf(
        import_prop_types.default.oneOfType([
          import_prop_types.default.object,
          import_prop_types.default.func,
          import_prop_types.default.arrayOf(
            import_prop_types.default.oneOfType([
              import_prop_types.default.bool,
              import_prop_types.default.string,
              import_prop_types.default.object,
              import_prop_types.default.func,
              import_prop_types.default.arrayOf(
                // prettier-ignore
                // type-coverage:ignore-next-line
                import_prop_types.default.any
              )
            ])
          )
        ])
      ),
      rehypePlugins: import_prop_types.default.arrayOf(
        import_prop_types.default.oneOfType([
          import_prop_types.default.object,
          import_prop_types.default.func,
          import_prop_types.default.arrayOf(
            import_prop_types.default.oneOfType([
              import_prop_types.default.bool,
              import_prop_types.default.string,
              import_prop_types.default.object,
              import_prop_types.default.func,
              import_prop_types.default.arrayOf(
                // prettier-ignore
                // type-coverage:ignore-next-line
                import_prop_types.default.any
              )
            ])
          )
        ])
      ),
      // Transform options:
      sourcePos: import_prop_types.default.bool,
      rawSourcePos: import_prop_types.default.bool,
      skipHtml: import_prop_types.default.bool,
      includeElementIndex: import_prop_types.default.bool,
      transformLinkUri: import_prop_types.default.oneOfType([import_prop_types.default.func, import_prop_types.default.bool]),
      linkTarget: import_prop_types.default.oneOfType([import_prop_types.default.func, import_prop_types.default.string]),
      transformImageUri: import_prop_types.default.func,
      components: import_prop_types.default.object
    };
  }
});

// node_modules/react-markdown/index.js
var react_markdown_exports = {};
__export(react_markdown_exports, {
  default: () => ReactMarkdown,
  uriTransformer: () => uriTransformer
});
var import_dist463, import_dist464, import_dist465;
var init_react_markdown2 = __esm({
  "node_modules/react-markdown/index.js"() {
    import_dist463 = __toESM(require_dist());
    import_dist464 = __toESM(require_dist2());
    import_dist465 = __toESM(require_dist3());
    init_uri_transformer();
    init_react_markdown();
  }
});

// node_modules/micromark/dist/constant/has-own-property.js
var require_has_own_property = __commonJS({
  "node_modules/micromark/dist/constant/has-own-property.js"(exports, module) {
    "use strict";
    var import_dist466 = __toESM(require_dist());
    var import_dist467 = __toESM(require_dist2());
    var import_dist468 = __toESM(require_dist3());
    var own8 = {}.hasOwnProperty;
    module.exports = own8;
  }
});

// node_modules/micromark/dist/constant/splice.js
var require_splice = __commonJS({
  "node_modules/micromark/dist/constant/splice.js"(exports, module) {
    "use strict";
    var import_dist466 = __toESM(require_dist());
    var import_dist467 = __toESM(require_dist2());
    var import_dist468 = __toESM(require_dist3());
    var splice2 = [].splice;
    module.exports = splice2;
  }
});

// node_modules/micromark/dist/util/chunked-splice.js
var require_chunked_splice = __commonJS({
  "node_modules/micromark/dist/util/chunked-splice.js"(exports, module) {
    "use strict";
    var import_dist466 = __toESM(require_dist());
    var import_dist467 = __toESM(require_dist2());
    var import_dist468 = __toESM(require_dist3());
    var splice2 = require_splice();
    function chunkedSplice(list3, start, remove, items) {
      var end = list3.length;
      var chunkStart = 0;
      var parameters;
      if (start < 0) {
        start = -start > end ? 0 : end + start;
      } else {
        start = start > end ? end : start;
      }
      remove = remove > 0 ? remove : 0;
      if (items.length < 1e4) {
        parameters = Array.from(items);
        parameters.unshift(start, remove);
        splice2.apply(list3, parameters);
      } else {
        if (remove) splice2.apply(list3, [start, remove]);
        while (chunkStart < items.length) {
          parameters = items.slice(chunkStart, chunkStart + 1e4);
          parameters.unshift(start, 0);
          splice2.apply(list3, parameters);
          chunkStart += 1e4;
          start += 1e4;
        }
      }
    }
    module.exports = chunkedSplice;
  }
});

// node_modules/micromark/dist/util/miniflat.js
var require_miniflat = __commonJS({
  "node_modules/micromark/dist/util/miniflat.js"(exports, module) {
    "use strict";
    var import_dist466 = __toESM(require_dist());
    var import_dist467 = __toESM(require_dist2());
    var import_dist468 = __toESM(require_dist3());
    function miniflat(value) {
      return value === null || value === void 0 ? [] : "length" in value ? value : [value];
    }
    module.exports = miniflat;
  }
});

// node_modules/micromark/dist/util/combine-extensions.js
var require_combine_extensions = __commonJS({
  "node_modules/micromark/dist/util/combine-extensions.js"(exports, module) {
    "use strict";
    var import_dist466 = __toESM(require_dist());
    var import_dist467 = __toESM(require_dist2());
    var import_dist468 = __toESM(require_dist3());
    var hasOwnProperty2 = require_has_own_property();
    var chunkedSplice = require_chunked_splice();
    var miniflat = require_miniflat();
    function combineExtensions2(extensions) {
      var all3 = {};
      var index2 = -1;
      while (++index2 < extensions.length) {
        extension2(all3, extensions[index2]);
      }
      return all3;
    }
    function extension2(all3, extension3) {
      var hook;
      var left;
      var right;
      var code2;
      for (hook in extension3) {
        left = hasOwnProperty2.call(all3, hook) ? all3[hook] : all3[hook] = {};
        right = extension3[hook];
        for (code2 in right) {
          left[code2] = constructs2(
            miniflat(right[code2]),
            hasOwnProperty2.call(left, code2) ? left[code2] : []
          );
        }
      }
    }
    function constructs2(list3, existing) {
      var index2 = -1;
      var before = [];
      while (++index2 < list3.length) {
        ;
        (list3[index2].add === "after" ? existing : before).push(list3[index2]);
      }
      chunkedSplice(existing, 0, 0, before);
      return existing;
    }
    module.exports = combineExtensions2;
  }
});

// node_modules/micromark/dist/constant/from-char-code.js
var require_from_char_code = __commonJS({
  "node_modules/micromark/dist/constant/from-char-code.js"(exports, module) {
    "use strict";
    var import_dist466 = __toESM(require_dist());
    var import_dist467 = __toESM(require_dist2());
    var import_dist468 = __toESM(require_dist3());
    var fromCharCode = String.fromCharCode;
    module.exports = fromCharCode;
  }
});

// node_modules/micromark/dist/util/regex-check.js
var require_regex_check = __commonJS({
  "node_modules/micromark/dist/util/regex-check.js"(exports, module) {
    "use strict";
    var import_dist466 = __toESM(require_dist());
    var import_dist467 = __toESM(require_dist2());
    var import_dist468 = __toESM(require_dist3());
    var fromCharCode = require_from_char_code();
    function regexCheck2(regex) {
      return check;
      function check(code2) {
        return regex.test(fromCharCode(code2));
      }
    }
    module.exports = regexCheck2;
  }
});

// node_modules/micromark/dist/character/ascii-alpha.js
var require_ascii_alpha = __commonJS({
  "node_modules/micromark/dist/character/ascii-alpha.js"(exports, module) {
    "use strict";
    var import_dist466 = __toESM(require_dist());
    var import_dist467 = __toESM(require_dist2());
    var import_dist468 = __toESM(require_dist3());
    var regexCheck2 = require_regex_check();
    var asciiAlpha2 = regexCheck2(/[A-Za-z]/);
    module.exports = asciiAlpha2;
  }
});

// node_modules/micromark/dist/character/ascii-alphanumeric.js
var require_ascii_alphanumeric = __commonJS({
  "node_modules/micromark/dist/character/ascii-alphanumeric.js"(exports, module) {
    "use strict";
    var import_dist466 = __toESM(require_dist());
    var import_dist467 = __toESM(require_dist2());
    var import_dist468 = __toESM(require_dist3());
    var regexCheck2 = require_regex_check();
    var asciiAlphanumeric2 = regexCheck2(/[\dA-Za-z]/);
    module.exports = asciiAlphanumeric2;
  }
});

// node_modules/micromark/dist/character/ascii-control.js
var require_ascii_control = __commonJS({
  "node_modules/micromark/dist/character/ascii-control.js"(exports, module) {
    "use strict";
    var import_dist466 = __toESM(require_dist());
    var import_dist467 = __toESM(require_dist2());
    var import_dist468 = __toESM(require_dist3());
    function asciiControl2(code2) {
      return (
        // Special whitespace codes (which have negative values), C0 and Control
        // character DEL
        code2 < 32 || code2 === 127
      );
    }
    module.exports = asciiControl2;
  }
});

// node_modules/micromark/dist/character/markdown-line-ending.js
var require_markdown_line_ending = __commonJS({
  "node_modules/micromark/dist/character/markdown-line-ending.js"(exports, module) {
    "use strict";
    var import_dist466 = __toESM(require_dist());
    var import_dist467 = __toESM(require_dist2());
    var import_dist468 = __toESM(require_dist3());
    function markdownLineEnding2(code2) {
      return code2 < -2;
    }
    module.exports = markdownLineEnding2;
  }
});

// node_modules/micromark/dist/constant/unicode-punctuation-regex.js
var require_unicode_punctuation_regex = __commonJS({
  "node_modules/micromark/dist/constant/unicode-punctuation-regex.js"(exports, module) {
    "use strict";
    var import_dist466 = __toESM(require_dist());
    var import_dist467 = __toESM(require_dist2());
    var import_dist468 = __toESM(require_dist3());
    var unicodePunctuation2 = /[!-\/:-@\[-`\{-~\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u2E52\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]/;
    module.exports = unicodePunctuation2;
  }
});

// node_modules/micromark/dist/character/unicode-punctuation.js
var require_unicode_punctuation = __commonJS({
  "node_modules/micromark/dist/character/unicode-punctuation.js"(exports, module) {
    "use strict";
    var import_dist466 = __toESM(require_dist());
    var import_dist467 = __toESM(require_dist2());
    var import_dist468 = __toESM(require_dist3());
    var unicodePunctuationRegex2 = require_unicode_punctuation_regex();
    var regexCheck2 = require_regex_check();
    var unicodePunctuation2 = regexCheck2(unicodePunctuationRegex2);
    module.exports = unicodePunctuation2;
  }
});

// node_modules/micromark/dist/character/unicode-whitespace.js
var require_unicode_whitespace = __commonJS({
  "node_modules/micromark/dist/character/unicode-whitespace.js"(exports, module) {
    "use strict";
    var import_dist466 = __toESM(require_dist());
    var import_dist467 = __toESM(require_dist2());
    var import_dist468 = __toESM(require_dist3());
    var regexCheck2 = require_regex_check();
    var unicodeWhitespace2 = regexCheck2(/\s/);
    module.exports = unicodeWhitespace2;
  }
});

// node_modules/micromark-extension-gfm-autolink-literal/syntax.js
var require_syntax = __commonJS({
  "node_modules/micromark-extension-gfm-autolink-literal/syntax.js"(exports) {
    var import_dist466 = __toESM(require_dist());
    var import_dist467 = __toESM(require_dist2());
    var import_dist468 = __toESM(require_dist3());
    var asciiAlpha2 = require_ascii_alpha();
    var asciiAlphanumeric2 = require_ascii_alphanumeric();
    var asciiControl2 = require_ascii_control();
    var markdownLineEnding2 = require_markdown_line_ending();
    var unicodePunctuation2 = require_unicode_punctuation();
    var unicodeWhitespace2 = require_unicode_whitespace();
    var www = { tokenize: tokenizeWww, partial: true };
    var domain = { tokenize: tokenizeDomain, partial: true };
    var path2 = { tokenize: tokenizePath, partial: true };
    var punctuation = { tokenize: tokenizePunctuation, partial: true };
    var namedCharacterReference = {
      tokenize: tokenizeNamedCharacterReference,
      partial: true
    };
    var wwwAutolink = { tokenize: tokenizeWwwAutolink, previous: previousWww };
    var httpAutolink = { tokenize: tokenizeHttpAutolink, previous: previousHttp };
    var emailAutolink = { tokenize: tokenizeEmailAutolink, previous: previousEmail };
    var text4 = {};
    exports.text = text4;
    var code2 = 48;
    while (code2 < 123) {
      text4[code2] = emailAutolink;
      code2++;
      if (code2 === 58) code2 = 65;
      else if (code2 === 91) code2 = 97;
    }
    text4[43] = emailAutolink;
    text4[45] = emailAutolink;
    text4[46] = emailAutolink;
    text4[95] = emailAutolink;
    text4[72] = [emailAutolink, httpAutolink];
    text4[104] = [emailAutolink, httpAutolink];
    text4[87] = [emailAutolink, wwwAutolink];
    text4[119] = [emailAutolink, wwwAutolink];
    function tokenizeEmailAutolink(effects, ok3, nok) {
      var self2 = this;
      var hasDot;
      return start;
      function start(code3) {
        if (!gfmAtext(code3) || !previousEmail(self2.previous) || previous2(self2.events)) {
          return nok(code3);
        }
        effects.enter("literalAutolink");
        effects.enter("literalAutolinkEmail");
        return atext(code3);
      }
      function atext(code3) {
        if (gfmAtext(code3)) {
          effects.consume(code3);
          return atext;
        }
        if (code3 === 64) {
          effects.consume(code3);
          return label;
        }
        return nok(code3);
      }
      function label(code3) {
        if (code3 === 46) {
          return effects.check(punctuation, done, dotContinuation)(code3);
        }
        if (
          // `-`
          code3 === 45 || // `_`
          code3 === 95
        ) {
          return effects.check(punctuation, nok, dashOrUnderscoreContinuation)(code3);
        }
        if (asciiAlphanumeric2(code3)) {
          effects.consume(code3);
          return label;
        }
        return done(code3);
      }
      function dotContinuation(code3) {
        effects.consume(code3);
        hasDot = true;
        return label;
      }
      function dashOrUnderscoreContinuation(code3) {
        effects.consume(code3);
        return afterDashOrUnderscore;
      }
      function afterDashOrUnderscore(code3) {
        if (code3 === 46) {
          return effects.check(punctuation, nok, dotContinuation)(code3);
        }
        return label(code3);
      }
      function done(code3) {
        if (hasDot) {
          effects.exit("literalAutolinkEmail");
          effects.exit("literalAutolink");
          return ok3(code3);
        }
        return nok(code3);
      }
    }
    function tokenizeWwwAutolink(effects, ok3, nok) {
      var self2 = this;
      return start;
      function start(code3) {
        if (code3 !== 87 && code3 - 32 !== 87 || !previousWww(self2.previous) || previous2(self2.events)) {
          return nok(code3);
        }
        effects.enter("literalAutolink");
        effects.enter("literalAutolinkWww");
        return effects.check(
          www,
          effects.attempt(domain, effects.attempt(path2, done), nok),
          nok
        )(code3);
      }
      function done(code3) {
        effects.exit("literalAutolinkWww");
        effects.exit("literalAutolink");
        return ok3(code3);
      }
    }
    function tokenizeHttpAutolink(effects, ok3, nok) {
      var self2 = this;
      return start;
      function start(code3) {
        if (code3 !== 72 && code3 - 32 !== 72 || !previousHttp(self2.previous) || previous2(self2.events)) {
          return nok(code3);
        }
        effects.enter("literalAutolink");
        effects.enter("literalAutolinkHttp");
        effects.consume(code3);
        return t1;
      }
      function t1(code3) {
        if (code3 === 84 || code3 - 32 === 84) {
          effects.consume(code3);
          return t2;
        }
        return nok(code3);
      }
      function t2(code3) {
        if (code3 === 84 || code3 - 32 === 84) {
          effects.consume(code3);
          return p;
        }
        return nok(code3);
      }
      function p(code3) {
        if (code3 === 80 || code3 - 32 === 80) {
          effects.consume(code3);
          return s;
        }
        return nok(code3);
      }
      function s(code3) {
        if (code3 === 83 || code3 - 32 === 83) {
          effects.consume(code3);
          return colon;
        }
        return colon(code3);
      }
      function colon(code3) {
        if (code3 === 58) {
          effects.consume(code3);
          return slash1;
        }
        return nok(code3);
      }
      function slash1(code3) {
        if (code3 === 47) {
          effects.consume(code3);
          return slash2;
        }
        return nok(code3);
      }
      function slash2(code3) {
        if (code3 === 47) {
          effects.consume(code3);
          return after;
        }
        return nok(code3);
      }
      function after(code3) {
        return asciiControl2(code3) || unicodeWhitespace2(code3) || unicodePunctuation2(code3) ? nok(code3) : effects.attempt(domain, effects.attempt(path2, done), nok)(code3);
      }
      function done(code3) {
        effects.exit("literalAutolinkHttp");
        effects.exit("literalAutolink");
        return ok3(code3);
      }
    }
    function tokenizeWww(effects, ok3, nok) {
      return start;
      function start(code3) {
        effects.consume(code3);
        return w2;
      }
      function w2(code3) {
        if (code3 === 87 || code3 - 32 === 87) {
          effects.consume(code3);
          return w3;
        }
        return nok(code3);
      }
      function w3(code3) {
        if (code3 === 87 || code3 - 32 === 87) {
          effects.consume(code3);
          return dot;
        }
        return nok(code3);
      }
      function dot(code3) {
        if (code3 === 46) {
          effects.consume(code3);
          return after;
        }
        return nok(code3);
      }
      function after(code3) {
        return code3 === null || markdownLineEnding2(code3) ? nok(code3) : ok3(code3);
      }
    }
    function tokenizeDomain(effects, ok3, nok) {
      var hasUnderscoreInLastSegment;
      var hasUnderscoreInLastLastSegment;
      return domain2;
      function domain2(code3) {
        if (code3 === 38) {
          return effects.check(
            namedCharacterReference,
            done,
            punctuationContinuation
          )(code3);
        }
        if (code3 === 46 || code3 === 95) {
          return effects.check(punctuation, done, punctuationContinuation)(code3);
        }
        if (asciiControl2(code3) || unicodeWhitespace2(code3) || code3 !== 45 && unicodePunctuation2(code3)) {
          return done(code3);
        }
        effects.consume(code3);
        return domain2;
      }
      function punctuationContinuation(code3) {
        if (code3 === 46) {
          hasUnderscoreInLastLastSegment = hasUnderscoreInLastSegment;
          hasUnderscoreInLastSegment = void 0;
          effects.consume(code3);
          return domain2;
        }
        if (code3 === 95) hasUnderscoreInLastSegment = true;
        effects.consume(code3);
        return domain2;
      }
      function done(code3) {
        if (!hasUnderscoreInLastLastSegment && !hasUnderscoreInLastSegment) {
          return ok3(code3);
        }
        return nok(code3);
      }
    }
    function tokenizePath(effects, ok3) {
      var balance = 0;
      return inPath;
      function inPath(code3) {
        if (code3 === 38) {
          return effects.check(
            namedCharacterReference,
            ok3,
            continuedPunctuation
          )(code3);
        }
        if (code3 === 40) {
          balance++;
        }
        if (code3 === 41) {
          return effects.check(
            punctuation,
            parenAtPathEnd,
            continuedPunctuation
          )(code3);
        }
        if (pathEnd(code3)) {
          return ok3(code3);
        }
        if (trailingPunctuation(code3)) {
          return effects.check(punctuation, ok3, continuedPunctuation)(code3);
        }
        effects.consume(code3);
        return inPath;
      }
      function continuedPunctuation(code3) {
        effects.consume(code3);
        return inPath;
      }
      function parenAtPathEnd(code3) {
        balance--;
        return balance < 0 ? ok3(code3) : continuedPunctuation(code3);
      }
    }
    function tokenizeNamedCharacterReference(effects, ok3, nok) {
      return start;
      function start(code3) {
        effects.consume(code3);
        return inside;
      }
      function inside(code3) {
        if (asciiAlpha2(code3)) {
          effects.consume(code3);
          return inside;
        }
        if (code3 === 59) {
          effects.consume(code3);
          return after;
        }
        return nok(code3);
      }
      function after(code3) {
        return pathEnd(code3) ? ok3(code3) : nok(code3);
      }
    }
    function tokenizePunctuation(effects, ok3, nok) {
      return start;
      function start(code3) {
        effects.consume(code3);
        return after;
      }
      function after(code3) {
        if (trailingPunctuation(code3)) {
          effects.consume(code3);
          return after;
        }
        return pathEnd(code3) ? ok3(code3) : nok(code3);
      }
    }
    function trailingPunctuation(code3) {
      return (
        // `!`
        code3 === 33 || // `"`
        code3 === 34 || // `'`
        code3 === 39 || // `)`
        code3 === 41 || // `*`
        code3 === 42 || // `,`
        code3 === 44 || // `.`
        code3 === 46 || // `:`
        code3 === 58 || // `;`
        code3 === 59 || // `<`
        code3 === 60 || // `?`
        code3 === 63 || // `_`.
        code3 === 95 || // `~`
        code3 === 126
      );
    }
    function pathEnd(code3) {
      return (
        // EOF.
        code3 === null || // CR, LF, CRLF, HT, VS.
        code3 < 0 || // Space.
        code3 === 32 || // `<`
        code3 === 60
      );
    }
    function gfmAtext(code3) {
      return code3 === 43 || code3 === 45 || code3 === 46 || code3 === 95 || asciiAlphanumeric2(code3);
    }
    function previousWww(code3) {
      return code3 === null || code3 < 0 || code3 === 32 || code3 === 40 || code3 === 42 || code3 === 95 || code3 === 126;
    }
    function previousHttp(code3) {
      return code3 === null || !asciiAlpha2(code3);
    }
    function previousEmail(code3) {
      return code3 !== 47 && previousHttp(code3);
    }
    function previous2(events) {
      var index2 = events.length;
      while (index2--) {
        if ((events[index2][1].type === "labelLink" || events[index2][1].type === "labelImage") && !events[index2][1]._balanced) {
          return true;
        }
      }
    }
  }
});

// node_modules/micromark-extension-gfm-autolink-literal/index.js
var require_micromark_extension_gfm_autolink_literal = __commonJS({
  "node_modules/micromark-extension-gfm-autolink-literal/index.js"(exports, module) {
    var import_dist466 = __toESM(require_dist());
    var import_dist467 = __toESM(require_dist2());
    var import_dist468 = __toESM(require_dist3());
    module.exports = require_syntax();
  }
});

// node_modules/micromark/dist/character/markdown-line-ending-or-space.js
var require_markdown_line_ending_or_space = __commonJS({
  "node_modules/micromark/dist/character/markdown-line-ending-or-space.js"(exports, module) {
    "use strict";
    var import_dist466 = __toESM(require_dist());
    var import_dist467 = __toESM(require_dist2());
    var import_dist468 = __toESM(require_dist3());
    function markdownLineEndingOrSpace2(code2) {
      return code2 < 0 || code2 === 32;
    }
    module.exports = markdownLineEndingOrSpace2;
  }
});

// node_modules/micromark/dist/util/classify-character.js
var require_classify_character = __commonJS({
  "node_modules/micromark/dist/util/classify-character.js"(exports, module) {
    "use strict";
    var import_dist466 = __toESM(require_dist());
    var import_dist467 = __toESM(require_dist2());
    var import_dist468 = __toESM(require_dist3());
    var markdownLineEndingOrSpace2 = require_markdown_line_ending_or_space();
    var unicodePunctuation2 = require_unicode_punctuation();
    var unicodeWhitespace2 = require_unicode_whitespace();
    function classifyCharacter2(code2) {
      if (code2 === null || markdownLineEndingOrSpace2(code2) || unicodeWhitespace2(code2)) {
        return 1;
      }
      if (unicodePunctuation2(code2)) {
        return 2;
      }
    }
    module.exports = classifyCharacter2;
  }
});

// node_modules/micromark/dist/util/resolve-all.js
var require_resolve_all = __commonJS({
  "node_modules/micromark/dist/util/resolve-all.js"(exports, module) {
    "use strict";
    var import_dist466 = __toESM(require_dist());
    var import_dist467 = __toESM(require_dist2());
    var import_dist468 = __toESM(require_dist3());
    function resolveAll2(constructs2, events, context) {
      var called = [];
      var index2 = -1;
      var resolve;
      while (++index2 < constructs2.length) {
        resolve = constructs2[index2].resolveAll;
        if (resolve && called.indexOf(resolve) < 0) {
          events = resolve(events, context);
          called.push(resolve);
        }
      }
      return events;
    }
    module.exports = resolveAll2;
  }
});

// node_modules/micromark/dist/constant/assign.js
var require_assign = __commonJS({
  "node_modules/micromark/dist/constant/assign.js"(exports, module) {
    "use strict";
    var import_dist466 = __toESM(require_dist());
    var import_dist467 = __toESM(require_dist2());
    var import_dist468 = __toESM(require_dist3());
    var assign = Object.assign;
    module.exports = assign;
  }
});

// node_modules/micromark/dist/util/shallow.js
var require_shallow = __commonJS({
  "node_modules/micromark/dist/util/shallow.js"(exports, module) {
    "use strict";
    var import_dist466 = __toESM(require_dist());
    var import_dist467 = __toESM(require_dist2());
    var import_dist468 = __toESM(require_dist3());
    var assign = require_assign();
    function shallow(object) {
      return assign({}, object);
    }
    module.exports = shallow;
  }
});

// node_modules/micromark-extension-gfm-strikethrough/index.js
var require_micromark_extension_gfm_strikethrough = __commonJS({
  "node_modules/micromark-extension-gfm-strikethrough/index.js"(exports, module) {
    var import_dist466 = __toESM(require_dist());
    var import_dist467 = __toESM(require_dist2());
    var import_dist468 = __toESM(require_dist3());
    module.exports = create2;
    var classifyCharacter2 = require_classify_character();
    var chunkedSplice = require_chunked_splice();
    var resolveAll2 = require_resolve_all();
    var shallow = require_shallow();
    function create2(options) {
      var settings = options || {};
      var single = settings.singleTilde;
      var tokenizer = {
        tokenize: tokenizeStrikethrough,
        resolveAll: resolveAllStrikethrough
      };
      if (single === null || single === void 0) {
        single = true;
      }
      return { text: { 126: tokenizer }, insideSpan: { null: tokenizer } };
      function resolveAllStrikethrough(events, context) {
        var index2 = -1;
        var strikethrough2;
        var text4;
        var open;
        var nextEvents;
        while (++index2 < events.length) {
          if (events[index2][0] === "enter" && events[index2][1].type === "strikethroughSequenceTemporary" && events[index2][1]._close) {
            open = index2;
            while (open--) {
              if (events[open][0] === "exit" && events[open][1].type === "strikethroughSequenceTemporary" && events[open][1]._open && // If the sizes are the same:
              events[index2][1].end.offset - events[index2][1].start.offset === events[open][1].end.offset - events[open][1].start.offset) {
                events[index2][1].type = "strikethroughSequence";
                events[open][1].type = "strikethroughSequence";
                strikethrough2 = {
                  type: "strikethrough",
                  start: shallow(events[open][1].start),
                  end: shallow(events[index2][1].end)
                };
                text4 = {
                  type: "strikethroughText",
                  start: shallow(events[open][1].end),
                  end: shallow(events[index2][1].start)
                };
                nextEvents = [
                  ["enter", strikethrough2, context],
                  ["enter", events[open][1], context],
                  ["exit", events[open][1], context],
                  ["enter", text4, context]
                ];
                chunkedSplice(
                  nextEvents,
                  nextEvents.length,
                  0,
                  resolveAll2(
                    context.parser.constructs.insideSpan.null,
                    events.slice(open + 1, index2),
                    context
                  )
                );
                chunkedSplice(nextEvents, nextEvents.length, 0, [
                  ["exit", text4, context],
                  ["enter", events[index2][1], context],
                  ["exit", events[index2][1], context],
                  ["exit", strikethrough2, context]
                ]);
                chunkedSplice(events, open - 1, index2 - open + 3, nextEvents);
                index2 = open + nextEvents.length - 2;
                break;
              }
            }
          }
        }
        return removeRemainingSequences(events);
      }
      function removeRemainingSequences(events) {
        var index2 = -1;
        var length = events.length;
        while (++index2 < length) {
          if (events[index2][1].type === "strikethroughSequenceTemporary") {
            events[index2][1].type = "data";
          }
        }
        return events;
      }
      function tokenizeStrikethrough(effects, ok3, nok) {
        var previous2 = this.previous;
        var events = this.events;
        var size = 0;
        return start;
        function start(code2) {
          if (code2 !== 126 || previous2 === 126 && events[events.length - 1][1].type !== "characterEscape") {
            return nok(code2);
          }
          effects.enter("strikethroughSequenceTemporary");
          return more(code2);
        }
        function more(code2) {
          var before = classifyCharacter2(previous2);
          var token;
          var after;
          if (code2 === 126) {
            if (size > 1) return nok(code2);
            effects.consume(code2);
            size++;
            return more;
          }
          if (size < 2 && !single) return nok(code2);
          token = effects.exit("strikethroughSequenceTemporary");
          after = classifyCharacter2(code2);
          token._open = !after || after === 2 && before;
          token._close = !before || before === 2 && after;
          return ok3(code2);
        }
      }
    }
  }
});

// node_modules/micromark/dist/character/markdown-space.js
var require_markdown_space = __commonJS({
  "node_modules/micromark/dist/character/markdown-space.js"(exports, module) {
    "use strict";
    var import_dist466 = __toESM(require_dist());
    var import_dist467 = __toESM(require_dist2());
    var import_dist468 = __toESM(require_dist3());
    function markdownSpace2(code2) {
      return code2 === -2 || code2 === -1 || code2 === 32;
    }
    module.exports = markdownSpace2;
  }
});

// node_modules/micromark/dist/tokenize/factory-space.js
var require_factory_space = __commonJS({
  "node_modules/micromark/dist/tokenize/factory-space.js"(exports, module) {
    "use strict";
    var import_dist466 = __toESM(require_dist());
    var import_dist467 = __toESM(require_dist2());
    var import_dist468 = __toESM(require_dist3());
    var markdownSpace2 = require_markdown_space();
    function spaceFactory(effects, ok3, type, max) {
      var limit = max ? max - 1 : Infinity;
      var size = 0;
      return start;
      function start(code2) {
        if (markdownSpace2(code2)) {
          effects.enter(type);
          return prefix(code2);
        }
        return ok3(code2);
      }
      function prefix(code2) {
        if (markdownSpace2(code2) && size++ < limit) {
          effects.consume(code2);
          return prefix;
        }
        effects.exit(type);
        return ok3(code2);
      }
    }
    module.exports = spaceFactory;
  }
});

// node_modules/micromark-extension-gfm-table/syntax.js
var require_syntax2 = __commonJS({
  "node_modules/micromark-extension-gfm-table/syntax.js"(exports) {
    var import_dist466 = __toESM(require_dist());
    var import_dist467 = __toESM(require_dist2());
    var import_dist468 = __toESM(require_dist3());
    exports.flow = {
      null: { tokenize: tokenizeTable, resolve: resolveTable, interruptible: true }
    };
    var createSpace = require_factory_space();
    var setextUnderlineMini = { tokenize: tokenizeSetextUnderlineMini, partial: true };
    var nextPrefixedOrBlank = { tokenize: tokenizeNextPrefixedOrBlank, partial: true };
    function resolveTable(events, context) {
      var length = events.length;
      var index2 = -1;
      var token;
      var inHead;
      var inDelimiterRow;
      var inRow;
      var cell;
      var content3;
      var text4;
      var contentStart;
      var contentEnd;
      var cellStart;
      while (++index2 < length) {
        token = events[index2][1];
        if (inRow) {
          if (token.type === "temporaryTableCellContent") {
            contentStart = contentStart || index2;
            contentEnd = index2;
          }
          if (
            // Combine separate content parts into one.
            (token.type === "tableCellDivider" || token.type === "tableRow") && contentEnd
          ) {
            content3 = {
              type: "tableContent",
              start: events[contentStart][1].start,
              end: events[contentEnd][1].end
            };
            text4 = {
              type: "chunkText",
              start: content3.start,
              end: content3.end,
              contentType: "text"
            };
            events.splice(
              contentStart,
              contentEnd - contentStart + 1,
              ["enter", content3, context],
              ["enter", text4, context],
              ["exit", text4, context],
              ["exit", content3, context]
            );
            index2 -= contentEnd - contentStart - 3;
            length = events.length;
            contentStart = void 0;
            contentEnd = void 0;
          }
        }
        if (events[index2][0] === "exit" && cellStart && cellStart + 1 < index2 && (token.type === "tableCellDivider" || token.type === "tableRow" && (cellStart + 3 < index2 || events[cellStart][1].type !== "whitespace"))) {
          cell = {
            type: inDelimiterRow ? "tableDelimiter" : inHead ? "tableHeader" : "tableData",
            start: events[cellStart][1].start,
            end: events[index2][1].end
          };
          events.splice(index2 + (token.type === "tableCellDivider" ? 1 : 0), 0, [
            "exit",
            cell,
            context
          ]);
          events.splice(cellStart, 0, ["enter", cell, context]);
          index2 += 2;
          length = events.length;
          cellStart = index2 + 1;
        }
        if (token.type === "tableRow") {
          inRow = events[index2][0] === "enter";
          if (inRow) {
            cellStart = index2 + 1;
          }
        }
        if (token.type === "tableDelimiterRow") {
          inDelimiterRow = events[index2][0] === "enter";
          if (inDelimiterRow) {
            cellStart = index2 + 1;
          }
        }
        if (token.type === "tableHead") {
          inHead = events[index2][0] === "enter";
        }
      }
      return events;
    }
    function tokenizeTable(effects, ok3, nok) {
      var align = [];
      var tableHeaderCount = 0;
      var seenDelimiter;
      var hasDash;
      return start;
      function start(code2) {
        if (code2 === null || code2 === -5 || code2 === -4 || code2 === -3) {
          return nok(code2);
        }
        effects.enter("table")._align = align;
        effects.enter("tableHead");
        effects.enter("tableRow");
        if (code2 === 124) {
          return cellDividerHead(code2);
        }
        tableHeaderCount++;
        effects.enter("temporaryTableCellContent");
        return inCellContentHead(code2);
      }
      function cellDividerHead(code2) {
        effects.enter("tableCellDivider");
        effects.consume(code2);
        effects.exit("tableCellDivider");
        seenDelimiter = true;
        return cellBreakHead;
      }
      function cellBreakHead(code2) {
        if (code2 === null || code2 === -5 || code2 === -4 || code2 === -3) {
          return atRowEndHead(code2);
        }
        if (code2 === -2 || code2 === -1 || code2 === 32) {
          effects.enter("whitespace");
          effects.consume(code2);
          return inWhitespaceHead;
        }
        if (seenDelimiter) {
          seenDelimiter = void 0;
          tableHeaderCount++;
        }
        if (code2 === 124) {
          return cellDividerHead(code2);
        }
        effects.enter("temporaryTableCellContent");
        return inCellContentHead(code2);
      }
      function inWhitespaceHead(code2) {
        if (code2 === -2 || code2 === -1 || code2 === 32) {
          effects.consume(code2);
          return inWhitespaceHead;
        }
        effects.exit("whitespace");
        return cellBreakHead(code2);
      }
      function inCellContentHead(code2) {
        if (code2 === null || code2 < 0 || code2 === 32 || code2 === 124) {
          effects.exit("temporaryTableCellContent");
          return cellBreakHead(code2);
        }
        effects.consume(code2);
        return code2 === 92 ? inCellContentEscapeHead : inCellContentHead;
      }
      function inCellContentEscapeHead(code2) {
        if (code2 === 92 || code2 === 124) {
          effects.consume(code2);
          return inCellContentHead;
        }
        return inCellContentHead(code2);
      }
      function atRowEndHead(code2) {
        if (code2 === null) {
          return nok(code2);
        }
        effects.exit("tableRow");
        effects.exit("tableHead");
        effects.enter("lineEnding");
        effects.consume(code2);
        effects.exit("lineEnding");
        return effects.check(
          setextUnderlineMini,
          nok,
          // Support an indent before the delimiter row.
          createSpace(effects, rowStartDelimiter, "linePrefix", 4)
        );
      }
      function rowStartDelimiter(code2) {
        if (code2 === null || code2 < 0 || code2 === 32) {
          return nok(code2);
        }
        effects.enter("tableDelimiterRow");
        return atDelimiterRowBreak(code2);
      }
      function atDelimiterRowBreak(code2) {
        if (code2 === null || code2 === -5 || code2 === -4 || code2 === -3) {
          return rowEndDelimiter(code2);
        }
        if (code2 === -2 || code2 === -1 || code2 === 32) {
          effects.enter("whitespace");
          effects.consume(code2);
          return inWhitespaceDelimiter;
        }
        if (code2 === 45) {
          effects.enter("tableDelimiterFiller");
          effects.consume(code2);
          hasDash = true;
          align.push(null);
          return inFillerDelimiter;
        }
        if (code2 === 58) {
          effects.enter("tableDelimiterAlignment");
          effects.consume(code2);
          effects.exit("tableDelimiterAlignment");
          align.push("left");
          return afterLeftAlignment;
        }
        if (code2 === 124) {
          effects.enter("tableCellDivider");
          effects.consume(code2);
          effects.exit("tableCellDivider");
          return atDelimiterRowBreak;
        }
        return nok(code2);
      }
      function inWhitespaceDelimiter(code2) {
        if (code2 === -2 || code2 === -1 || code2 === 32) {
          effects.consume(code2);
          return inWhitespaceDelimiter;
        }
        effects.exit("whitespace");
        return atDelimiterRowBreak(code2);
      }
      function inFillerDelimiter(code2) {
        if (code2 === 45) {
          effects.consume(code2);
          return inFillerDelimiter;
        }
        effects.exit("tableDelimiterFiller");
        if (code2 === 58) {
          effects.enter("tableDelimiterAlignment");
          effects.consume(code2);
          effects.exit("tableDelimiterAlignment");
          align[align.length - 1] = align[align.length - 1] === "left" ? "center" : "right";
          return afterRightAlignment;
        }
        return atDelimiterRowBreak(code2);
      }
      function afterLeftAlignment(code2) {
        if (code2 === 45) {
          effects.enter("tableDelimiterFiller");
          effects.consume(code2);
          hasDash = true;
          return inFillerDelimiter;
        }
        return nok(code2);
      }
      function afterRightAlignment(code2) {
        if (code2 === null || code2 === -5 || code2 === -4 || code2 === -3) {
          return rowEndDelimiter(code2);
        }
        if (code2 === -2 || code2 === -1 || code2 === 32) {
          effects.enter("whitespace");
          effects.consume(code2);
          return inWhitespaceDelimiter;
        }
        if (code2 === 124) {
          effects.enter("tableCellDivider");
          effects.consume(code2);
          effects.exit("tableCellDivider");
          return atDelimiterRowBreak;
        }
        return nok(code2);
      }
      function rowEndDelimiter(code2) {
        effects.exit("tableDelimiterRow");
        if (!hasDash || tableHeaderCount !== align.length) {
          return nok(code2);
        }
        if (code2 === null) {
          return tableClose(code2);
        }
        return effects.check(nextPrefixedOrBlank, tableClose, tableContinue)(code2);
      }
      function tableClose(code2) {
        effects.exit("table");
        return ok3(code2);
      }
      function tableContinue(code2) {
        effects.enter("lineEnding");
        effects.consume(code2);
        effects.exit("lineEnding");
        return createSpace(effects, bodyStart, "linePrefix", 4);
      }
      function bodyStart(code2) {
        effects.enter("tableBody");
        return rowStartBody(code2);
      }
      function rowStartBody(code2) {
        effects.enter("tableRow");
        if (code2 === 124) {
          return cellDividerBody(code2);
        }
        effects.enter("temporaryTableCellContent");
        return inCellContentBody(code2);
      }
      function cellDividerBody(code2) {
        effects.enter("tableCellDivider");
        effects.consume(code2);
        effects.exit("tableCellDivider");
        return cellBreakBody;
      }
      function cellBreakBody(code2) {
        if (code2 === null || code2 === -5 || code2 === -4 || code2 === -3) {
          return atRowEndBody(code2);
        }
        if (code2 === -2 || code2 === -1 || code2 === 32) {
          effects.enter("whitespace");
          effects.consume(code2);
          return inWhitespaceBody;
        }
        if (code2 === 124) {
          return cellDividerBody(code2);
        }
        effects.enter("temporaryTableCellContent");
        return inCellContentBody(code2);
      }
      function inWhitespaceBody(code2) {
        if (code2 === -2 || code2 === -1 || code2 === 32) {
          effects.consume(code2);
          return inWhitespaceBody;
        }
        effects.exit("whitespace");
        return cellBreakBody(code2);
      }
      function inCellContentBody(code2) {
        if (code2 === null || code2 < 0 || code2 === 32 || code2 === 124) {
          effects.exit("temporaryTableCellContent");
          return cellBreakBody(code2);
        }
        effects.consume(code2);
        return code2 === 92 ? inCellContentEscapeBody : inCellContentBody;
      }
      function inCellContentEscapeBody(code2) {
        if (code2 === 92 || code2 === 124) {
          effects.consume(code2);
          return inCellContentBody;
        }
        return inCellContentBody(code2);
      }
      function atRowEndBody(code2) {
        effects.exit("tableRow");
        if (code2 === null) {
          return tableBodyClose(code2);
        }
        return effects.check(
          nextPrefixedOrBlank,
          tableBodyClose,
          tableBodyContinue
        )(code2);
      }
      function tableBodyClose(code2) {
        effects.exit("tableBody");
        return tableClose(code2);
      }
      function tableBodyContinue(code2) {
        effects.enter("lineEnding");
        effects.consume(code2);
        effects.exit("lineEnding");
        return createSpace(effects, rowStartBody, "linePrefix", 4);
      }
    }
    function tokenizeSetextUnderlineMini(effects, ok3, nok) {
      return start;
      function start(code2) {
        if (code2 !== 45) {
          return nok(code2);
        }
        effects.enter("setextUnderline");
        return sequence(code2);
      }
      function sequence(code2) {
        if (code2 === 45) {
          effects.consume(code2);
          return sequence;
        }
        return whitespace2(code2);
      }
      function whitespace2(code2) {
        if (code2 === -2 || code2 === -1 || code2 === 32) {
          effects.consume(code2);
          return whitespace2;
        }
        if (code2 === null || code2 === -5 || code2 === -4 || code2 === -3) {
          return ok3(code2);
        }
        return nok(code2);
      }
    }
    function tokenizeNextPrefixedOrBlank(effects, ok3, nok) {
      var size = 0;
      return start;
      function start(code2) {
        effects.enter("check");
        effects.consume(code2);
        return whitespace2;
      }
      function whitespace2(code2) {
        if (code2 === -1 || code2 === 32) {
          effects.consume(code2);
          size++;
          return size === 4 ? ok3 : whitespace2;
        }
        if (code2 === null || code2 < 0) {
          return ok3(code2);
        }
        return nok(code2);
      }
    }
  }
});

// node_modules/micromark-extension-gfm-table/index.js
var require_micromark_extension_gfm_table = __commonJS({
  "node_modules/micromark-extension-gfm-table/index.js"(exports, module) {
    var import_dist466 = __toESM(require_dist());
    var import_dist467 = __toESM(require_dist2());
    var import_dist468 = __toESM(require_dist3());
    module.exports = require_syntax2();
  }
});

// node_modules/micromark/dist/util/size-chunks.js
var require_size_chunks = __commonJS({
  "node_modules/micromark/dist/util/size-chunks.js"(exports, module) {
    "use strict";
    var import_dist466 = __toESM(require_dist());
    var import_dist467 = __toESM(require_dist2());
    var import_dist468 = __toESM(require_dist3());
    function sizeChunks(chunks) {
      var index2 = -1;
      var size = 0;
      while (++index2 < chunks.length) {
        size += typeof chunks[index2] === "string" ? chunks[index2].length : 1;
      }
      return size;
    }
    module.exports = sizeChunks;
  }
});

// node_modules/micromark/dist/util/prefix-size.js
var require_prefix_size = __commonJS({
  "node_modules/micromark/dist/util/prefix-size.js"(exports, module) {
    "use strict";
    var import_dist466 = __toESM(require_dist());
    var import_dist467 = __toESM(require_dist2());
    var import_dist468 = __toESM(require_dist3());
    var sizeChunks = require_size_chunks();
    function prefixSize(events, type) {
      var tail = events[events.length - 1];
      if (!tail || tail[1].type !== type) return 0;
      return sizeChunks(tail[2].sliceStream(tail[1]));
    }
    module.exports = prefixSize;
  }
});

// node_modules/micromark-extension-gfm-task-list-item/syntax.js
var require_syntax3 = __commonJS({
  "node_modules/micromark-extension-gfm-task-list-item/syntax.js"(exports) {
    var import_dist466 = __toESM(require_dist());
    var import_dist467 = __toESM(require_dist2());
    var import_dist468 = __toESM(require_dist3());
    var markdownLineEndingOrSpace2 = require_markdown_line_ending_or_space();
    var spaceFactory = require_factory_space();
    var prefixSize = require_prefix_size();
    var tasklistCheck = { tokenize: tokenizeTasklistCheck };
    exports.text = { 91: tasklistCheck };
    function tokenizeTasklistCheck(effects, ok3, nok) {
      var self2 = this;
      return open;
      function open(code2) {
        if (
          // Exit if not `[`.
          code2 !== 91 || // Exit if theres stuff before.
          self2.previous !== null || // Exit if not in the first content that is the first child of a list
          // item.
          !self2._gfmTasklistFirstContentOfListItem
        ) {
          return nok(code2);
        }
        effects.enter("taskListCheck");
        effects.enter("taskListCheckMarker");
        effects.consume(code2);
        effects.exit("taskListCheckMarker");
        return inside;
      }
      function inside(code2) {
        if (code2 === -2 || code2 === 32) {
          effects.enter("taskListCheckValueUnchecked");
          effects.consume(code2);
          effects.exit("taskListCheckValueUnchecked");
          return close;
        }
        if (code2 === 88 || code2 === 120) {
          effects.enter("taskListCheckValueChecked");
          effects.consume(code2);
          effects.exit("taskListCheckValueChecked");
          return close;
        }
        return nok(code2);
      }
      function close(code2) {
        if (code2 === 93) {
          effects.enter("taskListCheckMarker");
          effects.consume(code2);
          effects.exit("taskListCheckMarker");
          effects.exit("taskListCheck");
          return effects.check({ tokenize: spaceThenNonSpace }, ok3, nok);
        }
        return nok(code2);
      }
    }
    function spaceThenNonSpace(effects, ok3, nok) {
      var self2 = this;
      return spaceFactory(effects, after, "whitespace");
      function after(code2) {
        return prefixSize(self2.events, "whitespace") && code2 !== null && !markdownLineEndingOrSpace2(code2) ? ok3(code2) : nok(code2);
      }
    }
  }
});

// node_modules/micromark-extension-gfm-task-list-item/index.js
var require_micromark_extension_gfm_task_list_item = __commonJS({
  "node_modules/micromark-extension-gfm-task-list-item/index.js"(exports, module) {
    var import_dist466 = __toESM(require_dist());
    var import_dist467 = __toESM(require_dist2());
    var import_dist468 = __toESM(require_dist3());
    module.exports = require_syntax3();
  }
});

// node_modules/micromark-extension-gfm/syntax.js
var require_syntax4 = __commonJS({
  "node_modules/micromark-extension-gfm/syntax.js"(exports, module) {
    var import_dist466 = __toESM(require_dist());
    var import_dist467 = __toESM(require_dist2());
    var import_dist468 = __toESM(require_dist3());
    var combine = require_combine_extensions();
    var autolink2 = require_micromark_extension_gfm_autolink_literal();
    var strikethrough2 = require_micromark_extension_gfm_strikethrough();
    var table2 = require_micromark_extension_gfm_table();
    var tasklist = require_micromark_extension_gfm_task_list_item();
    module.exports = create2;
    function create2(options) {
      return combine([autolink2, strikethrough2(options), table2, tasklist]);
    }
  }
});

// node_modules/micromark-extension-gfm/index.js
var require_micromark_extension_gfm = __commonJS({
  "node_modules/micromark-extension-gfm/index.js"(exports, module) {
    var import_dist466 = __toESM(require_dist());
    var import_dist467 = __toESM(require_dist2());
    var import_dist468 = __toESM(require_dist3());
    module.exports = require_syntax4();
  }
});

// node_modules/ccount/index.js
var require_ccount = __commonJS({
  "node_modules/ccount/index.js"(exports, module) {
    "use strict";
    var import_dist466 = __toESM(require_dist());
    var import_dist467 = __toESM(require_dist2());
    var import_dist468 = __toESM(require_dist3());
    module.exports = ccount;
    function ccount(source, character) {
      var value = String(source);
      var count = 0;
      var index2;
      if (typeof character !== "string") {
        throw new Error("Expected character");
      }
      index2 = value.indexOf(character);
      while (index2 !== -1) {
        count++;
        index2 = value.indexOf(character, index2 + character.length);
      }
      return count;
    }
  }
});

// node_modules/unist-util-is/convert.js
var require_convert = __commonJS({
  "node_modules/unist-util-is/convert.js"(exports, module) {
    "use strict";
    var import_dist466 = __toESM(require_dist());
    var import_dist467 = __toESM(require_dist2());
    var import_dist468 = __toESM(require_dist3());
    module.exports = convert2;
    function convert2(test) {
      if (test == null) {
        return ok3;
      }
      if (typeof test === "string") {
        return typeFactory2(test);
      }
      if (typeof test === "object") {
        return "length" in test ? anyFactory2(test) : allFactory(test);
      }
      if (typeof test === "function") {
        return test;
      }
      throw new Error("Expected function, string, or object as test");
    }
    function allFactory(test) {
      return all3;
      function all3(node2) {
        var key;
        for (key in test) {
          if (node2[key] !== test[key]) return false;
        }
        return true;
      }
    }
    function anyFactory2(tests) {
      var checks2 = [];
      var index2 = -1;
      while (++index2 < tests.length) {
        checks2[index2] = convert2(tests[index2]);
      }
      return any;
      function any() {
        var index3 = -1;
        while (++index3 < checks2.length) {
          if (checks2[index3].apply(this, arguments)) {
            return true;
          }
        }
        return false;
      }
    }
    function typeFactory2(test) {
      return type;
      function type(node2) {
        return Boolean(node2 && node2.type === test);
      }
    }
    function ok3() {
      return true;
    }
  }
});

// node_modules/unist-util-visit-parents/color.browser.js
var require_color_browser = __commonJS({
  "node_modules/unist-util-visit-parents/color.browser.js"(exports, module) {
    var import_dist466 = __toESM(require_dist());
    var import_dist467 = __toESM(require_dist2());
    var import_dist468 = __toESM(require_dist3());
    module.exports = identity;
    function identity(d) {
      return d;
    }
  }
});

// node_modules/unist-util-visit-parents/index.js
var require_unist_util_visit_parents = __commonJS({
  "node_modules/unist-util-visit-parents/index.js"(exports, module) {
    "use strict";
    var import_dist466 = __toESM(require_dist());
    var import_dist467 = __toESM(require_dist2());
    var import_dist468 = __toESM(require_dist3());
    module.exports = visitParents2;
    var convert2 = require_convert();
    var color2 = require_color_browser();
    var CONTINUE2 = true;
    var SKIP2 = "skip";
    var EXIT2 = false;
    visitParents2.CONTINUE = CONTINUE2;
    visitParents2.SKIP = SKIP2;
    visitParents2.EXIT = EXIT2;
    function visitParents2(tree, test, visitor, reverse) {
      var step;
      var is3;
      if (typeof test === "function" && typeof visitor !== "function") {
        reverse = visitor;
        visitor = test;
        test = null;
      }
      is3 = convert2(test);
      step = reverse ? -1 : 1;
      factory(tree, null, [])();
      function factory(node2, index2, parents) {
        var value = typeof node2 === "object" && node2 !== null ? node2 : {};
        var name;
        if (typeof value.type === "string") {
          name = typeof value.tagName === "string" ? value.tagName : typeof value.name === "string" ? value.name : void 0;
          visit2.displayName = "node (" + color2(value.type + (name ? "<" + name + ">" : "")) + ")";
        }
        return visit2;
        function visit2() {
          var grandparents = parents.concat(node2);
          var result = [];
          var subresult;
          var offset;
          if (!test || is3(node2, index2, parents[parents.length - 1] || null)) {
            result = toResult2(visitor(node2, parents));
            if (result[0] === EXIT2) {
              return result;
            }
          }
          if (node2.children && result[0] !== SKIP2) {
            offset = (reverse ? node2.children.length : -1) + step;
            while (offset > -1 && offset < node2.children.length) {
              subresult = factory(node2.children[offset], offset, grandparents)();
              if (subresult[0] === EXIT2) {
                return subresult;
              }
              offset = typeof subresult[1] === "number" ? subresult[1] : offset + step;
            }
          }
          return result;
        }
      }
    }
    function toResult2(value) {
      if (value !== null && typeof value === "object" && "length" in value) {
        return value;
      }
      if (typeof value === "number") {
        return [CONTINUE2, value];
      }
      return [value];
    }
  }
});

// node_modules/escape-string-regexp/index.js
var require_escape_string_regexp = __commonJS({
  "node_modules/escape-string-regexp/index.js"(exports, module) {
    "use strict";
    var import_dist466 = __toESM(require_dist());
    var import_dist467 = __toESM(require_dist2());
    var import_dist468 = __toESM(require_dist3());
    module.exports = (string3) => {
      if (typeof string3 !== "string") {
        throw new TypeError("Expected a string");
      }
      return string3.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
    };
  }
});

// node_modules/mdast-util-find-and-replace/index.js
var require_mdast_util_find_and_replace = __commonJS({
  "node_modules/mdast-util-find-and-replace/index.js"(exports, module) {
    "use strict";
    var import_dist466 = __toESM(require_dist());
    var import_dist467 = __toESM(require_dist2());
    var import_dist468 = __toESM(require_dist3());
    module.exports = findAndReplace;
    var visit2 = require_unist_util_visit_parents();
    var convert2 = require_convert();
    var escape = require_escape_string_regexp();
    var splice2 = [].splice;
    function findAndReplace(tree, find2, replace, options) {
      var settings;
      var schema;
      if (typeof find2 === "string" || find2 && typeof find2.exec === "function") {
        schema = [[find2, replace]];
      } else {
        schema = find2;
        options = replace;
      }
      settings = options || {};
      search2(tree, settings, handlerFactory(toPairs(schema)));
      return tree;
      function handlerFactory(pairs) {
        var pair = pairs[0];
        return handler;
        function handler(node2, parent) {
          var find3 = pair[0];
          var replace2 = pair[1];
          var nodes = [];
          var start = 0;
          var index2 = parent.children.indexOf(node2);
          var position3;
          var match;
          var subhandler;
          var value;
          find3.lastIndex = 0;
          match = find3.exec(node2.value);
          while (match) {
            position3 = match.index;
            value = replace2.apply(
              null,
              [].concat(match, { index: match.index, input: match.input })
            );
            if (value !== false) {
              if (start !== position3) {
                nodes.push({ type: "text", value: node2.value.slice(start, position3) });
              }
              if (typeof value === "string" && value.length > 0) {
                value = { type: "text", value };
              }
              if (value) {
                nodes = [].concat(nodes, value);
              }
              start = position3 + match[0].length;
            }
            if (!find3.global) {
              break;
            }
            match = find3.exec(node2.value);
          }
          if (position3 === void 0) {
            nodes = [node2];
            index2--;
          } else {
            if (start < node2.value.length) {
              nodes.push({ type: "text", value: node2.value.slice(start) });
            }
            nodes.unshift(index2, 1);
            splice2.apply(parent.children, nodes);
          }
          if (pairs.length > 1) {
            subhandler = handlerFactory(pairs.slice(1));
            position3 = -1;
            while (++position3 < nodes.length) {
              node2 = nodes[position3];
              if (node2.type === "text") {
                subhandler(node2, parent);
              } else {
                search2(node2, settings, subhandler);
              }
            }
          }
          return index2 + nodes.length + 1;
        }
      }
    }
    function search2(tree, settings, handler) {
      var ignored = convert2(settings.ignore || []);
      var result = [];
      visit2(tree, "text", visitor);
      return result;
      function visitor(node2, parents) {
        var index2 = -1;
        var parent;
        var grandparent;
        while (++index2 < parents.length) {
          parent = parents[index2];
          if (ignored(
            parent,
            grandparent ? grandparent.children.indexOf(parent) : void 0,
            grandparent
          )) {
            return;
          }
          grandparent = parent;
        }
        return handler(node2, grandparent);
      }
    }
    function toPairs(schema) {
      var result = [];
      var key;
      var index2;
      if (typeof schema !== "object") {
        throw new Error("Expected array or object as schema");
      }
      if ("length" in schema) {
        index2 = -1;
        while (++index2 < schema.length) {
          result.push([
            toExpression(schema[index2][0]),
            toFunction(schema[index2][1])
          ]);
        }
      } else {
        for (key in schema) {
          result.push([toExpression(key), toFunction(schema[key])]);
        }
      }
      return result;
    }
    function toExpression(find2) {
      return typeof find2 === "string" ? new RegExp(escape(find2), "g") : find2;
    }
    function toFunction(replace) {
      return typeof replace === "function" ? replace : returner;
      function returner() {
        return replace;
      }
    }
  }
});

// node_modules/mdast-util-gfm-autolink-literal/from-markdown.js
var require_from_markdown = __commonJS({
  "node_modules/mdast-util-gfm-autolink-literal/from-markdown.js"(exports) {
    var import_dist466 = __toESM(require_dist());
    var import_dist467 = __toESM(require_dist2());
    var import_dist468 = __toESM(require_dist3());
    var ccount = require_ccount();
    var findAndReplace = require_mdast_util_find_and_replace();
    var unicodePunctuation2 = require_unicode_punctuation();
    var unicodeWhitespace2 = require_unicode_whitespace();
    exports.transforms = [transformGfmAutolinkLiterals];
    exports.enter = {
      literalAutolink: enterLiteralAutolink,
      literalAutolinkEmail: enterLiteralAutolinkValue,
      literalAutolinkHttp: enterLiteralAutolinkValue,
      literalAutolinkWww: enterLiteralAutolinkValue
    };
    exports.exit = {
      literalAutolink: exitLiteralAutolink,
      literalAutolinkEmail: exitLiteralAutolinkEmail,
      literalAutolinkHttp: exitLiteralAutolinkHttp,
      literalAutolinkWww: exitLiteralAutolinkWww
    };
    function enterLiteralAutolink(token) {
      this.enter({ type: "link", title: null, url: "", children: [] }, token);
    }
    function enterLiteralAutolinkValue(token) {
      this.config.enter.autolinkProtocol.call(this, token);
    }
    function exitLiteralAutolinkHttp(token) {
      this.config.exit.autolinkProtocol.call(this, token);
    }
    function exitLiteralAutolinkWww(token) {
      this.config.exit.data.call(this, token);
      this.stack[this.stack.length - 1].url = "http://" + this.sliceSerialize(token);
    }
    function exitLiteralAutolinkEmail(token) {
      this.config.exit.autolinkEmail.call(this, token);
    }
    function exitLiteralAutolink(token) {
      this.exit(token);
    }
    function transformGfmAutolinkLiterals(tree) {
      findAndReplace(
        tree,
        [
          [/(https?:\/\/|www(?=\.))([-.\w]+)([^ \t\r\n]*)/i, findUrl],
          [/([-.\w+]+)@([-\w]+(?:\.[-\w]+)+)/, findEmail]
        ],
        { ignore: ["link", "linkReference"] }
      );
    }
    function findUrl($0, protocol, domain, path2, match) {
      var prefix = "";
      var parts;
      var result;
      if (!previous2(match)) {
        return false;
      }
      if (/^w/i.test(protocol)) {
        domain = protocol + domain;
        protocol = "";
        prefix = "http://";
      }
      if (!isCorrectDomain(domain)) {
        return false;
      }
      parts = splitUrl(domain + path2);
      if (!parts[0]) return false;
      result = {
        type: "link",
        title: null,
        url: prefix + protocol + parts[0],
        children: [{ type: "text", value: protocol + parts[0] }]
      };
      if (parts[1]) {
        result = [result, { type: "text", value: parts[1] }];
      }
      return result;
    }
    function findEmail($0, atext, label, match) {
      if (!previous2(match, true) || /[_-]$/.test(label)) {
        return false;
      }
      return {
        type: "link",
        title: null,
        url: "mailto:" + atext + "@" + label,
        children: [{ type: "text", value: atext + "@" + label }]
      };
    }
    function isCorrectDomain(domain) {
      var parts = domain.split(".");
      if (parts.length < 2 || parts[parts.length - 1] && (/_/.test(parts[parts.length - 1]) || !/[a-zA-Z\d]/.test(parts[parts.length - 1])) || parts[parts.length - 2] && (/_/.test(parts[parts.length - 2]) || !/[a-zA-Z\d]/.test(parts[parts.length - 2]))) {
        return false;
      }
      return true;
    }
    function splitUrl(url) {
      var trail = /[!"&'),.:;<>?\]}]+$/.exec(url);
      var closingParenIndex;
      var openingParens;
      var closingParens;
      if (trail) {
        url = url.slice(0, trail.index);
        trail = trail[0];
        closingParenIndex = trail.indexOf(")");
        openingParens = ccount(url, "(");
        closingParens = ccount(url, ")");
        while (closingParenIndex !== -1 && openingParens > closingParens) {
          url += trail.slice(0, closingParenIndex + 1);
          trail = trail.slice(closingParenIndex + 1);
          closingParenIndex = trail.indexOf(")");
          closingParens++;
        }
      }
      return [url, trail];
    }
    function previous2(match, email) {
      var code2 = match.input.charCodeAt(match.index - 1);
      return (code2 !== code2 || unicodeWhitespace2(code2) || unicodePunctuation2(code2)) && (!email || code2 !== 47);
    }
  }
});

// node_modules/mdast-util-gfm-strikethrough/from-markdown.js
var require_from_markdown2 = __commonJS({
  "node_modules/mdast-util-gfm-strikethrough/from-markdown.js"(exports) {
    var import_dist466 = __toESM(require_dist());
    var import_dist467 = __toESM(require_dist2());
    var import_dist468 = __toESM(require_dist3());
    exports.canContainEols = ["delete"];
    exports.enter = { strikethrough: enterStrikethrough };
    exports.exit = { strikethrough: exitStrikethrough };
    function enterStrikethrough(token) {
      this.enter({ type: "delete", children: [] }, token);
    }
    function exitStrikethrough(token) {
      this.exit(token);
    }
  }
});

// node_modules/mdast-util-gfm-table/from-markdown.js
var require_from_markdown3 = __commonJS({
  "node_modules/mdast-util-gfm-table/from-markdown.js"(exports) {
    var import_dist466 = __toESM(require_dist());
    var import_dist467 = __toESM(require_dist2());
    var import_dist468 = __toESM(require_dist3());
    exports.enter = {
      table: enterTable,
      tableData: enterCell,
      tableHeader: enterCell,
      tableRow: enterRow
    };
    exports.exit = {
      codeText: exitCodeText,
      table: exitTable,
      tableData: exit2,
      tableHeader: exit2,
      tableRow: exit2
    };
    function enterTable(token) {
      this.enter({ type: "table", align: token._align, children: [] }, token);
      this.setData("inTable", true);
    }
    function exitTable(token) {
      this.exit(token);
      this.setData("inTable");
    }
    function enterRow(token) {
      this.enter({ type: "tableRow", children: [] }, token);
    }
    function exit2(token) {
      this.exit(token);
    }
    function enterCell(token) {
      this.enter({ type: "tableCell", children: [] }, token);
    }
    function exitCodeText(token) {
      var value = this.resume();
      if (this.getData("inTable")) {
        value = value.replace(/\\([\\|])/g, replace);
      }
      this.stack[this.stack.length - 1].value = value;
      this.exit(token);
    }
    function replace($0, $1) {
      return $1 === "|" ? $1 : $0;
    }
  }
});

// node_modules/mdast-util-gfm-task-list-item/from-markdown.js
var require_from_markdown4 = __commonJS({
  "node_modules/mdast-util-gfm-task-list-item/from-markdown.js"(exports) {
    var import_dist466 = __toESM(require_dist());
    var import_dist467 = __toESM(require_dist2());
    var import_dist468 = __toESM(require_dist3());
    exports.exit = {
      taskListCheckValueChecked: exitCheck,
      taskListCheckValueUnchecked: exitCheck,
      paragraph: exitParagraphWithTaskListItem
    };
    function exitCheck(token) {
      this.stack[this.stack.length - 2].checked = token.type === "taskListCheckValueChecked";
    }
    function exitParagraphWithTaskListItem(token) {
      var parent = this.stack[this.stack.length - 2];
      var node2 = this.stack[this.stack.length - 1];
      var siblings = parent.children;
      var head = node2.children[0];
      var index2 = -1;
      var firstParaghraph;
      if (parent && parent.type === "listItem" && typeof parent.checked === "boolean" && head && head.type === "text") {
        while (++index2 < siblings.length) {
          if (siblings[index2].type === "paragraph") {
            firstParaghraph = siblings[index2];
            break;
          }
        }
        if (firstParaghraph === node2) {
          head.value = head.value.slice(1);
          if (head.value.length === 0) {
            node2.children.shift();
          } else {
            head.position.start.column++;
            head.position.start.offset++;
            node2.position.start = Object.assign({}, head.position.start);
          }
        }
      }
      this.exit(token);
    }
  }
});

// node_modules/mdast-util-gfm/from-markdown.js
var require_from_markdown5 = __commonJS({
  "node_modules/mdast-util-gfm/from-markdown.js"(exports, module) {
    var import_dist466 = __toESM(require_dist());
    var import_dist467 = __toESM(require_dist2());
    var import_dist468 = __toESM(require_dist3());
    var autolinkLiteral = require_from_markdown();
    var strikethrough2 = require_from_markdown2();
    var table2 = require_from_markdown3();
    var taskListItem = require_from_markdown4();
    var own8 = {}.hasOwnProperty;
    module.exports = configure2([
      autolinkLiteral,
      strikethrough2,
      table2,
      taskListItem
    ]);
    function configure2(extensions) {
      var config = { transforms: [], canContainEols: [] };
      var length = extensions.length;
      var index2 = -1;
      while (++index2 < length) {
        extension2(config, extensions[index2]);
      }
      return config;
    }
    function extension2(config, extension3) {
      var key;
      var left;
      var right;
      for (key in extension3) {
        left = own8.call(config, key) ? config[key] : config[key] = {};
        right = extension3[key];
        if (key === "canContainEols" || key === "transforms") {
          config[key] = [].concat(left, right);
        } else {
          Object.assign(left, right);
        }
      }
    }
  }
});

// node_modules/mdast-util-gfm-autolink-literal/to-markdown.js
var require_to_markdown = __commonJS({
  "node_modules/mdast-util-gfm-autolink-literal/to-markdown.js"(exports) {
    var import_dist466 = __toESM(require_dist());
    var import_dist467 = __toESM(require_dist2());
    var import_dist468 = __toESM(require_dist3());
    var inConstruct = "phrasing";
    var notInConstruct = ["autolink", "link", "image", "label"];
    exports.unsafe = [
      {
        character: "@",
        before: "[+\\-.\\w]",
        after: "[\\-.\\w]",
        inConstruct,
        notInConstruct
      },
      {
        character: ".",
        before: "[Ww]",
        after: "[\\-.\\w]",
        inConstruct,
        notInConstruct
      },
      {
        character: ":",
        before: "[ps]",
        after: "\\/",
        inConstruct,
        notInConstruct
      }
    ];
  }
});

// node_modules/mdast-util-to-markdown/lib/util/container-phrasing.js
var require_container_phrasing = __commonJS({
  "node_modules/mdast-util-to-markdown/lib/util/container-phrasing.js"(exports, module) {
    var import_dist466 = __toESM(require_dist());
    var import_dist467 = __toESM(require_dist2());
    var import_dist468 = __toESM(require_dist3());
    module.exports = phrasing;
    function phrasing(parent, context, safeOptions) {
      var children = parent.children || [];
      var results = [];
      var index2 = -1;
      var before = safeOptions.before;
      var after;
      var handle;
      var child;
      while (++index2 < children.length) {
        child = children[index2];
        if (index2 + 1 < children.length) {
          handle = context.handle.handlers[children[index2 + 1].type];
          if (handle && handle.peek) handle = handle.peek;
          after = handle ? handle(children[index2 + 1], parent, context, {
            before: "",
            after: ""
          }).charAt(0) : "";
        } else {
          after = safeOptions.after;
        }
        if (results.length > 0 && (before === "\r" || before === "\n") && child.type === "html") {
          results[results.length - 1] = results[results.length - 1].replace(
            /(\r?\n|\r)$/,
            " "
          );
          before = " ";
        }
        results.push(
          context.handle(child, parent, context, {
            before,
            after
          })
        );
        before = results[results.length - 1].slice(-1);
      }
      return results.join("");
    }
  }
});

// node_modules/mdast-util-gfm-strikethrough/to-markdown.js
var require_to_markdown2 = __commonJS({
  "node_modules/mdast-util-gfm-strikethrough/to-markdown.js"(exports) {
    var import_dist466 = __toESM(require_dist());
    var import_dist467 = __toESM(require_dist2());
    var import_dist468 = __toESM(require_dist3());
    var phrasing = require_container_phrasing();
    exports.unsafe = [{ character: "~", inConstruct: "phrasing" }];
    exports.handlers = { delete: handleDelete };
    handleDelete.peek = peekDelete;
    function handleDelete(node2, _, context) {
      var exit2 = context.enter("emphasis");
      var value = phrasing(node2, context, { before: "~", after: "~" });
      exit2();
      return "~~" + value + "~~";
    }
    function peekDelete() {
      return "~";
    }
  }
});

// node_modules/mdast-util-to-markdown/lib/util/pattern-compile.js
var require_pattern_compile = __commonJS({
  "node_modules/mdast-util-to-markdown/lib/util/pattern-compile.js"(exports, module) {
    var import_dist466 = __toESM(require_dist());
    var import_dist467 = __toESM(require_dist2());
    var import_dist468 = __toESM(require_dist3());
    module.exports = patternCompile;
    function patternCompile(pattern) {
      var before;
      var after;
      if (!pattern._compiled) {
        before = pattern.before ? "(?:" + pattern.before + ")" : "";
        after = pattern.after ? "(?:" + pattern.after + ")" : "";
        if (pattern.atBreak) {
          before = "[\\r\\n][\\t ]*" + before;
        }
        pattern._compiled = new RegExp(
          (before ? "(" + before + ")" : "") + (/[|\\{}()[\]^$+*?.-]/.test(pattern.character) ? "\\" : "") + pattern.character + (after || ""),
          "g"
        );
      }
      return pattern._compiled;
    }
  }
});

// node_modules/mdast-util-to-markdown/lib/handle/inline-code.js
var require_inline_code = __commonJS({
  "node_modules/mdast-util-to-markdown/lib/handle/inline-code.js"(exports, module) {
    var import_dist466 = __toESM(require_dist());
    var import_dist467 = __toESM(require_dist2());
    var import_dist468 = __toESM(require_dist3());
    module.exports = inlineCode2;
    inlineCode2.peek = inlineCodePeek;
    var patternCompile = require_pattern_compile();
    function inlineCode2(node2, parent, context) {
      var value = node2.value || "";
      var sequence = "`";
      var index2 = -1;
      var pattern;
      var expression;
      var match;
      var position3;
      while (new RegExp("(^|[^`])" + sequence + "([^`]|$)").test(value)) {
        sequence += "`";
      }
      if (/[^ \r\n]/.test(value) && (/[ \r\n`]/.test(value.charAt(0)) || /[ \r\n`]/.test(value.charAt(value.length - 1)))) {
        value = " " + value + " ";
      }
      while (++index2 < context.unsafe.length) {
        pattern = context.unsafe[index2];
        if (!pattern.atBreak) continue;
        expression = patternCompile(pattern);
        while (match = expression.exec(value)) {
          position3 = match.index;
          if (value.charCodeAt(position3) === 10 && value.charCodeAt(position3 - 1) === 13) {
            position3--;
          }
          value = value.slice(0, position3) + " " + value.slice(match.index + 1);
        }
      }
      return sequence + value + sequence;
    }
    function inlineCodePeek() {
      return "`";
    }
  }
});

// node_modules/repeat-string/index.js
var require_repeat_string = __commonJS({
  "node_modules/repeat-string/index.js"(exports, module) {
    "use strict";
    var import_dist466 = __toESM(require_dist());
    var import_dist467 = __toESM(require_dist2());
    var import_dist468 = __toESM(require_dist3());
    var res = "";
    var cache;
    module.exports = repeat;
    function repeat(str, num) {
      if (typeof str !== "string") {
        throw new TypeError("expected a string");
      }
      if (num === 1) return str;
      if (num === 2) return str + str;
      var max = str.length * num;
      if (cache !== str || typeof cache === "undefined") {
        cache = str;
        res = "";
      } else if (res.length >= max) {
        return res.substr(0, max);
      }
      while (max > res.length && num > 1) {
        if (num & 1) {
          res += str;
        }
        num >>= 1;
        str += str;
      }
      res += str;
      res = res.substr(0, max);
      return res;
    }
  }
});

// node_modules/markdown-table/index.js
var require_markdown_table = __commonJS({
  "node_modules/markdown-table/index.js"(exports, module) {
    "use strict";
    var import_dist466 = __toESM(require_dist());
    var import_dist467 = __toESM(require_dist2());
    var import_dist468 = __toESM(require_dist3());
    var repeat = require_repeat_string();
    module.exports = markdownTable;
    var trailingWhitespace = / +$/;
    var space2 = " ";
    var lineFeed = "\n";
    var dash2 = "-";
    var colon = ":";
    var verticalBar = "|";
    var x = 0;
    var C = 67;
    var L = 76;
    var R = 82;
    var c = 99;
    var l = 108;
    var r = 114;
    function markdownTable(table2, options) {
      var settings = options || {};
      var padding = settings.padding !== false;
      var start = settings.delimiterStart !== false;
      var end = settings.delimiterEnd !== false;
      var align = (settings.align || []).concat();
      var alignDelimiters = settings.alignDelimiters !== false;
      var alignments = [];
      var stringLength = settings.stringLength || defaultStringLength;
      var rowIndex = -1;
      var rowLength = table2.length;
      var cellMatrix = [];
      var sizeMatrix = [];
      var row = [];
      var sizes = [];
      var longestCellByColumn = [];
      var mostCellsPerRow = 0;
      var cells;
      var columnIndex;
      var columnLength;
      var largest;
      var size;
      var cell;
      var lines2;
      var line2;
      var before;
      var after;
      var code2;
      while (++rowIndex < rowLength) {
        cells = table2[rowIndex];
        columnIndex = -1;
        columnLength = cells.length;
        row = [];
        sizes = [];
        if (columnLength > mostCellsPerRow) {
          mostCellsPerRow = columnLength;
        }
        while (++columnIndex < columnLength) {
          cell = serialize(cells[columnIndex]);
          if (alignDelimiters === true) {
            size = stringLength(cell);
            sizes[columnIndex] = size;
            largest = longestCellByColumn[columnIndex];
            if (largest === void 0 || size > largest) {
              longestCellByColumn[columnIndex] = size;
            }
          }
          row.push(cell);
        }
        cellMatrix[rowIndex] = row;
        sizeMatrix[rowIndex] = sizes;
      }
      columnIndex = -1;
      columnLength = mostCellsPerRow;
      if (typeof align === "object" && "length" in align) {
        while (++columnIndex < columnLength) {
          alignments[columnIndex] = toAlignment(align[columnIndex]);
        }
      } else {
        code2 = toAlignment(align);
        while (++columnIndex < columnLength) {
          alignments[columnIndex] = code2;
        }
      }
      columnIndex = -1;
      columnLength = mostCellsPerRow;
      row = [];
      sizes = [];
      while (++columnIndex < columnLength) {
        code2 = alignments[columnIndex];
        before = "";
        after = "";
        if (code2 === l) {
          before = colon;
        } else if (code2 === r) {
          after = colon;
        } else if (code2 === c) {
          before = colon;
          after = colon;
        }
        size = alignDelimiters ? Math.max(
          1,
          longestCellByColumn[columnIndex] - before.length - after.length
        ) : 1;
        cell = before + repeat(dash2, size) + after;
        if (alignDelimiters === true) {
          size = before.length + size + after.length;
          if (size > longestCellByColumn[columnIndex]) {
            longestCellByColumn[columnIndex] = size;
          }
          sizes[columnIndex] = size;
        }
        row[columnIndex] = cell;
      }
      cellMatrix.splice(1, 0, row);
      sizeMatrix.splice(1, 0, sizes);
      rowIndex = -1;
      rowLength = cellMatrix.length;
      lines2 = [];
      while (++rowIndex < rowLength) {
        row = cellMatrix[rowIndex];
        sizes = sizeMatrix[rowIndex];
        columnIndex = -1;
        columnLength = mostCellsPerRow;
        line2 = [];
        while (++columnIndex < columnLength) {
          cell = row[columnIndex] || "";
          before = "";
          after = "";
          if (alignDelimiters === true) {
            size = longestCellByColumn[columnIndex] - (sizes[columnIndex] || 0);
            code2 = alignments[columnIndex];
            if (code2 === r) {
              before = repeat(space2, size);
            } else if (code2 === c) {
              if (size % 2 === 0) {
                before = repeat(space2, size / 2);
                after = before;
              } else {
                before = repeat(space2, size / 2 + 0.5);
                after = repeat(space2, size / 2 - 0.5);
              }
            } else {
              after = repeat(space2, size);
            }
          }
          if (start === true && columnIndex === 0) {
            line2.push(verticalBar);
          }
          if (padding === true && // Dont add the opening space if were not aligning and the cell is
          // empty: there will be a closing space.
          !(alignDelimiters === false && cell === "") && (start === true || columnIndex !== 0)) {
            line2.push(space2);
          }
          if (alignDelimiters === true) {
            line2.push(before);
          }
          line2.push(cell);
          if (alignDelimiters === true) {
            line2.push(after);
          }
          if (padding === true) {
            line2.push(space2);
          }
          if (end === true || columnIndex !== columnLength - 1) {
            line2.push(verticalBar);
          }
        }
        line2 = line2.join("");
        if (end === false) {
          line2 = line2.replace(trailingWhitespace, "");
        }
        lines2.push(line2);
      }
      return lines2.join(lineFeed);
    }
    function serialize(value) {
      return value === null || value === void 0 ? "" : String(value);
    }
    function defaultStringLength(value) {
      return value.length;
    }
    function toAlignment(value) {
      var code2 = typeof value === "string" ? value.charCodeAt(0) : x;
      return code2 === L || code2 === l ? l : code2 === R || code2 === r ? r : code2 === C || code2 === c ? c : x;
    }
  }
});

// node_modules/mdast-util-gfm-table/to-markdown.js
var require_to_markdown3 = __commonJS({
  "node_modules/mdast-util-gfm-table/to-markdown.js"(exports, module) {
    var import_dist466 = __toESM(require_dist());
    var import_dist467 = __toESM(require_dist2());
    var import_dist468 = __toESM(require_dist3());
    var phrasing = require_container_phrasing();
    var defaultInlineCode = require_inline_code();
    var markdownTable = require_markdown_table();
    module.exports = toMarkdown;
    function toMarkdown(options) {
      var settings = options || {};
      var padding = settings.tableCellPadding;
      var alignDelimiters = settings.tablePipeAlign;
      var stringLength = settings.stringLength;
      var around = padding ? " " : "|";
      return {
        unsafe: [
          { character: "\r", inConstruct: "tableCell" },
          { character: "\n", inConstruct: "tableCell" },
          // A pipe, when followed by a tab or space (padding), or a dash or colon
          // (unpadded delimiter row), could result in a table.
          { atBreak: true, character: "|", after: "[	 :-]" },
          // A pipe in a cell must be encoded.
          { character: "|", inConstruct: "tableCell" },
          // A colon must be followed by a dash, in which case it could start a
          // delimiter row.
          { atBreak: true, character: ":", after: "-" },
          // A delimiter row can also start with a dash, when followed by more
          // dashes, a colon, or a pipe.
          // This is a stricter version than the built in check for lists, thematic
          // breaks, and setex heading underlines though:
          // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/51a2038/lib/unsafe.js#L57>
          { atBreak: true, character: "-", after: "[:|-]" }
        ],
        handlers: {
          table: handleTable,
          tableRow: handleTableRow,
          tableCell: handleTableCell,
          inlineCode: inlineCodeWithTable
        }
      };
      function handleTable(node2, _, context) {
        return serializeData(handleTableAsData(node2, context), node2.align);
      }
      function handleTableRow(node2, _, context) {
        var row = handleTableRowAsData(node2, context);
        var value = serializeData([row]);
        return value.slice(0, value.indexOf("\n"));
      }
      function handleTableCell(node2, _, context) {
        var exit2 = context.enter("tableCell");
        var value = phrasing(node2, context, { before: around, after: around });
        exit2();
        return value;
      }
      function serializeData(matrix, align) {
        return markdownTable(matrix, {
          align,
          alignDelimiters,
          padding,
          stringLength
        });
      }
      function handleTableAsData(node2, context) {
        var children = node2.children;
        var index2 = -1;
        var length = children.length;
        var result = [];
        var subexit = context.enter("table");
        while (++index2 < length) {
          result[index2] = handleTableRowAsData(children[index2], context);
        }
        subexit();
        return result;
      }
      function handleTableRowAsData(node2, context) {
        var children = node2.children;
        var index2 = -1;
        var length = children.length;
        var result = [];
        var subexit = context.enter("tableRow");
        while (++index2 < length) {
          result[index2] = handleTableCell(children[index2], node2, context);
        }
        subexit();
        return result;
      }
      function inlineCodeWithTable(node2, parent, context) {
        var value = defaultInlineCode(node2, parent, context);
        if (context.stack.indexOf("tableCell") !== -1) {
          value = value.replace(/\|/g, "\\$&");
        }
        return value;
      }
    }
  }
});

// node_modules/mdast-util-to-markdown/lib/util/check-bullet.js
var require_check_bullet = __commonJS({
  "node_modules/mdast-util-to-markdown/lib/util/check-bullet.js"(exports, module) {
    var import_dist466 = __toESM(require_dist());
    var import_dist467 = __toESM(require_dist2());
    var import_dist468 = __toESM(require_dist3());
    module.exports = checkBullet;
    function checkBullet(context) {
      var marker = context.options.bullet || "*";
      if (marker !== "*" && marker !== "+" && marker !== "-") {
        throw new Error(
          "Cannot serialize items with `" + marker + "` for `options.bullet`, expected `*`, `+`, or `-`"
        );
      }
      return marker;
    }
  }
});

// node_modules/mdast-util-to-markdown/lib/util/check-list-item-indent.js
var require_check_list_item_indent = __commonJS({
  "node_modules/mdast-util-to-markdown/lib/util/check-list-item-indent.js"(exports, module) {
    var import_dist466 = __toESM(require_dist());
    var import_dist467 = __toESM(require_dist2());
    var import_dist468 = __toESM(require_dist3());
    module.exports = checkListItemIndent;
    function checkListItemIndent(context) {
      var style = context.options.listItemIndent || "tab";
      if (style === 1 || style === "1") {
        return "one";
      }
      if (style !== "tab" && style !== "one" && style !== "mixed") {
        throw new Error(
          "Cannot serialize items with `" + style + "` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`"
        );
      }
      return style;
    }
  }
});

// node_modules/mdast-util-to-markdown/lib/util/container-flow.js
var require_container_flow = __commonJS({
  "node_modules/mdast-util-to-markdown/lib/util/container-flow.js"(exports, module) {
    var import_dist466 = __toESM(require_dist());
    var import_dist467 = __toESM(require_dist2());
    var import_dist468 = __toESM(require_dist3());
    module.exports = flow3;
    var repeat = require_repeat_string();
    function flow3(parent, context) {
      var children = parent.children || [];
      var results = [];
      var index2 = -1;
      var child;
      while (++index2 < children.length) {
        child = children[index2];
        results.push(
          context.handle(child, parent, context, { before: "\n", after: "\n" })
        );
        if (index2 + 1 < children.length) {
          results.push(between(child, children[index2 + 1]));
        }
      }
      return results.join("");
      function between(left, right) {
        var index3 = -1;
        var result;
        while (++index3 < context.join.length) {
          result = context.join[index3](left, right, parent, context);
          if (result === true || result === 1) {
            break;
          }
          if (typeof result === "number") {
            return repeat("\n", 1 + Number(result));
          }
          if (result === false) {
            return "\n\n<!---->\n\n";
          }
        }
        return "\n\n";
      }
    }
  }
});

// node_modules/mdast-util-to-markdown/lib/util/indent-lines.js
var require_indent_lines = __commonJS({
  "node_modules/mdast-util-to-markdown/lib/util/indent-lines.js"(exports, module) {
    var import_dist466 = __toESM(require_dist());
    var import_dist467 = __toESM(require_dist2());
    var import_dist468 = __toESM(require_dist3());
    module.exports = indentLines;
    var eol = /\r?\n|\r/g;
    function indentLines(value, map) {
      var result = [];
      var start = 0;
      var line2 = 0;
      var match;
      while (match = eol.exec(value)) {
        one3(value.slice(start, match.index));
        result.push(match[0]);
        start = match.index + match[0].length;
        line2++;
      }
      one3(value.slice(start));
      return result.join("");
      function one3(value2) {
        result.push(map(value2, line2, !value2));
      }
    }
  }
});

// node_modules/mdast-util-to-markdown/lib/handle/list-item.js
var require_list_item = __commonJS({
  "node_modules/mdast-util-to-markdown/lib/handle/list-item.js"(exports, module) {
    var import_dist466 = __toESM(require_dist());
    var import_dist467 = __toESM(require_dist2());
    var import_dist468 = __toESM(require_dist3());
    module.exports = listItem2;
    var repeat = require_repeat_string();
    var checkBullet = require_check_bullet();
    var checkListItemIndent = require_check_list_item_indent();
    var flow3 = require_container_flow();
    var indentLines = require_indent_lines();
    function listItem2(node2, parent, context) {
      var bullet = checkBullet(context);
      var listItemIndent = checkListItemIndent(context);
      var size;
      var value;
      var exit2;
      if (parent && parent.ordered) {
        bullet = (parent.start > -1 ? parent.start : 1) + (context.options.incrementListMarker === false ? 0 : parent.children.indexOf(node2)) + ".";
      }
      size = bullet.length + 1;
      if (listItemIndent === "tab" || listItemIndent === "mixed" && (parent && parent.spread || node2.spread)) {
        size = Math.ceil(size / 4) * 4;
      }
      exit2 = context.enter("listItem");
      value = indentLines(flow3(node2, context), map);
      exit2();
      return value;
      function map(line2, index2, blank) {
        if (index2) {
          return (blank ? "" : repeat(" ", size)) + line2;
        }
        return (blank ? bullet : bullet + repeat(" ", size - bullet.length)) + line2;
      }
    }
  }
});

// node_modules/mdast-util-gfm-task-list-item/to-markdown.js
var require_to_markdown4 = __commonJS({
  "node_modules/mdast-util-gfm-task-list-item/to-markdown.js"(exports) {
    var import_dist466 = __toESM(require_dist());
    var import_dist467 = __toESM(require_dist2());
    var import_dist468 = __toESM(require_dist3());
    var defaultListItem = require_list_item();
    exports.unsafe = [{ atBreak: true, character: "-", after: "[:|-]" }];
    exports.handlers = {
      listItem: listItemWithTaskListItem
    };
    function listItemWithTaskListItem(node2, parent, context) {
      var value = defaultListItem(node2, parent, context);
      var head = node2.children[0];
      if (typeof node2.checked === "boolean" && head && head.type === "paragraph") {
        value = value.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, check);
      }
      return value;
      function check($0) {
        return $0 + "[" + (node2.checked ? "x" : " ") + "] ";
      }
    }
  }
});

// node_modules/mdast-util-to-markdown/lib/configure.js
var require_configure = __commonJS({
  "node_modules/mdast-util-to-markdown/lib/configure.js"(exports, module) {
    var import_dist466 = __toESM(require_dist());
    var import_dist467 = __toESM(require_dist2());
    var import_dist468 = __toESM(require_dist3());
    module.exports = configure2;
    function configure2(base2, extension2) {
      var index2 = -1;
      var key;
      if (extension2.extensions) {
        while (++index2 < extension2.extensions.length) {
          configure2(base2, extension2.extensions[index2]);
        }
      }
      for (key in extension2) {
        if (key === "extensions") {
        } else if (key === "unsafe" || key === "join") {
          base2[key] = base2[key].concat(extension2[key] || []);
        } else if (key === "handlers") {
          base2[key] = Object.assign(base2[key], extension2[key] || {});
        } else {
          base2.options[key] = extension2[key];
        }
      }
      return base2;
    }
  }
});

// node_modules/mdast-util-gfm/to-markdown.js
var require_to_markdown5 = __commonJS({
  "node_modules/mdast-util-gfm/to-markdown.js"(exports, module) {
    var import_dist466 = __toESM(require_dist());
    var import_dist467 = __toESM(require_dist2());
    var import_dist468 = __toESM(require_dist3());
    var autolinkLiteral = require_to_markdown();
    var strikethrough2 = require_to_markdown2();
    var table2 = require_to_markdown3();
    var taskListItem = require_to_markdown4();
    var configure2 = require_configure();
    module.exports = toMarkdown;
    function toMarkdown(options) {
      var config = configure2(
        { handlers: {}, join: [], unsafe: [], options: {} },
        {
          extensions: [autolinkLiteral, strikethrough2, table2(options), taskListItem]
        }
      );
      return Object.assign(config.options, {
        handlers: config.handlers,
        join: config.join,
        unsafe: config.unsafe
      });
    }
  }
});

// node_modules/remark-gfm/index.js
var require_remark_gfm = __commonJS({
  "node_modules/remark-gfm/index.js"(exports, module) {
    "use strict";
    var import_dist466 = __toESM(require_dist());
    var import_dist467 = __toESM(require_dist2());
    var import_dist468 = __toESM(require_dist3());
    var syntax = require_micromark_extension_gfm();
    var fromMarkdown2 = require_from_markdown5();
    var toMarkdown = require_to_markdown5();
    var warningIssued;
    module.exports = gfm;
    function gfm(options) {
      var data = this.data();
      if (!warningIssued && (this.Parser && this.Parser.prototype && this.Parser.prototype.blockTokenizers || this.Compiler && this.Compiler.prototype && this.Compiler.prototype.visitors)) {
        warningIssued = true;
        console.warn(
          "[remark-gfm] Warning: please upgrade to remark 13 to use this plugin"
        );
      }
      add("micromarkExtensions", syntax(options));
      add("fromMarkdownExtensions", fromMarkdown2);
      add("toMarkdownExtensions", toMarkdown(options));
      function add(field, value) {
        if (data[field]) data[field].push(value);
        else data[field] = [value];
      }
    }
  }
});

// node_modules/@splunk/react-ui/Markdown.js
var require_Markdown = __commonJS({
  "node_modules/@splunk/react-ui/Markdown.js"(exports, module) {
    var import_dist466 = __toESM(require_dist());
    var import_dist467 = __toESM(require_dist2());
    var import_dist468 = __toESM(require_dist3());
    (() => {
      "use strict";
      var e = {};
      (() => {
        e.n = (r2) => {
          var n2 = r2 && r2.__esModule ? (
            /******/
            () => r2["default"]
          ) : () => r2;
          e.d(n2, {
            a: n2
          });
          return n2;
        };
      })();
      (() => {
        e.d = (r2, n2) => {
          for (var t2 in n2) {
            if (e.o(n2, t2) && !e.o(r2, t2)) {
              Object.defineProperty(r2, t2, {
                enumerable: true,
                get: n2[t2]
              });
            }
          }
        };
      })();
      (() => {
        e.o = (e2, r2) => Object.prototype.hasOwnProperty.call(e2, r2);
      })();
      (() => {
        e.r = (e2) => {
          if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
            Object.defineProperty(e2, Symbol.toStringTag, {
              value: "Module"
            });
          }
          Object.defineProperty(e2, "__esModule", {
            value: true
          });
        };
      })();
      var r = {};
      e.r(r);
      e.d(r, {
        MarkdownAnchorHeading: () => (
          /* reexport */
          j
        ),
        MarkdownBlockquote: () => (
          /* reexport */
          M
        ),
        MarkdownCode: () => (
          /* reexport */
          B
        ),
        MarkdownCodeBlock: () => (
          /* reexport */
          F
        ),
        MarkdownHeading: () => (
          /* reexport */
          V
        ),
        MarkdownImage: () => (
          /* reexport */
          ee
        ),
        MarkdownItem: () => (
          /* reexport */
          ie
        ),
        MarkdownLink: () => (
          /* reexport */
          pe
        ),
        MarkdownList: () => (
          /* reexport */
          Oe
        ),
        MarkdownParagraph: () => (
          /* reexport */
          ke
        ),
        default: () => (
          /* reexport */
          We
        )
      });
      const n = require_react();
      var t = e.n(n);
      const l = require_prop_types();
      var o = e.n(l);
      const i = (init_react_markdown2(), __toCommonJS(react_markdown_exports));
      var a = e.n(i);
      const u = require_remark_gfm();
      var c = e.n(u);
      const f = (init_styled_components_esm(), __toCommonJS(styled_components_esm_exports));
      var s = e.n(f);
      const d = require_Prose();
      var p = e.n(d);
      const v = require_Anchor();
      var y = e.n(v);
      function b() {
        return b = Object.assign ? Object.assign.bind() : function(e2) {
          for (var r2 = 1; r2 < arguments.length; r2++) {
            var n2 = arguments[r2];
            for (var t2 in n2) {
              ({}).hasOwnProperty.call(n2, t2) && (e2[t2] = n2[t2]);
            }
          }
          return e2;
        }, b.apply(null, arguments);
      }
      function m(e2, r2) {
        if (null == e2) return {};
        var n2, t2, l2 = O(e2, r2);
        if (Object.getOwnPropertySymbols) {
          var o2 = Object.getOwnPropertySymbols(e2);
          for (t2 = 0; t2 < o2.length; t2++) {
            n2 = o2[t2], -1 === r2.indexOf(n2) && {}.propertyIsEnumerable.call(e2, n2) && (l2[n2] = e2[n2]);
          }
        }
        return l2;
      }
      function O(e2, r2) {
        if (null == e2) return {};
        var n2 = {};
        for (var t2 in e2) {
          if ({}.hasOwnProperty.call(e2, t2)) {
            if (-1 !== r2.indexOf(t2)) continue;
            n2[t2] = e2[t2];
          }
        }
        return n2;
      }
      function g(e2) {
        "@babel/helpers - typeof";
        return g = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e3) {
          return typeof e3;
        } : function(e3) {
          return e3 && "function" == typeof Symbol && e3.constructor === Symbol && e3 !== Symbol.prototype ? "symbol" : typeof e3;
        }, g(e2);
      }
      function h(e2) {
        var r2 = g(e2);
        var n2 = "";
        if (e2 != null) {
          if (r2 === "string" || r2 === "number") {
            n2 = e2.toString();
          } else if (r2 === "boolean") {
            n2 = e2 ? "true" : "false";
          } else if (g(e2) === "object") {
            if (e2 instanceof Array) {
              n2 = e2.map(h).join(" ");
            } else if ("props" in e2) {
              n2 = h(e2.props.children);
            }
          }
        }
        return n2;
      }
      function w(e2) {
        return n.Children.toArray(e2).map(h).join(" ").toLowerCase().replace(/[^a-z0-9-. ]/g, "").replace(/[-. ]+/g, "-");
      }
      function P(e2) {
        var r2 = e2.level, n2 = e2.children, l2 = m(e2, ["level", "children"]);
        return t().createElement(V, b({
          level: r2
        }, l2), t().createElement(y(), {
          name: w(n2)
        }, n2));
      }
      const j = P;
      const k = require_themes();
      var S = s().div.withConfig({
        displayName: "MarkdownStyles__StyledCodeBlock",
        componentId: "sc-1xadih-0"
      })(["", ""], k.mixins.reset("block"));
      var E = s().code.withConfig({
        displayName: "MarkdownStyles__StyledCodeInline",
        componentId: "sc-1xadih-1"
      })(["", ";font-size:inherit;font-family:", ";background-color:", ";"], k.mixins.reset("inline"), k.variables.monoFontFamily, k.variables.neutral100);
      var x = s().blockquote.withConfig({
        displayName: "MarkdownStyles__StyledHint",
        componentId: "sc-1xadih-2"
      })(["", " padding:", ";border-left:10px solid ", ";>:last-child{margin-bottom:0;}"], k.mixins.reset("block"), k.variables.spacingSmall, (0, k.pick)({
        dark: k.variables.white,
        light: k.variables.neutral500
      }));
      function R(e2, r2) {
        if (null == e2) return {};
        var n2, t2, l2 = q(e2, r2);
        if (Object.getOwnPropertySymbols) {
          var o2 = Object.getOwnPropertySymbols(e2);
          for (t2 = 0; t2 < o2.length; t2++) {
            n2 = o2[t2], -1 === r2.indexOf(n2) && {}.propertyIsEnumerable.call(e2, n2) && (l2[n2] = e2[n2]);
          }
        }
        return l2;
      }
      function q(e2, r2) {
        if (null == e2) return {};
        var n2 = {};
        for (var t2 in e2) {
          if ({}.hasOwnProperty.call(e2, t2)) {
            if (-1 !== r2.indexOf(t2)) continue;
            n2[t2] = e2[t2];
          }
        }
        return n2;
      }
      function I(e2) {
        var r2 = e2.children, n2 = R(e2, ["children"]);
        return t().createElement(x, n2, r2);
      }
      const M = I;
      function T(e2, r2) {
        if (null == e2) return {};
        var n2, t2, l2 = C(e2, r2);
        if (Object.getOwnPropertySymbols) {
          var o2 = Object.getOwnPropertySymbols(e2);
          for (t2 = 0; t2 < o2.length; t2++) {
            n2 = o2[t2], -1 === r2.indexOf(n2) && {}.propertyIsEnumerable.call(e2, n2) && (l2[n2] = e2[n2]);
          }
        }
        return l2;
      }
      function C(e2, r2) {
        if (null == e2) return {};
        var n2 = {};
        for (var t2 in e2) {
          if ({}.hasOwnProperty.call(e2, t2)) {
            if (-1 !== r2.indexOf(t2)) continue;
            n2[t2] = e2[t2];
          }
        }
        return n2;
      }
      function _(e2) {
        var r2 = e2.children, n2 = T(e2, ["children"]);
        return t().createElement(E, n2, r2);
      }
      const B = _;
      const H = require_Code();
      var A = e.n(H);
      const U = require_i18n();
      function L(e2, r2) {
        if (null == e2) return {};
        var n2, t2, l2 = N(e2, r2);
        if (Object.getOwnPropertySymbols) {
          var o2 = Object.getOwnPropertySymbols(e2);
          for (t2 = 0; t2 < o2.length; t2++) {
            n2 = o2[t2], -1 === r2.indexOf(n2) && {}.propertyIsEnumerable.call(e2, n2) && (l2[n2] = e2[n2]);
          }
        }
        return l2;
      }
      function N(e2, r2) {
        if (null == e2) return {};
        var n2 = {};
        for (var t2 in e2) {
          if ({}.hasOwnProperty.call(e2, t2)) {
            if (-1 !== r2.indexOf(t2)) continue;
            n2[t2] = e2[t2];
          }
        }
        return n2;
      }
      function D(e2) {
        var r2 = e2.children, n2 = e2.language, l2 = L(e2, ["children", "language"]);
        return t().createElement(S, l2, t().createElement(A(), {
          "aria-label": (0, U._)("Code Block"),
          language: n2,
          value: String(r2).replace(/\n$/, "")
        }));
      }
      const F = D;
      const z = require_Heading();
      var $2 = e.n(z);
      function G() {
        return G = Object.assign ? Object.assign.bind() : function(e2) {
          for (var r2 = 1; r2 < arguments.length; r2++) {
            var n2 = arguments[r2];
            for (var t2 in n2) {
              ({}).hasOwnProperty.call(n2, t2) && (e2[t2] = n2[t2]);
            }
          }
          return e2;
        }, G.apply(null, arguments);
      }
      function J(e2, r2) {
        if (null == e2) return {};
        var n2, t2, l2 = K(e2, r2);
        if (Object.getOwnPropertySymbols) {
          var o2 = Object.getOwnPropertySymbols(e2);
          for (t2 = 0; t2 < o2.length; t2++) {
            n2 = o2[t2], -1 === r2.indexOf(n2) && {}.propertyIsEnumerable.call(e2, n2) && (l2[n2] = e2[n2]);
          }
        }
        return l2;
      }
      function K(e2, r2) {
        if (null == e2) return {};
        var n2 = {};
        for (var t2 in e2) {
          if ({}.hasOwnProperty.call(e2, t2)) {
            if (-1 !== r2.indexOf(t2)) continue;
            n2[t2] = e2[t2];
          }
        }
        return n2;
      }
      function Q(e2) {
        var r2 = e2.level, n2 = e2.children, l2 = J(e2, ["level", "children"]);
        var o2 = Math.min(r2, 6);
        return t().createElement($2(), G({
          level: o2
        }, l2), n2);
      }
      const V = Q;
      function W() {
        return W = Object.assign ? Object.assign.bind() : function(e2) {
          for (var r2 = 1; r2 < arguments.length; r2++) {
            var n2 = arguments[r2];
            for (var t2 in n2) {
              ({}).hasOwnProperty.call(n2, t2) && (e2[t2] = n2[t2]);
            }
          }
          return e2;
        }, W.apply(null, arguments);
      }
      function X(e2, r2) {
        if (null == e2) return {};
        var n2, t2, l2 = Y(e2, r2);
        if (Object.getOwnPropertySymbols) {
          var o2 = Object.getOwnPropertySymbols(e2);
          for (t2 = 0; t2 < o2.length; t2++) {
            n2 = o2[t2], -1 === r2.indexOf(n2) && {}.propertyIsEnumerable.call(e2, n2) && (l2[n2] = e2[n2]);
          }
        }
        return l2;
      }
      function Y(e2, r2) {
        if (null == e2) return {};
        var n2 = {};
        for (var t2 in e2) {
          if ({}.hasOwnProperty.call(e2, t2)) {
            if (-1 !== r2.indexOf(t2)) continue;
            n2[t2] = e2[t2];
          }
        }
        return n2;
      }
      function Z(e2) {
        var r2 = e2.src, n2 = e2.title, l2 = e2.alt, o2 = X(e2, ["src", "title", "alt"]);
        return t().createElement("img", W({
          src: r2,
          title: n2,
          alt: l2
        }, o2));
      }
      const ee = Z;
      const re = require_List();
      var ne = e.n(re);
      function te(e2, r2) {
        if (null == e2) return {};
        var n2, t2, l2 = le(e2, r2);
        if (Object.getOwnPropertySymbols) {
          var o2 = Object.getOwnPropertySymbols(e2);
          for (t2 = 0; t2 < o2.length; t2++) {
            n2 = o2[t2], -1 === r2.indexOf(n2) && {}.propertyIsEnumerable.call(e2, n2) && (l2[n2] = e2[n2]);
          }
        }
        return l2;
      }
      function le(e2, r2) {
        if (null == e2) return {};
        var n2 = {};
        for (var t2 in e2) {
          if ({}.hasOwnProperty.call(e2, t2)) {
            if (-1 !== r2.indexOf(t2)) continue;
            n2[t2] = e2[t2];
          }
        }
        return n2;
      }
      function oe(e2) {
        var r2 = e2.children, n2 = te(e2, ["children"]);
        return t().createElement(re.Item, n2, r2);
      }
      const ie = oe;
      const ae = require_Link();
      var ue = e.n(ae);
      function ce() {
        return ce = Object.assign ? Object.assign.bind() : function(e2) {
          for (var r2 = 1; r2 < arguments.length; r2++) {
            var n2 = arguments[r2];
            for (var t2 in n2) {
              ({}).hasOwnProperty.call(n2, t2) && (e2[t2] = n2[t2]);
            }
          }
          return e2;
        }, ce.apply(null, arguments);
      }
      function fe(e2, r2) {
        if (null == e2) return {};
        var n2, t2, l2 = se(e2, r2);
        if (Object.getOwnPropertySymbols) {
          var o2 = Object.getOwnPropertySymbols(e2);
          for (t2 = 0; t2 < o2.length; t2++) {
            n2 = o2[t2], -1 === r2.indexOf(n2) && {}.propertyIsEnumerable.call(e2, n2) && (l2[n2] = e2[n2]);
          }
        }
        return l2;
      }
      function se(e2, r2) {
        if (null == e2) return {};
        var n2 = {};
        for (var t2 in e2) {
          if ({}.hasOwnProperty.call(e2, t2)) {
            if (-1 !== r2.indexOf(t2)) continue;
            n2[t2] = e2[t2];
          }
        }
        return n2;
      }
      function de(e2) {
        var r2 = e2.children, n2 = e2.href, l2 = fe(e2, ["children", "href"]);
        return t().createElement(ue(), ce({
          to: n2
        }, l2), r2);
      }
      const pe = de;
      function ve() {
        return ve = Object.assign ? Object.assign.bind() : function(e2) {
          for (var r2 = 1; r2 < arguments.length; r2++) {
            var n2 = arguments[r2];
            for (var t2 in n2) {
              ({}).hasOwnProperty.call(n2, t2) && (e2[t2] = n2[t2]);
            }
          }
          return e2;
        }, ve.apply(null, arguments);
      }
      function ye(e2, r2) {
        if (null == e2) return {};
        var n2, t2, l2 = be(e2, r2);
        if (Object.getOwnPropertySymbols) {
          var o2 = Object.getOwnPropertySymbols(e2);
          for (t2 = 0; t2 < o2.length; t2++) {
            n2 = o2[t2], -1 === r2.indexOf(n2) && {}.propertyIsEnumerable.call(e2, n2) && (l2[n2] = e2[n2]);
          }
        }
        return l2;
      }
      function be(e2, r2) {
        if (null == e2) return {};
        var n2 = {};
        for (var t2 in e2) {
          if ({}.hasOwnProperty.call(e2, t2)) {
            if (-1 !== r2.indexOf(t2)) continue;
            n2[t2] = e2[t2];
          }
        }
        return n2;
      }
      function me(e2) {
        var r2 = e2.children, n2 = e2.ordered, l2 = ye(e2, ["children", "ordered"]);
        return t().createElement(ne(), ve({}, l2, {
          ordered: n2
        }), r2);
      }
      const Oe = me;
      const ge = require_Paragraph();
      var he = e.n(ge);
      function we(e2, r2) {
        if (null == e2) return {};
        var n2, t2, l2 = Pe(e2, r2);
        if (Object.getOwnPropertySymbols) {
          var o2 = Object.getOwnPropertySymbols(e2);
          for (t2 = 0; t2 < o2.length; t2++) {
            n2 = o2[t2], -1 === r2.indexOf(n2) && {}.propertyIsEnumerable.call(e2, n2) && (l2[n2] = e2[n2]);
          }
        }
        return l2;
      }
      function Pe(e2, r2) {
        if (null == e2) return {};
        var n2 = {};
        for (var t2 in e2) {
          if ({}.hasOwnProperty.call(e2, t2)) {
            if (-1 !== r2.indexOf(t2)) continue;
            n2[t2] = e2[t2];
          }
        }
        return n2;
      }
      function je(e2) {
        var r2 = e2.children, n2 = we(e2, ["children"]);
        return t().createElement(he(), n2, r2);
      }
      const ke = je;
      const Se = require_Table();
      var Ee = e.n(Se);
      function xe() {
        return xe = Object.assign ? Object.assign.bind() : function(e2) {
          for (var r2 = 1; r2 < arguments.length; r2++) {
            var n2 = arguments[r2];
            for (var t2 in n2) {
              ({}).hasOwnProperty.call(n2, t2) && (e2[t2] = n2[t2]);
            }
          }
          return e2;
        }, xe.apply(null, arguments);
      }
      function Re(e2, r2) {
        if (null == e2) return {};
        var n2, t2, l2 = qe(e2, r2);
        if (Object.getOwnPropertySymbols) {
          var o2 = Object.getOwnPropertySymbols(e2);
          for (t2 = 0; t2 < o2.length; t2++) {
            n2 = o2[t2], -1 === r2.indexOf(n2) && {}.propertyIsEnumerable.call(e2, n2) && (l2[n2] = e2[n2]);
          }
        }
        return l2;
      }
      function qe(e2, r2) {
        if (null == e2) return {};
        var n2 = {};
        for (var t2 in e2) {
          if ({}.hasOwnProperty.call(e2, t2)) {
            if (-1 !== r2.indexOf(t2)) continue;
            n2[t2] = e2[t2];
          }
        }
        return n2;
      }
      function Ie(e2) {
        var r2 = e2.children, n2 = Re(e2, ["children"]);
        return t().createElement(Ee(), n2, r2);
      }
      Ie.splunkUiType = "Table";
      function Me(e2) {
        var r2 = e2.children, n2 = Re(e2, ["children"]);
        return t().createElement(Ee().Body, n2, r2);
      }
      Me.splunkUiType = "Table.Body";
      function Te(e2) {
        var r2 = e2.children, n2 = e2.style, l2 = Re(e2, ["children", "style"]);
        return t().createElement(Ee().Cell, xe({}, l2, {
          align: n2 === null || n2 === void 0 ? void 0 : n2.textAlign
        }), r2);
      }
      Te.splunkUiType = "Table.Cell";
      function Ce(e2) {
        var r2;
        return (e2 === null || e2 === void 0 ? void 0 : (r2 = e2.props) === null || r2 === void 0 ? void 0 : r2.children) != null;
      }
      function _e(e2) {
        var r2 = e2.children, n2 = Re(e2, ["children"]);
        var l2 = r2[0];
        var o2;
        if (Ce(l2)) {
          o2 = l2.props.children;
        }
        return t().createElement(Ee().Head, n2, o2);
      }
      _e.splunkUiType = "Table.Head";
      function Be(e2) {
        var r2 = e2.children, n2 = e2.style, l2 = Re(e2, ["children", "style"]);
        return t().createElement(Ee().HeadCell, xe({}, l2, {
          align: n2 === null || n2 === void 0 ? void 0 : n2.textAlign
        }), r2);
      }
      Be.splunkUiType = "Table.HeadCell";
      function He(e2) {
        var r2 = e2.children, n2 = Re(e2, ["children"]);
        return t().createElement(Ee().Row, n2, r2);
      }
      He.splunkUiType = "Table.Row";
      function Ae(e2) {
        "@babel/helpers - typeof";
        return Ae = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e3) {
          return typeof e3;
        } : function(e3) {
          return e3 && "function" == typeof Symbol && e3.constructor === Symbol && e3 !== Symbol.prototype ? "symbol" : typeof e3;
        }, Ae(e2);
      }
      function Ue() {
        return Ue = Object.assign ? Object.assign.bind() : function(e2) {
          for (var r2 = 1; r2 < arguments.length; r2++) {
            var n2 = arguments[r2];
            for (var t2 in n2) {
              ({}).hasOwnProperty.call(n2, t2) && (e2[t2] = n2[t2]);
            }
          }
          return e2;
        }, Ue.apply(null, arguments);
      }
      function Le(e2, r2) {
        var n2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var t2 = Object.getOwnPropertySymbols(e2);
          r2 && (t2 = t2.filter((function(r3) {
            return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
          }))), n2.push.apply(n2, t2);
        }
        return n2;
      }
      function Ne(e2) {
        for (var r2 = 1; r2 < arguments.length; r2++) {
          var n2 = null != arguments[r2] ? arguments[r2] : {};
          r2 % 2 ? Le(Object(n2), true).forEach((function(r3) {
            De(e2, r3, n2[r3]);
          })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(n2)) : Le(Object(n2)).forEach((function(r3) {
            Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(n2, r3));
          }));
        }
        return e2;
      }
      function De(e2, r2, n2) {
        return (r2 = Fe(r2)) in e2 ? Object.defineProperty(e2, r2, {
          value: n2,
          enumerable: true,
          configurable: true,
          writable: true
        }) : e2[r2] = n2, e2;
      }
      function Fe(e2) {
        var r2 = ze(e2, "string");
        return "symbol" == Ae(r2) ? r2 : r2 + "";
      }
      function ze(e2, r2) {
        if ("object" != Ae(e2) || !e2) return e2;
        var n2 = e2[Symbol.toPrimitive];
        if (void 0 !== n2) {
          var t2 = n2.call(e2, r2 || "default");
          if ("object" != Ae(t2)) return t2;
          throw new TypeError("@@toPrimitive must return a primitive value.");
        }
        return ("string" === r2 ? String : Number)(e2);
      }
      function $e(e2, r2) {
        if (null == e2) return {};
        var n2, t2, l2 = Ge(e2, r2);
        if (Object.getOwnPropertySymbols) {
          var o2 = Object.getOwnPropertySymbols(e2);
          for (t2 = 0; t2 < o2.length; t2++) {
            n2 = o2[t2], -1 === r2.indexOf(n2) && {}.propertyIsEnumerable.call(e2, n2) && (l2[n2] = e2[n2]);
          }
        }
        return l2;
      }
      function Ge(e2, r2) {
        if (null == e2) return {};
        var n2 = {};
        for (var t2 in e2) {
          if ({}.hasOwnProperty.call(e2, t2)) {
            if (-1 !== r2.indexOf(t2)) continue;
            n2[t2] = e2[t2];
          }
        }
        return n2;
      }
      var Je = {
        blockquoteRenderer: o().func,
        codeBlockRenderer: o().func,
        codeRenderer: o().func,
        elementRef: o().oneOfType([o().func, o().object]),
        headingRenderer: o().func,
        imageRenderer: o().func,
        itemRenderer: o().func,
        linkRenderer: o().func,
        listRenderer: o().func,
        paragraphRenderer: o().func,
        text: o().string.isRequired,
        rendererOptions: o().object
      };
      var Ke = function e2(r2) {
        return t().createElement(t().Fragment, null, r2.children);
      };
      var Qe = [c()];
      function Ve(e2) {
        var r2 = e2.blockquoteRenderer, l2 = e2.codeBlockRenderer, o2 = e2.codeRenderer, i2 = e2.elementRef, u2 = e2.headingRenderer, c2 = e2.imageRenderer, s2 = e2.itemRenderer, d2 = e2.linkRenderer, v2 = e2.listRenderer, y2 = e2.paragraphRenderer, b2 = e2.text, m2 = e2.rendererOptions, O2 = $e(e2, ["blockquoteRenderer", "codeBlockRenderer", "codeRenderer", "elementRef", "headingRenderer", "imageRenderer", "itemRenderer", "linkRenderer", "listRenderer", "paragraphRenderer", "text", "rendererOptions"]);
        var g2 = (0, n.useCallback)((function(e3) {
          var r3, n2;
          var i3 = e3.className, a2 = i3 === void 0 ? "" : i3, u3 = e3.node;
          var c3 = u3 === null || u3 === void 0 ? void 0 : (r3 = u3.position) === null || r3 === void 0 ? void 0 : r3.start.line;
          var f2 = u3 === null || u3 === void 0 ? void 0 : (n2 = u3.position) === null || n2 === void 0 ? void 0 : n2.end.line;
          var s3 = c3 !== void 0 && f2 !== void 0 && c3 === f2;
          if (s3) {
            return o2 ? o2(Ne({}, e3)) : t().createElement(B, e3);
          }
          var d3 = (a2 === null || a2 === void 0 ? void 0 : a2.replace("language-", "")) || void 0;
          return l2 ? l2(Ne({
            language: d3
          }, e3)) : t().createElement(F, Ue({
            language: d3
          }, e3));
        }), [l2, o2]);
        var h2 = (0, n.useMemo)((function() {
          return {
            a: d2 || pe,
            blockquote: r2 || M,
            code: g2,
            h1: u2 || V,
            h2: u2 || V,
            h3: u2 || V,
            h4: u2 || V,
            h5: u2 || V,
            h6: u2 || V,
            img: c2 || ee,
            li: s2 || ie,
            ol: v2 || Oe,
            p: y2 || ke,
            pre: Ke,
            ul: v2 || Oe,
            table: Ie,
            thead: _e,
            th: Be,
            td: Te,
            tr: He,
            tbody: Me
          };
        }), [r2, g2, u2, c2, s2, d2, v2, y2]);
        return t().createElement(p(), Ue({
          "data-test": "markdown",
          elementRef: i2,
          elementSelectors: {
            /* stylelint-disable */
            pre: (0, f.css)([":is(", ")"], S),
            blockquote: (0, f.css)([":is(", ")"], x)
            /* stylelint-enable */
          }
        }, O2), t().createElement(a(), Ue({
          remarkPlugins: Qe,
          components: h2
        }, m2), b2));
      }
      Ve.propTypes = Je;
      const We = Ve;
      module.exports = r;
    })();
  }
});

// node_modules/@splunk/visualizations-shared/colorConstants.js
var require_colorConstants = __commonJS({
  "node_modules/@splunk/visualizations-shared/colorConstants.js"(exports, module) {
    var import_dist466 = __toESM(require_dist());
    var import_dist467 = __toESM(require_dist2());
    var import_dist468 = __toESM(require_dist3());
    var __create = Object.create;
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __getProtoOf = Object.getPrototypeOf;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export2 = (target, all3) => {
      for (var name in all3)
        __defProp(target, name, { get: all3[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
    var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
      // If the importer is in node compatibility mode or this is not an ESM
      // file that has been converted to a CommonJS file using a Babel-
      // compatible transform (i.e. "__esModule" has not been set), then set
      // "default" to the CommonJS "module.exports" for node compatibility.
      isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
      mod
    ));
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var colorConstants_exports = {};
    __export2(colorConstants_exports, {
      COLOR_EDITOR_PALETTE: () => COLOR_EDITOR_PALETTE,
      DELTA_GREEN: () => DELTA_GREEN,
      DELTA_RED: () => DELTA_RED,
      RADIAL_BACKGROUND_COLOR: () => RADIAL_BACKGROUND_COLOR,
      RADIAL_SEVERITY_COLORS: () => RADIAL_SEVERITY_COLORS,
      RADIAL_STROKE_COLOR: () => RADIAL_STROKE_COLOR,
      SEMANTIC_ERROR: () => SEMANTIC_ERROR,
      SEMANTIC_SUCCESS: () => SEMANTIC_SUCCESS,
      SEMANTIC_WARNING: () => SEMANTIC_WARNING,
      SPARKLINE_FILL_COLOR: () => SPARKLINE_FILL_COLOR,
      SPARKLINE_STROKE_COLOR: () => SPARKLINE_STROKE_COLOR,
      SPARKLINE_WHITE: () => SPARKLINE_WHITE
    });
    module.exports = __toCommonJS2(colorConstants_exports);
    var getTheme_exports = {};
    __export2(getTheme_exports, {
      default: () => getTheme_default
    });
    var defaultImport = __toESM2(require_getTheme());
    __reExport(getTheme_exports, require_getTheme());
    var getTheme_default = "default" in defaultImport ? defaultImport.default : defaultImport;
    var themeEnterprise = getTheme_default({
      family: "enterprise",
      colorScheme: "light",
      density: "comfortable"
    });
    var DELTA_GREEN = themeEnterprise.successColor;
    var DELTA_RED = themeEnterprise.errorColor;
    var SEMANTIC_SUCCESS = "#53a051";
    var SEMANTIC_WARNING = "#f8be34";
    var SEMANTIC_ERROR = "#dc4e41";
    var SPARKLINE_FILL_COLOR = themeEnterprise.gray60;
    var SPARKLINE_STROKE_COLOR = themeEnterprise.gray20;
    var SPARKLINE_WHITE = themeEnterprise.white;
    var RADIAL_BACKGROUND_COLOR = themeEnterprise.gray92;
    var RADIAL_STROKE_COLOR = themeEnterprise.gray60;
    var RADIAL_SEVERITY_COLORS = {
      none: {
        background: themeEnterprise.gray92,
        stroke: themeEnterprise.gray60
      },
      low: {
        background: themeEnterprise.successColorL40,
        stroke: themeEnterprise.successColorD50
      },
      guarded: {
        background: themeEnterprise.infoColorL40,
        stroke: themeEnterprise.infoColorD50
      },
      elevated: {
        background: themeEnterprise.warningColorL40,
        stroke: themeEnterprise.warningColorD50
      },
      high: {
        background: themeEnterprise.alertColorL40,
        stroke: themeEnterprise.alertColorD50
      },
      severe: {
        background: themeEnterprise.errorColorL40,
        stroke: themeEnterprise.errorColorD50
      }
    };
    var COLOR_EDITOR_PALETTE = [
      "transparent",
      "#000000",
      "#ffffff",
      "#dc4e41",
      "#f1813f",
      "#f8be34",
      "#53a051",
      "#0877a6",
      "#ec9960",
      "#af575a",
      "#62b3b2",
      "#4fa484",
      "#f8be44",
      "#5a4575",
      "#708794",
      "#294e70",
      "#b6c75a"
    ];
  }
});

// node_modules/@splunk/visualization-encoding/utils/types.js
var require_types = __commonJS({
  "node_modules/@splunk/visualization-encoding/utils/types.js"(exports, module) {
    var import_dist466 = __toESM(require_dist());
    var import_dist467 = __toESM(require_dist2());
    var import_dist468 = __toESM(require_dist3());
    var __create = Object.create;
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __getProtoOf = Object.getPrototypeOf;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export2 = (target, all3) => {
      for (var name in all3)
        __defProp(target, name, { get: all3[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
    var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
      // If the importer is in node compatibility mode or this is not an ESM
      // file that has been converted to a CommonJS file using a Babel-
      // compatible transform (i.e. "__esModule" has not been set), then set
      // "default" to the CommonJS "module.exports" for node compatibility.
      isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
      mod
    ));
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var types_exports2 = {};
    __export2(types_exports2, {
      canInferTypeFromMeta: () => canInferTypeFromMeta,
      dataPointValues: () => dataPointValues,
      getDataTypeForMeta: () => getDataTypeForMeta,
      getDataTypeForPoint: () => getDataTypeForPoint,
      inferDataTypeFromData: () => inferDataTypeFromData,
      inferDataTypeFromDataPoints: () => inferDataTypeFromDataPoints,
      isGeoJsonObject: () => isGeoJsonObject,
      isNumber: () => isNumber,
      isString: () => isString,
      isTime: () => isTime
    });
    module.exports = __toCommonJS2(types_exports2);
    var moment_exports = {};
    __export2(moment_exports, {
      default: () => moment_default
    });
    var defaultImport = __toESM2(require_moment());
    __reExport(moment_exports, require_moment());
    var moment_default = "default" in defaultImport ? defaultImport.default : defaultImport;
    var lodash_exports = {};
    __export2(lodash_exports, {
      default: () => lodash_default
    });
    var defaultImport2 = __toESM2(require_lodash());
    __reExport(lodash_exports, require_lodash());
    var lodash_default = "default" in defaultImport2 ? defaultImport2.default : defaultImport2;
    var visualization_schemas_exports = {};
    __export2(visualization_schemas_exports, {
      default: () => visualization_schemas_default
    });
    var defaultImport3 = __toESM2(require_cjs());
    __reExport(visualization_schemas_exports, require_cjs());
    var visualization_schemas_default = "default" in defaultImport3 ? defaultImport3.default : defaultImport3;
    var namedColors_default = [
      "transparent",
      "aliceblue",
      "antiquewhite",
      "aqua",
      "aquamarine",
      "azure",
      "beige",
      "bisque",
      "black",
      "blanchedalmond",
      "blue",
      "blueviolet",
      "brown",
      "burlywood",
      "cadetblue",
      "chartreuse",
      "chocolate",
      "coral",
      "cornflowerblue",
      "cornsilk",
      "crimson",
      "cyan",
      "darkblue",
      "darkcyan",
      "darkgoldenrod",
      "darkgray",
      "darkgreen",
      "darkgrey",
      "darkkhaki",
      "darkmagenta",
      "darkolivegreen",
      "darkorange",
      "darkorchid",
      "darkred",
      "darksalmon",
      "darkseagreen",
      "darkslateblue",
      "darkslategray",
      "darkslategrey",
      "darkturquoise",
      "darkviolet",
      "deeppink",
      "deepskyblue",
      "dimgray",
      "dimgrey",
      "dodgerblue",
      "firebrick",
      "floralwhite",
      "forestgreen",
      "fuchsia",
      "gainsboro",
      "ghostwhite",
      "gold",
      "goldenrod",
      "gray",
      "green",
      "greenyellow",
      "grey",
      "honeydew",
      "hotpink",
      "indianred",
      "indigo",
      "ivory",
      "khaki",
      "lavender",
      "lavenderblush",
      "lawngreen",
      "lemonchiffon",
      "lightblue",
      "lightcoral",
      "lightcyan",
      "lightgoldenrodyellow",
      "lightgray",
      "lightgreen",
      "lightgrey",
      "lightpink",
      "lightsalmon",
      "lightseagreen",
      "lightskyblue",
      "lightslategray",
      "lightslategrey",
      "lightsteelblue",
      "lightyellow",
      "lime",
      "limegreen",
      "linen",
      "magenta",
      "maroon",
      "mediumaquamarine",
      "mediumblue",
      "mediumorchid",
      "mediumpurple",
      "mediumseagreen",
      "mediumslateblue",
      "mediumspringgreen",
      "mediumturquoise",
      "mediumvioletred",
      "midnightblue",
      "mintcream",
      "mistyrose",
      "moccasin",
      "navajowhite",
      "navy",
      "oldlace",
      "olive",
      "olivedrab",
      "orange",
      "orangered",
      "orchid",
      "palegoldenrod",
      "palegreen",
      "paleturquoise",
      "palevioletred",
      "papayawhip",
      "peachpuff",
      "peru",
      "pink",
      "plum",
      "powderblue",
      "purple",
      "rebeccapurple",
      "red",
      "rosybrown",
      "royalblue",
      "saddlebrown",
      "salmon",
      "sandybrown",
      "seagreen",
      "seashell",
      "sienna",
      "silver",
      "skyblue",
      "slateblue",
      "slategray",
      "slategrey",
      "snow",
      "springgreen",
      "steelblue",
      "tan",
      "teal",
      "thistle",
      "tomato",
      "turquoise",
      "violet",
      "wheat",
      "white",
      "whitesmoke",
      "yellow",
      "yellowgreen"
    ];
    function isColor(color2 = "") {
      if (typeof color2 !== "string") {
        return false;
      }
      if (color2.startsWith("#")) {
        color2 = color2.substring(1);
        return [3, 4, 6, 8].indexOf(color2.length) > -1 && !Number.isNaN(parseInt(color2, 16));
      }
      const trimmedColor = color2.trim();
      if (visualization_schemas_exports.rgbColorPattern.test(trimmedColor) || visualization_schemas_exports.rgbaColorPattern.test(trimmedColor)) {
        return true;
      }
      return namedColors_default.includes(color2.toLowerCase());
    }
    var timeToSplunkMoment = (time) => {
      if (moment_default.getDefaultSplunkTimezone()) {
        return moment_default.newSplunkTime({ time });
      }
      return moment_default(time);
    };
    var formatTimeWithTimezoneCorrection = (time, format = moment_default.defaultFormat) => {
      const utcOffset = moment_default.parseZone(time).utcOffset();
      const momentTime = timeToSplunkMoment(time).utcOffset(utcOffset);
      return momentTime.format(format);
    };
    var TypeSafeValue = class _TypeSafeValue {
      // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
      constructor(type, value, coercedValue) {
        this.isTypeSafe = true;
        this.type = type;
        this.value = value;
        this.coercedValue = coercedValue;
      }
      /**
       * returns a TypeSafeValue, either by converting the non TypeSafeValue to
       * a TypeSafeValue, or by simply returning the passed-in TypeSafeValue
       * @param {TypedValue<T>} typedValue
       * @returns {TypeSafeValue<T>}
       */
      static from(typedValue) {
        if (typedValue.isTypeSafe) {
          return typedValue;
        }
        const { value, type } = typedValue;
        const [coercedValue] = _TypeSafeValue.coerceValue(typedValue);
        return new _TypeSafeValue(type, value, coercedValue);
      }
      /**
       * Creates a TypeSafeValue from a raw value
       * @param value
       * @returns {TypeSafeValue<DataType>}
       */
      static fromRaw(value) {
        const type = getDataTypeForPoint(value);
        return new _TypeSafeValue(type, value, value);
      }
      /**
       * attempts to coerce the provided value to the provided type. Returns tuple
       * of the coerced value and a boolean telling if the coercion was clean (true)
       * or if the coercion was likely produced an unusable result, such as NaN for
       * a number, or '' for a color.
       * @param {TypedValue<T>} typedValue
       * @returns {[any]}
       */
      static coerceValue(typedValue) {
        const { type, value } = typedValue;
        let coercedValue = null;
        try {
          switch (type) {
            case "number": {
              coercedValue = Number(value);
              break;
            }
            case "time": {
              const isOk = isTime(value);
              if (value instanceof Date) {
                coercedValue = value;
              } else if (!isOk) {
                coercedValue = "Invalid Date";
              } else {
                const timeString = formatTimeWithTimezoneCorrection(value);
                coercedValue = timeString;
              }
              break;
            }
            case "string": {
              coercedValue = value.toString();
              break;
            }
            case "color": {
              coercedValue = value;
              break;
            }
            case "sparkline": {
              coercedValue = value;
              break;
            }
            case "array": {
              coercedValue = value;
              break;
            }
            case "null": {
              coercedValue = value;
              break;
            }
            case "geojson": {
              coercedValue = value;
              break;
            }
            default: {
              coercedValue = "";
            }
          }
        } catch (e) {
        }
        return [coercedValue];
      }
      toRawCoercedValue() {
        switch (this.type) {
          case "time":
          case "sparkline":
          case "array":
          case "number":
          case "string":
          case "color":
          case "geojson":
          default:
            return this.coercedValue;
        }
      }
      toRawValue() {
        switch (this.type) {
          case "time":
          case "sparkline":
          case "array":
          case "number":
          case "string":
          case "color":
          case "geojson":
          default:
            return this.value;
        }
      }
    };
    var _DataPoint = class _DataPoint2 {
      static isDataPoint(o) {
        return o instanceof _DataPoint2;
      }
      static fromRaw(value) {
        return new _DataPoint2("", TypeSafeValue.fromRaw(value));
      }
      /**
       *
       * @param {string} field data field
       * @param {object} value data value + it's type (number, string, time, color, geojson)
       */
      constructor(field, value) {
        this.field = field;
        this.setValue(value);
        _DataPoint2.count += 1;
      }
      getValue() {
        return this.value;
      }
      /**
       * Sets the data point's value to a static TypedValue.
       * @param {TypedValue} v
       */
      setValue(v) {
        this.value = TypeSafeValue.from(v);
      }
      /**
       * Get only value of the data point.
       * @returns {string|number|GeoJsonDataType|null}
       */
      getRawValue() {
        return this.value.toRawValue();
      }
      /**
       * Get only the coerced value of the data point.
       * @returns {string|number|null}
       */
      getCoercedValue() {
        return this.value.toRawCoercedValue();
      }
      /**
       * Returns the data field of the point.
       * @public
       * @returns {DataPoint<'string'>}
       */
      getField() {
        return _DataPoint2.fromRaw(this.field);
      }
      /**
       * Returns the data type of the point.
       * @public
       * @returns {string}
       */
      getType() {
        return this.value.type;
      }
    };
    _DataPoint.count = 0;
    var DataPoint = _DataPoint;
    var supportedDateFormats = [
      "YYYY-MM-DD",
      // HTML5 date
      moment_default.ISO_8601,
      "YYYY-MM-DDTHH:mm",
      // HTML5 date local
      "YYYY-MM-DDTHH:mm:ss.SSS",
      // HTML5 date local milliseconds
      "YYYY-MM-DDTHH:mm:ss",
      // HTML5 date local seconds
      "YYYY-MM-DD HH:MM",
      "YYYY-MM-DD HH:MM:SS",
      "YYYY-MM-DD HH:MM:SS.SSS"
    ];
    var typeOrder = [
      "geojson",
      "sparkline",
      "array",
      "string",
      "color",
      "number",
      "time",
      "null",
      "unknown"
    ];
    function isNumber(dataPoint) {
      return dataPoint !== null && !(0, lodash_exports.isBoolean)(dataPoint) && dataPoint !== "" && (0, lodash_exports.isFinite)(+dataPoint) && (0, lodash_exports.isNumber)(+dataPoint);
    }
    function isGeoJsonObject(dataPoint) {
      if (!dataPoint) return false;
      let parsedDataPoint;
      try {
        parsedDataPoint = (0, lodash_exports.isObject)(dataPoint) ? dataPoint : JSON.parse(dataPoint);
      } catch (e) {
        return false;
      }
      if (parsedDataPoint == null) {
        return false;
      }
      return Object.prototype.hasOwnProperty.call(parsedDataPoint, "coordinates") && parsedDataPoint.coordinates != null && Array.isArray(parsedDataPoint.coordinates) && Object.prototype.hasOwnProperty.call(parsedDataPoint, "type") && parsedDataPoint.type === "MultiPolygon";
    }
    function isTime(dataPoint) {
      if (!dataPoint) {
        return false;
      }
      return typeof dataPoint === "string" ? moment_default(dataPoint, supportedDateFormats, true).isValid() : moment_default(dataPoint).isValid();
    }
    function isString(dataPoint) {
      return typeof dataPoint === "string" && dataPoint.length > 0;
    }
    var getDataTypeForPoint = (dataPoint, metaData) => {
      if (canInferTypeFromMeta(metaData)) {
        return getDataTypeForMeta(metaData);
      }
      return memoizedGetDataTypeForValue(dataPoint);
    };
    var getDataTypeForValue = (dataPoint) => {
      if (Array.isArray(dataPoint)) {
        if (dataPoint.length > 1 && dataPoint[0] === "##__SPARKLINE__##") {
          return "sparkline";
        }
        return "array";
      }
      if (isGeoJsonObject(dataPoint)) {
        return "geojson";
      }
      if ((0, lodash_exports.isObject)(dataPoint)) {
        return "unknown";
      }
      if (isNumber(dataPoint)) {
        return "number";
      }
      if (isString(dataPoint) && isColor(dataPoint)) {
        return "color";
      }
      if (isTime(dataPoint)) {
        return "time";
      }
      if (isString(dataPoint)) {
        return "string";
      }
      if (dataPoint === null) {
        return "null";
      }
      return "unknown";
    };
    var memoizedGetDataTypeForValue = (0, lodash_exports.memoize)(getDataTypeForValue);
    var splTypesToDSLDataTypes = {
      str: "string",
      num: "number"
    };
    var canInferTypeFromMeta = (metaData = {}) => {
      const { name, type = "" } = metaData;
      return splTypesToDSLDataTypes[type] !== void 0 || name === "_time";
    };
    var getDataTypeForMeta = (metaData = {}) => {
      const { name, type } = metaData;
      if (name === "_time") {
        return "time";
      }
      const typeMatch = splTypesToDSLDataTypes[type];
      if (typeMatch !== void 0) {
        return typeMatch;
      }
      return "unknown";
    };
    var applyTypePrioritization = (typeMatches) => {
      const typesWithCount = Object.keys(typeMatches).filter(
        (key) => typeMatches[key] > 0
      );
      if (typesWithCount.length === 0) {
        return "unknown";
      }
      if (typesWithCount.length === 1) {
        return typesWithCount[0];
      }
      for (let i = 0; i < typeOrder.length; i += 1) {
        const key = typeOrder[i];
        if (typesWithCount.find((k) => k === key)) {
          return key;
        }
      }
      return "unknown";
    };
    var inferDataTypeFromDataPoints = (dataPoints) => {
      if (!dataPoints) {
        return "unknown";
      }
      const typeMatches = {
        time: 0,
        number: 0,
        string: 0,
        color: 0,
        unknown: 0,
        array: 0,
        sparkline: 0,
        null: 0,
        geojson: 0
      };
      dataPoints.forEach((point4) => {
        typeMatches[point4.getType()] += 1;
      });
      return applyTypePrioritization(typeMatches);
    };
    var dataPointValues = (data) => {
      return data.map((point4) => DataPoint.isDataPoint(point4) ? point4 : DataPoint.fromRaw(point4));
    };
    var inferDataTypeFromData = (data) => inferDataTypeFromDataPoints(dataPointValues(data));
  }
});

// node_modules/@babel/runtime/helpers/objectWithoutPropertiesLoose.js
var require_objectWithoutPropertiesLoose = __commonJS({
  "node_modules/@babel/runtime/helpers/objectWithoutPropertiesLoose.js"(exports, module) {
    var import_dist466 = __toESM(require_dist());
    var import_dist467 = __toESM(require_dist2());
    var import_dist468 = __toESM(require_dist3());
    function _objectWithoutPropertiesLoose(r, e) {
      if (null == r) return {};
      var t = {};
      for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
        if (-1 !== e.indexOf(n)) continue;
        t[n] = r[n];
      }
      return t;
    }
    module.exports = _objectWithoutPropertiesLoose, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/objectWithoutProperties.js
var require_objectWithoutProperties = __commonJS({
  "node_modules/@babel/runtime/helpers/objectWithoutProperties.js"(exports, module) {
    var import_dist466 = __toESM(require_dist());
    var import_dist467 = __toESM(require_dist2());
    var import_dist468 = __toESM(require_dist3());
    var objectWithoutPropertiesLoose = require_objectWithoutPropertiesLoose();
    function _objectWithoutProperties(e, t) {
      if (null == e) return {};
      var o, r, i = objectWithoutPropertiesLoose(e, t);
      if (Object.getOwnPropertySymbols) {
        var n = Object.getOwnPropertySymbols(e);
        for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
      }
      return i;
    }
    module.exports = _objectWithoutProperties, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/extends.js
var require_extends = __commonJS({
  "node_modules/@babel/runtime/helpers/extends.js"(exports, module) {
    var import_dist466 = __toESM(require_dist());
    var import_dist467 = __toESM(require_dist2());
    var import_dist468 = __toESM(require_dist3());
    function _extends() {
      return module.exports = _extends = Object.assign ? Object.assign.bind() : function(n) {
        for (var e = 1; e < arguments.length; e++) {
          var t = arguments[e];
          for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
        }
        return n;
      }, module.exports.__esModule = true, module.exports["default"] = module.exports, _extends.apply(null, arguments);
    }
    module.exports = _extends, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

export {
  require_visualization_color_palettes,
  require_objectWithoutProperties,
  require_extends,
  require_style,
  require_colorUtils,
  require_colorUtils2,
  require_trellisUtils,
  require_dataSourceUtils,
  sortable_esm_exports,
  init_sortable_esm,
  require_ParallelDots,
  require_ArrowDown,
  require_ArrowUp,
  require_Table,
  require_TextArea,
  require_Code,
  require_Markdown,
  require_colorConstants,
  require_types
};
/*! Bundled license information:

@splunk/react-ui/Code.js:
  (**
  * Prism: Lightweight, robust, elegant syntax highlighting
  *
  * @license MIT <https://opensource.org/licenses/MIT>
  * @author Lea Verou <https://lea.verou.me>
  * @namespace
  * @public
  *)

is-buffer/index.js:
  (*!
   * Determine if an object is a Buffer
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)

repeat-string/index.js:
  (*!
   * repeat-string <https://github.com/jonschlinkert/repeat-string>
   *
   * Copyright (c) 2014-2015, Jon Schlinkert.
   * Licensed under the MIT License.
   *)
*/
//# sourceMappingURL=chunk-4D5NF5YA.js.map
