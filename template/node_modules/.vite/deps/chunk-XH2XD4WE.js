import __buffer_polyfill from 'vite-plugin-node-polyfills/shims/buffer'
globalThis.Buffer = globalThis.Buffer || __buffer_polyfill
import __global_polyfill from 'vite-plugin-node-polyfills/shims/global'
globalThis.global = globalThis.global || __global_polyfill
import __process_polyfill from 'vite-plugin-node-polyfills/shims/process'
globalThis.process = globalThis.process || __process_polyfill

import {
  require_format,
  require_isNumber
} from "./chunk-6CXBXVKR.js";
import {
  init_jspdf_es_min,
  jspdf_es_min_exports
} from "./chunk-ILMRD3Q4.js";
import {
  require_SetCache,
  require_arrayIncludes,
  require_arrayIncludesWith,
  require_baseFindIndex,
  require_baseIteratee,
  require_cacheHas,
  require_every,
  require_get,
  require_id,
  require_intersection,
  require_isFinite
} from "./chunk-ADRYVMRQ.js";
import {
  require_toInteger
} from "./chunk-LPGHV4NL.js";
import {
  require_arrayMap,
  require_baseFlatten,
  require_has,
  require_keys
} from "./chunk-PYQODTGJ.js";
import {
  require_i18n,
  require_isString
} from "./chunk-SFZFMFKO.js";
import {
  require_baseRest,
  require_baseUnary,
  require_isArrayLike,
  require_isArrayLikeObject,
  require_isPlainObject
} from "./chunk-RQTG6R3C.js";
import {
  require_memoize
} from "./chunk-WZ5QAOVA.js";
import {
  require_call_bound,
  require_inherits,
  require_is_typed_array,
  require_safe_buffer,
  require_stream_browserify,
  require_type
} from "./chunk-WJRY3YLW.js";
import {
  dist_exports,
  init_dist
} from "./chunk-UVNYCG7R.js";
import {
  require_lodash
} from "./chunk-FUC7W543.js";
import {
  __commonJS,
  __esm,
  __export,
  __require,
  __toCommonJS,
  __toESM,
  require_dist,
  require_dist2,
  require_dist3
} from "./chunk-2RF6DQJU.js";

// node_modules/@splunk/ui-utils/cookie.js
var require_cookie = __commonJS({
  "node_modules/@splunk/ui-utils/cookie.js"(exports2) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.getEntry = getEntry;
    function getEntry(name) {
      if (typeof document === "undefined") {
        return null;
      }
      var regex = new RegExp("(^|; ?)".concat(name, "=([^;]+)"));
      var value = null;
      try {
        var match = document.cookie.match(regex);
        value = match ? match[2] : null;
      } catch (e) {
      }
      return value;
    }
  }
});

// node_modules/@splunk/splunk-utils/config.js
var require_config = __commonJS({
  "node_modules/@splunk/splunk-utils/config.js"(exports2) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.getCSRFToken = getCSRFToken;
    exports2.extractAppName = extractAppName;
    exports2.versionLabel = exports2.username = exports2.splunkdPath = exports2.serverTimezoneInfo = exports2.rootPath = exports2.portNumber = exports2.locale = exports2.config = exports2.buildPushNumber = exports2.buildNumber = exports2.appBuild = exports2.app = exports2.isAvailable = exports2.CSRFToken = void 0;
    var _get = _interopRequireDefault(require_get());
    var _cookie = require_cookie();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    var root = typeof window === "undefined" ? global : window;
    function get$CEntry(prop) {
      return (0, _get["default"])(root, ["$C", prop]);
    }
    var CSRFToken = (0, _cookie.getEntry)("splunkweb_csrf_token_".concat(get$CEntry("MRSPARKLE_PORT_NUMBER")));
    exports2.CSRFToken = CSRFToken;
    function getCSRFToken() {
      return (0, _cookie.getEntry)("splunkweb_csrf_token_".concat(get$CEntry("MRSPARKLE_PORT_NUMBER")));
    }
    var isAvailable = !!get$CEntry("SPLUNKD_PATH");
    exports2.isAvailable = isAvailable;
    function extractAppName() {
      var pathname = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : (0, _get["default"])(root, ["document", "location", "pathname"], "");
      var pathMatch = pathname.match(/\w\w.\w\w\/(app|manager)\/([^/]+)/);
      return pathMatch ? pathMatch[2] : void 0;
    }
    var app = extractAppName();
    exports2.app = app;
    var appBuild = get$CEntry("APP_BUILD");
    exports2.appBuild = appBuild;
    var buildNumber = get$CEntry("BUILD_NUMBER");
    exports2.buildNumber = buildNumber;
    var buildPushNumber = get$CEntry("BUILD_PUSH_NUMBER");
    exports2.buildPushNumber = buildPushNumber;
    var config = (0, _get["default"])(root, "$C");
    exports2.config = config;
    var locale = get$CEntry("LOCALE");
    exports2.locale = locale;
    var portNumber = get$CEntry("MRSPARKLE_PORT_NUMBER");
    exports2.portNumber = portNumber;
    var rootPath = get$CEntry("MRSPARKLE_ROOT_PATH");
    exports2.rootPath = rootPath;
    var serverTimezoneInfo = get$CEntry("SERVER_ZONEINFO");
    exports2.serverTimezoneInfo = serverTimezoneInfo;
    var splunkdPath = get$CEntry("SPLUNKD_PATH");
    exports2.splunkdPath = splunkdPath;
    var username = get$CEntry("USERNAME");
    exports2.username = username;
    var versionLabel = get$CEntry("VERSION_LABEL");
    exports2.versionLabel = versionLabel;
  }
});

// node_modules/@splunk/moment/index.js
var require_moment = __commonJS({
  "node_modules/@splunk/moment/index.js"(exports2, module2) {
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    (() => {
      var e = { 2153: (e2, a2, n2) => {
        "use strict";
        n2.d(a2, { default: () => r });
        var t2 = n2(316), c = n2.n(t2);
        function s(e3, a3) {
          var n3 = Object.keys(e3);
          if (Object.getOwnPropertySymbols) {
            var t3 = Object.getOwnPropertySymbols(e3);
            a3 && (t3 = t3.filter((function(a4) {
              return Object.getOwnPropertyDescriptor(e3, a4).enumerable;
            }))), n3.push.apply(n3, t3);
          }
          return n3;
        }
        function o(e3) {
          for (var a3 = 1; a3 < arguments.length; a3++) {
            var n3 = null != arguments[a3] ? arguments[a3] : {};
            a3 % 2 ? s(Object(n3), true).forEach((function(a4) {
              i(e3, a4, n3[a4]);
            })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(n3)) : s(Object(n3)).forEach((function(a4) {
              Object.defineProperty(e3, a4, Object.getOwnPropertyDescriptor(n3, a4));
            }));
          }
          return e3;
        }
        function i(e3, a3, n3) {
          return a3 in e3 ? Object.defineProperty(e3, a3, { value: n3, enumerable: true, configurable: true, writable: true }) : e3[a3] = n3, e3;
        }
        const r = function(e3, a3) {
          var n3 = { abbrs: [], offsets: [], starts: [] };
          e3.split(";").forEach((function(e4) {
            switch (e4.charAt(0)) {
              case "C":
              default:
                break;
              case "Y":
                n3 = (function(e5, a4) {
                  var n4 = e5.split(" ");
                  if (n4.length < 5) return a4;
                  var t4 = parseInt(n4[0], 10);
                  if (!c()(t4)) return a4;
                  var s3 = n4.splice(2).reduce((function(e6, a5) {
                    var n5 = String.fromCharCode(parseInt(a5, 16));
                    return "".concat(e6).concat(n5);
                  }), "");
                  return o(o({}, a4), {}, { abbrs: a4.abbrs.concat([s3]), offsets: a4.offsets.concat([-t4 / 60]) });
                })(e4.substring(1, e4.length), n3);
                break;
              case "@":
                n3 = (function(e5, a4) {
                  var n4 = e5.split(" ");
                  if (n4.length < 2) return a4;
                  var t4 = parseInt(n4[0], 10);
                  if (!c()(t4)) return a4;
                  var s3 = parseInt(n4[1], 10);
                  return !c()(s3) || s3 < 0 || s3 >= a4.offsets.length ? a4 : o(o({}, a4), {}, { starts: a4.starts.concat([{ time: 1e3 * t4, abbr: a4.abbrs[s3], offset: a4.offsets[s3] }]) });
                })(e4.substring(1, e4.length), n3);
            }
          }));
          var t3 = { name: a3, abbrs: [], offsets: [], untils: [] };
          if (0 === n3.starts.length) return t3.abbrs.push(n3.abbrs[0]), t3.offsets.push(n3.offsets[0]), t3.untils.push(null), t3;
          var s2 = n3.starts[0], i2 = n3.starts[n3.starts.length - 1];
          return n3.starts.forEach((function(e4, a4) {
            e4 === s2 ? (t3.abbrs.push(i2.abbr), t3.offsets.push(i2.offset), t3.untils.push(e4.time)) : (t3.abbrs.push(n3.starts[a4 - 1].abbr), t3.offsets.push(n3.starts[a4 - 1].offset), t3.untils.push(e4.time)), e4 === i2 && (t3.abbrs.push(e4.abbr), t3.offsets.push(e4.offset), t3.untils.push(null));
          })), t3;
        };
      }, 4253: (e2, a2, n2) => {
        var t2 = n2(7554), c = n2(6772), s = n2(1616), o = n2(8099), i = n2(2673);
        function r(e3) {
          var a3 = -1, n3 = null == e3 ? 0 : e3.length;
          for (this.clear(); ++a3 < n3; ) {
            var t3 = e3[a3];
            this.set(t3[0], t3[1]);
          }
        }
        r.prototype.clear = t2, r.prototype.delete = c, r.prototype.get = s, r.prototype.has = o, r.prototype.set = i, e2.exports = r;
      }, 9849: (e2, a2, n2) => {
        var t2 = n2(5698), c = n2(7688), s = n2(2640), o = n2(8406), i = n2(2070);
        function r(e3) {
          var a3 = -1, n3 = null == e3 ? 0 : e3.length;
          for (this.clear(); ++a3 < n3; ) {
            var t3 = e3[a3];
            this.set(t3[0], t3[1]);
          }
        }
        r.prototype.clear = t2, r.prototype.delete = c, r.prototype.get = s, r.prototype.has = o, r.prototype.set = i, e2.exports = r;
      }, 6619: (e2, a2, n2) => {
        var t2 = n2(4061)(n2(5126), "Map");
        e2.exports = t2;
      }, 9794: (e2, a2, n2) => {
        var t2 = n2(6807), c = n2(2770), s = n2(893), o = n2(2461), i = n2(8476);
        function r(e3) {
          var a3 = -1, n3 = null == e3 ? 0 : e3.length;
          for (this.clear(); ++a3 < n3; ) {
            var t3 = e3[a3];
            this.set(t3[0], t3[1]);
          }
        }
        r.prototype.clear = t2, r.prototype.delete = c, r.prototype.get = s, r.prototype.has = o, r.prototype.set = i, e2.exports = r;
      }, 7887: (e2, a2, n2) => {
        var t2 = n2(5126).Symbol;
        e2.exports = t2;
      }, 5285: (e2, a2, n2) => {
        var t2 = n2(2537);
        e2.exports = function(e3, a3) {
          for (var n3 = e3.length; n3--; ) if (t2(e3[n3][0], a3)) return n3;
          return -1;
        };
      }, 7030: (e2, a2, n2) => {
        var t2 = n2(7887), c = n2(3490), s = n2(6275), o = t2 ? t2.toStringTag : void 0;
        e2.exports = function(e3) {
          return null == e3 ? void 0 === e3 ? "[object Undefined]" : "[object Null]" : o && o in Object(e3) ? c(e3) : s(e3);
        };
      }, 5849: (e2, a2, n2) => {
        var t2 = n2(8626), c = n2(9650), s = n2(5600), o = n2(339), i = /^\[object .+?Constructor\]$/, r = Function.prototype, M = Object.prototype, d = r.toString, _ = M.hasOwnProperty, u = RegExp("^" + d.call(_).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
        e2.exports = function(e3) {
          return !(!s(e3) || c(e3)) && (t2(e3) ? u : i).test(o(e3));
        };
      }, 6832: (e2, a2, n2) => {
        var t2 = n2(5126)["__core-js_shared__"];
        e2.exports = t2;
      }, 9876: (e2, a2, n2) => {
        var t2 = "object" == typeof n2.g && n2.g && n2.g.Object === Object && n2.g;
        e2.exports = t2;
      }, 3291: (e2, a2, n2) => {
        var t2 = n2(4246);
        e2.exports = function(e3, a3) {
          var n3 = e3.__data__;
          return t2(a3) ? n3["string" == typeof a3 ? "string" : "hash"] : n3.map;
        };
      }, 4061: (e2, a2, n2) => {
        var t2 = n2(5849), c = n2(6692);
        e2.exports = function(e3, a3) {
          var n3 = c(e3, a3);
          return t2(n3) ? n3 : void 0;
        };
      }, 3490: (e2, a2, n2) => {
        var t2 = n2(7887), c = Object.prototype, s = c.hasOwnProperty, o = c.toString, i = t2 ? t2.toStringTag : void 0;
        e2.exports = function(e3) {
          var a3 = s.call(e3, i), n3 = e3[i];
          try {
            e3[i] = void 0;
            var t3 = true;
          } catch (e4) {
          }
          var c2 = o.call(e3);
          return t3 && (a3 ? e3[i] = n3 : delete e3[i]), c2;
        };
      }, 6692: (e2) => {
        e2.exports = function(e3, a2) {
          return null == e3 ? void 0 : e3[a2];
        };
      }, 7554: (e2, a2, n2) => {
        var t2 = n2(290);
        e2.exports = function() {
          this.__data__ = t2 ? t2(null) : {}, this.size = 0;
        };
      }, 6772: (e2) => {
        e2.exports = function(e3) {
          var a2 = this.has(e3) && delete this.__data__[e3];
          return this.size -= a2 ? 1 : 0, a2;
        };
      }, 1616: (e2, a2, n2) => {
        var t2 = n2(290), c = Object.prototype.hasOwnProperty;
        e2.exports = function(e3) {
          var a3 = this.__data__;
          if (t2) {
            var n3 = a3[e3];
            return "__lodash_hash_undefined__" === n3 ? void 0 : n3;
          }
          return c.call(a3, e3) ? a3[e3] : void 0;
        };
      }, 8099: (e2, a2, n2) => {
        var t2 = n2(290), c = Object.prototype.hasOwnProperty;
        e2.exports = function(e3) {
          var a3 = this.__data__;
          return t2 ? void 0 !== a3[e3] : c.call(a3, e3);
        };
      }, 2673: (e2, a2, n2) => {
        var t2 = n2(290);
        e2.exports = function(e3, a3) {
          var n3 = this.__data__;
          return this.size += this.has(e3) ? 0 : 1, n3[e3] = t2 && void 0 === a3 ? "__lodash_hash_undefined__" : a3, this;
        };
      }, 4246: (e2) => {
        e2.exports = function(e3) {
          var a2 = typeof e3;
          return "string" == a2 || "number" == a2 || "symbol" == a2 || "boolean" == a2 ? "__proto__" !== e3 : null === e3;
        };
      }, 9650: (e2, a2, n2) => {
        var t2, c = n2(6832), s = (t2 = /[^.]+$/.exec(c && c.keys && c.keys.IE_PROTO || "")) ? "Symbol(src)_1." + t2 : "";
        e2.exports = function(e3) {
          return !!s && s in e3;
        };
      }, 5698: (e2) => {
        e2.exports = function() {
          this.__data__ = [], this.size = 0;
        };
      }, 7688: (e2, a2, n2) => {
        var t2 = n2(5285), c = Array.prototype.splice;
        e2.exports = function(e3) {
          var a3 = this.__data__, n3 = t2(a3, e3);
          return !(n3 < 0 || (n3 == a3.length - 1 ? a3.pop() : c.call(a3, n3, 1), --this.size, 0));
        };
      }, 2640: (e2, a2, n2) => {
        var t2 = n2(5285);
        e2.exports = function(e3) {
          var a3 = this.__data__, n3 = t2(a3, e3);
          return n3 < 0 ? void 0 : a3[n3][1];
        };
      }, 8406: (e2, a2, n2) => {
        var t2 = n2(5285);
        e2.exports = function(e3) {
          return t2(this.__data__, e3) > -1;
        };
      }, 2070: (e2, a2, n2) => {
        var t2 = n2(5285);
        e2.exports = function(e3, a3) {
          var n3 = this.__data__, c = t2(n3, e3);
          return c < 0 ? (++this.size, n3.push([e3, a3])) : n3[c][1] = a3, this;
        };
      }, 6807: (e2, a2, n2) => {
        var t2 = n2(4253), c = n2(9849), s = n2(6619);
        e2.exports = function() {
          this.size = 0, this.__data__ = { hash: new t2(), map: new (s || c)(), string: new t2() };
        };
      }, 2770: (e2, a2, n2) => {
        var t2 = n2(3291);
        e2.exports = function(e3) {
          var a3 = t2(this, e3).delete(e3);
          return this.size -= a3 ? 1 : 0, a3;
        };
      }, 893: (e2, a2, n2) => {
        var t2 = n2(3291);
        e2.exports = function(e3) {
          return t2(this, e3).get(e3);
        };
      }, 2461: (e2, a2, n2) => {
        var t2 = n2(3291);
        e2.exports = function(e3) {
          return t2(this, e3).has(e3);
        };
      }, 8476: (e2, a2, n2) => {
        var t2 = n2(3291);
        e2.exports = function(e3, a3) {
          var n3 = t2(this, e3), c = n3.size;
          return n3.set(e3, a3), this.size += n3.size == c ? 0 : 1, this;
        };
      }, 290: (e2, a2, n2) => {
        var t2 = n2(4061)(Object, "create");
        e2.exports = t2;
      }, 6275: (e2) => {
        var a2 = Object.prototype.toString;
        e2.exports = function(e3) {
          return a2.call(e3);
        };
      }, 5126: (e2, a2, n2) => {
        var t2 = n2(9876), c = "object" == typeof self && self && self.Object === Object && self, s = t2 || c || Function("return this")();
        e2.exports = s;
      }, 339: (e2) => {
        var a2 = Function.prototype.toString;
        e2.exports = function(e3) {
          if (null != e3) {
            try {
              return a2.call(e3);
            } catch (e4) {
            }
            try {
              return e3 + "";
            } catch (e4) {
            }
          }
          return "";
        };
      }, 2537: (e2) => {
        e2.exports = function(e3, a2) {
          return e3 === a2 || e3 != e3 && a2 != a2;
        };
      }, 316: (e2, a2, n2) => {
        var t2 = n2(5126).isFinite;
        e2.exports = function(e3) {
          return "number" == typeof e3 && t2(e3);
        };
      }, 8626: (e2, a2, n2) => {
        var t2 = n2(7030), c = n2(5600);
        e2.exports = function(e3) {
          if (!c(e3)) return false;
          var a3 = t2(e3);
          return "[object Function]" == a3 || "[object GeneratorFunction]" == a3 || "[object AsyncFunction]" == a3 || "[object Proxy]" == a3;
        };
      }, 5600: (e2) => {
        e2.exports = function(e3) {
          var a2 = typeof e3;
          return null != e3 && ("object" == a2 || "function" == a2);
        };
      }, 7097: (e2, a2, n2) => {
        var t2 = n2(9794);
        function c(e3, a3) {
          if ("function" != typeof e3 || null != a3 && "function" != typeof a3) throw new TypeError("Expected a function");
          var n3 = function() {
            var t3 = arguments, c2 = a3 ? a3.apply(this, t3) : t3[0], s = n3.cache;
            if (s.has(c2)) return s.get(c2);
            var o = e3.apply(this, t3);
            return n3.cache = s.set(c2, o) || s, o;
          };
          return n3.cache = new (c.Cache || t2)(), n3;
        }
        c.Cache = t2, e2.exports = c;
      }, 4764: (e2, a2, n2) => {
        (e2.exports = n2(2428)).tz.load(n2(1175));
      }, 6337: function(e2, a2, n2) {
        var t2, c, s;
        !(function(o, i) {
          "use strict";
          e2.exports ? e2.exports = i(n2(4764)) : (c = [n2(9034)], void 0 === (s = "function" == typeof (t2 = i) ? t2.apply(a2, c) : t2) || (e2.exports = s));
        })(0, (function(e3) {
          "use strict";
          if (!e3.tz) throw new Error("moment-timezone-utils.js must be loaded after moment-timezone.js");
          var a3 = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWX", n3 = 1e-6;
          function t3(e4, t4) {
            for (var c3 = "", s3 = Math.abs(e4), o2 = Math.floor(s3), i2 = (function(e5, t5) {
              for (var c4, s4 = ".", o3 = ""; t5 > 0; ) t5 -= 1, e5 *= 60, c4 = Math.floor(e5 + n3), s4 += a3[c4], e5 -= c4, c4 && (o3 += s4, s4 = "");
              return o3;
            })(s3 - o2, Math.min(~~t4, 10)); o2 > 0; ) c3 = a3[o2 % 60] + c3, o2 = Math.floor(o2 / 60);
            return e4 < 0 && (c3 = "-" + c3), c3 && i2 ? c3 + i2 : (i2 || "-" !== c3) && (c3 || i2) || "0";
          }
          function c2(e4) {
            var a4, n4 = [], c3 = 0;
            for (a4 = 0; a4 < e4.length - 1; a4++) n4[a4] = t3(Math.round((e4[a4] - c3) / 1e3) / 60, 1), c3 = e4[a4];
            return n4.join(" ");
          }
          function s2(e4) {
            var a4, n4, c3 = 0, s3 = [], o2 = [], i2 = [], r2 = {};
            for (a4 = 0; a4 < e4.abbrs.length; a4++) void 0 === r2[n4 = e4.abbrs[a4] + "|" + e4.offsets[a4]] && (r2[n4] = c3, s3[c3] = e4.abbrs[a4], o2[c3] = t3(Math.round(60 * e4.offsets[a4]) / 60, 1), c3++), i2[a4] = t3(r2[n4], 0);
            return s3.join(" ") + "|" + o2.join(" ") + "|" + i2.join("");
          }
          function o(e4) {
            if (!e4) return "";
            if (e4 < 1e3) return e4;
            var a4 = String(0 | e4).length - 2;
            return Math.round(e4 / Math.pow(10, a4)) + "e" + a4;
          }
          function i(e4) {
            return (function(e5) {
              if (!e5.name) throw new Error("Missing name");
              if (!e5.abbrs) throw new Error("Missing abbrs");
              if (!e5.untils) throw new Error("Missing untils");
              if (!e5.offsets) throw new Error("Missing offsets");
              if (e5.offsets.length !== e5.untils.length || e5.offsets.length !== e5.abbrs.length) throw new Error("Mismatched array lengths");
            })(e4), [e4.name, s2(e4), c2(e4.untils), o(e4.population)].join("|");
          }
          function r(e4) {
            return [e4.name, e4.zones.join(" ")].join("|");
          }
          function M(e4, a4) {
            var n4;
            if (e4.length !== a4.length) return false;
            for (n4 = 0; n4 < e4.length; n4++) if (e4[n4] !== a4[n4]) return false;
            return true;
          }
          function d(e4, a4) {
            return M(e4.offsets, a4.offsets) && M(e4.abbrs, a4.abbrs) && M(e4.untils, a4.untils);
          }
          function _(e4, a4) {
            var n4 = [], t4 = [];
            return e4.links && (t4 = e4.links.slice()), (function(e5, a5, n5, t5) {
              var c3, s3, o2, i2, r2, M2, _2 = [];
              for (c3 = 0; c3 < e5.length; c3++) {
                for (M2 = false, o2 = e5[c3], s3 = 0; s3 < _2.length; s3++) d(o2, i2 = (r2 = _2[s3])[0]) && (o2.population > i2.population || o2.population === i2.population && t5 && t5[o2.name] ? r2.unshift(o2) : r2.push(o2), M2 = true);
                M2 || _2.push([o2]);
              }
              for (c3 = 0; c3 < _2.length; c3++) for (r2 = _2[c3], a5.push(r2[0]), s3 = 1; s3 < r2.length; s3++) n5.push(r2[0].name + "|" + r2[s3].name);
            })(e4.zones, n4, t4, a4), { version: e4.version, zones: n4, links: t4.sort() };
          }
          function u(e4, a4, n4) {
            var t4 = Array.prototype.slice, c3 = (function(e5, a5, n5) {
              var t5, c4, s4 = 0, o2 = e5.length + 1;
              for (n5 || (n5 = a5), a5 > n5 && (c4 = a5, a5 = n5, n5 = c4), c4 = 0; c4 < e5.length; c4++) null != e5[c4] && ((t5 = new Date(e5[c4]).getUTCFullYear()) < a5 && (s4 = c4 + 1), t5 > n5 && (o2 = Math.min(o2, c4 + 1)));
              return [s4, o2];
            })(e4.untils, a4, n4), s3 = t4.apply(e4.untils, c3);
            return s3[s3.length - 1] = null, { name: e4.name, abbrs: t4.apply(e4.abbrs, c3), untils: s3, offsets: t4.apply(e4.offsets, c3), population: e4.population, countries: e4.countries };
          }
          return e3.tz.pack = i, e3.tz.packBase60 = t3, e3.tz.createLinks = _, e3.tz.filterYears = u, e3.tz.filterLinkPack = function(e4, a4, n4, t4) {
            var c3, s3, o2 = e4.zones, M2 = [];
            for (c3 = 0; c3 < o2.length; c3++) M2[c3] = u(o2[c3], a4, n4);
            for (s3 = _({ zones: M2, links: e4.links.slice(), version: e4.version }, t4), c3 = 0; c3 < s3.zones.length; c3++) s3.zones[c3] = i(s3.zones[c3]);
            return s3.countries = e4.countries ? e4.countries.map((function(e5) {
              return r(e5);
            })) : [], s3;
          }, e3.tz.packCountry = r, e3;
        }));
      }, 2428: function(e2, a2, n2) {
        var t2, c, s;
        !(function(o, i) {
          "use strict";
          e2.exports ? e2.exports = i(n2(9034)) : (c = [n2(9034)], void 0 === (s = "function" == typeof (t2 = i) ? t2.apply(a2, c) : t2) || (e2.exports = s));
        })(0, (function(e3) {
          "use strict";
          var a3, n3 = {}, t3 = {}, c2 = {}, s2 = {}, o = {};
          e3 && "string" == typeof e3.version || W("Moment Timezone requires Moment.js. See https://momentjs.com/timezone/docs/#/use-it/browser/");
          var i = e3.version.split("."), r = +i[0], M = +i[1];
          function d(e4) {
            return e4 > 96 ? e4 - 87 : e4 > 64 ? e4 - 29 : e4 - 48;
          }
          function _(e4) {
            var a4 = 0, n4 = e4.split("."), t4 = n4[0], c3 = n4[1] || "", s3 = 1, o2 = 0, i2 = 1;
            for (45 === e4.charCodeAt(0) && (a4 = 1, i2 = -1); a4 < t4.length; a4++) o2 = 60 * o2 + d(t4.charCodeAt(a4));
            for (a4 = 0; a4 < c3.length; a4++) s3 /= 60, o2 += d(c3.charCodeAt(a4)) * s3;
            return o2 * i2;
          }
          function u(e4) {
            for (var a4 = 0; a4 < e4.length; a4++) e4[a4] = _(e4[a4]);
          }
          function m(e4, a4) {
            var n4, t4 = [];
            for (n4 = 0; n4 < a4.length; n4++) t4[n4] = e4[a4[n4]];
            return t4;
          }
          function l(e4) {
            var a4 = e4.split("|"), n4 = a4[2].split(" "), t4 = a4[3].split(""), c3 = a4[4].split(" ");
            return u(n4), u(t4), u(c3), (function(e5, a5) {
              for (var n5 = 0; n5 < a5; n5++) e5[n5] = Math.round((e5[n5 - 1] || 0) + 6e4 * e5[n5]);
              e5[a5 - 1] = 1 / 0;
            })(c3, t4.length), { name: a4[0], abbrs: m(a4[1].split(" "), t4), offsets: m(n4, t4), untils: c3, population: 0 | a4[5] };
          }
          function p(e4) {
            e4 && this._set(l(e4));
          }
          function L(e4, a4) {
            this.name = e4, this.zones = a4;
          }
          function b(e4) {
            var a4 = e4.toTimeString(), n4 = a4.match(/\([a-z ]+\)/i);
            "GMT" === (n4 = n4 && n4[0] ? (n4 = n4[0].match(/[A-Z]/g)) ? n4.join("") : void 0 : (n4 = a4.match(/[A-Z]{3,5}/g)) ? n4[0] : void 0) && (n4 = void 0), this.at = +e4, this.abbr = n4, this.offset = e4.getTimezoneOffset();
          }
          function A(e4) {
            this.zone = e4, this.offsetScore = 0, this.abbrScore = 0;
          }
          function f(e4, a4) {
            for (var n4, t4; t4 = 6e4 * ((a4.at - e4.at) / 12e4 | 0); ) (n4 = new b(new Date(e4.at + t4))).offset === e4.offset ? e4 = n4 : a4 = n4;
            return e4;
          }
          function h(e4, a4) {
            return e4.offsetScore !== a4.offsetScore ? e4.offsetScore - a4.offsetScore : e4.abbrScore !== a4.abbrScore ? e4.abbrScore - a4.abbrScore : e4.zone.population !== a4.zone.population ? a4.zone.population - e4.zone.population : a4.zone.name.localeCompare(e4.zone.name);
          }
          function z(e4, a4) {
            var n4, t4;
            for (u(a4), n4 = 0; n4 < a4.length; n4++) t4 = a4[n4], o[t4] = o[t4] || {}, o[t4][e4] = true;
          }
          function Y(e4) {
            var a4, n4, t4, c3 = e4.length, i2 = {}, r2 = [];
            for (a4 = 0; a4 < c3; a4++) for (n4 in t4 = o[e4[a4].offset] || {}) t4.hasOwnProperty(n4) && (i2[n4] = true);
            for (a4 in i2) i2.hasOwnProperty(a4) && r2.push(s2[a4]);
            return r2;
          }
          function y(e4) {
            return (e4 || "").toLowerCase().replace(/\//g, "_");
          }
          function T(e4) {
            var a4, t4, c3, o2;
            for ("string" == typeof e4 && (e4 = [e4]), a4 = 0; a4 < e4.length; a4++) o2 = y(t4 = (c3 = e4[a4].split("|"))[0]), n3[o2] = e4[a4], s2[o2] = t4, z(o2, c3[2].split(" "));
          }
          function O(e4, a4) {
            e4 = y(e4);
            var c3, o2 = n3[e4];
            return o2 instanceof p ? o2 : "string" == typeof o2 ? (o2 = new p(o2), n3[e4] = o2, o2) : t3[e4] && a4 !== O && (c3 = O(t3[e4], O)) ? ((o2 = n3[e4] = new p())._set(c3), o2.name = s2[e4], o2) : null;
          }
          function D(e4) {
            var a4, n4, c3, o2;
            for ("string" == typeof e4 && (e4 = [e4]), a4 = 0; a4 < e4.length; a4++) c3 = y((n4 = e4[a4].split("|"))[0]), o2 = y(n4[1]), t3[c3] = o2, s2[c3] = n4[0], t3[o2] = c3, s2[o2] = n4[1];
          }
          function k(e4) {
            var a4 = "X" === e4._f || "x" === e4._f;
            return !(!e4._a || void 0 !== e4._tzm || a4);
          }
          function W(e4) {
            "undefined" != typeof console && "function" == typeof console.error && console.error(e4);
          }
          function g(a4) {
            var n4 = Array.prototype.slice.call(arguments, 0, -1), t4 = arguments[arguments.length - 1], c3 = O(t4), s3 = e3.utc.apply(null, n4);
            return c3 && !e3.isMoment(a4) && k(s3) && s3.add(c3.parse(s3), "minutes"), s3.tz(t4), s3;
          }
          (r < 2 || 2 === r && M < 6) && W("Moment Timezone requires Moment.js >= 2.6.0. You are using Moment.js " + e3.version + ". See momentjs.com"), p.prototype = { _set: function(e4) {
            this.name = e4.name, this.abbrs = e4.abbrs, this.untils = e4.untils, this.offsets = e4.offsets, this.population = e4.population;
          }, _index: function(e4) {
            var a4, n4 = +e4, t4 = this.untils;
            for (a4 = 0; a4 < t4.length; a4++) if (n4 < t4[a4]) return a4;
          }, countries: function() {
            var e4 = this.name;
            return Object.keys(c2).filter((function(a4) {
              return -1 !== c2[a4].zones.indexOf(e4);
            }));
          }, parse: function(e4) {
            var a4, n4, t4, c3, s3 = +e4, o2 = this.offsets, i2 = this.untils, r2 = i2.length - 1;
            for (c3 = 0; c3 < r2; c3++) if (a4 = o2[c3], n4 = o2[c3 + 1], t4 = o2[c3 ? c3 - 1 : c3], a4 < n4 && g.moveAmbiguousForward ? a4 = n4 : a4 > t4 && g.moveInvalidForward && (a4 = t4), s3 < i2[c3] - 6e4 * a4) return o2[c3];
            return o2[r2];
          }, abbr: function(e4) {
            return this.abbrs[this._index(e4)];
          }, offset: function(e4) {
            return W("zone.offset has been deprecated in favor of zone.utcOffset"), this.offsets[this._index(e4)];
          }, utcOffset: function(e4) {
            return this.offsets[this._index(e4)];
          } }, A.prototype.scoreOffsetAt = function(e4) {
            this.offsetScore += Math.abs(this.zone.utcOffset(e4.at) - e4.offset), this.zone.abbr(e4.at).replace(/[^A-Z]/g, "") !== e4.abbr && this.abbrScore++;
          }, g.version = "0.5.28", g.dataVersion = "", g._zones = n3, g._links = t3, g._names = s2, g._countries = c2, g.add = T, g.link = D, g.load = function(e4) {
            T(e4.zones), D(e4.links), (function(e5) {
              var a4, n4, t4, s3;
              if (e5 && e5.length) for (a4 = 0; a4 < e5.length; a4++) n4 = (s3 = e5[a4].split("|"))[0].toUpperCase(), t4 = s3[1].split(" "), c2[n4] = new L(n4, t4);
            })(e4.countries), g.dataVersion = e4.version;
          }, g.zone = O, g.zoneExists = function e4(a4) {
            return e4.didShowError || (e4.didShowError = true, W("moment.tz.zoneExists('" + a4 + "') has been deprecated in favor of !moment.tz.zone('" + a4 + "')")), !!O(a4);
          }, g.guess = function(e4) {
            return a3 && !e4 || (a3 = (function() {
              try {
                var e5 = Intl.DateTimeFormat().resolvedOptions().timeZone;
                if (e5 && e5.length > 3) {
                  var a4 = s2[y(e5)];
                  if (a4) return a4;
                  W("Moment Timezone found " + e5 + " from the Intl api, but did not have that data loaded.");
                }
              } catch (e6) {
              }
              var n4, t4, c3, o2 = (function() {
                var e6, a5, n5, t5 = (/* @__PURE__ */ new Date()).getFullYear() - 2, c4 = new b(new Date(t5, 0, 1)), s3 = [c4];
                for (n5 = 1; n5 < 48; n5++) (a5 = new b(new Date(t5, n5, 1))).offset !== c4.offset && (e6 = f(c4, a5), s3.push(e6), s3.push(new b(new Date(e6.at + 6e4)))), c4 = a5;
                for (n5 = 0; n5 < 4; n5++) s3.push(new b(new Date(t5 + n5, 0, 1))), s3.push(new b(new Date(t5 + n5, 6, 1)));
                return s3;
              })(), i2 = o2.length, r2 = Y(o2), M2 = [];
              for (t4 = 0; t4 < r2.length; t4++) {
                for (n4 = new A(O(r2[t4]), i2), c3 = 0; c3 < i2; c3++) n4.scoreOffsetAt(o2[c3]);
                M2.push(n4);
              }
              return M2.sort(h), M2.length > 0 ? M2[0].zone.name : void 0;
            })()), a3;
          }, g.names = function() {
            var e4, a4 = [];
            for (e4 in s2) s2.hasOwnProperty(e4) && (n3[e4] || n3[t3[e4]]) && s2[e4] && a4.push(s2[e4]);
            return a4.sort();
          }, g.Zone = p, g.unpack = l, g.unpackBase60 = _, g.needsOffset = k, g.moveInvalidForward = true, g.moveAmbiguousForward = false, g.countries = function() {
            return Object.keys(c2);
          }, g.zonesForCountry = function(e4, a4) {
            var n4;
            if (n4 = (n4 = e4).toUpperCase(), !(e4 = c2[n4] || null)) return null;
            var t4 = e4.zones.sort();
            return a4 ? t4.map((function(e5) {
              return { name: e5, offset: O(e5).utcOffset(/* @__PURE__ */ new Date()) };
            })) : t4;
          };
          var N, q = e3.fn;
          function S(e4) {
            return function() {
              return this._z ? this._z.abbr(this) : e4.call(this);
            };
          }
          function w(e4) {
            return function() {
              return this._z = null, e4.apply(this, arguments);
            };
          }
          e3.tz = g, e3.defaultZone = null, e3.updateOffset = function(a4, n4) {
            var t4, c3 = e3.defaultZone;
            if (void 0 === a4._z && (c3 && k(a4) && !a4._isUTC && (a4._d = e3.utc(a4._a)._d, a4.utc().add(c3.parse(a4), "minutes")), a4._z = c3), a4._z) if (t4 = a4._z.utcOffset(a4), Math.abs(t4) < 16 && (t4 /= 60), void 0 !== a4.utcOffset) {
              var s3 = a4._z;
              a4.utcOffset(-t4, n4), a4._z = s3;
            } else a4.zone(t4, n4);
          }, q.tz = function(a4, n4) {
            if (a4) {
              if ("string" != typeof a4) throw new Error("Time zone name must be a string, got " + a4 + " [" + typeof a4 + "]");
              return this._z = O(a4), this._z ? e3.updateOffset(this, n4) : W("Moment Timezone has no data for " + a4 + ". See http://momentjs.com/timezone/docs/#/data-loading/."), this;
            }
            if (this._z) return this._z.name;
          }, q.zoneName = S(q.zoneName), q.zoneAbbr = S(q.zoneAbbr), q.utc = w(q.utc), q.local = w(q.local), q.utcOffset = (N = q.utcOffset, function() {
            return arguments.length > 0 && (this._z = null), N.apply(this, arguments);
          }), e3.tz.setDefault = function(a4) {
            return (r < 2 || 2 === r && M < 9) && W("Moment Timezone setDefault() requires Moment.js >= 2.9.0. You are using Moment.js " + e3.version + "."), e3.defaultZone = a4 ? O(a4) : null, e3;
          };
          var v = e3.momentProperties;
          return "[object Array]" === Object.prototype.toString.call(v) ? (v.push("_z"), v.push("_a")) : v && (v._z = null), e3;
        }));
      }, 5191: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          e3.defineLocale("af", { months: "Januarie_Februarie_Maart_April_Mei_Junie_Julie_Augustus_September_Oktober_November_Desember".split("_"), monthsShort: "Jan_Feb_Mrt_Apr_Mei_Jun_Jul_Aug_Sep_Okt_Nov_Des".split("_"), weekdays: "Sondag_Maandag_Dinsdag_Woensdag_Donderdag_Vrydag_Saterdag".split("_"), weekdaysShort: "Son_Maa_Din_Woe_Don_Vry_Sat".split("_"), weekdaysMin: "So_Ma_Di_Wo_Do_Vr_Sa".split("_"), meridiemParse: /vm|nm/i, isPM: function(e4) {
            return /^nm$/i.test(e4);
          }, meridiem: function(e4, a3, n3) {
            return e4 < 12 ? n3 ? "vm" : "VM" : n3 ? "nm" : "NM";
          }, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" }, calendar: { sameDay: "[Vandag om] LT", nextDay: "[Môre om] LT", nextWeek: "dddd [om] LT", lastDay: "[Gister om] LT", lastWeek: "[Laas] dddd [om] LT", sameElse: "L" }, relativeTime: { future: "oor %s", past: "%s gelede", s: "'n paar sekondes", ss: "%d sekondes", m: "'n minuut", mm: "%d minute", h: "'n uur", hh: "%d ure", d: "'n dag", dd: "%d dae", M: "'n maand", MM: "%d maande", y: "'n jaar", yy: "%d jaar" }, dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/, ordinal: function(e4) {
            return e4 + (1 === e4 || 8 === e4 || e4 >= 20 ? "ste" : "de");
          }, week: { dow: 1, doy: 4 } });
        })(n2(9034));
      }, 1727: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          var a3 = function(e4) {
            return 0 === e4 ? 0 : 1 === e4 ? 1 : 2 === e4 ? 2 : e4 % 100 >= 3 && e4 % 100 <= 10 ? 3 : e4 % 100 >= 11 ? 4 : 5;
          }, n3 = { s: ["أقل من ثانية", "ثانية واحدة", ["ثانيتان", "ثانيتين"], "%d ثوان", "%d ثانية", "%d ثانية"], m: ["أقل من دقيقة", "دقيقة واحدة", ["دقيقتان", "دقيقتين"], "%d دقائق", "%d دقيقة", "%d دقيقة"], h: ["أقل من ساعة", "ساعة واحدة", ["ساعتان", "ساعتين"], "%d ساعات", "%d ساعة", "%d ساعة"], d: ["أقل من يوم", "يوم واحد", ["يومان", "يومين"], "%d أيام", "%d يومًا", "%d يوم"], M: ["أقل من شهر", "شهر واحد", ["شهران", "شهرين"], "%d أشهر", "%d شهرا", "%d شهر"], y: ["أقل من عام", "عام واحد", ["عامان", "عامين"], "%d أعوام", "%d عامًا", "%d عام"] }, t2 = function(e4) {
            return function(t3, c2, s, o) {
              var i = a3(t3), r = n3[e4][a3(t3)];
              return 2 === i && (r = r[c2 ? 0 : 1]), r.replace(/%d/i, t3);
            };
          }, c = ["جانفي", "فيفري", "مارس", "أفريل", "ماي", "جوان", "جويلية", "أوت", "سبتمبر", "أكتوبر", "نوفمبر", "ديسمبر"];
          e3.defineLocale("ar-dz", { months: c, monthsShort: c, weekdays: "الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت".split("_"), weekdaysShort: "أحد_إثنين_ثلاثاء_أربعاء_خميس_جمعة_سبت".split("_"), weekdaysMin: "ح_ن_ث_ر_خ_ج_س".split("_"), weekdaysParseExact: true, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "D/‏M/‏YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D MMMM YYYY HH:mm" }, meridiemParse: /ص|م/, isPM: function(e4) {
            return "م" === e4;
          }, meridiem: function(e4, a4, n4) {
            return e4 < 12 ? "ص" : "م";
          }, calendar: { sameDay: "[اليوم عند الساعة] LT", nextDay: "[غدًا عند الساعة] LT", nextWeek: "dddd [عند الساعة] LT", lastDay: "[أمس عند الساعة] LT", lastWeek: "dddd [عند الساعة] LT", sameElse: "L" }, relativeTime: { future: "بعد %s", past: "منذ %s", s: t2("s"), ss: t2("s"), m: t2("m"), mm: t2("m"), h: t2("h"), hh: t2("h"), d: t2("d"), dd: t2("d"), M: t2("M"), MM: t2("M"), y: t2("y"), yy: t2("y") }, postformat: function(e4) {
            return e4.replace(/,/g, "،");
          }, week: { dow: 0, doy: 4 } });
        })(n2(9034));
      }, 8279: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          e3.defineLocale("ar-kw", { months: "يناير_فبراير_مارس_أبريل_ماي_يونيو_يوليوز_غشت_شتنبر_أكتوبر_نونبر_دجنبر".split("_"), monthsShort: "يناير_فبراير_مارس_أبريل_ماي_يونيو_يوليوز_غشت_شتنبر_أكتوبر_نونبر_دجنبر".split("_"), weekdays: "الأحد_الإتنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت".split("_"), weekdaysShort: "احد_اتنين_ثلاثاء_اربعاء_خميس_جمعة_سبت".split("_"), weekdaysMin: "ح_ن_ث_ر_خ_ج_س".split("_"), weekdaysParseExact: true, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D MMMM YYYY HH:mm" }, calendar: { sameDay: "[اليوم على الساعة] LT", nextDay: "[غدا على الساعة] LT", nextWeek: "dddd [على الساعة] LT", lastDay: "[أمس على الساعة] LT", lastWeek: "dddd [على الساعة] LT", sameElse: "L" }, relativeTime: { future: "في %s", past: "منذ %s", s: "ثوان", ss: "%d ثانية", m: "دقيقة", mm: "%d دقائق", h: "ساعة", hh: "%d ساعات", d: "يوم", dd: "%d أيام", M: "شهر", MM: "%d أشهر", y: "سنة", yy: "%d سنوات" }, week: { dow: 0, doy: 12 } });
        })(n2(9034));
      }, 7895: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          var a3 = { 1: "1", 2: "2", 3: "3", 4: "4", 5: "5", 6: "6", 7: "7", 8: "8", 9: "9", 0: "0" }, n3 = function(e4) {
            return 0 === e4 ? 0 : 1 === e4 ? 1 : 2 === e4 ? 2 : e4 % 100 >= 3 && e4 % 100 <= 10 ? 3 : e4 % 100 >= 11 ? 4 : 5;
          }, t2 = { s: ["أقل من ثانية", "ثانية واحدة", ["ثانيتان", "ثانيتين"], "%d ثوان", "%d ثانية", "%d ثانية"], m: ["أقل من دقيقة", "دقيقة واحدة", ["دقيقتان", "دقيقتين"], "%d دقائق", "%d دقيقة", "%d دقيقة"], h: ["أقل من ساعة", "ساعة واحدة", ["ساعتان", "ساعتين"], "%d ساعات", "%d ساعة", "%d ساعة"], d: ["أقل من يوم", "يوم واحد", ["يومان", "يومين"], "%d أيام", "%d يومًا", "%d يوم"], M: ["أقل من شهر", "شهر واحد", ["شهران", "شهرين"], "%d أشهر", "%d شهرا", "%d شهر"], y: ["أقل من عام", "عام واحد", ["عامان", "عامين"], "%d أعوام", "%d عامًا", "%d عام"] }, c = function(e4) {
            return function(a4, c2, s2, o) {
              var i = n3(a4), r = t2[e4][n3(a4)];
              return 2 === i && (r = r[c2 ? 0 : 1]), r.replace(/%d/i, a4);
            };
          }, s = ["يناير", "فبراير", "مارس", "أبريل", "مايو", "يونيو", "يوليو", "أغسطس", "سبتمبر", "أكتوبر", "نوفمبر", "ديسمبر"];
          e3.defineLocale("ar-ly", { months: s, monthsShort: s, weekdays: "الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت".split("_"), weekdaysShort: "أحد_إثنين_ثلاثاء_أربعاء_خميس_جمعة_سبت".split("_"), weekdaysMin: "ح_ن_ث_ر_خ_ج_س".split("_"), weekdaysParseExact: true, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "D/‏M/‏YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D MMMM YYYY HH:mm" }, meridiemParse: /ص|م/, isPM: function(e4) {
            return "م" === e4;
          }, meridiem: function(e4, a4, n4) {
            return e4 < 12 ? "ص" : "م";
          }, calendar: { sameDay: "[اليوم عند الساعة] LT", nextDay: "[غدًا عند الساعة] LT", nextWeek: "dddd [عند الساعة] LT", lastDay: "[أمس عند الساعة] LT", lastWeek: "dddd [عند الساعة] LT", sameElse: "L" }, relativeTime: { future: "بعد %s", past: "منذ %s", s: c("s"), ss: c("s"), m: c("m"), mm: c("m"), h: c("h"), hh: c("h"), d: c("d"), dd: c("d"), M: c("M"), MM: c("M"), y: c("y"), yy: c("y") }, preparse: function(e4) {
            return e4.replace(/،/g, ",");
          }, postformat: function(e4) {
            return e4.replace(/\d/g, (function(e5) {
              return a3[e5];
            })).replace(/,/g, "،");
          }, week: { dow: 6, doy: 12 } });
        })(n2(9034));
      }, 1987: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          e3.defineLocale("ar-ma", { months: "يناير_فبراير_مارس_أبريل_ماي_يونيو_يوليوز_غشت_شتنبر_أكتوبر_نونبر_دجنبر".split("_"), monthsShort: "يناير_فبراير_مارس_أبريل_ماي_يونيو_يوليوز_غشت_شتنبر_أكتوبر_نونبر_دجنبر".split("_"), weekdays: "الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت".split("_"), weekdaysShort: "احد_اثنين_ثلاثاء_اربعاء_خميس_جمعة_سبت".split("_"), weekdaysMin: "ح_ن_ث_ر_خ_ج_س".split("_"), weekdaysParseExact: true, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D MMMM YYYY HH:mm" }, calendar: { sameDay: "[اليوم على الساعة] LT", nextDay: "[غدا على الساعة] LT", nextWeek: "dddd [على الساعة] LT", lastDay: "[أمس على الساعة] LT", lastWeek: "dddd [على الساعة] LT", sameElse: "L" }, relativeTime: { future: "في %s", past: "منذ %s", s: "ثوان", ss: "%d ثانية", m: "دقيقة", mm: "%d دقائق", h: "ساعة", hh: "%d ساعات", d: "يوم", dd: "%d أيام", M: "شهر", MM: "%d أشهر", y: "سنة", yy: "%d سنوات" }, week: { dow: 1, doy: 4 } });
        })(n2(9034));
      }, 2796: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          var a3 = { 1: "١", 2: "٢", 3: "٣", 4: "٤", 5: "٥", 6: "٦", 7: "٧", 8: "٨", 9: "٩", 0: "٠" }, n3 = { "١": "1", "٢": "2", "٣": "3", "٤": "4", "٥": "5", "٦": "6", "٧": "7", "٨": "8", "٩": "9", "٠": "0" };
          e3.defineLocale("ar-sa", { months: "يناير_فبراير_مارس_أبريل_مايو_يونيو_يوليو_أغسطس_سبتمبر_أكتوبر_نوفمبر_ديسمبر".split("_"), monthsShort: "يناير_فبراير_مارس_أبريل_مايو_يونيو_يوليو_أغسطس_سبتمبر_أكتوبر_نوفمبر_ديسمبر".split("_"), weekdays: "الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت".split("_"), weekdaysShort: "أحد_إثنين_ثلاثاء_أربعاء_خميس_جمعة_سبت".split("_"), weekdaysMin: "ح_ن_ث_ر_خ_ج_س".split("_"), weekdaysParseExact: true, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D MMMM YYYY HH:mm" }, meridiemParse: /ص|م/, isPM: function(e4) {
            return "م" === e4;
          }, meridiem: function(e4, a4, n4) {
            return e4 < 12 ? "ص" : "م";
          }, calendar: { sameDay: "[اليوم على الساعة] LT", nextDay: "[غدا على الساعة] LT", nextWeek: "dddd [على الساعة] LT", lastDay: "[أمس على الساعة] LT", lastWeek: "dddd [على الساعة] LT", sameElse: "L" }, relativeTime: { future: "في %s", past: "منذ %s", s: "ثوان", ss: "%d ثانية", m: "دقيقة", mm: "%d دقائق", h: "ساعة", hh: "%d ساعات", d: "يوم", dd: "%d أيام", M: "شهر", MM: "%d أشهر", y: "سنة", yy: "%d سنوات" }, preparse: function(e4) {
            return e4.replace(/[١٢٣٤٥٦٧٨٩٠]/g, (function(e5) {
              return n3[e5];
            })).replace(/،/g, ",");
          }, postformat: function(e4) {
            return e4.replace(/\d/g, (function(e5) {
              return a3[e5];
            })).replace(/,/g, "،");
          }, week: { dow: 0, doy: 6 } });
        })(n2(9034));
      }, 2386: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          e3.defineLocale("ar-tn", { months: "جانفي_فيفري_مارس_أفريل_ماي_جوان_جويلية_أوت_سبتمبر_أكتوبر_نوفمبر_ديسمبر".split("_"), monthsShort: "جانفي_فيفري_مارس_أفريل_ماي_جوان_جويلية_أوت_سبتمبر_أكتوبر_نوفمبر_ديسمبر".split("_"), weekdays: "الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت".split("_"), weekdaysShort: "أحد_إثنين_ثلاثاء_أربعاء_خميس_جمعة_سبت".split("_"), weekdaysMin: "ح_ن_ث_ر_خ_ج_س".split("_"), weekdaysParseExact: true, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D MMMM YYYY HH:mm" }, calendar: { sameDay: "[اليوم على الساعة] LT", nextDay: "[غدا على الساعة] LT", nextWeek: "dddd [على الساعة] LT", lastDay: "[أمس على الساعة] LT", lastWeek: "dddd [على الساعة] LT", sameElse: "L" }, relativeTime: { future: "في %s", past: "منذ %s", s: "ثوان", ss: "%d ثانية", m: "دقيقة", mm: "%d دقائق", h: "ساعة", hh: "%d ساعات", d: "يوم", dd: "%d أيام", M: "شهر", MM: "%d أشهر", y: "سنة", yy: "%d سنوات" }, week: { dow: 1, doy: 4 } });
        })(n2(9034));
      }, 4358: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          var a3 = { 1: "١", 2: "٢", 3: "٣", 4: "٤", 5: "٥", 6: "٦", 7: "٧", 8: "٨", 9: "٩", 0: "٠" }, n3 = { "١": "1", "٢": "2", "٣": "3", "٤": "4", "٥": "5", "٦": "6", "٧": "7", "٨": "8", "٩": "9", "٠": "0" }, t2 = function(e4) {
            return 0 === e4 ? 0 : 1 === e4 ? 1 : 2 === e4 ? 2 : e4 % 100 >= 3 && e4 % 100 <= 10 ? 3 : e4 % 100 >= 11 ? 4 : 5;
          }, c = { s: ["أقل من ثانية", "ثانية واحدة", ["ثانيتان", "ثانيتين"], "%d ثوان", "%d ثانية", "%d ثانية"], m: ["أقل من دقيقة", "دقيقة واحدة", ["دقيقتان", "دقيقتين"], "%d دقائق", "%d دقيقة", "%d دقيقة"], h: ["أقل من ساعة", "ساعة واحدة", ["ساعتان", "ساعتين"], "%d ساعات", "%d ساعة", "%d ساعة"], d: ["أقل من يوم", "يوم واحد", ["يومان", "يومين"], "%d أيام", "%d يومًا", "%d يوم"], M: ["أقل من شهر", "شهر واحد", ["شهران", "شهرين"], "%d أشهر", "%d شهرا", "%d شهر"], y: ["أقل من عام", "عام واحد", ["عامان", "عامين"], "%d أعوام", "%d عامًا", "%d عام"] }, s = function(e4) {
            return function(a4, n4, s2, o2) {
              var i = t2(a4), r = c[e4][t2(a4)];
              return 2 === i && (r = r[n4 ? 0 : 1]), r.replace(/%d/i, a4);
            };
          }, o = ["يناير", "فبراير", "مارس", "أبريل", "مايو", "يونيو", "يوليو", "أغسطس", "سبتمبر", "أكتوبر", "نوفمبر", "ديسمبر"];
          e3.defineLocale("ar", { months: o, monthsShort: o, weekdays: "الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت".split("_"), weekdaysShort: "أحد_إثنين_ثلاثاء_أربعاء_خميس_جمعة_سبت".split("_"), weekdaysMin: "ح_ن_ث_ر_خ_ج_س".split("_"), weekdaysParseExact: true, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "D/‏M/‏YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D MMMM YYYY HH:mm" }, meridiemParse: /ص|م/, isPM: function(e4) {
            return "م" === e4;
          }, meridiem: function(e4, a4, n4) {
            return e4 < 12 ? "ص" : "م";
          }, calendar: { sameDay: "[اليوم عند الساعة] LT", nextDay: "[غدًا عند الساعة] LT", nextWeek: "dddd [عند الساعة] LT", lastDay: "[أمس عند الساعة] LT", lastWeek: "dddd [عند الساعة] LT", sameElse: "L" }, relativeTime: { future: "بعد %s", past: "منذ %s", s: s("s"), ss: s("s"), m: s("m"), mm: s("m"), h: s("h"), hh: s("h"), d: s("d"), dd: s("d"), M: s("M"), MM: s("M"), y: s("y"), yy: s("y") }, preparse: function(e4) {
            return e4.replace(/[١٢٣٤٥٦٧٨٩٠]/g, (function(e5) {
              return n3[e5];
            })).replace(/،/g, ",");
          }, postformat: function(e4) {
            return e4.replace(/\d/g, (function(e5) {
              return a3[e5];
            })).replace(/,/g, "،");
          }, week: { dow: 6, doy: 12 } });
        })(n2(9034));
      }, 7452: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          var a3 = { 1: "-inci", 5: "-inci", 8: "-inci", 70: "-inci", 80: "-inci", 2: "-nci", 7: "-nci", 20: "-nci", 50: "-nci", 3: "-üncü", 4: "-üncü", 100: "-üncü", 6: "-ncı", 9: "-uncu", 10: "-uncu", 30: "-uncu", 60: "-ıncı", 90: "-ıncı" };
          e3.defineLocale("az", { months: "yanvar_fevral_mart_aprel_may_iyun_iyul_avqust_sentyabr_oktyabr_noyabr_dekabr".split("_"), monthsShort: "yan_fev_mar_apr_may_iyn_iyl_avq_sen_okt_noy_dek".split("_"), weekdays: "Bazar_Bazar ertəsi_Çərşənbə axşamı_Çərşənbə_Cümə axşamı_Cümə_Şənbə".split("_"), weekdaysShort: "Baz_BzE_ÇAx_Çər_CAx_Cüm_Şən".split("_"), weekdaysMin: "Bz_BE_ÇA_Çə_CA_Cü_Şə".split("_"), weekdaysParseExact: true, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD.MM.YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" }, calendar: { sameDay: "[bugün saat] LT", nextDay: "[sabah saat] LT", nextWeek: "[gələn həftə] dddd [saat] LT", lastDay: "[dünən] LT", lastWeek: "[keçən həftə] dddd [saat] LT", sameElse: "L" }, relativeTime: { future: "%s sonra", past: "%s əvvəl", s: "bir neçə saniyə", ss: "%d saniyə", m: "bir dəqiqə", mm: "%d dəqiqə", h: "bir saat", hh: "%d saat", d: "bir gün", dd: "%d gün", M: "bir ay", MM: "%d ay", y: "bir il", yy: "%d il" }, meridiemParse: /gecə|səhər|gündüz|axşam/, isPM: function(e4) {
            return /^(gündüz|axşam)$/.test(e4);
          }, meridiem: function(e4, a4, n3) {
            return e4 < 4 ? "gecə" : e4 < 12 ? "səhər" : e4 < 17 ? "gündüz" : "axşam";
          }, dayOfMonthOrdinalParse: /\d{1,2}-(ıncı|inci|nci|üncü|ncı|uncu)/, ordinal: function(e4) {
            if (0 === e4) return e4 + "-ıncı";
            var n3 = e4 % 10;
            return e4 + (a3[n3] || a3[e4 % 100 - n3] || a3[e4 >= 100 ? 100 : null]);
          }, week: { dow: 1, doy: 7 } });
        })(n2(9034));
      }, 9053: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          function a3(e4, a4, n3) {
            return "m" === n3 ? a4 ? "хвіліна" : "хвіліну" : "h" === n3 ? a4 ? "гадзіна" : "гадзіну" : e4 + " " + (t2 = +e4, c = { ss: a4 ? "секунда_секунды_секунд" : "секунду_секунды_секунд", mm: a4 ? "хвіліна_хвіліны_хвілін" : "хвіліну_хвіліны_хвілін", hh: a4 ? "гадзіна_гадзіны_гадзін" : "гадзіну_гадзіны_гадзін", dd: "дзень_дні_дзён", MM: "месяц_месяцы_месяцаў", yy: "год_гады_гадоў" }[n3].split("_"), t2 % 10 == 1 && t2 % 100 != 11 ? c[0] : t2 % 10 >= 2 && t2 % 10 <= 4 && (t2 % 100 < 10 || t2 % 100 >= 20) ? c[1] : c[2]);
            var t2, c;
          }
          e3.defineLocale("be", { months: { format: "студзеня_лютага_сакавіка_красавіка_траўня_чэрвеня_ліпеня_жніўня_верасня_кастрычніка_лістапада_снежня".split("_"), standalone: "студзень_люты_сакавік_красавік_травень_чэрвень_ліпень_жнівень_верасень_кастрычнік_лістапад_снежань".split("_") }, monthsShort: "студ_лют_сак_крас_трав_чэрв_ліп_жнів_вер_каст_ліст_снеж".split("_"), weekdays: { format: "нядзелю_панядзелак_аўторак_сераду_чацвер_пятніцу_суботу".split("_"), standalone: "нядзеля_панядзелак_аўторак_серада_чацвер_пятніца_субота".split("_"), isFormat: /\[ ?[Ууў] ?(?:мінулую|наступную)? ?\] ?dddd/ }, weekdaysShort: "нд_пн_ат_ср_чц_пт_сб".split("_"), weekdaysMin: "нд_пн_ат_ср_чц_пт_сб".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD.MM.YYYY", LL: "D MMMM YYYY г.", LLL: "D MMMM YYYY г., HH:mm", LLLL: "dddd, D MMMM YYYY г., HH:mm" }, calendar: { sameDay: "[Сёння ў] LT", nextDay: "[Заўтра ў] LT", lastDay: "[Учора ў] LT", nextWeek: function() {
            return "[У] dddd [ў] LT";
          }, lastWeek: function() {
            switch (this.day()) {
              case 0:
              case 3:
              case 5:
              case 6:
                return "[У мінулую] dddd [ў] LT";
              case 1:
              case 2:
              case 4:
                return "[У мінулы] dddd [ў] LT";
            }
          }, sameElse: "L" }, relativeTime: { future: "праз %s", past: "%s таму", s: "некалькі секунд", m: a3, mm: a3, h: a3, hh: a3, d: "дзень", dd: a3, M: "месяц", MM: a3, y: "год", yy: a3 }, meridiemParse: /ночы|раніцы|дня|вечара/, isPM: function(e4) {
            return /^(дня|вечара)$/.test(e4);
          }, meridiem: function(e4, a4, n3) {
            return e4 < 4 ? "ночы" : e4 < 12 ? "раніцы" : e4 < 17 ? "дня" : "вечара";
          }, dayOfMonthOrdinalParse: /\d{1,2}-(і|ы|га)/, ordinal: function(e4, a4) {
            switch (a4) {
              case "M":
              case "d":
              case "DDD":
              case "w":
              case "W":
                return e4 % 10 != 2 && e4 % 10 != 3 || e4 % 100 == 12 || e4 % 100 == 13 ? e4 + "-ы" : e4 + "-і";
              case "D":
                return e4 + "-га";
              default:
                return e4;
            }
          }, week: { dow: 1, doy: 7 } });
        })(n2(9034));
      }, 5428: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          e3.defineLocale("bg", { months: "януари_февруари_март_април_май_юни_юли_август_септември_октомври_ноември_декември".split("_"), monthsShort: "яну_фев_мар_апр_май_юни_юли_авг_сеп_окт_ное_дек".split("_"), weekdays: "неделя_понеделник_вторник_сряда_четвъртък_петък_събота".split("_"), weekdaysShort: "нед_пон_вто_сря_чет_пет_съб".split("_"), weekdaysMin: "нд_пн_вт_ср_чт_пт_сб".split("_"), longDateFormat: { LT: "H:mm", LTS: "H:mm:ss", L: "D.MM.YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY H:mm", LLLL: "dddd, D MMMM YYYY H:mm" }, calendar: { sameDay: "[Днес в] LT", nextDay: "[Утре в] LT", nextWeek: "dddd [в] LT", lastDay: "[Вчера в] LT", lastWeek: function() {
            switch (this.day()) {
              case 0:
              case 3:
              case 6:
                return "[Миналата] dddd [в] LT";
              case 1:
              case 2:
              case 4:
              case 5:
                return "[Миналия] dddd [в] LT";
            }
          }, sameElse: "L" }, relativeTime: { future: "след %s", past: "преди %s", s: "няколко секунди", ss: "%d секунди", m: "минута", mm: "%d минути", h: "час", hh: "%d часа", d: "ден", dd: "%d дена", w: "седмица", ww: "%d седмици", M: "месец", MM: "%d месеца", y: "година", yy: "%d години" }, dayOfMonthOrdinalParse: /\d{1,2}-(ев|ен|ти|ви|ри|ми)/, ordinal: function(e4) {
            var a3 = e4 % 10, n3 = e4 % 100;
            return 0 === e4 ? e4 + "-ев" : 0 === n3 ? e4 + "-ен" : n3 > 10 && n3 < 20 ? e4 + "-ти" : 1 === a3 ? e4 + "-ви" : 2 === a3 ? e4 + "-ри" : 7 === a3 || 8 === a3 ? e4 + "-ми" : e4 + "-ти";
          }, week: { dow: 1, doy: 7 } });
        })(n2(9034));
      }, 1569: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          e3.defineLocale("bm", { months: "Zanwuyekalo_Fewuruyekalo_Marisikalo_Awirilikalo_Mɛkalo_Zuwɛnkalo_Zuluyekalo_Utikalo_Sɛtanburukalo_ɔkutɔburukalo_Nowanburukalo_Desanburukalo".split("_"), monthsShort: "Zan_Few_Mar_Awi_Mɛ_Zuw_Zul_Uti_Sɛt_ɔku_Now_Des".split("_"), weekdays: "Kari_Ntɛnɛn_Tarata_Araba_Alamisa_Juma_Sibiri".split("_"), weekdaysShort: "Kar_Ntɛ_Tar_Ara_Ala_Jum_Sib".split("_"), weekdaysMin: "Ka_Nt_Ta_Ar_Al_Ju_Si".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "MMMM [tile] D [san] YYYY", LLL: "MMMM [tile] D [san] YYYY [lɛrɛ] HH:mm", LLLL: "dddd MMMM [tile] D [san] YYYY [lɛrɛ] HH:mm" }, calendar: { sameDay: "[Bi lɛrɛ] LT", nextDay: "[Sini lɛrɛ] LT", nextWeek: "dddd [don lɛrɛ] LT", lastDay: "[Kunu lɛrɛ] LT", lastWeek: "dddd [tɛmɛnen lɛrɛ] LT", sameElse: "L" }, relativeTime: { future: "%s kɔnɔ", past: "a bɛ %s bɔ", s: "sanga dama dama", ss: "sekondi %d", m: "miniti kelen", mm: "miniti %d", h: "lɛrɛ kelen", hh: "lɛrɛ %d", d: "tile kelen", dd: "tile %d", M: "kalo kelen", MM: "kalo %d", y: "san kelen", yy: "san %d" }, week: { dow: 1, doy: 4 } });
        })(n2(9034));
      }, 4635: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          var a3 = { 1: "১", 2: "২", 3: "৩", 4: "৪", 5: "৫", 6: "৬", 7: "৭", 8: "৮", 9: "৯", 0: "০" }, n3 = { "১": "1", "২": "2", "৩": "3", "৪": "4", "৫": "5", "৬": "6", "৭": "7", "৮": "8", "৯": "9", "০": "0" };
          e3.defineLocale("bn-bd", { months: "জানুয়ারি_ফেব্রুয়ারি_মার্চ_এপ্রিল_মে_জুন_জুলাই_আগস্ট_সেপ্টেম্বর_অক্টোবর_নভেম্বর_ডিসেম্বর".split("_"), monthsShort: "জানু_ফেব্রু_মার্চ_এপ্রিল_মে_জুন_জুলাই_আগস্ট_সেপ্ট_অক্টো_নভে_ডিসে".split("_"), weekdays: "রবিবার_সোমবার_মঙ্গলবার_বুধবার_বৃহস্পতিবার_শুক্রবার_শনিবার".split("_"), weekdaysShort: "রবি_সোম_মঙ্গল_বুধ_বৃহস্পতি_শুক্র_শনি".split("_"), weekdaysMin: "রবি_সোম_মঙ্গল_বুধ_বৃহ_শুক্র_শনি".split("_"), longDateFormat: { LT: "A h:mm সময়", LTS: "A h:mm:ss সময়", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY, A h:mm সময়", LLLL: "dddd, D MMMM YYYY, A h:mm সময়" }, calendar: { sameDay: "[আজ] LT", nextDay: "[আগামীকাল] LT", nextWeek: "dddd, LT", lastDay: "[গতকাল] LT", lastWeek: "[গত] dddd, LT", sameElse: "L" }, relativeTime: { future: "%s পরে", past: "%s আগে", s: "কয়েক সেকেন্ড", ss: "%d সেকেন্ড", m: "এক মিনিট", mm: "%d মিনিট", h: "এক ঘন্টা", hh: "%d ঘন্টা", d: "এক দিন", dd: "%d দিন", M: "এক মাস", MM: "%d মাস", y: "এক বছর", yy: "%d বছর" }, preparse: function(e4) {
            return e4.replace(/[১২৩৪৫৬৭৮৯০]/g, (function(e5) {
              return n3[e5];
            }));
          }, postformat: function(e4) {
            return e4.replace(/\d/g, (function(e5) {
              return a3[e5];
            }));
          }, meridiemParse: /রাত|ভোর|সকাল|দুপুর|বিকাল|সন্ধ্যা|রাত/, meridiemHour: function(e4, a4) {
            return 12 === e4 && (e4 = 0), "রাত" === a4 ? e4 < 4 ? e4 : e4 + 12 : "ভোর" === a4 || "সকাল" === a4 ? e4 : "দুপুর" === a4 ? e4 >= 3 ? e4 : e4 + 12 : "বিকাল" === a4 || "সন্ধ্যা" === a4 ? e4 + 12 : void 0;
          }, meridiem: function(e4, a4, n4) {
            return e4 < 4 ? "রাত" : e4 < 6 ? "ভোর" : e4 < 12 ? "সকাল" : e4 < 15 ? "দুপুর" : e4 < 18 ? "বিকাল" : e4 < 20 ? "সন্ধ্যা" : "রাত";
          }, week: { dow: 0, doy: 6 } });
        })(n2(9034));
      }, 6212: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          var a3 = { 1: "১", 2: "২", 3: "৩", 4: "৪", 5: "৫", 6: "৬", 7: "৭", 8: "৮", 9: "৯", 0: "০" }, n3 = { "১": "1", "২": "2", "৩": "3", "৪": "4", "৫": "5", "৬": "6", "৭": "7", "৮": "8", "৯": "9", "০": "0" };
          e3.defineLocale("bn", { months: "জানুয়ারি_ফেব্রুয়ারি_মার্চ_এপ্রিল_মে_জুন_জুলাই_আগস্ট_সেপ্টেম্বর_অক্টোবর_নভেম্বর_ডিসেম্বর".split("_"), monthsShort: "জানু_ফেব্রু_মার্চ_এপ্রিল_মে_জুন_জুলাই_আগস্ট_সেপ্ট_অক্টো_নভে_ডিসে".split("_"), weekdays: "রবিবার_সোমবার_মঙ্গলবার_বুধবার_বৃহস্পতিবার_শুক্রবার_শনিবার".split("_"), weekdaysShort: "রবি_সোম_মঙ্গল_বুধ_বৃহস্পতি_শুক্র_শনি".split("_"), weekdaysMin: "রবি_সোম_মঙ্গল_বুধ_বৃহ_শুক্র_শনি".split("_"), longDateFormat: { LT: "A h:mm সময়", LTS: "A h:mm:ss সময়", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY, A h:mm সময়", LLLL: "dddd, D MMMM YYYY, A h:mm সময়" }, calendar: { sameDay: "[আজ] LT", nextDay: "[আগামীকাল] LT", nextWeek: "dddd, LT", lastDay: "[গতকাল] LT", lastWeek: "[গত] dddd, LT", sameElse: "L" }, relativeTime: { future: "%s পরে", past: "%s আগে", s: "কয়েক সেকেন্ড", ss: "%d সেকেন্ড", m: "এক মিনিট", mm: "%d মিনিট", h: "এক ঘন্টা", hh: "%d ঘন্টা", d: "এক দিন", dd: "%d দিন", M: "এক মাস", MM: "%d মাস", y: "এক বছর", yy: "%d বছর" }, preparse: function(e4) {
            return e4.replace(/[১২৩৪৫৬৭৮৯০]/g, (function(e5) {
              return n3[e5];
            }));
          }, postformat: function(e4) {
            return e4.replace(/\d/g, (function(e5) {
              return a3[e5];
            }));
          }, meridiemParse: /রাত|সকাল|দুপুর|বিকাল|রাত/, meridiemHour: function(e4, a4) {
            return 12 === e4 && (e4 = 0), "রাত" === a4 && e4 >= 4 || "দুপুর" === a4 && e4 < 5 || "বিকাল" === a4 ? e4 + 12 : e4;
          }, meridiem: function(e4, a4, n4) {
            return e4 < 4 ? "রাত" : e4 < 10 ? "সকাল" : e4 < 17 ? "দুপুর" : e4 < 20 ? "বিকাল" : "রাত";
          }, week: { dow: 0, doy: 6 } });
        })(n2(9034));
      }, 3667: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          var a3 = { 1: "༡", 2: "༢", 3: "༣", 4: "༤", 5: "༥", 6: "༦", 7: "༧", 8: "༨", 9: "༩", 0: "༠" }, n3 = { "༡": "1", "༢": "2", "༣": "3", "༤": "4", "༥": "5", "༦": "6", "༧": "7", "༨": "8", "༩": "9", "༠": "0" };
          e3.defineLocale("bo", { months: "ཟླ་བ་དང་པོ_ཟླ་བ་གཉིས་པ_ཟླ་བ་གསུམ་པ_ཟླ་བ་བཞི་པ_ཟླ་བ་ལྔ་པ_ཟླ་བ་དྲུག་པ_ཟླ་བ་བདུན་པ_ཟླ་བ་བརྒྱད་པ_ཟླ་བ་དགུ་པ_ཟླ་བ་བཅུ་པ_ཟླ་བ་བཅུ་གཅིག་པ_ཟླ་བ་བཅུ་གཉིས་པ".split("_"), monthsShort: "ཟླ་1_ཟླ་2_ཟླ་3_ཟླ་4_ཟླ་5_ཟླ་6_ཟླ་7_ཟླ་8_ཟླ་9_ཟླ་10_ཟླ་11_ཟླ་12".split("_"), monthsShortRegex: /^(ཟླ་\d{1,2})/, monthsParseExact: true, weekdays: "གཟའ་ཉི་མ་_གཟའ་ཟླ་བ་_གཟའ་མིག་དམར་_གཟའ་ལྷག་པ་_གཟའ་ཕུར་བུ_གཟའ་པ་སངས་_གཟའ་སྤེན་པ་".split("_"), weekdaysShort: "ཉི་མ་_ཟླ་བ་_མིག་དམར་_ལྷག་པ་_ཕུར་བུ_པ་སངས་_སྤེན་པ་".split("_"), weekdaysMin: "ཉི_ཟླ_མིག_ལྷག_ཕུར_སངས_སྤེན".split("_"), longDateFormat: { LT: "A h:mm", LTS: "A h:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY, A h:mm", LLLL: "dddd, D MMMM YYYY, A h:mm" }, calendar: { sameDay: "[དི་རིང] LT", nextDay: "[སང་ཉིན] LT", nextWeek: "[བདུན་ཕྲག་རྗེས་མ], LT", lastDay: "[ཁ་སང] LT", lastWeek: "[བདུན་ཕྲག་མཐའ་མ] dddd, LT", sameElse: "L" }, relativeTime: { future: "%s ལ་", past: "%s སྔན་ལ", s: "ལམ་སང", ss: "%d སྐར་ཆ།", m: "སྐར་མ་གཅིག", mm: "%d སྐར་མ", h: "ཆུ་ཚོད་གཅིག", hh: "%d ཆུ་ཚོད", d: "ཉིན་གཅིག", dd: "%d ཉིན་", M: "ཟླ་བ་གཅིག", MM: "%d ཟླ་བ", y: "ལོ་གཅིག", yy: "%d ལོ" }, preparse: function(e4) {
            return e4.replace(/[༡༢༣༤༥༦༧༨༩༠]/g, (function(e5) {
              return n3[e5];
            }));
          }, postformat: function(e4) {
            return e4.replace(/\d/g, (function(e5) {
              return a3[e5];
            }));
          }, meridiemParse: /མཚན་མོ|ཞོགས་ཀས|ཉིན་གུང|དགོང་དག|མཚན་མོ/, meridiemHour: function(e4, a4) {
            return 12 === e4 && (e4 = 0), "མཚན་མོ" === a4 && e4 >= 4 || "ཉིན་གུང" === a4 && e4 < 5 || "དགོང་དག" === a4 ? e4 + 12 : e4;
          }, meridiem: function(e4, a4, n4) {
            return e4 < 4 ? "མཚན་མོ" : e4 < 10 ? "ཞོགས་ཀས" : e4 < 17 ? "ཉིན་གུང" : e4 < 20 ? "དགོང་དག" : "མཚན་མོ";
          }, week: { dow: 0, doy: 6 } });
        })(n2(9034));
      }, 192: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          function a3(e4, a4, n4) {
            return e4 + " " + (function(e5, a5) {
              return 2 === a5 ? (function(e6) {
                var a6 = { m: "v", b: "v", d: "z" };
                return void 0 === a6[e6.charAt(0)] ? e6 : a6[e6.charAt(0)] + e6.substring(1);
              })(e5) : e5;
            })({ mm: "munutenn", MM: "miz", dd: "devezh" }[n4], e4);
          }
          function n3(e4) {
            return e4 > 9 ? n3(e4 % 10) : e4;
          }
          var t2 = [/^gen/i, /^c[ʼ\']hwe/i, /^meu/i, /^ebr/i, /^mae/i, /^(mez|eve)/i, /^gou/i, /^eos/i, /^gwe/i, /^her/i, /^du/i, /^ker/i], c = /^(genver|c[ʼ\']hwevrer|meurzh|ebrel|mae|mezheven|gouere|eost|gwengolo|here|du|kerzu|gen|c[ʼ\']hwe|meu|ebr|mae|eve|gou|eos|gwe|her|du|ker)/i, s = [/^Su/i, /^Lu/i, /^Me([^r]|$)/i, /^Mer/i, /^Ya/i, /^Gw/i, /^Sa/i];
          e3.defineLocale("br", { months: "Genver_Cʼhwevrer_Meurzh_Ebrel_Mae_Mezheven_Gouere_Eost_Gwengolo_Here_Du_Kerzu".split("_"), monthsShort: "Gen_Cʼhwe_Meu_Ebr_Mae_Eve_Gou_Eos_Gwe_Her_Du_Ker".split("_"), weekdays: "Sul_Lun_Meurzh_Mercʼher_Yaou_Gwener_Sadorn".split("_"), weekdaysShort: "Sul_Lun_Meu_Mer_Yao_Gwe_Sad".split("_"), weekdaysMin: "Su_Lu_Me_Mer_Ya_Gw_Sa".split("_"), weekdaysParse: s, fullWeekdaysParse: [/^sul/i, /^lun/i, /^meurzh/i, /^merc[ʼ\']her/i, /^yaou/i, /^gwener/i, /^sadorn/i], shortWeekdaysParse: [/^Sul/i, /^Lun/i, /^Meu/i, /^Mer/i, /^Yao/i, /^Gwe/i, /^Sad/i], minWeekdaysParse: s, monthsRegex: c, monthsShortRegex: c, monthsStrictRegex: /^(genver|c[ʼ\']hwevrer|meurzh|ebrel|mae|mezheven|gouere|eost|gwengolo|here|du|kerzu)/i, monthsShortStrictRegex: /^(gen|c[ʼ\']hwe|meu|ebr|mae|eve|gou|eos|gwe|her|du|ker)/i, monthsParse: t2, longMonthsParse: t2, shortMonthsParse: t2, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D [a viz] MMMM YYYY", LLL: "D [a viz] MMMM YYYY HH:mm", LLLL: "dddd, D [a viz] MMMM YYYY HH:mm" }, calendar: { sameDay: "[Hiziv da] LT", nextDay: "[Warcʼhoazh da] LT", nextWeek: "dddd [da] LT", lastDay: "[Decʼh da] LT", lastWeek: "dddd [paset da] LT", sameElse: "L" }, relativeTime: { future: "a-benn %s", past: "%s ʼzo", s: "un nebeud segondennoù", ss: "%d eilenn", m: "ur vunutenn", mm: a3, h: "un eur", hh: "%d eur", d: "un devezh", dd: a3, M: "ur miz", MM: a3, y: "ur bloaz", yy: function(e4) {
            switch (n3(e4)) {
              case 1:
              case 3:
              case 4:
              case 5:
              case 9:
                return e4 + " bloaz";
              default:
                return e4 + " vloaz";
            }
          } }, dayOfMonthOrdinalParse: /\d{1,2}(añ|vet)/, ordinal: function(e4) {
            return e4 + (1 === e4 ? "añ" : "vet");
          }, week: { dow: 1, doy: 4 }, meridiemParse: /a.m.|g.m./, isPM: function(e4) {
            return "g.m." === e4;
          }, meridiem: function(e4, a4, n4) {
            return e4 < 12 ? "a.m." : "g.m.";
          } });
        })(n2(9034));
      }, 1802: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          function a3(e4, a4, n3) {
            var t2 = e4 + " ";
            switch (n3) {
              case "ss":
                return t2 + (1 === e4 ? "sekunda" : 2 === e4 || 3 === e4 || 4 === e4 ? "sekunde" : "sekundi");
              case "m":
                return a4 ? "jedna minuta" : "jedne minute";
              case "mm":
                return t2 + (1 === e4 ? "minuta" : 2 === e4 || 3 === e4 || 4 === e4 ? "minute" : "minuta");
              case "h":
                return a4 ? "jedan sat" : "jednog sata";
              case "hh":
                return t2 + (1 === e4 ? "sat" : 2 === e4 || 3 === e4 || 4 === e4 ? "sata" : "sati");
              case "dd":
                return t2 + (1 === e4 ? "dan" : "dana");
              case "MM":
                return t2 + (1 === e4 ? "mjesec" : 2 === e4 || 3 === e4 || 4 === e4 ? "mjeseca" : "mjeseci");
              case "yy":
                return t2 + (1 === e4 ? "godina" : 2 === e4 || 3 === e4 || 4 === e4 ? "godine" : "godina");
            }
          }
          e3.defineLocale("bs", { months: "januar_februar_mart_april_maj_juni_juli_august_septembar_oktobar_novembar_decembar".split("_"), monthsShort: "jan._feb._mar._apr._maj._jun._jul._aug._sep._okt._nov._dec.".split("_"), monthsParseExact: true, weekdays: "nedjelja_ponedjeljak_utorak_srijeda_četvrtak_petak_subota".split("_"), weekdaysShort: "ned._pon._uto._sri._čet._pet._sub.".split("_"), weekdaysMin: "ne_po_ut_sr_če_pe_su".split("_"), weekdaysParseExact: true, longDateFormat: { LT: "H:mm", LTS: "H:mm:ss", L: "DD.MM.YYYY", LL: "D. MMMM YYYY", LLL: "D. MMMM YYYY H:mm", LLLL: "dddd, D. MMMM YYYY H:mm" }, calendar: { sameDay: "[danas u] LT", nextDay: "[sutra u] LT", nextWeek: function() {
            switch (this.day()) {
              case 0:
                return "[u] [nedjelju] [u] LT";
              case 3:
                return "[u] [srijedu] [u] LT";
              case 6:
                return "[u] [subotu] [u] LT";
              case 1:
              case 2:
              case 4:
              case 5:
                return "[u] dddd [u] LT";
            }
          }, lastDay: "[jučer u] LT", lastWeek: function() {
            switch (this.day()) {
              case 0:
              case 3:
                return "[prošlu] dddd [u] LT";
              case 6:
                return "[prošle] [subote] [u] LT";
              case 1:
              case 2:
              case 4:
              case 5:
                return "[prošli] dddd [u] LT";
            }
          }, sameElse: "L" }, relativeTime: { future: "za %s", past: "prije %s", s: "par sekundi", ss: a3, m: a3, mm: a3, h: a3, hh: a3, d: "dan", dd: a3, M: "mjesec", MM: a3, y: "godinu", yy: a3 }, dayOfMonthOrdinalParse: /\d{1,2}\./, ordinal: "%d.", week: { dow: 1, doy: 7 } });
        })(n2(9034));
      }, 9118: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          e3.defineLocale("ca", { months: { standalone: "gener_febrer_març_abril_maig_juny_juliol_agost_setembre_octubre_novembre_desembre".split("_"), format: "de gener_de febrer_de març_d'abril_de maig_de juny_de juliol_d'agost_de setembre_d'octubre_de novembre_de desembre".split("_"), isFormat: /D[oD]?(\s)+MMMM/ }, monthsShort: "gen._febr._març_abr._maig_juny_jul._ag._set._oct._nov._des.".split("_"), monthsParseExact: true, weekdays: "diumenge_dilluns_dimarts_dimecres_dijous_divendres_dissabte".split("_"), weekdaysShort: "dg._dl._dt._dc._dj._dv._ds.".split("_"), weekdaysMin: "dg_dl_dt_dc_dj_dv_ds".split("_"), weekdaysParseExact: true, longDateFormat: { LT: "H:mm", LTS: "H:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM [de] YYYY", ll: "D MMM YYYY", LLL: "D MMMM [de] YYYY [a les] H:mm", lll: "D MMM YYYY, H:mm", LLLL: "dddd D MMMM [de] YYYY [a les] H:mm", llll: "ddd D MMM YYYY, H:mm" }, calendar: { sameDay: function() {
            return "[avui a " + (1 !== this.hours() ? "les" : "la") + "] LT";
          }, nextDay: function() {
            return "[demà a " + (1 !== this.hours() ? "les" : "la") + "] LT";
          }, nextWeek: function() {
            return "dddd [a " + (1 !== this.hours() ? "les" : "la") + "] LT";
          }, lastDay: function() {
            return "[ahir a " + (1 !== this.hours() ? "les" : "la") + "] LT";
          }, lastWeek: function() {
            return "[el] dddd [passat a " + (1 !== this.hours() ? "les" : "la") + "] LT";
          }, sameElse: "L" }, relativeTime: { future: "d'aquí %s", past: "fa %s", s: "uns segons", ss: "%d segons", m: "un minut", mm: "%d minuts", h: "una hora", hh: "%d hores", d: "un dia", dd: "%d dies", M: "un mes", MM: "%d mesos", y: "un any", yy: "%d anys" }, dayOfMonthOrdinalParse: /\d{1,2}(r|n|t|è|a)/, ordinal: function(e4, a3) {
            var n3 = 1 === e4 ? "r" : 2 === e4 ? "n" : 3 === e4 ? "r" : 4 === e4 ? "t" : "è";
            return "w" !== a3 && "W" !== a3 || (n3 = "a"), e4 + n3;
          }, week: { dow: 1, doy: 4 } });
        })(n2(9034));
      }, 9990: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          var a3 = { format: "leden_únor_březen_duben_květen_červen_červenec_srpen_září_říjen_listopad_prosinec".split("_"), standalone: "ledna_února_března_dubna_května_června_července_srpna_září_října_listopadu_prosince".split("_") }, n3 = "led_úno_bře_dub_kvě_čvn_čvc_srp_zář_říj_lis_pro".split("_"), t2 = [/^led/i, /^úno/i, /^bře/i, /^dub/i, /^kvě/i, /^(čvn|červen$|června)/i, /^(čvc|červenec|července)/i, /^srp/i, /^zář/i, /^říj/i, /^lis/i, /^pro/i], c = /^(leden|únor|březen|duben|květen|červenec|července|červen|června|srpen|září|říjen|listopad|prosinec|led|úno|bře|dub|kvě|čvn|čvc|srp|zář|říj|lis|pro)/i;
          function s(e4) {
            return e4 > 1 && e4 < 5 && 1 != ~~(e4 / 10);
          }
          function o(e4, a4, n4, t3) {
            var c2 = e4 + " ";
            switch (n4) {
              case "s":
                return a4 || t3 ? "pár sekund" : "pár sekundami";
              case "ss":
                return a4 || t3 ? c2 + (s(e4) ? "sekundy" : "sekund") : c2 + "sekundami";
              case "m":
                return a4 ? "minuta" : t3 ? "minutu" : "minutou";
              case "mm":
                return a4 || t3 ? c2 + (s(e4) ? "minuty" : "minut") : c2 + "minutami";
              case "h":
                return a4 ? "hodina" : t3 ? "hodinu" : "hodinou";
              case "hh":
                return a4 || t3 ? c2 + (s(e4) ? "hodiny" : "hodin") : c2 + "hodinami";
              case "d":
                return a4 || t3 ? "den" : "dnem";
              case "dd":
                return a4 || t3 ? c2 + (s(e4) ? "dny" : "dní") : c2 + "dny";
              case "M":
                return a4 || t3 ? "měsíc" : "měsícem";
              case "MM":
                return a4 || t3 ? c2 + (s(e4) ? "měsíce" : "měsíců") : c2 + "měsíci";
              case "y":
                return a4 || t3 ? "rok" : "rokem";
              case "yy":
                return a4 || t3 ? c2 + (s(e4) ? "roky" : "let") : c2 + "lety";
            }
          }
          e3.defineLocale("cs", { months: a3, monthsShort: n3, monthsRegex: c, monthsShortRegex: c, monthsStrictRegex: /^(leden|ledna|února|únor|březen|března|duben|dubna|květen|května|červenec|července|červen|června|srpen|srpna|září|říjen|října|listopadu|listopad|prosinec|prosince)/i, monthsShortStrictRegex: /^(led|úno|bře|dub|kvě|čvn|čvc|srp|zář|říj|lis|pro)/i, monthsParse: t2, longMonthsParse: t2, shortMonthsParse: t2, weekdays: "neděle_pondělí_úterý_středa_čtvrtek_pátek_sobota".split("_"), weekdaysShort: "ne_po_út_st_čt_pá_so".split("_"), weekdaysMin: "ne_po_út_st_čt_pá_so".split("_"), longDateFormat: { LT: "H:mm", LTS: "H:mm:ss", L: "DD.MM.YYYY", LL: "D. MMMM YYYY", LLL: "D. MMMM YYYY H:mm", LLLL: "dddd D. MMMM YYYY H:mm", l: "D. M. YYYY" }, calendar: { sameDay: "[dnes v] LT", nextDay: "[zítra v] LT", nextWeek: function() {
            switch (this.day()) {
              case 0:
                return "[v neděli v] LT";
              case 1:
              case 2:
                return "[v] dddd [v] LT";
              case 3:
                return "[ve středu v] LT";
              case 4:
                return "[ve čtvrtek v] LT";
              case 5:
                return "[v pátek v] LT";
              case 6:
                return "[v sobotu v] LT";
            }
          }, lastDay: "[včera v] LT", lastWeek: function() {
            switch (this.day()) {
              case 0:
                return "[minulou neděli v] LT";
              case 1:
              case 2:
                return "[minulé] dddd [v] LT";
              case 3:
                return "[minulou středu v] LT";
              case 4:
              case 5:
                return "[minulý] dddd [v] LT";
              case 6:
                return "[minulou sobotu v] LT";
            }
          }, sameElse: "L" }, relativeTime: { future: "za %s", past: "před %s", s: o, ss: o, m: o, mm: o, h: o, hh: o, d: o, dd: o, M: o, MM: o, y: o, yy: o }, dayOfMonthOrdinalParse: /\d{1,2}\./, ordinal: "%d.", week: { dow: 1, doy: 4 } });
        })(n2(9034));
      }, 557: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          e3.defineLocale("cv", { months: "кӑрлач_нарӑс_пуш_ака_май_ҫӗртме_утӑ_ҫурла_авӑн_юпа_чӳк_раштав".split("_"), monthsShort: "кӑр_нар_пуш_ака_май_ҫӗр_утӑ_ҫур_авн_юпа_чӳк_раш".split("_"), weekdays: "вырсарникун_тунтикун_ытларикун_юнкун_кӗҫнерникун_эрнекун_шӑматкун".split("_"), weekdaysShort: "выр_тун_ытл_юн_кӗҫ_эрн_шӑм".split("_"), weekdaysMin: "вр_тн_ыт_юн_кҫ_эр_шм".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD-MM-YYYY", LL: "YYYY [ҫулхи] MMMM [уйӑхӗн] D[-мӗшӗ]", LLL: "YYYY [ҫулхи] MMMM [уйӑхӗн] D[-мӗшӗ], HH:mm", LLLL: "dddd, YYYY [ҫулхи] MMMM [уйӑхӗн] D[-мӗшӗ], HH:mm" }, calendar: { sameDay: "[Паян] LT [сехетре]", nextDay: "[Ыран] LT [сехетре]", lastDay: "[Ӗнер] LT [сехетре]", nextWeek: "[Ҫитес] dddd LT [сехетре]", lastWeek: "[Иртнӗ] dddd LT [сехетре]", sameElse: "L" }, relativeTime: { future: function(e4) {
            return e4 + (/сехет$/i.exec(e4) ? "рен" : /ҫул$/i.exec(e4) ? "тан" : "ран");
          }, past: "%s каялла", s: "пӗр-ик ҫеккунт", ss: "%d ҫеккунт", m: "пӗр минут", mm: "%d минут", h: "пӗр сехет", hh: "%d сехет", d: "пӗр кун", dd: "%d кун", M: "пӗр уйӑх", MM: "%d уйӑх", y: "пӗр ҫул", yy: "%d ҫул" }, dayOfMonthOrdinalParse: /\d{1,2}-мӗш/, ordinal: "%d-мӗш", week: { dow: 1, doy: 7 } });
        })(n2(9034));
      }, 4227: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          e3.defineLocale("cy", { months: "Ionawr_Chwefror_Mawrth_Ebrill_Mai_Mehefin_Gorffennaf_Awst_Medi_Hydref_Tachwedd_Rhagfyr".split("_"), monthsShort: "Ion_Chwe_Maw_Ebr_Mai_Meh_Gor_Aws_Med_Hyd_Tach_Rhag".split("_"), weekdays: "Dydd Sul_Dydd Llun_Dydd Mawrth_Dydd Mercher_Dydd Iau_Dydd Gwener_Dydd Sadwrn".split("_"), weekdaysShort: "Sul_Llun_Maw_Mer_Iau_Gwe_Sad".split("_"), weekdaysMin: "Su_Ll_Ma_Me_Ia_Gw_Sa".split("_"), weekdaysParseExact: true, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" }, calendar: { sameDay: "[Heddiw am] LT", nextDay: "[Yfory am] LT", nextWeek: "dddd [am] LT", lastDay: "[Ddoe am] LT", lastWeek: "dddd [diwethaf am] LT", sameElse: "L" }, relativeTime: { future: "mewn %s", past: "%s yn ôl", s: "ychydig eiliadau", ss: "%d eiliad", m: "munud", mm: "%d munud", h: "awr", hh: "%d awr", d: "diwrnod", dd: "%d diwrnod", M: "mis", MM: "%d mis", y: "blwyddyn", yy: "%d flynedd" }, dayOfMonthOrdinalParse: /\d{1,2}(fed|ain|af|il|ydd|ed|eg)/, ordinal: function(e4) {
            var a3 = "";
            return e4 > 20 ? a3 = 40 === e4 || 50 === e4 || 60 === e4 || 80 === e4 || 100 === e4 ? "fed" : "ain" : e4 > 0 && (a3 = ["", "af", "il", "ydd", "ydd", "ed", "ed", "ed", "fed", "fed", "fed", "eg", "fed", "eg", "eg", "fed", "eg", "eg", "fed", "eg", "fed"][e4]), e4 + a3;
          }, week: { dow: 1, doy: 4 } });
        })(n2(9034));
      }, 5406: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          e3.defineLocale("da", { months: "januar_februar_marts_april_maj_juni_juli_august_september_oktober_november_december".split("_"), monthsShort: "jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec".split("_"), weekdays: "søndag_mandag_tirsdag_onsdag_torsdag_fredag_lørdag".split("_"), weekdaysShort: "søn_man_tir_ons_tor_fre_lør".split("_"), weekdaysMin: "sø_ma_ti_on_to_fr_lø".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD.MM.YYYY", LL: "D. MMMM YYYY", LLL: "D. MMMM YYYY HH:mm", LLLL: "dddd [d.] D. MMMM YYYY [kl.] HH:mm" }, calendar: { sameDay: "[i dag kl.] LT", nextDay: "[i morgen kl.] LT", nextWeek: "på dddd [kl.] LT", lastDay: "[i går kl.] LT", lastWeek: "[i] dddd[s kl.] LT", sameElse: "L" }, relativeTime: { future: "om %s", past: "%s siden", s: "få sekunder", ss: "%d sekunder", m: "et minut", mm: "%d minutter", h: "en time", hh: "%d timer", d: "en dag", dd: "%d dage", M: "en måned", MM: "%d måneder", y: "et år", yy: "%d år" }, dayOfMonthOrdinalParse: /\d{1,2}\./, ordinal: "%d.", week: { dow: 1, doy: 4 } });
        })(n2(9034));
      }, 4139: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          function a3(e4, a4, n3, t2) {
            var c = { m: ["eine Minute", "einer Minute"], h: ["eine Stunde", "einer Stunde"], d: ["ein Tag", "einem Tag"], dd: [e4 + " Tage", e4 + " Tagen"], w: ["eine Woche", "einer Woche"], M: ["ein Monat", "einem Monat"], MM: [e4 + " Monate", e4 + " Monaten"], y: ["ein Jahr", "einem Jahr"], yy: [e4 + " Jahre", e4 + " Jahren"] };
            return a4 ? c[n3][0] : c[n3][1];
          }
          e3.defineLocale("de-at", { months: "Jänner_Februar_März_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember".split("_"), monthsShort: "Jän._Feb._März_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.".split("_"), monthsParseExact: true, weekdays: "Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag".split("_"), weekdaysShort: "So._Mo._Di._Mi._Do._Fr._Sa.".split("_"), weekdaysMin: "So_Mo_Di_Mi_Do_Fr_Sa".split("_"), weekdaysParseExact: true, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD.MM.YYYY", LL: "D. MMMM YYYY", LLL: "D. MMMM YYYY HH:mm", LLLL: "dddd, D. MMMM YYYY HH:mm" }, calendar: { sameDay: "[heute um] LT [Uhr]", sameElse: "L", nextDay: "[morgen um] LT [Uhr]", nextWeek: "dddd [um] LT [Uhr]", lastDay: "[gestern um] LT [Uhr]", lastWeek: "[letzten] dddd [um] LT [Uhr]" }, relativeTime: { future: "in %s", past: "vor %s", s: "ein paar Sekunden", ss: "%d Sekunden", m: a3, mm: "%d Minuten", h: a3, hh: "%d Stunden", d: a3, dd: a3, w: a3, ww: "%d Wochen", M: a3, MM: a3, y: a3, yy: a3 }, dayOfMonthOrdinalParse: /\d{1,2}\./, ordinal: "%d.", week: { dow: 1, doy: 4 } });
        })(n2(9034));
      }, 6591: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          function a3(e4, a4, n3, t2) {
            var c = { m: ["eine Minute", "einer Minute"], h: ["eine Stunde", "einer Stunde"], d: ["ein Tag", "einem Tag"], dd: [e4 + " Tage", e4 + " Tagen"], w: ["eine Woche", "einer Woche"], M: ["ein Monat", "einem Monat"], MM: [e4 + " Monate", e4 + " Monaten"], y: ["ein Jahr", "einem Jahr"], yy: [e4 + " Jahre", e4 + " Jahren"] };
            return a4 ? c[n3][0] : c[n3][1];
          }
          e3.defineLocale("de-ch", { months: "Januar_Februar_März_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember".split("_"), monthsShort: "Jan._Feb._März_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.".split("_"), monthsParseExact: true, weekdays: "Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag".split("_"), weekdaysShort: "So_Mo_Di_Mi_Do_Fr_Sa".split("_"), weekdaysMin: "So_Mo_Di_Mi_Do_Fr_Sa".split("_"), weekdaysParseExact: true, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD.MM.YYYY", LL: "D. MMMM YYYY", LLL: "D. MMMM YYYY HH:mm", LLLL: "dddd, D. MMMM YYYY HH:mm" }, calendar: { sameDay: "[heute um] LT [Uhr]", sameElse: "L", nextDay: "[morgen um] LT [Uhr]", nextWeek: "dddd [um] LT [Uhr]", lastDay: "[gestern um] LT [Uhr]", lastWeek: "[letzten] dddd [um] LT [Uhr]" }, relativeTime: { future: "in %s", past: "vor %s", s: "ein paar Sekunden", ss: "%d Sekunden", m: a3, mm: "%d Minuten", h: a3, hh: "%d Stunden", d: a3, dd: a3, w: a3, ww: "%d Wochen", M: a3, MM: a3, y: a3, yy: a3 }, dayOfMonthOrdinalParse: /\d{1,2}\./, ordinal: "%d.", week: { dow: 1, doy: 4 } });
        })(n2(9034));
      }, 7994: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          function a3(e4, a4, n3, t2) {
            var c = { m: ["eine Minute", "einer Minute"], h: ["eine Stunde", "einer Stunde"], d: ["ein Tag", "einem Tag"], dd: [e4 + " Tage", e4 + " Tagen"], w: ["eine Woche", "einer Woche"], M: ["ein Monat", "einem Monat"], MM: [e4 + " Monate", e4 + " Monaten"], y: ["ein Jahr", "einem Jahr"], yy: [e4 + " Jahre", e4 + " Jahren"] };
            return a4 ? c[n3][0] : c[n3][1];
          }
          e3.defineLocale("de", { months: "Januar_Februar_März_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember".split("_"), monthsShort: "Jan._Feb._März_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.".split("_"), monthsParseExact: true, weekdays: "Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag".split("_"), weekdaysShort: "So._Mo._Di._Mi._Do._Fr._Sa.".split("_"), weekdaysMin: "So_Mo_Di_Mi_Do_Fr_Sa".split("_"), weekdaysParseExact: true, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD.MM.YYYY", LL: "D. MMMM YYYY", LLL: "D. MMMM YYYY HH:mm", LLLL: "dddd, D. MMMM YYYY HH:mm" }, calendar: { sameDay: "[heute um] LT [Uhr]", sameElse: "L", nextDay: "[morgen um] LT [Uhr]", nextWeek: "dddd [um] LT [Uhr]", lastDay: "[gestern um] LT [Uhr]", lastWeek: "[letzten] dddd [um] LT [Uhr]" }, relativeTime: { future: "in %s", past: "vor %s", s: "ein paar Sekunden", ss: "%d Sekunden", m: a3, mm: "%d Minuten", h: a3, hh: "%d Stunden", d: a3, dd: a3, w: a3, ww: "%d Wochen", M: a3, MM: a3, y: a3, yy: a3 }, dayOfMonthOrdinalParse: /\d{1,2}\./, ordinal: "%d.", week: { dow: 1, doy: 4 } });
        })(n2(9034));
      }, 4649: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          var a3 = ["ޖެނުއަރީ", "ފެބްރުއަރީ", "މާރިޗު", "އޭޕްރީލު", "މޭ", "ޖޫން", "ޖުލައި", "އޯގަސްޓު", "ސެޕްޓެމްބަރު", "އޮކްޓޯބަރު", "ނޮވެމްބަރު", "ޑިސެމްބަރު"], n3 = ["އާދިއްތަ", "ހޯމަ", "އަންގާރަ", "ބުދަ", "ބުރާސްފަތި", "ހުކުރު", "ހޮނިހިރު"];
          e3.defineLocale("dv", { months: a3, monthsShort: a3, weekdays: n3, weekdaysShort: n3, weekdaysMin: "އާދި_ހޯމަ_އަން_ބުދަ_ބުރާ_ހުކު_ހޮނި".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "D/M/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D MMMM YYYY HH:mm" }, meridiemParse: /މކ|މފ/, isPM: function(e4) {
            return "މފ" === e4;
          }, meridiem: function(e4, a4, n4) {
            return e4 < 12 ? "މކ" : "މފ";
          }, calendar: { sameDay: "[މިއަދު] LT", nextDay: "[މާދަމާ] LT", nextWeek: "dddd LT", lastDay: "[އިއްޔެ] LT", lastWeek: "[ފާއިތުވި] dddd LT", sameElse: "L" }, relativeTime: { future: "ތެރޭގައި %s", past: "ކުރިން %s", s: "ސިކުންތުކޮޅެއް", ss: "d% ސިކުންތު", m: "މިނިޓެއް", mm: "މިނިޓު %d", h: "ގަޑިއިރެއް", hh: "ގަޑިއިރު %d", d: "ދުވަހެއް", dd: "ދުވަސް %d", M: "މަހެއް", MM: "މަސް %d", y: "އަހަރެއް", yy: "އަހަރު %d" }, preparse: function(e4) {
            return e4.replace(/،/g, ",");
          }, postformat: function(e4) {
            return e4.replace(/,/g, "،");
          }, week: { dow: 7, doy: 12 } });
        })(n2(9034));
      }, 4453: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          e3.defineLocale("el", { monthsNominativeEl: "Ιανουάριος_Φεβρουάριος_Μάρτιος_Απρίλιος_Μάιος_Ιούνιος_Ιούλιος_Αύγουστος_Σεπτέμβριος_Οκτώβριος_Νοέμβριος_Δεκέμβριος".split("_"), monthsGenitiveEl: "Ιανουαρίου_Φεβρουαρίου_Μαρτίου_Απριλίου_Μαΐου_Ιουνίου_Ιουλίου_Αυγούστου_Σεπτεμβρίου_Οκτωβρίου_Νοεμβρίου_Δεκεμβρίου".split("_"), months: function(e4, a3) {
            return e4 ? "string" == typeof a3 && /D/.test(a3.substring(0, a3.indexOf("MMMM"))) ? this._monthsGenitiveEl[e4.month()] : this._monthsNominativeEl[e4.month()] : this._monthsNominativeEl;
          }, monthsShort: "Ιαν_Φεβ_Μαρ_Απρ_Μαϊ_Ιουν_Ιουλ_Αυγ_Σεπ_Οκτ_Νοε_Δεκ".split("_"), weekdays: "Κυριακή_Δευτέρα_Τρίτη_Τετάρτη_Πέμπτη_Παρασκευή_Σάββατο".split("_"), weekdaysShort: "Κυρ_Δευ_Τρι_Τετ_Πεμ_Παρ_Σαβ".split("_"), weekdaysMin: "Κυ_Δε_Τρ_Τε_Πε_Πα_Σα".split("_"), meridiem: function(e4, a3, n3) {
            return e4 > 11 ? n3 ? "μμ" : "ΜΜ" : n3 ? "πμ" : "ΠΜ";
          }, isPM: function(e4) {
            return "μ" === (e4 + "").toLowerCase()[0];
          }, meridiemParse: /[ΠΜ]\.?Μ?\.?/i, longDateFormat: { LT: "h:mm A", LTS: "h:mm:ss A", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY h:mm A", LLLL: "dddd, D MMMM YYYY h:mm A" }, calendarEl: { sameDay: "[Σήμερα {}] LT", nextDay: "[Αύριο {}] LT", nextWeek: "dddd [{}] LT", lastDay: "[Χθες {}] LT", lastWeek: function() {
            return 6 === this.day() ? "[το προηγούμενο] dddd [{}] LT" : "[την προηγούμενη] dddd [{}] LT";
          }, sameElse: "L" }, calendar: function(e4, a3) {
            var n3, t2 = this._calendarEl[e4], c = a3 && a3.hours();
            return n3 = t2, ("undefined" != typeof Function && n3 instanceof Function || "[object Function]" === Object.prototype.toString.call(n3)) && (t2 = t2.apply(a3)), t2.replace("{}", c % 12 == 1 ? "στη" : "στις");
          }, relativeTime: { future: "σε %s", past: "%s πριν", s: "λίγα δευτερόλεπτα", ss: "%d δευτερόλεπτα", m: "ένα λεπτό", mm: "%d λεπτά", h: "μία ώρα", hh: "%d ώρες", d: "μία μέρα", dd: "%d μέρες", M: "ένας μήνας", MM: "%d μήνες", y: "ένας χρόνος", yy: "%d χρόνια" }, dayOfMonthOrdinalParse: /\d{1,2}η/, ordinal: "%dη", week: { dow: 1, doy: 4 } });
        })(n2(9034));
      }, 8428: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          e3.defineLocale("en-au", { months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), longDateFormat: { LT: "h:mm A", LTS: "h:mm:ss A", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY h:mm A", LLLL: "dddd, D MMMM YYYY h:mm A" }, calendar: { sameDay: "[Today at] LT", nextDay: "[Tomorrow at] LT", nextWeek: "dddd [at] LT", lastDay: "[Yesterday at] LT", lastWeek: "[Last] dddd [at] LT", sameElse: "L" }, relativeTime: { future: "in %s", past: "%s ago", s: "a few seconds", ss: "%d seconds", m: "a minute", mm: "%d minutes", h: "an hour", hh: "%d hours", d: "a day", dd: "%d days", M: "a month", MM: "%d months", y: "a year", yy: "%d years" }, dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/, ordinal: function(e4) {
            var a3 = e4 % 10;
            return e4 + (1 == ~~(e4 % 100 / 10) ? "th" : 1 === a3 ? "st" : 2 === a3 ? "nd" : 3 === a3 ? "rd" : "th");
          }, week: { dow: 0, doy: 4 } });
        })(n2(9034));
      }, 6972: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          e3.defineLocale("en-ca", { months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), longDateFormat: { LT: "h:mm A", LTS: "h:mm:ss A", L: "YYYY-MM-DD", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A" }, calendar: { sameDay: "[Today at] LT", nextDay: "[Tomorrow at] LT", nextWeek: "dddd [at] LT", lastDay: "[Yesterday at] LT", lastWeek: "[Last] dddd [at] LT", sameElse: "L" }, relativeTime: { future: "in %s", past: "%s ago", s: "a few seconds", ss: "%d seconds", m: "a minute", mm: "%d minutes", h: "an hour", hh: "%d hours", d: "a day", dd: "%d days", M: "a month", MM: "%d months", y: "a year", yy: "%d years" }, dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/, ordinal: function(e4) {
            var a3 = e4 % 10;
            return e4 + (1 == ~~(e4 % 100 / 10) ? "th" : 1 === a3 ? "st" : 2 === a3 ? "nd" : 3 === a3 ? "rd" : "th");
          } });
        })(n2(9034));
      }, 3224: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          e3.defineLocale("en-gb", { months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" }, calendar: { sameDay: "[Today at] LT", nextDay: "[Tomorrow at] LT", nextWeek: "dddd [at] LT", lastDay: "[Yesterday at] LT", lastWeek: "[Last] dddd [at] LT", sameElse: "L" }, relativeTime: { future: "in %s", past: "%s ago", s: "a few seconds", ss: "%d seconds", m: "a minute", mm: "%d minutes", h: "an hour", hh: "%d hours", d: "a day", dd: "%d days", M: "a month", MM: "%d months", y: "a year", yy: "%d years" }, dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/, ordinal: function(e4) {
            var a3 = e4 % 10;
            return e4 + (1 == ~~(e4 % 100 / 10) ? "th" : 1 === a3 ? "st" : 2 === a3 ? "nd" : 3 === a3 ? "rd" : "th");
          }, week: { dow: 1, doy: 4 } });
        })(n2(9034));
      }, 8843: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          e3.defineLocale("en-ie", { months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D MMMM YYYY HH:mm" }, calendar: { sameDay: "[Today at] LT", nextDay: "[Tomorrow at] LT", nextWeek: "dddd [at] LT", lastDay: "[Yesterday at] LT", lastWeek: "[Last] dddd [at] LT", sameElse: "L" }, relativeTime: { future: "in %s", past: "%s ago", s: "a few seconds", ss: "%d seconds", m: "a minute", mm: "%d minutes", h: "an hour", hh: "%d hours", d: "a day", dd: "%d days", M: "a month", MM: "%d months", y: "a year", yy: "%d years" }, dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/, ordinal: function(e4) {
            var a3 = e4 % 10;
            return e4 + (1 == ~~(e4 % 100 / 10) ? "th" : 1 === a3 ? "st" : 2 === a3 ? "nd" : 3 === a3 ? "rd" : "th");
          }, week: { dow: 1, doy: 4 } });
        })(n2(9034));
      }, 2732: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          e3.defineLocale("en-il", { months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" }, calendar: { sameDay: "[Today at] LT", nextDay: "[Tomorrow at] LT", nextWeek: "dddd [at] LT", lastDay: "[Yesterday at] LT", lastWeek: "[Last] dddd [at] LT", sameElse: "L" }, relativeTime: { future: "in %s", past: "%s ago", s: "a few seconds", ss: "%d seconds", m: "a minute", mm: "%d minutes", h: "an hour", hh: "%d hours", d: "a day", dd: "%d days", M: "a month", MM: "%d months", y: "a year", yy: "%d years" }, dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/, ordinal: function(e4) {
            var a3 = e4 % 10;
            return e4 + (1 == ~~(e4 % 100 / 10) ? "th" : 1 === a3 ? "st" : 2 === a3 ? "nd" : 3 === a3 ? "rd" : "th");
          } });
        })(n2(9034));
      }, 6579: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          e3.defineLocale("en-in", { months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), longDateFormat: { LT: "h:mm A", LTS: "h:mm:ss A", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY h:mm A", LLLL: "dddd, D MMMM YYYY h:mm A" }, calendar: { sameDay: "[Today at] LT", nextDay: "[Tomorrow at] LT", nextWeek: "dddd [at] LT", lastDay: "[Yesterday at] LT", lastWeek: "[Last] dddd [at] LT", sameElse: "L" }, relativeTime: { future: "in %s", past: "%s ago", s: "a few seconds", ss: "%d seconds", m: "a minute", mm: "%d minutes", h: "an hour", hh: "%d hours", d: "a day", dd: "%d days", M: "a month", MM: "%d months", y: "a year", yy: "%d years" }, dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/, ordinal: function(e4) {
            var a3 = e4 % 10;
            return e4 + (1 == ~~(e4 % 100 / 10) ? "th" : 1 === a3 ? "st" : 2 === a3 ? "nd" : 3 === a3 ? "rd" : "th");
          }, week: { dow: 0, doy: 6 } });
        })(n2(9034));
      }, 9851: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          e3.defineLocale("en-nz", { months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), longDateFormat: { LT: "h:mm A", LTS: "h:mm:ss A", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY h:mm A", LLLL: "dddd, D MMMM YYYY h:mm A" }, calendar: { sameDay: "[Today at] LT", nextDay: "[Tomorrow at] LT", nextWeek: "dddd [at] LT", lastDay: "[Yesterday at] LT", lastWeek: "[Last] dddd [at] LT", sameElse: "L" }, relativeTime: { future: "in %s", past: "%s ago", s: "a few seconds", ss: "%d seconds", m: "a minute", mm: "%d minutes", h: "an hour", hh: "%d hours", d: "a day", dd: "%d days", M: "a month", MM: "%d months", y: "a year", yy: "%d years" }, dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/, ordinal: function(e4) {
            var a3 = e4 % 10;
            return e4 + (1 == ~~(e4 % 100 / 10) ? "th" : 1 === a3 ? "st" : 2 === a3 ? "nd" : 3 === a3 ? "rd" : "th");
          }, week: { dow: 1, doy: 4 } });
        })(n2(9034));
      }, 442: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          e3.defineLocale("en-sg", { months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" }, calendar: { sameDay: "[Today at] LT", nextDay: "[Tomorrow at] LT", nextWeek: "dddd [at] LT", lastDay: "[Yesterday at] LT", lastWeek: "[Last] dddd [at] LT", sameElse: "L" }, relativeTime: { future: "in %s", past: "%s ago", s: "a few seconds", ss: "%d seconds", m: "a minute", mm: "%d minutes", h: "an hour", hh: "%d hours", d: "a day", dd: "%d days", M: "a month", MM: "%d months", y: "a year", yy: "%d years" }, dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/, ordinal: function(e4) {
            var a3 = e4 % 10;
            return e4 + (1 == ~~(e4 % 100 / 10) ? "th" : 1 === a3 ? "st" : 2 === a3 ? "nd" : 3 === a3 ? "rd" : "th");
          }, week: { dow: 1, doy: 4 } });
        })(n2(9034));
      }, 654: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          e3.defineLocale("eo", { months: "januaro_februaro_marto_aprilo_majo_junio_julio_aŭgusto_septembro_oktobro_novembro_decembro".split("_"), monthsShort: "jan_feb_mart_apr_maj_jun_jul_aŭg_sept_okt_nov_dec".split("_"), weekdays: "dimanĉo_lundo_mardo_merkredo_ĵaŭdo_vendredo_sabato".split("_"), weekdaysShort: "dim_lun_mard_merk_ĵaŭ_ven_sab".split("_"), weekdaysMin: "di_lu_ma_me_ĵa_ve_sa".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "YYYY-MM-DD", LL: "[la] D[-an de] MMMM, YYYY", LLL: "[la] D[-an de] MMMM, YYYY HH:mm", LLLL: "dddd[n], [la] D[-an de] MMMM, YYYY HH:mm", llll: "ddd, [la] D[-an de] MMM, YYYY HH:mm" }, meridiemParse: /[ap]\.t\.m/i, isPM: function(e4) {
            return "p" === e4.charAt(0).toLowerCase();
          }, meridiem: function(e4, a3, n3) {
            return e4 > 11 ? n3 ? "p.t.m." : "P.T.M." : n3 ? "a.t.m." : "A.T.M.";
          }, calendar: { sameDay: "[Hodiaŭ je] LT", nextDay: "[Morgaŭ je] LT", nextWeek: "dddd[n je] LT", lastDay: "[Hieraŭ je] LT", lastWeek: "[pasintan] dddd[n je] LT", sameElse: "L" }, relativeTime: { future: "post %s", past: "antaŭ %s", s: "kelkaj sekundoj", ss: "%d sekundoj", m: "unu minuto", mm: "%d minutoj", h: "unu horo", hh: "%d horoj", d: "unu tago", dd: "%d tagoj", M: "unu monato", MM: "%d monatoj", y: "unu jaro", yy: "%d jaroj" }, dayOfMonthOrdinalParse: /\d{1,2}a/, ordinal: "%da", week: { dow: 1, doy: 7 } });
        })(n2(9034));
      }, 8791: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          var a3 = "ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.".split("_"), n3 = "ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic".split("_"), t2 = [/^ene/i, /^feb/i, /^mar/i, /^abr/i, /^may/i, /^jun/i, /^jul/i, /^ago/i, /^sep/i, /^oct/i, /^nov/i, /^dic/i], c = /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;
          e3.defineLocale("es-do", { months: "enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre".split("_"), monthsShort: function(e4, t3) {
            return e4 ? /-MMM-/.test(t3) ? n3[e4.month()] : a3[e4.month()] : a3;
          }, monthsRegex: c, monthsShortRegex: c, monthsStrictRegex: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i, monthsShortStrictRegex: /^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i, monthsParse: t2, longMonthsParse: t2, shortMonthsParse: t2, weekdays: "domingo_lunes_martes_miércoles_jueves_viernes_sábado".split("_"), weekdaysShort: "dom._lun._mar._mié._jue._vie._sáb.".split("_"), weekdaysMin: "do_lu_ma_mi_ju_vi_sá".split("_"), weekdaysParseExact: true, longDateFormat: { LT: "h:mm A", LTS: "h:mm:ss A", L: "DD/MM/YYYY", LL: "D [de] MMMM [de] YYYY", LLL: "D [de] MMMM [de] YYYY h:mm A", LLLL: "dddd, D [de] MMMM [de] YYYY h:mm A" }, calendar: { sameDay: function() {
            return "[hoy a la" + (1 !== this.hours() ? "s" : "") + "] LT";
          }, nextDay: function() {
            return "[mañana a la" + (1 !== this.hours() ? "s" : "") + "] LT";
          }, nextWeek: function() {
            return "dddd [a la" + (1 !== this.hours() ? "s" : "") + "] LT";
          }, lastDay: function() {
            return "[ayer a la" + (1 !== this.hours() ? "s" : "") + "] LT";
          }, lastWeek: function() {
            return "[el] dddd [pasado a la" + (1 !== this.hours() ? "s" : "") + "] LT";
          }, sameElse: "L" }, relativeTime: { future: "en %s", past: "hace %s", s: "unos segundos", ss: "%d segundos", m: "un minuto", mm: "%d minutos", h: "una hora", hh: "%d horas", d: "un día", dd: "%d días", w: "una semana", ww: "%d semanas", M: "un mes", MM: "%d meses", y: "un año", yy: "%d años" }, dayOfMonthOrdinalParse: /\d{1,2}º/, ordinal: "%dº", week: { dow: 1, doy: 4 } });
        })(n2(9034));
      }, 7278: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          var a3 = "ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.".split("_"), n3 = "ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic".split("_"), t2 = [/^ene/i, /^feb/i, /^mar/i, /^abr/i, /^may/i, /^jun/i, /^jul/i, /^ago/i, /^sep/i, /^oct/i, /^nov/i, /^dic/i], c = /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;
          e3.defineLocale("es-mx", { months: "enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre".split("_"), monthsShort: function(e4, t3) {
            return e4 ? /-MMM-/.test(t3) ? n3[e4.month()] : a3[e4.month()] : a3;
          }, monthsRegex: c, monthsShortRegex: c, monthsStrictRegex: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i, monthsShortStrictRegex: /^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i, monthsParse: t2, longMonthsParse: t2, shortMonthsParse: t2, weekdays: "domingo_lunes_martes_miércoles_jueves_viernes_sábado".split("_"), weekdaysShort: "dom._lun._mar._mié._jue._vie._sáb.".split("_"), weekdaysMin: "do_lu_ma_mi_ju_vi_sá".split("_"), weekdaysParseExact: true, longDateFormat: { LT: "H:mm", LTS: "H:mm:ss", L: "DD/MM/YYYY", LL: "D [de] MMMM [de] YYYY", LLL: "D [de] MMMM [de] YYYY H:mm", LLLL: "dddd, D [de] MMMM [de] YYYY H:mm" }, calendar: { sameDay: function() {
            return "[hoy a la" + (1 !== this.hours() ? "s" : "") + "] LT";
          }, nextDay: function() {
            return "[mañana a la" + (1 !== this.hours() ? "s" : "") + "] LT";
          }, nextWeek: function() {
            return "dddd [a la" + (1 !== this.hours() ? "s" : "") + "] LT";
          }, lastDay: function() {
            return "[ayer a la" + (1 !== this.hours() ? "s" : "") + "] LT";
          }, lastWeek: function() {
            return "[el] dddd [pasado a la" + (1 !== this.hours() ? "s" : "") + "] LT";
          }, sameElse: "L" }, relativeTime: { future: "en %s", past: "hace %s", s: "unos segundos", ss: "%d segundos", m: "un minuto", mm: "%d minutos", h: "una hora", hh: "%d horas", d: "un día", dd: "%d días", w: "una semana", ww: "%d semanas", M: "un mes", MM: "%d meses", y: "un año", yy: "%d años" }, dayOfMonthOrdinalParse: /\d{1,2}º/, ordinal: "%dº", week: { dow: 0, doy: 4 }, invalidDate: "Fecha inválida" });
        })(n2(9034));
      }, 717: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          var a3 = "ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.".split("_"), n3 = "ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic".split("_"), t2 = [/^ene/i, /^feb/i, /^mar/i, /^abr/i, /^may/i, /^jun/i, /^jul/i, /^ago/i, /^sep/i, /^oct/i, /^nov/i, /^dic/i], c = /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;
          e3.defineLocale("es-us", { months: "enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre".split("_"), monthsShort: function(e4, t3) {
            return e4 ? /-MMM-/.test(t3) ? n3[e4.month()] : a3[e4.month()] : a3;
          }, monthsRegex: c, monthsShortRegex: c, monthsStrictRegex: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i, monthsShortStrictRegex: /^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i, monthsParse: t2, longMonthsParse: t2, shortMonthsParse: t2, weekdays: "domingo_lunes_martes_miércoles_jueves_viernes_sábado".split("_"), weekdaysShort: "dom._lun._mar._mié._jue._vie._sáb.".split("_"), weekdaysMin: "do_lu_ma_mi_ju_vi_sá".split("_"), weekdaysParseExact: true, longDateFormat: { LT: "h:mm A", LTS: "h:mm:ss A", L: "MM/DD/YYYY", LL: "D [de] MMMM [de] YYYY", LLL: "D [de] MMMM [de] YYYY h:mm A", LLLL: "dddd, D [de] MMMM [de] YYYY h:mm A" }, calendar: { sameDay: function() {
            return "[hoy a la" + (1 !== this.hours() ? "s" : "") + "] LT";
          }, nextDay: function() {
            return "[mañana a la" + (1 !== this.hours() ? "s" : "") + "] LT";
          }, nextWeek: function() {
            return "dddd [a la" + (1 !== this.hours() ? "s" : "") + "] LT";
          }, lastDay: function() {
            return "[ayer a la" + (1 !== this.hours() ? "s" : "") + "] LT";
          }, lastWeek: function() {
            return "[el] dddd [pasado a la" + (1 !== this.hours() ? "s" : "") + "] LT";
          }, sameElse: "L" }, relativeTime: { future: "en %s", past: "hace %s", s: "unos segundos", ss: "%d segundos", m: "un minuto", mm: "%d minutos", h: "una hora", hh: "%d horas", d: "un día", dd: "%d días", w: "una semana", ww: "%d semanas", M: "un mes", MM: "%d meses", y: "un año", yy: "%d años" }, dayOfMonthOrdinalParse: /\d{1,2}º/, ordinal: "%dº", week: { dow: 0, doy: 6 } });
        })(n2(9034));
      }, 3621: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          var a3 = "ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.".split("_"), n3 = "ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic".split("_"), t2 = [/^ene/i, /^feb/i, /^mar/i, /^abr/i, /^may/i, /^jun/i, /^jul/i, /^ago/i, /^sep/i, /^oct/i, /^nov/i, /^dic/i], c = /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;
          e3.defineLocale("es", { months: "enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre".split("_"), monthsShort: function(e4, t3) {
            return e4 ? /-MMM-/.test(t3) ? n3[e4.month()] : a3[e4.month()] : a3;
          }, monthsRegex: c, monthsShortRegex: c, monthsStrictRegex: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i, monthsShortStrictRegex: /^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i, monthsParse: t2, longMonthsParse: t2, shortMonthsParse: t2, weekdays: "domingo_lunes_martes_miércoles_jueves_viernes_sábado".split("_"), weekdaysShort: "dom._lun._mar._mié._jue._vie._sáb.".split("_"), weekdaysMin: "do_lu_ma_mi_ju_vi_sá".split("_"), weekdaysParseExact: true, longDateFormat: { LT: "H:mm", LTS: "H:mm:ss", L: "DD/MM/YYYY", LL: "D [de] MMMM [de] YYYY", LLL: "D [de] MMMM [de] YYYY H:mm", LLLL: "dddd, D [de] MMMM [de] YYYY H:mm" }, calendar: { sameDay: function() {
            return "[hoy a la" + (1 !== this.hours() ? "s" : "") + "] LT";
          }, nextDay: function() {
            return "[mañana a la" + (1 !== this.hours() ? "s" : "") + "] LT";
          }, nextWeek: function() {
            return "dddd [a la" + (1 !== this.hours() ? "s" : "") + "] LT";
          }, lastDay: function() {
            return "[ayer a la" + (1 !== this.hours() ? "s" : "") + "] LT";
          }, lastWeek: function() {
            return "[el] dddd [pasado a la" + (1 !== this.hours() ? "s" : "") + "] LT";
          }, sameElse: "L" }, relativeTime: { future: "en %s", past: "hace %s", s: "unos segundos", ss: "%d segundos", m: "un minuto", mm: "%d minutos", h: "una hora", hh: "%d horas", d: "un día", dd: "%d días", w: "una semana", ww: "%d semanas", M: "un mes", MM: "%d meses", y: "un año", yy: "%d años" }, dayOfMonthOrdinalParse: /\d{1,2}º/, ordinal: "%dº", week: { dow: 1, doy: 4 }, invalidDate: "Fecha inválida" });
        })(n2(9034));
      }, 2404: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          function a3(e4, a4, n3, t2) {
            var c = { s: ["mõne sekundi", "mõni sekund", "paar sekundit"], ss: [e4 + "sekundi", e4 + "sekundit"], m: ["ühe minuti", "üks minut"], mm: [e4 + " minuti", e4 + " minutit"], h: ["ühe tunni", "tund aega", "üks tund"], hh: [e4 + " tunni", e4 + " tundi"], d: ["ühe päeva", "üks päev"], M: ["kuu aja", "kuu aega", "üks kuu"], MM: [e4 + " kuu", e4 + " kuud"], y: ["ühe aasta", "aasta", "üks aasta"], yy: [e4 + " aasta", e4 + " aastat"] };
            return a4 ? c[n3][2] ? c[n3][2] : c[n3][1] : t2 ? c[n3][0] : c[n3][1];
          }
          e3.defineLocale("et", { months: "jaanuar_veebruar_märts_aprill_mai_juuni_juuli_august_september_oktoober_november_detsember".split("_"), monthsShort: "jaan_veebr_märts_apr_mai_juuni_juuli_aug_sept_okt_nov_dets".split("_"), weekdays: "pühapäev_esmaspäev_teisipäev_kolmapäev_neljapäev_reede_laupäev".split("_"), weekdaysShort: "P_E_T_K_N_R_L".split("_"), weekdaysMin: "P_E_T_K_N_R_L".split("_"), longDateFormat: { LT: "H:mm", LTS: "H:mm:ss", L: "DD.MM.YYYY", LL: "D. MMMM YYYY", LLL: "D. MMMM YYYY H:mm", LLLL: "dddd, D. MMMM YYYY H:mm" }, calendar: { sameDay: "[Täna,] LT", nextDay: "[Homme,] LT", nextWeek: "[Järgmine] dddd LT", lastDay: "[Eile,] LT", lastWeek: "[Eelmine] dddd LT", sameElse: "L" }, relativeTime: { future: "%s pärast", past: "%s tagasi", s: a3, ss: a3, m: a3, mm: a3, h: a3, hh: a3, d: a3, dd: "%d päeva", M: a3, MM: a3, y: a3, yy: a3 }, dayOfMonthOrdinalParse: /\d{1,2}\./, ordinal: "%d.", week: { dow: 1, doy: 4 } });
        })(n2(9034));
      }, 2944: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          e3.defineLocale("eu", { months: "urtarrila_otsaila_martxoa_apirila_maiatza_ekaina_uztaila_abuztua_iraila_urria_azaroa_abendua".split("_"), monthsShort: "urt._ots._mar._api._mai._eka._uzt._abu._ira._urr._aza._abe.".split("_"), monthsParseExact: true, weekdays: "igandea_astelehena_asteartea_asteazkena_osteguna_ostirala_larunbata".split("_"), weekdaysShort: "ig._al._ar._az._og._ol._lr.".split("_"), weekdaysMin: "ig_al_ar_az_og_ol_lr".split("_"), weekdaysParseExact: true, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "YYYY-MM-DD", LL: "YYYY[ko] MMMM[ren] D[a]", LLL: "YYYY[ko] MMMM[ren] D[a] HH:mm", LLLL: "dddd, YYYY[ko] MMMM[ren] D[a] HH:mm", l: "YYYY-M-D", ll: "YYYY[ko] MMM D[a]", lll: "YYYY[ko] MMM D[a] HH:mm", llll: "ddd, YYYY[ko] MMM D[a] HH:mm" }, calendar: { sameDay: "[gaur] LT[etan]", nextDay: "[bihar] LT[etan]", nextWeek: "dddd LT[etan]", lastDay: "[atzo] LT[etan]", lastWeek: "[aurreko] dddd LT[etan]", sameElse: "L" }, relativeTime: { future: "%s barru", past: "duela %s", s: "segundo batzuk", ss: "%d segundo", m: "minutu bat", mm: "%d minutu", h: "ordu bat", hh: "%d ordu", d: "egun bat", dd: "%d egun", M: "hilabete bat", MM: "%d hilabete", y: "urte bat", yy: "%d urte" }, dayOfMonthOrdinalParse: /\d{1,2}\./, ordinal: "%d.", week: { dow: 1, doy: 7 } });
        })(n2(9034));
      }, 496: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          var a3 = { 1: "۱", 2: "۲", 3: "۳", 4: "۴", 5: "۵", 6: "۶", 7: "۷", 8: "۸", 9: "۹", 0: "۰" }, n3 = { "۱": "1", "۲": "2", "۳": "3", "۴": "4", "۵": "5", "۶": "6", "۷": "7", "۸": "8", "۹": "9", "۰": "0" };
          e3.defineLocale("fa", { months: "ژانویه_فوریه_مارس_آوریل_مه_ژوئن_ژوئیه_اوت_سپتامبر_اکتبر_نوامبر_دسامبر".split("_"), monthsShort: "ژانویه_فوریه_مارس_آوریل_مه_ژوئن_ژوئیه_اوت_سپتامبر_اکتبر_نوامبر_دسامبر".split("_"), weekdays: "یک‌شنبه_دوشنبه_سه‌شنبه_چهارشنبه_پنج‌شنبه_جمعه_شنبه".split("_"), weekdaysShort: "یک‌شنبه_دوشنبه_سه‌شنبه_چهارشنبه_پنج‌شنبه_جمعه_شنبه".split("_"), weekdaysMin: "ی_د_س_چ_پ_ج_ش".split("_"), weekdaysParseExact: true, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" }, meridiemParse: /قبل از ظهر|بعد از ظهر/, isPM: function(e4) {
            return /بعد از ظهر/.test(e4);
          }, meridiem: function(e4, a4, n4) {
            return e4 < 12 ? "قبل از ظهر" : "بعد از ظهر";
          }, calendar: { sameDay: "[امروز ساعت] LT", nextDay: "[فردا ساعت] LT", nextWeek: "dddd [ساعت] LT", lastDay: "[دیروز ساعت] LT", lastWeek: "dddd [پیش] [ساعت] LT", sameElse: "L" }, relativeTime: { future: "در %s", past: "%s پیش", s: "چند ثانیه", ss: "%d ثانیه", m: "یک دقیقه", mm: "%d دقیقه", h: "یک ساعت", hh: "%d ساعت", d: "یک روز", dd: "%d روز", M: "یک ماه", MM: "%d ماه", y: "یک سال", yy: "%d سال" }, preparse: function(e4) {
            return e4.replace(/[۰-۹]/g, (function(e5) {
              return n3[e5];
            })).replace(/،/g, ",");
          }, postformat: function(e4) {
            return e4.replace(/\d/g, (function(e5) {
              return a3[e5];
            })).replace(/,/g, "،");
          }, dayOfMonthOrdinalParse: /\d{1,2}م/, ordinal: "%dم", week: { dow: 6, doy: 12 } });
        })(n2(9034));
      }, 8137: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          var a3 = "nolla yksi kaksi kolme neljä viisi kuusi seitsemän kahdeksan yhdeksän".split(" "), n3 = ["nolla", "yhden", "kahden", "kolmen", "neljän", "viiden", "kuuden", a3[7], a3[8], a3[9]];
          function t2(e4, t3, c, s) {
            var o = "";
            switch (c) {
              case "s":
                return s ? "muutaman sekunnin" : "muutama sekunti";
              case "ss":
                o = s ? "sekunnin" : "sekuntia";
                break;
              case "m":
                return s ? "minuutin" : "minuutti";
              case "mm":
                o = s ? "minuutin" : "minuuttia";
                break;
              case "h":
                return s ? "tunnin" : "tunti";
              case "hh":
                o = s ? "tunnin" : "tuntia";
                break;
              case "d":
                return s ? "päivän" : "päivä";
              case "dd":
                o = s ? "päivän" : "päivää";
                break;
              case "M":
                return s ? "kuukauden" : "kuukausi";
              case "MM":
                o = s ? "kuukauden" : "kuukautta";
                break;
              case "y":
                return s ? "vuoden" : "vuosi";
              case "yy":
                o = s ? "vuoden" : "vuotta";
            }
            return (function(e5, t4) {
              return e5 < 10 ? t4 ? n3[e5] : a3[e5] : e5;
            })(e4, s) + " " + o;
          }
          e3.defineLocale("fi", { months: "tammikuu_helmikuu_maaliskuu_huhtikuu_toukokuu_kesäkuu_heinäkuu_elokuu_syyskuu_lokakuu_marraskuu_joulukuu".split("_"), monthsShort: "tammi_helmi_maalis_huhti_touko_kesä_heinä_elo_syys_loka_marras_joulu".split("_"), weekdays: "sunnuntai_maanantai_tiistai_keskiviikko_torstai_perjantai_lauantai".split("_"), weekdaysShort: "su_ma_ti_ke_to_pe_la".split("_"), weekdaysMin: "su_ma_ti_ke_to_pe_la".split("_"), longDateFormat: { LT: "HH.mm", LTS: "HH.mm.ss", L: "DD.MM.YYYY", LL: "Do MMMM[ta] YYYY", LLL: "Do MMMM[ta] YYYY, [klo] HH.mm", LLLL: "dddd, Do MMMM[ta] YYYY, [klo] HH.mm", l: "D.M.YYYY", ll: "Do MMM YYYY", lll: "Do MMM YYYY, [klo] HH.mm", llll: "ddd, Do MMM YYYY, [klo] HH.mm" }, calendar: { sameDay: "[tänään] [klo] LT", nextDay: "[huomenna] [klo] LT", nextWeek: "dddd [klo] LT", lastDay: "[eilen] [klo] LT", lastWeek: "[viime] dddd[na] [klo] LT", sameElse: "L" }, relativeTime: { future: "%s päästä", past: "%s sitten", s: t2, ss: t2, m: t2, mm: t2, h: t2, hh: t2, d: t2, dd: t2, M: t2, MM: t2, y: t2, yy: t2 }, dayOfMonthOrdinalParse: /\d{1,2}\./, ordinal: "%d.", week: { dow: 1, doy: 4 } });
        })(n2(9034));
      }, 2872: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          e3.defineLocale("fil", { months: "Enero_Pebrero_Marso_Abril_Mayo_Hunyo_Hulyo_Agosto_Setyembre_Oktubre_Nobyembre_Disyembre".split("_"), monthsShort: "Ene_Peb_Mar_Abr_May_Hun_Hul_Ago_Set_Okt_Nob_Dis".split("_"), weekdays: "Linggo_Lunes_Martes_Miyerkules_Huwebes_Biyernes_Sabado".split("_"), weekdaysShort: "Lin_Lun_Mar_Miy_Huw_Biy_Sab".split("_"), weekdaysMin: "Li_Lu_Ma_Mi_Hu_Bi_Sab".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "MM/D/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY HH:mm", LLLL: "dddd, MMMM DD, YYYY HH:mm" }, calendar: { sameDay: "LT [ngayong araw]", nextDay: "[Bukas ng] LT", nextWeek: "LT [sa susunod na] dddd", lastDay: "LT [kahapon]", lastWeek: "LT [noong nakaraang] dddd", sameElse: "L" }, relativeTime: { future: "sa loob ng %s", past: "%s ang nakalipas", s: "ilang segundo", ss: "%d segundo", m: "isang minuto", mm: "%d minuto", h: "isang oras", hh: "%d oras", d: "isang araw", dd: "%d araw", M: "isang buwan", MM: "%d buwan", y: "isang taon", yy: "%d taon" }, dayOfMonthOrdinalParse: /\d{1,2}/, ordinal: function(e4) {
            return e4;
          }, week: { dow: 1, doy: 4 } });
        })(n2(9034));
      }, 6545: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          e3.defineLocale("fo", { months: "januar_februar_mars_apríl_mai_juni_juli_august_september_oktober_november_desember".split("_"), monthsShort: "jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des".split("_"), weekdays: "sunnudagur_mánadagur_týsdagur_mikudagur_hósdagur_fríggjadagur_leygardagur".split("_"), weekdaysShort: "sun_mán_týs_mik_hós_frí_ley".split("_"), weekdaysMin: "su_má_tý_mi_hó_fr_le".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D. MMMM, YYYY HH:mm" }, calendar: { sameDay: "[Í dag kl.] LT", nextDay: "[Í morgin kl.] LT", nextWeek: "dddd [kl.] LT", lastDay: "[Í gjár kl.] LT", lastWeek: "[síðstu] dddd [kl] LT", sameElse: "L" }, relativeTime: { future: "um %s", past: "%s síðani", s: "fá sekund", ss: "%d sekundir", m: "ein minuttur", mm: "%d minuttir", h: "ein tími", hh: "%d tímar", d: "ein dagur", dd: "%d dagar", M: "ein mánaður", MM: "%d mánaðir", y: "eitt ár", yy: "%d ár" }, dayOfMonthOrdinalParse: /\d{1,2}\./, ordinal: "%d.", week: { dow: 1, doy: 4 } });
        })(n2(9034));
      }, 3049: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          e3.defineLocale("fr-ca", { months: "janvier_février_mars_avril_mai_juin_juillet_août_septembre_octobre_novembre_décembre".split("_"), monthsShort: "janv._févr._mars_avr._mai_juin_juil._août_sept._oct._nov._déc.".split("_"), monthsParseExact: true, weekdays: "dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi".split("_"), weekdaysShort: "dim._lun._mar._mer._jeu._ven._sam.".split("_"), weekdaysMin: "di_lu_ma_me_je_ve_sa".split("_"), weekdaysParseExact: true, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "YYYY-MM-DD", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D MMMM YYYY HH:mm" }, calendar: { sameDay: "[Aujourd’hui à] LT", nextDay: "[Demain à] LT", nextWeek: "dddd [à] LT", lastDay: "[Hier à] LT", lastWeek: "dddd [dernier à] LT", sameElse: "L" }, relativeTime: { future: "dans %s", past: "il y a %s", s: "quelques secondes", ss: "%d secondes", m: "une minute", mm: "%d minutes", h: "une heure", hh: "%d heures", d: "un jour", dd: "%d jours", M: "un mois", MM: "%d mois", y: "un an", yy: "%d ans" }, dayOfMonthOrdinalParse: /\d{1,2}(er|e)/, ordinal: function(e4, a3) {
            switch (a3) {
              default:
              case "M":
              case "Q":
              case "D":
              case "DDD":
              case "d":
                return e4 + (1 === e4 ? "er" : "e");
              case "w":
              case "W":
                return e4 + (1 === e4 ? "re" : "e");
            }
          } });
        })(n2(9034));
      }, 2338: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          e3.defineLocale("fr-ch", { months: "janvier_février_mars_avril_mai_juin_juillet_août_septembre_octobre_novembre_décembre".split("_"), monthsShort: "janv._févr._mars_avr._mai_juin_juil._août_sept._oct._nov._déc.".split("_"), monthsParseExact: true, weekdays: "dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi".split("_"), weekdaysShort: "dim._lun._mar._mer._jeu._ven._sam.".split("_"), weekdaysMin: "di_lu_ma_me_je_ve_sa".split("_"), weekdaysParseExact: true, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD.MM.YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D MMMM YYYY HH:mm" }, calendar: { sameDay: "[Aujourd’hui à] LT", nextDay: "[Demain à] LT", nextWeek: "dddd [à] LT", lastDay: "[Hier à] LT", lastWeek: "dddd [dernier à] LT", sameElse: "L" }, relativeTime: { future: "dans %s", past: "il y a %s", s: "quelques secondes", ss: "%d secondes", m: "une minute", mm: "%d minutes", h: "une heure", hh: "%d heures", d: "un jour", dd: "%d jours", M: "un mois", MM: "%d mois", y: "un an", yy: "%d ans" }, dayOfMonthOrdinalParse: /\d{1,2}(er|e)/, ordinal: function(e4, a3) {
            switch (a3) {
              default:
              case "M":
              case "Q":
              case "D":
              case "DDD":
              case "d":
                return e4 + (1 === e4 ? "er" : "e");
              case "w":
              case "W":
                return e4 + (1 === e4 ? "re" : "e");
            }
          }, week: { dow: 1, doy: 4 } });
        })(n2(9034));
      }, 9090: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          var a3 = /(janv\.?|févr\.?|mars|avr\.?|mai|juin|juil\.?|août|sept\.?|oct\.?|nov\.?|déc\.?|janvier|février|mars|avril|mai|juin|juillet|août|septembre|octobre|novembre|décembre)/i, n3 = [/^janv/i, /^févr/i, /^mars/i, /^avr/i, /^mai/i, /^juin/i, /^juil/i, /^août/i, /^sept/i, /^oct/i, /^nov/i, /^déc/i];
          e3.defineLocale("fr", { months: "janvier_février_mars_avril_mai_juin_juillet_août_septembre_octobre_novembre_décembre".split("_"), monthsShort: "janv._févr._mars_avr._mai_juin_juil._août_sept._oct._nov._déc.".split("_"), monthsRegex: a3, monthsShortRegex: a3, monthsStrictRegex: /^(janvier|février|mars|avril|mai|juin|juillet|août|septembre|octobre|novembre|décembre)/i, monthsShortStrictRegex: /(janv\.?|févr\.?|mars|avr\.?|mai|juin|juil\.?|août|sept\.?|oct\.?|nov\.?|déc\.?)/i, monthsParse: n3, longMonthsParse: n3, shortMonthsParse: n3, weekdays: "dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi".split("_"), weekdaysShort: "dim._lun._mar._mer._jeu._ven._sam.".split("_"), weekdaysMin: "di_lu_ma_me_je_ve_sa".split("_"), weekdaysParseExact: true, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D MMMM YYYY HH:mm" }, calendar: { sameDay: "[Aujourd’hui à] LT", nextDay: "[Demain à] LT", nextWeek: "dddd [à] LT", lastDay: "[Hier à] LT", lastWeek: "dddd [dernier à] LT", sameElse: "L" }, relativeTime: { future: "dans %s", past: "il y a %s", s: "quelques secondes", ss: "%d secondes", m: "une minute", mm: "%d minutes", h: "une heure", hh: "%d heures", d: "un jour", dd: "%d jours", w: "une semaine", ww: "%d semaines", M: "un mois", MM: "%d mois", y: "un an", yy: "%d ans" }, dayOfMonthOrdinalParse: /\d{1,2}(er|)/, ordinal: function(e4, a4) {
            switch (a4) {
              case "D":
                return e4 + (1 === e4 ? "er" : "");
              default:
              case "M":
              case "Q":
              case "DDD":
              case "d":
                return e4 + (1 === e4 ? "er" : "e");
              case "w":
              case "W":
                return e4 + (1 === e4 ? "re" : "e");
            }
          }, week: { dow: 1, doy: 4 } });
        })(n2(9034));
      }, 5088: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          var a3 = "jan._feb._mrt._apr._mai_jun._jul._aug._sep._okt._nov._des.".split("_"), n3 = "jan_feb_mrt_apr_mai_jun_jul_aug_sep_okt_nov_des".split("_");
          e3.defineLocale("fy", { months: "jannewaris_febrewaris_maart_april_maaie_juny_july_augustus_septimber_oktober_novimber_desimber".split("_"), monthsShort: function(e4, t2) {
            return e4 ? /-MMM-/.test(t2) ? n3[e4.month()] : a3[e4.month()] : a3;
          }, monthsParseExact: true, weekdays: "snein_moandei_tiisdei_woansdei_tongersdei_freed_sneon".split("_"), weekdaysShort: "si._mo._ti._wo._to._fr._so.".split("_"), weekdaysMin: "Si_Mo_Ti_Wo_To_Fr_So".split("_"), weekdaysParseExact: true, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD-MM-YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D MMMM YYYY HH:mm" }, calendar: { sameDay: "[hjoed om] LT", nextDay: "[moarn om] LT", nextWeek: "dddd [om] LT", lastDay: "[juster om] LT", lastWeek: "[ôfrûne] dddd [om] LT", sameElse: "L" }, relativeTime: { future: "oer %s", past: "%s lyn", s: "in pear sekonden", ss: "%d sekonden", m: "ien minút", mm: "%d minuten", h: "ien oere", hh: "%d oeren", d: "ien dei", dd: "%d dagen", M: "ien moanne", MM: "%d moannen", y: "ien jier", yy: "%d jierren" }, dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/, ordinal: function(e4) {
            return e4 + (1 === e4 || 8 === e4 || e4 >= 20 ? "ste" : "de");
          }, week: { dow: 1, doy: 4 } });
        })(n2(9034));
      }, 7812: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          e3.defineLocale("ga", { months: ["Eanáir", "Feabhra", "Márta", "Aibreán", "Bealtaine", "Meitheamh", "Iúil", "Lúnasa", "Meán Fómhair", "Deireadh Fómhair", "Samhain", "Nollaig"], monthsShort: ["Ean", "Feabh", "Márt", "Aib", "Beal", "Meith", "Iúil", "Lún", "M.F.", "D.F.", "Samh", "Noll"], monthsParseExact: true, weekdays: ["Dé Domhnaigh", "Dé Luain", "Dé Máirt", "Dé Céadaoin", "Déardaoin", "Dé hAoine", "Dé Sathairn"], weekdaysShort: ["Domh", "Luan", "Máirt", "Céad", "Déar", "Aoine", "Sath"], weekdaysMin: ["Do", "Lu", "Má", "Cé", "Dé", "A", "Sa"], longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" }, calendar: { sameDay: "[Inniu ag] LT", nextDay: "[Amárach ag] LT", nextWeek: "dddd [ag] LT", lastDay: "[Inné ag] LT", lastWeek: "dddd [seo caite] [ag] LT", sameElse: "L" }, relativeTime: { future: "i %s", past: "%s ó shin", s: "cúpla soicind", ss: "%d soicind", m: "nóiméad", mm: "%d nóiméad", h: "uair an chloig", hh: "%d uair an chloig", d: "lá", dd: "%d lá", M: "mí", MM: "%d míonna", y: "bliain", yy: "%d bliain" }, dayOfMonthOrdinalParse: /\d{1,2}(d|na|mh)/, ordinal: function(e4) {
            return e4 + (1 === e4 ? "d" : e4 % 10 == 2 ? "na" : "mh");
          }, week: { dow: 1, doy: 4 } });
        })(n2(9034));
      }, 8374: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          e3.defineLocale("gd", { months: ["Am Faoilleach", "An Gearran", "Am Màrt", "An Giblean", "An Cèitean", "An t-Ògmhios", "An t-Iuchar", "An Lùnastal", "An t-Sultain", "An Dàmhair", "An t-Samhain", "An Dùbhlachd"], monthsShort: ["Faoi", "Gear", "Màrt", "Gibl", "Cèit", "Ògmh", "Iuch", "Lùn", "Sult", "Dàmh", "Samh", "Dùbh"], monthsParseExact: true, weekdays: ["Didòmhnaich", "Diluain", "Dimàirt", "Diciadain", "Diardaoin", "Dihaoine", "Disathairne"], weekdaysShort: ["Did", "Dil", "Dim", "Dic", "Dia", "Dih", "Dis"], weekdaysMin: ["Dò", "Lu", "Mà", "Ci", "Ar", "Ha", "Sa"], longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" }, calendar: { sameDay: "[An-diugh aig] LT", nextDay: "[A-màireach aig] LT", nextWeek: "dddd [aig] LT", lastDay: "[An-dè aig] LT", lastWeek: "dddd [seo chaidh] [aig] LT", sameElse: "L" }, relativeTime: { future: "ann an %s", past: "bho chionn %s", s: "beagan diogan", ss: "%d diogan", m: "mionaid", mm: "%d mionaidean", h: "uair", hh: "%d uairean", d: "latha", dd: "%d latha", M: "mìos", MM: "%d mìosan", y: "bliadhna", yy: "%d bliadhna" }, dayOfMonthOrdinalParse: /\d{1,2}(d|na|mh)/, ordinal: function(e4) {
            return e4 + (1 === e4 ? "d" : e4 % 10 == 2 ? "na" : "mh");
          }, week: { dow: 1, doy: 4 } });
        })(n2(9034));
      }, 3649: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          e3.defineLocale("gl", { months: "xaneiro_febreiro_marzo_abril_maio_xuño_xullo_agosto_setembro_outubro_novembro_decembro".split("_"), monthsShort: "xan._feb._mar._abr._mai._xuñ._xul._ago._set._out._nov._dec.".split("_"), monthsParseExact: true, weekdays: "domingo_luns_martes_mércores_xoves_venres_sábado".split("_"), weekdaysShort: "dom._lun._mar._mér._xov._ven._sáb.".split("_"), weekdaysMin: "do_lu_ma_mé_xo_ve_sá".split("_"), weekdaysParseExact: true, longDateFormat: { LT: "H:mm", LTS: "H:mm:ss", L: "DD/MM/YYYY", LL: "D [de] MMMM [de] YYYY", LLL: "D [de] MMMM [de] YYYY H:mm", LLLL: "dddd, D [de] MMMM [de] YYYY H:mm" }, calendar: { sameDay: function() {
            return "[hoxe " + (1 !== this.hours() ? "ás" : "á") + "] LT";
          }, nextDay: function() {
            return "[mañá " + (1 !== this.hours() ? "ás" : "á") + "] LT";
          }, nextWeek: function() {
            return "dddd [" + (1 !== this.hours() ? "ás" : "a") + "] LT";
          }, lastDay: function() {
            return "[onte " + (1 !== this.hours() ? "á" : "a") + "] LT";
          }, lastWeek: function() {
            return "[o] dddd [pasado " + (1 !== this.hours() ? "ás" : "a") + "] LT";
          }, sameElse: "L" }, relativeTime: { future: function(e4) {
            return 0 === e4.indexOf("un") ? "n" + e4 : "en " + e4;
          }, past: "hai %s", s: "uns segundos", ss: "%d segundos", m: "un minuto", mm: "%d minutos", h: "unha hora", hh: "%d horas", d: "un día", dd: "%d días", M: "un mes", MM: "%d meses", y: "un ano", yy: "%d anos" }, dayOfMonthOrdinalParse: /\d{1,2}º/, ordinal: "%dº", week: { dow: 1, doy: 4 } });
        })(n2(9034));
      }, 2674: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          function a3(e4, a4, n3, t2) {
            var c = { s: ["थोडया सॅकंडांनी", "थोडे सॅकंड"], ss: [e4 + " सॅकंडांनी", e4 + " सॅकंड"], m: ["एका मिणटान", "एक मिनूट"], mm: [e4 + " मिणटांनी", e4 + " मिणटां"], h: ["एका वरान", "एक वर"], hh: [e4 + " वरांनी", e4 + " वरां"], d: ["एका दिसान", "एक दीस"], dd: [e4 + " दिसांनी", e4 + " दीस"], M: ["एका म्हयन्यान", "एक म्हयनो"], MM: [e4 + " म्हयन्यानी", e4 + " म्हयने"], y: ["एका वर्सान", "एक वर्स"], yy: [e4 + " वर्सांनी", e4 + " वर्सां"] };
            return t2 ? c[n3][0] : c[n3][1];
          }
          e3.defineLocale("gom-deva", { months: { standalone: "जानेवारी_फेब्रुवारी_मार्च_एप्रील_मे_जून_जुलय_ऑगस्ट_सप्टेंबर_ऑक्टोबर_नोव्हेंबर_डिसेंबर".split("_"), format: "जानेवारीच्या_फेब्रुवारीच्या_मार्चाच्या_एप्रीलाच्या_मेयाच्या_जूनाच्या_जुलयाच्या_ऑगस्टाच्या_सप्टेंबराच्या_ऑक्टोबराच्या_नोव्हेंबराच्या_डिसेंबराच्या".split("_"), isFormat: /MMMM(\s)+D[oD]?/ }, monthsShort: "जाने._फेब्रु._मार्च_एप्री._मे_जून_जुल._ऑग._सप्टें._ऑक्टो._नोव्हें._डिसें.".split("_"), monthsParseExact: true, weekdays: "आयतार_सोमार_मंगळार_बुधवार_बिरेस्तार_सुक्रार_शेनवार".split("_"), weekdaysShort: "आयत._सोम._मंगळ._बुध._ब्रेस्त._सुक्र._शेन.".split("_"), weekdaysMin: "आ_सो_मं_बु_ब्रे_सु_शे".split("_"), weekdaysParseExact: true, longDateFormat: { LT: "A h:mm [वाजतां]", LTS: "A h:mm:ss [वाजतां]", L: "DD-MM-YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY A h:mm [वाजतां]", LLLL: "dddd, MMMM Do, YYYY, A h:mm [वाजतां]", llll: "ddd, D MMM YYYY, A h:mm [वाजतां]" }, calendar: { sameDay: "[आयज] LT", nextDay: "[फाल्यां] LT", nextWeek: "[फुडलो] dddd[,] LT", lastDay: "[काल] LT", lastWeek: "[फाटलो] dddd[,] LT", sameElse: "L" }, relativeTime: { future: "%s", past: "%s आदीं", s: a3, ss: a3, m: a3, mm: a3, h: a3, hh: a3, d: a3, dd: a3, M: a3, MM: a3, y: a3, yy: a3 }, dayOfMonthOrdinalParse: /\d{1,2}(वेर)/, ordinal: function(e4, a4) {
            return "D" === a4 ? e4 + "वेर" : e4;
          }, week: { dow: 0, doy: 3 }, meridiemParse: /राती|सकाळीं|दनपारां|सांजे/, meridiemHour: function(e4, a4) {
            return 12 === e4 && (e4 = 0), "राती" === a4 ? e4 < 4 ? e4 : e4 + 12 : "सकाळीं" === a4 ? e4 : "दनपारां" === a4 ? e4 > 12 ? e4 : e4 + 12 : "सांजे" === a4 ? e4 + 12 : void 0;
          }, meridiem: function(e4, a4, n3) {
            return e4 < 4 ? "राती" : e4 < 12 ? "सकाळीं" : e4 < 16 ? "दनपारां" : e4 < 20 ? "सांजे" : "राती";
          } });
        })(n2(9034));
      }, 4948: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          function a3(e4, a4, n3, t2) {
            var c = { s: ["thoddea sekondamni", "thodde sekond"], ss: [e4 + " sekondamni", e4 + " sekond"], m: ["eka mintan", "ek minut"], mm: [e4 + " mintamni", e4 + " mintam"], h: ["eka voran", "ek vor"], hh: [e4 + " voramni", e4 + " voram"], d: ["eka disan", "ek dis"], dd: [e4 + " disamni", e4 + " dis"], M: ["eka mhoinean", "ek mhoino"], MM: [e4 + " mhoineamni", e4 + " mhoine"], y: ["eka vorsan", "ek voros"], yy: [e4 + " vorsamni", e4 + " vorsam"] };
            return t2 ? c[n3][0] : c[n3][1];
          }
          e3.defineLocale("gom-latn", { months: { standalone: "Janer_Febrer_Mars_Abril_Mai_Jun_Julai_Agost_Setembr_Otubr_Novembr_Dezembr".split("_"), format: "Janerachea_Febrerachea_Marsachea_Abrilachea_Maiachea_Junachea_Julaiachea_Agostachea_Setembrachea_Otubrachea_Novembrachea_Dezembrachea".split("_"), isFormat: /MMMM(\s)+D[oD]?/ }, monthsShort: "Jan._Feb._Mars_Abr._Mai_Jun_Jul._Ago._Set._Otu._Nov._Dez.".split("_"), monthsParseExact: true, weekdays: "Aitar_Somar_Mongllar_Budhvar_Birestar_Sukrar_Son'var".split("_"), weekdaysShort: "Ait._Som._Mon._Bud._Bre._Suk._Son.".split("_"), weekdaysMin: "Ai_Sm_Mo_Bu_Br_Su_Sn".split("_"), weekdaysParseExact: true, longDateFormat: { LT: "A h:mm [vazta]", LTS: "A h:mm:ss [vazta]", L: "DD-MM-YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY A h:mm [vazta]", LLLL: "dddd, MMMM Do, YYYY, A h:mm [vazta]", llll: "ddd, D MMM YYYY, A h:mm [vazta]" }, calendar: { sameDay: "[Aiz] LT", nextDay: "[Faleam] LT", nextWeek: "[Fuddlo] dddd[,] LT", lastDay: "[Kal] LT", lastWeek: "[Fattlo] dddd[,] LT", sameElse: "L" }, relativeTime: { future: "%s", past: "%s adim", s: a3, ss: a3, m: a3, mm: a3, h: a3, hh: a3, d: a3, dd: a3, M: a3, MM: a3, y: a3, yy: a3 }, dayOfMonthOrdinalParse: /\d{1,2}(er)/, ordinal: function(e4, a4) {
            return "D" === a4 ? e4 + "er" : e4;
          }, week: { dow: 0, doy: 3 }, meridiemParse: /rati|sokallim|donparam|sanje/, meridiemHour: function(e4, a4) {
            return 12 === e4 && (e4 = 0), "rati" === a4 ? e4 < 4 ? e4 : e4 + 12 : "sokallim" === a4 ? e4 : "donparam" === a4 ? e4 > 12 ? e4 : e4 + 12 : "sanje" === a4 ? e4 + 12 : void 0;
          }, meridiem: function(e4, a4, n3) {
            return e4 < 4 ? "rati" : e4 < 12 ? "sokallim" : e4 < 16 ? "donparam" : e4 < 20 ? "sanje" : "rati";
          } });
        })(n2(9034));
      }, 4033: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          var a3 = { 1: "૧", 2: "૨", 3: "૩", 4: "૪", 5: "૫", 6: "૬", 7: "૭", 8: "૮", 9: "૯", 0: "૦" }, n3 = { "૧": "1", "૨": "2", "૩": "3", "૪": "4", "૫": "5", "૬": "6", "૭": "7", "૮": "8", "૯": "9", "૦": "0" };
          e3.defineLocale("gu", { months: "જાન્યુઆરી_ફેબ્રુઆરી_માર્ચ_એપ્રિલ_મે_જૂન_જુલાઈ_ઑગસ્ટ_સપ્ટેમ્બર_ઑક્ટ્બર_નવેમ્બર_ડિસેમ્બર".split("_"), monthsShort: "જાન્યુ._ફેબ્રુ._માર્ચ_એપ્રિ._મે_જૂન_જુલા._ઑગ._સપ્ટે._ઑક્ટ્._નવે._ડિસે.".split("_"), monthsParseExact: true, weekdays: "રવિવાર_સોમવાર_મંગળવાર_બુધ્વાર_ગુરુવાર_શુક્રવાર_શનિવાર".split("_"), weekdaysShort: "રવિ_સોમ_મંગળ_બુધ્_ગુરુ_શુક્ર_શનિ".split("_"), weekdaysMin: "ર_સો_મં_બુ_ગુ_શુ_શ".split("_"), longDateFormat: { LT: "A h:mm વાગ્યે", LTS: "A h:mm:ss વાગ્યે", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY, A h:mm વાગ્યે", LLLL: "dddd, D MMMM YYYY, A h:mm વાગ્યે" }, calendar: { sameDay: "[આજ] LT", nextDay: "[કાલે] LT", nextWeek: "dddd, LT", lastDay: "[ગઇકાલે] LT", lastWeek: "[પાછલા] dddd, LT", sameElse: "L" }, relativeTime: { future: "%s મા", past: "%s પહેલા", s: "અમુક પળો", ss: "%d સેકંડ", m: "એક મિનિટ", mm: "%d મિનિટ", h: "એક કલાક", hh: "%d કલાક", d: "એક દિવસ", dd: "%d દિવસ", M: "એક મહિનો", MM: "%d મહિનો", y: "એક વર્ષ", yy: "%d વર્ષ" }, preparse: function(e4) {
            return e4.replace(/[૧૨૩૪૫૬૭૮૯૦]/g, (function(e5) {
              return n3[e5];
            }));
          }, postformat: function(e4) {
            return e4.replace(/\d/g, (function(e5) {
              return a3[e5];
            }));
          }, meridiemParse: /રાત|બપોર|સવાર|સાંજ/, meridiemHour: function(e4, a4) {
            return 12 === e4 && (e4 = 0), "રાત" === a4 ? e4 < 4 ? e4 : e4 + 12 : "સવાર" === a4 ? e4 : "બપોર" === a4 ? e4 >= 10 ? e4 : e4 + 12 : "સાંજ" === a4 ? e4 + 12 : void 0;
          }, meridiem: function(e4, a4, n4) {
            return e4 < 4 ? "રાત" : e4 < 10 ? "સવાર" : e4 < 17 ? "બપોર" : e4 < 20 ? "સાંજ" : "રાત";
          }, week: { dow: 0, doy: 6 } });
        })(n2(9034));
      }, 175: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          e3.defineLocale("he", { months: "ינואר_פברואר_מרץ_אפריל_מאי_יוני_יולי_אוגוסט_ספטמבר_אוקטובר_נובמבר_דצמבר".split("_"), monthsShort: "ינו׳_פבר׳_מרץ_אפר׳_מאי_יוני_יולי_אוג׳_ספט׳_אוק׳_נוב׳_דצמ׳".split("_"), weekdays: "ראשון_שני_שלישי_רביעי_חמישי_שישי_שבת".split("_"), weekdaysShort: "א׳_ב׳_ג׳_ד׳_ה׳_ו׳_ש׳".split("_"), weekdaysMin: "א_ב_ג_ד_ה_ו_ש".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D [ב]MMMM YYYY", LLL: "D [ב]MMMM YYYY HH:mm", LLLL: "dddd, D [ב]MMMM YYYY HH:mm", l: "D/M/YYYY", ll: "D MMM YYYY", lll: "D MMM YYYY HH:mm", llll: "ddd, D MMM YYYY HH:mm" }, calendar: { sameDay: "[היום ב־]LT", nextDay: "[מחר ב־]LT", nextWeek: "dddd [בשעה] LT", lastDay: "[אתמול ב־]LT", lastWeek: "[ביום] dddd [האחרון בשעה] LT", sameElse: "L" }, relativeTime: { future: "בעוד %s", past: "לפני %s", s: "מספר שניות", ss: "%d שניות", m: "דקה", mm: "%d דקות", h: "שעה", hh: function(e4) {
            return 2 === e4 ? "שעתיים" : e4 + " שעות";
          }, d: "יום", dd: function(e4) {
            return 2 === e4 ? "יומיים" : e4 + " ימים";
          }, M: "חודש", MM: function(e4) {
            return 2 === e4 ? "חודשיים" : e4 + " חודשים";
          }, y: "שנה", yy: function(e4) {
            return 2 === e4 ? "שנתיים" : e4 % 10 == 0 && 10 !== e4 ? e4 + " שנה" : e4 + " שנים";
          } }, meridiemParse: /אחה"צ|לפנה"צ|אחרי הצהריים|לפני הצהריים|לפנות בוקר|בבוקר|בערב/i, isPM: function(e4) {
            return /^(אחה"צ|אחרי הצהריים|בערב)$/.test(e4);
          }, meridiem: function(e4, a3, n3) {
            return e4 < 5 ? "לפנות בוקר" : e4 < 10 ? "בבוקר" : e4 < 12 ? n3 ? 'לפנה"צ' : "לפני הצהריים" : e4 < 18 ? n3 ? 'אחה"צ' : "אחרי הצהריים" : "בערב";
          } });
        })(n2(9034));
      }, 8055: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          var a3 = { 1: "१", 2: "२", 3: "३", 4: "४", 5: "५", 6: "६", 7: "७", 8: "८", 9: "९", 0: "०" }, n3 = { "१": "1", "२": "2", "३": "3", "४": "4", "५": "5", "६": "6", "७": "7", "८": "8", "९": "9", "०": "0" }, t2 = [/^जन/i, /^फ़र|फर/i, /^मार्च/i, /^अप्रै/i, /^मई/i, /^जून/i, /^जुल/i, /^अग/i, /^सितं|सित/i, /^अक्टू/i, /^नव|नवं/i, /^दिसं|दिस/i];
          e3.defineLocale("hi", { months: { format: "जनवरी_फ़रवरी_मार्च_अप्रैल_मई_जून_जुलाई_अगस्त_सितम्बर_अक्टूबर_नवम्बर_दिसम्बर".split("_"), standalone: "जनवरी_फरवरी_मार्च_अप्रैल_मई_जून_जुलाई_अगस्त_सितंबर_अक्टूबर_नवंबर_दिसंबर".split("_") }, monthsShort: "जन._फ़र._मार्च_अप्रै._मई_जून_जुल._अग._सित._अक्टू._नव._दिस.".split("_"), weekdays: "रविवार_सोमवार_मंगलवार_बुधवार_गुरूवार_शुक्रवार_शनिवार".split("_"), weekdaysShort: "रवि_सोम_मंगल_बुध_गुरू_शुक्र_शनि".split("_"), weekdaysMin: "र_सो_मं_बु_गु_शु_श".split("_"), longDateFormat: { LT: "A h:mm बजे", LTS: "A h:mm:ss बजे", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY, A h:mm बजे", LLLL: "dddd, D MMMM YYYY, A h:mm बजे" }, monthsParse: t2, longMonthsParse: t2, shortMonthsParse: [/^जन/i, /^फ़र/i, /^मार्च/i, /^अप्रै/i, /^मई/i, /^जून/i, /^जुल/i, /^अग/i, /^सित/i, /^अक्टू/i, /^नव/i, /^दिस/i], monthsRegex: /^(जनवरी|जन\.?|फ़रवरी|फरवरी|फ़र\.?|मार्च?|अप्रैल|अप्रै\.?|मई?|जून?|जुलाई|जुल\.?|अगस्त|अग\.?|सितम्बर|सितंबर|सित\.?|अक्टूबर|अक्टू\.?|नवम्बर|नवंबर|नव\.?|दिसम्बर|दिसंबर|दिस\.?)/i, monthsShortRegex: /^(जनवरी|जन\.?|फ़रवरी|फरवरी|फ़र\.?|मार्च?|अप्रैल|अप्रै\.?|मई?|जून?|जुलाई|जुल\.?|अगस्त|अग\.?|सितम्बर|सितंबर|सित\.?|अक्टूबर|अक्टू\.?|नवम्बर|नवंबर|नव\.?|दिसम्बर|दिसंबर|दिस\.?)/i, monthsStrictRegex: /^(जनवरी?|फ़रवरी|फरवरी?|मार्च?|अप्रैल?|मई?|जून?|जुलाई?|अगस्त?|सितम्बर|सितंबर|सित?\.?|अक्टूबर|अक्टू\.?|नवम्बर|नवंबर?|दिसम्बर|दिसंबर?)/i, monthsShortStrictRegex: /^(जन\.?|फ़र\.?|मार्च?|अप्रै\.?|मई?|जून?|जुल\.?|अग\.?|सित\.?|अक्टू\.?|नव\.?|दिस\.?)/i, calendar: { sameDay: "[आज] LT", nextDay: "[कल] LT", nextWeek: "dddd, LT", lastDay: "[कल] LT", lastWeek: "[पिछले] dddd, LT", sameElse: "L" }, relativeTime: { future: "%s में", past: "%s पहले", s: "कुछ ही क्षण", ss: "%d सेकंड", m: "एक मिनट", mm: "%d मिनट", h: "एक घंटा", hh: "%d घंटे", d: "एक दिन", dd: "%d दिन", M: "एक महीने", MM: "%d महीने", y: "एक वर्ष", yy: "%d वर्ष" }, preparse: function(e4) {
            return e4.replace(/[१२३४५६७८९०]/g, (function(e5) {
              return n3[e5];
            }));
          }, postformat: function(e4) {
            return e4.replace(/\d/g, (function(e5) {
              return a3[e5];
            }));
          }, meridiemParse: /रात|सुबह|दोपहर|शाम/, meridiemHour: function(e4, a4) {
            return 12 === e4 && (e4 = 0), "रात" === a4 ? e4 < 4 ? e4 : e4 + 12 : "सुबह" === a4 ? e4 : "दोपहर" === a4 ? e4 >= 10 ? e4 : e4 + 12 : "शाम" === a4 ? e4 + 12 : void 0;
          }, meridiem: function(e4, a4, n4) {
            return e4 < 4 ? "रात" : e4 < 10 ? "सुबह" : e4 < 17 ? "दोपहर" : e4 < 20 ? "शाम" : "रात";
          }, week: { dow: 0, doy: 6 } });
        })(n2(9034));
      }, 1678: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          function a3(e4, a4, n3) {
            var t2 = e4 + " ";
            switch (n3) {
              case "ss":
                return t2 + (1 === e4 ? "sekunda" : 2 === e4 || 3 === e4 || 4 === e4 ? "sekunde" : "sekundi");
              case "m":
                return a4 ? "jedna minuta" : "jedne minute";
              case "mm":
                return t2 + (1 === e4 ? "minuta" : 2 === e4 || 3 === e4 || 4 === e4 ? "minute" : "minuta");
              case "h":
                return a4 ? "jedan sat" : "jednog sata";
              case "hh":
                return t2 + (1 === e4 ? "sat" : 2 === e4 || 3 === e4 || 4 === e4 ? "sata" : "sati");
              case "dd":
                return t2 + (1 === e4 ? "dan" : "dana");
              case "MM":
                return t2 + (1 === e4 ? "mjesec" : 2 === e4 || 3 === e4 || 4 === e4 ? "mjeseca" : "mjeseci");
              case "yy":
                return t2 + (1 === e4 ? "godina" : 2 === e4 || 3 === e4 || 4 === e4 ? "godine" : "godina");
            }
          }
          e3.defineLocale("hr", { months: { format: "siječnja_veljače_ožujka_travnja_svibnja_lipnja_srpnja_kolovoza_rujna_listopada_studenoga_prosinca".split("_"), standalone: "siječanj_veljača_ožujak_travanj_svibanj_lipanj_srpanj_kolovoz_rujan_listopad_studeni_prosinac".split("_") }, monthsShort: "sij._velj._ožu._tra._svi._lip._srp._kol._ruj._lis._stu._pro.".split("_"), monthsParseExact: true, weekdays: "nedjelja_ponedjeljak_utorak_srijeda_četvrtak_petak_subota".split("_"), weekdaysShort: "ned._pon._uto._sri._čet._pet._sub.".split("_"), weekdaysMin: "ne_po_ut_sr_če_pe_su".split("_"), weekdaysParseExact: true, longDateFormat: { LT: "H:mm", LTS: "H:mm:ss", L: "DD.MM.YYYY", LL: "Do MMMM YYYY", LLL: "Do MMMM YYYY H:mm", LLLL: "dddd, Do MMMM YYYY H:mm" }, calendar: { sameDay: "[danas u] LT", nextDay: "[sutra u] LT", nextWeek: function() {
            switch (this.day()) {
              case 0:
                return "[u] [nedjelju] [u] LT";
              case 3:
                return "[u] [srijedu] [u] LT";
              case 6:
                return "[u] [subotu] [u] LT";
              case 1:
              case 2:
              case 4:
              case 5:
                return "[u] dddd [u] LT";
            }
          }, lastDay: "[jučer u] LT", lastWeek: function() {
            switch (this.day()) {
              case 0:
                return "[prošlu] [nedjelju] [u] LT";
              case 3:
                return "[prošlu] [srijedu] [u] LT";
              case 6:
                return "[prošle] [subote] [u] LT";
              case 1:
              case 2:
              case 4:
              case 5:
                return "[prošli] dddd [u] LT";
            }
          }, sameElse: "L" }, relativeTime: { future: "za %s", past: "prije %s", s: "par sekundi", ss: a3, m: a3, mm: a3, h: a3, hh: a3, d: "dan", dd: a3, M: "mjesec", MM: a3, y: "godinu", yy: a3 }, dayOfMonthOrdinalParse: /\d{1,2}\./, ordinal: "%d.", week: { dow: 1, doy: 7 } });
        })(n2(9034));
      }, 5111: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          var a3 = "vasárnap hétfőn kedden szerdán csütörtökön pénteken szombaton".split(" ");
          function n3(e4, a4, n4, t3) {
            var c = e4;
            switch (n4) {
              case "s":
                return t3 || a4 ? "néhány másodperc" : "néhány másodperce";
              case "ss":
                return c + (t3 || a4) ? " másodperc" : " másodperce";
              case "m":
                return "egy" + (t3 || a4 ? " perc" : " perce");
              case "mm":
                return c + (t3 || a4 ? " perc" : " perce");
              case "h":
                return "egy" + (t3 || a4 ? " óra" : " órája");
              case "hh":
                return c + (t3 || a4 ? " óra" : " órája");
              case "d":
                return "egy" + (t3 || a4 ? " nap" : " napja");
              case "dd":
                return c + (t3 || a4 ? " nap" : " napja");
              case "M":
                return "egy" + (t3 || a4 ? " hónap" : " hónapja");
              case "MM":
                return c + (t3 || a4 ? " hónap" : " hónapja");
              case "y":
                return "egy" + (t3 || a4 ? " év" : " éve");
              case "yy":
                return c + (t3 || a4 ? " év" : " éve");
            }
            return "";
          }
          function t2(e4) {
            return (e4 ? "" : "[múlt] ") + "[" + a3[this.day()] + "] LT[-kor]";
          }
          e3.defineLocale("hu", { months: "január_február_március_április_május_június_július_augusztus_szeptember_október_november_december".split("_"), monthsShort: "jan._feb._márc._ápr._máj._jún._júl._aug._szept._okt._nov._dec.".split("_"), monthsParseExact: true, weekdays: "vasárnap_hétfő_kedd_szerda_csütörtök_péntek_szombat".split("_"), weekdaysShort: "vas_hét_kedd_sze_csüt_pén_szo".split("_"), weekdaysMin: "v_h_k_sze_cs_p_szo".split("_"), longDateFormat: { LT: "H:mm", LTS: "H:mm:ss", L: "YYYY.MM.DD.", LL: "YYYY. MMMM D.", LLL: "YYYY. MMMM D. H:mm", LLLL: "YYYY. MMMM D., dddd H:mm" }, meridiemParse: /de|du/i, isPM: function(e4) {
            return "u" === e4.charAt(1).toLowerCase();
          }, meridiem: function(e4, a4, n4) {
            return e4 < 12 ? true === n4 ? "de" : "DE" : true === n4 ? "du" : "DU";
          }, calendar: { sameDay: "[ma] LT[-kor]", nextDay: "[holnap] LT[-kor]", nextWeek: function() {
            return t2.call(this, true);
          }, lastDay: "[tegnap] LT[-kor]", lastWeek: function() {
            return t2.call(this, false);
          }, sameElse: "L" }, relativeTime: { future: "%s múlva", past: "%s", s: n3, ss: n3, m: n3, mm: n3, h: n3, hh: n3, d: n3, dd: n3, M: n3, MM: n3, y: n3, yy: n3 }, dayOfMonthOrdinalParse: /\d{1,2}\./, ordinal: "%d.", week: { dow: 1, doy: 4 } });
        })(n2(9034));
      }, 6530: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          e3.defineLocale("hy-am", { months: { format: "հունվարի_փետրվարի_մարտի_ապրիլի_մայիսի_հունիսի_հուլիսի_օգոստոսի_սեպտեմբերի_հոկտեմբերի_նոյեմբերի_դեկտեմբերի".split("_"), standalone: "հունվար_փետրվար_մարտ_ապրիլ_մայիս_հունիս_հուլիս_օգոստոս_սեպտեմբեր_հոկտեմբեր_նոյեմբեր_դեկտեմբեր".split("_") }, monthsShort: "հնվ_փտր_մրտ_ապր_մյս_հնս_հլս_օգս_սպտ_հկտ_նմբ_դկտ".split("_"), weekdays: "կիրակի_երկուշաբթի_երեքշաբթի_չորեքշաբթի_հինգշաբթի_ուրբաթ_շաբաթ".split("_"), weekdaysShort: "կրկ_երկ_երք_չրք_հնգ_ուրբ_շբթ".split("_"), weekdaysMin: "կրկ_երկ_երք_չրք_հնգ_ուրբ_շբթ".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD.MM.YYYY", LL: "D MMMM YYYY թ.", LLL: "D MMMM YYYY թ., HH:mm", LLLL: "dddd, D MMMM YYYY թ., HH:mm" }, calendar: { sameDay: "[այսօր] LT", nextDay: "[վաղը] LT", lastDay: "[երեկ] LT", nextWeek: function() {
            return "dddd [օրը ժամը] LT";
          }, lastWeek: function() {
            return "[անցած] dddd [օրը ժամը] LT";
          }, sameElse: "L" }, relativeTime: { future: "%s հետո", past: "%s առաջ", s: "մի քանի վայրկյան", ss: "%d վայրկյան", m: "րոպե", mm: "%d րոպե", h: "ժամ", hh: "%d ժամ", d: "օր", dd: "%d օր", M: "ամիս", MM: "%d ամիս", y: "տարի", yy: "%d տարի" }, meridiemParse: /գիշերվա|առավոտվա|ցերեկվա|երեկոյան/, isPM: function(e4) {
            return /^(ցերեկվա|երեկոյան)$/.test(e4);
          }, meridiem: function(e4) {
            return e4 < 4 ? "գիշերվա" : e4 < 12 ? "առավոտվա" : e4 < 17 ? "ցերեկվա" : "երեկոյան";
          }, dayOfMonthOrdinalParse: /\d{1,2}|\d{1,2}-(ին|րդ)/, ordinal: function(e4, a3) {
            switch (a3) {
              case "DDD":
              case "w":
              case "W":
              case "DDDo":
                return 1 === e4 ? e4 + "-ին" : e4 + "-րդ";
              default:
                return e4;
            }
          }, week: { dow: 1, doy: 7 } });
        })(n2(9034));
      }, 9126: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          e3.defineLocale("id", { months: "Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_November_Desember".split("_"), monthsShort: "Jan_Feb_Mar_Apr_Mei_Jun_Jul_Agt_Sep_Okt_Nov_Des".split("_"), weekdays: "Minggu_Senin_Selasa_Rabu_Kamis_Jumat_Sabtu".split("_"), weekdaysShort: "Min_Sen_Sel_Rab_Kam_Jum_Sab".split("_"), weekdaysMin: "Mg_Sn_Sl_Rb_Km_Jm_Sb".split("_"), longDateFormat: { LT: "HH.mm", LTS: "HH.mm.ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY [pukul] HH.mm", LLLL: "dddd, D MMMM YYYY [pukul] HH.mm" }, meridiemParse: /pagi|siang|sore|malam/, meridiemHour: function(e4, a3) {
            return 12 === e4 && (e4 = 0), "pagi" === a3 ? e4 : "siang" === a3 ? e4 >= 11 ? e4 : e4 + 12 : "sore" === a3 || "malam" === a3 ? e4 + 12 : void 0;
          }, meridiem: function(e4, a3, n3) {
            return e4 < 11 ? "pagi" : e4 < 15 ? "siang" : e4 < 19 ? "sore" : "malam";
          }, calendar: { sameDay: "[Hari ini pukul] LT", nextDay: "[Besok pukul] LT", nextWeek: "dddd [pukul] LT", lastDay: "[Kemarin pukul] LT", lastWeek: "dddd [lalu pukul] LT", sameElse: "L" }, relativeTime: { future: "dalam %s", past: "%s yang lalu", s: "beberapa detik", ss: "%d detik", m: "semenit", mm: "%d menit", h: "sejam", hh: "%d jam", d: "sehari", dd: "%d hari", M: "sebulan", MM: "%d bulan", y: "setahun", yy: "%d tahun" }, week: { dow: 0, doy: 6 } });
        })(n2(9034));
      }, 1696: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          function a3(e4) {
            return e4 % 100 == 11 || e4 % 10 != 1;
          }
          function n3(e4, n4, t2, c) {
            var s = e4 + " ";
            switch (t2) {
              case "s":
                return n4 || c ? "nokkrar sekúndur" : "nokkrum sekúndum";
              case "ss":
                return a3(e4) ? s + (n4 || c ? "sekúndur" : "sekúndum") : s + "sekúnda";
              case "m":
                return n4 ? "mínúta" : "mínútu";
              case "mm":
                return a3(e4) ? s + (n4 || c ? "mínútur" : "mínútum") : n4 ? s + "mínúta" : s + "mínútu";
              case "hh":
                return a3(e4) ? s + (n4 || c ? "klukkustundir" : "klukkustundum") : s + "klukkustund";
              case "d":
                return n4 ? "dagur" : c ? "dag" : "degi";
              case "dd":
                return a3(e4) ? n4 ? s + "dagar" : s + (c ? "daga" : "dögum") : n4 ? s + "dagur" : s + (c ? "dag" : "degi");
              case "M":
                return n4 ? "mánuður" : c ? "mánuð" : "mánuði";
              case "MM":
                return a3(e4) ? n4 ? s + "mánuðir" : s + (c ? "mánuði" : "mánuðum") : n4 ? s + "mánuður" : s + (c ? "mánuð" : "mánuði");
              case "y":
                return n4 || c ? "ár" : "ári";
              case "yy":
                return a3(e4) ? s + (n4 || c ? "ár" : "árum") : s + (n4 || c ? "ár" : "ári");
            }
          }
          e3.defineLocale("is", { months: "janúar_febrúar_mars_apríl_maí_júní_júlí_ágúst_september_október_nóvember_desember".split("_"), monthsShort: "jan_feb_mar_apr_maí_jún_júl_ágú_sep_okt_nóv_des".split("_"), weekdays: "sunnudagur_mánudagur_þriðjudagur_miðvikudagur_fimmtudagur_föstudagur_laugardagur".split("_"), weekdaysShort: "sun_mán_þri_mið_fim_fös_lau".split("_"), weekdaysMin: "Su_Má_Þr_Mi_Fi_Fö_La".split("_"), longDateFormat: { LT: "H:mm", LTS: "H:mm:ss", L: "DD.MM.YYYY", LL: "D. MMMM YYYY", LLL: "D. MMMM YYYY [kl.] H:mm", LLLL: "dddd, D. MMMM YYYY [kl.] H:mm" }, calendar: { sameDay: "[í dag kl.] LT", nextDay: "[á morgun kl.] LT", nextWeek: "dddd [kl.] LT", lastDay: "[í gær kl.] LT", lastWeek: "[síðasta] dddd [kl.] LT", sameElse: "L" }, relativeTime: { future: "eftir %s", past: "fyrir %s síðan", s: n3, ss: n3, m: n3, mm: n3, h: "klukkustund", hh: n3, d: n3, dd: n3, M: n3, MM: n3, y: n3, yy: n3 }, dayOfMonthOrdinalParse: /\d{1,2}\./, ordinal: "%d.", week: { dow: 1, doy: 4 } });
        })(n2(9034));
      }, 8821: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          e3.defineLocale("it-ch", { months: "gennaio_febbraio_marzo_aprile_maggio_giugno_luglio_agosto_settembre_ottobre_novembre_dicembre".split("_"), monthsShort: "gen_feb_mar_apr_mag_giu_lug_ago_set_ott_nov_dic".split("_"), weekdays: "domenica_lunedì_martedì_mercoledì_giovedì_venerdì_sabato".split("_"), weekdaysShort: "dom_lun_mar_mer_gio_ven_sab".split("_"), weekdaysMin: "do_lu_ma_me_gi_ve_sa".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD.MM.YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D MMMM YYYY HH:mm" }, calendar: { sameDay: "[Oggi alle] LT", nextDay: "[Domani alle] LT", nextWeek: "dddd [alle] LT", lastDay: "[Ieri alle] LT", lastWeek: function() {
            return 0 === this.day() ? "[la scorsa] dddd [alle] LT" : "[lo scorso] dddd [alle] LT";
          }, sameElse: "L" }, relativeTime: { future: function(e4) {
            return (/^[0-9].+$/.test(e4) ? "tra" : "in") + " " + e4;
          }, past: "%s fa", s: "alcuni secondi", ss: "%d secondi", m: "un minuto", mm: "%d minuti", h: "un'ora", hh: "%d ore", d: "un giorno", dd: "%d giorni", M: "un mese", MM: "%d mesi", y: "un anno", yy: "%d anni" }, dayOfMonthOrdinalParse: /\d{1,2}º/, ordinal: "%dº", week: { dow: 1, doy: 4 } });
        })(n2(9034));
      }, 8710: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          e3.defineLocale("it", { months: "gennaio_febbraio_marzo_aprile_maggio_giugno_luglio_agosto_settembre_ottobre_novembre_dicembre".split("_"), monthsShort: "gen_feb_mar_apr_mag_giu_lug_ago_set_ott_nov_dic".split("_"), weekdays: "domenica_lunedì_martedì_mercoledì_giovedì_venerdì_sabato".split("_"), weekdaysShort: "dom_lun_mar_mer_gio_ven_sab".split("_"), weekdaysMin: "do_lu_ma_me_gi_ve_sa".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D MMMM YYYY HH:mm" }, calendar: { sameDay: function() {
            return "[Oggi a" + (this.hours() > 1 ? "lle " : 0 === this.hours() ? " " : "ll'") + "]LT";
          }, nextDay: function() {
            return "[Domani a" + (this.hours() > 1 ? "lle " : 0 === this.hours() ? " " : "ll'") + "]LT";
          }, nextWeek: function() {
            return "dddd [a" + (this.hours() > 1 ? "lle " : 0 === this.hours() ? " " : "ll'") + "]LT";
          }, lastDay: function() {
            return "[Ieri a" + (this.hours() > 1 ? "lle " : 0 === this.hours() ? " " : "ll'") + "]LT";
          }, lastWeek: function() {
            return 0 === this.day() ? "[La scorsa] dddd [a" + (this.hours() > 1 ? "lle " : 0 === this.hours() ? " " : "ll'") + "]LT" : "[Lo scorso] dddd [a" + (this.hours() > 1 ? "lle " : 0 === this.hours() ? " " : "ll'") + "]LT";
          }, sameElse: "L" }, relativeTime: { future: "tra %s", past: "%s fa", s: "alcuni secondi", ss: "%d secondi", m: "un minuto", mm: "%d minuti", h: "un'ora", hh: "%d ore", d: "un giorno", dd: "%d giorni", w: "una settimana", ww: "%d settimane", M: "un mese", MM: "%d mesi", y: "un anno", yy: "%d anni" }, dayOfMonthOrdinalParse: /\d{1,2}º/, ordinal: "%dº", week: { dow: 1, doy: 4 } });
        })(n2(9034));
      }, 3974: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          e3.defineLocale("ja", { eras: [{ since: "2019-05-01", offset: 1, name: "令和", narrow: "㋿", abbr: "R" }, { since: "1989-01-08", until: "2019-04-30", offset: 1, name: "平成", narrow: "㍻", abbr: "H" }, { since: "1926-12-25", until: "1989-01-07", offset: 1, name: "昭和", narrow: "㍼", abbr: "S" }, { since: "1912-07-30", until: "1926-12-24", offset: 1, name: "大正", narrow: "㍽", abbr: "T" }, { since: "1873-01-01", until: "1912-07-29", offset: 6, name: "明治", narrow: "㍾", abbr: "M" }, { since: "0001-01-01", until: "1873-12-31", offset: 1, name: "西暦", narrow: "AD", abbr: "AD" }, { since: "0000-12-31", until: -1 / 0, offset: 1, name: "紀元前", narrow: "BC", abbr: "BC" }], eraYearOrdinalRegex: /(元|\d+)年/, eraYearOrdinalParse: function(e4, a3) {
            return "元" === a3[1] ? 1 : parseInt(a3[1] || e4, 10);
          }, months: "1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月".split("_"), monthsShort: "1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月".split("_"), weekdays: "日曜日_月曜日_火曜日_水曜日_木曜日_金曜日_土曜日".split("_"), weekdaysShort: "日_月_火_水_木_金_土".split("_"), weekdaysMin: "日_月_火_水_木_金_土".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "YYYY/MM/DD", LL: "YYYY年M月D日", LLL: "YYYY年M月D日 HH:mm", LLLL: "YYYY年M月D日 dddd HH:mm", l: "YYYY/MM/DD", ll: "YYYY年M月D日", lll: "YYYY年M月D日 HH:mm", llll: "YYYY年M月D日(ddd) HH:mm" }, meridiemParse: /午前|午後/i, isPM: function(e4) {
            return "午後" === e4;
          }, meridiem: function(e4, a3, n3) {
            return e4 < 12 ? "午前" : "午後";
          }, calendar: { sameDay: "[今日] LT", nextDay: "[明日] LT", nextWeek: function(e4) {
            return e4.week() !== this.week() ? "[来週]dddd LT" : "dddd LT";
          }, lastDay: "[昨日] LT", lastWeek: function(e4) {
            return this.week() !== e4.week() ? "[先週]dddd LT" : "dddd LT";
          }, sameElse: "L" }, dayOfMonthOrdinalParse: /\d{1,2}日/, ordinal: function(e4, a3) {
            switch (a3) {
              case "y":
                return 1 === e4 ? "元年" : e4 + "年";
              case "d":
              case "D":
              case "DDD":
                return e4 + "日";
              default:
                return e4;
            }
          }, relativeTime: { future: "%s後", past: "%s前", s: "数秒", ss: "%d秒", m: "1分", mm: "%d分", h: "1時間", hh: "%d時間", d: "1日", dd: "%d日", M: "1ヶ月", MM: "%dヶ月", y: "1年", yy: "%d年" } });
        })(n2(9034));
      }, 648: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          e3.defineLocale("jv", { months: "Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_Nopember_Desember".split("_"), monthsShort: "Jan_Feb_Mar_Apr_Mei_Jun_Jul_Ags_Sep_Okt_Nop_Des".split("_"), weekdays: "Minggu_Senen_Seloso_Rebu_Kemis_Jemuwah_Septu".split("_"), weekdaysShort: "Min_Sen_Sel_Reb_Kem_Jem_Sep".split("_"), weekdaysMin: "Mg_Sn_Sl_Rb_Km_Jm_Sp".split("_"), longDateFormat: { LT: "HH.mm", LTS: "HH.mm.ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY [pukul] HH.mm", LLLL: "dddd, D MMMM YYYY [pukul] HH.mm" }, meridiemParse: /enjing|siyang|sonten|ndalu/, meridiemHour: function(e4, a3) {
            return 12 === e4 && (e4 = 0), "enjing" === a3 ? e4 : "siyang" === a3 ? e4 >= 11 ? e4 : e4 + 12 : "sonten" === a3 || "ndalu" === a3 ? e4 + 12 : void 0;
          }, meridiem: function(e4, a3, n3) {
            return e4 < 11 ? "enjing" : e4 < 15 ? "siyang" : e4 < 19 ? "sonten" : "ndalu";
          }, calendar: { sameDay: "[Dinten puniko pukul] LT", nextDay: "[Mbenjang pukul] LT", nextWeek: "dddd [pukul] LT", lastDay: "[Kala wingi pukul] LT", lastWeek: "dddd [kepengker pukul] LT", sameElse: "L" }, relativeTime: { future: "wonten ing %s", past: "%s ingkang kepengker", s: "sawetawis detik", ss: "%d detik", m: "setunggal menit", mm: "%d menit", h: "setunggal jam", hh: "%d jam", d: "sedinten", dd: "%d dinten", M: "sewulan", MM: "%d wulan", y: "setaun", yy: "%d taun" }, week: { dow: 1, doy: 7 } });
        })(n2(9034));
      }, 4731: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          e3.defineLocale("ka", { months: "იანვარი_თებერვალი_მარტი_აპრილი_მაისი_ივნისი_ივლისი_აგვისტო_სექტემბერი_ოქტომბერი_ნოემბერი_დეკემბერი".split("_"), monthsShort: "იან_თებ_მარ_აპრ_მაი_ივნ_ივლ_აგვ_სექ_ოქტ_ნოე_დეკ".split("_"), weekdays: { standalone: "კვირა_ორშაბათი_სამშაბათი_ოთხშაბათი_ხუთშაბათი_პარასკევი_შაბათი".split("_"), format: "კვირას_ორშაბათს_სამშაბათს_ოთხშაბათს_ხუთშაბათს_პარასკევს_შაბათს".split("_"), isFormat: /(წინა|შემდეგ)/ }, weekdaysShort: "კვი_ორშ_სამ_ოთხ_ხუთ_პარ_შაბ".split("_"), weekdaysMin: "კვ_ორ_სა_ოთ_ხუ_პა_შა".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" }, calendar: { sameDay: "[დღეს] LT[-ზე]", nextDay: "[ხვალ] LT[-ზე]", lastDay: "[გუშინ] LT[-ზე]", nextWeek: "[შემდეგ] dddd LT[-ზე]", lastWeek: "[წინა] dddd LT-ზე", sameElse: "L" }, relativeTime: { future: function(e4) {
            return e4.replace(/(წამ|წუთ|საათ|წელ|დღ|თვ)(ი|ე)/, (function(e5, a3, n3) {
              return "ი" === n3 ? a3 + "ში" : a3 + n3 + "ში";
            }));
          }, past: function(e4) {
            return /(წამი|წუთი|საათი|დღე|თვე)/.test(e4) ? e4.replace(/(ი|ე)$/, "ის წინ") : /წელი/.test(e4) ? e4.replace(/წელი$/, "წლის წინ") : e4;
          }, s: "რამდენიმე წამი", ss: "%d წამი", m: "წუთი", mm: "%d წუთი", h: "საათი", hh: "%d საათი", d: "დღე", dd: "%d დღე", M: "თვე", MM: "%d თვე", y: "წელი", yy: "%d წელი" }, dayOfMonthOrdinalParse: /0|1-ლი|მე-\d{1,2}|\d{1,2}-ე/, ordinal: function(e4) {
            return 0 === e4 ? e4 : 1 === e4 ? e4 + "-ლი" : e4 < 20 || e4 <= 100 && e4 % 20 == 0 || e4 % 100 == 0 ? "მე-" + e4 : e4 + "-ე";
          }, week: { dow: 1, doy: 7 } });
        })(n2(9034));
      }, 3501: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          var a3 = { 0: "-ші", 1: "-ші", 2: "-ші", 3: "-ші", 4: "-ші", 5: "-ші", 6: "-шы", 7: "-ші", 8: "-ші", 9: "-шы", 10: "-шы", 20: "-шы", 30: "-шы", 40: "-шы", 50: "-ші", 60: "-шы", 70: "-ші", 80: "-ші", 90: "-шы", 100: "-ші" };
          e3.defineLocale("kk", { months: "қаңтар_ақпан_наурыз_сәуір_мамыр_маусым_шілде_тамыз_қыркүйек_қазан_қараша_желтоқсан".split("_"), monthsShort: "қаң_ақп_нау_сәу_мам_мау_шіл_там_қыр_қаз_қар_жел".split("_"), weekdays: "жексенбі_дүйсенбі_сейсенбі_сәрсенбі_бейсенбі_жұма_сенбі".split("_"), weekdaysShort: "жек_дүй_сей_сәр_бей_жұм_сен".split("_"), weekdaysMin: "жк_дй_сй_ср_бй_жм_сн".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD.MM.YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" }, calendar: { sameDay: "[Бүгін сағат] LT", nextDay: "[Ертең сағат] LT", nextWeek: "dddd [сағат] LT", lastDay: "[Кеше сағат] LT", lastWeek: "[Өткен аптаның] dddd [сағат] LT", sameElse: "L" }, relativeTime: { future: "%s ішінде", past: "%s бұрын", s: "бірнеше секунд", ss: "%d секунд", m: "бір минут", mm: "%d минут", h: "бір сағат", hh: "%d сағат", d: "бір күн", dd: "%d күн", M: "бір ай", MM: "%d ай", y: "бір жыл", yy: "%d жыл" }, dayOfMonthOrdinalParse: /\d{1,2}-(ші|шы)/, ordinal: function(e4) {
            return e4 + (a3[e4] || a3[e4 % 10] || a3[e4 >= 100 ? 100 : null]);
          }, week: { dow: 1, doy: 7 } });
        })(n2(9034));
      }, 4398: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          var a3 = { 1: "១", 2: "២", 3: "៣", 4: "៤", 5: "៥", 6: "៦", 7: "៧", 8: "៨", 9: "៩", 0: "០" }, n3 = { "១": "1", "២": "2", "៣": "3", "៤": "4", "៥": "5", "៦": "6", "៧": "7", "៨": "8", "៩": "9", "០": "0" };
          e3.defineLocale("km", { months: "មករា_កុម្ភៈ_មីនា_មេសា_ឧសភា_មិថុនា_កក្កដា_សីហា_កញ្ញា_តុលា_វិច្ឆិកា_ធ្នូ".split("_"), monthsShort: "មករា_កុម្ភៈ_មីនា_មេសា_ឧសភា_មិថុនា_កក្កដា_សីហា_កញ្ញា_តុលា_វិច្ឆិកា_ធ្នូ".split("_"), weekdays: "អាទិត្យ_ច័ន្ទ_អង្គារ_ពុធ_ព្រហស្បតិ៍_សុក្រ_សៅរ៍".split("_"), weekdaysShort: "អា_ច_អ_ព_ព្រ_សុ_ស".split("_"), weekdaysMin: "អា_ច_អ_ព_ព្រ_សុ_ស".split("_"), weekdaysParseExact: true, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" }, meridiemParse: /ព្រឹក|ល្ងាច/, isPM: function(e4) {
            return "ល្ងាច" === e4;
          }, meridiem: function(e4, a4, n4) {
            return e4 < 12 ? "ព្រឹក" : "ល្ងាច";
          }, calendar: { sameDay: "[ថ្ងៃនេះ ម៉ោង] LT", nextDay: "[ស្អែក ម៉ោង] LT", nextWeek: "dddd [ម៉ោង] LT", lastDay: "[ម្សិលមិញ ម៉ោង] LT", lastWeek: "dddd [សប្តាហ៍មុន] [ម៉ោង] LT", sameElse: "L" }, relativeTime: { future: "%sទៀត", past: "%sមុន", s: "ប៉ុន្មានវិនាទី", ss: "%d វិនាទី", m: "មួយនាទី", mm: "%d នាទី", h: "មួយម៉ោង", hh: "%d ម៉ោង", d: "មួយថ្ងៃ", dd: "%d ថ្ងៃ", M: "មួយខែ", MM: "%d ខែ", y: "មួយឆ្នាំ", yy: "%d ឆ្នាំ" }, dayOfMonthOrdinalParse: /ទី\d{1,2}/, ordinal: "ទី%d", preparse: function(e4) {
            return e4.replace(/[១២៣៤៥៦៧៨៩០]/g, (function(e5) {
              return n3[e5];
            }));
          }, postformat: function(e4) {
            return e4.replace(/\d/g, (function(e5) {
              return a3[e5];
            }));
          }, week: { dow: 1, doy: 4 } });
        })(n2(9034));
      }, 1825: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          var a3 = { 1: "೧", 2: "೨", 3: "೩", 4: "೪", 5: "೫", 6: "೬", 7: "೭", 8: "೮", 9: "೯", 0: "೦" }, n3 = { "೧": "1", "೨": "2", "೩": "3", "೪": "4", "೫": "5", "೬": "6", "೭": "7", "೮": "8", "೯": "9", "೦": "0" };
          e3.defineLocale("kn", { months: "ಜನವರಿ_ಫೆಬ್ರವರಿ_ಮಾರ್ಚ್_ಏಪ್ರಿಲ್_ಮೇ_ಜೂನ್_ಜುಲೈ_ಆಗಸ್ಟ್_ಸೆಪ್ಟೆಂಬರ್_ಅಕ್ಟೋಬರ್_ನವೆಂಬರ್_ಡಿಸೆಂಬರ್".split("_"), monthsShort: "ಜನ_ಫೆಬ್ರ_ಮಾರ್ಚ್_ಏಪ್ರಿಲ್_ಮೇ_ಜೂನ್_ಜುಲೈ_ಆಗಸ್ಟ್_ಸೆಪ್ಟೆಂ_ಅಕ್ಟೋ_ನವೆಂ_ಡಿಸೆಂ".split("_"), monthsParseExact: true, weekdays: "ಭಾನುವಾರ_ಸೋಮವಾರ_ಮಂಗಳವಾರ_ಬುಧವಾರ_ಗುರುವಾರ_ಶುಕ್ರವಾರ_ಶನಿವಾರ".split("_"), weekdaysShort: "ಭಾನು_ಸೋಮ_ಮಂಗಳ_ಬುಧ_ಗುರು_ಶುಕ್ರ_ಶನಿ".split("_"), weekdaysMin: "ಭಾ_ಸೋ_ಮಂ_ಬು_ಗು_ಶು_ಶ".split("_"), longDateFormat: { LT: "A h:mm", LTS: "A h:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY, A h:mm", LLLL: "dddd, D MMMM YYYY, A h:mm" }, calendar: { sameDay: "[ಇಂದು] LT", nextDay: "[ನಾಳೆ] LT", nextWeek: "dddd, LT", lastDay: "[ನಿನ್ನೆ] LT", lastWeek: "[ಕೊನೆಯ] dddd, LT", sameElse: "L" }, relativeTime: { future: "%s ನಂತರ", past: "%s ಹಿಂದೆ", s: "ಕೆಲವು ಕ್ಷಣಗಳು", ss: "%d ಸೆಕೆಂಡುಗಳು", m: "ಒಂದು ನಿಮಿಷ", mm: "%d ನಿಮಿಷ", h: "ಒಂದು ಗಂಟೆ", hh: "%d ಗಂಟೆ", d: "ಒಂದು ದಿನ", dd: "%d ದಿನ", M: "ಒಂದು ತಿಂಗಳು", MM: "%d ತಿಂಗಳು", y: "ಒಂದು ವರ್ಷ", yy: "%d ವರ್ಷ" }, preparse: function(e4) {
            return e4.replace(/[೧೨೩೪೫೬೭೮೯೦]/g, (function(e5) {
              return n3[e5];
            }));
          }, postformat: function(e4) {
            return e4.replace(/\d/g, (function(e5) {
              return a3[e5];
            }));
          }, meridiemParse: /ರಾತ್ರಿ|ಬೆಳಿಗ್ಗೆ|ಮಧ್ಯಾಹ್ನ|ಸಂಜೆ/, meridiemHour: function(e4, a4) {
            return 12 === e4 && (e4 = 0), "ರಾತ್ರಿ" === a4 ? e4 < 4 ? e4 : e4 + 12 : "ಬೆಳಿಗ್ಗೆ" === a4 ? e4 : "ಮಧ್ಯಾಹ್ನ" === a4 ? e4 >= 10 ? e4 : e4 + 12 : "ಸಂಜೆ" === a4 ? e4 + 12 : void 0;
          }, meridiem: function(e4, a4, n4) {
            return e4 < 4 ? "ರಾತ್ರಿ" : e4 < 10 ? "ಬೆಳಿಗ್ಗೆ" : e4 < 17 ? "ಮಧ್ಯಾಹ್ನ" : e4 < 20 ? "ಸಂಜೆ" : "ರಾತ್ರಿ";
          }, dayOfMonthOrdinalParse: /\d{1,2}(ನೇ)/, ordinal: function(e4) {
            return e4 + "ನೇ";
          }, week: { dow: 0, doy: 6 } });
        })(n2(9034));
      }, 3729: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          e3.defineLocale("ko", { months: "1월_2월_3월_4월_5월_6월_7월_8월_9월_10월_11월_12월".split("_"), monthsShort: "1월_2월_3월_4월_5월_6월_7월_8월_9월_10월_11월_12월".split("_"), weekdays: "일요일_월요일_화요일_수요일_목요일_금요일_토요일".split("_"), weekdaysShort: "일_월_화_수_목_금_토".split("_"), weekdaysMin: "일_월_화_수_목_금_토".split("_"), longDateFormat: { LT: "A h:mm", LTS: "A h:mm:ss", L: "YYYY.MM.DD.", LL: "YYYY년 MMMM D일", LLL: "YYYY년 MMMM D일 A h:mm", LLLL: "YYYY년 MMMM D일 dddd A h:mm", l: "YYYY.MM.DD.", ll: "YYYY년 MMMM D일", lll: "YYYY년 MMMM D일 A h:mm", llll: "YYYY년 MMMM D일 dddd A h:mm" }, calendar: { sameDay: "오늘 LT", nextDay: "내일 LT", nextWeek: "dddd LT", lastDay: "어제 LT", lastWeek: "지난주 dddd LT", sameElse: "L" }, relativeTime: { future: "%s 후", past: "%s 전", s: "몇 초", ss: "%d초", m: "1분", mm: "%d분", h: "한 시간", hh: "%d시간", d: "하루", dd: "%d일", M: "한 달", MM: "%d달", y: "일 년", yy: "%d년" }, dayOfMonthOrdinalParse: /\d{1,2}(일|월|주)/, ordinal: function(e4, a3) {
            switch (a3) {
              case "d":
              case "D":
              case "DDD":
                return e4 + "일";
              case "M":
                return e4 + "월";
              case "w":
              case "W":
                return e4 + "주";
              default:
                return e4;
            }
          }, meridiemParse: /오전|오후/, isPM: function(e4) {
            return "오후" === e4;
          }, meridiem: function(e4, a3, n3) {
            return e4 < 12 ? "오전" : "오후";
          } });
        })(n2(9034));
      }, 9670: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          var a3 = { 1: "١", 2: "٢", 3: "٣", 4: "٤", 5: "٥", 6: "٦", 7: "٧", 8: "٨", 9: "٩", 0: "٠" }, n3 = { "١": "1", "٢": "2", "٣": "3", "٤": "4", "٥": "5", "٦": "6", "٧": "7", "٨": "8", "٩": "9", "٠": "0" }, t2 = ["کانونی دووەم", "شوبات", "ئازار", "نیسان", "ئایار", "حوزەیران", "تەمموز", "ئاب", "ئەیلوول", "تشرینی یەكەم", "تشرینی دووەم", "كانونی یەکەم"];
          e3.defineLocale("ku", { months: t2, monthsShort: t2, weekdays: "یه‌كشه‌ممه‌_دووشه‌ممه‌_سێشه‌ممه‌_چوارشه‌ممه‌_پێنجشه‌ممه‌_هه‌ینی_شه‌ممه‌".split("_"), weekdaysShort: "یه‌كشه‌م_دووشه‌م_سێشه‌م_چوارشه‌م_پێنجشه‌م_هه‌ینی_شه‌ممه‌".split("_"), weekdaysMin: "ی_د_س_چ_پ_ه_ش".split("_"), weekdaysParseExact: true, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" }, meridiemParse: /ئێواره‌|به‌یانی/, isPM: function(e4) {
            return /ئێواره‌/.test(e4);
          }, meridiem: function(e4, a4, n4) {
            return e4 < 12 ? "به‌یانی" : "ئێواره‌";
          }, calendar: { sameDay: "[ئه‌مرۆ كاتژمێر] LT", nextDay: "[به‌یانی كاتژمێر] LT", nextWeek: "dddd [كاتژمێر] LT", lastDay: "[دوێنێ كاتژمێر] LT", lastWeek: "dddd [كاتژمێر] LT", sameElse: "L" }, relativeTime: { future: "له‌ %s", past: "%s", s: "چه‌ند چركه‌یه‌ك", ss: "چركه‌ %d", m: "یه‌ك خوله‌ك", mm: "%d خوله‌ك", h: "یه‌ك كاتژمێر", hh: "%d كاتژمێر", d: "یه‌ك ڕۆژ", dd: "%d ڕۆژ", M: "یه‌ك مانگ", MM: "%d مانگ", y: "یه‌ك ساڵ", yy: "%d ساڵ" }, preparse: function(e4) {
            return e4.replace(/[١٢٣٤٥٦٧٨٩٠]/g, (function(e5) {
              return n3[e5];
            })).replace(/،/g, ",");
          }, postformat: function(e4) {
            return e4.replace(/\d/g, (function(e5) {
              return a3[e5];
            })).replace(/,/g, "،");
          }, week: { dow: 6, doy: 12 } });
        })(n2(9034));
      }, 8797: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          var a3 = { 0: "-чү", 1: "-чи", 2: "-чи", 3: "-чү", 4: "-чү", 5: "-чи", 6: "-чы", 7: "-чи", 8: "-чи", 9: "-чу", 10: "-чу", 20: "-чы", 30: "-чу", 40: "-чы", 50: "-чү", 60: "-чы", 70: "-чи", 80: "-чи", 90: "-чу", 100: "-чү" };
          e3.defineLocale("ky", { months: "январь_февраль_март_апрель_май_июнь_июль_август_сентябрь_октябрь_ноябрь_декабрь".split("_"), monthsShort: "янв_фев_март_апр_май_июнь_июль_авг_сен_окт_ноя_дек".split("_"), weekdays: "Жекшемби_Дүйшөмбү_Шейшемби_Шаршемби_Бейшемби_Жума_Ишемби".split("_"), weekdaysShort: "Жек_Дүй_Шей_Шар_Бей_Жум_Ише".split("_"), weekdaysMin: "Жк_Дй_Шй_Шр_Бй_Жм_Иш".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD.MM.YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" }, calendar: { sameDay: "[Бүгүн саат] LT", nextDay: "[Эртең саат] LT", nextWeek: "dddd [саат] LT", lastDay: "[Кечээ саат] LT", lastWeek: "[Өткөн аптанын] dddd [күнү] [саат] LT", sameElse: "L" }, relativeTime: { future: "%s ичинде", past: "%s мурун", s: "бирнече секунд", ss: "%d секунд", m: "бир мүнөт", mm: "%d мүнөт", h: "бир саат", hh: "%d саат", d: "бир күн", dd: "%d күн", M: "бир ай", MM: "%d ай", y: "бир жыл", yy: "%d жыл" }, dayOfMonthOrdinalParse: /\d{1,2}-(чи|чы|чү|чу)/, ordinal: function(e4) {
            return e4 + (a3[e4] || a3[e4 % 10] || a3[e4 >= 100 ? 100 : null]);
          }, week: { dow: 1, doy: 7 } });
        })(n2(9034));
      }, 627: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          function a3(e4, a4, n4, t2) {
            var c = { m: ["eng Minutt", "enger Minutt"], h: ["eng Stonn", "enger Stonn"], d: ["een Dag", "engem Dag"], M: ["ee Mount", "engem Mount"], y: ["ee Joer", "engem Joer"] };
            return a4 ? c[n4][0] : c[n4][1];
          }
          function n3(e4) {
            if (e4 = parseInt(e4, 10), isNaN(e4)) return false;
            if (e4 < 0) return true;
            if (e4 < 10) return 4 <= e4 && e4 <= 7;
            if (e4 < 100) {
              var a4 = e4 % 10;
              return n3(0 === a4 ? e4 / 10 : a4);
            }
            if (e4 < 1e4) {
              for (; e4 >= 10; ) e4 /= 10;
              return n3(e4);
            }
            return n3(e4 /= 1e3);
          }
          e3.defineLocale("lb", { months: "Januar_Februar_Mäerz_Abrëll_Mee_Juni_Juli_August_September_Oktober_November_Dezember".split("_"), monthsShort: "Jan._Febr._Mrz._Abr._Mee_Jun._Jul._Aug._Sept._Okt._Nov._Dez.".split("_"), monthsParseExact: true, weekdays: "Sonndeg_Méindeg_Dënschdeg_Mëttwoch_Donneschdeg_Freideg_Samschdeg".split("_"), weekdaysShort: "So._Mé._Dë._Më._Do._Fr._Sa.".split("_"), weekdaysMin: "So_Mé_Dë_Më_Do_Fr_Sa".split("_"), weekdaysParseExact: true, longDateFormat: { LT: "H:mm [Auer]", LTS: "H:mm:ss [Auer]", L: "DD.MM.YYYY", LL: "D. MMMM YYYY", LLL: "D. MMMM YYYY H:mm [Auer]", LLLL: "dddd, D. MMMM YYYY H:mm [Auer]" }, calendar: { sameDay: "[Haut um] LT", sameElse: "L", nextDay: "[Muer um] LT", nextWeek: "dddd [um] LT", lastDay: "[Gëschter um] LT", lastWeek: function() {
            switch (this.day()) {
              case 2:
              case 4:
                return "[Leschten] dddd [um] LT";
              default:
                return "[Leschte] dddd [um] LT";
            }
          } }, relativeTime: { future: function(e4) {
            return n3(e4.substr(0, e4.indexOf(" "))) ? "a " + e4 : "an " + e4;
          }, past: function(e4) {
            return n3(e4.substr(0, e4.indexOf(" "))) ? "viru " + e4 : "virun " + e4;
          }, s: "e puer Sekonnen", ss: "%d Sekonnen", m: a3, mm: "%d Minutten", h: a3, hh: "%d Stonnen", d: a3, dd: "%d Deeg", M: a3, MM: "%d Méint", y: a3, yy: "%d Joer" }, dayOfMonthOrdinalParse: /\d{1,2}\./, ordinal: "%d.", week: { dow: 1, doy: 4 } });
        })(n2(9034));
      }, 5859: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          e3.defineLocale("lo", { months: "ມັງກອນ_ກຸມພາ_ມີນາ_ເມສາ_ພຶດສະພາ_ມິຖຸນາ_ກໍລະກົດ_ສິງຫາ_ກັນຍາ_ຕຸລາ_ພະຈິກ_ທັນວາ".split("_"), monthsShort: "ມັງກອນ_ກຸມພາ_ມີນາ_ເມສາ_ພຶດສະພາ_ມິຖຸນາ_ກໍລະກົດ_ສິງຫາ_ກັນຍາ_ຕຸລາ_ພະຈິກ_ທັນວາ".split("_"), weekdays: "ອາທິດ_ຈັນ_ອັງຄານ_ພຸດ_ພະຫັດ_ສຸກ_ເສົາ".split("_"), weekdaysShort: "ທິດ_ຈັນ_ອັງຄານ_ພຸດ_ພະຫັດ_ສຸກ_ເສົາ".split("_"), weekdaysMin: "ທ_ຈ_ອຄ_ພ_ພຫ_ສກ_ສ".split("_"), weekdaysParseExact: true, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "ວັນdddd D MMMM YYYY HH:mm" }, meridiemParse: /ຕອນເຊົ້າ|ຕອນແລງ/, isPM: function(e4) {
            return "ຕອນແລງ" === e4;
          }, meridiem: function(e4, a3, n3) {
            return e4 < 12 ? "ຕອນເຊົ້າ" : "ຕອນແລງ";
          }, calendar: { sameDay: "[ມື້ນີ້ເວລາ] LT", nextDay: "[ມື້ອື່ນເວລາ] LT", nextWeek: "[ວັນ]dddd[ໜ້າເວລາ] LT", lastDay: "[ມື້ວານນີ້ເວລາ] LT", lastWeek: "[ວັນ]dddd[ແລ້ວນີ້ເວລາ] LT", sameElse: "L" }, relativeTime: { future: "ອີກ %s", past: "%sຜ່ານມາ", s: "ບໍ່ເທົ່າໃດວິນາທີ", ss: "%d ວິນາທີ", m: "1 ນາທີ", mm: "%d ນາທີ", h: "1 ຊົ່ວໂມງ", hh: "%d ຊົ່ວໂມງ", d: "1 ມື້", dd: "%d ມື້", M: "1 ເດືອນ", MM: "%d ເດືອນ", y: "1 ປີ", yy: "%d ປີ" }, dayOfMonthOrdinalParse: /(ທີ່)\d{1,2}/, ordinal: function(e4) {
            return "ທີ່" + e4;
          } });
        })(n2(9034));
      }, 355: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          var a3 = { ss: "sekundė_sekundžių_sekundes", m: "minutė_minutės_minutę", mm: "minutės_minučių_minutes", h: "valanda_valandos_valandą", hh: "valandos_valandų_valandas", d: "diena_dienos_dieną", dd: "dienos_dienų_dienas", M: "mėnuo_mėnesio_mėnesį", MM: "mėnesiai_mėnesių_mėnesius", y: "metai_metų_metus", yy: "metai_metų_metus" };
          function n3(e4, a4, n4, t3) {
            return a4 ? c(n4)[0] : t3 ? c(n4)[1] : c(n4)[2];
          }
          function t2(e4) {
            return e4 % 10 == 0 || e4 > 10 && e4 < 20;
          }
          function c(e4) {
            return a3[e4].split("_");
          }
          function s(e4, a4, s2, o) {
            var i = e4 + " ";
            return 1 === e4 ? i + n3(0, a4, s2[0], o) : a4 ? i + (t2(e4) ? c(s2)[1] : c(s2)[0]) : o ? i + c(s2)[1] : i + (t2(e4) ? c(s2)[1] : c(s2)[2]);
          }
          e3.defineLocale("lt", { months: { format: "sausio_vasario_kovo_balandžio_gegužės_birželio_liepos_rugpjūčio_rugsėjo_spalio_lapkričio_gruodžio".split("_"), standalone: "sausis_vasaris_kovas_balandis_gegužė_birželis_liepa_rugpjūtis_rugsėjis_spalis_lapkritis_gruodis".split("_"), isFormat: /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?|MMMM?(\[[^\[\]]*\]|\s)+D[oD]?/ }, monthsShort: "sau_vas_kov_bal_geg_bir_lie_rgp_rgs_spa_lap_grd".split("_"), weekdays: { format: "sekmadienį_pirmadienį_antradienį_trečiadienį_ketvirtadienį_penktadienį_šeštadienį".split("_"), standalone: "sekmadienis_pirmadienis_antradienis_trečiadienis_ketvirtadienis_penktadienis_šeštadienis".split("_"), isFormat: /dddd HH:mm/ }, weekdaysShort: "Sek_Pir_Ant_Tre_Ket_Pen_Šeš".split("_"), weekdaysMin: "S_P_A_T_K_Pn_Š".split("_"), weekdaysParseExact: true, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "YYYY-MM-DD", LL: "YYYY [m.] MMMM D [d.]", LLL: "YYYY [m.] MMMM D [d.], HH:mm [val.]", LLLL: "YYYY [m.] MMMM D [d.], dddd, HH:mm [val.]", l: "YYYY-MM-DD", ll: "YYYY [m.] MMMM D [d.]", lll: "YYYY [m.] MMMM D [d.], HH:mm [val.]", llll: "YYYY [m.] MMMM D [d.], ddd, HH:mm [val.]" }, calendar: { sameDay: "[Šiandien] LT", nextDay: "[Rytoj] LT", nextWeek: "dddd LT", lastDay: "[Vakar] LT", lastWeek: "[Praėjusį] dddd LT", sameElse: "L" }, relativeTime: { future: "po %s", past: "prieš %s", s: function(e4, a4, n4, t3) {
            return a4 ? "kelios sekundės" : t3 ? "kelių sekundžių" : "kelias sekundes";
          }, ss: s, m: n3, mm: s, h: n3, hh: s, d: n3, dd: s, M: n3, MM: s, y: n3, yy: s }, dayOfMonthOrdinalParse: /\d{1,2}-oji/, ordinal: function(e4) {
            return e4 + "-oji";
          }, week: { dow: 1, doy: 4 } });
        })(n2(9034));
      }, 6594: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          var a3 = { ss: "sekundes_sekundēm_sekunde_sekundes".split("_"), m: "minūtes_minūtēm_minūte_minūtes".split("_"), mm: "minūtes_minūtēm_minūte_minūtes".split("_"), h: "stundas_stundām_stunda_stundas".split("_"), hh: "stundas_stundām_stunda_stundas".split("_"), d: "dienas_dienām_diena_dienas".split("_"), dd: "dienas_dienām_diena_dienas".split("_"), M: "mēneša_mēnešiem_mēnesis_mēneši".split("_"), MM: "mēneša_mēnešiem_mēnesis_mēneši".split("_"), y: "gada_gadiem_gads_gadi".split("_"), yy: "gada_gadiem_gads_gadi".split("_") };
          function n3(e4, a4, n4) {
            return n4 ? a4 % 10 == 1 && a4 % 100 != 11 ? e4[2] : e4[3] : a4 % 10 == 1 && a4 % 100 != 11 ? e4[0] : e4[1];
          }
          function t2(e4, t3, c2) {
            return e4 + " " + n3(a3[c2], e4, t3);
          }
          function c(e4, t3, c2) {
            return n3(a3[c2], e4, t3);
          }
          e3.defineLocale("lv", { months: "janvāris_februāris_marts_aprīlis_maijs_jūnijs_jūlijs_augusts_septembris_oktobris_novembris_decembris".split("_"), monthsShort: "jan_feb_mar_apr_mai_jūn_jūl_aug_sep_okt_nov_dec".split("_"), weekdays: "svētdiena_pirmdiena_otrdiena_trešdiena_ceturtdiena_piektdiena_sestdiena".split("_"), weekdaysShort: "Sv_P_O_T_C_Pk_S".split("_"), weekdaysMin: "Sv_P_O_T_C_Pk_S".split("_"), weekdaysParseExact: true, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD.MM.YYYY.", LL: "YYYY. [gada] D. MMMM", LLL: "YYYY. [gada] D. MMMM, HH:mm", LLLL: "YYYY. [gada] D. MMMM, dddd, HH:mm" }, calendar: { sameDay: "[Šodien pulksten] LT", nextDay: "[Rīt pulksten] LT", nextWeek: "dddd [pulksten] LT", lastDay: "[Vakar pulksten] LT", lastWeek: "[Pagājušā] dddd [pulksten] LT", sameElse: "L" }, relativeTime: { future: "pēc %s", past: "pirms %s", s: function(e4, a4) {
            return a4 ? "dažas sekundes" : "dažām sekundēm";
          }, ss: t2, m: c, mm: t2, h: c, hh: t2, d: c, dd: t2, M: c, MM: t2, y: c, yy: t2 }, dayOfMonthOrdinalParse: /\d{1,2}\./, ordinal: "%d.", week: { dow: 1, doy: 4 } });
        })(n2(9034));
      }, 5324: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          var a3 = { words: { ss: ["sekund", "sekunda", "sekundi"], m: ["jedan minut", "jednog minuta"], mm: ["minut", "minuta", "minuta"], h: ["jedan sat", "jednog sata"], hh: ["sat", "sata", "sati"], dd: ["dan", "dana", "dana"], MM: ["mjesec", "mjeseca", "mjeseci"], yy: ["godina", "godine", "godina"] }, correctGrammaticalCase: function(e4, a4) {
            return 1 === e4 ? a4[0] : e4 >= 2 && e4 <= 4 ? a4[1] : a4[2];
          }, translate: function(e4, n3, t2) {
            var c = a3.words[t2];
            return 1 === t2.length ? n3 ? c[0] : c[1] : e4 + " " + a3.correctGrammaticalCase(e4, c);
          } };
          e3.defineLocale("me", { months: "januar_februar_mart_april_maj_jun_jul_avgust_septembar_oktobar_novembar_decembar".split("_"), monthsShort: "jan._feb._mar._apr._maj_jun_jul_avg._sep._okt._nov._dec.".split("_"), monthsParseExact: true, weekdays: "nedjelja_ponedjeljak_utorak_srijeda_četvrtak_petak_subota".split("_"), weekdaysShort: "ned._pon._uto._sri._čet._pet._sub.".split("_"), weekdaysMin: "ne_po_ut_sr_če_pe_su".split("_"), weekdaysParseExact: true, longDateFormat: { LT: "H:mm", LTS: "H:mm:ss", L: "DD.MM.YYYY", LL: "D. MMMM YYYY", LLL: "D. MMMM YYYY H:mm", LLLL: "dddd, D. MMMM YYYY H:mm" }, calendar: { sameDay: "[danas u] LT", nextDay: "[sjutra u] LT", nextWeek: function() {
            switch (this.day()) {
              case 0:
                return "[u] [nedjelju] [u] LT";
              case 3:
                return "[u] [srijedu] [u] LT";
              case 6:
                return "[u] [subotu] [u] LT";
              case 1:
              case 2:
              case 4:
              case 5:
                return "[u] dddd [u] LT";
            }
          }, lastDay: "[juče u] LT", lastWeek: function() {
            return ["[prošle] [nedjelje] [u] LT", "[prošlog] [ponedjeljka] [u] LT", "[prošlog] [utorka] [u] LT", "[prošle] [srijede] [u] LT", "[prošlog] [četvrtka] [u] LT", "[prošlog] [petka] [u] LT", "[prošle] [subote] [u] LT"][this.day()];
          }, sameElse: "L" }, relativeTime: { future: "za %s", past: "prije %s", s: "nekoliko sekundi", ss: a3.translate, m: a3.translate, mm: a3.translate, h: a3.translate, hh: a3.translate, d: "dan", dd: a3.translate, M: "mjesec", MM: a3.translate, y: "godinu", yy: a3.translate }, dayOfMonthOrdinalParse: /\d{1,2}\./, ordinal: "%d.", week: { dow: 1, doy: 7 } });
        })(n2(9034));
      }, 1689: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          e3.defineLocale("mi", { months: "Kohi-tāte_Hui-tanguru_Poutū-te-rangi_Paenga-whāwhā_Haratua_Pipiri_Hōngoingoi_Here-turi-kōkā_Mahuru_Whiringa-ā-nuku_Whiringa-ā-rangi_Hakihea".split("_"), monthsShort: "Kohi_Hui_Pou_Pae_Hara_Pipi_Hōngoi_Here_Mahu_Whi-nu_Whi-ra_Haki".split("_"), monthsRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i, monthsStrictRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i, monthsShortRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i, monthsShortStrictRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,2}/i, weekdays: "Rātapu_Mane_Tūrei_Wenerei_Tāite_Paraire_Hātarei".split("_"), weekdaysShort: "Ta_Ma_Tū_We_Tāi_Pa_Hā".split("_"), weekdaysMin: "Ta_Ma_Tū_We_Tāi_Pa_Hā".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY [i] HH:mm", LLLL: "dddd, D MMMM YYYY [i] HH:mm" }, calendar: { sameDay: "[i teie mahana, i] LT", nextDay: "[apopo i] LT", nextWeek: "dddd [i] LT", lastDay: "[inanahi i] LT", lastWeek: "dddd [whakamutunga i] LT", sameElse: "L" }, relativeTime: { future: "i roto i %s", past: "%s i mua", s: "te hēkona ruarua", ss: "%d hēkona", m: "he meneti", mm: "%d meneti", h: "te haora", hh: "%d haora", d: "he ra", dd: "%d ra", M: "he marama", MM: "%d marama", y: "he tau", yy: "%d tau" }, dayOfMonthOrdinalParse: /\d{1,2}º/, ordinal: "%dº", week: { dow: 1, doy: 4 } });
        })(n2(9034));
      }, 1308: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          e3.defineLocale("mk", { months: "јануари_февруари_март_април_мај_јуни_јули_август_септември_октомври_ноември_декември".split("_"), monthsShort: "јан_фев_мар_апр_мај_јун_јул_авг_сеп_окт_ное_дек".split("_"), weekdays: "недела_понеделник_вторник_среда_четврток_петок_сабота".split("_"), weekdaysShort: "нед_пон_вто_сре_чет_пет_саб".split("_"), weekdaysMin: "нe_пo_вт_ср_че_пе_сa".split("_"), longDateFormat: { LT: "H:mm", LTS: "H:mm:ss", L: "D.MM.YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY H:mm", LLLL: "dddd, D MMMM YYYY H:mm" }, calendar: { sameDay: "[Денес во] LT", nextDay: "[Утре во] LT", nextWeek: "[Во] dddd [во] LT", lastDay: "[Вчера во] LT", lastWeek: function() {
            switch (this.day()) {
              case 0:
              case 3:
              case 6:
                return "[Изминатата] dddd [во] LT";
              case 1:
              case 2:
              case 4:
              case 5:
                return "[Изминатиот] dddd [во] LT";
            }
          }, sameElse: "L" }, relativeTime: { future: "за %s", past: "пред %s", s: "неколку секунди", ss: "%d секунди", m: "една минута", mm: "%d минути", h: "еден час", hh: "%d часа", d: "еден ден", dd: "%d дена", M: "еден месец", MM: "%d месеци", y: "една година", yy: "%d години" }, dayOfMonthOrdinalParse: /\d{1,2}-(ев|ен|ти|ви|ри|ми)/, ordinal: function(e4) {
            var a3 = e4 % 10, n3 = e4 % 100;
            return 0 === e4 ? e4 + "-ев" : 0 === n3 ? e4 + "-ен" : n3 > 10 && n3 < 20 ? e4 + "-ти" : 1 === a3 ? e4 + "-ви" : 2 === a3 ? e4 + "-ри" : 7 === a3 || 8 === a3 ? e4 + "-ми" : e4 + "-ти";
          }, week: { dow: 1, doy: 7 } });
        })(n2(9034));
      }, 5241: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          e3.defineLocale("ml", { months: "ജനുവരി_ഫെബ്രുവരി_മാർച്ച്_ഏപ്രിൽ_മേയ്_ജൂൺ_ജൂലൈ_ഓഗസ്റ്റ്_സെപ്റ്റംബർ_ഒക്ടോബർ_നവംബർ_ഡിസംബർ".split("_"), monthsShort: "ജനു._ഫെബ്രു._മാർ._ഏപ്രി._മേയ്_ജൂൺ_ജൂലൈ._ഓഗ._സെപ്റ്റ._ഒക്ടോ._നവം._ഡിസം.".split("_"), monthsParseExact: true, weekdays: "ഞായറാഴ്ച_തിങ്കളാഴ്ച_ചൊവ്വാഴ്ച_ബുധനാഴ്ച_വ്യാഴാഴ്ച_വെള്ളിയാഴ്ച_ശനിയാഴ്ച".split("_"), weekdaysShort: "ഞായർ_തിങ്കൾ_ചൊവ്വ_ബുധൻ_വ്യാഴം_വെള്ളി_ശനി".split("_"), weekdaysMin: "ഞാ_തി_ചൊ_ബു_വ്യാ_വെ_ശ".split("_"), longDateFormat: { LT: "A h:mm -നു", LTS: "A h:mm:ss -നു", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY, A h:mm -നു", LLLL: "dddd, D MMMM YYYY, A h:mm -നു" }, calendar: { sameDay: "[ഇന്ന്] LT", nextDay: "[നാളെ] LT", nextWeek: "dddd, LT", lastDay: "[ഇന്നലെ] LT", lastWeek: "[കഴിഞ്ഞ] dddd, LT", sameElse: "L" }, relativeTime: { future: "%s കഴിഞ്ഞ്", past: "%s മുൻപ്", s: "അൽപ നിമിഷങ്ങൾ", ss: "%d സെക്കൻഡ്", m: "ഒരു മിനിറ്റ്", mm: "%d മിനിറ്റ്", h: "ഒരു മണിക്കൂർ", hh: "%d മണിക്കൂർ", d: "ഒരു ദിവസം", dd: "%d ദിവസം", M: "ഒരു മാസം", MM: "%d മാസം", y: "ഒരു വർഷം", yy: "%d വർഷം" }, meridiemParse: /രാത്രി|രാവിലെ|ഉച്ച കഴിഞ്ഞ്|വൈകുന്നേരം|രാത്രി/i, meridiemHour: function(e4, a3) {
            return 12 === e4 && (e4 = 0), "രാത്രി" === a3 && e4 >= 4 || "ഉച്ച കഴിഞ്ഞ്" === a3 || "വൈകുന്നേരം" === a3 ? e4 + 12 : e4;
          }, meridiem: function(e4, a3, n3) {
            return e4 < 4 ? "രാത്രി" : e4 < 12 ? "രാവിലെ" : e4 < 17 ? "ഉച്ച കഴിഞ്ഞ്" : e4 < 20 ? "വൈകുന്നേരം" : "രാത്രി";
          } });
        })(n2(9034));
      }, 6320: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          function a3(e4, a4, n3, t2) {
            switch (n3) {
              case "s":
                return a4 ? "хэдхэн секунд" : "хэдхэн секундын";
              case "ss":
                return e4 + (a4 ? " секунд" : " секундын");
              case "m":
              case "mm":
                return e4 + (a4 ? " минут" : " минутын");
              case "h":
              case "hh":
                return e4 + (a4 ? " цаг" : " цагийн");
              case "d":
              case "dd":
                return e4 + (a4 ? " өдөр" : " өдрийн");
              case "M":
              case "MM":
                return e4 + (a4 ? " сар" : " сарын");
              case "y":
              case "yy":
                return e4 + (a4 ? " жил" : " жилийн");
              default:
                return e4;
            }
          }
          e3.defineLocale("mn", { months: "Нэгдүгээр сар_Хоёрдугаар сар_Гуравдугаар сар_Дөрөвдүгээр сар_Тавдугаар сар_Зургадугаар сар_Долдугаар сар_Наймдугаар сар_Есдүгээр сар_Аравдугаар сар_Арван нэгдүгээр сар_Арван хоёрдугаар сар".split("_"), monthsShort: "1 сар_2 сар_3 сар_4 сар_5 сар_6 сар_7 сар_8 сар_9 сар_10 сар_11 сар_12 сар".split("_"), monthsParseExact: true, weekdays: "Ням_Даваа_Мягмар_Лхагва_Пүрэв_Баасан_Бямба".split("_"), weekdaysShort: "Ням_Дав_Мяг_Лха_Пүр_Баа_Бям".split("_"), weekdaysMin: "Ня_Да_Мя_Лх_Пү_Ба_Бя".split("_"), weekdaysParseExact: true, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "YYYY-MM-DD", LL: "YYYY оны MMMMын D", LLL: "YYYY оны MMMMын D HH:mm", LLLL: "dddd, YYYY оны MMMMын D HH:mm" }, meridiemParse: /ҮӨ|ҮХ/i, isPM: function(e4) {
            return "ҮХ" === e4;
          }, meridiem: function(e4, a4, n3) {
            return e4 < 12 ? "ҮӨ" : "ҮХ";
          }, calendar: { sameDay: "[Өнөөдөр] LT", nextDay: "[Маргааш] LT", nextWeek: "[Ирэх] dddd LT", lastDay: "[Өчигдөр] LT", lastWeek: "[Өнгөрсөн] dddd LT", sameElse: "L" }, relativeTime: { future: "%s дараа", past: "%s өмнө", s: a3, ss: a3, m: a3, mm: a3, h: a3, hh: a3, d: a3, dd: a3, M: a3, MM: a3, y: a3, yy: a3 }, dayOfMonthOrdinalParse: /\d{1,2} өдөр/, ordinal: function(e4, a4) {
            switch (a4) {
              case "d":
              case "D":
              case "DDD":
                return e4 + " өдөр";
              default:
                return e4;
            }
          } });
        })(n2(9034));
      }, 6771: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          var a3 = { 1: "१", 2: "२", 3: "३", 4: "४", 5: "५", 6: "६", 7: "७", 8: "८", 9: "९", 0: "०" }, n3 = { "१": "1", "२": "2", "३": "3", "४": "4", "५": "5", "६": "6", "७": "7", "८": "8", "९": "9", "०": "0" };
          function t2(e4, a4, n4, t3) {
            var c = "";
            if (a4) switch (n4) {
              case "s":
                c = "काही सेकंद";
                break;
              case "ss":
                c = "%d सेकंद";
                break;
              case "m":
                c = "एक मिनिट";
                break;
              case "mm":
                c = "%d मिनिटे";
                break;
              case "h":
                c = "एक तास";
                break;
              case "hh":
                c = "%d तास";
                break;
              case "d":
                c = "एक दिवस";
                break;
              case "dd":
                c = "%d दिवस";
                break;
              case "M":
                c = "एक महिना";
                break;
              case "MM":
                c = "%d महिने";
                break;
              case "y":
                c = "एक वर्ष";
                break;
              case "yy":
                c = "%d वर्षे";
            }
            else switch (n4) {
              case "s":
                c = "काही सेकंदां";
                break;
              case "ss":
                c = "%d सेकंदां";
                break;
              case "m":
                c = "एका मिनिटा";
                break;
              case "mm":
                c = "%d मिनिटां";
                break;
              case "h":
                c = "एका तासा";
                break;
              case "hh":
                c = "%d तासां";
                break;
              case "d":
                c = "एका दिवसा";
                break;
              case "dd":
                c = "%d दिवसां";
                break;
              case "M":
                c = "एका महिन्या";
                break;
              case "MM":
                c = "%d महिन्यां";
                break;
              case "y":
                c = "एका वर्षा";
                break;
              case "yy":
                c = "%d वर्षां";
            }
            return c.replace(/%d/i, e4);
          }
          e3.defineLocale("mr", { months: "जानेवारी_फेब्रुवारी_मार्च_एप्रिल_मे_जून_जुलै_ऑगस्ट_सप्टेंबर_ऑक्टोबर_नोव्हेंबर_डिसेंबर".split("_"), monthsShort: "जाने._फेब्रु._मार्च._एप्रि._मे._जून._जुलै._ऑग._सप्टें._ऑक्टो._नोव्हें._डिसें.".split("_"), monthsParseExact: true, weekdays: "रविवार_सोमवार_मंगळवार_बुधवार_गुरूवार_शुक्रवार_शनिवार".split("_"), weekdaysShort: "रवि_सोम_मंगळ_बुध_गुरू_शुक्र_शनि".split("_"), weekdaysMin: "र_सो_मं_बु_गु_शु_श".split("_"), longDateFormat: { LT: "A h:mm वाजता", LTS: "A h:mm:ss वाजता", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY, A h:mm वाजता", LLLL: "dddd, D MMMM YYYY, A h:mm वाजता" }, calendar: { sameDay: "[आज] LT", nextDay: "[उद्या] LT", nextWeek: "dddd, LT", lastDay: "[काल] LT", lastWeek: "[मागील] dddd, LT", sameElse: "L" }, relativeTime: { future: "%sमध्ये", past: "%sपूर्वी", s: t2, ss: t2, m: t2, mm: t2, h: t2, hh: t2, d: t2, dd: t2, M: t2, MM: t2, y: t2, yy: t2 }, preparse: function(e4) {
            return e4.replace(/[१२३४५६७८९०]/g, (function(e5) {
              return n3[e5];
            }));
          }, postformat: function(e4) {
            return e4.replace(/\d/g, (function(e5) {
              return a3[e5];
            }));
          }, meridiemParse: /पहाटे|सकाळी|दुपारी|सायंकाळी|रात्री/, meridiemHour: function(e4, a4) {
            return 12 === e4 && (e4 = 0), "पहाटे" === a4 || "सकाळी" === a4 ? e4 : "दुपारी" === a4 || "सायंकाळी" === a4 || "रात्री" === a4 ? e4 >= 12 ? e4 : e4 + 12 : void 0;
          }, meridiem: function(e4, a4, n4) {
            return e4 >= 0 && e4 < 6 ? "पहाटे" : e4 < 12 ? "सकाळी" : e4 < 17 ? "दुपारी" : e4 < 20 ? "सायंकाळी" : "रात्री";
          }, week: { dow: 0, doy: 6 } });
        })(n2(9034));
      }, 7748: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          e3.defineLocale("ms-my", { months: "Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember".split("_"), monthsShort: "Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis".split("_"), weekdays: "Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu".split("_"), weekdaysShort: "Ahd_Isn_Sel_Rab_Kha_Jum_Sab".split("_"), weekdaysMin: "Ah_Is_Sl_Rb_Km_Jm_Sb".split("_"), longDateFormat: { LT: "HH.mm", LTS: "HH.mm.ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY [pukul] HH.mm", LLLL: "dddd, D MMMM YYYY [pukul] HH.mm" }, meridiemParse: /pagi|tengahari|petang|malam/, meridiemHour: function(e4, a3) {
            return 12 === e4 && (e4 = 0), "pagi" === a3 ? e4 : "tengahari" === a3 ? e4 >= 11 ? e4 : e4 + 12 : "petang" === a3 || "malam" === a3 ? e4 + 12 : void 0;
          }, meridiem: function(e4, a3, n3) {
            return e4 < 11 ? "pagi" : e4 < 15 ? "tengahari" : e4 < 19 ? "petang" : "malam";
          }, calendar: { sameDay: "[Hari ini pukul] LT", nextDay: "[Esok pukul] LT", nextWeek: "dddd [pukul] LT", lastDay: "[Kelmarin pukul] LT", lastWeek: "dddd [lepas pukul] LT", sameElse: "L" }, relativeTime: { future: "dalam %s", past: "%s yang lepas", s: "beberapa saat", ss: "%d saat", m: "seminit", mm: "%d minit", h: "sejam", hh: "%d jam", d: "sehari", dd: "%d hari", M: "sebulan", MM: "%d bulan", y: "setahun", yy: "%d tahun" }, week: { dow: 1, doy: 7 } });
        })(n2(9034));
      }, 503: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          e3.defineLocale("ms", { months: "Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember".split("_"), monthsShort: "Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis".split("_"), weekdays: "Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu".split("_"), weekdaysShort: "Ahd_Isn_Sel_Rab_Kha_Jum_Sab".split("_"), weekdaysMin: "Ah_Is_Sl_Rb_Km_Jm_Sb".split("_"), longDateFormat: { LT: "HH.mm", LTS: "HH.mm.ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY [pukul] HH.mm", LLLL: "dddd, D MMMM YYYY [pukul] HH.mm" }, meridiemParse: /pagi|tengahari|petang|malam/, meridiemHour: function(e4, a3) {
            return 12 === e4 && (e4 = 0), "pagi" === a3 ? e4 : "tengahari" === a3 ? e4 >= 11 ? e4 : e4 + 12 : "petang" === a3 || "malam" === a3 ? e4 + 12 : void 0;
          }, meridiem: function(e4, a3, n3) {
            return e4 < 11 ? "pagi" : e4 < 15 ? "tengahari" : e4 < 19 ? "petang" : "malam";
          }, calendar: { sameDay: "[Hari ini pukul] LT", nextDay: "[Esok pukul] LT", nextWeek: "dddd [pukul] LT", lastDay: "[Kelmarin pukul] LT", lastWeek: "dddd [lepas pukul] LT", sameElse: "L" }, relativeTime: { future: "dalam %s", past: "%s yang lepas", s: "beberapa saat", ss: "%d saat", m: "seminit", mm: "%d minit", h: "sejam", hh: "%d jam", d: "sehari", dd: "%d hari", M: "sebulan", MM: "%d bulan", y: "setahun", yy: "%d tahun" }, week: { dow: 1, doy: 7 } });
        })(n2(9034));
      }, 5534: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          e3.defineLocale("mt", { months: "Jannar_Frar_Marzu_April_Mejju_Ġunju_Lulju_Awwissu_Settembru_Ottubru_Novembru_Diċembru".split("_"), monthsShort: "Jan_Fra_Mar_Apr_Mej_Ġun_Lul_Aww_Set_Ott_Nov_Diċ".split("_"), weekdays: "Il-Ħadd_It-Tnejn_It-Tlieta_L-Erbgħa_Il-Ħamis_Il-Ġimgħa_Is-Sibt".split("_"), weekdaysShort: "Ħad_Tne_Tli_Erb_Ħam_Ġim_Sib".split("_"), weekdaysMin: "Ħa_Tn_Tl_Er_Ħa_Ġi_Si".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" }, calendar: { sameDay: "[Illum fil-]LT", nextDay: "[Għada fil-]LT", nextWeek: "dddd [fil-]LT", lastDay: "[Il-bieraħ fil-]LT", lastWeek: "dddd [li għadda] [fil-]LT", sameElse: "L" }, relativeTime: { future: "f’ %s", past: "%s ilu", s: "ftit sekondi", ss: "%d sekondi", m: "minuta", mm: "%d minuti", h: "siegħa", hh: "%d siegħat", d: "ġurnata", dd: "%d ġranet", M: "xahar", MM: "%d xhur", y: "sena", yy: "%d sni" }, dayOfMonthOrdinalParse: /\d{1,2}º/, ordinal: "%dº", week: { dow: 1, doy: 4 } });
        })(n2(9034));
      }, 2727: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          var a3 = { 1: "၁", 2: "၂", 3: "၃", 4: "၄", 5: "၅", 6: "၆", 7: "၇", 8: "၈", 9: "၉", 0: "၀" }, n3 = { "၁": "1", "၂": "2", "၃": "3", "၄": "4", "၅": "5", "၆": "6", "၇": "7", "၈": "8", "၉": "9", "၀": "0" };
          e3.defineLocale("my", { months: "ဇန်နဝါရီ_ဖေဖော်ဝါရီ_မတ်_ဧပြီ_မေ_ဇွန်_ဇူလိုင်_သြဂုတ်_စက်တင်ဘာ_အောက်တိုဘာ_နိုဝင်ဘာ_ဒီဇင်ဘာ".split("_"), monthsShort: "ဇန်_ဖေ_မတ်_ပြီ_မေ_ဇွန်_လိုင်_သြ_စက်_အောက်_နို_ဒီ".split("_"), weekdays: "တနင်္ဂနွေ_တနင်္လာ_အင်္ဂါ_ဗုဒ္ဓဟူး_ကြာသပတေး_သောကြာ_စနေ".split("_"), weekdaysShort: "နွေ_လာ_ဂါ_ဟူး_ကြာ_သော_နေ".split("_"), weekdaysMin: "နွေ_လာ_ဂါ_ဟူး_ကြာ_သော_နေ".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D MMMM YYYY HH:mm" }, calendar: { sameDay: "[ယနေ.] LT [မှာ]", nextDay: "[မနက်ဖြန်] LT [မှာ]", nextWeek: "dddd LT [မှာ]", lastDay: "[မနေ.က] LT [မှာ]", lastWeek: "[ပြီးခဲ့သော] dddd LT [မှာ]", sameElse: "L" }, relativeTime: { future: "လာမည့် %s မှာ", past: "လွန်ခဲ့သော %s က", s: "စက္ကန်.အနည်းငယ်", ss: "%d စက္ကန့်", m: "တစ်မိနစ်", mm: "%d မိနစ်", h: "တစ်နာရီ", hh: "%d နာရီ", d: "တစ်ရက်", dd: "%d ရက်", M: "တစ်လ", MM: "%d လ", y: "တစ်နှစ်", yy: "%d နှစ်" }, preparse: function(e4) {
            return e4.replace(/[၁၂၃၄၅၆၇၈၉၀]/g, (function(e5) {
              return n3[e5];
            }));
          }, postformat: function(e4) {
            return e4.replace(/\d/g, (function(e5) {
              return a3[e5];
            }));
          }, week: { dow: 1, doy: 4 } });
        })(n2(9034));
      }, 7550: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          e3.defineLocale("nb", { months: "januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember".split("_"), monthsShort: "jan._feb._mars_apr._mai_juni_juli_aug._sep._okt._nov._des.".split("_"), monthsParseExact: true, weekdays: "søndag_mandag_tirsdag_onsdag_torsdag_fredag_lørdag".split("_"), weekdaysShort: "sø._ma._ti._on._to._fr._lø.".split("_"), weekdaysMin: "sø_ma_ti_on_to_fr_lø".split("_"), weekdaysParseExact: true, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD.MM.YYYY", LL: "D. MMMM YYYY", LLL: "D. MMMM YYYY [kl.] HH:mm", LLLL: "dddd D. MMMM YYYY [kl.] HH:mm" }, calendar: { sameDay: "[i dag kl.] LT", nextDay: "[i morgen kl.] LT", nextWeek: "dddd [kl.] LT", lastDay: "[i går kl.] LT", lastWeek: "[forrige] dddd [kl.] LT", sameElse: "L" }, relativeTime: { future: "om %s", past: "%s siden", s: "noen sekunder", ss: "%d sekunder", m: "ett minutt", mm: "%d minutter", h: "en time", hh: "%d timer", d: "en dag", dd: "%d dager", w: "en uke", ww: "%d uker", M: "en måned", MM: "%d måneder", y: "ett år", yy: "%d år" }, dayOfMonthOrdinalParse: /\d{1,2}\./, ordinal: "%d.", week: { dow: 1, doy: 4 } });
        })(n2(9034));
      }, 9899: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          var a3 = { 1: "१", 2: "२", 3: "३", 4: "४", 5: "५", 6: "६", 7: "७", 8: "८", 9: "९", 0: "०" }, n3 = { "१": "1", "२": "2", "३": "3", "४": "4", "५": "5", "६": "6", "७": "7", "८": "8", "९": "9", "०": "0" };
          e3.defineLocale("ne", { months: "जनवरी_फेब्रुवरी_मार्च_अप्रिल_मई_जुन_जुलाई_अगष्ट_सेप्टेम्बर_अक्टोबर_नोभेम्बर_डिसेम्बर".split("_"), monthsShort: "जन._फेब्रु._मार्च_अप्रि._मई_जुन_जुलाई._अग._सेप्ट._अक्टो._नोभे._डिसे.".split("_"), monthsParseExact: true, weekdays: "आइतबार_सोमबार_मङ्गलबार_बुधबार_बिहिबार_शुक्रबार_शनिबार".split("_"), weekdaysShort: "आइत._सोम._मङ्गल._बुध._बिहि._शुक्र._शनि.".split("_"), weekdaysMin: "आ._सो._मं._बु._बि._शु._श.".split("_"), weekdaysParseExact: true, longDateFormat: { LT: "Aको h:mm बजे", LTS: "Aको h:mm:ss बजे", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY, Aको h:mm बजे", LLLL: "dddd, D MMMM YYYY, Aको h:mm बजे" }, preparse: function(e4) {
            return e4.replace(/[१२३४५६७८९०]/g, (function(e5) {
              return n3[e5];
            }));
          }, postformat: function(e4) {
            return e4.replace(/\d/g, (function(e5) {
              return a3[e5];
            }));
          }, meridiemParse: /राति|बिहान|दिउँसो|साँझ/, meridiemHour: function(e4, a4) {
            return 12 === e4 && (e4 = 0), "राति" === a4 ? e4 < 4 ? e4 : e4 + 12 : "बिहान" === a4 ? e4 : "दिउँसो" === a4 ? e4 >= 10 ? e4 : e4 + 12 : "साँझ" === a4 ? e4 + 12 : void 0;
          }, meridiem: function(e4, a4, n4) {
            return e4 < 3 ? "राति" : e4 < 12 ? "बिहान" : e4 < 16 ? "दिउँसो" : e4 < 20 ? "साँझ" : "राति";
          }, calendar: { sameDay: "[आज] LT", nextDay: "[भोलि] LT", nextWeek: "[आउँदो] dddd[,] LT", lastDay: "[हिजो] LT", lastWeek: "[गएको] dddd[,] LT", sameElse: "L" }, relativeTime: { future: "%sमा", past: "%s अगाडि", s: "केही क्षण", ss: "%d सेकेण्ड", m: "एक मिनेट", mm: "%d मिनेट", h: "एक घण्टा", hh: "%d घण्टा", d: "एक दिन", dd: "%d दिन", M: "एक महिना", MM: "%d महिना", y: "एक बर्ष", yy: "%d बर्ष" }, week: { dow: 0, doy: 6 } });
        })(n2(9034));
      }, 1225: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          var a3 = "jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.".split("_"), n3 = "jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec".split("_"), t2 = [/^jan/i, /^feb/i, /^maart|mrt.?$/i, /^apr/i, /^mei$/i, /^jun[i.]?$/i, /^jul[i.]?$/i, /^aug/i, /^sep/i, /^okt/i, /^nov/i, /^dec/i], c = /^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december|jan\.?|feb\.?|mrt\.?|apr\.?|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i;
          e3.defineLocale("nl-be", { months: "januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december".split("_"), monthsShort: function(e4, t3) {
            return e4 ? /-MMM-/.test(t3) ? n3[e4.month()] : a3[e4.month()] : a3;
          }, monthsRegex: c, monthsShortRegex: c, monthsStrictRegex: /^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december)/i, monthsShortStrictRegex: /^(jan\.?|feb\.?|mrt\.?|apr\.?|mei|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i, monthsParse: t2, longMonthsParse: t2, shortMonthsParse: t2, weekdays: "zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag".split("_"), weekdaysShort: "zo._ma._di._wo._do._vr._za.".split("_"), weekdaysMin: "zo_ma_di_wo_do_vr_za".split("_"), weekdaysParseExact: true, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D MMMM YYYY HH:mm" }, calendar: { sameDay: "[vandaag om] LT", nextDay: "[morgen om] LT", nextWeek: "dddd [om] LT", lastDay: "[gisteren om] LT", lastWeek: "[afgelopen] dddd [om] LT", sameElse: "L" }, relativeTime: { future: "over %s", past: "%s geleden", s: "een paar seconden", ss: "%d seconden", m: "één minuut", mm: "%d minuten", h: "één uur", hh: "%d uur", d: "één dag", dd: "%d dagen", M: "één maand", MM: "%d maanden", y: "één jaar", yy: "%d jaar" }, dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/, ordinal: function(e4) {
            return e4 + (1 === e4 || 8 === e4 || e4 >= 20 ? "ste" : "de");
          }, week: { dow: 1, doy: 4 } });
        })(n2(9034));
      }, 1228: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          var a3 = "jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.".split("_"), n3 = "jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec".split("_"), t2 = [/^jan/i, /^feb/i, /^maart|mrt.?$/i, /^apr/i, /^mei$/i, /^jun[i.]?$/i, /^jul[i.]?$/i, /^aug/i, /^sep/i, /^okt/i, /^nov/i, /^dec/i], c = /^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december|jan\.?|feb\.?|mrt\.?|apr\.?|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i;
          e3.defineLocale("nl", { months: "januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december".split("_"), monthsShort: function(e4, t3) {
            return e4 ? /-MMM-/.test(t3) ? n3[e4.month()] : a3[e4.month()] : a3;
          }, monthsRegex: c, monthsShortRegex: c, monthsStrictRegex: /^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december)/i, monthsShortStrictRegex: /^(jan\.?|feb\.?|mrt\.?|apr\.?|mei|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i, monthsParse: t2, longMonthsParse: t2, shortMonthsParse: t2, weekdays: "zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag".split("_"), weekdaysShort: "zo._ma._di._wo._do._vr._za.".split("_"), weekdaysMin: "zo_ma_di_wo_do_vr_za".split("_"), weekdaysParseExact: true, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD-MM-YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D MMMM YYYY HH:mm" }, calendar: { sameDay: "[vandaag om] LT", nextDay: "[morgen om] LT", nextWeek: "dddd [om] LT", lastDay: "[gisteren om] LT", lastWeek: "[afgelopen] dddd [om] LT", sameElse: "L" }, relativeTime: { future: "over %s", past: "%s geleden", s: "een paar seconden", ss: "%d seconden", m: "één minuut", mm: "%d minuten", h: "één uur", hh: "%d uur", d: "één dag", dd: "%d dagen", w: "één week", ww: "%d weken", M: "één maand", MM: "%d maanden", y: "één jaar", yy: "%d jaar" }, dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/, ordinal: function(e4) {
            return e4 + (1 === e4 || 8 === e4 || e4 >= 20 ? "ste" : "de");
          }, week: { dow: 1, doy: 4 } });
        })(n2(9034));
      }, 7130: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          e3.defineLocale("nn", { months: "januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember".split("_"), monthsShort: "jan._feb._mars_apr._mai_juni_juli_aug._sep._okt._nov._des.".split("_"), monthsParseExact: true, weekdays: "sundag_måndag_tysdag_onsdag_torsdag_fredag_laurdag".split("_"), weekdaysShort: "su._må._ty._on._to._fr._lau.".split("_"), weekdaysMin: "su_må_ty_on_to_fr_la".split("_"), weekdaysParseExact: true, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD.MM.YYYY", LL: "D. MMMM YYYY", LLL: "D. MMMM YYYY [kl.] H:mm", LLLL: "dddd D. MMMM YYYY [kl.] HH:mm" }, calendar: { sameDay: "[I dag klokka] LT", nextDay: "[I morgon klokka] LT", nextWeek: "dddd [klokka] LT", lastDay: "[I går klokka] LT", lastWeek: "[Føregåande] dddd [klokka] LT", sameElse: "L" }, relativeTime: { future: "om %s", past: "%s sidan", s: "nokre sekund", ss: "%d sekund", m: "eit minutt", mm: "%d minutt", h: "ein time", hh: "%d timar", d: "ein dag", dd: "%d dagar", w: "ei veke", ww: "%d veker", M: "ein månad", MM: "%d månader", y: "eit år", yy: "%d år" }, dayOfMonthOrdinalParse: /\d{1,2}\./, ordinal: "%d.", week: { dow: 1, doy: 4 } });
        })(n2(9034));
      }, 3130: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          e3.defineLocale("oc-lnc", { months: { standalone: "genièr_febrièr_març_abril_mai_junh_julhet_agost_setembre_octòbre_novembre_decembre".split("_"), format: "de genièr_de febrièr_de març_d'abril_de mai_de junh_de julhet_d'agost_de setembre_d'octòbre_de novembre_de decembre".split("_"), isFormat: /D[oD]?(\s)+MMMM/ }, monthsShort: "gen._febr._març_abr._mai_junh_julh._ago._set._oct._nov._dec.".split("_"), monthsParseExact: true, weekdays: "dimenge_diluns_dimars_dimècres_dijòus_divendres_dissabte".split("_"), weekdaysShort: "dg._dl._dm._dc._dj._dv._ds.".split("_"), weekdaysMin: "dg_dl_dm_dc_dj_dv_ds".split("_"), weekdaysParseExact: true, longDateFormat: { LT: "H:mm", LTS: "H:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM [de] YYYY", ll: "D MMM YYYY", LLL: "D MMMM [de] YYYY [a] H:mm", lll: "D MMM YYYY, H:mm", LLLL: "dddd D MMMM [de] YYYY [a] H:mm", llll: "ddd D MMM YYYY, H:mm" }, calendar: { sameDay: "[uèi a] LT", nextDay: "[deman a] LT", nextWeek: "dddd [a] LT", lastDay: "[ièr a] LT", lastWeek: "dddd [passat a] LT", sameElse: "L" }, relativeTime: { future: "d'aquí %s", past: "fa %s", s: "unas segondas", ss: "%d segondas", m: "una minuta", mm: "%d minutas", h: "una ora", hh: "%d oras", d: "un jorn", dd: "%d jorns", M: "un mes", MM: "%d meses", y: "un an", yy: "%d ans" }, dayOfMonthOrdinalParse: /\d{1,2}(r|n|t|è|a)/, ordinal: function(e4, a3) {
            var n3 = 1 === e4 ? "r" : 2 === e4 ? "n" : 3 === e4 ? "r" : 4 === e4 ? "t" : "è";
            return "w" !== a3 && "W" !== a3 || (n3 = "a"), e4 + n3;
          }, week: { dow: 1, doy: 4 } });
        })(n2(9034));
      }, 1282: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          var a3 = { 1: "੧", 2: "੨", 3: "੩", 4: "੪", 5: "੫", 6: "੬", 7: "੭", 8: "੮", 9: "੯", 0: "੦" }, n3 = { "੧": "1", "੨": "2", "੩": "3", "੪": "4", "੫": "5", "੬": "6", "੭": "7", "੮": "8", "੯": "9", "੦": "0" };
          e3.defineLocale("pa-in", { months: "ਜਨਵਰੀ_ਫ਼ਰਵਰੀ_ਮਾਰਚ_ਅਪ੍ਰੈਲ_ਮਈ_ਜੂਨ_ਜੁਲਾਈ_ਅਗਸਤ_ਸਤੰਬਰ_ਅਕਤੂਬਰ_ਨਵੰਬਰ_ਦਸੰਬਰ".split("_"), monthsShort: "ਜਨਵਰੀ_ਫ਼ਰਵਰੀ_ਮਾਰਚ_ਅਪ੍ਰੈਲ_ਮਈ_ਜੂਨ_ਜੁਲਾਈ_ਅਗਸਤ_ਸਤੰਬਰ_ਅਕਤੂਬਰ_ਨਵੰਬਰ_ਦਸੰਬਰ".split("_"), weekdays: "ਐਤਵਾਰ_ਸੋਮਵਾਰ_ਮੰਗਲਵਾਰ_ਬੁਧਵਾਰ_ਵੀਰਵਾਰ_ਸ਼ੁੱਕਰਵਾਰ_ਸ਼ਨੀਚਰਵਾਰ".split("_"), weekdaysShort: "ਐਤ_ਸੋਮ_ਮੰਗਲ_ਬੁਧ_ਵੀਰ_ਸ਼ੁਕਰ_ਸ਼ਨੀ".split("_"), weekdaysMin: "ਐਤ_ਸੋਮ_ਮੰਗਲ_ਬੁਧ_ਵੀਰ_ਸ਼ੁਕਰ_ਸ਼ਨੀ".split("_"), longDateFormat: { LT: "A h:mm ਵਜੇ", LTS: "A h:mm:ss ਵਜੇ", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY, A h:mm ਵਜੇ", LLLL: "dddd, D MMMM YYYY, A h:mm ਵਜੇ" }, calendar: { sameDay: "[ਅਜ] LT", nextDay: "[ਕਲ] LT", nextWeek: "[ਅਗਲਾ] dddd, LT", lastDay: "[ਕਲ] LT", lastWeek: "[ਪਿਛਲੇ] dddd, LT", sameElse: "L" }, relativeTime: { future: "%s ਵਿੱਚ", past: "%s ਪਿਛਲੇ", s: "ਕੁਝ ਸਕਿੰਟ", ss: "%d ਸਕਿੰਟ", m: "ਇਕ ਮਿੰਟ", mm: "%d ਮਿੰਟ", h: "ਇੱਕ ਘੰਟਾ", hh: "%d ਘੰਟੇ", d: "ਇੱਕ ਦਿਨ", dd: "%d ਦਿਨ", M: "ਇੱਕ ਮਹੀਨਾ", MM: "%d ਮਹੀਨੇ", y: "ਇੱਕ ਸਾਲ", yy: "%d ਸਾਲ" }, preparse: function(e4) {
            return e4.replace(/[੧੨੩੪੫੬੭੮੯੦]/g, (function(e5) {
              return n3[e5];
            }));
          }, postformat: function(e4) {
            return e4.replace(/\d/g, (function(e5) {
              return a3[e5];
            }));
          }, meridiemParse: /ਰਾਤ|ਸਵੇਰ|ਦੁਪਹਿਰ|ਸ਼ਾਮ/, meridiemHour: function(e4, a4) {
            return 12 === e4 && (e4 = 0), "ਰਾਤ" === a4 ? e4 < 4 ? e4 : e4 + 12 : "ਸਵੇਰ" === a4 ? e4 : "ਦੁਪਹਿਰ" === a4 ? e4 >= 10 ? e4 : e4 + 12 : "ਸ਼ਾਮ" === a4 ? e4 + 12 : void 0;
          }, meridiem: function(e4, a4, n4) {
            return e4 < 4 ? "ਰਾਤ" : e4 < 10 ? "ਸਵੇਰ" : e4 < 17 ? "ਦੁਪਹਿਰ" : e4 < 20 ? "ਸ਼ਾਮ" : "ਰਾਤ";
          }, week: { dow: 0, doy: 6 } });
        })(n2(9034));
      }, 8190: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          var a3 = "styczeń_luty_marzec_kwiecień_maj_czerwiec_lipiec_sierpień_wrzesień_październik_listopad_grudzień".split("_"), n3 = "stycznia_lutego_marca_kwietnia_maja_czerwca_lipca_sierpnia_września_października_listopada_grudnia".split("_"), t2 = [/^sty/i, /^lut/i, /^mar/i, /^kwi/i, /^maj/i, /^cze/i, /^lip/i, /^sie/i, /^wrz/i, /^paź/i, /^lis/i, /^gru/i];
          function c(e4) {
            return e4 % 10 < 5 && e4 % 10 > 1 && ~~(e4 / 10) % 10 != 1;
          }
          function s(e4, a4, n4) {
            var t3 = e4 + " ";
            switch (n4) {
              case "ss":
                return t3 + (c(e4) ? "sekundy" : "sekund");
              case "m":
                return a4 ? "minuta" : "minutę";
              case "mm":
                return t3 + (c(e4) ? "minuty" : "minut");
              case "h":
                return a4 ? "godzina" : "godzinę";
              case "hh":
                return t3 + (c(e4) ? "godziny" : "godzin");
              case "ww":
                return t3 + (c(e4) ? "tygodnie" : "tygodni");
              case "MM":
                return t3 + (c(e4) ? "miesiące" : "miesięcy");
              case "yy":
                return t3 + (c(e4) ? "lata" : "lat");
            }
          }
          e3.defineLocale("pl", { months: function(e4, t3) {
            return e4 ? /D MMMM/.test(t3) ? n3[e4.month()] : a3[e4.month()] : a3;
          }, monthsShort: "sty_lut_mar_kwi_maj_cze_lip_sie_wrz_paź_lis_gru".split("_"), monthsParse: t2, longMonthsParse: t2, shortMonthsParse: t2, weekdays: "niedziela_poniedziałek_wtorek_środa_czwartek_piątek_sobota".split("_"), weekdaysShort: "ndz_pon_wt_śr_czw_pt_sob".split("_"), weekdaysMin: "Nd_Pn_Wt_Śr_Cz_Pt_So".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD.MM.YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" }, calendar: { sameDay: "[Dziś o] LT", nextDay: "[Jutro o] LT", nextWeek: function() {
            switch (this.day()) {
              case 0:
                return "[W niedzielę o] LT";
              case 2:
                return "[We wtorek o] LT";
              case 3:
                return "[W środę o] LT";
              case 6:
                return "[W sobotę o] LT";
              default:
                return "[W] dddd [o] LT";
            }
          }, lastDay: "[Wczoraj o] LT", lastWeek: function() {
            switch (this.day()) {
              case 0:
                return "[W zeszłą niedzielę o] LT";
              case 3:
                return "[W zeszłą środę o] LT";
              case 6:
                return "[W zeszłą sobotę o] LT";
              default:
                return "[W zeszły] dddd [o] LT";
            }
          }, sameElse: "L" }, relativeTime: { future: "za %s", past: "%s temu", s: "kilka sekund", ss: s, m: s, mm: s, h: s, hh: s, d: "1 dzień", dd: "%d dni", w: "tydzień", ww: s, M: "miesiąc", MM: s, y: "rok", yy: s }, dayOfMonthOrdinalParse: /\d{1,2}\./, ordinal: "%d.", week: { dow: 1, doy: 4 } });
        })(n2(9034));
      }, 8135: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          e3.defineLocale("pt-br", { months: "janeiro_fevereiro_março_abril_maio_junho_julho_agosto_setembro_outubro_novembro_dezembro".split("_"), monthsShort: "jan_fev_mar_abr_mai_jun_jul_ago_set_out_nov_dez".split("_"), weekdays: "domingo_segunda-feira_terça-feira_quarta-feira_quinta-feira_sexta-feira_sábado".split("_"), weekdaysShort: "dom_seg_ter_qua_qui_sex_sáb".split("_"), weekdaysMin: "do_2ª_3ª_4ª_5ª_6ª_sá".split("_"), weekdaysParseExact: true, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D [de] MMMM [de] YYYY", LLL: "D [de] MMMM [de] YYYY [às] HH:mm", LLLL: "dddd, D [de] MMMM [de] YYYY [às] HH:mm" }, calendar: { sameDay: "[Hoje às] LT", nextDay: "[Amanhã às] LT", nextWeek: "dddd [às] LT", lastDay: "[Ontem às] LT", lastWeek: function() {
            return 0 === this.day() || 6 === this.day() ? "[Último] dddd [às] LT" : "[Última] dddd [às] LT";
          }, sameElse: "L" }, relativeTime: { future: "em %s", past: "há %s", s: "poucos segundos", ss: "%d segundos", m: "um minuto", mm: "%d minutos", h: "uma hora", hh: "%d horas", d: "um dia", dd: "%d dias", M: "um mês", MM: "%d meses", y: "um ano", yy: "%d anos" }, dayOfMonthOrdinalParse: /\d{1,2}º/, ordinal: "%dº", invalidDate: "Data inválida" });
        })(n2(9034));
      }, 1549: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          e3.defineLocale("pt", { months: "janeiro_fevereiro_março_abril_maio_junho_julho_agosto_setembro_outubro_novembro_dezembro".split("_"), monthsShort: "jan_fev_mar_abr_mai_jun_jul_ago_set_out_nov_dez".split("_"), weekdays: "Domingo_Segunda-feira_Terça-feira_Quarta-feira_Quinta-feira_Sexta-feira_Sábado".split("_"), weekdaysShort: "Dom_Seg_Ter_Qua_Qui_Sex_Sáb".split("_"), weekdaysMin: "Do_2ª_3ª_4ª_5ª_6ª_Sá".split("_"), weekdaysParseExact: true, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D [de] MMMM [de] YYYY", LLL: "D [de] MMMM [de] YYYY HH:mm", LLLL: "dddd, D [de] MMMM [de] YYYY HH:mm" }, calendar: { sameDay: "[Hoje às] LT", nextDay: "[Amanhã às] LT", nextWeek: "dddd [às] LT", lastDay: "[Ontem às] LT", lastWeek: function() {
            return 0 === this.day() || 6 === this.day() ? "[Último] dddd [às] LT" : "[Última] dddd [às] LT";
          }, sameElse: "L" }, relativeTime: { future: "em %s", past: "há %s", s: "segundos", ss: "%d segundos", m: "um minuto", mm: "%d minutos", h: "uma hora", hh: "%d horas", d: "um dia", dd: "%d dias", w: "uma semana", ww: "%d semanas", M: "um mês", MM: "%d meses", y: "um ano", yy: "%d anos" }, dayOfMonthOrdinalParse: /\d{1,2}º/, ordinal: "%dº", week: { dow: 1, doy: 4 } });
        })(n2(9034));
      }, 307: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          function a3(e4, a4, n3) {
            var t2 = " ";
            return (e4 % 100 >= 20 || e4 >= 100 && e4 % 100 == 0) && (t2 = " de "), e4 + t2 + { ss: "secunde", mm: "minute", hh: "ore", dd: "zile", ww: "săptămâni", MM: "luni", yy: "ani" }[n3];
          }
          e3.defineLocale("ro", { months: "ianuarie_februarie_martie_aprilie_mai_iunie_iulie_august_septembrie_octombrie_noiembrie_decembrie".split("_"), monthsShort: "ian._feb._mart._apr._mai_iun._iul._aug._sept._oct._nov._dec.".split("_"), monthsParseExact: true, weekdays: "duminică_luni_marți_miercuri_joi_vineri_sâmbătă".split("_"), weekdaysShort: "Dum_Lun_Mar_Mie_Joi_Vin_Sâm".split("_"), weekdaysMin: "Du_Lu_Ma_Mi_Jo_Vi_Sâ".split("_"), longDateFormat: { LT: "H:mm", LTS: "H:mm:ss", L: "DD.MM.YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY H:mm", LLLL: "dddd, D MMMM YYYY H:mm" }, calendar: { sameDay: "[azi la] LT", nextDay: "[mâine la] LT", nextWeek: "dddd [la] LT", lastDay: "[ieri la] LT", lastWeek: "[fosta] dddd [la] LT", sameElse: "L" }, relativeTime: { future: "peste %s", past: "%s în urmă", s: "câteva secunde", ss: a3, m: "un minut", mm: a3, h: "o oră", hh: a3, d: "o zi", dd: a3, w: "o săptămână", ww: a3, M: "o lună", MM: a3, y: "un an", yy: a3 }, week: { dow: 1, doy: 7 } });
        })(n2(9034));
      }, 9272: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          function a3(e4, a4, n4) {
            return "m" === n4 ? a4 ? "минута" : "минуту" : e4 + " " + (t2 = +e4, c = { ss: a4 ? "секунда_секунды_секунд" : "секунду_секунды_секунд", mm: a4 ? "минута_минуты_минут" : "минуту_минуты_минут", hh: "час_часа_часов", dd: "день_дня_дней", ww: "неделя_недели_недель", MM: "месяц_месяца_месяцев", yy: "год_года_лет" }[n4].split("_"), t2 % 10 == 1 && t2 % 100 != 11 ? c[0] : t2 % 10 >= 2 && t2 % 10 <= 4 && (t2 % 100 < 10 || t2 % 100 >= 20) ? c[1] : c[2]);
            var t2, c;
          }
          var n3 = [/^янв/i, /^фев/i, /^мар/i, /^апр/i, /^ма[йя]/i, /^июн/i, /^июл/i, /^авг/i, /^сен/i, /^окт/i, /^ноя/i, /^дек/i];
          e3.defineLocale("ru", { months: { format: "января_февраля_марта_апреля_мая_июня_июля_августа_сентября_октября_ноября_декабря".split("_"), standalone: "январь_февраль_март_апрель_май_июнь_июль_август_сентябрь_октябрь_ноябрь_декабрь".split("_") }, monthsShort: { format: "янв._февр._мар._апр._мая_июня_июля_авг._сент._окт._нояб._дек.".split("_"), standalone: "янв._февр._март_апр._май_июнь_июль_авг._сент._окт._нояб._дек.".split("_") }, weekdays: { standalone: "воскресенье_понедельник_вторник_среда_четверг_пятница_суббота".split("_"), format: "воскресенье_понедельник_вторник_среду_четверг_пятницу_субботу".split("_"), isFormat: /\[ ?[Вв] ?(?:прошлую|следующую|эту)? ?] ?dddd/ }, weekdaysShort: "вс_пн_вт_ср_чт_пт_сб".split("_"), weekdaysMin: "вс_пн_вт_ср_чт_пт_сб".split("_"), monthsParse: n3, longMonthsParse: n3, shortMonthsParse: n3, monthsRegex: /^(январ[ья]|янв\.?|феврал[ья]|февр?\.?|марта?|мар\.?|апрел[ья]|апр\.?|ма[йя]|июн[ья]|июн\.?|июл[ья]|июл\.?|августа?|авг\.?|сентябр[ья]|сент?\.?|октябр[ья]|окт\.?|ноябр[ья]|нояб?\.?|декабр[ья]|дек\.?)/i, monthsShortRegex: /^(январ[ья]|янв\.?|феврал[ья]|февр?\.?|марта?|мар\.?|апрел[ья]|апр\.?|ма[йя]|июн[ья]|июн\.?|июл[ья]|июл\.?|августа?|авг\.?|сентябр[ья]|сент?\.?|октябр[ья]|окт\.?|ноябр[ья]|нояб?\.?|декабр[ья]|дек\.?)/i, monthsStrictRegex: /^(январ[яь]|феврал[яь]|марта?|апрел[яь]|ма[яй]|июн[яь]|июл[яь]|августа?|сентябр[яь]|октябр[яь]|ноябр[яь]|декабр[яь])/i, monthsShortStrictRegex: /^(янв\.|февр?\.|мар[т.]|апр\.|ма[яй]|июн[ья.]|июл[ья.]|авг\.|сент?\.|окт\.|нояб?\.|дек\.)/i, longDateFormat: { LT: "H:mm", LTS: "H:mm:ss", L: "DD.MM.YYYY", LL: "D MMMM YYYY г.", LLL: "D MMMM YYYY г., H:mm", LLLL: "dddd, D MMMM YYYY г., H:mm" }, calendar: { sameDay: "[Сегодня, в] LT", nextDay: "[Завтра, в] LT", lastDay: "[Вчера, в] LT", nextWeek: function(e4) {
            if (e4.week() === this.week()) return 2 === this.day() ? "[Во] dddd, [в] LT" : "[В] dddd, [в] LT";
            switch (this.day()) {
              case 0:
                return "[В следующее] dddd, [в] LT";
              case 1:
              case 2:
              case 4:
                return "[В следующий] dddd, [в] LT";
              case 3:
              case 5:
              case 6:
                return "[В следующую] dddd, [в] LT";
            }
          }, lastWeek: function(e4) {
            if (e4.week() === this.week()) return 2 === this.day() ? "[Во] dddd, [в] LT" : "[В] dddd, [в] LT";
            switch (this.day()) {
              case 0:
                return "[В прошлое] dddd, [в] LT";
              case 1:
              case 2:
              case 4:
                return "[В прошлый] dddd, [в] LT";
              case 3:
              case 5:
              case 6:
                return "[В прошлую] dddd, [в] LT";
            }
          }, sameElse: "L" }, relativeTime: { future: "через %s", past: "%s назад", s: "несколько секунд", ss: a3, m: a3, mm: a3, h: "час", hh: a3, d: "день", dd: a3, w: "неделя", ww: a3, M: "месяц", MM: a3, y: "год", yy: a3 }, meridiemParse: /ночи|утра|дня|вечера/i, isPM: function(e4) {
            return /^(дня|вечера)$/.test(e4);
          }, meridiem: function(e4, a4, n4) {
            return e4 < 4 ? "ночи" : e4 < 12 ? "утра" : e4 < 17 ? "дня" : "вечера";
          }, dayOfMonthOrdinalParse: /\d{1,2}-(й|го|я)/, ordinal: function(e4, a4) {
            switch (a4) {
              case "M":
              case "d":
              case "DDD":
                return e4 + "-й";
              case "D":
                return e4 + "-го";
              case "w":
              case "W":
                return e4 + "-я";
              default:
                return e4;
            }
          }, week: { dow: 1, doy: 4 } });
        })(n2(9034));
      }, 9248: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          var a3 = ["جنوري", "فيبروري", "مارچ", "اپريل", "مئي", "جون", "جولاءِ", "آگسٽ", "سيپٽمبر", "آڪٽوبر", "نومبر", "ڊسمبر"], n3 = ["آچر", "سومر", "اڱارو", "اربع", "خميس", "جمع", "ڇنڇر"];
          e3.defineLocale("sd", { months: a3, monthsShort: a3, weekdays: n3, weekdaysShort: n3, weekdaysMin: n3, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd، D MMMM YYYY HH:mm" }, meridiemParse: /صبح|شام/, isPM: function(e4) {
            return "شام" === e4;
          }, meridiem: function(e4, a4, n4) {
            return e4 < 12 ? "صبح" : "شام";
          }, calendar: { sameDay: "[اڄ] LT", nextDay: "[سڀاڻي] LT", nextWeek: "dddd [اڳين هفتي تي] LT", lastDay: "[ڪالهه] LT", lastWeek: "[گزريل هفتي] dddd [تي] LT", sameElse: "L" }, relativeTime: { future: "%s پوء", past: "%s اڳ", s: "چند سيڪنڊ", ss: "%d سيڪنڊ", m: "هڪ منٽ", mm: "%d منٽ", h: "هڪ ڪلاڪ", hh: "%d ڪلاڪ", d: "هڪ ڏينهن", dd: "%d ڏينهن", M: "هڪ مهينو", MM: "%d مهينا", y: "هڪ سال", yy: "%d سال" }, preparse: function(e4) {
            return e4.replace(/،/g, ",");
          }, postformat: function(e4) {
            return e4.replace(/,/g, "،");
          }, week: { dow: 1, doy: 4 } });
        })(n2(9034));
      }, 4969: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          e3.defineLocale("se", { months: "ođđajagemánnu_guovvamánnu_njukčamánnu_cuoŋománnu_miessemánnu_geassemánnu_suoidnemánnu_borgemánnu_čakčamánnu_golggotmánnu_skábmamánnu_juovlamánnu".split("_"), monthsShort: "ođđj_guov_njuk_cuo_mies_geas_suoi_borg_čakč_golg_skáb_juov".split("_"), weekdays: "sotnabeaivi_vuossárga_maŋŋebárga_gaskavahkku_duorastat_bearjadat_lávvardat".split("_"), weekdaysShort: "sotn_vuos_maŋ_gask_duor_bear_láv".split("_"), weekdaysMin: "s_v_m_g_d_b_L".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD.MM.YYYY", LL: "MMMM D. [b.] YYYY", LLL: "MMMM D. [b.] YYYY [ti.] HH:mm", LLLL: "dddd, MMMM D. [b.] YYYY [ti.] HH:mm" }, calendar: { sameDay: "[otne ti] LT", nextDay: "[ihttin ti] LT", nextWeek: "dddd [ti] LT", lastDay: "[ikte ti] LT", lastWeek: "[ovddit] dddd [ti] LT", sameElse: "L" }, relativeTime: { future: "%s geažes", past: "maŋit %s", s: "moadde sekunddat", ss: "%d sekunddat", m: "okta minuhta", mm: "%d minuhtat", h: "okta diimmu", hh: "%d diimmut", d: "okta beaivi", dd: "%d beaivvit", M: "okta mánnu", MM: "%d mánut", y: "okta jahki", yy: "%d jagit" }, dayOfMonthOrdinalParse: /\d{1,2}\./, ordinal: "%d.", week: { dow: 1, doy: 4 } });
        })(n2(9034));
      }, 5522: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          e3.defineLocale("si", { months: "ජනවාරි_පෙබරවාරි_මාර්තු_අප්‍රේල්_මැයි_ජූනි_ජූලි_අගෝස්තු_සැප්තැම්බර්_ඔක්තෝබර්_නොවැම්බර්_දෙසැම්බර්".split("_"), monthsShort: "ජන_පෙබ_මාර්_අප්_මැයි_ජූනි_ජූලි_අගෝ_සැප්_ඔක්_නොවැ_දෙසැ".split("_"), weekdays: "ඉරිදා_සඳුදා_අඟහරුවාදා_බදාදා_බ්‍රහස්පතින්දා_සිකුරාදා_සෙනසුරාදා".split("_"), weekdaysShort: "ඉරි_සඳු_අඟ_බදා_බ්‍රහ_සිකු_සෙන".split("_"), weekdaysMin: "ඉ_ස_අ_බ_බ්‍ර_සි_සෙ".split("_"), weekdaysParseExact: true, longDateFormat: { LT: "a h:mm", LTS: "a h:mm:ss", L: "YYYY/MM/DD", LL: "YYYY MMMM D", LLL: "YYYY MMMM D, a h:mm", LLLL: "YYYY MMMM D [වැනි] dddd, a h:mm:ss" }, calendar: { sameDay: "[අද] LT[ට]", nextDay: "[හෙට] LT[ට]", nextWeek: "dddd LT[ට]", lastDay: "[ඊයේ] LT[ට]", lastWeek: "[පසුගිය] dddd LT[ට]", sameElse: "L" }, relativeTime: { future: "%sකින්", past: "%sකට පෙර", s: "තත්පර කිහිපය", ss: "තත්පර %d", m: "මිනිත්තුව", mm: "මිනිත්තු %d", h: "පැය", hh: "පැය %d", d: "දිනය", dd: "දින %d", M: "මාසය", MM: "මාස %d", y: "වසර", yy: "වසර %d" }, dayOfMonthOrdinalParse: /\d{1,2} වැනි/, ordinal: function(e4) {
            return e4 + " වැනි";
          }, meridiemParse: /පෙර වරු|පස් වරු|පෙ.ව|ප.ව./, isPM: function(e4) {
            return "ප.ව." === e4 || "පස් වරු" === e4;
          }, meridiem: function(e4, a3, n3) {
            return e4 > 11 ? n3 ? "ප.ව." : "පස් වරු" : n3 ? "පෙ.ව." : "පෙර වරු";
          } });
        })(n2(9034));
      }, 1581: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          var a3 = "január_február_marec_apríl_máj_jún_júl_august_september_október_november_december".split("_"), n3 = "jan_feb_mar_apr_máj_jún_júl_aug_sep_okt_nov_dec".split("_");
          function t2(e4) {
            return e4 > 1 && e4 < 5;
          }
          function c(e4, a4, n4, c2) {
            var s = e4 + " ";
            switch (n4) {
              case "s":
                return a4 || c2 ? "pár sekúnd" : "pár sekundami";
              case "ss":
                return a4 || c2 ? s + (t2(e4) ? "sekundy" : "sekúnd") : s + "sekundami";
              case "m":
                return a4 ? "minúta" : c2 ? "minútu" : "minútou";
              case "mm":
                return a4 || c2 ? s + (t2(e4) ? "minúty" : "minút") : s + "minútami";
              case "h":
                return a4 ? "hodina" : c2 ? "hodinu" : "hodinou";
              case "hh":
                return a4 || c2 ? s + (t2(e4) ? "hodiny" : "hodín") : s + "hodinami";
              case "d":
                return a4 || c2 ? "deň" : "dňom";
              case "dd":
                return a4 || c2 ? s + (t2(e4) ? "dni" : "dní") : s + "dňami";
              case "M":
                return a4 || c2 ? "mesiac" : "mesiacom";
              case "MM":
                return a4 || c2 ? s + (t2(e4) ? "mesiace" : "mesiacov") : s + "mesiacmi";
              case "y":
                return a4 || c2 ? "rok" : "rokom";
              case "yy":
                return a4 || c2 ? s + (t2(e4) ? "roky" : "rokov") : s + "rokmi";
            }
          }
          e3.defineLocale("sk", { months: a3, monthsShort: n3, weekdays: "nedeľa_pondelok_utorok_streda_štvrtok_piatok_sobota".split("_"), weekdaysShort: "ne_po_ut_st_št_pi_so".split("_"), weekdaysMin: "ne_po_ut_st_št_pi_so".split("_"), longDateFormat: { LT: "H:mm", LTS: "H:mm:ss", L: "DD.MM.YYYY", LL: "D. MMMM YYYY", LLL: "D. MMMM YYYY H:mm", LLLL: "dddd D. MMMM YYYY H:mm" }, calendar: { sameDay: "[dnes o] LT", nextDay: "[zajtra o] LT", nextWeek: function() {
            switch (this.day()) {
              case 0:
                return "[v nedeľu o] LT";
              case 1:
              case 2:
                return "[v] dddd [o] LT";
              case 3:
                return "[v stredu o] LT";
              case 4:
                return "[vo štvrtok o] LT";
              case 5:
                return "[v piatok o] LT";
              case 6:
                return "[v sobotu o] LT";
            }
          }, lastDay: "[včera o] LT", lastWeek: function() {
            switch (this.day()) {
              case 0:
                return "[minulú nedeľu o] LT";
              case 1:
              case 2:
              case 4:
              case 5:
                return "[minulý] dddd [o] LT";
              case 3:
                return "[minulú stredu o] LT";
              case 6:
                return "[minulú sobotu o] LT";
            }
          }, sameElse: "L" }, relativeTime: { future: "za %s", past: "pred %s", s: c, ss: c, m: c, mm: c, h: c, hh: c, d: c, dd: c, M: c, MM: c, y: c, yy: c }, dayOfMonthOrdinalParse: /\d{1,2}\./, ordinal: "%d.", week: { dow: 1, doy: 4 } });
        })(n2(9034));
      }, 6428: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          function a3(e4, a4, n3, t2) {
            var c = e4 + " ";
            switch (n3) {
              case "s":
                return a4 || t2 ? "nekaj sekund" : "nekaj sekundami";
              case "ss":
                return c + (1 === e4 ? a4 ? "sekundo" : "sekundi" : 2 === e4 ? a4 || t2 ? "sekundi" : "sekundah" : e4 < 5 ? a4 || t2 ? "sekunde" : "sekundah" : "sekund");
              case "m":
                return a4 ? "ena minuta" : "eno minuto";
              case "mm":
                return c + (1 === e4 ? a4 ? "minuta" : "minuto" : 2 === e4 ? a4 || t2 ? "minuti" : "minutama" : e4 < 5 ? a4 || t2 ? "minute" : "minutami" : a4 || t2 ? "minut" : "minutami");
              case "h":
                return a4 ? "ena ura" : "eno uro";
              case "hh":
                return c + (1 === e4 ? a4 ? "ura" : "uro" : 2 === e4 ? a4 || t2 ? "uri" : "urama" : e4 < 5 ? a4 || t2 ? "ure" : "urami" : a4 || t2 ? "ur" : "urami");
              case "d":
                return a4 || t2 ? "en dan" : "enim dnem";
              case "dd":
                return c + (1 === e4 ? a4 || t2 ? "dan" : "dnem" : 2 === e4 ? a4 || t2 ? "dni" : "dnevoma" : a4 || t2 ? "dni" : "dnevi");
              case "M":
                return a4 || t2 ? "en mesec" : "enim mesecem";
              case "MM":
                return c + (1 === e4 ? a4 || t2 ? "mesec" : "mesecem" : 2 === e4 ? a4 || t2 ? "meseca" : "mesecema" : e4 < 5 ? a4 || t2 ? "mesece" : "meseci" : a4 || t2 ? "mesecev" : "meseci");
              case "y":
                return a4 || t2 ? "eno leto" : "enim letom";
              case "yy":
                return c + (1 === e4 ? a4 || t2 ? "leto" : "letom" : 2 === e4 ? a4 || t2 ? "leti" : "letoma" : e4 < 5 ? a4 || t2 ? "leta" : "leti" : a4 || t2 ? "let" : "leti");
            }
          }
          e3.defineLocale("sl", { months: "januar_februar_marec_april_maj_junij_julij_avgust_september_oktober_november_december".split("_"), monthsShort: "jan._feb._mar._apr._maj._jun._jul._avg._sep._okt._nov._dec.".split("_"), monthsParseExact: true, weekdays: "nedelja_ponedeljek_torek_sreda_četrtek_petek_sobota".split("_"), weekdaysShort: "ned._pon._tor._sre._čet._pet._sob.".split("_"), weekdaysMin: "ne_po_to_sr_če_pe_so".split("_"), weekdaysParseExact: true, longDateFormat: { LT: "H:mm", LTS: "H:mm:ss", L: "DD. MM. YYYY", LL: "D. MMMM YYYY", LLL: "D. MMMM YYYY H:mm", LLLL: "dddd, D. MMMM YYYY H:mm" }, calendar: { sameDay: "[danes ob] LT", nextDay: "[jutri ob] LT", nextWeek: function() {
            switch (this.day()) {
              case 0:
                return "[v] [nedeljo] [ob] LT";
              case 3:
                return "[v] [sredo] [ob] LT";
              case 6:
                return "[v] [soboto] [ob] LT";
              case 1:
              case 2:
              case 4:
              case 5:
                return "[v] dddd [ob] LT";
            }
          }, lastDay: "[včeraj ob] LT", lastWeek: function() {
            switch (this.day()) {
              case 0:
                return "[prejšnjo] [nedeljo] [ob] LT";
              case 3:
                return "[prejšnjo] [sredo] [ob] LT";
              case 6:
                return "[prejšnjo] [soboto] [ob] LT";
              case 1:
              case 2:
              case 4:
              case 5:
                return "[prejšnji] dddd [ob] LT";
            }
          }, sameElse: "L" }, relativeTime: { future: "čez %s", past: "pred %s", s: a3, ss: a3, m: a3, mm: a3, h: a3, hh: a3, d: a3, dd: a3, M: a3, MM: a3, y: a3, yy: a3 }, dayOfMonthOrdinalParse: /\d{1,2}\./, ordinal: "%d.", week: { dow: 1, doy: 7 } });
        })(n2(9034));
      }, 4611: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          e3.defineLocale("sq", { months: "Janar_Shkurt_Mars_Prill_Maj_Qershor_Korrik_Gusht_Shtator_Tetor_Nëntor_Dhjetor".split("_"), monthsShort: "Jan_Shk_Mar_Pri_Maj_Qer_Kor_Gus_Sht_Tet_Nën_Dhj".split("_"), weekdays: "E Diel_E Hënë_E Martë_E Mërkurë_E Enjte_E Premte_E Shtunë".split("_"), weekdaysShort: "Die_Hën_Mar_Mër_Enj_Pre_Sht".split("_"), weekdaysMin: "D_H_Ma_Më_E_P_Sh".split("_"), weekdaysParseExact: true, meridiemParse: /PD|MD/, isPM: function(e4) {
            return "M" === e4.charAt(0);
          }, meridiem: function(e4, a3, n3) {
            return e4 < 12 ? "PD" : "MD";
          }, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" }, calendar: { sameDay: "[Sot në] LT", nextDay: "[Nesër në] LT", nextWeek: "dddd [në] LT", lastDay: "[Dje në] LT", lastWeek: "dddd [e kaluar në] LT", sameElse: "L" }, relativeTime: { future: "në %s", past: "%s më parë", s: "disa sekonda", ss: "%d sekonda", m: "një minutë", mm: "%d minuta", h: "një orë", hh: "%d orë", d: "një ditë", dd: "%d ditë", M: "një muaj", MM: "%d muaj", y: "një vit", yy: "%d vite" }, dayOfMonthOrdinalParse: /\d{1,2}\./, ordinal: "%d.", week: { dow: 1, doy: 4 } });
        })(n2(9034));
      }, 185: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          var a3 = { words: { ss: ["секунда", "секунде", "секунди"], m: ["један минут", "једног минута"], mm: ["минут", "минута", "минута"], h: ["један сат", "једног сата"], hh: ["сат", "сата", "сати"], d: ["један дан", "једног дана"], dd: ["дан", "дана", "дана"], M: ["један месец", "једног месеца"], MM: ["месец", "месеца", "месеци"], y: ["једну годину", "једне године"], yy: ["годину", "године", "година"] }, correctGrammaticalCase: function(e4, a4) {
            return e4 % 10 >= 1 && e4 % 10 <= 4 && (e4 % 100 < 10 || e4 % 100 >= 20) ? e4 % 10 == 1 ? a4[0] : a4[1] : a4[2];
          }, translate: function(e4, n3, t2, c) {
            var s, o = a3.words[t2];
            return 1 === t2.length ? "y" === t2 && n3 ? "једна година" : c || n3 ? o[0] : o[1] : (s = a3.correctGrammaticalCase(e4, o), "yy" === t2 && n3 && "годину" === s ? e4 + " година" : e4 + " " + s);
          } };
          e3.defineLocale("sr-cyrl", { months: "јануар_фебруар_март_април_мај_јун_јул_август_септембар_октобар_новембар_децембар".split("_"), monthsShort: "јан._феб._мар._апр._мај_јун_јул_авг._сеп._окт._нов._дец.".split("_"), monthsParseExact: true, weekdays: "недеља_понедељак_уторак_среда_четвртак_петак_субота".split("_"), weekdaysShort: "нед._пон._уто._сре._чет._пет._суб.".split("_"), weekdaysMin: "не_по_ут_ср_че_пе_су".split("_"), weekdaysParseExact: true, longDateFormat: { LT: "H:mm", LTS: "H:mm:ss", L: "D. M. YYYY.", LL: "D. MMMM YYYY.", LLL: "D. MMMM YYYY. H:mm", LLLL: "dddd, D. MMMM YYYY. H:mm" }, calendar: { sameDay: "[данас у] LT", nextDay: "[сутра у] LT", nextWeek: function() {
            switch (this.day()) {
              case 0:
                return "[у] [недељу] [у] LT";
              case 3:
                return "[у] [среду] [у] LT";
              case 6:
                return "[у] [суботу] [у] LT";
              case 1:
              case 2:
              case 4:
              case 5:
                return "[у] dddd [у] LT";
            }
          }, lastDay: "[јуче у] LT", lastWeek: function() {
            return ["[прошле] [недеље] [у] LT", "[прошлог] [понедељка] [у] LT", "[прошлог] [уторка] [у] LT", "[прошле] [среде] [у] LT", "[прошлог] [четвртка] [у] LT", "[прошлог] [петка] [у] LT", "[прошле] [суботе] [у] LT"][this.day()];
          }, sameElse: "L" }, relativeTime: { future: "за %s", past: "пре %s", s: "неколико секунди", ss: a3.translate, m: a3.translate, mm: a3.translate, h: a3.translate, hh: a3.translate, d: a3.translate, dd: a3.translate, M: a3.translate, MM: a3.translate, y: a3.translate, yy: a3.translate }, dayOfMonthOrdinalParse: /\d{1,2}\./, ordinal: "%d.", week: { dow: 1, doy: 7 } });
        })(n2(9034));
      }, 9821: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          var a3 = { words: { ss: ["sekunda", "sekunde", "sekundi"], m: ["jedan minut", "jednog minuta"], mm: ["minut", "minuta", "minuta"], h: ["jedan sat", "jednog sata"], hh: ["sat", "sata", "sati"], d: ["jedan dan", "jednog dana"], dd: ["dan", "dana", "dana"], M: ["jedan mesec", "jednog meseca"], MM: ["mesec", "meseca", "meseci"], y: ["jednu godinu", "jedne godine"], yy: ["godinu", "godine", "godina"] }, correctGrammaticalCase: function(e4, a4) {
            return e4 % 10 >= 1 && e4 % 10 <= 4 && (e4 % 100 < 10 || e4 % 100 >= 20) ? e4 % 10 == 1 ? a4[0] : a4[1] : a4[2];
          }, translate: function(e4, n3, t2, c) {
            var s, o = a3.words[t2];
            return 1 === t2.length ? "y" === t2 && n3 ? "jedna godina" : c || n3 ? o[0] : o[1] : (s = a3.correctGrammaticalCase(e4, o), "yy" === t2 && n3 && "godinu" === s ? e4 + " godina" : e4 + " " + s);
          } };
          e3.defineLocale("sr", { months: "januar_februar_mart_april_maj_jun_jul_avgust_septembar_oktobar_novembar_decembar".split("_"), monthsShort: "jan._feb._mar._apr._maj_jun_jul_avg._sep._okt._nov._dec.".split("_"), monthsParseExact: true, weekdays: "nedelja_ponedeljak_utorak_sreda_četvrtak_petak_subota".split("_"), weekdaysShort: "ned._pon._uto._sre._čet._pet._sub.".split("_"), weekdaysMin: "ne_po_ut_sr_če_pe_su".split("_"), weekdaysParseExact: true, longDateFormat: { LT: "H:mm", LTS: "H:mm:ss", L: "D. M. YYYY.", LL: "D. MMMM YYYY.", LLL: "D. MMMM YYYY. H:mm", LLLL: "dddd, D. MMMM YYYY. H:mm" }, calendar: { sameDay: "[danas u] LT", nextDay: "[sutra u] LT", nextWeek: function() {
            switch (this.day()) {
              case 0:
                return "[u] [nedelju] [u] LT";
              case 3:
                return "[u] [sredu] [u] LT";
              case 6:
                return "[u] [subotu] [u] LT";
              case 1:
              case 2:
              case 4:
              case 5:
                return "[u] dddd [u] LT";
            }
          }, lastDay: "[juče u] LT", lastWeek: function() {
            return ["[prošle] [nedelje] [u] LT", "[prošlog] [ponedeljka] [u] LT", "[prošlog] [utorka] [u] LT", "[prošle] [srede] [u] LT", "[prošlog] [četvrtka] [u] LT", "[prošlog] [petka] [u] LT", "[prošle] [subote] [u] LT"][this.day()];
          }, sameElse: "L" }, relativeTime: { future: "za %s", past: "pre %s", s: "nekoliko sekundi", ss: a3.translate, m: a3.translate, mm: a3.translate, h: a3.translate, hh: a3.translate, d: a3.translate, dd: a3.translate, M: a3.translate, MM: a3.translate, y: a3.translate, yy: a3.translate }, dayOfMonthOrdinalParse: /\d{1,2}\./, ordinal: "%d.", week: { dow: 1, doy: 7 } });
        })(n2(9034));
      }, 5029: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          e3.defineLocale("ss", { months: "Bhimbidvwane_Indlovana_Indlov'lenkhulu_Mabasa_Inkhwekhweti_Inhlaba_Kholwane_Ingci_Inyoni_Imphala_Lweti_Ingongoni".split("_"), monthsShort: "Bhi_Ina_Inu_Mab_Ink_Inh_Kho_Igc_Iny_Imp_Lwe_Igo".split("_"), weekdays: "Lisontfo_Umsombuluko_Lesibili_Lesitsatfu_Lesine_Lesihlanu_Umgcibelo".split("_"), weekdaysShort: "Lis_Umb_Lsb_Les_Lsi_Lsh_Umg".split("_"), weekdaysMin: "Li_Us_Lb_Lt_Ls_Lh_Ug".split("_"), weekdaysParseExact: true, longDateFormat: { LT: "h:mm A", LTS: "h:mm:ss A", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY h:mm A", LLLL: "dddd, D MMMM YYYY h:mm A" }, calendar: { sameDay: "[Namuhla nga] LT", nextDay: "[Kusasa nga] LT", nextWeek: "dddd [nga] LT", lastDay: "[Itolo nga] LT", lastWeek: "dddd [leliphelile] [nga] LT", sameElse: "L" }, relativeTime: { future: "nga %s", past: "wenteka nga %s", s: "emizuzwana lomcane", ss: "%d mzuzwana", m: "umzuzu", mm: "%d emizuzu", h: "lihora", hh: "%d emahora", d: "lilanga", dd: "%d emalanga", M: "inyanga", MM: "%d tinyanga", y: "umnyaka", yy: "%d iminyaka" }, meridiemParse: /ekuseni|emini|entsambama|ebusuku/, meridiem: function(e4, a3, n3) {
            return e4 < 11 ? "ekuseni" : e4 < 15 ? "emini" : e4 < 19 ? "entsambama" : "ebusuku";
          }, meridiemHour: function(e4, a3) {
            return 12 === e4 && (e4 = 0), "ekuseni" === a3 ? e4 : "emini" === a3 ? e4 >= 11 ? e4 : e4 + 12 : "entsambama" === a3 || "ebusuku" === a3 ? 0 === e4 ? 0 : e4 + 12 : void 0;
          }, dayOfMonthOrdinalParse: /\d{1,2}/, ordinal: "%d", week: { dow: 1, doy: 4 } });
        })(n2(9034));
      }, 939: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          e3.defineLocale("sv", { months: "januari_februari_mars_april_maj_juni_juli_augusti_september_oktober_november_december".split("_"), monthsShort: "jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec".split("_"), weekdays: "söndag_måndag_tisdag_onsdag_torsdag_fredag_lördag".split("_"), weekdaysShort: "sön_mån_tis_ons_tor_fre_lör".split("_"), weekdaysMin: "sö_må_ti_on_to_fr_lö".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "YYYY-MM-DD", LL: "D MMMM YYYY", LLL: "D MMMM YYYY [kl.] HH:mm", LLLL: "dddd D MMMM YYYY [kl.] HH:mm", lll: "D MMM YYYY HH:mm", llll: "ddd D MMM YYYY HH:mm" }, calendar: { sameDay: "[Idag] LT", nextDay: "[Imorgon] LT", lastDay: "[Igår] LT", nextWeek: "[På] dddd LT", lastWeek: "[I] dddd[s] LT", sameElse: "L" }, relativeTime: { future: "om %s", past: "för %s sedan", s: "några sekunder", ss: "%d sekunder", m: "en minut", mm: "%d minuter", h: "en timme", hh: "%d timmar", d: "en dag", dd: "%d dagar", M: "en månad", MM: "%d månader", y: "ett år", yy: "%d år" }, dayOfMonthOrdinalParse: /\d{1,2}(\:e|\:a)/, ordinal: function(e4) {
            var a3 = e4 % 10;
            return e4 + (1 == ~~(e4 % 100 / 10) ? ":e" : 1 === a3 || 2 === a3 ? ":a" : ":e");
          }, week: { dow: 1, doy: 4 } });
        })(n2(9034));
      }, 3107: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          e3.defineLocale("sw", { months: "Januari_Februari_Machi_Aprili_Mei_Juni_Julai_Agosti_Septemba_Oktoba_Novemba_Desemba".split("_"), monthsShort: "Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ago_Sep_Okt_Nov_Des".split("_"), weekdays: "Jumapili_Jumatatu_Jumanne_Jumatano_Alhamisi_Ijumaa_Jumamosi".split("_"), weekdaysShort: "Jpl_Jtat_Jnne_Jtan_Alh_Ijm_Jmos".split("_"), weekdaysMin: "J2_J3_J4_J5_Al_Ij_J1".split("_"), weekdaysParseExact: true, longDateFormat: { LT: "hh:mm A", LTS: "HH:mm:ss", L: "DD.MM.YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" }, calendar: { sameDay: "[leo saa] LT", nextDay: "[kesho saa] LT", nextWeek: "[wiki ijayo] dddd [saat] LT", lastDay: "[jana] LT", lastWeek: "[wiki iliyopita] dddd [saat] LT", sameElse: "L" }, relativeTime: { future: "%s baadaye", past: "tokea %s", s: "hivi punde", ss: "sekunde %d", m: "dakika moja", mm: "dakika %d", h: "saa limoja", hh: "masaa %d", d: "siku moja", dd: "siku %d", M: "mwezi mmoja", MM: "miezi %d", y: "mwaka mmoja", yy: "miaka %d" }, week: { dow: 1, doy: 7 } });
        })(n2(9034));
      }, 2304: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          var a3 = { 1: "௧", 2: "௨", 3: "௩", 4: "௪", 5: "௫", 6: "௬", 7: "௭", 8: "௮", 9: "௯", 0: "௦" }, n3 = { "௧": "1", "௨": "2", "௩": "3", "௪": "4", "௫": "5", "௬": "6", "௭": "7", "௮": "8", "௯": "9", "௦": "0" };
          e3.defineLocale("ta", { months: "ஜனவரி_பிப்ரவரி_மார்ச்_ஏப்ரல்_மே_ஜூன்_ஜூலை_ஆகஸ்ட்_செப்டெம்பர்_அக்டோபர்_நவம்பர்_டிசம்பர்".split("_"), monthsShort: "ஜனவரி_பிப்ரவரி_மார்ச்_ஏப்ரல்_மே_ஜூன்_ஜூலை_ஆகஸ்ட்_செப்டெம்பர்_அக்டோபர்_நவம்பர்_டிசம்பர்".split("_"), weekdays: "ஞாயிற்றுக்கிழமை_திங்கட்கிழமை_செவ்வாய்கிழமை_புதன்கிழமை_வியாழக்கிழமை_வெள்ளிக்கிழமை_சனிக்கிழமை".split("_"), weekdaysShort: "ஞாயிறு_திங்கள்_செவ்வாய்_புதன்_வியாழன்_வெள்ளி_சனி".split("_"), weekdaysMin: "ஞா_தி_செ_பு_வி_வெ_ச".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY, HH:mm", LLLL: "dddd, D MMMM YYYY, HH:mm" }, calendar: { sameDay: "[இன்று] LT", nextDay: "[நாளை] LT", nextWeek: "dddd, LT", lastDay: "[நேற்று] LT", lastWeek: "[கடந்த வாரம்] dddd, LT", sameElse: "L" }, relativeTime: { future: "%s இல்", past: "%s முன்", s: "ஒரு சில விநாடிகள்", ss: "%d விநாடிகள்", m: "ஒரு நிமிடம்", mm: "%d நிமிடங்கள்", h: "ஒரு மணி நேரம்", hh: "%d மணி நேரம்", d: "ஒரு நாள்", dd: "%d நாட்கள்", M: "ஒரு மாதம்", MM: "%d மாதங்கள்", y: "ஒரு வருடம்", yy: "%d ஆண்டுகள்" }, dayOfMonthOrdinalParse: /\d{1,2}வது/, ordinal: function(e4) {
            return e4 + "வது";
          }, preparse: function(e4) {
            return e4.replace(/[௧௨௩௪௫௬௭௮௯௦]/g, (function(e5) {
              return n3[e5];
            }));
          }, postformat: function(e4) {
            return e4.replace(/\d/g, (function(e5) {
              return a3[e5];
            }));
          }, meridiemParse: /யாமம்|வைகறை|காலை|நண்பகல்|எற்பாடு|மாலை/, meridiem: function(e4, a4, n4) {
            return e4 < 2 ? " யாமம்" : e4 < 6 ? " வைகறை" : e4 < 10 ? " காலை" : e4 < 14 ? " நண்பகல்" : e4 < 18 ? " எற்பாடு" : e4 < 22 ? " மாலை" : " யாமம்";
          }, meridiemHour: function(e4, a4) {
            return 12 === e4 && (e4 = 0), "யாமம்" === a4 ? e4 < 2 ? e4 : e4 + 12 : "வைகறை" === a4 || "காலை" === a4 || "நண்பகல்" === a4 && e4 >= 10 ? e4 : e4 + 12;
          }, week: { dow: 0, doy: 6 } });
        })(n2(9034));
      }, 2550: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          e3.defineLocale("te", { months: "జనవరి_ఫిబ్రవరి_మార్చి_ఏప్రిల్_మే_జూన్_జులై_ఆగస్టు_సెప్టెంబర్_అక్టోబర్_నవంబర్_డిసెంబర్".split("_"), monthsShort: "జన._ఫిబ్ర._మార్చి_ఏప్రి._మే_జూన్_జులై_ఆగ._సెప్._అక్టో._నవ._డిసె.".split("_"), monthsParseExact: true, weekdays: "ఆదివారం_సోమవారం_మంగళవారం_బుధవారం_గురువారం_శుక్రవారం_శనివారం".split("_"), weekdaysShort: "ఆది_సోమ_మంగళ_బుధ_గురు_శుక్ర_శని".split("_"), weekdaysMin: "ఆ_సో_మం_బు_గు_శు_శ".split("_"), longDateFormat: { LT: "A h:mm", LTS: "A h:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY, A h:mm", LLLL: "dddd, D MMMM YYYY, A h:mm" }, calendar: { sameDay: "[నేడు] LT", nextDay: "[రేపు] LT", nextWeek: "dddd, LT", lastDay: "[నిన్న] LT", lastWeek: "[గత] dddd, LT", sameElse: "L" }, relativeTime: { future: "%s లో", past: "%s క్రితం", s: "కొన్ని క్షణాలు", ss: "%d సెకన్లు", m: "ఒక నిమిషం", mm: "%d నిమిషాలు", h: "ఒక గంట", hh: "%d గంటలు", d: "ఒక రోజు", dd: "%d రోజులు", M: "ఒక నెల", MM: "%d నెలలు", y: "ఒక సంవత్సరం", yy: "%d సంవత్సరాలు" }, dayOfMonthOrdinalParse: /\d{1,2}వ/, ordinal: "%dవ", meridiemParse: /రాత్రి|ఉదయం|మధ్యాహ్నం|సాయంత్రం/, meridiemHour: function(e4, a3) {
            return 12 === e4 && (e4 = 0), "రాత్రి" === a3 ? e4 < 4 ? e4 : e4 + 12 : "ఉదయం" === a3 ? e4 : "మధ్యాహ్నం" === a3 ? e4 >= 10 ? e4 : e4 + 12 : "సాయంత్రం" === a3 ? e4 + 12 : void 0;
          }, meridiem: function(e4, a3, n3) {
            return e4 < 4 ? "రాత్రి" : e4 < 10 ? "ఉదయం" : e4 < 17 ? "మధ్యాహ్నం" : e4 < 20 ? "సాయంత్రం" : "రాత్రి";
          }, week: { dow: 0, doy: 6 } });
        })(n2(9034));
      }, 9717: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          e3.defineLocale("tet", { months: "Janeiru_Fevereiru_Marsu_Abril_Maiu_Juñu_Jullu_Agustu_Setembru_Outubru_Novembru_Dezembru".split("_"), monthsShort: "Jan_Fev_Mar_Abr_Mai_Jun_Jul_Ago_Set_Out_Nov_Dez".split("_"), weekdays: "Domingu_Segunda_Tersa_Kuarta_Kinta_Sesta_Sabadu".split("_"), weekdaysShort: "Dom_Seg_Ters_Kua_Kint_Sest_Sab".split("_"), weekdaysMin: "Do_Seg_Te_Ku_Ki_Ses_Sa".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" }, calendar: { sameDay: "[Ohin iha] LT", nextDay: "[Aban iha] LT", nextWeek: "dddd [iha] LT", lastDay: "[Horiseik iha] LT", lastWeek: "dddd [semana kotuk] [iha] LT", sameElse: "L" }, relativeTime: { future: "iha %s", past: "%s liuba", s: "segundu balun", ss: "segundu %d", m: "minutu ida", mm: "minutu %d", h: "oras ida", hh: "oras %d", d: "loron ida", dd: "loron %d", M: "fulan ida", MM: "fulan %d", y: "tinan ida", yy: "tinan %d" }, dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/, ordinal: function(e4) {
            var a3 = e4 % 10;
            return e4 + (1 == ~~(e4 % 100 / 10) ? "th" : 1 === a3 ? "st" : 2 === a3 ? "nd" : 3 === a3 ? "rd" : "th");
          }, week: { dow: 1, doy: 4 } });
        })(n2(9034));
      }, 7669: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          var a3 = { 0: "-ум", 1: "-ум", 2: "-юм", 3: "-юм", 4: "-ум", 5: "-ум", 6: "-ум", 7: "-ум", 8: "-ум", 9: "-ум", 10: "-ум", 12: "-ум", 13: "-ум", 20: "-ум", 30: "-юм", 40: "-ум", 50: "-ум", 60: "-ум", 70: "-ум", 80: "-ум", 90: "-ум", 100: "-ум" };
          e3.defineLocale("tg", { months: { format: "январи_феврали_марти_апрели_майи_июни_июли_августи_сентябри_октябри_ноябри_декабри".split("_"), standalone: "январ_феврал_март_апрел_май_июн_июл_август_сентябр_октябр_ноябр_декабр".split("_") }, monthsShort: "янв_фев_мар_апр_май_июн_июл_авг_сен_окт_ноя_дек".split("_"), weekdays: "якшанбе_душанбе_сешанбе_чоршанбе_панҷшанбе_ҷумъа_шанбе".split("_"), weekdaysShort: "яшб_дшб_сшб_чшб_пшб_ҷум_шнб".split("_"), weekdaysMin: "яш_дш_сш_чш_пш_ҷм_шб".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD.MM.YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" }, calendar: { sameDay: "[Имрӯз соати] LT", nextDay: "[Фардо соати] LT", lastDay: "[Дирӯз соати] LT", nextWeek: "dddd[и] [ҳафтаи оянда соати] LT", lastWeek: "dddd[и] [ҳафтаи гузашта соати] LT", sameElse: "L" }, relativeTime: { future: "баъди %s", past: "%s пеш", s: "якчанд сония", m: "як дақиқа", mm: "%d дақиқа", h: "як соат", hh: "%d соат", d: "як рӯз", dd: "%d рӯз", M: "як моҳ", MM: "%d моҳ", y: "як сол", yy: "%d сол" }, meridiemParse: /шаб|субҳ|рӯз|бегоҳ/, meridiemHour: function(e4, a4) {
            return 12 === e4 && (e4 = 0), "шаб" === a4 ? e4 < 4 ? e4 : e4 + 12 : "субҳ" === a4 ? e4 : "рӯз" === a4 ? e4 >= 11 ? e4 : e4 + 12 : "бегоҳ" === a4 ? e4 + 12 : void 0;
          }, meridiem: function(e4, a4, n3) {
            return e4 < 4 ? "шаб" : e4 < 11 ? "субҳ" : e4 < 16 ? "рӯз" : e4 < 19 ? "бегоҳ" : "шаб";
          }, dayOfMonthOrdinalParse: /\d{1,2}-(ум|юм)/, ordinal: function(e4) {
            return e4 + (a3[e4] || a3[e4 % 10] || a3[e4 >= 100 ? 100 : null]);
          }, week: { dow: 1, doy: 7 } });
        })(n2(9034));
      }, 4959: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          e3.defineLocale("th", { months: "มกราคม_กุมภาพันธ์_มีนาคม_เมษายน_พฤษภาคม_มิถุนายน_กรกฎาคม_สิงหาคม_กันยายน_ตุลาคม_พฤศจิกายน_ธันวาคม".split("_"), monthsShort: "ม.ค._ก.พ._มี.ค._เม.ย._พ.ค._มิ.ย._ก.ค._ส.ค._ก.ย._ต.ค._พ.ย._ธ.ค.".split("_"), monthsParseExact: true, weekdays: "อาทิตย์_จันทร์_อังคาร_พุธ_พฤหัสบดี_ศุกร์_เสาร์".split("_"), weekdaysShort: "อาทิตย์_จันทร์_อังคาร_พุธ_พฤหัส_ศุกร์_เสาร์".split("_"), weekdaysMin: "อา._จ._อ._พ._พฤ._ศ._ส.".split("_"), weekdaysParseExact: true, longDateFormat: { LT: "H:mm", LTS: "H:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY เวลา H:mm", LLLL: "วันddddที่ D MMMM YYYY เวลา H:mm" }, meridiemParse: /ก่อนเที่ยง|หลังเที่ยง/, isPM: function(e4) {
            return "หลังเที่ยง" === e4;
          }, meridiem: function(e4, a3, n3) {
            return e4 < 12 ? "ก่อนเที่ยง" : "หลังเที่ยง";
          }, calendar: { sameDay: "[วันนี้ เวลา] LT", nextDay: "[พรุ่งนี้ เวลา] LT", nextWeek: "dddd[หน้า เวลา] LT", lastDay: "[เมื่อวานนี้ เวลา] LT", lastWeek: "[วัน]dddd[ที่แล้ว เวลา] LT", sameElse: "L" }, relativeTime: { future: "อีก %s", past: "%sที่แล้ว", s: "ไม่กี่วินาที", ss: "%d วินาที", m: "1 นาที", mm: "%d นาที", h: "1 ชั่วโมง", hh: "%d ชั่วโมง", d: "1 วัน", dd: "%d วัน", w: "1 สัปดาห์", ww: "%d สัปดาห์", M: "1 เดือน", MM: "%d เดือน", y: "1 ปี", yy: "%d ปี" } });
        })(n2(9034));
      }, 2661: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          var a3 = { 1: "'inji", 5: "'inji", 8: "'inji", 70: "'inji", 80: "'inji", 2: "'nji", 7: "'nji", 20: "'nji", 50: "'nji", 3: "'ünji", 4: "'ünji", 100: "'ünji", 6: "'njy", 9: "'unjy", 10: "'unjy", 30: "'unjy", 60: "'ynjy", 90: "'ynjy" };
          e3.defineLocale("tk", { months: "Ýanwar_Fewral_Mart_Aprel_Maý_Iýun_Iýul_Awgust_Sentýabr_Oktýabr_Noýabr_Dekabr".split("_"), monthsShort: "Ýan_Few_Mar_Apr_Maý_Iýn_Iýl_Awg_Sen_Okt_Noý_Dek".split("_"), weekdays: "Ýekşenbe_Duşenbe_Sişenbe_Çarşenbe_Penşenbe_Anna_Şenbe".split("_"), weekdaysShort: "Ýek_Duş_Siş_Çar_Pen_Ann_Şen".split("_"), weekdaysMin: "Ýk_Dş_Sş_Çr_Pn_An_Şn".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD.MM.YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" }, calendar: { sameDay: "[bugün sagat] LT", nextDay: "[ertir sagat] LT", nextWeek: "[indiki] dddd [sagat] LT", lastDay: "[düýn] LT", lastWeek: "[geçen] dddd [sagat] LT", sameElse: "L" }, relativeTime: { future: "%s soň", past: "%s öň", s: "birnäçe sekunt", m: "bir minut", mm: "%d minut", h: "bir sagat", hh: "%d sagat", d: "bir gün", dd: "%d gün", M: "bir aý", MM: "%d aý", y: "bir ýyl", yy: "%d ýyl" }, ordinal: function(e4, n3) {
            switch (n3) {
              case "d":
              case "D":
              case "Do":
              case "DD":
                return e4;
              default:
                if (0 === e4) return e4 + "'unjy";
                var t2 = e4 % 10;
                return e4 + (a3[t2] || a3[e4 % 100 - t2] || a3[e4 >= 100 ? 100 : null]);
            }
          }, week: { dow: 1, doy: 7 } });
        })(n2(9034));
      }, 2234: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          e3.defineLocale("tl-ph", { months: "Enero_Pebrero_Marso_Abril_Mayo_Hunyo_Hulyo_Agosto_Setyembre_Oktubre_Nobyembre_Disyembre".split("_"), monthsShort: "Ene_Peb_Mar_Abr_May_Hun_Hul_Ago_Set_Okt_Nob_Dis".split("_"), weekdays: "Linggo_Lunes_Martes_Miyerkules_Huwebes_Biyernes_Sabado".split("_"), weekdaysShort: "Lin_Lun_Mar_Miy_Huw_Biy_Sab".split("_"), weekdaysMin: "Li_Lu_Ma_Mi_Hu_Bi_Sab".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "MM/D/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY HH:mm", LLLL: "dddd, MMMM DD, YYYY HH:mm" }, calendar: { sameDay: "LT [ngayong araw]", nextDay: "[Bukas ng] LT", nextWeek: "LT [sa susunod na] dddd", lastDay: "LT [kahapon]", lastWeek: "LT [noong nakaraang] dddd", sameElse: "L" }, relativeTime: { future: "sa loob ng %s", past: "%s ang nakalipas", s: "ilang segundo", ss: "%d segundo", m: "isang minuto", mm: "%d minuto", h: "isang oras", hh: "%d oras", d: "isang araw", dd: "%d araw", M: "isang buwan", MM: "%d buwan", y: "isang taon", yy: "%d taon" }, dayOfMonthOrdinalParse: /\d{1,2}/, ordinal: function(e4) {
            return e4;
          }, week: { dow: 1, doy: 4 } });
        })(n2(9034));
      }, 4120: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          var a3 = "pagh_wa’_cha’_wej_loS_vagh_jav_Soch_chorgh_Hut".split("_");
          function n3(e4, n4, t2, c) {
            var s = (function(e5) {
              var n5 = Math.floor(e5 % 1e3 / 100), t3 = Math.floor(e5 % 100 / 10), c2 = e5 % 10, s2 = "";
              return n5 > 0 && (s2 += a3[n5] + "vatlh"), t3 > 0 && (s2 += ("" !== s2 ? " " : "") + a3[t3] + "maH"), c2 > 0 && (s2 += ("" !== s2 ? " " : "") + a3[c2]), "" === s2 ? "pagh" : s2;
            })(e4);
            switch (t2) {
              case "ss":
                return s + " lup";
              case "mm":
                return s + " tup";
              case "hh":
                return s + " rep";
              case "dd":
                return s + " jaj";
              case "MM":
                return s + " jar";
              case "yy":
                return s + " DIS";
            }
          }
          e3.defineLocale("tlh", { months: "tera’ jar wa’_tera’ jar cha’_tera’ jar wej_tera’ jar loS_tera’ jar vagh_tera’ jar jav_tera’ jar Soch_tera’ jar chorgh_tera’ jar Hut_tera’ jar wa’maH_tera’ jar wa’maH wa’_tera’ jar wa’maH cha’".split("_"), monthsShort: "jar wa’_jar cha’_jar wej_jar loS_jar vagh_jar jav_jar Soch_jar chorgh_jar Hut_jar wa’maH_jar wa’maH wa’_jar wa’maH cha’".split("_"), monthsParseExact: true, weekdays: "lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj".split("_"), weekdaysShort: "lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj".split("_"), weekdaysMin: "lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD.MM.YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" }, calendar: { sameDay: "[DaHjaj] LT", nextDay: "[wa’leS] LT", nextWeek: "LLL", lastDay: "[wa’Hu’] LT", lastWeek: "LLL", sameElse: "L" }, relativeTime: { future: function(e4) {
            var a4 = e4;
            return -1 !== e4.indexOf("jaj") ? a4.slice(0, -3) + "leS" : -1 !== e4.indexOf("jar") ? a4.slice(0, -3) + "waQ" : -1 !== e4.indexOf("DIS") ? a4.slice(0, -3) + "nem" : a4 + " pIq";
          }, past: function(e4) {
            var a4 = e4;
            return -1 !== e4.indexOf("jaj") ? a4.slice(0, -3) + "Hu’" : -1 !== e4.indexOf("jar") ? a4.slice(0, -3) + "wen" : -1 !== e4.indexOf("DIS") ? a4.slice(0, -3) + "ben" : a4 + " ret";
          }, s: "puS lup", ss: n3, m: "wa’ tup", mm: n3, h: "wa’ rep", hh: n3, d: "wa’ jaj", dd: n3, M: "wa’ jar", MM: n3, y: "wa’ DIS", yy: n3 }, dayOfMonthOrdinalParse: /\d{1,2}\./, ordinal: "%d.", week: { dow: 1, doy: 4 } });
        })(n2(9034));
      }, 1111: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          var a3 = { 1: "'inci", 5: "'inci", 8: "'inci", 70: "'inci", 80: "'inci", 2: "'nci", 7: "'nci", 20: "'nci", 50: "'nci", 3: "'üncü", 4: "'üncü", 100: "'üncü", 6: "'ncı", 9: "'uncu", 10: "'uncu", 30: "'uncu", 60: "'ıncı", 90: "'ıncı" };
          e3.defineLocale("tr", { months: "Ocak_Şubat_Mart_Nisan_Mayıs_Haziran_Temmuz_Ağustos_Eylül_Ekim_Kasım_Aralık".split("_"), monthsShort: "Oca_Şub_Mar_Nis_May_Haz_Tem_Ağu_Eyl_Eki_Kas_Ara".split("_"), weekdays: "Pazar_Pazartesi_Salı_Çarşamba_Perşembe_Cuma_Cumartesi".split("_"), weekdaysShort: "Paz_Pzt_Sal_Çar_Per_Cum_Cmt".split("_"), weekdaysMin: "Pz_Pt_Sa_Ça_Pe_Cu_Ct".split("_"), meridiem: function(e4, a4, n3) {
            return e4 < 12 ? n3 ? "öö" : "ÖÖ" : n3 ? "ös" : "ÖS";
          }, meridiemParse: /öö|ÖÖ|ös|ÖS/, isPM: function(e4) {
            return "ös" === e4 || "ÖS" === e4;
          }, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD.MM.YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" }, calendar: { sameDay: "[bugün saat] LT", nextDay: "[yarın saat] LT", nextWeek: "[gelecek] dddd [saat] LT", lastDay: "[dün] LT", lastWeek: "[geçen] dddd [saat] LT", sameElse: "L" }, relativeTime: { future: "%s sonra", past: "%s önce", s: "birkaç saniye", ss: "%d saniye", m: "bir dakika", mm: "%d dakika", h: "bir saat", hh: "%d saat", d: "bir gün", dd: "%d gün", w: "bir hafta", ww: "%d hafta", M: "bir ay", MM: "%d ay", y: "bir yıl", yy: "%d yıl" }, ordinal: function(e4, n3) {
            switch (n3) {
              case "d":
              case "D":
              case "Do":
              case "DD":
                return e4;
              default:
                if (0 === e4) return e4 + "'ıncı";
                var t2 = e4 % 10;
                return e4 + (a3[t2] || a3[e4 % 100 - t2] || a3[e4 >= 100 ? 100 : null]);
            }
          }, week: { dow: 1, doy: 7 } });
        })(n2(9034));
      }, 3080: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          function a3(e4, a4, n3, t2) {
            var c = { s: ["viensas secunds", "'iensas secunds"], ss: [e4 + " secunds", e4 + " secunds"], m: ["'n míut", "'iens míut"], mm: [e4 + " míuts", e4 + " míuts"], h: ["'n þora", "'iensa þora"], hh: [e4 + " þoras", e4 + " þoras"], d: ["'n ziua", "'iensa ziua"], dd: [e4 + " ziuas", e4 + " ziuas"], M: ["'n mes", "'iens mes"], MM: [e4 + " mesen", e4 + " mesen"], y: ["'n ar", "'iens ar"], yy: [e4 + " ars", e4 + " ars"] };
            return t2 || a4 ? c[n3][0] : c[n3][1];
          }
          e3.defineLocale("tzl", { months: "Januar_Fevraglh_Març_Avrïu_Mai_Gün_Julia_Guscht_Setemvar_Listopäts_Noemvar_Zecemvar".split("_"), monthsShort: "Jan_Fev_Mar_Avr_Mai_Gün_Jul_Gus_Set_Lis_Noe_Zec".split("_"), weekdays: "Súladi_Lúneçi_Maitzi_Márcuri_Xhúadi_Viénerçi_Sáturi".split("_"), weekdaysShort: "Súl_Lún_Mai_Már_Xhú_Vié_Sát".split("_"), weekdaysMin: "Sú_Lú_Ma_Má_Xh_Vi_Sá".split("_"), longDateFormat: { LT: "HH.mm", LTS: "HH.mm.ss", L: "DD.MM.YYYY", LL: "D. MMMM [dallas] YYYY", LLL: "D. MMMM [dallas] YYYY HH.mm", LLLL: "dddd, [li] D. MMMM [dallas] YYYY HH.mm" }, meridiemParse: /d\'o|d\'a/i, isPM: function(e4) {
            return "d'o" === e4.toLowerCase();
          }, meridiem: function(e4, a4, n3) {
            return e4 > 11 ? n3 ? "d'o" : "D'O" : n3 ? "d'a" : "D'A";
          }, calendar: { sameDay: "[oxhi à] LT", nextDay: "[demà à] LT", nextWeek: "dddd [à] LT", lastDay: "[ieiri à] LT", lastWeek: "[sür el] dddd [lasteu à] LT", sameElse: "L" }, relativeTime: { future: "osprei %s", past: "ja%s", s: a3, ss: a3, m: a3, mm: a3, h: a3, hh: a3, d: a3, dd: a3, M: a3, MM: a3, y: a3, yy: a3 }, dayOfMonthOrdinalParse: /\d{1,2}\./, ordinal: "%d.", week: { dow: 1, doy: 4 } });
        })(n2(9034));
      }, 5385: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          e3.defineLocale("tzm-latn", { months: "innayr_brˤayrˤ_marˤsˤ_ibrir_mayyw_ywnyw_ywlywz_ɣwšt_šwtanbir_ktˤwbrˤ_nwwanbir_dwjnbir".split("_"), monthsShort: "innayr_brˤayrˤ_marˤsˤ_ibrir_mayyw_ywnyw_ywlywz_ɣwšt_šwtanbir_ktˤwbrˤ_nwwanbir_dwjnbir".split("_"), weekdays: "asamas_aynas_asinas_akras_akwas_asimwas_asiḍyas".split("_"), weekdaysShort: "asamas_aynas_asinas_akras_akwas_asimwas_asiḍyas".split("_"), weekdaysMin: "asamas_aynas_asinas_akras_akwas_asimwas_asiḍyas".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D MMMM YYYY HH:mm" }, calendar: { sameDay: "[asdkh g] LT", nextDay: "[aska g] LT", nextWeek: "dddd [g] LT", lastDay: "[assant g] LT", lastWeek: "dddd [g] LT", sameElse: "L" }, relativeTime: { future: "dadkh s yan %s", past: "yan %s", s: "imik", ss: "%d imik", m: "minuḍ", mm: "%d minuḍ", h: "saɛa", hh: "%d tassaɛin", d: "ass", dd: "%d ossan", M: "ayowr", MM: "%d iyyirn", y: "asgas", yy: "%d isgasn" }, week: { dow: 6, doy: 12 } });
        })(n2(9034));
      }, 8246: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          e3.defineLocale("tzm", { months: "ⵉⵏⵏⴰⵢⵔ_ⴱⵕⴰⵢⵕ_ⵎⴰⵕⵚ_ⵉⴱⵔⵉⵔ_ⵎⴰⵢⵢⵓ_ⵢⵓⵏⵢⵓ_ⵢⵓⵍⵢⵓⵣ_ⵖⵓⵛⵜ_ⵛⵓⵜⴰⵏⴱⵉⵔ_ⴽⵟⵓⴱⵕ_ⵏⵓⵡⴰⵏⴱⵉⵔ_ⴷⵓⵊⵏⴱⵉⵔ".split("_"), monthsShort: "ⵉⵏⵏⴰⵢⵔ_ⴱⵕⴰⵢⵕ_ⵎⴰⵕⵚ_ⵉⴱⵔⵉⵔ_ⵎⴰⵢⵢⵓ_ⵢⵓⵏⵢⵓ_ⵢⵓⵍⵢⵓⵣ_ⵖⵓⵛⵜ_ⵛⵓⵜⴰⵏⴱⵉⵔ_ⴽⵟⵓⴱⵕ_ⵏⵓⵡⴰⵏⴱⵉⵔ_ⴷⵓⵊⵏⴱⵉⵔ".split("_"), weekdays: "ⴰⵙⴰⵎⴰⵙ_ⴰⵢⵏⴰⵙ_ⴰⵙⵉⵏⴰⵙ_ⴰⴽⵔⴰⵙ_ⴰⴽⵡⴰⵙ_ⴰⵙⵉⵎⵡⴰⵙ_ⴰⵙⵉⴹⵢⴰⵙ".split("_"), weekdaysShort: "ⴰⵙⴰⵎⴰⵙ_ⴰⵢⵏⴰⵙ_ⴰⵙⵉⵏⴰⵙ_ⴰⴽⵔⴰⵙ_ⴰⴽⵡⴰⵙ_ⴰⵙⵉⵎⵡⴰⵙ_ⴰⵙⵉⴹⵢⴰⵙ".split("_"), weekdaysMin: "ⴰⵙⴰⵎⴰⵙ_ⴰⵢⵏⴰⵙ_ⴰⵙⵉⵏⴰⵙ_ⴰⴽⵔⴰⵙ_ⴰⴽⵡⴰⵙ_ⴰⵙⵉⵎⵡⴰⵙ_ⴰⵙⵉⴹⵢⴰⵙ".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D MMMM YYYY HH:mm" }, calendar: { sameDay: "[ⴰⵙⴷⵅ ⴴ] LT", nextDay: "[ⴰⵙⴽⴰ ⴴ] LT", nextWeek: "dddd [ⴴ] LT", lastDay: "[ⴰⵚⴰⵏⵜ ⴴ] LT", lastWeek: "dddd [ⴴ] LT", sameElse: "L" }, relativeTime: { future: "ⴷⴰⴷⵅ ⵙ ⵢⴰⵏ %s", past: "ⵢⴰⵏ %s", s: "ⵉⵎⵉⴽ", ss: "%d ⵉⵎⵉⴽ", m: "ⵎⵉⵏⵓⴺ", mm: "%d ⵎⵉⵏⵓⴺ", h: "ⵙⴰⵄⴰ", hh: "%d ⵜⴰⵙⵙⴰⵄⵉⵏ", d: "ⴰⵙⵙ", dd: "%d oⵙⵙⴰⵏ", M: "ⴰⵢoⵓⵔ", MM: "%d ⵉⵢⵢⵉⵔⵏ", y: "ⴰⵙⴳⴰⵙ", yy: "%d ⵉⵙⴳⴰⵙⵏ" }, week: { dow: 6, doy: 12 } });
        })(n2(9034));
      }, 8777: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          e3.defineLocale("ug-cn", { months: "يانۋار_فېۋرال_مارت_ئاپرېل_ماي_ئىيۇن_ئىيۇل_ئاۋغۇست_سېنتەبىر_ئۆكتەبىر_نويابىر_دېكابىر".split("_"), monthsShort: "يانۋار_فېۋرال_مارت_ئاپرېل_ماي_ئىيۇن_ئىيۇل_ئاۋغۇست_سېنتەبىر_ئۆكتەبىر_نويابىر_دېكابىر".split("_"), weekdays: "يەكشەنبە_دۈشەنبە_سەيشەنبە_چارشەنبە_پەيشەنبە_جۈمە_شەنبە".split("_"), weekdaysShort: "يە_دۈ_سە_چا_پە_جۈ_شە".split("_"), weekdaysMin: "يە_دۈ_سە_چا_پە_جۈ_شە".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "YYYY-MM-DD", LL: "YYYY-يىلىM-ئاينىڭD-كۈنى", LLL: "YYYY-يىلىM-ئاينىڭD-كۈنى، HH:mm", LLLL: "dddd، YYYY-يىلىM-ئاينىڭD-كۈنى، HH:mm" }, meridiemParse: /يېرىم كېچە|سەھەر|چۈشتىن بۇرۇن|چۈش|چۈشتىن كېيىن|كەچ/, meridiemHour: function(e4, a3) {
            return 12 === e4 && (e4 = 0), "يېرىم كېچە" === a3 || "سەھەر" === a3 || "چۈشتىن بۇرۇن" === a3 ? e4 : "چۈشتىن كېيىن" === a3 || "كەچ" === a3 ? e4 + 12 : e4 >= 11 ? e4 : e4 + 12;
          }, meridiem: function(e4, a3, n3) {
            var t2 = 100 * e4 + a3;
            return t2 < 600 ? "يېرىم كېچە" : t2 < 900 ? "سەھەر" : t2 < 1130 ? "چۈشتىن بۇرۇن" : t2 < 1230 ? "چۈش" : t2 < 1800 ? "چۈشتىن كېيىن" : "كەچ";
          }, calendar: { sameDay: "[بۈگۈن سائەت] LT", nextDay: "[ئەتە سائەت] LT", nextWeek: "[كېلەركى] dddd [سائەت] LT", lastDay: "[تۆنۈگۈن] LT", lastWeek: "[ئالدىنقى] dddd [سائەت] LT", sameElse: "L" }, relativeTime: { future: "%s كېيىن", past: "%s بۇرۇن", s: "نەچچە سېكونت", ss: "%d سېكونت", m: "بىر مىنۇت", mm: "%d مىنۇت", h: "بىر سائەت", hh: "%d سائەت", d: "بىر كۈن", dd: "%d كۈن", M: "بىر ئاي", MM: "%d ئاي", y: "بىر يىل", yy: "%d يىل" }, dayOfMonthOrdinalParse: /\d{1,2}(-كۈنى|-ئاي|-ھەپتە)/, ordinal: function(e4, a3) {
            switch (a3) {
              case "d":
              case "D":
              case "DDD":
                return e4 + "-كۈنى";
              case "w":
              case "W":
                return e4 + "-ھەپتە";
              default:
                return e4;
            }
          }, preparse: function(e4) {
            return e4.replace(/،/g, ",");
          }, postformat: function(e4) {
            return e4.replace(/,/g, "،");
          }, week: { dow: 1, doy: 7 } });
        })(n2(9034));
      }, 2014: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          function a3(e4, a4, n4) {
            return "m" === n4 ? a4 ? "хвилина" : "хвилину" : "h" === n4 ? a4 ? "година" : "годину" : e4 + " " + (t2 = +e4, c = { ss: a4 ? "секунда_секунди_секунд" : "секунду_секунди_секунд", mm: a4 ? "хвилина_хвилини_хвилин" : "хвилину_хвилини_хвилин", hh: a4 ? "година_години_годин" : "годину_години_годин", dd: "день_дні_днів", MM: "місяць_місяці_місяців", yy: "рік_роки_років" }[n4].split("_"), t2 % 10 == 1 && t2 % 100 != 11 ? c[0] : t2 % 10 >= 2 && t2 % 10 <= 4 && (t2 % 100 < 10 || t2 % 100 >= 20) ? c[1] : c[2]);
            var t2, c;
          }
          function n3(e4) {
            return function() {
              return e4 + "о" + (11 === this.hours() ? "б" : "") + "] LT";
            };
          }
          e3.defineLocale("uk", { months: { format: "січня_лютого_березня_квітня_травня_червня_липня_серпня_вересня_жовтня_листопада_грудня".split("_"), standalone: "січень_лютий_березень_квітень_травень_червень_липень_серпень_вересень_жовтень_листопад_грудень".split("_") }, monthsShort: "січ_лют_бер_квіт_трав_черв_лип_серп_вер_жовт_лист_груд".split("_"), weekdays: function(e4, a4) {
            var n4 = { nominative: "неділя_понеділок_вівторок_середа_четвер_п’ятниця_субота".split("_"), accusative: "неділю_понеділок_вівторок_середу_четвер_п’ятницю_суботу".split("_"), genitive: "неділі_понеділка_вівторка_середи_четверга_п’ятниці_суботи".split("_") };
            return true === e4 ? n4.nominative.slice(1, 7).concat(n4.nominative.slice(0, 1)) : e4 ? n4[/(\[[ВвУу]\]) ?dddd/.test(a4) ? "accusative" : /\[?(?:минулої|наступної)? ?\] ?dddd/.test(a4) ? "genitive" : "nominative"][e4.day()] : n4.nominative;
          }, weekdaysShort: "нд_пн_вт_ср_чт_пт_сб".split("_"), weekdaysMin: "нд_пн_вт_ср_чт_пт_сб".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD.MM.YYYY", LL: "D MMMM YYYY р.", LLL: "D MMMM YYYY р., HH:mm", LLLL: "dddd, D MMMM YYYY р., HH:mm" }, calendar: { sameDay: n3("[Сьогодні "), nextDay: n3("[Завтра "), lastDay: n3("[Вчора "), nextWeek: n3("[У] dddd ["), lastWeek: function() {
            switch (this.day()) {
              case 0:
              case 3:
              case 5:
              case 6:
                return n3("[Минулої] dddd [").call(this);
              case 1:
              case 2:
              case 4:
                return n3("[Минулого] dddd [").call(this);
            }
          }, sameElse: "L" }, relativeTime: { future: "за %s", past: "%s тому", s: "декілька секунд", ss: a3, m: a3, mm: a3, h: "годину", hh: a3, d: "день", dd: a3, M: "місяць", MM: a3, y: "рік", yy: a3 }, meridiemParse: /ночі|ранку|дня|вечора/, isPM: function(e4) {
            return /^(дня|вечора)$/.test(e4);
          }, meridiem: function(e4, a4, n4) {
            return e4 < 4 ? "ночі" : e4 < 12 ? "ранку" : e4 < 17 ? "дня" : "вечора";
          }, dayOfMonthOrdinalParse: /\d{1,2}-(й|го)/, ordinal: function(e4, a4) {
            switch (a4) {
              case "M":
              case "d":
              case "DDD":
              case "w":
              case "W":
                return e4 + "-й";
              case "D":
                return e4 + "-го";
              default:
                return e4;
            }
          }, week: { dow: 1, doy: 7 } });
        })(n2(9034));
      }, 5953: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          var a3 = ["جنوری", "فروری", "مارچ", "اپریل", "مئی", "جون", "جولائی", "اگست", "ستمبر", "اکتوبر", "نومبر", "دسمبر"], n3 = ["اتوار", "پیر", "منگل", "بدھ", "جمعرات", "جمعہ", "ہفتہ"];
          e3.defineLocale("ur", { months: a3, monthsShort: a3, weekdays: n3, weekdaysShort: n3, weekdaysMin: n3, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd، D MMMM YYYY HH:mm" }, meridiemParse: /صبح|شام/, isPM: function(e4) {
            return "شام" === e4;
          }, meridiem: function(e4, a4, n4) {
            return e4 < 12 ? "صبح" : "شام";
          }, calendar: { sameDay: "[آج بوقت] LT", nextDay: "[کل بوقت] LT", nextWeek: "dddd [بوقت] LT", lastDay: "[گذشتہ روز بوقت] LT", lastWeek: "[گذشتہ] dddd [بوقت] LT", sameElse: "L" }, relativeTime: { future: "%s بعد", past: "%s قبل", s: "چند سیکنڈ", ss: "%d سیکنڈ", m: "ایک منٹ", mm: "%d منٹ", h: "ایک گھنٹہ", hh: "%d گھنٹے", d: "ایک دن", dd: "%d دن", M: "ایک ماہ", MM: "%d ماہ", y: "ایک سال", yy: "%d سال" }, preparse: function(e4) {
            return e4.replace(/،/g, ",");
          }, postformat: function(e4) {
            return e4.replace(/,/g, "،");
          }, week: { dow: 1, doy: 4 } });
        })(n2(9034));
      }, 7791: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          e3.defineLocale("uz-latn", { months: "Yanvar_Fevral_Mart_Aprel_May_Iyun_Iyul_Avgust_Sentabr_Oktabr_Noyabr_Dekabr".split("_"), monthsShort: "Yan_Fev_Mar_Apr_May_Iyun_Iyul_Avg_Sen_Okt_Noy_Dek".split("_"), weekdays: "Yakshanba_Dushanba_Seshanba_Chorshanba_Payshanba_Juma_Shanba".split("_"), weekdaysShort: "Yak_Dush_Sesh_Chor_Pay_Jum_Shan".split("_"), weekdaysMin: "Ya_Du_Se_Cho_Pa_Ju_Sha".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "D MMMM YYYY, dddd HH:mm" }, calendar: { sameDay: "[Bugun soat] LT [da]", nextDay: "[Ertaga] LT [da]", nextWeek: "dddd [kuni soat] LT [da]", lastDay: "[Kecha soat] LT [da]", lastWeek: "[O'tgan] dddd [kuni soat] LT [da]", sameElse: "L" }, relativeTime: { future: "Yaqin %s ichida", past: "Bir necha %s oldin", s: "soniya", ss: "%d soniya", m: "bir daqiqa", mm: "%d daqiqa", h: "bir soat", hh: "%d soat", d: "bir kun", dd: "%d kun", M: "bir oy", MM: "%d oy", y: "bir yil", yy: "%d yil" }, week: { dow: 1, doy: 7 } });
        })(n2(9034));
      }, 9716: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          e3.defineLocale("uz", { months: "январ_феврал_март_апрел_май_июн_июл_август_сентябр_октябр_ноябр_декабр".split("_"), monthsShort: "янв_фев_мар_апр_май_июн_июл_авг_сен_окт_ноя_дек".split("_"), weekdays: "Якшанба_Душанба_Сешанба_Чоршанба_Пайшанба_Жума_Шанба".split("_"), weekdaysShort: "Якш_Душ_Сеш_Чор_Пай_Жум_Шан".split("_"), weekdaysMin: "Як_Ду_Се_Чо_Па_Жу_Ша".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "D MMMM YYYY, dddd HH:mm" }, calendar: { sameDay: "[Бугун соат] LT [да]", nextDay: "[Эртага] LT [да]", nextWeek: "dddd [куни соат] LT [да]", lastDay: "[Кеча соат] LT [да]", lastWeek: "[Утган] dddd [куни соат] LT [да]", sameElse: "L" }, relativeTime: { future: "Якин %s ичида", past: "Бир неча %s олдин", s: "фурсат", ss: "%d фурсат", m: "бир дакика", mm: "%d дакика", h: "бир соат", hh: "%d соат", d: "бир кун", dd: "%d кун", M: "бир ой", MM: "%d ой", y: "бир йил", yy: "%d йил" }, week: { dow: 1, doy: 7 } });
        })(n2(9034));
      }, 9816: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          e3.defineLocale("vi", { months: "tháng 1_tháng 2_tháng 3_tháng 4_tháng 5_tháng 6_tháng 7_tháng 8_tháng 9_tháng 10_tháng 11_tháng 12".split("_"), monthsShort: "Thg 01_Thg 02_Thg 03_Thg 04_Thg 05_Thg 06_Thg 07_Thg 08_Thg 09_Thg 10_Thg 11_Thg 12".split("_"), monthsParseExact: true, weekdays: "chủ nhật_thứ hai_thứ ba_thứ tư_thứ năm_thứ sáu_thứ bảy".split("_"), weekdaysShort: "CN_T2_T3_T4_T5_T6_T7".split("_"), weekdaysMin: "CN_T2_T3_T4_T5_T6_T7".split("_"), weekdaysParseExact: true, meridiemParse: /sa|ch/i, isPM: function(e4) {
            return /^ch$/i.test(e4);
          }, meridiem: function(e4, a3, n3) {
            return e4 < 12 ? n3 ? "sa" : "SA" : n3 ? "ch" : "CH";
          }, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM [năm] YYYY", LLL: "D MMMM [năm] YYYY HH:mm", LLLL: "dddd, D MMMM [năm] YYYY HH:mm", l: "DD/M/YYYY", ll: "D MMM YYYY", lll: "D MMM YYYY HH:mm", llll: "ddd, D MMM YYYY HH:mm" }, calendar: { sameDay: "[Hôm nay lúc] LT", nextDay: "[Ngày mai lúc] LT", nextWeek: "dddd [tuần tới lúc] LT", lastDay: "[Hôm qua lúc] LT", lastWeek: "dddd [tuần trước lúc] LT", sameElse: "L" }, relativeTime: { future: "%s tới", past: "%s trước", s: "vài giây", ss: "%d giây", m: "một phút", mm: "%d phút", h: "một giờ", hh: "%d giờ", d: "một ngày", dd: "%d ngày", w: "một tuần", ww: "%d tuần", M: "một tháng", MM: "%d tháng", y: "một năm", yy: "%d năm" }, dayOfMonthOrdinalParse: /\d{1,2}/, ordinal: function(e4) {
            return e4;
          }, week: { dow: 1, doy: 4 } });
        })(n2(9034));
      }, 4450: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          e3.defineLocale("x-pseudo", { months: "J~áñúá~rý_F~ébrú~árý_~Márc~h_Áp~ríl_~Máý_~Júñé~_Júl~ý_Áú~gúst~_Sép~témb~ér_Ó~ctób~ér_Ñ~óvém~bér_~Décé~mbér".split("_"), monthsShort: "J~áñ_~Féb_~Már_~Ápr_~Máý_~Júñ_~Júl_~Áúg_~Sép_~Óct_~Ñóv_~Déc".split("_"), monthsParseExact: true, weekdays: "S~úñdá~ý_Mó~ñdáý~_Túé~sdáý~_Wéd~ñésd~áý_T~húrs~dáý_~Fríd~áý_S~átúr~dáý".split("_"), weekdaysShort: "S~úñ_~Móñ_~Túé_~Wéd_~Thú_~Frí_~Sát".split("_"), weekdaysMin: "S~ú_Mó~_Tú_~Wé_T~h_Fr~_Sá".split("_"), weekdaysParseExact: true, longDateFormat: { LT: "HH:mm", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" }, calendar: { sameDay: "[T~ódá~ý át] LT", nextDay: "[T~ómó~rró~w át] LT", nextWeek: "dddd [át] LT", lastDay: "[Ý~ést~érdá~ý át] LT", lastWeek: "[L~ást] dddd [át] LT", sameElse: "L" }, relativeTime: { future: "í~ñ %s", past: "%s á~gó", s: "á ~féw ~sécó~ñds", ss: "%d s~écóñ~ds", m: "á ~míñ~úté", mm: "%d m~íñú~tés", h: "á~ñ hó~úr", hh: "%d h~óúrs", d: "á ~dáý", dd: "%d d~áýs", M: "á ~móñ~th", MM: "%d m~óñt~hs", y: "á ~ýéár", yy: "%d ý~éárs" }, dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/, ordinal: function(e4) {
            var a3 = e4 % 10;
            return e4 + (1 == ~~(e4 % 100 / 10) ? "th" : 1 === a3 ? "st" : 2 === a3 ? "nd" : 3 === a3 ? "rd" : "th");
          }, week: { dow: 1, doy: 4 } });
        })(n2(9034));
      }, 2556: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          e3.defineLocale("yo", { months: "Sẹ́rẹ́_Èrèlè_Ẹrẹ̀nà_Ìgbé_Èbibi_Òkùdu_Agẹmo_Ògún_Owewe_Ọ̀wàrà_Bélú_Ọ̀pẹ̀̀".split("_"), monthsShort: "Sẹ́r_Èrl_Ẹrn_Ìgb_Èbi_Òkù_Agẹ_Ògú_Owe_Ọ̀wà_Bél_Ọ̀pẹ̀̀".split("_"), weekdays: "Àìkú_Ajé_Ìsẹ́gun_Ọjọ́rú_Ọjọ́bọ_Ẹtì_Àbámẹ́ta".split("_"), weekdaysShort: "Àìk_Ajé_Ìsẹ́_Ọjr_Ọjb_Ẹtì_Àbá".split("_"), weekdaysMin: "Àì_Aj_Ìs_Ọr_Ọb_Ẹt_Àb".split("_"), longDateFormat: { LT: "h:mm A", LTS: "h:mm:ss A", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY h:mm A", LLLL: "dddd, D MMMM YYYY h:mm A" }, calendar: { sameDay: "[Ònì ni] LT", nextDay: "[Ọ̀la ni] LT", nextWeek: "dddd [Ọsẹ̀ tón'bọ] [ni] LT", lastDay: "[Àna ni] LT", lastWeek: "dddd [Ọsẹ̀ tólọ́] [ni] LT", sameElse: "L" }, relativeTime: { future: "ní %s", past: "%s kọjá", s: "ìsẹjú aayá die", ss: "aayá %d", m: "ìsẹjú kan", mm: "ìsẹjú %d", h: "wákati kan", hh: "wákati %d", d: "ọjọ́ kan", dd: "ọjọ́ %d", M: "osù kan", MM: "osù %d", y: "ọdún kan", yy: "ọdún %d" }, dayOfMonthOrdinalParse: /ọjọ́\s\d{1,2}/, ordinal: "ọjọ́ %d", week: { dow: 1, doy: 4 } });
        })(n2(9034));
      }, 7414: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          e3.defineLocale("zh-cn", { months: "一月_二月_三月_四月_五月_六月_七月_八月_九月_十月_十一月_十二月".split("_"), monthsShort: "1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月".split("_"), weekdays: "星期日_星期一_星期二_星期三_星期四_星期五_星期六".split("_"), weekdaysShort: "周日_周一_周二_周三_周四_周五_周六".split("_"), weekdaysMin: "日_一_二_三_四_五_六".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "YYYY/MM/DD", LL: "YYYY年M月D日", LLL: "YYYY年M月D日Ah点mm分", LLLL: "YYYY年M月D日ddddAh点mm分", l: "YYYY/M/D", ll: "YYYY年M月D日", lll: "YYYY年M月D日 HH:mm", llll: "YYYY年M月D日dddd HH:mm" }, meridiemParse: /凌晨|早上|上午|中午|下午|晚上/, meridiemHour: function(e4, a3) {
            return 12 === e4 && (e4 = 0), "凌晨" === a3 || "早上" === a3 || "上午" === a3 ? e4 : "下午" === a3 || "晚上" === a3 ? e4 + 12 : e4 >= 11 ? e4 : e4 + 12;
          }, meridiem: function(e4, a3, n3) {
            var t2 = 100 * e4 + a3;
            return t2 < 600 ? "凌晨" : t2 < 900 ? "早上" : t2 < 1130 ? "上午" : t2 < 1230 ? "中午" : t2 < 1800 ? "下午" : "晚上";
          }, calendar: { sameDay: "[今天]LT", nextDay: "[明天]LT", nextWeek: function(e4) {
            return e4.week() !== this.week() ? "[下]dddLT" : "[本]dddLT";
          }, lastDay: "[昨天]LT", lastWeek: function(e4) {
            return this.week() !== e4.week() ? "[上]dddLT" : "[本]dddLT";
          }, sameElse: "L" }, dayOfMonthOrdinalParse: /\d{1,2}(日|月|周)/, ordinal: function(e4, a3) {
            switch (a3) {
              case "d":
              case "D":
              case "DDD":
                return e4 + "日";
              case "M":
                return e4 + "月";
              case "w":
              case "W":
                return e4 + "周";
              default:
                return e4;
            }
          }, relativeTime: { future: "%s后", past: "%s前", s: "几秒", ss: "%d 秒", m: "1 分钟", mm: "%d 分钟", h: "1 小时", hh: "%d 小时", d: "1 天", dd: "%d 天", w: "1 周", ww: "%d 周", M: "1 个月", MM: "%d 个月", y: "1 年", yy: "%d 年" }, week: { dow: 1, doy: 4 } });
        })(n2(9034));
      }, 824: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          e3.defineLocale("zh-hk", { months: "一月_二月_三月_四月_五月_六月_七月_八月_九月_十月_十一月_十二月".split("_"), monthsShort: "1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月".split("_"), weekdays: "星期日_星期一_星期二_星期三_星期四_星期五_星期六".split("_"), weekdaysShort: "週日_週一_週二_週三_週四_週五_週六".split("_"), weekdaysMin: "日_一_二_三_四_五_六".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "YYYY/MM/DD", LL: "YYYY年M月D日", LLL: "YYYY年M月D日 HH:mm", LLLL: "YYYY年M月D日dddd HH:mm", l: "YYYY/M/D", ll: "YYYY年M月D日", lll: "YYYY年M月D日 HH:mm", llll: "YYYY年M月D日dddd HH:mm" }, meridiemParse: /凌晨|早上|上午|中午|下午|晚上/, meridiemHour: function(e4, a3) {
            return 12 === e4 && (e4 = 0), "凌晨" === a3 || "早上" === a3 || "上午" === a3 ? e4 : "中午" === a3 ? e4 >= 11 ? e4 : e4 + 12 : "下午" === a3 || "晚上" === a3 ? e4 + 12 : void 0;
          }, meridiem: function(e4, a3, n3) {
            var t2 = 100 * e4 + a3;
            return t2 < 600 ? "凌晨" : t2 < 900 ? "早上" : t2 < 1200 ? "上午" : 1200 === t2 ? "中午" : t2 < 1800 ? "下午" : "晚上";
          }, calendar: { sameDay: "[今天]LT", nextDay: "[明天]LT", nextWeek: "[下]ddddLT", lastDay: "[昨天]LT", lastWeek: "[上]ddddLT", sameElse: "L" }, dayOfMonthOrdinalParse: /\d{1,2}(日|月|週)/, ordinal: function(e4, a3) {
            switch (a3) {
              case "d":
              case "D":
              case "DDD":
                return e4 + "日";
              case "M":
                return e4 + "月";
              case "w":
              case "W":
                return e4 + "週";
              default:
                return e4;
            }
          }, relativeTime: { future: "%s後", past: "%s前", s: "幾秒", ss: "%d 秒", m: "1 分鐘", mm: "%d 分鐘", h: "1 小時", hh: "%d 小時", d: "1 天", dd: "%d 天", M: "1 個月", MM: "%d 個月", y: "1 年", yy: "%d 年" } });
        })(n2(9034));
      }, 8589: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          e3.defineLocale("zh-mo", { months: "一月_二月_三月_四月_五月_六月_七月_八月_九月_十月_十一月_十二月".split("_"), monthsShort: "1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月".split("_"), weekdays: "星期日_星期一_星期二_星期三_星期四_星期五_星期六".split("_"), weekdaysShort: "週日_週一_週二_週三_週四_週五_週六".split("_"), weekdaysMin: "日_一_二_三_四_五_六".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "YYYY年M月D日", LLL: "YYYY年M月D日 HH:mm", LLLL: "YYYY年M月D日dddd HH:mm", l: "D/M/YYYY", ll: "YYYY年M月D日", lll: "YYYY年M月D日 HH:mm", llll: "YYYY年M月D日dddd HH:mm" }, meridiemParse: /凌晨|早上|上午|中午|下午|晚上/, meridiemHour: function(e4, a3) {
            return 12 === e4 && (e4 = 0), "凌晨" === a3 || "早上" === a3 || "上午" === a3 ? e4 : "中午" === a3 ? e4 >= 11 ? e4 : e4 + 12 : "下午" === a3 || "晚上" === a3 ? e4 + 12 : void 0;
          }, meridiem: function(e4, a3, n3) {
            var t2 = 100 * e4 + a3;
            return t2 < 600 ? "凌晨" : t2 < 900 ? "早上" : t2 < 1130 ? "上午" : t2 < 1230 ? "中午" : t2 < 1800 ? "下午" : "晚上";
          }, calendar: { sameDay: "[今天] LT", nextDay: "[明天] LT", nextWeek: "[下]dddd LT", lastDay: "[昨天] LT", lastWeek: "[上]dddd LT", sameElse: "L" }, dayOfMonthOrdinalParse: /\d{1,2}(日|月|週)/, ordinal: function(e4, a3) {
            switch (a3) {
              case "d":
              case "D":
              case "DDD":
                return e4 + "日";
              case "M":
                return e4 + "月";
              case "w":
              case "W":
                return e4 + "週";
              default:
                return e4;
            }
          }, relativeTime: { future: "%s內", past: "%s前", s: "幾秒", ss: "%d 秒", m: "1 分鐘", mm: "%d 分鐘", h: "1 小時", hh: "%d 小時", d: "1 天", dd: "%d 天", M: "1 個月", MM: "%d 個月", y: "1 年", yy: "%d 年" } });
        })(n2(9034));
      }, 3285: function(e2, a2, n2) {
        !(function(e3) {
          "use strict";
          e3.defineLocale("zh-tw", { months: "一月_二月_三月_四月_五月_六月_七月_八月_九月_十月_十一月_十二月".split("_"), monthsShort: "1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月".split("_"), weekdays: "星期日_星期一_星期二_星期三_星期四_星期五_星期六".split("_"), weekdaysShort: "週日_週一_週二_週三_週四_週五_週六".split("_"), weekdaysMin: "日_一_二_三_四_五_六".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "YYYY/MM/DD", LL: "YYYY年M月D日", LLL: "YYYY年M月D日 HH:mm", LLLL: "YYYY年M月D日dddd HH:mm", l: "YYYY/M/D", ll: "YYYY年M月D日", lll: "YYYY年M月D日 HH:mm", llll: "YYYY年M月D日dddd HH:mm" }, meridiemParse: /凌晨|早上|上午|中午|下午|晚上/, meridiemHour: function(e4, a3) {
            return 12 === e4 && (e4 = 0), "凌晨" === a3 || "早上" === a3 || "上午" === a3 ? e4 : "中午" === a3 ? e4 >= 11 ? e4 : e4 + 12 : "下午" === a3 || "晚上" === a3 ? e4 + 12 : void 0;
          }, meridiem: function(e4, a3, n3) {
            var t2 = 100 * e4 + a3;
            return t2 < 600 ? "凌晨" : t2 < 900 ? "早上" : t2 < 1130 ? "上午" : t2 < 1230 ? "中午" : t2 < 1800 ? "下午" : "晚上";
          }, calendar: { sameDay: "[今天] LT", nextDay: "[明天] LT", nextWeek: "[下]dddd LT", lastDay: "[昨天] LT", lastWeek: "[上]dddd LT", sameElse: "L" }, dayOfMonthOrdinalParse: /\d{1,2}(日|月|週)/, ordinal: function(e4, a3) {
            switch (a3) {
              case "d":
              case "D":
              case "DDD":
                return e4 + "日";
              case "M":
                return e4 + "月";
              case "w":
              case "W":
                return e4 + "週";
              default:
                return e4;
            }
          }, relativeTime: { future: "%s後", past: "%s前", s: "幾秒", ss: "%d 秒", m: "1 分鐘", mm: "%d 分鐘", h: "1 小時", hh: "%d 小時", d: "1 天", dd: "%d 天", M: "1 個月", MM: "%d 個月", y: "1 年", yy: "%d 年" } });
        })(n2(9034));
      }, 6616: (e2, a2, n2) => {
        var t2 = { "./af": 5191, "./af.js": 5191, "./ar": 4358, "./ar-dz": 1727, "./ar-dz.js": 1727, "./ar-kw": 8279, "./ar-kw.js": 8279, "./ar-ly": 7895, "./ar-ly.js": 7895, "./ar-ma": 1987, "./ar-ma.js": 1987, "./ar-sa": 2796, "./ar-sa.js": 2796, "./ar-tn": 2386, "./ar-tn.js": 2386, "./ar.js": 4358, "./az": 7452, "./az.js": 7452, "./be": 9053, "./be.js": 9053, "./bg": 5428, "./bg.js": 5428, "./bm": 1569, "./bm.js": 1569, "./bn": 6212, "./bn-bd": 4635, "./bn-bd.js": 4635, "./bn.js": 6212, "./bo": 3667, "./bo.js": 3667, "./br": 192, "./br.js": 192, "./bs": 1802, "./bs.js": 1802, "./ca": 9118, "./ca.js": 9118, "./cs": 9990, "./cs.js": 9990, "./cv": 557, "./cv.js": 557, "./cy": 4227, "./cy.js": 4227, "./da": 5406, "./da.js": 5406, "./de": 7994, "./de-at": 4139, "./de-at.js": 4139, "./de-ch": 6591, "./de-ch.js": 6591, "./de.js": 7994, "./dv": 4649, "./dv.js": 4649, "./el": 4453, "./el.js": 4453, "./en-au": 8428, "./en-au.js": 8428, "./en-ca": 6972, "./en-ca.js": 6972, "./en-gb": 3224, "./en-gb.js": 3224, "./en-ie": 8843, "./en-ie.js": 8843, "./en-il": 2732, "./en-il.js": 2732, "./en-in": 6579, "./en-in.js": 6579, "./en-nz": 9851, "./en-nz.js": 9851, "./en-sg": 442, "./en-sg.js": 442, "./eo": 654, "./eo.js": 654, "./es": 3621, "./es-do": 8791, "./es-do.js": 8791, "./es-mx": 7278, "./es-mx.js": 7278, "./es-us": 717, "./es-us.js": 717, "./es.js": 3621, "./et": 2404, "./et.js": 2404, "./eu": 2944, "./eu.js": 2944, "./fa": 496, "./fa.js": 496, "./fi": 8137, "./fi.js": 8137, "./fil": 2872, "./fil.js": 2872, "./fo": 6545, "./fo.js": 6545, "./fr": 9090, "./fr-ca": 3049, "./fr-ca.js": 3049, "./fr-ch": 2338, "./fr-ch.js": 2338, "./fr.js": 9090, "./fy": 5088, "./fy.js": 5088, "./ga": 7812, "./ga.js": 7812, "./gd": 8374, "./gd.js": 8374, "./gl": 3649, "./gl.js": 3649, "./gom-deva": 2674, "./gom-deva.js": 2674, "./gom-latn": 4948, "./gom-latn.js": 4948, "./gu": 4033, "./gu.js": 4033, "./he": 175, "./he.js": 175, "./hi": 8055, "./hi.js": 8055, "./hr": 1678, "./hr.js": 1678, "./hu": 5111, "./hu.js": 5111, "./hy-am": 6530, "./hy-am.js": 6530, "./id": 9126, "./id.js": 9126, "./is": 1696, "./is.js": 1696, "./it": 8710, "./it-ch": 8821, "./it-ch.js": 8821, "./it.js": 8710, "./ja": 3974, "./ja.js": 3974, "./jv": 648, "./jv.js": 648, "./ka": 4731, "./ka.js": 4731, "./kk": 3501, "./kk.js": 3501, "./km": 4398, "./km.js": 4398, "./kn": 1825, "./kn.js": 1825, "./ko": 3729, "./ko.js": 3729, "./ku": 9670, "./ku.js": 9670, "./ky": 8797, "./ky.js": 8797, "./lb": 627, "./lb.js": 627, "./lo": 5859, "./lo.js": 5859, "./lt": 355, "./lt.js": 355, "./lv": 6594, "./lv.js": 6594, "./me": 5324, "./me.js": 5324, "./mi": 1689, "./mi.js": 1689, "./mk": 1308, "./mk.js": 1308, "./ml": 5241, "./ml.js": 5241, "./mn": 6320, "./mn.js": 6320, "./mr": 6771, "./mr.js": 6771, "./ms": 503, "./ms-my": 7748, "./ms-my.js": 7748, "./ms.js": 503, "./mt": 5534, "./mt.js": 5534, "./my": 2727, "./my.js": 2727, "./nb": 7550, "./nb.js": 7550, "./ne": 9899, "./ne.js": 9899, "./nl": 1228, "./nl-be": 1225, "./nl-be.js": 1225, "./nl.js": 1228, "./nn": 7130, "./nn.js": 7130, "./oc-lnc": 3130, "./oc-lnc.js": 3130, "./pa-in": 1282, "./pa-in.js": 1282, "./pl": 8190, "./pl.js": 8190, "./pt": 1549, "./pt-br": 8135, "./pt-br.js": 8135, "./pt.js": 1549, "./ro": 307, "./ro.js": 307, "./ru": 9272, "./ru.js": 9272, "./sd": 9248, "./sd.js": 9248, "./se": 4969, "./se.js": 4969, "./si": 5522, "./si.js": 5522, "./sk": 1581, "./sk.js": 1581, "./sl": 6428, "./sl.js": 6428, "./sq": 4611, "./sq.js": 4611, "./sr": 9821, "./sr-cyrl": 185, "./sr-cyrl.js": 185, "./sr.js": 9821, "./ss": 5029, "./ss.js": 5029, "./sv": 939, "./sv.js": 939, "./sw": 3107, "./sw.js": 3107, "./ta": 2304, "./ta.js": 2304, "./te": 2550, "./te.js": 2550, "./tet": 9717, "./tet.js": 9717, "./tg": 7669, "./tg.js": 7669, "./th": 4959, "./th.js": 4959, "./tk": 2661, "./tk.js": 2661, "./tl-ph": 2234, "./tl-ph.js": 2234, "./tlh": 4120, "./tlh.js": 4120, "./tr": 1111, "./tr.js": 1111, "./tzl": 3080, "./tzl.js": 3080, "./tzm": 8246, "./tzm-latn": 5385, "./tzm-latn.js": 5385, "./tzm.js": 8246, "./ug-cn": 8777, "./ug-cn.js": 8777, "./uk": 2014, "./uk.js": 2014, "./ur": 5953, "./ur.js": 5953, "./uz": 9716, "./uz-latn": 7791, "./uz-latn.js": 7791, "./uz.js": 9716, "./vi": 9816, "./vi.js": 9816, "./x-pseudo": 4450, "./x-pseudo.js": 4450, "./yo": 2556, "./yo.js": 2556, "./zh-cn": 7414, "./zh-cn.js": 7414, "./zh-hk": 824, "./zh-hk.js": 824, "./zh-mo": 8589, "./zh-mo.js": 8589, "./zh-tw": 3285, "./zh-tw.js": 3285 };
        function c(e3) {
          var a3 = s(e3);
          return n2(a3);
        }
        function s(e3) {
          if (!n2.o(t2, e3)) {
            var a3 = new Error("Cannot find module '" + e3 + "'");
            throw a3.code = "MODULE_NOT_FOUND", a3;
          }
          return t2[e3];
        }
        c.keys = function() {
          return Object.keys(t2);
        }, c.resolve = s, e2.exports = c, c.id = 6616;
      }, 9034: function(e2, a2, n2) {
        (e2 = n2.nmd(e2)).exports = (function() {
          "use strict";
          var a3, t2;
          function c() {
            return a3.apply(null, arguments);
          }
          function s(e3) {
            return e3 instanceof Array || "[object Array]" === Object.prototype.toString.call(e3);
          }
          function o(e3) {
            return null != e3 && "[object Object]" === Object.prototype.toString.call(e3);
          }
          function i(e3, a4) {
            return Object.prototype.hasOwnProperty.call(e3, a4);
          }
          function r(e3) {
            if (Object.getOwnPropertyNames) return 0 === Object.getOwnPropertyNames(e3).length;
            var a4;
            for (a4 in e3) if (i(e3, a4)) return false;
            return true;
          }
          function M(e3) {
            return void 0 === e3;
          }
          function d(e3) {
            return "number" == typeof e3 || "[object Number]" === Object.prototype.toString.call(e3);
          }
          function _(e3) {
            return e3 instanceof Date || "[object Date]" === Object.prototype.toString.call(e3);
          }
          function u(e3, a4) {
            var n3, t3 = [], c2 = e3.length;
            for (n3 = 0; n3 < c2; ++n3) t3.push(a4(e3[n3], n3));
            return t3;
          }
          function m(e3, a4) {
            for (var n3 in a4) i(a4, n3) && (e3[n3] = a4[n3]);
            return i(a4, "toString") && (e3.toString = a4.toString), i(a4, "valueOf") && (e3.valueOf = a4.valueOf), e3;
          }
          function l(e3, a4, n3, t3) {
            return va(e3, a4, n3, t3, true).utc();
          }
          function p(e3) {
            return null == e3._pf && (e3._pf = { empty: false, unusedTokens: [], unusedInput: [], overflow: -2, charsLeftOver: 0, nullInput: false, invalidEra: null, invalidMonth: null, invalidFormat: false, userInvalidated: false, iso: false, parsedDateParts: [], era: null, meridiem: null, rfc2822: false, weekdayMismatch: false }), e3._pf;
          }
          function L(e3) {
            if (null == e3._isValid) {
              var a4 = p(e3), n3 = t2.call(a4.parsedDateParts, (function(e4) {
                return null != e4;
              })), c2 = !isNaN(e3._d.getTime()) && a4.overflow < 0 && !a4.empty && !a4.invalidEra && !a4.invalidMonth && !a4.invalidWeekday && !a4.weekdayMismatch && !a4.nullInput && !a4.invalidFormat && !a4.userInvalidated && (!a4.meridiem || a4.meridiem && n3);
              if (e3._strict && (c2 = c2 && 0 === a4.charsLeftOver && 0 === a4.unusedTokens.length && void 0 === a4.bigHour), null != Object.isFrozen && Object.isFrozen(e3)) return c2;
              e3._isValid = c2;
            }
            return e3._isValid;
          }
          function b(e3) {
            var a4 = l(NaN);
            return null != e3 ? m(p(a4), e3) : p(a4).userInvalidated = true, a4;
          }
          t2 = Array.prototype.some ? Array.prototype.some : function(e3) {
            var a4, n3 = Object(this), t3 = n3.length >>> 0;
            for (a4 = 0; a4 < t3; a4++) if (a4 in n3 && e3.call(this, n3[a4], a4, n3)) return true;
            return false;
          };
          var A = c.momentProperties = [], f = false;
          function h(e3, a4) {
            var n3, t3, c2, s2 = A.length;
            if (M(a4._isAMomentObject) || (e3._isAMomentObject = a4._isAMomentObject), M(a4._i) || (e3._i = a4._i), M(a4._f) || (e3._f = a4._f), M(a4._l) || (e3._l = a4._l), M(a4._strict) || (e3._strict = a4._strict), M(a4._tzm) || (e3._tzm = a4._tzm), M(a4._isUTC) || (e3._isUTC = a4._isUTC), M(a4._offset) || (e3._offset = a4._offset), M(a4._pf) || (e3._pf = p(a4)), M(a4._locale) || (e3._locale = a4._locale), s2 > 0) for (n3 = 0; n3 < s2; n3++) M(c2 = a4[t3 = A[n3]]) || (e3[t3] = c2);
            return e3;
          }
          function z(e3) {
            h(this, e3), this._d = new Date(null != e3._d ? e3._d.getTime() : NaN), this.isValid() || (this._d = /* @__PURE__ */ new Date(NaN)), false === f && (f = true, c.updateOffset(this), f = false);
          }
          function Y(e3) {
            return e3 instanceof z || null != e3 && null != e3._isAMomentObject;
          }
          function y(e3) {
            false === c.suppressDeprecationWarnings && "undefined" != typeof console && console.warn && console.warn("Deprecation warning: " + e3);
          }
          function T(e3, a4) {
            var n3 = true;
            return m((function() {
              if (null != c.deprecationHandler && c.deprecationHandler(null, e3), n3) {
                var t3, s2, o2, r2 = [], M2 = arguments.length;
                for (s2 = 0; s2 < M2; s2++) {
                  if (t3 = "", "object" == typeof arguments[s2]) {
                    for (o2 in t3 += "\n[" + s2 + "] ", arguments[0]) i(arguments[0], o2) && (t3 += o2 + ": " + arguments[0][o2] + ", ");
                    t3 = t3.slice(0, -2);
                  } else t3 = arguments[s2];
                  r2.push(t3);
                }
                y(e3 + "\nArguments: " + Array.prototype.slice.call(r2).join("") + "\n" + new Error().stack), n3 = false;
              }
              return a4.apply(this, arguments);
            }), a4);
          }
          var O, D = {};
          function k(e3, a4) {
            null != c.deprecationHandler && c.deprecationHandler(e3, a4), D[e3] || (y(a4), D[e3] = true);
          }
          function W(e3) {
            return "undefined" != typeof Function && e3 instanceof Function || "[object Function]" === Object.prototype.toString.call(e3);
          }
          function g(e3, a4) {
            var n3, t3 = m({}, e3);
            for (n3 in a4) i(a4, n3) && (o(e3[n3]) && o(a4[n3]) ? (t3[n3] = {}, m(t3[n3], e3[n3]), m(t3[n3], a4[n3])) : null != a4[n3] ? t3[n3] = a4[n3] : delete t3[n3]);
            for (n3 in e3) i(e3, n3) && !i(a4, n3) && o(e3[n3]) && (t3[n3] = m({}, t3[n3]));
            return t3;
          }
          function N(e3) {
            null != e3 && this.set(e3);
          }
          c.suppressDeprecationWarnings = false, c.deprecationHandler = null, O = Object.keys ? Object.keys : function(e3) {
            var a4, n3 = [];
            for (a4 in e3) i(e3, a4) && n3.push(a4);
            return n3;
          };
          function q(e3, a4, n3) {
            var t3 = "" + Math.abs(e3), c2 = a4 - t3.length;
            return (e3 >= 0 ? n3 ? "+" : "" : "-") + Math.pow(10, Math.max(0, c2)).toString().substr(1) + t3;
          }
          var S = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g, w = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, v = {}, X = {};
          function B(e3, a4, n3, t3) {
            var c2 = t3;
            "string" == typeof t3 && (c2 = function() {
              return this[t3]();
            }), e3 && (X[e3] = c2), a4 && (X[a4[0]] = function() {
              return q(c2.apply(this, arguments), a4[1], a4[2]);
            }), n3 && (X[n3] = function() {
              return this.localeData().ordinal(c2.apply(this, arguments), e3);
            });
          }
          function H(e3, a4) {
            return e3.isValid() ? (a4 = j(a4, e3.localeData()), v[a4] = v[a4] || (function(e4) {
              var a5, n3, t3, c2 = e4.match(S);
              for (a5 = 0, n3 = c2.length; a5 < n3; a5++) X[c2[a5]] ? c2[a5] = X[c2[a5]] : c2[a5] = (t3 = c2[a5]).match(/\[[\s\S]/) ? t3.replace(/^\[|\]$/g, "") : t3.replace(/\\/g, "");
              return function(a6) {
                var t4, s2 = "";
                for (t4 = 0; t4 < n3; t4++) s2 += W(c2[t4]) ? c2[t4].call(a6, e4) : c2[t4];
                return s2;
              };
            })(a4), v[a4](e3)) : e3.localeData().invalidDate();
          }
          function j(e3, a4) {
            var n3 = 5;
            function t3(e4) {
              return a4.longDateFormat(e4) || e4;
            }
            for (w.lastIndex = 0; n3 >= 0 && w.test(e3); ) e3 = e3.replace(w, t3), w.lastIndex = 0, n3 -= 1;
            return e3;
          }
          var E = {};
          function P(e3, a4) {
            var n3 = e3.toLowerCase();
            E[n3] = E[n3 + "s"] = E[a4] = e3;
          }
          function C(e3) {
            return "string" == typeof e3 ? E[e3] || E[e3.toLowerCase()] : void 0;
          }
          function x(e3) {
            var a4, n3, t3 = {};
            for (n3 in e3) i(e3, n3) && (a4 = C(n3)) && (t3[a4] = e3[n3]);
            return t3;
          }
          var R = {};
          function F(e3, a4) {
            R[e3] = a4;
          }
          function I(e3) {
            return e3 % 4 == 0 && e3 % 100 != 0 || e3 % 400 == 0;
          }
          function U(e3) {
            return e3 < 0 ? Math.ceil(e3) || 0 : Math.floor(e3);
          }
          function J(e3) {
            var a4 = +e3, n3 = 0;
            return 0 !== a4 && isFinite(a4) && (n3 = U(a4)), n3;
          }
          function G(e3, a4) {
            return function(n3) {
              return null != n3 ? (V(this, e3, n3), c.updateOffset(this, a4), this) : K(this, e3);
            };
          }
          function K(e3, a4) {
            return e3.isValid() ? e3._d["get" + (e3._isUTC ? "UTC" : "") + a4]() : NaN;
          }
          function V(e3, a4, n3) {
            e3.isValid() && !isNaN(n3) && ("FullYear" === a4 && I(e3.year()) && 1 === e3.month() && 29 === e3.date() ? (n3 = J(n3), e3._d["set" + (e3._isUTC ? "UTC" : "") + a4](n3, e3.month(), qe(n3, e3.month()))) : e3._d["set" + (e3._isUTC ? "UTC" : "") + a4](n3));
          }
          var Q, Z = /\d/, $ = /\d\d/, ee = /\d{3}/, ae = /\d{4}/, ne = /[+-]?\d{6}/, te = /\d\d?/, ce = /\d\d\d\d?/, se = /\d\d\d\d\d\d?/, oe = /\d{1,3}/, ie = /\d{1,4}/, re = /[+-]?\d{1,6}/, Me = /\d+/, de = /[+-]?\d+/, _e = /Z|[+-]\d\d:?\d\d/gi, ue = /Z|[+-]\d\d(?::?\d\d)?/gi, me = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i;
          function le(e3, a4, n3) {
            Q[e3] = W(a4) ? a4 : function(e4, t3) {
              return e4 && n3 ? n3 : a4;
            };
          }
          function pe(e3, a4) {
            return i(Q, e3) ? Q[e3](a4._strict, a4._locale) : new RegExp(Le(e3.replace("\\", "").replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, (function(e4, a5, n3, t3, c2) {
              return a5 || n3 || t3 || c2;
            }))));
          }
          function Le(e3) {
            return e3.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
          }
          Q = {};
          var be = {};
          function Ae(e3, a4) {
            var n3, t3, c2 = a4;
            for ("string" == typeof e3 && (e3 = [e3]), d(a4) && (c2 = function(e4, n4) {
              n4[a4] = J(e4);
            }), t3 = e3.length, n3 = 0; n3 < t3; n3++) be[e3[n3]] = c2;
          }
          function fe(e3, a4) {
            Ae(e3, (function(e4, n3, t3, c2) {
              t3._w = t3._w || {}, a4(e4, t3._w, t3, c2);
            }));
          }
          function he(e3, a4, n3) {
            null != a4 && i(be, e3) && be[e3](a4, n3._a, n3, e3);
          }
          var ze, Ye = 0, ye = 1, Te = 2, Oe = 3, De = 4, ke = 5, We = 6, ge = 7, Ne = 8;
          function qe(e3, a4) {
            if (isNaN(e3) || isNaN(a4)) return NaN;
            var n3, t3 = (a4 % (n3 = 12) + n3) % n3;
            return e3 += (a4 - t3) / 12, 1 === t3 ? I(e3) ? 29 : 28 : 31 - t3 % 7 % 2;
          }
          ze = Array.prototype.indexOf ? Array.prototype.indexOf : function(e3) {
            var a4;
            for (a4 = 0; a4 < this.length; ++a4) if (this[a4] === e3) return a4;
            return -1;
          }, B("M", ["MM", 2], "Mo", (function() {
            return this.month() + 1;
          })), B("MMM", 0, 0, (function(e3) {
            return this.localeData().monthsShort(this, e3);
          })), B("MMMM", 0, 0, (function(e3) {
            return this.localeData().months(this, e3);
          })), P("month", "M"), F("month", 8), le("M", te), le("MM", te, $), le("MMM", (function(e3, a4) {
            return a4.monthsShortRegex(e3);
          })), le("MMMM", (function(e3, a4) {
            return a4.monthsRegex(e3);
          })), Ae(["M", "MM"], (function(e3, a4) {
            a4[ye] = J(e3) - 1;
          })), Ae(["MMM", "MMMM"], (function(e3, a4, n3, t3) {
            var c2 = n3._locale.monthsParse(e3, t3, n3._strict);
            null != c2 ? a4[ye] = c2 : p(n3).invalidMonth = e3;
          }));
          var Se = "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), we = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), ve = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/, Xe = me, Be = me;
          function He(e3, a4, n3) {
            var t3, c2, s2, o2 = e3.toLocaleLowerCase();
            if (!this._monthsParse) for (this._monthsParse = [], this._longMonthsParse = [], this._shortMonthsParse = [], t3 = 0; t3 < 12; ++t3) s2 = l([2e3, t3]), this._shortMonthsParse[t3] = this.monthsShort(s2, "").toLocaleLowerCase(), this._longMonthsParse[t3] = this.months(s2, "").toLocaleLowerCase();
            return n3 ? "MMM" === a4 ? -1 !== (c2 = ze.call(this._shortMonthsParse, o2)) ? c2 : null : -1 !== (c2 = ze.call(this._longMonthsParse, o2)) ? c2 : null : "MMM" === a4 ? -1 !== (c2 = ze.call(this._shortMonthsParse, o2)) || -1 !== (c2 = ze.call(this._longMonthsParse, o2)) ? c2 : null : -1 !== (c2 = ze.call(this._longMonthsParse, o2)) || -1 !== (c2 = ze.call(this._shortMonthsParse, o2)) ? c2 : null;
          }
          function je(e3, a4) {
            var n3;
            if (!e3.isValid()) return e3;
            if ("string" == typeof a4) {
              if (/^\d+$/.test(a4)) a4 = J(a4);
              else if (!d(a4 = e3.localeData().monthsParse(a4))) return e3;
            }
            return n3 = Math.min(e3.date(), qe(e3.year(), a4)), e3._d["set" + (e3._isUTC ? "UTC" : "") + "Month"](a4, n3), e3;
          }
          function Ee(e3) {
            return null != e3 ? (je(this, e3), c.updateOffset(this, true), this) : K(this, "Month");
          }
          function Pe() {
            function e3(e4, a5) {
              return a5.length - e4.length;
            }
            var a4, n3, t3 = [], c2 = [], s2 = [];
            for (a4 = 0; a4 < 12; a4++) n3 = l([2e3, a4]), t3.push(this.monthsShort(n3, "")), c2.push(this.months(n3, "")), s2.push(this.months(n3, "")), s2.push(this.monthsShort(n3, ""));
            for (t3.sort(e3), c2.sort(e3), s2.sort(e3), a4 = 0; a4 < 12; a4++) t3[a4] = Le(t3[a4]), c2[a4] = Le(c2[a4]);
            for (a4 = 0; a4 < 24; a4++) s2[a4] = Le(s2[a4]);
            this._monthsRegex = new RegExp("^(" + s2.join("|") + ")", "i"), this._monthsShortRegex = this._monthsRegex, this._monthsStrictRegex = new RegExp("^(" + c2.join("|") + ")", "i"), this._monthsShortStrictRegex = new RegExp("^(" + t3.join("|") + ")", "i");
          }
          function Ce(e3) {
            return I(e3) ? 366 : 365;
          }
          B("Y", 0, 0, (function() {
            var e3 = this.year();
            return e3 <= 9999 ? q(e3, 4) : "+" + e3;
          })), B(0, ["YY", 2], 0, (function() {
            return this.year() % 100;
          })), B(0, ["YYYY", 4], 0, "year"), B(0, ["YYYYY", 5], 0, "year"), B(0, ["YYYYYY", 6, true], 0, "year"), P("year", "y"), F("year", 1), le("Y", de), le("YY", te, $), le("YYYY", ie, ae), le("YYYYY", re, ne), le("YYYYYY", re, ne), Ae(["YYYYY", "YYYYYY"], Ye), Ae("YYYY", (function(e3, a4) {
            a4[Ye] = 2 === e3.length ? c.parseTwoDigitYear(e3) : J(e3);
          })), Ae("YY", (function(e3, a4) {
            a4[Ye] = c.parseTwoDigitYear(e3);
          })), Ae("Y", (function(e3, a4) {
            a4[Ye] = parseInt(e3, 10);
          })), c.parseTwoDigitYear = function(e3) {
            return J(e3) + (J(e3) > 68 ? 1900 : 2e3);
          };
          var xe = G("FullYear", true);
          function Re(e3, a4, n3, t3, c2, s2, o2) {
            var i2;
            return e3 < 100 && e3 >= 0 ? (i2 = new Date(e3 + 400, a4, n3, t3, c2, s2, o2), isFinite(i2.getFullYear()) && i2.setFullYear(e3)) : i2 = new Date(e3, a4, n3, t3, c2, s2, o2), i2;
          }
          function Fe(e3) {
            var a4, n3;
            return e3 < 100 && e3 >= 0 ? ((n3 = Array.prototype.slice.call(arguments))[0] = e3 + 400, a4 = new Date(Date.UTC.apply(null, n3)), isFinite(a4.getUTCFullYear()) && a4.setUTCFullYear(e3)) : a4 = new Date(Date.UTC.apply(null, arguments)), a4;
          }
          function Ie(e3, a4, n3) {
            var t3 = 7 + a4 - n3;
            return -(7 + Fe(e3, 0, t3).getUTCDay() - a4) % 7 + t3 - 1;
          }
          function Ue(e3, a4, n3, t3, c2) {
            var s2, o2, i2 = 1 + 7 * (a4 - 1) + (7 + n3 - t3) % 7 + Ie(e3, t3, c2);
            return i2 <= 0 ? o2 = Ce(s2 = e3 - 1) + i2 : i2 > Ce(e3) ? (s2 = e3 + 1, o2 = i2 - Ce(e3)) : (s2 = e3, o2 = i2), { year: s2, dayOfYear: o2 };
          }
          function Je(e3, a4, n3) {
            var t3, c2, s2 = Ie(e3.year(), a4, n3), o2 = Math.floor((e3.dayOfYear() - s2 - 1) / 7) + 1;
            return o2 < 1 ? t3 = o2 + Ge(c2 = e3.year() - 1, a4, n3) : o2 > Ge(e3.year(), a4, n3) ? (t3 = o2 - Ge(e3.year(), a4, n3), c2 = e3.year() + 1) : (c2 = e3.year(), t3 = o2), { week: t3, year: c2 };
          }
          function Ge(e3, a4, n3) {
            var t3 = Ie(e3, a4, n3), c2 = Ie(e3 + 1, a4, n3);
            return (Ce(e3) - t3 + c2) / 7;
          }
          B("w", ["ww", 2], "wo", "week"), B("W", ["WW", 2], "Wo", "isoWeek"), P("week", "w"), P("isoWeek", "W"), F("week", 5), F("isoWeek", 5), le("w", te), le("ww", te, $), le("W", te), le("WW", te, $), fe(["w", "ww", "W", "WW"], (function(e3, a4, n3, t3) {
            a4[t3.substr(0, 1)] = J(e3);
          }));
          function Ke(e3, a4) {
            return e3.slice(a4, 7).concat(e3.slice(0, a4));
          }
          B("d", 0, "do", "day"), B("dd", 0, 0, (function(e3) {
            return this.localeData().weekdaysMin(this, e3);
          })), B("ddd", 0, 0, (function(e3) {
            return this.localeData().weekdaysShort(this, e3);
          })), B("dddd", 0, 0, (function(e3) {
            return this.localeData().weekdays(this, e3);
          })), B("e", 0, 0, "weekday"), B("E", 0, 0, "isoWeekday"), P("day", "d"), P("weekday", "e"), P("isoWeekday", "E"), F("day", 11), F("weekday", 11), F("isoWeekday", 11), le("d", te), le("e", te), le("E", te), le("dd", (function(e3, a4) {
            return a4.weekdaysMinRegex(e3);
          })), le("ddd", (function(e3, a4) {
            return a4.weekdaysShortRegex(e3);
          })), le("dddd", (function(e3, a4) {
            return a4.weekdaysRegex(e3);
          })), fe(["dd", "ddd", "dddd"], (function(e3, a4, n3, t3) {
            var c2 = n3._locale.weekdaysParse(e3, t3, n3._strict);
            null != c2 ? a4.d = c2 : p(n3).invalidWeekday = e3;
          })), fe(["d", "e", "E"], (function(e3, a4, n3, t3) {
            a4[t3] = J(e3);
          }));
          var Ve = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), Qe = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), Ze = "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), $e = me, ea = me, aa = me;
          function na(e3, a4, n3) {
            var t3, c2, s2, o2 = e3.toLocaleLowerCase();
            if (!this._weekdaysParse) for (this._weekdaysParse = [], this._shortWeekdaysParse = [], this._minWeekdaysParse = [], t3 = 0; t3 < 7; ++t3) s2 = l([2e3, 1]).day(t3), this._minWeekdaysParse[t3] = this.weekdaysMin(s2, "").toLocaleLowerCase(), this._shortWeekdaysParse[t3] = this.weekdaysShort(s2, "").toLocaleLowerCase(), this._weekdaysParse[t3] = this.weekdays(s2, "").toLocaleLowerCase();
            return n3 ? "dddd" === a4 ? -1 !== (c2 = ze.call(this._weekdaysParse, o2)) ? c2 : null : "ddd" === a4 ? -1 !== (c2 = ze.call(this._shortWeekdaysParse, o2)) ? c2 : null : -1 !== (c2 = ze.call(this._minWeekdaysParse, o2)) ? c2 : null : "dddd" === a4 ? -1 !== (c2 = ze.call(this._weekdaysParse, o2)) || -1 !== (c2 = ze.call(this._shortWeekdaysParse, o2)) || -1 !== (c2 = ze.call(this._minWeekdaysParse, o2)) ? c2 : null : "ddd" === a4 ? -1 !== (c2 = ze.call(this._shortWeekdaysParse, o2)) || -1 !== (c2 = ze.call(this._weekdaysParse, o2)) || -1 !== (c2 = ze.call(this._minWeekdaysParse, o2)) ? c2 : null : -1 !== (c2 = ze.call(this._minWeekdaysParse, o2)) || -1 !== (c2 = ze.call(this._weekdaysParse, o2)) || -1 !== (c2 = ze.call(this._shortWeekdaysParse, o2)) ? c2 : null;
          }
          function ta() {
            function e3(e4, a5) {
              return a5.length - e4.length;
            }
            var a4, n3, t3, c2, s2, o2 = [], i2 = [], r2 = [], M2 = [];
            for (a4 = 0; a4 < 7; a4++) n3 = l([2e3, 1]).day(a4), t3 = Le(this.weekdaysMin(n3, "")), c2 = Le(this.weekdaysShort(n3, "")), s2 = Le(this.weekdays(n3, "")), o2.push(t3), i2.push(c2), r2.push(s2), M2.push(t3), M2.push(c2), M2.push(s2);
            o2.sort(e3), i2.sort(e3), r2.sort(e3), M2.sort(e3), this._weekdaysRegex = new RegExp("^(" + M2.join("|") + ")", "i"), this._weekdaysShortRegex = this._weekdaysRegex, this._weekdaysMinRegex = this._weekdaysRegex, this._weekdaysStrictRegex = new RegExp("^(" + r2.join("|") + ")", "i"), this._weekdaysShortStrictRegex = new RegExp("^(" + i2.join("|") + ")", "i"), this._weekdaysMinStrictRegex = new RegExp("^(" + o2.join("|") + ")", "i");
          }
          function ca() {
            return this.hours() % 12 || 12;
          }
          function sa(e3, a4) {
            B(e3, 0, 0, (function() {
              return this.localeData().meridiem(this.hours(), this.minutes(), a4);
            }));
          }
          function oa(e3, a4) {
            return a4._meridiemParse;
          }
          B("H", ["HH", 2], 0, "hour"), B("h", ["hh", 2], 0, ca), B("k", ["kk", 2], 0, (function() {
            return this.hours() || 24;
          })), B("hmm", 0, 0, (function() {
            return "" + ca.apply(this) + q(this.minutes(), 2);
          })), B("hmmss", 0, 0, (function() {
            return "" + ca.apply(this) + q(this.minutes(), 2) + q(this.seconds(), 2);
          })), B("Hmm", 0, 0, (function() {
            return "" + this.hours() + q(this.minutes(), 2);
          })), B("Hmmss", 0, 0, (function() {
            return "" + this.hours() + q(this.minutes(), 2) + q(this.seconds(), 2);
          })), sa("a", true), sa("A", false), P("hour", "h"), F("hour", 13), le("a", oa), le("A", oa), le("H", te), le("h", te), le("k", te), le("HH", te, $), le("hh", te, $), le("kk", te, $), le("hmm", ce), le("hmmss", se), le("Hmm", ce), le("Hmmss", se), Ae(["H", "HH"], Oe), Ae(["k", "kk"], (function(e3, a4, n3) {
            var t3 = J(e3);
            a4[Oe] = 24 === t3 ? 0 : t3;
          })), Ae(["a", "A"], (function(e3, a4, n3) {
            n3._isPm = n3._locale.isPM(e3), n3._meridiem = e3;
          })), Ae(["h", "hh"], (function(e3, a4, n3) {
            a4[Oe] = J(e3), p(n3).bigHour = true;
          })), Ae("hmm", (function(e3, a4, n3) {
            var t3 = e3.length - 2;
            a4[Oe] = J(e3.substr(0, t3)), a4[De] = J(e3.substr(t3)), p(n3).bigHour = true;
          })), Ae("hmmss", (function(e3, a4, n3) {
            var t3 = e3.length - 4, c2 = e3.length - 2;
            a4[Oe] = J(e3.substr(0, t3)), a4[De] = J(e3.substr(t3, 2)), a4[ke] = J(e3.substr(c2)), p(n3).bigHour = true;
          })), Ae("Hmm", (function(e3, a4, n3) {
            var t3 = e3.length - 2;
            a4[Oe] = J(e3.substr(0, t3)), a4[De] = J(e3.substr(t3));
          })), Ae("Hmmss", (function(e3, a4, n3) {
            var t3 = e3.length - 4, c2 = e3.length - 2;
            a4[Oe] = J(e3.substr(0, t3)), a4[De] = J(e3.substr(t3, 2)), a4[ke] = J(e3.substr(c2));
          }));
          var ia = G("Hours", true);
          var ra, Ma = { calendar: { sameDay: "[Today at] LT", nextDay: "[Tomorrow at] LT", nextWeek: "dddd [at] LT", lastDay: "[Yesterday at] LT", lastWeek: "[Last] dddd [at] LT", sameElse: "L" }, longDateFormat: { LTS: "h:mm:ss A", LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A" }, invalidDate: "Invalid date", ordinal: "%d", dayOfMonthOrdinalParse: /\d{1,2}/, relativeTime: { future: "in %s", past: "%s ago", s: "a few seconds", ss: "%d seconds", m: "a minute", mm: "%d minutes", h: "an hour", hh: "%d hours", d: "a day", dd: "%d days", w: "a week", ww: "%d weeks", M: "a month", MM: "%d months", y: "a year", yy: "%d years" }, months: Se, monthsShort: we, week: { dow: 0, doy: 6 }, weekdays: Ve, weekdaysMin: Ze, weekdaysShort: Qe, meridiemParse: /[ap]\.?m?\.?/i }, da = {}, _a = {};
          function ua(e3, a4) {
            var n3, t3 = Math.min(e3.length, a4.length);
            for (n3 = 0; n3 < t3; n3 += 1) if (e3[n3] !== a4[n3]) return n3;
            return t3;
          }
          function ma(e3) {
            return e3 ? e3.toLowerCase().replace("_", "-") : e3;
          }
          function la(a4) {
            var t3 = null;
            if (void 0 === da[a4] && e2 && e2.exports && (function(e3) {
              return null != e3.match("^[^/\\\\]*$");
            })(a4)) try {
              t3 = ra._abbr, n2(6616)("./" + a4), pa(t3);
            } catch (e3) {
              da[a4] = null;
            }
            return da[a4];
          }
          function pa(e3, a4) {
            var n3;
            return e3 && ((n3 = M(a4) ? ba(e3) : La(e3, a4)) ? ra = n3 : "undefined" != typeof console && console.warn && console.warn("Locale " + e3 + " not found. Did you forget to load it?")), ra._abbr;
          }
          function La(e3, a4) {
            if (null !== a4) {
              var n3, t3 = Ma;
              if (a4.abbr = e3, null != da[e3]) k("defineLocaleOverride", "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."), t3 = da[e3]._config;
              else if (null != a4.parentLocale) if (null != da[a4.parentLocale]) t3 = da[a4.parentLocale]._config;
              else {
                if (null == (n3 = la(a4.parentLocale))) return _a[a4.parentLocale] || (_a[a4.parentLocale] = []), _a[a4.parentLocale].push({ name: e3, config: a4 }), null;
                t3 = n3._config;
              }
              return da[e3] = new N(g(t3, a4)), _a[e3] && _a[e3].forEach((function(e4) {
                La(e4.name, e4.config);
              })), pa(e3), da[e3];
            }
            return delete da[e3], null;
          }
          function ba(e3) {
            var a4;
            if (e3 && e3._locale && e3._locale._abbr && (e3 = e3._locale._abbr), !e3) return ra;
            if (!s(e3)) {
              if (a4 = la(e3)) return a4;
              e3 = [e3];
            }
            return (function(e4) {
              for (var a5, n3, t3, c2, s2 = 0; s2 < e4.length; ) {
                for (a5 = (c2 = ma(e4[s2]).split("-")).length, n3 = (n3 = ma(e4[s2 + 1])) ? n3.split("-") : null; a5 > 0; ) {
                  if (t3 = la(c2.slice(0, a5).join("-"))) return t3;
                  if (n3 && n3.length >= a5 && ua(c2, n3) >= a5 - 1) break;
                  a5--;
                }
                s2++;
              }
              return ra;
            })(e3);
          }
          function Aa(e3) {
            var a4, n3 = e3._a;
            return n3 && -2 === p(e3).overflow && (a4 = n3[ye] < 0 || n3[ye] > 11 ? ye : n3[Te] < 1 || n3[Te] > qe(n3[Ye], n3[ye]) ? Te : n3[Oe] < 0 || n3[Oe] > 24 || 24 === n3[Oe] && (0 !== n3[De] || 0 !== n3[ke] || 0 !== n3[We]) ? Oe : n3[De] < 0 || n3[De] > 59 ? De : n3[ke] < 0 || n3[ke] > 59 ? ke : n3[We] < 0 || n3[We] > 999 ? We : -1, p(e3)._overflowDayOfYear && (a4 < Ye || a4 > Te) && (a4 = Te), p(e3)._overflowWeeks && -1 === a4 && (a4 = ge), p(e3)._overflowWeekday && -1 === a4 && (a4 = Ne), p(e3).overflow = a4), e3;
          }
          var fa = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, ha = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, za = /Z|[+-]\d\d(?::?\d\d)?/, Ya = [["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/], ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/], ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/], ["GGGG-[W]WW", /\d{4}-W\d\d/, false], ["YYYY-DDD", /\d{4}-\d{3}/], ["YYYY-MM", /\d{4}-\d\d/, false], ["YYYYYYMMDD", /[+-]\d{10}/], ["YYYYMMDD", /\d{8}/], ["GGGG[W]WWE", /\d{4}W\d{3}/], ["GGGG[W]WW", /\d{4}W\d{2}/, false], ["YYYYDDD", /\d{7}/], ["YYYYMM", /\d{6}/, false], ["YYYY", /\d{4}/, false]], ya = [["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/], ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/], ["HH:mm:ss", /\d\d:\d\d:\d\d/], ["HH:mm", /\d\d:\d\d/], ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/], ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/], ["HHmmss", /\d\d\d\d\d\d/], ["HHmm", /\d\d\d\d/], ["HH", /\d\d/]], Ta = /^\/?Date\((-?\d+)/i, Oa = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/, Da = { UT: 0, GMT: 0, EDT: -240, EST: -300, CDT: -300, CST: -360, MDT: -360, MST: -420, PDT: -420, PST: -480 };
          function ka(e3) {
            var a4, n3, t3, c2, s2, o2, i2 = e3._i, r2 = fa.exec(i2) || ha.exec(i2), M2 = Ya.length, d2 = ya.length;
            if (r2) {
              for (p(e3).iso = true, a4 = 0, n3 = M2; a4 < n3; a4++) if (Ya[a4][1].exec(r2[1])) {
                c2 = Ya[a4][0], t3 = false !== Ya[a4][2];
                break;
              }
              if (null == c2) return void (e3._isValid = false);
              if (r2[3]) {
                for (a4 = 0, n3 = d2; a4 < n3; a4++) if (ya[a4][1].exec(r2[3])) {
                  s2 = (r2[2] || " ") + ya[a4][0];
                  break;
                }
                if (null == s2) return void (e3._isValid = false);
              }
              if (!t3 && null != s2) return void (e3._isValid = false);
              if (r2[4]) {
                if (!za.exec(r2[4])) return void (e3._isValid = false);
                o2 = "Z";
              }
              e3._f = c2 + (s2 || "") + (o2 || ""), Sa(e3);
            } else e3._isValid = false;
          }
          function Wa(e3) {
            var a4 = parseInt(e3, 10);
            return a4 <= 49 ? 2e3 + a4 : a4 <= 999 ? 1900 + a4 : a4;
          }
          function ga(e3) {
            var a4, n3, t3, c2, s2, o2, i2, r2, M2 = Oa.exec(e3._i.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, ""));
            if (M2) {
              if (n3 = M2[4], t3 = M2[3], c2 = M2[2], s2 = M2[5], o2 = M2[6], i2 = M2[7], r2 = [Wa(n3), we.indexOf(t3), parseInt(c2, 10), parseInt(s2, 10), parseInt(o2, 10)], i2 && r2.push(parseInt(i2, 10)), a4 = r2, !(function(e4, a5, n4) {
                return !e4 || Qe.indexOf(e4) === new Date(a5[0], a5[1], a5[2]).getDay() || (p(n4).weekdayMismatch = true, n4._isValid = false, false);
              })(M2[1], a4, e3)) return;
              e3._a = a4, e3._tzm = (function(e4, a5, n4) {
                if (e4) return Da[e4];
                if (a5) return 0;
                var t4 = parseInt(n4, 10), c3 = t4 % 100;
                return (t4 - c3) / 100 * 60 + c3;
              })(M2[8], M2[9], M2[10]), e3._d = Fe.apply(null, e3._a), e3._d.setUTCMinutes(e3._d.getUTCMinutes() - e3._tzm), p(e3).rfc2822 = true;
            } else e3._isValid = false;
          }
          function Na(e3, a4, n3) {
            return null != e3 ? e3 : null != a4 ? a4 : n3;
          }
          function qa(e3) {
            var a4, n3, t3, s2, o2, i2 = [];
            if (!e3._d) {
              for (t3 = (function(e4) {
                var a5 = new Date(c.now());
                return e4._useUTC ? [a5.getUTCFullYear(), a5.getUTCMonth(), a5.getUTCDate()] : [a5.getFullYear(), a5.getMonth(), a5.getDate()];
              })(e3), e3._w && null == e3._a[Te] && null == e3._a[ye] && (function(e4) {
                var a5, n4, t4, c2, s3, o3, i3, r2, M2;
                null != (a5 = e4._w).GG || null != a5.W || null != a5.E ? (s3 = 1, o3 = 4, n4 = Na(a5.GG, e4._a[Ye], Je(Xa(), 1, 4).year), t4 = Na(a5.W, 1), ((c2 = Na(a5.E, 1)) < 1 || c2 > 7) && (r2 = true)) : (s3 = e4._locale._week.dow, o3 = e4._locale._week.doy, M2 = Je(Xa(), s3, o3), n4 = Na(a5.gg, e4._a[Ye], M2.year), t4 = Na(a5.w, M2.week), null != a5.d ? ((c2 = a5.d) < 0 || c2 > 6) && (r2 = true) : null != a5.e ? (c2 = a5.e + s3, (a5.e < 0 || a5.e > 6) && (r2 = true)) : c2 = s3), t4 < 1 || t4 > Ge(n4, s3, o3) ? p(e4)._overflowWeeks = true : null != r2 ? p(e4)._overflowWeekday = true : (i3 = Ue(n4, t4, c2, s3, o3), e4._a[Ye] = i3.year, e4._dayOfYear = i3.dayOfYear);
              })(e3), null != e3._dayOfYear && (o2 = Na(e3._a[Ye], t3[Ye]), (e3._dayOfYear > Ce(o2) || 0 === e3._dayOfYear) && (p(e3)._overflowDayOfYear = true), n3 = Fe(o2, 0, e3._dayOfYear), e3._a[ye] = n3.getUTCMonth(), e3._a[Te] = n3.getUTCDate()), a4 = 0; a4 < 3 && null == e3._a[a4]; ++a4) e3._a[a4] = i2[a4] = t3[a4];
              for (; a4 < 7; a4++) e3._a[a4] = i2[a4] = null == e3._a[a4] ? 2 === a4 ? 1 : 0 : e3._a[a4];
              24 === e3._a[Oe] && 0 === e3._a[De] && 0 === e3._a[ke] && 0 === e3._a[We] && (e3._nextDay = true, e3._a[Oe] = 0), e3._d = (e3._useUTC ? Fe : Re).apply(null, i2), s2 = e3._useUTC ? e3._d.getUTCDay() : e3._d.getDay(), null != e3._tzm && e3._d.setUTCMinutes(e3._d.getUTCMinutes() - e3._tzm), e3._nextDay && (e3._a[Oe] = 24), e3._w && void 0 !== e3._w.d && e3._w.d !== s2 && (p(e3).weekdayMismatch = true);
            }
          }
          function Sa(e3) {
            if (e3._f !== c.ISO_8601) if (e3._f !== c.RFC_2822) {
              e3._a = [], p(e3).empty = true;
              var a4, n3, t3, s2, o2, i2, r2, M2 = "" + e3._i, d2 = M2.length, _2 = 0;
              for (r2 = (t3 = j(e3._f, e3._locale).match(S) || []).length, a4 = 0; a4 < r2; a4++) s2 = t3[a4], (n3 = (M2.match(pe(s2, e3)) || [])[0]) && ((o2 = M2.substr(0, M2.indexOf(n3))).length > 0 && p(e3).unusedInput.push(o2), M2 = M2.slice(M2.indexOf(n3) + n3.length), _2 += n3.length), X[s2] ? (n3 ? p(e3).empty = false : p(e3).unusedTokens.push(s2), he(s2, n3, e3)) : e3._strict && !n3 && p(e3).unusedTokens.push(s2);
              p(e3).charsLeftOver = d2 - _2, M2.length > 0 && p(e3).unusedInput.push(M2), e3._a[Oe] <= 12 && true === p(e3).bigHour && e3._a[Oe] > 0 && (p(e3).bigHour = void 0), p(e3).parsedDateParts = e3._a.slice(0), p(e3).meridiem = e3._meridiem, e3._a[Oe] = (function(e4, a5, n4) {
                var t4;
                return null == n4 ? a5 : null != e4.meridiemHour ? e4.meridiemHour(a5, n4) : null != e4.isPM ? ((t4 = e4.isPM(n4)) && a5 < 12 && (a5 += 12), t4 || 12 !== a5 || (a5 = 0), a5) : a5;
              })(e3._locale, e3._a[Oe], e3._meridiem), null !== (i2 = p(e3).era) && (e3._a[Ye] = e3._locale.erasConvertYear(i2, e3._a[Ye])), qa(e3), Aa(e3);
            } else ga(e3);
            else ka(e3);
          }
          function wa(e3) {
            var a4 = e3._i, n3 = e3._f;
            return e3._locale = e3._locale || ba(e3._l), null === a4 || void 0 === n3 && "" === a4 ? b({ nullInput: true }) : ("string" == typeof a4 && (e3._i = a4 = e3._locale.preparse(a4)), Y(a4) ? new z(Aa(a4)) : (_(a4) ? e3._d = a4 : s(n3) ? (function(e4) {
              var a5, n4, t3, c2, s2, o2, i2 = false, r2 = e4._f.length;
              if (0 === r2) return p(e4).invalidFormat = true, void (e4._d = /* @__PURE__ */ new Date(NaN));
              for (c2 = 0; c2 < r2; c2++) s2 = 0, o2 = false, a5 = h({}, e4), null != e4._useUTC && (a5._useUTC = e4._useUTC), a5._f = e4._f[c2], Sa(a5), L(a5) && (o2 = true), s2 += p(a5).charsLeftOver, s2 += 10 * p(a5).unusedTokens.length, p(a5).score = s2, i2 ? s2 < t3 && (t3 = s2, n4 = a5) : (null == t3 || s2 < t3 || o2) && (t3 = s2, n4 = a5, o2 && (i2 = true));
              m(e4, n4 || a5);
            })(e3) : n3 ? Sa(e3) : (function(e4) {
              var a5 = e4._i;
              M(a5) ? e4._d = new Date(c.now()) : _(a5) ? e4._d = new Date(a5.valueOf()) : "string" == typeof a5 ? (function(e5) {
                var a6 = Ta.exec(e5._i);
                null === a6 ? (ka(e5), false === e5._isValid && (delete e5._isValid, ga(e5), false === e5._isValid && (delete e5._isValid, e5._strict ? e5._isValid = false : c.createFromInputFallback(e5)))) : e5._d = /* @__PURE__ */ new Date(+a6[1]);
              })(e4) : s(a5) ? (e4._a = u(a5.slice(0), (function(e5) {
                return parseInt(e5, 10);
              })), qa(e4)) : o(a5) ? (function(e5) {
                if (!e5._d) {
                  var a6 = x(e5._i), n4 = void 0 === a6.day ? a6.date : a6.day;
                  e5._a = u([a6.year, a6.month, n4, a6.hour, a6.minute, a6.second, a6.millisecond], (function(e6) {
                    return e6 && parseInt(e6, 10);
                  })), qa(e5);
                }
              })(e4) : d(a5) ? e4._d = new Date(a5) : c.createFromInputFallback(e4);
            })(e3), L(e3) || (e3._d = null), e3));
          }
          function va(e3, a4, n3, t3, c2) {
            var i2, M2 = {};
            return true !== a4 && false !== a4 || (t3 = a4, a4 = void 0), true !== n3 && false !== n3 || (t3 = n3, n3 = void 0), (o(e3) && r(e3) || s(e3) && 0 === e3.length) && (e3 = void 0), M2._isAMomentObject = true, M2._useUTC = M2._isUTC = c2, M2._l = n3, M2._i = e3, M2._f = a4, M2._strict = t3, (i2 = new z(Aa(wa(M2))))._nextDay && (i2.add(1, "d"), i2._nextDay = void 0), i2;
          }
          function Xa(e3, a4, n3, t3) {
            return va(e3, a4, n3, t3, false);
          }
          c.createFromInputFallback = T("value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.", (function(e3) {
            e3._d = /* @__PURE__ */ new Date(e3._i + (e3._useUTC ? " UTC" : ""));
          })), c.ISO_8601 = function() {
          }, c.RFC_2822 = function() {
          };
          var Ba = T("moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/", (function() {
            var e3 = Xa.apply(null, arguments);
            return this.isValid() && e3.isValid() ? e3 < this ? this : e3 : b();
          })), Ha = T("moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/", (function() {
            var e3 = Xa.apply(null, arguments);
            return this.isValid() && e3.isValid() ? e3 > this ? this : e3 : b();
          }));
          function ja(e3, a4) {
            var n3, t3;
            if (1 === a4.length && s(a4[0]) && (a4 = a4[0]), !a4.length) return Xa();
            for (n3 = a4[0], t3 = 1; t3 < a4.length; ++t3) a4[t3].isValid() && !a4[t3][e3](n3) || (n3 = a4[t3]);
            return n3;
          }
          var Ea = ["year", "quarter", "month", "week", "day", "hour", "minute", "second", "millisecond"];
          function Pa(e3) {
            var a4 = x(e3), n3 = a4.year || 0, t3 = a4.quarter || 0, c2 = a4.month || 0, s2 = a4.week || a4.isoWeek || 0, o2 = a4.day || 0, r2 = a4.hour || 0, M2 = a4.minute || 0, d2 = a4.second || 0, _2 = a4.millisecond || 0;
            this._isValid = (function(e4) {
              var a5, n4, t4 = false, c3 = Ea.length;
              for (a5 in e4) if (i(e4, a5) && (-1 === ze.call(Ea, a5) || null != e4[a5] && isNaN(e4[a5]))) return false;
              for (n4 = 0; n4 < c3; ++n4) if (e4[Ea[n4]]) {
                if (t4) return false;
                parseFloat(e4[Ea[n4]]) !== J(e4[Ea[n4]]) && (t4 = true);
              }
              return true;
            })(a4), this._milliseconds = +_2 + 1e3 * d2 + 6e4 * M2 + 1e3 * r2 * 60 * 60, this._days = +o2 + 7 * s2, this._months = +c2 + 3 * t3 + 12 * n3, this._data = {}, this._locale = ba(), this._bubble();
          }
          function Ca(e3) {
            return e3 instanceof Pa;
          }
          function xa(e3) {
            return e3 < 0 ? -1 * Math.round(-1 * e3) : Math.round(e3);
          }
          function Ra(e3, a4) {
            B(e3, 0, 0, (function() {
              var e4 = this.utcOffset(), n3 = "+";
              return e4 < 0 && (e4 = -e4, n3 = "-"), n3 + q(~~(e4 / 60), 2) + a4 + q(~~e4 % 60, 2);
            }));
          }
          Ra("Z", ":"), Ra("ZZ", ""), le("Z", ue), le("ZZ", ue), Ae(["Z", "ZZ"], (function(e3, a4, n3) {
            n3._useUTC = true, n3._tzm = Ia(ue, e3);
          }));
          var Fa = /([\+\-]|\d\d)/gi;
          function Ia(e3, a4) {
            var n3, t3, c2 = (a4 || "").match(e3);
            return null === c2 ? null : 0 === (t3 = 60 * (n3 = ((c2[c2.length - 1] || []) + "").match(Fa) || ["-", 0, 0])[1] + J(n3[2])) ? 0 : "+" === n3[0] ? t3 : -t3;
          }
          function Ua(e3, a4) {
            var n3, t3;
            return a4._isUTC ? (n3 = a4.clone(), t3 = (Y(e3) || _(e3) ? e3.valueOf() : Xa(e3).valueOf()) - n3.valueOf(), n3._d.setTime(n3._d.valueOf() + t3), c.updateOffset(n3, false), n3) : Xa(e3).local();
          }
          function Ja(e3) {
            return -Math.round(e3._d.getTimezoneOffset());
          }
          function Ga() {
            return !!this.isValid() && this._isUTC && 0 === this._offset;
          }
          c.updateOffset = function() {
          };
          var Ka = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/, Va = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
          function Qa(e3, a4) {
            var n3, t3, c2, s2, o2, r2, M2 = e3, _2 = null;
            return Ca(e3) ? M2 = { ms: e3._milliseconds, d: e3._days, M: e3._months } : d(e3) || !isNaN(+e3) ? (M2 = {}, a4 ? M2[a4] = +e3 : M2.milliseconds = +e3) : (_2 = Ka.exec(e3)) ? (n3 = "-" === _2[1] ? -1 : 1, M2 = { y: 0, d: J(_2[Te]) * n3, h: J(_2[Oe]) * n3, m: J(_2[De]) * n3, s: J(_2[ke]) * n3, ms: J(xa(1e3 * _2[We])) * n3 }) : (_2 = Va.exec(e3)) ? (n3 = "-" === _2[1] ? -1 : 1, M2 = { y: Za(_2[2], n3), M: Za(_2[3], n3), w: Za(_2[4], n3), d: Za(_2[5], n3), h: Za(_2[6], n3), m: Za(_2[7], n3), s: Za(_2[8], n3) }) : null == M2 ? M2 = {} : "object" == typeof M2 && ("from" in M2 || "to" in M2) && (s2 = Xa(M2.from), o2 = Xa(M2.to), c2 = s2.isValid() && o2.isValid() ? (o2 = Ua(o2, s2), s2.isBefore(o2) ? r2 = $a(s2, o2) : ((r2 = $a(o2, s2)).milliseconds = -r2.milliseconds, r2.months = -r2.months), r2) : { milliseconds: 0, months: 0 }, (M2 = {}).ms = c2.milliseconds, M2.M = c2.months), t3 = new Pa(M2), Ca(e3) && i(e3, "_locale") && (t3._locale = e3._locale), Ca(e3) && i(e3, "_isValid") && (t3._isValid = e3._isValid), t3;
          }
          function Za(e3, a4) {
            var n3 = e3 && parseFloat(e3.replace(",", "."));
            return (isNaN(n3) ? 0 : n3) * a4;
          }
          function $a(e3, a4) {
            var n3 = {};
            return n3.months = a4.month() - e3.month() + 12 * (a4.year() - e3.year()), e3.clone().add(n3.months, "M").isAfter(a4) && --n3.months, n3.milliseconds = +a4 - +e3.clone().add(n3.months, "M"), n3;
          }
          function en(e3, a4) {
            return function(n3, t3) {
              var c2;
              return null === t3 || isNaN(+t3) || (k(a4, "moment()." + a4 + "(period, number) is deprecated. Please use moment()." + a4 + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."), c2 = n3, n3 = t3, t3 = c2), an(this, Qa(n3, t3), e3), this;
            };
          }
          function an(e3, a4, n3, t3) {
            var s2 = a4._milliseconds, o2 = xa(a4._days), i2 = xa(a4._months);
            e3.isValid() && (t3 = null == t3 || t3, i2 && je(e3, K(e3, "Month") + i2 * n3), o2 && V(e3, "Date", K(e3, "Date") + o2 * n3), s2 && e3._d.setTime(e3._d.valueOf() + s2 * n3), t3 && c.updateOffset(e3, o2 || i2));
          }
          Qa.fn = Pa.prototype, Qa.invalid = function() {
            return Qa(NaN);
          };
          var nn = en(1, "add"), tn = en(-1, "subtract");
          function cn(e3) {
            return "string" == typeof e3 || e3 instanceof String;
          }
          function sn(e3) {
            return Y(e3) || _(e3) || cn(e3) || d(e3) || (function(e4) {
              var a4 = s(e4), n3 = false;
              return a4 && (n3 = 0 === e4.filter((function(a5) {
                return !d(a5) && cn(e4);
              })).length), a4 && n3;
            })(e3) || (function(e4) {
              var a4, n3, t3 = o(e4) && !r(e4), c2 = false, s2 = ["years", "year", "y", "months", "month", "M", "days", "day", "d", "dates", "date", "D", "hours", "hour", "h", "minutes", "minute", "m", "seconds", "second", "s", "milliseconds", "millisecond", "ms"], M2 = s2.length;
              for (a4 = 0; a4 < M2; a4 += 1) n3 = s2[a4], c2 = c2 || i(e4, n3);
              return t3 && c2;
            })(e3) || null == e3;
          }
          function on(e3, a4) {
            if (e3.date() < a4.date()) return -on(a4, e3);
            var n3 = 12 * (a4.year() - e3.year()) + (a4.month() - e3.month()), t3 = e3.clone().add(n3, "months");
            return -(n3 + (a4 - t3 < 0 ? (a4 - t3) / (t3 - e3.clone().add(n3 - 1, "months")) : (a4 - t3) / (e3.clone().add(n3 + 1, "months") - t3))) || 0;
          }
          function rn(e3) {
            var a4;
            return void 0 === e3 ? this._locale._abbr : (null != (a4 = ba(e3)) && (this._locale = a4), this);
          }
          c.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ", c.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
          var Mn = T("moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.", (function(e3) {
            return void 0 === e3 ? this.localeData() : this.locale(e3);
          }));
          function dn() {
            return this._locale;
          }
          var _n = 1e3, un = 6e4, mn = 36e5, ln = 126227808e5;
          function pn(e3, a4) {
            return (e3 % a4 + a4) % a4;
          }
          function Ln(e3, a4, n3) {
            return e3 < 100 && e3 >= 0 ? new Date(e3 + 400, a4, n3) - ln : new Date(e3, a4, n3).valueOf();
          }
          function bn(e3, a4, n3) {
            return e3 < 100 && e3 >= 0 ? Date.UTC(e3 + 400, a4, n3) - ln : Date.UTC(e3, a4, n3);
          }
          function An(e3, a4) {
            return a4.erasAbbrRegex(e3);
          }
          function fn() {
            var e3, a4, n3 = [], t3 = [], c2 = [], s2 = [], o2 = this.eras();
            for (e3 = 0, a4 = o2.length; e3 < a4; ++e3) t3.push(Le(o2[e3].name)), n3.push(Le(o2[e3].abbr)), c2.push(Le(o2[e3].narrow)), s2.push(Le(o2[e3].name)), s2.push(Le(o2[e3].abbr)), s2.push(Le(o2[e3].narrow));
            this._erasRegex = new RegExp("^(" + s2.join("|") + ")", "i"), this._erasNameRegex = new RegExp("^(" + t3.join("|") + ")", "i"), this._erasAbbrRegex = new RegExp("^(" + n3.join("|") + ")", "i"), this._erasNarrowRegex = new RegExp("^(" + c2.join("|") + ")", "i");
          }
          function hn(e3, a4) {
            B(0, [e3, e3.length], 0, a4);
          }
          function zn(e3, a4, n3, t3, c2) {
            var s2;
            return null == e3 ? Je(this, t3, c2).year : (a4 > (s2 = Ge(e3, t3, c2)) && (a4 = s2), Yn.call(this, e3, a4, n3, t3, c2));
          }
          function Yn(e3, a4, n3, t3, c2) {
            var s2 = Ue(e3, a4, n3, t3, c2), o2 = Fe(s2.year, 0, s2.dayOfYear);
            return this.year(o2.getUTCFullYear()), this.month(o2.getUTCMonth()), this.date(o2.getUTCDate()), this;
          }
          B("N", 0, 0, "eraAbbr"), B("NN", 0, 0, "eraAbbr"), B("NNN", 0, 0, "eraAbbr"), B("NNNN", 0, 0, "eraName"), B("NNNNN", 0, 0, "eraNarrow"), B("y", ["y", 1], "yo", "eraYear"), B("y", ["yy", 2], 0, "eraYear"), B("y", ["yyy", 3], 0, "eraYear"), B("y", ["yyyy", 4], 0, "eraYear"), le("N", An), le("NN", An), le("NNN", An), le("NNNN", (function(e3, a4) {
            return a4.erasNameRegex(e3);
          })), le("NNNNN", (function(e3, a4) {
            return a4.erasNarrowRegex(e3);
          })), Ae(["N", "NN", "NNN", "NNNN", "NNNNN"], (function(e3, a4, n3, t3) {
            var c2 = n3._locale.erasParse(e3, t3, n3._strict);
            c2 ? p(n3).era = c2 : p(n3).invalidEra = e3;
          })), le("y", Me), le("yy", Me), le("yyy", Me), le("yyyy", Me), le("yo", (function(e3, a4) {
            return a4._eraYearOrdinalRegex || Me;
          })), Ae(["y", "yy", "yyy", "yyyy"], Ye), Ae(["yo"], (function(e3, a4, n3, t3) {
            var c2;
            n3._locale._eraYearOrdinalRegex && (c2 = e3.match(n3._locale._eraYearOrdinalRegex)), n3._locale.eraYearOrdinalParse ? a4[Ye] = n3._locale.eraYearOrdinalParse(e3, c2) : a4[Ye] = parseInt(e3, 10);
          })), B(0, ["gg", 2], 0, (function() {
            return this.weekYear() % 100;
          })), B(0, ["GG", 2], 0, (function() {
            return this.isoWeekYear() % 100;
          })), hn("gggg", "weekYear"), hn("ggggg", "weekYear"), hn("GGGG", "isoWeekYear"), hn("GGGGG", "isoWeekYear"), P("weekYear", "gg"), P("isoWeekYear", "GG"), F("weekYear", 1), F("isoWeekYear", 1), le("G", de), le("g", de), le("GG", te, $), le("gg", te, $), le("GGGG", ie, ae), le("gggg", ie, ae), le("GGGGG", re, ne), le("ggggg", re, ne), fe(["gggg", "ggggg", "GGGG", "GGGGG"], (function(e3, a4, n3, t3) {
            a4[t3.substr(0, 2)] = J(e3);
          })), fe(["gg", "GG"], (function(e3, a4, n3, t3) {
            a4[t3] = c.parseTwoDigitYear(e3);
          })), B("Q", 0, "Qo", "quarter"), P("quarter", "Q"), F("quarter", 7), le("Q", Z), Ae("Q", (function(e3, a4) {
            a4[ye] = 3 * (J(e3) - 1);
          })), B("D", ["DD", 2], "Do", "date"), P("date", "D"), F("date", 9), le("D", te), le("DD", te, $), le("Do", (function(e3, a4) {
            return e3 ? a4._dayOfMonthOrdinalParse || a4._ordinalParse : a4._dayOfMonthOrdinalParseLenient;
          })), Ae(["D", "DD"], Te), Ae("Do", (function(e3, a4) {
            a4[Te] = J(e3.match(te)[0]);
          }));
          var yn = G("Date", true);
          B("DDD", ["DDDD", 3], "DDDo", "dayOfYear"), P("dayOfYear", "DDD"), F("dayOfYear", 4), le("DDD", oe), le("DDDD", ee), Ae(["DDD", "DDDD"], (function(e3, a4, n3) {
            n3._dayOfYear = J(e3);
          })), B("m", ["mm", 2], 0, "minute"), P("minute", "m"), F("minute", 14), le("m", te), le("mm", te, $), Ae(["m", "mm"], De);
          var Tn = G("Minutes", false);
          B("s", ["ss", 2], 0, "second"), P("second", "s"), F("second", 15), le("s", te), le("ss", te, $), Ae(["s", "ss"], ke);
          var On, Dn, kn = G("Seconds", false);
          for (B("S", 0, 0, (function() {
            return ~~(this.millisecond() / 100);
          })), B(0, ["SS", 2], 0, (function() {
            return ~~(this.millisecond() / 10);
          })), B(0, ["SSS", 3], 0, "millisecond"), B(0, ["SSSS", 4], 0, (function() {
            return 10 * this.millisecond();
          })), B(0, ["SSSSS", 5], 0, (function() {
            return 100 * this.millisecond();
          })), B(0, ["SSSSSS", 6], 0, (function() {
            return 1e3 * this.millisecond();
          })), B(0, ["SSSSSSS", 7], 0, (function() {
            return 1e4 * this.millisecond();
          })), B(0, ["SSSSSSSS", 8], 0, (function() {
            return 1e5 * this.millisecond();
          })), B(0, ["SSSSSSSSS", 9], 0, (function() {
            return 1e6 * this.millisecond();
          })), P("millisecond", "ms"), F("millisecond", 16), le("S", oe, Z), le("SS", oe, $), le("SSS", oe, ee), On = "SSSS"; On.length <= 9; On += "S") le(On, Me);
          function Wn(e3, a4) {
            a4[We] = J(1e3 * ("0." + e3));
          }
          for (On = "S"; On.length <= 9; On += "S") Ae(On, Wn);
          Dn = G("Milliseconds", false), B("z", 0, 0, "zoneAbbr"), B("zz", 0, 0, "zoneName");
          var gn = z.prototype;
          function Nn(e3) {
            return e3;
          }
          gn.add = nn, gn.calendar = function(e3, a4) {
            1 === arguments.length && (arguments[0] ? sn(arguments[0]) ? (e3 = arguments[0], a4 = void 0) : (function(e4) {
              var a5, n4 = o(e4) && !r(e4), t4 = false, c2 = ["sameDay", "nextDay", "lastDay", "nextWeek", "lastWeek", "sameElse"];
              for (a5 = 0; a5 < c2.length; a5 += 1) t4 = t4 || i(e4, c2[a5]);
              return n4 && t4;
            })(arguments[0]) && (a4 = arguments[0], e3 = void 0) : (e3 = void 0, a4 = void 0));
            var n3 = e3 || Xa(), t3 = Ua(n3, this).startOf("day"), s2 = c.calendarFormat(this, t3) || "sameElse", M2 = a4 && (W(a4[s2]) ? a4[s2].call(this, n3) : a4[s2]);
            return this.format(M2 || this.localeData().calendar(s2, this, Xa(n3)));
          }, gn.clone = function() {
            return new z(this);
          }, gn.diff = function(e3, a4, n3) {
            var t3, c2, s2;
            if (!this.isValid()) return NaN;
            if (!(t3 = Ua(e3, this)).isValid()) return NaN;
            switch (c2 = 6e4 * (t3.utcOffset() - this.utcOffset()), a4 = C(a4)) {
              case "year":
                s2 = on(this, t3) / 12;
                break;
              case "month":
                s2 = on(this, t3);
                break;
              case "quarter":
                s2 = on(this, t3) / 3;
                break;
              case "second":
                s2 = (this - t3) / 1e3;
                break;
              case "minute":
                s2 = (this - t3) / 6e4;
                break;
              case "hour":
                s2 = (this - t3) / 36e5;
                break;
              case "day":
                s2 = (this - t3 - c2) / 864e5;
                break;
              case "week":
                s2 = (this - t3 - c2) / 6048e5;
                break;
              default:
                s2 = this - t3;
            }
            return n3 ? s2 : U(s2);
          }, gn.endOf = function(e3) {
            var a4, n3;
            if (void 0 === (e3 = C(e3)) || "millisecond" === e3 || !this.isValid()) return this;
            switch (n3 = this._isUTC ? bn : Ln, e3) {
              case "year":
                a4 = n3(this.year() + 1, 0, 1) - 1;
                break;
              case "quarter":
                a4 = n3(this.year(), this.month() - this.month() % 3 + 3, 1) - 1;
                break;
              case "month":
                a4 = n3(this.year(), this.month() + 1, 1) - 1;
                break;
              case "week":
                a4 = n3(this.year(), this.month(), this.date() - this.weekday() + 7) - 1;
                break;
              case "isoWeek":
                a4 = n3(this.year(), this.month(), this.date() - (this.isoWeekday() - 1) + 7) - 1;
                break;
              case "day":
              case "date":
                a4 = n3(this.year(), this.month(), this.date() + 1) - 1;
                break;
              case "hour":
                a4 = this._d.valueOf(), a4 += mn - pn(a4 + (this._isUTC ? 0 : this.utcOffset() * un), mn) - 1;
                break;
              case "minute":
                a4 = this._d.valueOf(), a4 += un - pn(a4, un) - 1;
                break;
              case "second":
                a4 = this._d.valueOf(), a4 += _n - pn(a4, _n) - 1;
            }
            return this._d.setTime(a4), c.updateOffset(this, true), this;
          }, gn.format = function(e3) {
            e3 || (e3 = this.isUtc() ? c.defaultFormatUtc : c.defaultFormat);
            var a4 = H(this, e3);
            return this.localeData().postformat(a4);
          }, gn.from = function(e3, a4) {
            return this.isValid() && (Y(e3) && e3.isValid() || Xa(e3).isValid()) ? Qa({ to: this, from: e3 }).locale(this.locale()).humanize(!a4) : this.localeData().invalidDate();
          }, gn.fromNow = function(e3) {
            return this.from(Xa(), e3);
          }, gn.to = function(e3, a4) {
            return this.isValid() && (Y(e3) && e3.isValid() || Xa(e3).isValid()) ? Qa({ from: this, to: e3 }).locale(this.locale()).humanize(!a4) : this.localeData().invalidDate();
          }, gn.toNow = function(e3) {
            return this.to(Xa(), e3);
          }, gn.get = function(e3) {
            return W(this[e3 = C(e3)]) ? this[e3]() : this;
          }, gn.invalidAt = function() {
            return p(this).overflow;
          }, gn.isAfter = function(e3, a4) {
            var n3 = Y(e3) ? e3 : Xa(e3);
            return !(!this.isValid() || !n3.isValid()) && ("millisecond" === (a4 = C(a4) || "millisecond") ? this.valueOf() > n3.valueOf() : n3.valueOf() < this.clone().startOf(a4).valueOf());
          }, gn.isBefore = function(e3, a4) {
            var n3 = Y(e3) ? e3 : Xa(e3);
            return !(!this.isValid() || !n3.isValid()) && ("millisecond" === (a4 = C(a4) || "millisecond") ? this.valueOf() < n3.valueOf() : this.clone().endOf(a4).valueOf() < n3.valueOf());
          }, gn.isBetween = function(e3, a4, n3, t3) {
            var c2 = Y(e3) ? e3 : Xa(e3), s2 = Y(a4) ? a4 : Xa(a4);
            return !!(this.isValid() && c2.isValid() && s2.isValid()) && ("(" === (t3 = t3 || "()")[0] ? this.isAfter(c2, n3) : !this.isBefore(c2, n3)) && (")" === t3[1] ? this.isBefore(s2, n3) : !this.isAfter(s2, n3));
          }, gn.isSame = function(e3, a4) {
            var n3, t3 = Y(e3) ? e3 : Xa(e3);
            return !(!this.isValid() || !t3.isValid()) && ("millisecond" === (a4 = C(a4) || "millisecond") ? this.valueOf() === t3.valueOf() : (n3 = t3.valueOf(), this.clone().startOf(a4).valueOf() <= n3 && n3 <= this.clone().endOf(a4).valueOf()));
          }, gn.isSameOrAfter = function(e3, a4) {
            return this.isSame(e3, a4) || this.isAfter(e3, a4);
          }, gn.isSameOrBefore = function(e3, a4) {
            return this.isSame(e3, a4) || this.isBefore(e3, a4);
          }, gn.isValid = function() {
            return L(this);
          }, gn.lang = Mn, gn.locale = rn, gn.localeData = dn, gn.max = Ha, gn.min = Ba, gn.parsingFlags = function() {
            return m({}, p(this));
          }, gn.set = function(e3, a4) {
            if ("object" == typeof e3) {
              var n3, t3 = (function(e4) {
                var a5, n4 = [];
                for (a5 in e4) i(e4, a5) && n4.push({ unit: a5, priority: R[a5] });
                return n4.sort((function(e5, a6) {
                  return e5.priority - a6.priority;
                })), n4;
              })(e3 = x(e3)), c2 = t3.length;
              for (n3 = 0; n3 < c2; n3++) this[t3[n3].unit](e3[t3[n3].unit]);
            } else if (W(this[e3 = C(e3)])) return this[e3](a4);
            return this;
          }, gn.startOf = function(e3) {
            var a4, n3;
            if (void 0 === (e3 = C(e3)) || "millisecond" === e3 || !this.isValid()) return this;
            switch (n3 = this._isUTC ? bn : Ln, e3) {
              case "year":
                a4 = n3(this.year(), 0, 1);
                break;
              case "quarter":
                a4 = n3(this.year(), this.month() - this.month() % 3, 1);
                break;
              case "month":
                a4 = n3(this.year(), this.month(), 1);
                break;
              case "week":
                a4 = n3(this.year(), this.month(), this.date() - this.weekday());
                break;
              case "isoWeek":
                a4 = n3(this.year(), this.month(), this.date() - (this.isoWeekday() - 1));
                break;
              case "day":
              case "date":
                a4 = n3(this.year(), this.month(), this.date());
                break;
              case "hour":
                a4 = this._d.valueOf(), a4 -= pn(a4 + (this._isUTC ? 0 : this.utcOffset() * un), mn);
                break;
              case "minute":
                a4 = this._d.valueOf(), a4 -= pn(a4, un);
                break;
              case "second":
                a4 = this._d.valueOf(), a4 -= pn(a4, _n);
            }
            return this._d.setTime(a4), c.updateOffset(this, true), this;
          }, gn.subtract = tn, gn.toArray = function() {
            var e3 = this;
            return [e3.year(), e3.month(), e3.date(), e3.hour(), e3.minute(), e3.second(), e3.millisecond()];
          }, gn.toObject = function() {
            var e3 = this;
            return { years: e3.year(), months: e3.month(), date: e3.date(), hours: e3.hours(), minutes: e3.minutes(), seconds: e3.seconds(), milliseconds: e3.milliseconds() };
          }, gn.toDate = function() {
            return new Date(this.valueOf());
          }, gn.toISOString = function(e3) {
            if (!this.isValid()) return null;
            var a4 = true !== e3, n3 = a4 ? this.clone().utc() : this;
            return n3.year() < 0 || n3.year() > 9999 ? H(n3, a4 ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ") : W(Date.prototype.toISOString) ? a4 ? this.toDate().toISOString() : new Date(this.valueOf() + 60 * this.utcOffset() * 1e3).toISOString().replace("Z", H(n3, "Z")) : H(n3, a4 ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ");
          }, gn.inspect = function() {
            if (!this.isValid()) return "moment.invalid(/* " + this._i + " */)";
            var e3, a4, n3, t3 = "moment", c2 = "";
            return this.isLocal() || (t3 = 0 === this.utcOffset() ? "moment.utc" : "moment.parseZone", c2 = "Z"), e3 = "[" + t3 + '("]', a4 = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY", "-MM-DD[T]HH:mm:ss.SSS", n3 = c2 + '[")]', this.format(e3 + a4 + "-MM-DD[T]HH:mm:ss.SSS" + n3);
          }, "undefined" != typeof Symbol && null != Symbol.for && (gn[Symbol.for("nodejs.util.inspect.custom")] = function() {
            return "Moment<" + this.format() + ">";
          }), gn.toJSON = function() {
            return this.isValid() ? this.toISOString() : null;
          }, gn.toString = function() {
            return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
          }, gn.unix = function() {
            return Math.floor(this.valueOf() / 1e3);
          }, gn.valueOf = function() {
            return this._d.valueOf() - 6e4 * (this._offset || 0);
          }, gn.creationData = function() {
            return { input: this._i, format: this._f, locale: this._locale, isUTC: this._isUTC, strict: this._strict };
          }, gn.eraName = function() {
            var e3, a4, n3, t3 = this.localeData().eras();
            for (e3 = 0, a4 = t3.length; e3 < a4; ++e3) {
              if (n3 = this.clone().startOf("day").valueOf(), t3[e3].since <= n3 && n3 <= t3[e3].until) return t3[e3].name;
              if (t3[e3].until <= n3 && n3 <= t3[e3].since) return t3[e3].name;
            }
            return "";
          }, gn.eraNarrow = function() {
            var e3, a4, n3, t3 = this.localeData().eras();
            for (e3 = 0, a4 = t3.length; e3 < a4; ++e3) {
              if (n3 = this.clone().startOf("day").valueOf(), t3[e3].since <= n3 && n3 <= t3[e3].until) return t3[e3].narrow;
              if (t3[e3].until <= n3 && n3 <= t3[e3].since) return t3[e3].narrow;
            }
            return "";
          }, gn.eraAbbr = function() {
            var e3, a4, n3, t3 = this.localeData().eras();
            for (e3 = 0, a4 = t3.length; e3 < a4; ++e3) {
              if (n3 = this.clone().startOf("day").valueOf(), t3[e3].since <= n3 && n3 <= t3[e3].until) return t3[e3].abbr;
              if (t3[e3].until <= n3 && n3 <= t3[e3].since) return t3[e3].abbr;
            }
            return "";
          }, gn.eraYear = function() {
            var e3, a4, n3, t3, s2 = this.localeData().eras();
            for (e3 = 0, a4 = s2.length; e3 < a4; ++e3) if (n3 = s2[e3].since <= s2[e3].until ? 1 : -1, t3 = this.clone().startOf("day").valueOf(), s2[e3].since <= t3 && t3 <= s2[e3].until || s2[e3].until <= t3 && t3 <= s2[e3].since) return (this.year() - c(s2[e3].since).year()) * n3 + s2[e3].offset;
            return this.year();
          }, gn.year = xe, gn.isLeapYear = function() {
            return I(this.year());
          }, gn.weekYear = function(e3) {
            return zn.call(this, e3, this.week(), this.weekday(), this.localeData()._week.dow, this.localeData()._week.doy);
          }, gn.isoWeekYear = function(e3) {
            return zn.call(this, e3, this.isoWeek(), this.isoWeekday(), 1, 4);
          }, gn.quarter = gn.quarters = function(e3) {
            return null == e3 ? Math.ceil((this.month() + 1) / 3) : this.month(3 * (e3 - 1) + this.month() % 3);
          }, gn.month = Ee, gn.daysInMonth = function() {
            return qe(this.year(), this.month());
          }, gn.week = gn.weeks = function(e3) {
            var a4 = this.localeData().week(this);
            return null == e3 ? a4 : this.add(7 * (e3 - a4), "d");
          }, gn.isoWeek = gn.isoWeeks = function(e3) {
            var a4 = Je(this, 1, 4).week;
            return null == e3 ? a4 : this.add(7 * (e3 - a4), "d");
          }, gn.weeksInYear = function() {
            var e3 = this.localeData()._week;
            return Ge(this.year(), e3.dow, e3.doy);
          }, gn.weeksInWeekYear = function() {
            var e3 = this.localeData()._week;
            return Ge(this.weekYear(), e3.dow, e3.doy);
          }, gn.isoWeeksInYear = function() {
            return Ge(this.year(), 1, 4);
          }, gn.isoWeeksInISOWeekYear = function() {
            return Ge(this.isoWeekYear(), 1, 4);
          }, gn.date = yn, gn.day = gn.days = function(e3) {
            if (!this.isValid()) return null != e3 ? this : NaN;
            var a4 = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
            return null != e3 ? (e3 = (function(e4, a5) {
              return "string" != typeof e4 ? e4 : isNaN(e4) ? "number" == typeof (e4 = a5.weekdaysParse(e4)) ? e4 : null : parseInt(e4, 10);
            })(e3, this.localeData()), this.add(e3 - a4, "d")) : a4;
          }, gn.weekday = function(e3) {
            if (!this.isValid()) return null != e3 ? this : NaN;
            var a4 = (this.day() + 7 - this.localeData()._week.dow) % 7;
            return null == e3 ? a4 : this.add(e3 - a4, "d");
          }, gn.isoWeekday = function(e3) {
            if (!this.isValid()) return null != e3 ? this : NaN;
            if (null != e3) {
              var a4 = (function(e4, a5) {
                return "string" == typeof e4 ? a5.weekdaysParse(e4) % 7 || 7 : isNaN(e4) ? null : e4;
              })(e3, this.localeData());
              return this.day(this.day() % 7 ? a4 : a4 - 7);
            }
            return this.day() || 7;
          }, gn.dayOfYear = function(e3) {
            var a4 = Math.round((this.clone().startOf("day") - this.clone().startOf("year")) / 864e5) + 1;
            return null == e3 ? a4 : this.add(e3 - a4, "d");
          }, gn.hour = gn.hours = ia, gn.minute = gn.minutes = Tn, gn.second = gn.seconds = kn, gn.millisecond = gn.milliseconds = Dn, gn.utcOffset = function(e3, a4, n3) {
            var t3, s2 = this._offset || 0;
            if (!this.isValid()) return null != e3 ? this : NaN;
            if (null != e3) {
              if ("string" == typeof e3) {
                if (null === (e3 = Ia(ue, e3))) return this;
              } else Math.abs(e3) < 16 && !n3 && (e3 *= 60);
              return !this._isUTC && a4 && (t3 = Ja(this)), this._offset = e3, this._isUTC = true, null != t3 && this.add(t3, "m"), s2 !== e3 && (!a4 || this._changeInProgress ? an(this, Qa(e3 - s2, "m"), 1, false) : this._changeInProgress || (this._changeInProgress = true, c.updateOffset(this, true), this._changeInProgress = null)), this;
            }
            return this._isUTC ? s2 : Ja(this);
          }, gn.utc = function(e3) {
            return this.utcOffset(0, e3);
          }, gn.local = function(e3) {
            return this._isUTC && (this.utcOffset(0, e3), this._isUTC = false, e3 && this.subtract(Ja(this), "m")), this;
          }, gn.parseZone = function() {
            if (null != this._tzm) this.utcOffset(this._tzm, false, true);
            else if ("string" == typeof this._i) {
              var e3 = Ia(_e, this._i);
              null != e3 ? this.utcOffset(e3) : this.utcOffset(0, true);
            }
            return this;
          }, gn.hasAlignedHourOffset = function(e3) {
            return !!this.isValid() && (e3 = e3 ? Xa(e3).utcOffset() : 0, (this.utcOffset() - e3) % 60 == 0);
          }, gn.isDST = function() {
            return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
          }, gn.isLocal = function() {
            return !!this.isValid() && !this._isUTC;
          }, gn.isUtcOffset = function() {
            return !!this.isValid() && this._isUTC;
          }, gn.isUtc = Ga, gn.isUTC = Ga, gn.zoneAbbr = function() {
            return this._isUTC ? "UTC" : "";
          }, gn.zoneName = function() {
            return this._isUTC ? "Coordinated Universal Time" : "";
          }, gn.dates = T("dates accessor is deprecated. Use date instead.", yn), gn.months = T("months accessor is deprecated. Use month instead", Ee), gn.years = T("years accessor is deprecated. Use year instead", xe), gn.zone = T("moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/", (function(e3, a4) {
            return null != e3 ? ("string" != typeof e3 && (e3 = -e3), this.utcOffset(e3, a4), this) : -this.utcOffset();
          })), gn.isDSTShifted = T("isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information", (function() {
            if (!M(this._isDSTShifted)) return this._isDSTShifted;
            var e3, a4 = {};
            return h(a4, this), (a4 = wa(a4))._a ? (e3 = a4._isUTC ? l(a4._a) : Xa(a4._a), this._isDSTShifted = this.isValid() && (function(e4, a5, n3) {
              var t3, c2 = Math.min(e4.length, a5.length), s2 = Math.abs(e4.length - a5.length), o2 = 0;
              for (t3 = 0; t3 < c2; t3++) (n3 && e4[t3] !== a5[t3] || !n3 && J(e4[t3]) !== J(a5[t3])) && o2++;
              return o2 + s2;
            })(a4._a, e3.toArray()) > 0) : this._isDSTShifted = false, this._isDSTShifted;
          }));
          var qn = N.prototype;
          function Sn(e3, a4, n3, t3) {
            var c2 = ba(), s2 = l().set(t3, a4);
            return c2[n3](s2, e3);
          }
          function wn(e3, a4, n3) {
            if (d(e3) && (a4 = e3, e3 = void 0), e3 = e3 || "", null != a4) return Sn(e3, a4, n3, "month");
            var t3, c2 = [];
            for (t3 = 0; t3 < 12; t3++) c2[t3] = Sn(e3, t3, n3, "month");
            return c2;
          }
          function vn(e3, a4, n3, t3) {
            "boolean" == typeof e3 ? (d(a4) && (n3 = a4, a4 = void 0), a4 = a4 || "") : (n3 = a4 = e3, e3 = false, d(a4) && (n3 = a4, a4 = void 0), a4 = a4 || "");
            var c2, s2 = ba(), o2 = e3 ? s2._week.dow : 0, i2 = [];
            if (null != n3) return Sn(a4, (n3 + o2) % 7, t3, "day");
            for (c2 = 0; c2 < 7; c2++) i2[c2] = Sn(a4, (c2 + o2) % 7, t3, "day");
            return i2;
          }
          qn.calendar = function(e3, a4, n3) {
            var t3 = this._calendar[e3] || this._calendar.sameElse;
            return W(t3) ? t3.call(a4, n3) : t3;
          }, qn.longDateFormat = function(e3) {
            var a4 = this._longDateFormat[e3], n3 = this._longDateFormat[e3.toUpperCase()];
            return a4 || !n3 ? a4 : (this._longDateFormat[e3] = n3.match(S).map((function(e4) {
              return "MMMM" === e4 || "MM" === e4 || "DD" === e4 || "dddd" === e4 ? e4.slice(1) : e4;
            })).join(""), this._longDateFormat[e3]);
          }, qn.invalidDate = function() {
            return this._invalidDate;
          }, qn.ordinal = function(e3) {
            return this._ordinal.replace("%d", e3);
          }, qn.preparse = Nn, qn.postformat = Nn, qn.relativeTime = function(e3, a4, n3, t3) {
            var c2 = this._relativeTime[n3];
            return W(c2) ? c2(e3, a4, n3, t3) : c2.replace(/%d/i, e3);
          }, qn.pastFuture = function(e3, a4) {
            var n3 = this._relativeTime[e3 > 0 ? "future" : "past"];
            return W(n3) ? n3(a4) : n3.replace(/%s/i, a4);
          }, qn.set = function(e3) {
            var a4, n3;
            for (n3 in e3) i(e3, n3) && (W(a4 = e3[n3]) ? this[n3] = a4 : this["_" + n3] = a4);
            this._config = e3, this._dayOfMonthOrdinalParseLenient = new RegExp((this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source);
          }, qn.eras = function(e3, a4) {
            var n3, t3, s2, o2 = this._eras || ba("en")._eras;
            for (n3 = 0, t3 = o2.length; n3 < t3; ++n3) switch ("string" == typeof o2[n3].since && (s2 = c(o2[n3].since).startOf("day"), o2[n3].since = s2.valueOf()), typeof o2[n3].until) {
              case "undefined":
                o2[n3].until = 1 / 0;
                break;
              case "string":
                s2 = c(o2[n3].until).startOf("day").valueOf(), o2[n3].until = s2.valueOf();
            }
            return o2;
          }, qn.erasParse = function(e3, a4, n3) {
            var t3, c2, s2, o2, i2, r2 = this.eras();
            for (e3 = e3.toUpperCase(), t3 = 0, c2 = r2.length; t3 < c2; ++t3) if (s2 = r2[t3].name.toUpperCase(), o2 = r2[t3].abbr.toUpperCase(), i2 = r2[t3].narrow.toUpperCase(), n3) switch (a4) {
              case "N":
              case "NN":
              case "NNN":
                if (o2 === e3) return r2[t3];
                break;
              case "NNNN":
                if (s2 === e3) return r2[t3];
                break;
              case "NNNNN":
                if (i2 === e3) return r2[t3];
            }
            else if ([s2, o2, i2].indexOf(e3) >= 0) return r2[t3];
          }, qn.erasConvertYear = function(e3, a4) {
            var n3 = e3.since <= e3.until ? 1 : -1;
            return void 0 === a4 ? c(e3.since).year() : c(e3.since).year() + (a4 - e3.offset) * n3;
          }, qn.erasAbbrRegex = function(e3) {
            return i(this, "_erasAbbrRegex") || fn.call(this), e3 ? this._erasAbbrRegex : this._erasRegex;
          }, qn.erasNameRegex = function(e3) {
            return i(this, "_erasNameRegex") || fn.call(this), e3 ? this._erasNameRegex : this._erasRegex;
          }, qn.erasNarrowRegex = function(e3) {
            return i(this, "_erasNarrowRegex") || fn.call(this), e3 ? this._erasNarrowRegex : this._erasRegex;
          }, qn.months = function(e3, a4) {
            return e3 ? s(this._months) ? this._months[e3.month()] : this._months[(this._months.isFormat || ve).test(a4) ? "format" : "standalone"][e3.month()] : s(this._months) ? this._months : this._months.standalone;
          }, qn.monthsShort = function(e3, a4) {
            return e3 ? s(this._monthsShort) ? this._monthsShort[e3.month()] : this._monthsShort[ve.test(a4) ? "format" : "standalone"][e3.month()] : s(this._monthsShort) ? this._monthsShort : this._monthsShort.standalone;
          }, qn.monthsParse = function(e3, a4, n3) {
            var t3, c2, s2;
            if (this._monthsParseExact) return He.call(this, e3, a4, n3);
            for (this._monthsParse || (this._monthsParse = [], this._longMonthsParse = [], this._shortMonthsParse = []), t3 = 0; t3 < 12; t3++) {
              if (c2 = l([2e3, t3]), n3 && !this._longMonthsParse[t3] && (this._longMonthsParse[t3] = new RegExp("^" + this.months(c2, "").replace(".", "") + "$", "i"), this._shortMonthsParse[t3] = new RegExp("^" + this.monthsShort(c2, "").replace(".", "") + "$", "i")), n3 || this._monthsParse[t3] || (s2 = "^" + this.months(c2, "") + "|^" + this.monthsShort(c2, ""), this._monthsParse[t3] = new RegExp(s2.replace(".", ""), "i")), n3 && "MMMM" === a4 && this._longMonthsParse[t3].test(e3)) return t3;
              if (n3 && "MMM" === a4 && this._shortMonthsParse[t3].test(e3)) return t3;
              if (!n3 && this._monthsParse[t3].test(e3)) return t3;
            }
          }, qn.monthsRegex = function(e3) {
            return this._monthsParseExact ? (i(this, "_monthsRegex") || Pe.call(this), e3 ? this._monthsStrictRegex : this._monthsRegex) : (i(this, "_monthsRegex") || (this._monthsRegex = Be), this._monthsStrictRegex && e3 ? this._monthsStrictRegex : this._monthsRegex);
          }, qn.monthsShortRegex = function(e3) {
            return this._monthsParseExact ? (i(this, "_monthsRegex") || Pe.call(this), e3 ? this._monthsShortStrictRegex : this._monthsShortRegex) : (i(this, "_monthsShortRegex") || (this._monthsShortRegex = Xe), this._monthsShortStrictRegex && e3 ? this._monthsShortStrictRegex : this._monthsShortRegex);
          }, qn.week = function(e3) {
            return Je(e3, this._week.dow, this._week.doy).week;
          }, qn.firstDayOfYear = function() {
            return this._week.doy;
          }, qn.firstDayOfWeek = function() {
            return this._week.dow;
          }, qn.weekdays = function(e3, a4) {
            var n3 = s(this._weekdays) ? this._weekdays : this._weekdays[e3 && true !== e3 && this._weekdays.isFormat.test(a4) ? "format" : "standalone"];
            return true === e3 ? Ke(n3, this._week.dow) : e3 ? n3[e3.day()] : n3;
          }, qn.weekdaysMin = function(e3) {
            return true === e3 ? Ke(this._weekdaysMin, this._week.dow) : e3 ? this._weekdaysMin[e3.day()] : this._weekdaysMin;
          }, qn.weekdaysShort = function(e3) {
            return true === e3 ? Ke(this._weekdaysShort, this._week.dow) : e3 ? this._weekdaysShort[e3.day()] : this._weekdaysShort;
          }, qn.weekdaysParse = function(e3, a4, n3) {
            var t3, c2, s2;
            if (this._weekdaysParseExact) return na.call(this, e3, a4, n3);
            for (this._weekdaysParse || (this._weekdaysParse = [], this._minWeekdaysParse = [], this._shortWeekdaysParse = [], this._fullWeekdaysParse = []), t3 = 0; t3 < 7; t3++) {
              if (c2 = l([2e3, 1]).day(t3), n3 && !this._fullWeekdaysParse[t3] && (this._fullWeekdaysParse[t3] = new RegExp("^" + this.weekdays(c2, "").replace(".", "\\.?") + "$", "i"), this._shortWeekdaysParse[t3] = new RegExp("^" + this.weekdaysShort(c2, "").replace(".", "\\.?") + "$", "i"), this._minWeekdaysParse[t3] = new RegExp("^" + this.weekdaysMin(c2, "").replace(".", "\\.?") + "$", "i")), this._weekdaysParse[t3] || (s2 = "^" + this.weekdays(c2, "") + "|^" + this.weekdaysShort(c2, "") + "|^" + this.weekdaysMin(c2, ""), this._weekdaysParse[t3] = new RegExp(s2.replace(".", ""), "i")), n3 && "dddd" === a4 && this._fullWeekdaysParse[t3].test(e3)) return t3;
              if (n3 && "ddd" === a4 && this._shortWeekdaysParse[t3].test(e3)) return t3;
              if (n3 && "dd" === a4 && this._minWeekdaysParse[t3].test(e3)) return t3;
              if (!n3 && this._weekdaysParse[t3].test(e3)) return t3;
            }
          }, qn.weekdaysRegex = function(e3) {
            return this._weekdaysParseExact ? (i(this, "_weekdaysRegex") || ta.call(this), e3 ? this._weekdaysStrictRegex : this._weekdaysRegex) : (i(this, "_weekdaysRegex") || (this._weekdaysRegex = $e), this._weekdaysStrictRegex && e3 ? this._weekdaysStrictRegex : this._weekdaysRegex);
          }, qn.weekdaysShortRegex = function(e3) {
            return this._weekdaysParseExact ? (i(this, "_weekdaysRegex") || ta.call(this), e3 ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex) : (i(this, "_weekdaysShortRegex") || (this._weekdaysShortRegex = ea), this._weekdaysShortStrictRegex && e3 ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex);
          }, qn.weekdaysMinRegex = function(e3) {
            return this._weekdaysParseExact ? (i(this, "_weekdaysRegex") || ta.call(this), e3 ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex) : (i(this, "_weekdaysMinRegex") || (this._weekdaysMinRegex = aa), this._weekdaysMinStrictRegex && e3 ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex);
          }, qn.isPM = function(e3) {
            return "p" === (e3 + "").toLowerCase().charAt(0);
          }, qn.meridiem = function(e3, a4, n3) {
            return e3 > 11 ? n3 ? "pm" : "PM" : n3 ? "am" : "AM";
          }, pa("en", { eras: [{ since: "0001-01-01", until: 1 / 0, offset: 1, name: "Anno Domini", narrow: "AD", abbr: "AD" }, { since: "0000-12-31", until: -1 / 0, offset: 1, name: "Before Christ", narrow: "BC", abbr: "BC" }], dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/, ordinal: function(e3) {
            var a4 = e3 % 10;
            return e3 + (1 === J(e3 % 100 / 10) ? "th" : 1 === a4 ? "st" : 2 === a4 ? "nd" : 3 === a4 ? "rd" : "th");
          } }), c.lang = T("moment.lang is deprecated. Use moment.locale instead.", pa), c.langData = T("moment.langData is deprecated. Use moment.localeData instead.", ba);
          var Xn = Math.abs;
          function Bn(e3, a4, n3, t3) {
            var c2 = Qa(a4, n3);
            return e3._milliseconds += t3 * c2._milliseconds, e3._days += t3 * c2._days, e3._months += t3 * c2._months, e3._bubble();
          }
          function Hn(e3) {
            return e3 < 0 ? Math.floor(e3) : Math.ceil(e3);
          }
          function jn(e3) {
            return 4800 * e3 / 146097;
          }
          function En(e3) {
            return 146097 * e3 / 4800;
          }
          function Pn(e3) {
            return function() {
              return this.as(e3);
            };
          }
          var Cn = Pn("ms"), xn = Pn("s"), Rn = Pn("m"), Fn = Pn("h"), In = Pn("d"), Un = Pn("w"), Jn = Pn("M"), Gn = Pn("Q"), Kn = Pn("y");
          function Vn(e3) {
            return function() {
              return this.isValid() ? this._data[e3] : NaN;
            };
          }
          var Qn = Vn("milliseconds"), Zn = Vn("seconds"), $n = Vn("minutes"), et = Vn("hours"), at = Vn("days"), nt = Vn("months"), tt = Vn("years");
          var ct = Math.round, st = { ss: 44, s: 45, m: 45, h: 22, d: 26, w: null, M: 11 };
          function ot(e3, a4, n3, t3, c2) {
            return c2.relativeTime(a4 || 1, !!n3, e3, t3);
          }
          var it = Math.abs;
          function rt(e3) {
            return (e3 > 0) - (e3 < 0) || +e3;
          }
          function Mt() {
            if (!this.isValid()) return this.localeData().invalidDate();
            var e3, a4, n3, t3, c2, s2, o2, i2, r2 = it(this._milliseconds) / 1e3, M2 = it(this._days), d2 = it(this._months), _2 = this.asSeconds();
            return _2 ? (e3 = U(r2 / 60), a4 = U(e3 / 60), r2 %= 60, e3 %= 60, n3 = U(d2 / 12), d2 %= 12, t3 = r2 ? r2.toFixed(3).replace(/\.?0+$/, "") : "", c2 = _2 < 0 ? "-" : "", s2 = rt(this._months) !== rt(_2) ? "-" : "", o2 = rt(this._days) !== rt(_2) ? "-" : "", i2 = rt(this._milliseconds) !== rt(_2) ? "-" : "", c2 + "P" + (n3 ? s2 + n3 + "Y" : "") + (d2 ? s2 + d2 + "M" : "") + (M2 ? o2 + M2 + "D" : "") + (a4 || e3 || r2 ? "T" : "") + (a4 ? i2 + a4 + "H" : "") + (e3 ? i2 + e3 + "M" : "") + (r2 ? i2 + t3 + "S" : "")) : "P0D";
          }
          var dt = Pa.prototype;
          return dt.isValid = function() {
            return this._isValid;
          }, dt.abs = function() {
            var e3 = this._data;
            return this._milliseconds = Xn(this._milliseconds), this._days = Xn(this._days), this._months = Xn(this._months), e3.milliseconds = Xn(e3.milliseconds), e3.seconds = Xn(e3.seconds), e3.minutes = Xn(e3.minutes), e3.hours = Xn(e3.hours), e3.months = Xn(e3.months), e3.years = Xn(e3.years), this;
          }, dt.add = function(e3, a4) {
            return Bn(this, e3, a4, 1);
          }, dt.subtract = function(e3, a4) {
            return Bn(this, e3, a4, -1);
          }, dt.as = function(e3) {
            if (!this.isValid()) return NaN;
            var a4, n3, t3 = this._milliseconds;
            if ("month" === (e3 = C(e3)) || "quarter" === e3 || "year" === e3) switch (a4 = this._days + t3 / 864e5, n3 = this._months + jn(a4), e3) {
              case "month":
                return n3;
              case "quarter":
                return n3 / 3;
              case "year":
                return n3 / 12;
            }
            else switch (a4 = this._days + Math.round(En(this._months)), e3) {
              case "week":
                return a4 / 7 + t3 / 6048e5;
              case "day":
                return a4 + t3 / 864e5;
              case "hour":
                return 24 * a4 + t3 / 36e5;
              case "minute":
                return 1440 * a4 + t3 / 6e4;
              case "second":
                return 86400 * a4 + t3 / 1e3;
              case "millisecond":
                return Math.floor(864e5 * a4) + t3;
              default:
                throw new Error("Unknown unit " + e3);
            }
          }, dt.asMilliseconds = Cn, dt.asSeconds = xn, dt.asMinutes = Rn, dt.asHours = Fn, dt.asDays = In, dt.asWeeks = Un, dt.asMonths = Jn, dt.asQuarters = Gn, dt.asYears = Kn, dt.valueOf = function() {
            return this.isValid() ? this._milliseconds + 864e5 * this._days + this._months % 12 * 2592e6 + 31536e6 * J(this._months / 12) : NaN;
          }, dt._bubble = function() {
            var e3, a4, n3, t3, c2, s2 = this._milliseconds, o2 = this._days, i2 = this._months, r2 = this._data;
            return s2 >= 0 && o2 >= 0 && i2 >= 0 || s2 <= 0 && o2 <= 0 && i2 <= 0 || (s2 += 864e5 * Hn(En(i2) + o2), o2 = 0, i2 = 0), r2.milliseconds = s2 % 1e3, e3 = U(s2 / 1e3), r2.seconds = e3 % 60, a4 = U(e3 / 60), r2.minutes = a4 % 60, n3 = U(a4 / 60), r2.hours = n3 % 24, o2 += U(n3 / 24), i2 += c2 = U(jn(o2)), o2 -= Hn(En(c2)), t3 = U(i2 / 12), i2 %= 12, r2.days = o2, r2.months = i2, r2.years = t3, this;
          }, dt.clone = function() {
            return Qa(this);
          }, dt.get = function(e3) {
            return e3 = C(e3), this.isValid() ? this[e3 + "s"]() : NaN;
          }, dt.milliseconds = Qn, dt.seconds = Zn, dt.minutes = $n, dt.hours = et, dt.days = at, dt.weeks = function() {
            return U(this.days() / 7);
          }, dt.months = nt, dt.years = tt, dt.humanize = function(e3, a4) {
            if (!this.isValid()) return this.localeData().invalidDate();
            var n3, t3, c2 = false, s2 = st;
            return "object" == typeof e3 && (a4 = e3, e3 = false), "boolean" == typeof e3 && (c2 = e3), "object" == typeof a4 && (s2 = Object.assign({}, st, a4), null != a4.s && null == a4.ss && (s2.ss = a4.s - 1)), t3 = (function(e4, a5, n4, t4) {
              var c3 = Qa(e4).abs(), s3 = ct(c3.as("s")), o2 = ct(c3.as("m")), i2 = ct(c3.as("h")), r2 = ct(c3.as("d")), M2 = ct(c3.as("M")), d2 = ct(c3.as("w")), _2 = ct(c3.as("y")), u2 = s3 <= n4.ss && ["s", s3] || s3 < n4.s && ["ss", s3] || o2 <= 1 && ["m"] || o2 < n4.m && ["mm", o2] || i2 <= 1 && ["h"] || i2 < n4.h && ["hh", i2] || r2 <= 1 && ["d"] || r2 < n4.d && ["dd", r2];
              return null != n4.w && (u2 = u2 || d2 <= 1 && ["w"] || d2 < n4.w && ["ww", d2]), (u2 = u2 || M2 <= 1 && ["M"] || M2 < n4.M && ["MM", M2] || _2 <= 1 && ["y"] || ["yy", _2])[2] = a5, u2[3] = +e4 > 0, u2[4] = t4, ot.apply(null, u2);
            })(this, !c2, s2, n3 = this.localeData()), c2 && (t3 = n3.pastFuture(+this, t3)), n3.postformat(t3);
          }, dt.toISOString = Mt, dt.toString = Mt, dt.toJSON = Mt, dt.locale = rn, dt.localeData = dn, dt.toIsoString = T("toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)", Mt), dt.lang = Mn, B("X", 0, 0, "unix"), B("x", 0, 0, "valueOf"), le("x", de), le("X", /[+-]?\d+(\.\d{1,3})?/), Ae("X", (function(e3, a4, n3) {
            n3._d = new Date(1e3 * parseFloat(e3));
          })), Ae("x", (function(e3, a4, n3) {
            n3._d = new Date(J(e3));
          })), c.version = "2.29.4", a3 = Xa, c.fn = gn, c.min = function() {
            return ja("isBefore", [].slice.call(arguments, 0));
          }, c.max = function() {
            return ja("isAfter", [].slice.call(arguments, 0));
          }, c.now = function() {
            return Date.now ? Date.now() : +/* @__PURE__ */ new Date();
          }, c.utc = l, c.unix = function(e3) {
            return Xa(1e3 * e3);
          }, c.months = function(e3, a4) {
            return wn(e3, a4, "months");
          }, c.isDate = _, c.locale = pa, c.invalid = b, c.duration = Qa, c.isMoment = Y, c.weekdays = function(e3, a4, n3) {
            return vn(e3, a4, n3, "weekdays");
          }, c.parseZone = function() {
            return Xa.apply(null, arguments).parseZone();
          }, c.localeData = ba, c.isDuration = Ca, c.monthsShort = function(e3, a4) {
            return wn(e3, a4, "monthsShort");
          }, c.weekdaysMin = function(e3, a4, n3) {
            return vn(e3, a4, n3, "weekdaysMin");
          }, c.defineLocale = La, c.updateLocale = function(e3, a4) {
            if (null != a4) {
              var n3, t3, c2 = Ma;
              null != da[e3] && null != da[e3].parentLocale ? da[e3].set(g(da[e3]._config, a4)) : (null != (t3 = la(e3)) && (c2 = t3._config), a4 = g(c2, a4), null == t3 && (a4.abbr = e3), (n3 = new N(a4)).parentLocale = da[e3], da[e3] = n3), pa(e3);
            } else null != da[e3] && (null != da[e3].parentLocale ? (da[e3] = da[e3].parentLocale, e3 === pa() && pa(e3)) : null != da[e3] && delete da[e3]);
            return da[e3];
          }, c.locales = function() {
            return O(da);
          }, c.weekdaysShort = function(e3, a4, n3) {
            return vn(e3, a4, n3, "weekdaysShort");
          }, c.normalizeUnits = C, c.relativeTimeRounding = function(e3) {
            return void 0 === e3 ? ct : "function" == typeof e3 && (ct = e3, true);
          }, c.relativeTimeThreshold = function(e3, a4) {
            return void 0 !== st[e3] && (void 0 === a4 ? st[e3] : (st[e3] = a4, "s" === e3 && (st.ss = a4 - 1), true));
          }, c.calendarFormat = function(e3, a4) {
            var n3 = e3.diff(a4, "days", true);
            return n3 < -6 ? "sameElse" : n3 < -1 ? "lastWeek" : n3 < 0 ? "lastDay" : n3 < 1 ? "sameDay" : n3 < 2 ? "nextDay" : n3 < 7 ? "nextWeek" : "sameElse";
          }, c.prototype = gn, c.HTML5_FMT = { DATETIME_LOCAL: "YYYY-MM-DDTHH:mm", DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss", DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS", DATE: "YYYY-MM-DD", TIME: "HH:mm", TIME_SECONDS: "HH:mm:ss", TIME_MS: "HH:mm:ss.SSS", WEEK: "GGGG-[W]WW", MONTH: "YYYY-MM" }, c;
        })();
      }, 1175: (e2) => {
        "use strict";
        e2.exports = JSON.parse('{"version":"2019c","zones":["Africa/Abidjan|LMT GMT|g.8 0|01|-2ldXH.Q|48e5","Africa/Accra|LMT GMT +0020|.Q 0 -k|012121212121212121212121212121212121212121212121|-26BbX.8 6tzX.8 MnE 1BAk MnE 1BAk MnE 1BAk MnE 1C0k MnE 1BAk MnE 1BAk MnE 1BAk MnE 1C0k MnE 1BAk MnE 1BAk MnE 1BAk MnE 1C0k MnE 1BAk MnE 1BAk MnE 1BAk MnE 1C0k MnE 1BAk MnE 1BAk MnE 1BAk MnE 1C0k MnE 1BAk MnE 1BAk MnE|41e5","Africa/Nairobi|LMT EAT +0230 +0245|-2r.g -30 -2u -2J|01231|-1F3Cr.g 3Dzr.g okMu MFXJ|47e5","Africa/Algiers|PMT WET WEST CET CEST|-9.l 0 -10 -10 -20|0121212121212121343431312123431213|-2nco9.l cNb9.l HA0 19A0 1iM0 11c0 1oo0 Wo0 1rc0 QM0 1EM0 UM0 DA0 Imo0 rd0 De0 9Xz0 1fb0 1ap0 16K0 2yo0 mEp0 hwL0 jxA0 11A0 dDd0 17b0 11B0 1cN0 2Dy0 1cN0 1fB0 1cL0|26e5","Africa/Lagos|LMT WAT|-d.A -10|01|-22y0d.A|17e6","Africa/Bissau|LMT -01 GMT|12.k 10 0|012|-2ldX0 2xoo0|39e4","Africa/Maputo|LMT CAT|-2a.k -20|01|-2GJea.k|26e5","Africa/Cairo|EET EEST|-20 -30|0101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010|-1bIO0 vb0 1ip0 11z0 1iN0 1nz0 12p0 1pz0 10N0 1pz0 16p0 1jz0 s3d0 Vz0 1oN0 11b0 1oO0 10N0 1pz0 10N0 1pb0 10N0 1pb0 10N0 1pb0 10N0 1pz0 10N0 1pb0 10N0 1pb0 11d0 1oL0 11d0 1pb0 11d0 1oL0 11d0 1oL0 11d0 1oL0 11d0 1pb0 11d0 1oL0 11d0 1oL0 11d0 1oL0 11d0 1pb0 11d0 1oL0 11d0 1oL0 11d0 1oL0 11d0 1pb0 11d0 1oL0 11d0 1WL0 rd0 1Rz0 wp0 1pb0 11d0 1oL0 11d0 1oL0 11d0 1oL0 11d0 1pb0 11d0 1qL0 Xd0 1oL0 11d0 1oL0 11d0 1pb0 11d0 1oL0 11d0 1oL0 11d0 1ny0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 11z0 1o10 11z0 1o10 WL0 1qN0 Rb0 1wp0 On0 1zd0 Lz0 1EN0 Fb0 c10 8n0 8Nd0 gL0 e10 mn0|15e6","Africa/Casablanca|LMT +00 +01|u.k 0 -10|01212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212|-2gMnt.E 130Lt.E rb0 Dd0 dVb0 b6p0 TX0 EoB0 LL0 gnd0 rz0 43d0 AL0 1Nd0 XX0 1Cp0 pz0 dEp0 4mn0 SyN0 AL0 1Nd0 wn0 1FB0 Db0 1zd0 Lz0 1Nf0 wM0 co0 go0 1o00 s00 dA0 vc0 11A0 A00 e00 y00 11A0 uM0 e00 Dc0 11A0 s00 e00 IM0 WM0 mo0 gM0 LA0 WM0 jA0 e00 28M0 e00 2600 e00 28M0 e00 2600 gM0 2600 e00 28M0 e00 2600 gM0 2600 e00 28M0 e00 2600 e00 28M0 e00 2600 gM0 2600 e00 28M0 e00 2600 gM0 2600 e00 2600 gM0 2600 e00 28M0 e00 2600 gM0|32e5","Africa/Ceuta|WET WEST CET CEST|0 -10 -10 -20|010101010101010101010232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232|-25KN0 11z0 drd0 18p0 3HX0 17d0 1fz0 1a10 1io0 1a00 1y7o0 LL0 gnd0 rz0 43d0 AL0 1Nd0 XX0 1Cp0 pz0 dEp0 4VB0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|85e3","Africa/El_Aaiun|LMT -01 +00 +01|Q.M 10 0 -10|012323232323232323232323232323232323232323232323232323232323232323232323232323232323|-1rDz7.c 1GVA7.c 6L0 AL0 1Nd0 XX0 1Cp0 pz0 1cBB0 AL0 1Nd0 wn0 1FB0 Db0 1zd0 Lz0 1Nf0 wM0 co0 go0 1o00 s00 dA0 vc0 11A0 A00 e00 y00 11A0 uM0 e00 Dc0 11A0 s00 e00 IM0 WM0 mo0 gM0 LA0 WM0 jA0 e00 28M0 e00 2600 e00 28M0 e00 2600 gM0 2600 e00 28M0 e00 2600 gM0 2600 e00 28M0 e00 2600 e00 28M0 e00 2600 gM0 2600 e00 28M0 e00 2600 gM0 2600 e00 2600 gM0 2600 e00 28M0 e00 2600 gM0|20e4","Africa/Johannesburg|SAST SAST SAST|-1u -20 -30|012121|-2GJdu 1Ajdu 1cL0 1cN0 1cL0|84e5","Africa/Juba|LMT CAT CAST EAT|-26.s -20 -30 -30|01212121212121212121212121212121213|-1yW26.s 1zK06.s 16L0 1iN0 17b0 1jd0 17b0 1ip0 17z0 1i10 17X0 1hB0 18n0 1hd0 19b0 1gp0 19z0 1iN0 17b0 1ip0 17z0 1i10 18n0 1hd0 18L0 1gN0 19b0 1gp0 19z0 1iN0 17z0 1i10 17X0 yGd0|","Africa/Khartoum|LMT CAT CAST EAT|-2a.8 -20 -30 -30|012121212121212121212121212121212131|-1yW2a.8 1zK0a.8 16L0 1iN0 17b0 1jd0 17b0 1ip0 17z0 1i10 17X0 1hB0 18n0 1hd0 19b0 1gp0 19z0 1iN0 17b0 1ip0 17z0 1i10 18n0 1hd0 18L0 1gN0 19b0 1gp0 19z0 1iN0 17z0 1i10 17X0 yGd0 HjL0|51e5","Africa/Monrovia|MMT MMT GMT|H.8 I.u 0|012|-23Lzg.Q 28G01.m|11e5","Africa/Ndjamena|LMT WAT WAST|-10.c -10 -20|0121|-2le10.c 2J3c0.c Wn0|13e5","Africa/Sao_Tome|LMT GMT WAT|A.J 0 -10|0121|-2le00 4i6N0 2q00|","Africa/Tripoli|LMT CET CEST EET|-Q.I -10 -20 -20|012121213121212121212121213123123|-21JcQ.I 1hnBQ.I vx0 4iP0 xx0 4eN0 Bb0 7ip0 U0n0 A10 1db0 1cN0 1db0 1dd0 1db0 1eN0 1bb0 1e10 1cL0 1c10 1db0 1dd0 1db0 1cN0 1db0 1q10 fAn0 1ep0 1db0 AKq0 TA0 1o00|11e5","Africa/Tunis|PMT CET CEST|-9.l -10 -20|0121212121212121212121212121212121|-2nco9.l 18pa9.l 1qM0 DA0 3Tc0 11B0 1ze0 WM0 7z0 3d0 14L0 1cN0 1f90 1ar0 16J0 1gXB0 WM0 1rA0 11c0 nwo0 Ko0 1cM0 1cM0 1rA0 10M0 zuM0 10N0 1aN0 1qM0 WM0 1qM0 11A0 1o00|20e5","Africa/Windhoek|+0130 SAST SAST CAT WAT|-1u -20 -30 -20 -10|01213434343434343434343434343434343434343434343434343|-2GJdu 1Ajdu 1cL0 1SqL0 9Io0 16P0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0|32e4","America/Adak|NST NWT NPT BST BDT AHST HST HDT|b0 a0 a0 b0 a0 a0 a0 90|012034343434343434343434343434343456767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676|-17SX0 8wW0 iB0 Qlb0 52O0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 s10 1Vz0 LB0 1BX0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 cm0 10q0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|326","America/Anchorage|AST AWT APT AHST AHDT YST AKST AKDT|a0 90 90 a0 90 90 90 80|012034343434343434343434343434343456767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676|-17T00 8wX0 iA0 Qlb0 52O0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 s10 1Vz0 LB0 1BX0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 cm0 10q0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|30e4","America/Port_of_Spain|LMT AST|46.4 40|01|-2kNvR.U|43e3","America/Araguaina|LMT -03 -02|3c.M 30 20|0121212121212121212121212121212121212121212121212121|-2glwL.c HdKL.c 1cc0 1e10 1bX0 Ezd0 So0 1vA0 Mn0 1BB0 ML0 1BB0 zX0 qe10 xb0 2ep0 nz0 1C10 zX0 1C10 LX0 1C10 Mn0 H210 Rb0 1tB0 IL0 1Fd0 FX0 1EN0 FX0 1HB0 Lz0 dMN0 Lz0 1zd0 Rb0 1wN0 Wn0 1tB0 Rb0 1tB0 WL0 1tB0 Rb0 1zd0 On0 1HB0 FX0 ny10 Lz0|14e4","America/Argentina/Buenos_Aires|CMT -04 -03 -02|4g.M 40 30 20|01212121212121212121212121212121212121212123232323232323232|-20UHH.c pKnH.c Mn0 1iN0 Tb0 1C10 LX0 1C10 LX0 1C10 LX0 1C10 Mn0 1C10 LX0 1C10 LX0 1C10 LX0 1C10 Mn0 MN0 2jz0 MN0 4lX0 u10 5Lb0 1pB0 Fnz0 u10 uL0 1vd0 SL0 1vd0 SL0 1vd0 17z0 1cN0 1fz0 1cN0 1cL0 1cN0 asn0 Db0 zvd0 Bz0 1tB0 TX0 1wp0 Rb0 1wp0 Rb0 1wp0 TX0 A4p0 uL0 1qN0 WL0|","America/Argentina/Catamarca|CMT -04 -03 -02|4g.M 40 30 20|01212121212121212121212121212121212121212123232323132321232|-20UHH.c pKnH.c Mn0 1iN0 Tb0 1C10 LX0 1C10 LX0 1C10 LX0 1C10 Mn0 1C10 LX0 1C10 LX0 1C10 LX0 1C10 Mn0 MN0 2jz0 MN0 4lX0 u10 5Lb0 1pB0 Fnz0 u10 uL0 1vd0 SL0 1vd0 SL0 1vd0 17z0 1cN0 1fz0 1cN0 1cL0 1cN0 asn0 Db0 zvd0 Bz0 1tB0 TX0 1wp0 Rb0 1wq0 Ra0 1wp0 TX0 rlB0 7B0 8zb0 uL0|","America/Argentina/Cordoba|CMT -04 -03 -02|4g.M 40 30 20|01212121212121212121212121212121212121212123232323132323232|-20UHH.c pKnH.c Mn0 1iN0 Tb0 1C10 LX0 1C10 LX0 1C10 LX0 1C10 Mn0 1C10 LX0 1C10 LX0 1C10 LX0 1C10 Mn0 MN0 2jz0 MN0 4lX0 u10 5Lb0 1pB0 Fnz0 u10 uL0 1vd0 SL0 1vd0 SL0 1vd0 17z0 1cN0 1fz0 1cN0 1cL0 1cN0 asn0 Db0 zvd0 Bz0 1tB0 TX0 1wp0 Rb0 1wq0 Ra0 1wp0 TX0 A4p0 uL0 1qN0 WL0|","America/Argentina/Jujuy|CMT -04 -03 -02|4g.M 40 30 20|012121212121212121212121212121212121212121232323121323232|-20UHH.c pKnH.c Mn0 1iN0 Tb0 1C10 LX0 1C10 LX0 1C10 LX0 1C10 Mn0 1C10 LX0 1C10 LX0 1C10 LX0 1C10 Mn0 MN0 2jz0 MN0 4lX0 u10 5Lb0 1pB0 Fnz0 u10 uL0 1vd0 SL0 1vd0 SL0 1vd0 17z0 1cN0 1fz0 1cN0 1cL0 1cN0 asn0 Db0 zvd0 Bz0 1tB0 TX0 1ze0 TX0 1ld0 WK0 1wp0 TX0 A4p0 uL0|","America/Argentina/La_Rioja|CMT -04 -03 -02|4g.M 40 30 20|012121212121212121212121212121212121212121232323231232321232|-20UHH.c pKnH.c Mn0 1iN0 Tb0 1C10 LX0 1C10 LX0 1C10 LX0 1C10 Mn0 1C10 LX0 1C10 LX0 1C10 LX0 1C10 Mn0 MN0 2jz0 MN0 4lX0 u10 5Lb0 1pB0 Fnz0 u10 uL0 1vd0 SL0 1vd0 SL0 1vd0 17z0 1cN0 1fz0 1cN0 1cL0 1cN0 asn0 Db0 zvd0 Bz0 1tB0 TX0 1wp0 Qn0 qO0 16n0 Rb0 1wp0 TX0 rlB0 7B0 8zb0 uL0|","America/Argentina/Mendoza|CMT -04 -03 -02|4g.M 40 30 20|01212121212121212121212121212121212121212123232312121321232|-20UHH.c pKnH.c Mn0 1iN0 Tb0 1C10 LX0 1C10 LX0 1C10 LX0 1C10 Mn0 1C10 LX0 1C10 LX0 1C10 LX0 1C10 Mn0 MN0 2jz0 MN0 4lX0 u10 5Lb0 1pB0 Fnz0 u10 uL0 1vd0 SL0 1vd0 SL0 1vd0 17z0 1cN0 1fz0 1cN0 1cL0 1cN0 asn0 Db0 zvd0 Bz0 1tB0 TX0 1u20 SL0 1vd0 Tb0 1wp0 TW0 ri10 Op0 7TX0 uL0|","America/Argentina/Rio_Gallegos|CMT -04 -03 -02|4g.M 40 30 20|01212121212121212121212121212121212121212123232323232321232|-20UHH.c pKnH.c Mn0 1iN0 Tb0 1C10 LX0 1C10 LX0 1C10 LX0 1C10 Mn0 1C10 LX0 1C10 LX0 1C10 LX0 1C10 Mn0 MN0 2jz0 MN0 4lX0 u10 5Lb0 1pB0 Fnz0 u10 uL0 1vd0 SL0 1vd0 SL0 1vd0 17z0 1cN0 1fz0 1cN0 1cL0 1cN0 asn0 Db0 zvd0 Bz0 1tB0 TX0 1wp0 Rb0 1wp0 Rb0 1wp0 TX0 rlB0 7B0 8zb0 uL0|","America/Argentina/Salta|CMT -04 -03 -02|4g.M 40 30 20|012121212121212121212121212121212121212121232323231323232|-20UHH.c pKnH.c Mn0 1iN0 Tb0 1C10 LX0 1C10 LX0 1C10 LX0 1C10 Mn0 1C10 LX0 1C10 LX0 1C10 LX0 1C10 Mn0 MN0 2jz0 MN0 4lX0 u10 5Lb0 1pB0 Fnz0 u10 uL0 1vd0 SL0 1vd0 SL0 1vd0 17z0 1cN0 1fz0 1cN0 1cL0 1cN0 asn0 Db0 zvd0 Bz0 1tB0 TX0 1wp0 Rb0 1wq0 Ra0 1wp0 TX0 A4p0 uL0|","America/Argentina/San_Juan|CMT -04 -03 -02|4g.M 40 30 20|012121212121212121212121212121212121212121232323231232321232|-20UHH.c pKnH.c Mn0 1iN0 Tb0 1C10 LX0 1C10 LX0 1C10 LX0 1C10 Mn0 1C10 LX0 1C10 LX0 1C10 LX0 1C10 Mn0 MN0 2jz0 MN0 4lX0 u10 5Lb0 1pB0 Fnz0 u10 uL0 1vd0 SL0 1vd0 SL0 1vd0 17z0 1cN0 1fz0 1cN0 1cL0 1cN0 asn0 Db0 zvd0 Bz0 1tB0 TX0 1wp0 Qn0 qO0 16n0 Rb0 1wp0 TX0 rld0 m10 8lb0 uL0|","America/Argentina/San_Luis|CMT -04 -03 -02|4g.M 40 30 20|012121212121212121212121212121212121212121232323121212321212|-20UHH.c pKnH.c Mn0 1iN0 Tb0 1C10 LX0 1C10 LX0 1C10 LX0 1C10 Mn0 1C10 LX0 1C10 LX0 1C10 LX0 1C10 Mn0 MN0 2jz0 MN0 4lX0 u10 5Lb0 1pB0 Fnz0 u10 uL0 1vd0 SL0 1vd0 SL0 1vd0 17z0 1cN0 1fz0 1cN0 1cL0 1cN0 asn0 Db0 zvd0 Bz0 1tB0 XX0 1q20 SL0 AN0 vDb0 m10 8lb0 8L0 jd0 1qN0 WL0 1qN0|","America/Argentina/Tucuman|CMT -04 -03 -02|4g.M 40 30 20|0121212121212121212121212121212121212121212323232313232123232|-20UHH.c pKnH.c Mn0 1iN0 Tb0 1C10 LX0 1C10 LX0 1C10 LX0 1C10 Mn0 1C10 LX0 1C10 LX0 1C10 LX0 1C10 Mn0 MN0 2jz0 MN0 4lX0 u10 5Lb0 1pB0 Fnz0 u10 uL0 1vd0 SL0 1vd0 SL0 1vd0 17z0 1cN0 1fz0 1cN0 1cL0 1cN0 asn0 Db0 zvd0 Bz0 1tB0 TX0 1wp0 Rb0 1wq0 Ra0 1wp0 TX0 rlB0 4N0 8BX0 uL0 1qN0 WL0|","America/Argentina/Ushuaia|CMT -04 -03 -02|4g.M 40 30 20|01212121212121212121212121212121212121212123232323232321232|-20UHH.c pKnH.c Mn0 1iN0 Tb0 1C10 LX0 1C10 LX0 1C10 LX0 1C10 Mn0 1C10 LX0 1C10 LX0 1C10 LX0 1C10 Mn0 MN0 2jz0 MN0 4lX0 u10 5Lb0 1pB0 Fnz0 u10 uL0 1vd0 SL0 1vd0 SL0 1vd0 17z0 1cN0 1fz0 1cN0 1cL0 1cN0 asn0 Db0 zvd0 Bz0 1tB0 TX0 1wp0 Rb0 1wp0 Rb0 1wp0 TX0 rkN0 8p0 8zb0 uL0|","America/Curacao|LMT -0430 AST|4z.L 4u 40|012|-2kV7o.d 28KLS.d|15e4","America/Asuncion|AMT -04 -03|3O.E 40 30|012121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212|-1x589.k 1DKM9.k 3CL0 3Dd0 10L0 1pB0 10n0 1pB0 10n0 1pB0 1cL0 1dd0 1db0 1dd0 1cL0 1dd0 1cL0 1dd0 1cL0 1dd0 1db0 1dd0 1cL0 1dd0 1cL0 1dd0 1cL0 1dd0 1db0 1dd0 1cL0 1lB0 14n0 1dd0 1cL0 1fd0 WL0 1rd0 1aL0 1dB0 Xz0 1qp0 Xb0 1qN0 10L0 1rB0 TX0 1tB0 WL0 1qN0 11z0 1o10 11z0 1o10 11z0 1qN0 1cL0 WN0 1qL0 11B0 1nX0 1ip0 WL0 1qN0 WL0 1qN0 WL0 1tB0 TX0 1tB0 TX0 1tB0 19X0 1a10 1fz0 1a10 1fz0 1cN0 17b0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1fB0 19X0 1fB0 19X0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1fB0 19X0 1fB0 19X0 1fB0 19X0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1fB0 19X0 1fB0 19X0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1fB0 19X0 1fB0 19X0 1fB0 19X0 1ip0 17b0 1ip0 17b0 1ip0|28e5","America/Atikokan|CST CDT CWT CPT EST|60 50 50 50 50|0101234|-25TQ0 1in0 Rnb0 3je0 8x30 iw0|28e2","America/Bahia_Banderas|LMT MST CST PST MDT CDT|71 70 60 80 60 50|0121212131414141414141414141414141414152525252525252525252525252525252525252525252525252525252|-1UQF0 deL0 8lc0 17c0 10M0 1dd0 otX0 gmN0 P2N0 13Vd0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 1fB0 WL0 1fB0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nW0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0|84e3","America/Bahia|LMT -03 -02|2y.4 30 20|01212121212121212121212121212121212121212121212121212121212121|-2glxp.U HdLp.U 1cc0 1e10 1bX0 Ezd0 So0 1vA0 Mn0 1BB0 ML0 1BB0 zX0 qe10 xb0 2ep0 nz0 1C10 zX0 1C10 LX0 1C10 Mn0 H210 Rb0 1tB0 IL0 1Fd0 FX0 1EN0 FX0 1HB0 Lz0 1EN0 Lz0 1C10 IL0 1HB0 Db0 1HB0 On0 1zd0 On0 1zd0 Lz0 1zd0 Rb0 1wN0 Wn0 1tB0 Rb0 1tB0 WL0 1tB0 Rb0 1zd0 On0 1HB0 FX0 l5B0 Rb0|27e5","America/Barbados|LMT BMT AST ADT|3W.t 3W.t 40 30|01232323232|-1Q0I1.v jsM0 1ODC1.v IL0 1ip0 17b0 1ip0 17b0 1ld0 13b0|28e4","America/Belem|LMT -03 -02|3d.U 30 20|012121212121212121212121212121|-2glwK.4 HdKK.4 1cc0 1e10 1bX0 Ezd0 So0 1vA0 Mn0 1BB0 ML0 1BB0 zX0 qe10 xb0 2ep0 nz0 1C10 zX0 1C10 LX0 1C10 Mn0 H210 Rb0 1tB0 IL0 1Fd0 FX0|20e5","America/Belize|LMT CST -0530 CDT|5Q.M 60 5u 50|01212121212121212121212121212121212121212121212121213131|-2kBu7.c fPA7.c Onu 1zcu Rbu 1wou Rbu 1wou Rbu 1zcu Onu 1zcu Onu 1zcu Rbu 1wou Rbu 1wou Rbu 1wou Rbu 1zcu Onu 1zcu Onu 1zcu Rbu 1wou Rbu 1wou Rbu 1zcu Onu 1zcu Onu 1zcu Onu 1zcu Rbu 1wou Rbu 1wou Rbu 1zcu Onu 1zcu Onu 1zcu Rbu 1wou Rbu 1f0Mu qn0 lxB0 mn0|57e3","America/Blanc-Sablon|AST ADT AWT APT|40 30 30 30|010230|-25TS0 1in0 UGp0 8x50 iu0|11e2","America/Boa_Vista|LMT -04 -03|42.E 40 30|0121212121212121212121212121212121|-2glvV.k HdKV.k 1cc0 1e10 1bX0 Ezd0 So0 1vA0 Mn0 1BB0 ML0 1BB0 zX0 qe10 xb0 2ep0 nz0 1C10 zX0 1C10 LX0 1C10 Mn0 H210 Rb0 1tB0 IL0 1Fd0 FX0 smp0 WL0 1tB0 2L0|62e2","America/Bogota|BMT -05 -04|4U.g 50 40|0121|-2eb73.I 38yo3.I 2en0|90e5","America/Boise|PST PDT MST MWT MPT MDT|80 70 70 60 60 60|0101023425252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252|-261q0 1nX0 11B0 1nX0 8C10 JCL0 8x20 ix0 QwN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 Dd0 1Kn0 LB0 1BX0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|21e4","America/Cambridge_Bay|-00 MST MWT MPT MDDT MDT CST CDT EST|0 70 60 60 50 60 60 50 50|0123141515151515151515151515151515151515151515678651515151515151515151515151515151515151515151515151515151515151515151515151|-21Jc0 RO90 8x20 ix0 LCL0 1fA0 zgO0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11A0 1nX0 2K0 WQ0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|15e2","America/Campo_Grande|LMT -04 -03|3C.s 40 30|01212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-2glwl.w HdLl.w 1cc0 1e10 1bX0 Ezd0 So0 1vA0 Mn0 1BB0 ML0 1BB0 zX0 qe10 xb0 2ep0 nz0 1C10 zX0 1C10 LX0 1C10 Mn0 H210 Rb0 1tB0 IL0 1Fd0 FX0 1EN0 FX0 1HB0 Lz0 1EN0 Lz0 1C10 IL0 1HB0 Db0 1HB0 On0 1zd0 On0 1zd0 Lz0 1zd0 Rb0 1wN0 Wn0 1tB0 Rb0 1tB0 WL0 1tB0 Rb0 1zd0 On0 1HB0 FX0 1C10 Lz0 1Ip0 HX0 1zd0 On0 1HB0 IL0 1wp0 On0 1C10 Lz0 1C10 On0 1zd0 On0 1zd0 Rb0 1zd0 Lz0 1C10 Lz0 1C10 On0 1zd0 On0 1zd0 On0 1zd0 On0 1HB0 FX0|77e4","America/Cancun|LMT CST EST EDT CDT|5L.4 60 50 40 50|0123232341414141414141414141414141414141412|-1UQG0 2q2o0 yLB0 1lb0 14p0 1lb0 14p0 Lz0 xB0 14p0 1nX0 11B0 1nX0 1fB0 WL0 1fB0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 Dd0|63e4","America/Caracas|CMT -0430 -04|4r.E 4u 40|01212|-2kV7w.k 28KM2.k 1IwOu kqo0|29e5","America/Cayenne|LMT -04 -03|3t.k 40 30|012|-2mrwu.E 2gWou.E|58e3","America/Panama|CMT EST|5j.A 50|01|-2uduE.o|15e5","America/Chicago|CST CDT EST CWT CPT|60 50 50 50 50|01010101010101010101010101010101010102010101010103401010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010|-261s0 1nX0 11B0 1nX0 1wp0 TX0 WN0 1qL0 1cN0 WL0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 11z0 1o10 11z0 11B0 1Hz0 14p0 11z0 1o10 11z0 1qN0 WL0 1qN0 11z0 1o10 11z0 RB0 8x30 iw0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 s10 1Vz0 LB0 1BX0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|92e5","America/Chihuahua|LMT MST CST CDT MDT|74.k 70 60 50 60|0121212323241414141414141414141414141414141414141414141414141414141414141414141414141414141|-1UQF0 deL0 8lc0 17c0 10M0 1dd0 2zQN0 1lb0 14p0 1lb0 14q0 1lb0 14p0 1nX0 11B0 1nX0 1fB0 WL0 1fB0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0|81e4","America/Costa_Rica|SJMT CST CDT|5A.d 60 50|0121212121|-1Xd6n.L 2lu0n.L Db0 1Kp0 Db0 pRB0 15b0 1kp0 mL0|12e5","America/Creston|MST PST|70 80|010|-29DR0 43B0|53e2","America/Cuiaba|LMT -04 -03|3I.k 40 30|012121212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-2glwf.E HdLf.E 1cc0 1e10 1bX0 Ezd0 So0 1vA0 Mn0 1BB0 ML0 1BB0 zX0 qe10 xb0 2ep0 nz0 1C10 zX0 1C10 LX0 1C10 Mn0 H210 Rb0 1tB0 IL0 1Fd0 FX0 1EN0 FX0 1HB0 Lz0 1EN0 Lz0 1C10 IL0 1HB0 Db0 1HB0 On0 1zd0 On0 1zd0 Lz0 1zd0 Rb0 1wN0 Wn0 1tB0 Rb0 1tB0 WL0 1tB0 Rb0 1zd0 On0 1HB0 FX0 4a10 HX0 1zd0 On0 1HB0 IL0 1wp0 On0 1C10 Lz0 1C10 On0 1zd0 On0 1zd0 Rb0 1zd0 Lz0 1C10 Lz0 1C10 On0 1zd0 On0 1zd0 On0 1zd0 On0 1HB0 FX0|54e4","America/Danmarkshavn|LMT -03 -02 GMT|1e.E 30 20 0|01212121212121212121212121212121213|-2a5WJ.k 2z5fJ.k 19U0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 DC0|8","America/Dawson_Creek|PST PDT PWT PPT MST|80 70 70 70 70|0102301010101010101010101010101010101010101010101010101014|-25TO0 1in0 UGp0 8x10 iy0 3NB0 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 ML0|12e3","America/Dawson|YST YDT YWT YPT YDDT PST PDT|90 80 80 80 70 80 70|0101023040565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565|-25TN0 1in0 1o10 13V0 Ser0 8x00 iz0 LCL0 1fA0 jrA0 fNd0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|13e2","America/Denver|MST MDT MWT MPT|70 60 60 60|01010101023010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010|-261r0 1nX0 11B0 1nX0 11B0 1qL0 WN0 mn0 Ord0 8x20 ix0 LCN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 s10 1Vz0 LB0 1BX0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|26e5","America/Detroit|LMT CST EST EWT EPT EDT|5w.b 60 50 40 40 40|0123425252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252|-2Cgir.N peqr.N 156L0 8x40 iv0 6fd0 11z0 JxX1 SMX 1cN0 1cL0 aW10 1cL0 s10 1Vz0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|37e5","America/Edmonton|LMT MST MDT MWT MPT|7x.Q 70 60 60 60|0121212121212134121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-2yd4q.8 shdq.8 1in0 17d0 hz0 2dB0 1fz0 1a10 11z0 1qN0 WL0 1qN0 11z0 IGN0 8x20 ix0 3NB0 11z0 XQp0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|10e5","America/Eirunepe|LMT -05 -04|4D.s 50 40|0121212121212121212121212121212121|-2glvk.w HdLk.w 1cc0 1e10 1bX0 Ezd0 So0 1vA0 Mn0 1BB0 ML0 1BB0 zX0 qe10 xb0 2ep0 nz0 1C10 zX0 1C10 LX0 1C10 Mn0 H210 Rb0 1tB0 IL0 1Fd0 FX0 dPB0 On0 yTd0 d5X0|31e3","America/El_Salvador|LMT CST CDT|5U.M 60 50|012121|-1XiG3.c 2Fvc3.c WL0 1qN0 WL0|11e5","America/Tijuana|LMT MST PST PDT PWT PPT|7M.4 70 80 70 70 70|012123245232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232|-1UQE0 4PX0 8mM0 8lc0 SN0 1cL0 pHB0 83r0 zI0 5O10 1Rz0 cOO0 11A0 1o00 11A0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1o00 11A0 BUp0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 U10 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|20e5","America/Fort_Nelson|PST PDT PWT PPT MST|80 70 70 70 70|01023010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010104|-25TO0 1in0 UGp0 8x10 iy0 3NB0 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0|39e2","America/Fort_Wayne|CST CDT CWT CPT EST EDT|60 50 50 50 50 40|010101023010101010101010101040454545454545454545454545454545454545454545454545454545454545454545454|-261s0 1nX0 11B0 1nX0 QI10 Db0 RB0 8x30 iw0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 5Tz0 1o10 qLb0 1cL0 1cN0 1cL0 1qhd0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|","America/Fortaleza|LMT -03 -02|2y 30 20|0121212121212121212121212121212121212121|-2glxq HdLq 1cc0 1e10 1bX0 Ezd0 So0 1vA0 Mn0 1BB0 ML0 1BB0 zX0 qe10 xb0 2ep0 nz0 1C10 zX0 1C10 LX0 1C10 Mn0 H210 Rb0 1tB0 IL0 1Fd0 FX0 1EN0 FX0 1HB0 Lz0 nsp0 WL0 1tB0 5z0 2mN0 On0|34e5","America/Glace_Bay|LMT AST ADT AWT APT|3X.M 40 30 30 30|012134121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-2IsI0.c CwO0.c 1in0 UGp0 8x50 iu0 iq10 11z0 Jg10 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|19e3","America/Godthab|LMT -03 -02|3q.U 30 20|0121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-2a5Ux.4 2z5dx.4 19U0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|17e3","America/Goose_Bay|NST NDT NST NDT NWT NPT AST ADT ADDT|3u.Q 2u.Q 3u 2u 2u 2u 40 30 20|010232323232323245232323232323232323232323232323232323232326767676767676767676767676767676767676767676768676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676|-25TSt.8 1in0 DXb0 2HbX.8 WL0 1qN0 WL0 1qN0 WL0 1tB0 TX0 1tB0 WL0 1qN0 WL0 1qN0 7UHu itu 1tB0 WL0 1qN0 WL0 1qN0 WL0 1qN0 WL0 1tB0 WL0 1ld0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 S10 g0u 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14n1 1lb0 14p0 1nW0 11C0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zcX Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|76e2","America/Grand_Turk|KMT EST EDT AST|57.a 50 40 40|01212121212121212121212121212121212121212121212121212121212121212121212121232121212121212121212121212121212121212121|-2l1uQ.O 2HHBQ.O 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 5Ip0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|37e2","America/Guatemala|LMT CST CDT|62.4 60 50|0121212121|-24KhV.U 2efXV.U An0 mtd0 Nz0 ifB0 17b0 zDB0 11z0|13e5","America/Guayaquil|QMT -05 -04|5e 50 40|0121|-1yVSK 2uILK rz0|27e5","America/Guyana|LMT -0345 -03 -04|3Q.E 3J 30 40|0123|-2dvU7.k 2r6LQ.k Bxbf|80e4","America/Halifax|LMT AST ADT AWT APT|4e.o 40 30 30 30|0121212121212121212121212121212121212121212121212134121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-2IsHJ.A xzzJ.A 1db0 3I30 1in0 3HX0 IL0 1E10 ML0 1yN0 Pb0 1Bd0 Mn0 1Bd0 Rz0 1w10 Xb0 1w10 LX0 1w10 Xb0 1w10 Lz0 1C10 Jz0 1E10 OL0 1yN0 Un0 1qp0 Xb0 1qp0 11X0 1w10 Lz0 1HB0 LX0 1C10 FX0 1w10 Xb0 1qp0 Xb0 1BB0 LX0 1td0 Xb0 1qp0 Xb0 Rf0 8x50 iu0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 3Qp0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 3Qp0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 6i10 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|39e4","America/Havana|HMT CST CDT|5t.A 50 40|012121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-1Meuu.o 72zu.o ML0 sld0 An0 1Nd0 Db0 1Nd0 An0 6Ep0 An0 1Nd0 An0 JDd0 Mn0 1Ap0 On0 1fd0 11X0 1qN0 WL0 1wp0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 14n0 1ld0 14L0 1kN0 15b0 1kp0 1cL0 1cN0 1fz0 1a10 1fz0 1fB0 11z0 14p0 1nX0 11B0 1nX0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 14n0 1ld0 14n0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 1a10 1in0 1a10 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1cM0 1cM0 1fA0 17c0 1o00 11A0 1qM0 11A0 1o00 11A0 1o00 14o0 1lc0 14o0 1lc0 11A0 6i00 Rc0 1wo0 U00 1tA0 Rc0 1wo0 U00 1wo0 U00 1zc0 U00 1qM0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0|21e5","America/Hermosillo|LMT MST CST PST MDT|7n.Q 70 60 80 60|0121212131414141|-1UQF0 deL0 8lc0 17c0 10M0 1dd0 otX0 gmN0 P2N0 13Vd0 1lb0 14p0 1lb0 14p0 1lb0|64e4","America/Indiana/Knox|CST CDT CWT CPT EST|60 50 50 50 50|0101023010101010101010101010101010101040101010101010101010101010101010101010101010101010141010101010101010101010101010101010101010101010101010101010101010|-261s0 1nX0 11B0 1nX0 SgN0 8x30 iw0 3NB0 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 1fz0 1cN0 1cL0 1cN0 11z0 1o10 11z0 1o10 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 3Cn0 8wp0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 s10 1Vz0 LB0 1BX0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 z8o0 1o00 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|","America/Indiana/Marengo|CST CDT CWT CPT EST EDT|60 50 50 50 50 40|0101023010101010101010104545454545414545454545454545454545454545454545454545454545454545454545454545454|-261s0 1nX0 11B0 1nX0 SgN0 8x30 iw0 dyN0 11z0 6fd0 11z0 1o10 11z0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 jrz0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 s10 1VA0 LA0 1BX0 1e6p0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|","America/Indiana/Petersburg|CST CDT CWT CPT EST EDT|60 50 50 50 50 40|01010230101010101010101010104010101010101010101010141014545454545454545454545454545454545454545454545454545454545454|-261s0 1nX0 11B0 1nX0 SgN0 8x30 iw0 njX0 WN0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 3Fb0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 s10 1Vz0 LB0 1BX0 1cN0 1fz0 1a10 1fz0 19co0 1o00 Rd0 1zb0 Oo0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|","America/Indiana/Tell_City|CST CDT CWT CPT EST EDT|60 50 50 50 50 40|01010230101010101010101010401054541010101010101010101010101010101010101010101010101010101010101010|-261s0 1nX0 11B0 1nX0 SgN0 8x30 iw0 njX0 WN0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 8wn0 1cN0 1cL0 1cN0 1cK0 1cN0 1cL0 1qhd0 1o00 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|","America/Indiana/Vevay|CST CDT CWT CPT EST EDT|60 50 50 50 50 40|010102304545454545454545454545454545454545454545454545454545454545454545454545454|-261s0 1nX0 11B0 1nX0 SgN0 8x30 iw0 kPB0 Awn0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1lnd0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|","America/Indiana/Vincennes|CST CDT CWT CPT EST EDT|60 50 50 50 50 40|01010230101010101010101010101010454541014545454545454545454545454545454545454545454545454545454545454|-261s0 1nX0 11B0 1nX0 SgN0 8x30 iw0 1o10 11z0 g0p0 11z0 1o10 11z0 1qL0 WN0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 1fz0 1cN0 WL0 1qN0 1cL0 1cN0 1cL0 1cN0 caL0 1cL0 1cN0 1cL0 1qhd0 1o00 Rd0 1zb0 Oo0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|","America/Indiana/Winamac|CST CDT CWT CPT EST EDT|60 50 50 50 50 40|01010230101010101010101010101010101010454541054545454545454545454545454545454545454545454545454545454545454|-261s0 1nX0 11B0 1nX0 SgN0 8x30 iw0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 1fz0 1cN0 1cL0 1cN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 jrz0 1cL0 1cN0 1cL0 1qhd0 1o00 Rd0 1za0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|","America/Inuvik|-00 PST PDDT MST MDT|0 80 60 70 60|0121343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343|-FnA0 tWU0 1fA0 wPe0 2pz0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|35e2","America/Iqaluit|-00 EWT EPT EST EDDT EDT CST CDT|0 40 40 50 30 40 60 50|01234353535353535353535353535353535353535353567353535353535353535353535353535353535353535353535353535353535353535353535353|-16K00 7nX0 iv0 LCL0 1fA0 zgO0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11C0 1nX0 11A0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|67e2","America/Jamaica|KMT EST EDT|57.a 50 40|0121212121212121212121|-2l1uQ.O 2uM1Q.O 1Vz0 LB0 1BX0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0|94e4","America/Juneau|PST PWT PPT PDT YDT YST AKST AKDT|80 70 70 70 80 90 90 80|01203030303030303030303030403030356767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676|-17T20 8x10 iy0 Vo10 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 s10 1Vz0 LB0 1BX0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cM0 1cM0 1cL0 1cN0 1fz0 1a10 1fz0 co0 10q0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|33e3","America/Kentucky/Louisville|CST CDT CWT CPT EST EDT|60 50 50 50 50 40|0101010102301010101010101010101010101454545454545414545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454|-261s0 1nX0 11B0 1nX0 3Fd0 Nb0 LPd0 11z0 RB0 8x30 iw0 1nX1 e0X 9vd0 WL0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 xz0 gso0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 s10 1VA0 LA0 1BX0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|","America/Kentucky/Monticello|CST CDT CWT CPT EST EDT|60 50 50 50 50 40|0101023010101010101010101010101010101010101010101010101010101010101010101454545454545454545454545454545454545454545454545454545454545454545454545454|-261s0 1nX0 11B0 1nX0 SgN0 8x30 iw0 SWp0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 s10 1Vz0 LB0 1BX0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11A0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|","America/La_Paz|CMT BST -04|4w.A 3w.A 40|012|-1x37r.o 13b0|19e5","America/Lima|LMT -05 -04|58.A 50 40|0121212121212121|-2tyGP.o 1bDzP.o zX0 1aN0 1cL0 1cN0 1cL0 1PrB0 zX0 1O10 zX0 6Gp0 zX0 98p0 zX0|11e6","America/Los_Angeles|PST PDT PWT PPT|80 70 70 70|010102301010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010|-261q0 1nX0 11B0 1nX0 SgN0 8x10 iy0 5Wp1 1VaX 3dA0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1a00 1fA0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 s10 1Vz0 LB0 1BX0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|15e6","America/Maceio|LMT -03 -02|2m.Q 30 20|012121212121212121212121212121212121212121|-2glxB.8 HdLB.8 1cc0 1e10 1bX0 Ezd0 So0 1vA0 Mn0 1BB0 ML0 1BB0 zX0 qe10 xb0 2ep0 nz0 1C10 zX0 1C10 LX0 1C10 Mn0 H210 Rb0 1tB0 IL0 1Fd0 FX0 1EN0 FX0 1HB0 Lz0 dMN0 Lz0 8Q10 WL0 1tB0 5z0 2mN0 On0|93e4","America/Managua|MMT CST EST CDT|5J.c 60 50 50|0121313121213131|-1quie.M 1yAMe.M 4mn0 9Up0 Dz0 1K10 Dz0 s3F0 1KH0 DB0 9In0 k8p0 19X0 1o30 11y0|22e5","America/Manaus|LMT -04 -03|40.4 40 30|01212121212121212121212121212121|-2glvX.U HdKX.U 1cc0 1e10 1bX0 Ezd0 So0 1vA0 Mn0 1BB0 ML0 1BB0 zX0 qe10 xb0 2ep0 nz0 1C10 zX0 1C10 LX0 1C10 Mn0 H210 Rb0 1tB0 IL0 1Fd0 FX0 dPB0 On0|19e5","America/Martinique|FFMT AST ADT|44.k 40 30|0121|-2mPTT.E 2LPbT.E 19X0|39e4","America/Matamoros|LMT CST CDT|6E 60 50|0121212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-1UQG0 2FjC0 1nX0 i6p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 1fB0 WL0 1fB0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 U10 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|45e4","America/Mazatlan|LMT MST CST PST MDT|75.E 70 60 80 60|0121212131414141414141414141414141414141414141414141414141414141414141414141414141414141414141|-1UQF0 deL0 8lc0 17c0 10M0 1dd0 otX0 gmN0 P2N0 13Vd0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 1fB0 WL0 1fB0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0|44e4","America/Menominee|CST CDT CWT CPT EST|60 50 50 50 50|01010230101041010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010|-261s0 1nX0 11B0 1nX0 SgN0 8x30 iw0 1o10 11z0 LCN0 1fz0 6410 9Jb0 1cM0 s10 1Vz0 LB0 1BX0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|85e2","America/Merida|LMT CST EST CDT|5W.s 60 50 50|0121313131313131313131313131313131313131313131313131313131313131313131313131313131313131|-1UQG0 2q2o0 2hz0 wu30 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 1fB0 WL0 1fB0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0|11e5","America/Metlakatla|PST PWT PPT PDT AKST AKDT|80 70 70 70 90 80|01203030303030303030303030303030304545450454545454545454545454545454545454545454|-17T20 8x10 iy0 Vo10 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 s10 1Vz0 LB0 1BX0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1hU10 Rd0 1zb0 Op0 1zb0 Op0 1zb0 uM0 jB0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|14e2","America/Mexico_City|LMT MST CST CDT CWT|6A.A 70 60 50 50|012121232324232323232323232323232323232323232323232323232323232323232323232323232323232323232323232|-1UQF0 deL0 8lc0 17c0 10M0 1dd0 gEn0 TX0 3xd0 Jb0 6zB0 SL0 e5d0 17b0 1Pff0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 1fB0 WL0 1fB0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0|20e6","America/Miquelon|LMT AST -03 -02|3I.E 40 30 20|012323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232|-2mKkf.k 2LTAf.k gQ10 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|61e2","America/Moncton|EST AST ADT AWT APT|50 40 30 30 30|012121212121212121212134121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-2IsH0 CwN0 1in0 zAo0 An0 1Nd0 An0 1Nd0 An0 1Nd0 An0 1Nd0 An0 1Nd0 An0 1K10 Lz0 1zB0 NX0 1u10 Wn0 S20 8x50 iu0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 11z0 1o10 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 3Cp0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14n1 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 ReX 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|64e3","America/Monterrey|LMT CST CDT|6F.g 60 50|0121212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-1UQG0 2FjC0 1nX0 i6p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 1fB0 WL0 1fB0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0|41e5","America/Montevideo|LMT MMT -04 -03 -0330 -0230 -02 -0130|3I.P 3I.P 40 30 3u 2u 20 1u|012343434343434343434343435353636353636375363636363636363636363636363636363636363636363|-2tRUf.9 sVc0 8jcf.9 1db0 1dcu 1cLu 1dcu 1cLu ircu 11zu 1o0u 11zu 1o0u 11zu 1o0u 11zu 1qMu WLu 1qMu WLu 1fAu 1cLu 1o0u 11zu NAu 3jXu zXu Dq0u 19Xu pcu jz0 cm10 19X0 6tB0 1fbu 3o0u jX0 4vB0 xz0 3Cp0 mmu 1a10 IMu Db0 4c10 uL0 1Nd0 An0 1SN0 uL0 mp0 28L0 iPB0 un0 1SN0 xz0 1zd0 Lz0 1zd0 Rb0 1zd0 On0 1wp0 Rb0 s8p0 1fB0 1ip0 11z0 1ld0 14n0 1o10 11z0 1o10 11z0 1o10 14n0 1ld0 14n0 1ld0 14n0 1o10 11z0 1o10 11z0 1o10 11z0|17e5","America/Toronto|EST EDT EWT EPT|50 40 40 40|01010101010101010101010101010101010101010101012301010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010|-25TR0 1in0 11Wu 1nzu 1fD0 WJ0 1wr0 Nb0 1Ap0 On0 1zd0 On0 1wp0 TX0 1tB0 TX0 1tB0 TX0 1tB0 WL0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 4kM0 8x40 iv0 1o10 11z0 1nX0 11z0 1o10 11z0 1o10 1qL0 11D0 1nX0 11B0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 11z0 1o10 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|65e5","America/Nassau|LMT EST EDT|59.u 50 40|012121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-2kNuO.u 26XdO.u 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|24e4","America/New_York|EST EDT EWT EPT|50 40 40 40|01010101010101010101010101010101010101010101010102301010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010|-261t0 1nX0 11B0 1nX0 11B0 1qL0 1a10 11z0 1qN0 WL0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 11z0 1o10 11z0 RB0 8x40 iv0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 s10 1Vz0 LB0 1BX0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|21e6","America/Nipigon|EST EDT EWT EPT|50 40 40 40|010123010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010|-25TR0 1in0 Rnb0 3je0 8x40 iv0 19yN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|16e2","America/Nome|NST NWT NPT BST BDT YST AKST AKDT|b0 a0 a0 b0 a0 90 90 80|012034343434343434343434343434343456767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676|-17SX0 8wW0 iB0 Qlb0 52O0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 s10 1Vz0 LB0 1BX0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 cl0 10q0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|38e2","America/Noronha|LMT -02 -01|29.E 20 10|0121212121212121212121212121212121212121|-2glxO.k HdKO.k 1cc0 1e10 1bX0 Ezd0 So0 1vA0 Mn0 1BB0 ML0 1BB0 zX0 qe10 xb0 2ep0 nz0 1C10 zX0 1C10 LX0 1C10 Mn0 H210 Rb0 1tB0 IL0 1Fd0 FX0 1EN0 FX0 1HB0 Lz0 nsp0 WL0 1tB0 2L0 2pB0 On0|30e2","America/North_Dakota/Beulah|MST MDT MWT MPT CST CDT|70 60 60 60 60 50|010102301010101010101010101010101010101010101010101010101010101010101010101010101010101010101014545454545454545454545454545454545454545454545454545454|-261r0 1nX0 11B0 1nX0 SgN0 8x20 ix0 QwN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 s10 1Vz0 LB0 1BX0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Oo0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|","America/North_Dakota/Center|MST MDT MWT MPT CST CDT|70 60 60 60 60 50|010102301010101010101010101010101010101010101010101010101014545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454|-261r0 1nX0 11B0 1nX0 SgN0 8x20 ix0 QwN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 s10 1Vz0 LB0 1BX0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14o0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|","America/North_Dakota/New_Salem|MST MDT MWT MPT CST CDT|70 60 60 60 60 50|010102301010101010101010101010101010101010101010101010101010101010101010101010101454545454545454545454545454545454545454545454545454545454545454545454|-261r0 1nX0 11B0 1nX0 SgN0 8x20 ix0 QwN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 s10 1Vz0 LB0 1BX0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14o0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|","America/Ojinaga|LMT MST CST CDT MDT|6V.E 70 60 50 60|0121212323241414141414141414141414141414141414141414141414141414141414141414141414141414141|-1UQF0 deL0 8lc0 17c0 10M0 1dd0 2zQN0 1lb0 14p0 1lb0 14q0 1lb0 14p0 1nX0 11B0 1nX0 1fB0 WL0 1fB0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 U10 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|23e3","America/Pangnirtung|-00 AST AWT APT ADDT ADT EDT EST CST CDT|0 40 30 30 20 30 40 50 60 50|012314151515151515151515151515151515167676767689767676767676767676767676767676767676767676767676767676767676767676767676767|-1XiM0 PnG0 8x50 iu0 LCL0 1fA0 zgO0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1o00 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11C0 1nX0 11A0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|14e2","America/Paramaribo|LMT PMT PMT -0330 -03|3E.E 3E.Q 3E.A 3u 30|01234|-2nDUj.k Wqo0.c qanX.I 1yVXN.o|24e4","America/Phoenix|MST MDT MWT|70 60 60|01010202010|-261r0 1nX0 11B0 1nX0 SgN0 4Al1 Ap0 1db0 SWqX 1cL0|42e5","America/Port-au-Prince|PPMT EST EDT|4N 50 40|01212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-28RHb 2FnMb 19X0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14q0 1o00 11A0 1o00 11A0 1o00 14o0 1lc0 14o0 1lc0 14o0 1o00 11A0 1o00 11A0 1o00 14o0 1lc0 14o0 1lc0 i6n0 1nX0 11B0 1nX0 d430 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 3iN0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|23e5","America/Rio_Branco|LMT -05 -04|4v.c 50 40|01212121212121212121212121212121|-2glvs.M HdLs.M 1cc0 1e10 1bX0 Ezd0 So0 1vA0 Mn0 1BB0 ML0 1BB0 zX0 qe10 xb0 2ep0 nz0 1C10 zX0 1C10 LX0 1C10 Mn0 H210 Rb0 1tB0 IL0 1Fd0 FX0 NBd0 d5X0|31e4","America/Porto_Velho|LMT -04 -03|4f.A 40 30|012121212121212121212121212121|-2glvI.o HdKI.o 1cc0 1e10 1bX0 Ezd0 So0 1vA0 Mn0 1BB0 ML0 1BB0 zX0 qe10 xb0 2ep0 nz0 1C10 zX0 1C10 LX0 1C10 Mn0 H210 Rb0 1tB0 IL0 1Fd0 FX0|37e4","America/Puerto_Rico|AST AWT APT|40 30 30|0120|-17lU0 7XT0 iu0|24e5","America/Punta_Arenas|SMT -05 -04 -03|4G.K 50 40 30|0102021212121212121232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323|-2q2jh.e fJAh.e 5knG.K 1Vzh.e jRAG.K 1pbh.e 11d0 1oL0 11d0 1oL0 11d0 1oL0 11d0 1pb0 11d0 nHX0 op0 blz0 ko0 Qeo0 WL0 1zd0 On0 1ip0 11z0 1o10 11z0 1qN0 WL0 1ld0 14n0 1qN0 WL0 1qN0 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 WL0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 WL0 1qN0 1cL0 1cN0 11z0 1o10 11z0 1qN0 WL0 1fB0 19X0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 17b0 1ip0 11z0 1ip0 1fz0 1fB0 11z0 1qN0 WL0 1qN0 WL0 1qN0 WL0 1qN0 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 17b0 1ip0 11z0 1o10 19X0 1fB0 1nX0 G10 1EL0 Op0 1zb0 Rd0 1wn0 Rd0 46n0 Ap0|","America/Rainy_River|CST CDT CWT CPT|60 50 50 50|010123010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010|-25TQ0 1in0 Rnb0 3je0 8x30 iw0 19yN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|842","America/Rankin_Inlet|-00 CST CDDT CDT EST|0 60 40 50 50|012131313131313131313131313131313131313131313431313131313131313131313131313131313131313131313131313131313131313131313131|-vDc0 keu0 1fA0 zgO0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|26e2","America/Recife|LMT -03 -02|2j.A 30 20|0121212121212121212121212121212121212121|-2glxE.o HdLE.o 1cc0 1e10 1bX0 Ezd0 So0 1vA0 Mn0 1BB0 ML0 1BB0 zX0 qe10 xb0 2ep0 nz0 1C10 zX0 1C10 LX0 1C10 Mn0 H210 Rb0 1tB0 IL0 1Fd0 FX0 1EN0 FX0 1HB0 Lz0 nsp0 WL0 1tB0 2L0 2pB0 On0|33e5","America/Regina|LMT MST MDT MWT MPT CST|6W.A 70 60 60 60 60|012121212121212121212121341212121212121212121212121215|-2AD51.o uHe1.o 1in0 s2L0 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 11z0 66N0 1cL0 1cN0 19X0 1fB0 1cL0 1fB0 1cL0 1cN0 1cL0 M30 8x20 ix0 1ip0 1cL0 1ip0 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 11z0 1o10 11z0 3NB0 1cL0 1cN0|19e4","America/Resolute|-00 CST CDDT CDT EST|0 60 40 50 50|012131313131313131313131313131313131313131313431313131313431313131313131313131313131313131313131313131313131313131313131|-SnA0 GWS0 1fA0 zgO0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|229","America/Santarem|LMT -04 -03|3C.M 40 30|0121212121212121212121212121212|-2glwl.c HdLl.c 1cc0 1e10 1bX0 Ezd0 So0 1vA0 Mn0 1BB0 ML0 1BB0 zX0 qe10 xb0 2ep0 nz0 1C10 zX0 1C10 LX0 1C10 Mn0 H210 Rb0 1tB0 IL0 1Fd0 FX0 NBd0|21e4","America/Santiago|SMT -05 -04 -03|4G.K 50 40 30|010202121212121212321232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323|-2q2jh.e fJAh.e 5knG.K 1Vzh.e jRAG.K 1pbh.e 11d0 1oL0 11d0 1oL0 11d0 1oL0 11d0 1pb0 11d0 nHX0 op0 9Bz0 jb0 1oN0 ko0 Qeo0 WL0 1zd0 On0 1ip0 11z0 1o10 11z0 1qN0 WL0 1ld0 14n0 1qN0 WL0 1qN0 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 WL0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 WL0 1qN0 1cL0 1cN0 11z0 1o10 11z0 1qN0 WL0 1fB0 19X0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 17b0 1ip0 11z0 1ip0 1fz0 1fB0 11z0 1qN0 WL0 1qN0 WL0 1qN0 WL0 1qN0 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 17b0 1ip0 11z0 1o10 19X0 1fB0 1nX0 G10 1EL0 Op0 1zb0 Rd0 1wn0 Rd0 46n0 Ap0 1Nb0 Ap0 1Nb0 Ap0 1zb0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0|62e5","America/Santo_Domingo|SDMT EST EDT -0430 AST|4E 50 40 4u 40|01213131313131414|-1ttjk 1lJMk Mn0 6sp0 Lbu 1Cou yLu 1RAu wLu 1QMu xzu 1Q0u xXu 1PAu 13jB0 e00|29e5","America/Sao_Paulo|LMT -03 -02|36.s 30 20|01212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-2glwR.w HdKR.w 1cc0 1e10 1bX0 Ezd0 So0 1vA0 Mn0 1BB0 ML0 1BB0 zX0 pTd0 PX0 2ep0 nz0 1C10 zX0 1C10 LX0 1C10 Mn0 H210 Rb0 1tB0 IL0 1Fd0 FX0 1EN0 FX0 1HB0 Lz0 1EN0 Lz0 1C10 IL0 1HB0 Db0 1HB0 On0 1zd0 On0 1zd0 Lz0 1zd0 Rb0 1wN0 Wn0 1tB0 Rb0 1tB0 WL0 1tB0 Rb0 1zd0 On0 1HB0 FX0 1C10 Lz0 1Ip0 HX0 1zd0 On0 1HB0 IL0 1wp0 On0 1C10 Lz0 1C10 On0 1zd0 On0 1zd0 Rb0 1zd0 Lz0 1C10 Lz0 1C10 On0 1zd0 On0 1zd0 On0 1zd0 On0 1HB0 FX0|20e6","America/Scoresbysund|LMT -02 -01 +00|1r.Q 20 10 0|0121323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232|-2a5Ww.8 2z5ew.8 1a00 1cK0 1cL0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|452","America/Sitka|PST PWT PPT PDT YST AKST AKDT|80 70 70 70 90 90 80|01203030303030303030303030303030345656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565|-17T20 8x10 iy0 Vo10 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 s10 1Vz0 LB0 1BX0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 co0 10q0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|90e2","America/St_Johns|NST NDT NST NDT NWT NPT NDDT|3u.Q 2u.Q 3u 2u 2u 2u 1u|01010101010101010101010101010101010102323232323232324523232323232323232323232323232323232323232323232323232323232323232323232323232323232326232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232|-28oit.8 14L0 1nB0 1in0 1gm0 Dz0 1JB0 1cL0 1cN0 1cL0 1fB0 19X0 1fB0 19X0 1fB0 19X0 1fB0 19X0 1fB0 1cL0 1cN0 1cL0 1fB0 19X0 1fB0 19X0 1fB0 19X0 1fB0 19X0 1fB0 1cL0 1fB0 19X0 1fB0 19X0 10O0 eKX.8 19X0 1iq0 WL0 1qN0 WL0 1qN0 WL0 1tB0 TX0 1tB0 WL0 1qN0 WL0 1qN0 7UHu itu 1tB0 WL0 1qN0 WL0 1qN0 WL0 1qN0 WL0 1tB0 WL0 1ld0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14n1 1lb0 14p0 1nW0 11C0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zcX Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|11e4","America/Swift_Current|LMT MST MDT MWT MPT CST|7b.k 70 60 60 60 60|012134121212121212121215|-2AD4M.E uHdM.E 1in0 UGp0 8x20 ix0 1o10 17b0 1ip0 11z0 1o10 11z0 1o10 11z0 isN0 1cL0 3Cp0 1cL0 1cN0 11z0 1qN0 WL0 pMp0|16e3","America/Tegucigalpa|LMT CST CDT|5M.Q 60 50|01212121|-1WGGb.8 2ETcb.8 WL0 1qN0 WL0 GRd0 AL0|11e5","America/Thule|LMT AST ADT|4z.8 40 30|012121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-2a5To.Q 31NBo.Q 1cL0 1cN0 1cL0 1fB0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|656","America/Thunder_Bay|CST EST EWT EPT EDT|60 50 40 40 40|0123141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141|-2q5S0 1iaN0 8x40 iv0 XNB0 1cL0 1cN0 1fz0 1cN0 1cL0 3Cp0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|11e4","America/Vancouver|PST PDT PWT PPT|80 70 70 70|0102301010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010|-25TO0 1in0 UGp0 8x10 iy0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|23e5","America/Whitehorse|YST YDT YWT YPT YDDT PST PDT|90 80 80 80 70 80 70|0101023040565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565|-25TN0 1in0 1o10 13V0 Ser0 8x00 iz0 LCL0 1fA0 3NA0 vrd0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|23e3","America/Winnipeg|CST CDT CWT CPT|60 50 50 50|010101023010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010|-2aIi0 WL0 3ND0 1in0 Jap0 Rb0 aCN0 8x30 iw0 1tB0 11z0 1ip0 11z0 1o10 11z0 1o10 11z0 1rd0 10L0 1op0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 1cL0 1cN0 11z0 6i10 WL0 6i10 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1a00 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1a00 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 14o0 1lc0 14o0 1o00 11A0 1o00 11A0 1o00 14o0 1lc0 14o0 1lc0 14o0 1o00 11A0 1o00 11A0 1o00 14o0 1lc0 14o0 1lc0 14o0 1lc0 14o0 1o00 11A0 1o00 11A0 1o00 14o0 1lc0 14o0 1lc0 14o0 1o00 11A0 1o00 11A0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|66e4","America/Yakutat|YST YWT YPT YDT AKST AKDT|90 80 80 80 90 80|01203030303030303030303030303030304545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454|-17T10 8x00 iz0 Vo10 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 s10 1Vz0 LB0 1BX0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 cn0 10q0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|642","America/Yellowknife|-00 MST MWT MPT MDDT MDT|0 70 60 60 50 60|012314151515151515151515151515151515151515151515151515151515151515151515151515151515151515151515151515151515151515151515151|-1pdA0 hix0 8x20 ix0 LCL0 1fA0 zgO0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|19e3","Antarctica/Casey|-00 +08 +11|0 -80 -b0|01212121|-2q00 1DjS0 T90 40P0 KL0 blz0 3m10|10","Antarctica/Davis|-00 +07 +05|0 -70 -50|01012121|-vyo0 iXt0 alj0 1D7v0 VB0 3Wn0 KN0|70","Antarctica/DumontDUrville|-00 +10|0 -a0|0101|-U0o0 cfq0 bFm0|80","Antarctica/Macquarie|AEST AEDT -00 +11|-a0 -b0 0 -b0|0102010101010101010101010101010101010101010101010101010101010101010101010101010101010101013|-29E80 19X0 4SL0 1ayy0 Lvs0 1cM0 1o00 Rc0 1wo0 Rc0 1wo0 U00 1wo0 LA0 1C00 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 11A0 1qM0 WM0 1qM0 Oo0 1zc0 Oo0 1zc0 Oo0 1wo0 WM0 1tA0 WM0 1tA0 U00 1tA0 U00 1tA0 11A0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 11A0 1o00 1io0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1cM0 1a00 1io0 1cM0 1cM0 1cM0 1cM0 1cM0|1","Antarctica/Mawson|-00 +06 +05|0 -60 -50|012|-CEo0 2fyk0|60","Pacific/Auckland|NZMT NZST NZST NZDT|-bu -cu -c0 -d0|01020202020202020202020202023232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323|-1GCVu Lz0 1tB0 11zu 1o0u 11zu 1o0u 11zu 1o0u 14nu 1lcu 14nu 1lcu 1lbu 11Au 1nXu 11Au 1nXu 11Au 1nXu 11Au 1nXu 11Au 1qLu WMu 1qLu 11Au 1n1bu IM0 1C00 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1qM0 14o0 1lc0 14o0 1lc0 14o0 1lc0 17c0 1io0 17c0 1io0 17c0 1io0 17c0 1lc0 14o0 1lc0 14o0 1lc0 17c0 1io0 17c0 1io0 17c0 1lc0 14o0 1lc0 14o0 1lc0 17c0 1io0 17c0 1io0 17c0 1io0 17c0 1io0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1io0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00|14e5","Antarctica/Palmer|-00 -03 -04 -02|0 30 40 20|0121212121213121212121212121212121212121212121212121212121212121212121212121212121|-cao0 nD0 1vd0 SL0 1vd0 17z0 1cN0 1fz0 1cN0 1cL0 1cN0 asn0 Db0 jsN0 14N0 11z0 1o10 11z0 1qN0 WL0 1qN0 WL0 1qN0 1cL0 1cN0 11z0 1o10 11z0 1qN0 WL0 1fB0 19X0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 17b0 1ip0 11z0 1ip0 1fz0 1fB0 11z0 1qN0 WL0 1qN0 WL0 1qN0 WL0 1qN0 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 17b0 1ip0 11z0 1o10 19X0 1fB0 1nX0 G10 1EL0 Op0 1zb0 Rd0 1wn0 Rd0 46n0 Ap0|40","Antarctica/Rothera|-00 -03|0 30|01|gOo0|130","Antarctica/Syowa|-00 +03|0 -30|01|-vs00|20","Antarctica/Troll|-00 +00 +02|0 0 -20|01212121212121212121212121212121212121212121212121212121212121212121|1puo0 hd0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|40","Antarctica/Vostok|-00 +06|0 -60|01|-tjA0|25","Europe/Oslo|CET CEST|-10 -20|010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010|-2awM0 Qm0 W6o0 5pf0 WM0 1fA0 1cM0 1cM0 1cM0 1cM0 wJc0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1qM0 WM0 zpc0 1a00 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|62e4","Asia/Riyadh|LMT +03|-36.Q -30|01|-TvD6.Q|57e5","Asia/Almaty|LMT +05 +06 +07|-57.M -50 -60 -70|012323232323232323232321232323232323232323232323232|-1Pc57.M eUo7.M 23CL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 2pB0 IM0 rX0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0|15e5","Asia/Amman|LMT EET EEST|-2n.I -20 -30|0121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-1yW2n.I 1HiMn.I KL0 1oN0 11b0 1oN0 11b0 1pd0 1dz0 1cp0 11b0 1op0 11b0 fO10 1db0 1e10 1cL0 1cN0 1cL0 1cN0 1fz0 1pd0 10n0 1ld0 14n0 1hB0 15b0 1ip0 19X0 1cN0 1cL0 1cN0 17b0 1ld0 14o0 1lc0 17c0 1io0 17c0 1io0 17c0 1So0 y00 1fc0 1dc0 1co0 1dc0 1cM0 1cM0 1cM0 1o00 11A0 1lc0 17c0 1cM0 1cM0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 4bX0 Dd0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0|25e5","Asia/Anadyr|LMT +12 +13 +14 +11|-bN.U -c0 -d0 -e0 -b0|01232121212121212121214121212121212121212121212121212121212141|-1PcbN.U eUnN.U 23CL0 1db0 2q10 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 2pB0 IM0 rX0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 2sp0 WM0|13e3","Asia/Aqtau|LMT +04 +05 +06|-3l.4 -40 -50 -60|012323232323232323232123232312121212121212121212|-1Pc3l.4 eUnl.4 24PX0 2pX0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 2pB0 IM0 rX0 1cM0 1cM0 1cM0 1cM0 1cM0 1cN0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0|15e4","Asia/Aqtobe|LMT +04 +05 +06|-3M.E -40 -50 -60|0123232323232323232321232323232323232323232323232|-1Pc3M.E eUnM.E 23CL0 3Db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 2pB0 IM0 rX0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0|27e4","Asia/Ashgabat|LMT +04 +05 +06|-3R.w -40 -50 -60|0123232323232323232323212|-1Pc3R.w eUnR.w 23CL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 2pB0 IM0|41e4","Asia/Atyrau|LMT +03 +05 +06 +04|-3r.I -30 -50 -60 -40|01232323232323232323242323232323232324242424242|-1Pc3r.I eUor.I 24PW0 2pX0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 2pB0 IM0 rX0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 2sp0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0|","Asia/Baghdad|BMT +03 +04|-2V.A -30 -40|012121212121212121212121212121212121212121212121212121|-26BeV.A 2ACnV.A 11b0 1cp0 1dz0 1dd0 1db0 1cN0 1cp0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1de0 1dc0 1dc0 1dc0 1cM0 1dc0 1cM0 1dc0 1cM0 1dc0 1dc0 1dc0 1cM0 1dc0 1cM0 1dc0 1cM0 1dc0 1dc0 1dc0 1cM0 1dc0 1cM0 1dc0 1cM0 1dc0 1dc0 1dc0 1cM0 1dc0 1cM0 1dc0 1cM0 1dc0|66e5","Asia/Qatar|LMT +04 +03|-3q.8 -40 -30|012|-21Jfq.8 27BXq.8|96e4","Asia/Baku|LMT +03 +04 +05|-3j.o -30 -40 -50|01232323232323232323232123232323232323232323232323232323232323232|-1Pc3j.o 1jUoj.o WCL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 2pB0 1cM0 9Je0 1o00 11z0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00|27e5","Asia/Bangkok|BMT +07|-6G.4 -70|01|-218SG.4|15e6","Asia/Barnaul|LMT +06 +07 +08|-5z -60 -70 -80|0123232323232323232323212323232321212121212121212121212121212121212|-21S5z pCnz 23CL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 2pB0 IM0 rX0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 p90 LE0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 8Hz0 3rd0|","Asia/Beirut|EET EEST|-20 -30|010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010|-21aq0 1on0 1410 1db0 19B0 1in0 1ip0 WL0 1lQp0 11b0 1oN0 11b0 1oN0 11b0 1pd0 11b0 1oN0 11b0 q6N0 En0 1oN0 11b0 1oN0 11b0 1oN0 11b0 1pd0 11b0 1oN0 11b0 1op0 11b0 dA10 17b0 1iN0 17b0 1iN0 17b0 1iN0 17b0 1vB0 SL0 1mp0 13z0 1iN0 17b0 1iN0 17b0 1jd0 12n0 1a10 1cL0 1cN0 1cL0 1cN0 1cL0 1fB0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0|22e5","Asia/Bishkek|LMT +05 +06 +07|-4W.o -50 -60 -70|012323232323232323232321212121212121212121212121212|-1Pc4W.o eUnW.o 23CL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 2e00 1tX0 17b0 1ip0 17b0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1cPu 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0|87e4","Asia/Brunei|LMT +0730 +08|-7D.E -7u -80|012|-1KITD.E gDc9.E|42e4","Asia/Kolkata|MMT IST +0630|-5l.a -5u -6u|012121|-2zOtl.a 1r2LP.a 1un0 HB0 7zX0|15e6","Asia/Chita|LMT +08 +09 +10|-7x.Q -80 -90 -a0|012323232323232323232321232323232323232323232323232323232323232312|-21Q7x.Q pAnx.Q 23CL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 2pB0 IM0 rX0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 8Hz0 3re0|33e4","Asia/Choibalsan|LMT +07 +08 +10 +09|-7C -70 -80 -a0 -90|0123434343434343434343434343434343434343434343424242|-2APHC 2UkoC cKn0 1da0 1dd0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1fB0 1cL0 1cN0 1cL0 1cN0 1cL0 6hD0 11z0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 3Db0 h1f0 1cJ0 1cP0 1cJ0|38e3","Asia/Shanghai|CST CDT|-80 -90|010101010101010101010101010|-1c2w0 Rz0 11d0 1wL0 A10 8HX0 1G10 Tz0 1ip0 1jX0 1cN0 11b0 1oN0 aL0 1tU30 Rb0 1o10 11z0 1qN0 WL0 1qN0 11z0 1o10 11z0 1o10 11z0|23e6","Asia/Colombo|MMT +0530 +06 +0630|-5j.w -5u -60 -6u|01231321|-2zOtj.w 1rFbN.w 1zzu 7Apu 23dz0 11zu n3cu|22e5","Asia/Dhaka|HMT +0630 +0530 +06 +07|-5R.k -6u -5u -60 -70|0121343|-18LFR.k 1unn.k HB0 m6n0 2kxbu 1i00|16e6","Asia/Damascus|LMT EET EEST|-2p.c -20 -30|01212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-21Jep.c Hep.c 17b0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1xRB0 11X0 1oN0 10L0 1pB0 11b0 1oN0 10L0 1mp0 13X0 1oN0 11b0 1pd0 11b0 1oN0 11b0 1oN0 11b0 1oN0 11b0 1pd0 11b0 1oN0 11b0 1oN0 11b0 1oN0 11b0 1pd0 11b0 1oN0 Nb0 1AN0 Nb0 bcp0 19X0 1gp0 19X0 3ld0 1xX0 Vd0 1Bz0 Sp0 1vX0 10p0 1dz0 1cN0 1cL0 1db0 1db0 1g10 1an0 1ap0 1db0 1fd0 1db0 1cN0 1db0 1dd0 1db0 1cp0 1dz0 1c10 1dX0 1cN0 1db0 1dd0 1db0 1cN0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1db0 1cN0 1db0 1cN0 19z0 1fB0 1qL0 11B0 1on0 Wp0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0|26e5","Asia/Dili|LMT +08 +09|-8m.k -80 -90|01212|-2le8m.k 1dnXm.k 1nfA0 Xld0|19e4","Asia/Dubai|LMT +04|-3F.c -40|01|-21JfF.c|39e5","Asia/Dushanbe|LMT +05 +06 +07|-4z.c -50 -60 -70|012323232323232323232321|-1Pc4z.c eUnz.c 23CL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 2hB0|76e4","Asia/Famagusta|LMT EET EEST +03|-2f.M -20 -30 -30|0121212121212121212121212121212121212121212121212121212121212121212121212121212121212312121212121212121212121212121212121212121|-1Vc2f.M 2a3cf.M 1cL0 1qp0 Xz0 19B0 19X0 1fB0 1db0 1cp0 1cL0 1fB0 19X0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1fB0 1cL0 1cN0 1cL0 1cN0 1o30 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 15U0 2Ks0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|","Asia/Gaza|EET EEST IST IDT|-20 -30 -20 -30|0101010101010101010101010101010123232323232323232323232323232320101010101010101010101010101010101010101010101010101010101010101010101010101010101010|-1c2q0 5Rb0 10r0 1px0 10N0 1pz0 16p0 1jB0 16p0 1jx0 pBd0 Vz0 1oN0 11b0 1oO0 10N0 1pz0 10N0 1pb0 10N0 1pb0 10N0 1pb0 10N0 1pz0 10N0 1pb0 10N0 1pb0 11d0 1oL0 dW0 hfB0 Db0 1fB0 Rb0 bXd0 gM0 8Q00 IM0 1wM0 11z0 1C10 IL0 1s10 10n0 1o10 WL0 1zd0 On0 1ld0 11z0 1o10 14n0 1o10 14n0 1nd0 12n0 1nd0 Xz0 1q10 12n0 M10 C00 17c0 1io0 17c0 1io0 17c0 1o00 1cL0 1fB0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 17c0 1io0 18N0 1bz0 19z0 1gp0 1610 1iL0 11z0 1o10 14o0 1lA1 SKX 1xd1 MKX 1AN0 1a00 1fA0 1cL0 1cN0 1nX0 1210 1nz0 1220 1qL0 WN0 1qL0 WN0 1qL0 11c0 1oo0 11c0 1rc0 Wo0 1rc0 Wo0 1rc0 11c0 1oo0 11c0 1oo0 11c0 1oo0 11c0 1rc0 Wo0 1rc0 11c0 1oo0 11c0 1oo0 11c0 1oo0 11c0 1oo0 11c0 1rc0 Wo0 1rc0 11c0 1oo0 11c0 1oo0 11c0 1oo0 11c0 1rc0|18e5","Asia/Hebron|EET EEST IST IDT|-20 -30 -20 -30|010101010101010101010101010101012323232323232323232323232323232010101010101010101010101010101010101010101010101010101010101010101010101010101010101010|-1c2q0 5Rb0 10r0 1px0 10N0 1pz0 16p0 1jB0 16p0 1jx0 pBd0 Vz0 1oN0 11b0 1oO0 10N0 1pz0 10N0 1pb0 10N0 1pb0 10N0 1pb0 10N0 1pz0 10N0 1pb0 10N0 1pb0 11d0 1oL0 dW0 hfB0 Db0 1fB0 Rb0 bXd0 gM0 8Q00 IM0 1wM0 11z0 1C10 IL0 1s10 10n0 1o10 WL0 1zd0 On0 1ld0 11z0 1o10 14n0 1o10 14n0 1nd0 12n0 1nd0 Xz0 1q10 12n0 M10 C00 17c0 1io0 17c0 1io0 17c0 1o00 1cL0 1fB0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 17c0 1io0 18N0 1bz0 19z0 1gp0 1610 1iL0 12L0 1mN0 14o0 1lc0 Tb0 1xd1 MKX bB0 cn0 1cN0 1a00 1fA0 1cL0 1cN0 1nX0 1210 1nz0 1220 1qL0 WN0 1qL0 WN0 1qL0 11c0 1oo0 11c0 1rc0 Wo0 1rc0 Wo0 1rc0 11c0 1oo0 11c0 1oo0 11c0 1oo0 11c0 1rc0 Wo0 1rc0 11c0 1oo0 11c0 1oo0 11c0 1oo0 11c0 1oo0 11c0 1rc0 Wo0 1rc0 11c0 1oo0 11c0 1oo0 11c0 1oo0 11c0 1rc0|25e4","Asia/Ho_Chi_Minh|LMT PLMT +07 +08 +09|-76.E -76.u -70 -80 -90|0123423232|-2yC76.E bK00.a 1h7b6.u 5lz0 18o0 3Oq0 k5b0 aW00 BAM0|90e5","Asia/Hong_Kong|LMT HKT HKST HKWT JST|-7A.G -80 -90 -8u -90|0123412121212121212121212121212121212121212121212121212121212121212121|-2CFH0 1taO0 Hc0 xUu 9tBu 11z0 1tDu Rc0 1wo0 11A0 1cM0 11A0 1o00 11A0 1o00 11A0 1o00 14o0 1o00 11A0 1nX0 U10 1tz0 U10 1wn0 Rd0 1wn0 U10 1tz0 U10 1tz0 U10 1tz0 U10 1wn0 Rd0 1wn0 Rd0 1wn0 U10 1tz0 U10 1tz0 17d0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 s10 1Vz0 1cN0 1cL0 1cN0 1cL0 6fd0 14n0|73e5","Asia/Hovd|LMT +06 +07 +08|-66.A -60 -70 -80|012323232323232323232323232323232323232323232323232|-2APG6.A 2Uko6.A cKn0 1db0 1dd0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1fB0 1cL0 1cN0 1cL0 1cN0 1cL0 6hD0 11z0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 kEp0 1cJ0 1cP0 1cJ0|81e3","Asia/Irkutsk|IMT +07 +08 +09|-6V.5 -70 -80 -90|01232323232323232323232123232323232323232323232323232323232323232|-21zGV.5 pjXV.5 23CL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 2pB0 IM0 rX0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 8Hz0|60e4","Europe/Istanbul|IMT EET EEST +03 +04|-1U.U -20 -30 -30 -40|0121212121212121212121212121212121212121212121234312121212121212121212121212121212121212121212121212121212121212123|-2ogNU.U dzzU.U 11b0 8tB0 1on0 1410 1db0 19B0 1in0 3Rd0 Un0 1oN0 11b0 zSN0 CL0 mp0 1Vz0 1gN0 8yn0 1yp0 ML0 1kp0 17b0 1ip0 17b0 1fB0 19X0 1ip0 19X0 1ip0 17b0 qdB0 38L0 1jd0 Tz0 l6O0 11A0 WN0 1qL0 TB0 1tX0 U10 1tz0 11B0 1in0 17d0 z90 cne0 pb0 2Cp0 1800 14o0 1dc0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1a00 1fA0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WO0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 Xc0 1qo0 WM0 1qM0 11A0 1o00 1200 1nA0 11A0 1tA0 U00 15w0|13e6","Asia/Jakarta|BMT +0720 +0730 +09 +08 WIB|-77.c -7k -7u -90 -80 -70|01232425|-1Q0Tk luM0 mPzO 8vWu 6kpu 4PXu xhcu|31e6","Asia/Jayapura|LMT +09 +0930 WIT|-9m.M -90 -9u -90|0123|-1uu9m.M sMMm.M L4nu|26e4","Asia/Jerusalem|JMT IST IDT IDDT|-2k.E -20 -30 -40|012121212121321212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-26Bek.E SyMk.E 5Rb0 10r0 1px0 10N0 1pz0 16p0 1jB0 16p0 1jx0 3LB0 Em0 or0 1cn0 1dB0 16n0 10O0 1ja0 1tC0 14o0 1cM0 1a00 11A0 1Na0 An0 1MP0 AJ0 1Kp0 LC0 1oo0 Wl0 EQN0 Db0 1fB0 Rb0 bXd0 gM0 8Q00 IM0 1wM0 11z0 1C10 IL0 1s10 10n0 1o10 WL0 1zd0 On0 1ld0 11z0 1o10 14n0 1o10 14n0 1nd0 12n0 1nd0 Xz0 1q10 12n0 1hB0 1dX0 1ep0 1aL0 1eN0 17X0 1nf0 11z0 1tB0 19W0 1e10 17b0 1ep0 1gL0 18N0 1fz0 1eN0 17b0 1gq0 1gn0 19d0 1dz0 1c10 17X0 1hB0 1gn0 19d0 1dz0 1c10 17X0 1kp0 1dz0 1c10 1aL0 1eN0 1oL0 10N0 1oL0 10N0 1oL0 10N0 1rz0 W10 1rz0 W10 1rz0 10N0 1oL0 10N0 1oL0 10N0 1rz0 W10 1rz0 W10 1rz0 10N0 1oL0 10N0 1oL0 10N0 1oL0 10N0 1rz0 W10 1rz0 W10 1rz0 10N0 1oL0 10N0 1oL0 10N0 1rz0 W10 1rz0 W10 1rz0 W10 1rz0 10N0 1oL0 10N0 1oL0|81e4","Asia/Kabul|+04 +0430|-40 -4u|01|-10Qs0|46e5","Asia/Kamchatka|LMT +11 +12 +13|-ay.A -b0 -c0 -d0|012323232323232323232321232323232323232323232323232323232323212|-1SLKy.A ivXy.A 23CL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 2pB0 IM0 rX0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 2sp0 WM0|18e4","Asia/Karachi|LMT +0530 +0630 +05 PKT PKST|-4s.c -5u -6u -50 -50 -60|012134545454|-2xoss.c 1qOKW.c 7zX0 eup0 LqMu 1fy00 1cL0 dK10 11b0 1610 1jX0|24e6","Asia/Urumqi|LMT +06|-5O.k -60|01|-1GgtO.k|32e5","Asia/Kathmandu|LMT +0530 +0545|-5F.g -5u -5J|012|-21JhF.g 2EGMb.g|12e5","Asia/Khandyga|LMT +08 +09 +10 +11|-92.d -80 -90 -a0 -b0|0123232323232323232323212323232323232323232323232343434343434343432|-21Q92.d pAp2.d 23CL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 2pB0 IM0 rX0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 qK0 yN0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 17V0 7zD0|66e2","Asia/Krasnoyarsk|LMT +06 +07 +08|-6b.q -60 -70 -80|01232323232323232323232123232323232323232323232323232323232323232|-21Hib.q prAb.q 23CL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 2pB0 IM0 rX0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 8Hz0|10e5","Asia/Kuala_Lumpur|SMT +07 +0720 +0730 +09 +08|-6T.p -70 -7k -7u -90 -80|0123435|-2Bg6T.p 17anT.p l5XE 17bO 8Fyu 1so1u|71e5","Asia/Kuching|LMT +0730 +08 +0820 +09|-7l.k -7u -80 -8k -90|0123232323232323242|-1KITl.k gDbP.k 6ynu AnE 1O0k AnE 1NAk AnE 1NAk AnE 1NAk AnE 1O0k AnE 1NAk AnE pAk 8Fz0|13e4","Asia/Macau|LMT CST +09 +10 CDT|-7y.a -80 -90 -a0 -90|012323214141414141414141414141414141414141414141414141414141414141414141|-2CFHy.a 1uqKy.a PX0 1kn0 15B0 11b0 4Qq0 1oM0 11c0 1ko0 1u00 11A0 1cM0 11c0 1o00 11A0 1o00 11A0 1oo0 1400 1o00 11A0 1o00 U00 1tA0 U00 1wo0 Rc0 1wru U10 1tz0 U10 1tz0 U10 1tz0 U10 1wn0 Rd0 1wn0 Rd0 1wn0 U10 1tz0 U10 1tz0 17d0 1cK0 1cO0 1cK0 1cO0 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 s10 1Vz0 1cN0 1cL0 1cN0 1cL0 6fd0 14n0|57e4","Asia/Magadan|LMT +10 +11 +12|-a3.c -a0 -b0 -c0|012323232323232323232321232323232323232323232323232323232323232312|-1Pca3.c eUo3.c 23CL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 2pB0 IM0 rX0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 8Hz0 3Cq0|95e3","Asia/Makassar|LMT MMT +08 +09 WITA|-7V.A -7V.A -80 -90 -80|01234|-21JjV.A vfc0 myLV.A 8ML0|15e5","Asia/Manila|PST PDT JST|-80 -90 -90|010201010|-1kJI0 AL0 cK10 65X0 mXB0 vX0 VK10 1db0|24e6","Asia/Nicosia|LMT EET EEST|-2d.s -20 -30|01212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-1Vc2d.s 2a3cd.s 1cL0 1qp0 Xz0 19B0 19X0 1fB0 1db0 1cp0 1cL0 1fB0 19X0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1fB0 1cL0 1cN0 1cL0 1cN0 1o30 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|32e4","Asia/Novokuznetsk|LMT +06 +07 +08|-5M.M -60 -70 -80|012323232323232323232321232323232323232323232323232323232323212|-1PctM.M eULM.M 23CL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 2pB0 IM0 rX0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 2sp0 WM0|55e4","Asia/Novosibirsk|LMT +06 +07 +08|-5v.E -60 -70 -80|0123232323232323232323212323212121212121212121212121212121212121212|-21Qnv.E pAFv.E 23CL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 2pB0 IM0 rX0 1cM0 1cM0 ml0 Os0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 8Hz0 4eN0|15e5","Asia/Omsk|LMT +05 +06 +07|-4R.u -50 -60 -70|01232323232323232323232123232323232323232323232323232323232323232|-224sR.u pMLR.u 23CL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 2pB0 IM0 rX0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 8Hz0|12e5","Asia/Oral|LMT +03 +05 +06 +04|-3p.o -30 -50 -60 -40|01232323232323232424242424242424242424242424242|-1Pc3p.o eUop.o 23CK0 3Db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 2pB0 1cM0 1fA0 1cM0 1cM0 IM0 1EM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0|27e4","Asia/Pontianak|LMT PMT +0730 +09 +08 WITA WIB|-7h.k -7h.k -7u -90 -80 -80 -70|012324256|-2ua7h.k XE00 munL.k 8Rau 6kpu 4PXu xhcu Wqnu|23e4","Asia/Pyongyang|LMT KST JST KST|-8n -8u -90 -90|012313|-2um8n 97XR 1lTzu 2Onc0 6BA0|29e5","Asia/Qostanay|LMT +04 +05 +06|-4e.s -40 -50 -60|012323232323232323232123232323232323232323232323|-1Pc4e.s eUoe.s 23CL0 3Db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 2pB0 IM0 rX0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0|","Asia/Qyzylorda|LMT +04 +05 +06|-4l.Q -40 -50 -60|01232323232323232323232323232323232323232323232|-1Pc4l.Q eUol.Q 23CL0 3Db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 3ao0 1EM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 zQl0|73e4","Asia/Rangoon|RMT +0630 +09|-6o.L -6u -90|0121|-21Jio.L SmnS.L 7j9u|48e5","Asia/Sakhalin|LMT +09 +11 +12 +10|-9u.M -90 -b0 -c0 -a0|01232323232323232323232423232323232424242424242424242424242424242|-2AGVu.M 1BoMu.M 1qFa0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 2pB0 IM0 rX0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 2pB0 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 8Hz0 3rd0|58e4","Asia/Samarkand|LMT +04 +05 +06|-4r.R -40 -50 -60|01232323232323232323232|-1Pc4r.R eUor.R 23CL0 3Db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0|36e4","Asia/Seoul|LMT KST JST KST KDT KDT|-8r.Q -8u -90 -90 -a0 -9u|012343434343151515151515134343|-2um8r.Q 97XV.Q 1m1zu 6CM0 Fz0 1kN0 14n0 1kN0 14L0 1zd0 On0 69B0 2I0u OL0 1FB0 Rb0 1qN0 TX0 1tB0 TX0 1tB0 TX0 1tB0 TX0 2ap0 12FBu 11A0 1o00 11A0|23e6","Asia/Srednekolymsk|LMT +10 +11 +12|-ae.Q -a0 -b0 -c0|01232323232323232323232123232323232323232323232323232323232323232|-1Pcae.Q eUoe.Q 23CL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 2pB0 IM0 rX0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 8Hz0|35e2","Asia/Taipei|CST JST CDT|-80 -90 -90|01020202020202020202020202020202020202020|-1iw80 joM0 1yo0 Tz0 1ip0 1jX0 1cN0 11b0 1oN0 11b0 1oN0 11b0 1oN0 11b0 10N0 1BX0 10p0 1pz0 10p0 1pz0 10p0 1db0 1dd0 1db0 1cN0 1db0 1cN0 1db0 1cN0 1db0 1BB0 ML0 1Bd0 ML0 uq10 1db0 1cN0 1db0 97B0 AL0|74e5","Asia/Tashkent|LMT +05 +06 +07|-4B.b -50 -60 -70|012323232323232323232321|-1Pc4B.b eUnB.b 23CL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 2pB0|23e5","Asia/Tbilisi|TBMT +03 +04 +05|-2X.b -30 -40 -50|0123232323232323232323212121232323232323232323212|-1Pc2X.b 1jUnX.b WCL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 2pB0 1cK0 1cL0 1cN0 1cL0 1cN0 2pz0 1cL0 1fB0 3Nz0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 An0 Os0 WM0|11e5","Asia/Tehran|LMT TMT +0330 +04 +05 +0430|-3p.I -3p.I -3u -40 -50 -4u|01234325252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252|-2btDp.I 1d3c0 1huLT.I TXu 1pz0 sN0 vAu 1cL0 1dB0 1en0 pNB0 UL0 1cN0 1dz0 1cp0 1dz0 1cp0 1dz0 1cp0 1dz0 1cp0 1dz0 1cN0 1dz0 1cp0 1dz0 1cp0 1dz0 1cp0 1dz0 1cN0 1dz0 1cp0 1dz0 1cp0 1dz0 1cp0 1dz0 1cN0 1dz0 64p0 1dz0 1cN0 1dz0 1cp0 1dz0 1cp0 1dz0 1cp0 1dz0 1cN0 1dz0 1cp0 1dz0 1cp0 1dz0 1cp0 1dz0 1cN0 1dz0 1cp0 1dz0 1cp0 1dz0 1cp0 1dz0 1cN0 1dz0 1cp0 1dz0 1cp0 1dz0 1cp0 1dz0 1cN0 1dz0 1cp0 1dz0 1cp0 1dz0 1cp0 1dz0 1cp0 1dz0 1cN0 1dz0 1cp0 1dz0 1cp0 1dz0 1cp0 1dz0 1cN0 1dz0 1cp0 1dz0 1cp0 1dz0 1cp0 1dz0|14e6","Asia/Thimphu|LMT +0530 +06|-5W.A -5u -60|012|-Su5W.A 1BGMs.A|79e3","Asia/Tokyo|JST JDT|-90 -a0|010101010|-QJJ0 Rc0 1lc0 14o0 1zc0 Oo0 1zc0 Oo0|38e6","Asia/Tomsk|LMT +06 +07 +08|-5D.P -60 -70 -80|0123232323232323232323212323232323232323232323212121212121212121212|-21NhD.P pxzD.P 23CL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 2pB0 IM0 rX0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 co0 1bB0 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 8Hz0 3Qp0|10e5","Asia/Ulaanbaatar|LMT +07 +08 +09|-77.w -70 -80 -90|012323232323232323232323232323232323232323232323232|-2APH7.w 2Uko7.w cKn0 1db0 1dd0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1fB0 1cL0 1cN0 1cL0 1cN0 1cL0 6hD0 11z0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 kEp0 1cJ0 1cP0 1cJ0|12e5","Asia/Ust-Nera|LMT +08 +09 +12 +11 +10|-9w.S -80 -90 -c0 -b0 -a0|012343434343434343434345434343434343434343434343434343434343434345|-21Q9w.S pApw.S 23CL0 1d90 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 2pB0 IM0 rX0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 17V0 7zD0|65e2","Asia/Vladivostok|LMT +09 +10 +11|-8L.v -90 -a0 -b0|01232323232323232323232123232323232323232323232323232323232323232|-1SJIL.v itXL.v 23CL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 2pB0 IM0 rX0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 8Hz0|60e4","Asia/Yakutsk|LMT +08 +09 +10|-8C.W -80 -90 -a0|01232323232323232323232123232323232323232323232323232323232323232|-21Q8C.W pAoC.W 23CL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 2pB0 IM0 rX0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 8Hz0|28e4","Asia/Yekaterinburg|LMT PMT +04 +05 +06|-42.x -3J.5 -40 -50 -60|012343434343434343434343234343434343434343434343434343434343434343|-2ag42.x 7mQh.s qBvJ.5 23CL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 2pB0 IM0 rX0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 8Hz0|14e5","Asia/Yerevan|LMT +03 +04 +05|-2W -30 -40 -50|0123232323232323232323212121212323232323232323232323232323232|-1Pc2W 1jUnW WCL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 2pB0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 4RX0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0|13e5","Atlantic/Azores|HMT -02 -01 +00 WET|1S.w 20 10 0 0|01212121212121212121212121212121212121212121232123212321232121212121212121212121212121212121212121232323232323232323232323232323234323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232|-2ldW0 aPX0 Sp0 LX0 1vc0 Tc0 1uM0 SM0 1vc0 Tc0 1vc0 SM0 1vc0 6600 1co0 3E00 17c0 1fA0 1a00 1io0 1a00 1io0 17c0 3I00 17c0 1cM0 1cM0 3Fc0 1cM0 1a00 1fA0 1io0 17c0 1cM0 1cM0 1a00 1fA0 1io0 1qM0 Dc0 1tA0 1cM0 1dc0 1400 gL0 IM0 s10 U00 dX0 Rc0 pd0 Rc0 gL0 Oo0 pd0 Rc0 gL0 Oo0 pd0 14o0 1cM0 1cP0 1cM0 1cM0 1cM0 1cM0 1cM0 3Co0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 qIl0 1cM0 1fA0 1cM0 1cM0 1cN0 1cL0 1cN0 1cM0 1cM0 1cM0 1cM0 1cN0 1cL0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cL0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|25e4","Atlantic/Bermuda|LMT AST ADT|4j.i 40 30|0121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-1BnRE.G 1LTbE.G 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|65e3","Atlantic/Canary|LMT -01 WET WEST|11.A 10 0 -10|01232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232|-1UtaW.o XPAW.o 1lAK0 1a10 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|54e4","Atlantic/Cape_Verde|LMT -02 -01|1y.4 20 10|01212|-2ldW0 1eEo0 7zX0 1djf0|50e4","Atlantic/Faroe|LMT WET WEST|r.4 0 -10|01212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-2uSnw.U 2Wgow.U 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|49e3","Atlantic/Madeira|FMT -01 +00 +01 WET WEST|17.A 10 0 -10 0 -10|01212121212121212121212121212121212121212121232123212321232121212121212121212121212121212121212121454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454|-2ldX0 aPX0 Sp0 LX0 1vc0 Tc0 1uM0 SM0 1vc0 Tc0 1vc0 SM0 1vc0 6600 1co0 3E00 17c0 1fA0 1a00 1io0 1a00 1io0 17c0 3I00 17c0 1cM0 1cM0 3Fc0 1cM0 1a00 1fA0 1io0 17c0 1cM0 1cM0 1a00 1fA0 1io0 1qM0 Dc0 1tA0 1cM0 1dc0 1400 gL0 IM0 s10 U00 dX0 Rc0 pd0 Rc0 gL0 Oo0 pd0 Rc0 gL0 Oo0 pd0 14o0 1cM0 1cP0 1cM0 1cM0 1cM0 1cM0 1cM0 3Co0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 qIl0 1cM0 1fA0 1cM0 1cM0 1cN0 1cL0 1cN0 1cM0 1cM0 1cM0 1cM0 1cN0 1cL0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|27e4","Atlantic/Reykjavik|LMT -01 +00 GMT|1s 10 0 0|012121212121212121212121212121212121212121212121212121212121212121213|-2uWmw mfaw 1Bd0 ML0 1LB0 Cn0 1LB0 3fX0 C10 HrX0 1cO0 LB0 1EL0 LA0 1C00 Oo0 1wo0 Rc0 1wo0 Rc0 1wo0 Rc0 1zc0 Oo0 1zc0 14o0 1lc0 14o0 1lc0 14o0 1o00 11A0 1lc0 14o0 1o00 14o0 1lc0 14o0 1lc0 14o0 1lc0 14o0 1lc0 14o0 1o00 14o0 1lc0 14o0 1lc0 14o0 1lc0 14o0 1lc0 14o0 1lc0 14o0 1o00 14o0 1lc0 14o0 1lc0 14o0 1lc0 14o0 1lc0 14o0 1o00 14o0|12e4","Atlantic/South_Georgia|-02|20|0||30","Atlantic/Stanley|SMT -04 -03 -02|3P.o 40 30 20|012121212121212323212121212121212121212121212121212121212121212121212|-2kJw8.A 12bA8.A 19X0 1fB0 19X0 1ip0 19X0 1fB0 19X0 1fB0 19X0 1fB0 Cn0 1Cc10 WL0 1qL0 U10 1tz0 2mN0 WN0 1qL0 WN0 1qL0 WN0 1qL0 WN0 1tz0 U10 1tz0 WN0 1qL0 WN0 1qL0 WN0 1qL0 WN0 1qL0 WN0 1tz0 WN0 1qL0 WN0 1qL0 WN0 1qL0 WN0 1qL0 WN0 1qN0 U10 1wn0 Rd0 1wn0 U10 1tz0 U10 1tz0 U10 1tz0 U10 1tz0 U10 1wn0 U10 1tz0 U10 1tz0 U10|21e2","Australia/Sydney|AEST AEDT|-a0 -b0|0101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101|-293lX xcX 10jd0 yL0 1cN0 1cL0 1fB0 19X0 17c10 LA0 1C00 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 14o0 1o00 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 U00 1qM0 WM0 1tA0 WM0 1tA0 U00 1tA0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 11A0 1o00 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 11A0 1o00 WM0 1qM0 14o0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0|40e5","Australia/Adelaide|ACST ACDT|-9u -au|0101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101|-293lt xcX 10jd0 yL0 1cN0 1cL0 1fB0 19X0 17c10 LA0 1C00 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 U00 1qM0 WM0 1tA0 WM0 1tA0 U00 1tA0 U00 1tA0 Oo0 1zc0 WM0 1qM0 Rc0 1zc0 U00 1tA0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 11A0 1o00 WM0 1qM0 14o0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0|11e5","Australia/Brisbane|AEST AEDT|-a0 -b0|01010101010101010|-293lX xcX 10jd0 yL0 1cN0 1cL0 1fB0 19X0 17c10 LA0 H1A0 Oo0 1zc0 Oo0 1zc0 Oo0|20e5","Australia/Broken_Hill|ACST ACDT|-9u -au|0101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101|-293lt xcX 10jd0 yL0 1cN0 1cL0 1fB0 19X0 17c10 LA0 1C00 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 14o0 1o00 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 U00 1qM0 WM0 1tA0 WM0 1tA0 U00 1tA0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 11A0 1o00 WM0 1qM0 14o0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0|18e3","Australia/Currie|AEST AEDT|-a0 -b0|0101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101|-29E80 19X0 10jd0 yL0 1cN0 1cL0 1fB0 19X0 17c10 LA0 1C00 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 11A0 1qM0 WM0 1qM0 Oo0 1zc0 Oo0 1zc0 Oo0 1wo0 WM0 1tA0 WM0 1tA0 U00 1tA0 U00 1tA0 11A0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 11A0 1o00 1io0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1cM0 1a00 1io0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0|746","Australia/Darwin|ACST ACDT|-9u -au|010101010|-293lt xcX 10jd0 yL0 1cN0 1cL0 1fB0 19X0|12e4","Australia/Eucla|+0845 +0945|-8J -9J|0101010101010101010|-293kI xcX 10jd0 yL0 1cN0 1cL0 1gSp0 Oo0 l5A0 Oo0 iJA0 G00 zU00 IM0 1qM0 11A0 1o00 11A0|368","Australia/Hobart|AEST AEDT|-a0 -b0|010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101|-29E80 19X0 10jd0 yL0 1cN0 1cL0 1fB0 19X0 VfB0 1cM0 1o00 Rc0 1wo0 Rc0 1wo0 U00 1wo0 LA0 1C00 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 11A0 1qM0 WM0 1qM0 Oo0 1zc0 Oo0 1zc0 Oo0 1wo0 WM0 1tA0 WM0 1tA0 U00 1tA0 U00 1tA0 11A0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 11A0 1o00 1io0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1cM0 1a00 1io0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0|21e4","Australia/Lord_Howe|AEST +1030 +1130 +11|-a0 -au -bu -b0|0121212121313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313|raC0 1zdu Rb0 1zd0 On0 1zd0 On0 1zd0 On0 1zd0 TXu 1qMu WLu 1tAu WLu 1tAu TXu 1tAu Onu 1zcu Onu 1zcu Onu 1zcu Rbu 1zcu Onu 1zcu Onu 1zcu 11zu 1o0u 11zu 1o0u 11zu 1o0u 11zu 1qMu WLu 11Au 1nXu 1qMu 11zu 1o0u 11zu 1o0u 11zu 1qMu WLu 1qMu 11zu 1o0u WLu 1qMu 14nu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1fAu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1fAu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1fzu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1fAu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1fAu 1cLu 1cMu 1cLu 1cMu|347","Australia/Lindeman|AEST AEDT|-a0 -b0|010101010101010101010|-293lX xcX 10jd0 yL0 1cN0 1cL0 1fB0 19X0 17c10 LA0 H1A0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0|10","Australia/Melbourne|AEST AEDT|-a0 -b0|0101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101|-293lX xcX 10jd0 yL0 1cN0 1cL0 1fB0 19X0 17c10 LA0 1C00 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 U00 1qM0 WM0 1qM0 11A0 1tA0 U00 1tA0 U00 1tA0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 11A0 1o00 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 11A0 1o00 WM0 1qM0 14o0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0|39e5","Australia/Perth|AWST AWDT|-80 -90|0101010101010101010|-293jX xcX 10jd0 yL0 1cN0 1cL0 1gSp0 Oo0 l5A0 Oo0 iJA0 G00 zU00 IM0 1qM0 11A0 1o00 11A0|18e5","CET|CET CEST|-10 -20|01010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010|-2aFe0 11d0 1iO0 11A0 1o00 11A0 Qrc0 6i00 WM0 1fA0 1cM0 1cM0 1cM0 16M0 1gMM0 1a00 1fA0 1cM0 1cM0 1cM0 1fA0 1a00 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|","Pacific/Easter|EMT -07 -06 -05|7h.s 70 60 50|012121212121212121212121212123232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323|-1uSgG.w 1s4IG.w WL0 1zd0 On0 1ip0 11z0 1o10 11z0 1qN0 WL0 1ld0 14n0 1qN0 WL0 1qN0 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 WL0 1qN0 11z0 1o10 2pA0 11z0 1o10 11z0 1qN0 WL0 1qN0 WL0 1qN0 1cL0 1cN0 11z0 1o10 11z0 1qN0 WL0 1fB0 19X0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 17b0 1ip0 11z0 1ip0 1fz0 1fB0 11z0 1qN0 WL0 1qN0 WL0 1qN0 WL0 1qN0 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 17b0 1ip0 11z0 1o10 19X0 1fB0 1nX0 G10 1EL0 Op0 1zb0 Rd0 1wn0 Rd0 46n0 Ap0 1Nb0 Ap0 1Nb0 Ap0 1zb0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0|30e2","CST6CDT|CST CDT CWT CPT|60 50 50 50|010102301010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010|-261s0 1nX0 11B0 1nX0 SgN0 8x30 iw0 QwN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 s10 1Vz0 LB0 1BX0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|","EET|EET EEST|-20 -30|010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010|hDB0 1a00 1fA0 1cM0 1cM0 1cM0 1fA0 1a00 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|","Europe/Dublin|DMT IST GMT BST IST|p.l -y.D 0 -10 -10|01232323232324242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242|-2ax9y.D Rc0 1fzy.D 14M0 1fc0 1g00 1co0 1dc0 1co0 1oo0 1400 1dc0 19A0 1io0 1io0 WM0 1o00 14o0 1o00 17c0 1io0 17c0 1fA0 1a00 1lc0 17c0 1io0 17c0 1fA0 1a00 1io0 17c0 1io0 17c0 1fA0 1cM0 1io0 17c0 1fA0 1a00 1io0 17c0 1io0 17c0 1fA0 1a00 1io0 1qM0 Dc0 g600 14o0 1wo0 17c0 1io0 11A0 1o00 17c0 1fA0 1a00 1fA0 1cM0 1fA0 1a00 17c0 1fA0 1a00 1io0 17c0 1lc0 17c0 1fA0 1a00 1io0 17c0 1io0 17c0 1fA0 1a00 1a00 1qM0 WM0 1qM0 11A0 1o00 WM0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1tA0 IM0 90o0 U00 1tA0 U00 1tA0 U00 1tA0 U00 1tA0 WM0 1qM0 WM0 1qM0 WM0 1tA0 U00 1tA0 U00 1tA0 11z0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1o00 14o0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|12e5","EST|EST|50|0||","EST5EDT|EST EDT EWT EPT|50 40 40 40|010102301010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010|-261t0 1nX0 11B0 1nX0 SgN0 8x40 iv0 QwN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 s10 1Vz0 LB0 1BX0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|","Etc/GMT-0|GMT|0|0||","Etc/GMT-1|+01|-10|0||","Pacific/Port_Moresby|+10|-a0|0||25e4","Etc/GMT-11|+11|-b0|0||","Pacific/Tarawa|+12|-c0|0||29e3","Etc/GMT-13|+13|-d0|0||","Etc/GMT-14|+14|-e0|0||","Etc/GMT-2|+02|-20|0||","Etc/GMT-3|+03|-30|0||","Etc/GMT-4|+04|-40|0||","Etc/GMT-5|+05|-50|0||","Etc/GMT-6|+06|-60|0||","Indian/Christmas|+07|-70|0||21e2","Etc/GMT-8|+08|-80|0||","Pacific/Palau|+09|-90|0||21e3","Etc/GMT+1|-01|10|0||","Etc/GMT+10|-10|a0|0||","Etc/GMT+11|-11|b0|0||","Etc/GMT+12|-12|c0|0||","Etc/GMT+3|-03|30|0||","Etc/GMT+4|-04|40|0||","Etc/GMT+5|-05|50|0||","Etc/GMT+6|-06|60|0||","Etc/GMT+7|-07|70|0||","Etc/GMT+8|-08|80|0||","Etc/GMT+9|-09|90|0||","Etc/UTC|UTC|0|0||","Europe/Amsterdam|AMT NST +0120 +0020 CEST CET|-j.w -1j.w -1k -k -20 -10|010101010101010101010101010101010101010101012323234545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545|-2aFcj.w 11b0 1iP0 11A0 1io0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1co0 1io0 1yo0 Pc0 1a00 1fA0 1Bc0 Mo0 1tc0 Uo0 1tA0 U00 1uo0 W00 1s00 VA0 1so0 Vc0 1sM0 UM0 1wo0 Rc0 1u00 Wo0 1rA0 W00 1s00 VA0 1sM0 UM0 1w00 fV0 BCX.w 1tA0 U00 1u00 Wo0 1sm0 601k WM0 1fA0 1cM0 1cM0 1cM0 16M0 1gMM0 1a00 1fA0 1cM0 1cM0 1cM0 1fA0 1a00 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|16e5","Europe/Andorra|WET CET CEST|0 -10 -20|012121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-UBA0 1xIN0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|79e3","Europe/Astrakhan|LMT +03 +04 +05|-3c.c -30 -40 -50|012323232323232323212121212121212121212121212121212121212121212|-1Pcrc.c eUMc.c 23CL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 2pB0 1cM0 1fA0 1cM0 3Co0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 8Hz0 3rd0|10e5","Europe/Athens|AMT EET EEST CEST CET|-1y.Q -20 -30 -20 -10|012123434121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-2a61x.Q CNbx.Q mn0 kU10 9b0 3Es0 Xa0 1fb0 1dd0 k3X0 Nz0 SCp0 1vc0 SO0 1cM0 1a00 1ao0 1fc0 1a10 1fG0 1cg0 1dX0 1bX0 1cQ0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|35e5","Europe/London|GMT BST BDST|0 -10 -20|0101010101010101010101010101010101010101010101010121212121210101210101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010|-2axa0 Rc0 1fA0 14M0 1fc0 1g00 1co0 1dc0 1co0 1oo0 1400 1dc0 19A0 1io0 1io0 WM0 1o00 14o0 1o00 17c0 1io0 17c0 1fA0 1a00 1lc0 17c0 1io0 17c0 1fA0 1a00 1io0 17c0 1io0 17c0 1fA0 1cM0 1io0 17c0 1fA0 1a00 1io0 17c0 1io0 17c0 1fA0 1a00 1io0 1qM0 Dc0 2Rz0 Dc0 1zc0 Oo0 1zc0 Rc0 1wo0 17c0 1iM0 FA0 xB0 1fA0 1a00 14o0 bb0 LA0 xB0 Rc0 1wo0 11A0 1o00 17c0 1fA0 1a00 1fA0 1cM0 1fA0 1a00 17c0 1fA0 1a00 1io0 17c0 1lc0 17c0 1fA0 1a00 1io0 17c0 1io0 17c0 1fA0 1a00 1a00 1qM0 WM0 1qM0 11A0 1o00 WM0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1tA0 IM0 90o0 U00 1tA0 U00 1tA0 U00 1tA0 U00 1tA0 WM0 1qM0 WM0 1qM0 WM0 1tA0 U00 1tA0 U00 1tA0 11z0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1o00 14o0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|10e6","Europe/Belgrade|CET CEST|-10 -20|01010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010|-19RC0 3IP0 WM0 1fA0 1cM0 1cM0 1rc0 Qo0 1vmo0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|12e5","Europe/Berlin|CET CEST CEMT|-10 -20 -30|01010101010101210101210101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010|-2aFe0 11d0 1iO0 11A0 1o00 11A0 Qrc0 6i00 WM0 1fA0 1cM0 1cM0 1cM0 kL0 Nc0 m10 WM0 1ao0 1cp0 dX0 jz0 Dd0 1io0 17c0 1fA0 1a00 1ehA0 1a00 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|41e5","Europe/Prague|CET CEST GMT|-10 -20 0|01010101010101010201010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010|-2aFe0 11d0 1iO0 11A0 1o00 11A0 Qrc0 6i00 WM0 1fA0 1cM0 1cM0 1cM0 1cM0 1qM0 11c0 mp0 xA0 mn0 17c0 1io0 17c0 1fc0 1ao0 1bNc0 1cM0 1fA0 1a00 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|13e5","Europe/Brussels|WET CET CEST WEST|0 -10 -20 -10|0121212103030303030303030303030303030303030303030303212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-2ehc0 3zX0 11c0 1iO0 11A0 1o00 11A0 my0 Ic0 1qM0 Rc0 1EM0 UM0 1u00 10o0 1io0 1io0 17c0 1a00 1fA0 1cM0 1cM0 1io0 17c0 1fA0 1a00 1io0 1a30 1io0 17c0 1fA0 1a00 1io0 17c0 1cM0 1cM0 1a00 1io0 1cM0 1cM0 1a00 1fA0 1io0 17c0 1cM0 1cM0 1a00 1fA0 1io0 1qM0 Dc0 y00 5Wn0 WM0 1fA0 1cM0 16M0 1iM0 16M0 1C00 Uo0 1eeo0 1a00 1fA0 1cM0 1cM0 1cM0 1fA0 1a00 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|21e5","Europe/Bucharest|BMT EET EEST|-1I.o -20 -30|0121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-1xApI.o 20LI.o RA0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1Axc0 On0 1fA0 1a10 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cK0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cL0 1cN0 1cL0 1fB0 1nX0 11E0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|19e5","Europe/Budapest|CET CEST|-10 -20|0101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010|-2aFe0 11d0 1iO0 11A0 1ip0 17b0 1op0 1tb0 Q2m0 3Ne0 WM0 1fA0 1cM0 1cM0 1oJ0 1dc0 1030 1fA0 1cM0 1cM0 1cM0 1cM0 1fA0 1a00 1iM0 1fA0 8Ha0 Rb0 1wN0 Rb0 1BB0 Lz0 1C20 LB0 SNX0 1a10 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|17e5","Europe/Zurich|CET CEST|-10 -20|01010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010|-19Lc0 11A0 1o00 11A0 1xG10 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|38e4","Europe/Chisinau|CMT BMT EET EEST CEST CET MSK MSD|-1T -1I.o -20 -30 -20 -10 -30 -40|012323232323232323234545467676767676767676767323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232|-26jdT wGMa.A 20LI.o RA0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 27A0 2en0 39g0 WM0 1fA0 1cM0 V90 1t7z0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 gL0 WO0 1cM0 1cM0 1cK0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1fB0 1nX0 11D0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|67e4","Europe/Copenhagen|CET CEST|-10 -20|0101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010|-2azC0 Tz0 VuO0 60q0 WM0 1fA0 1cM0 1cM0 1cM0 S00 1HA0 Nc0 1C00 Dc0 1Nc0 Ao0 1h5A0 1a00 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|12e5","Europe/Gibraltar|GMT BST BDST CET CEST|0 -10 -20 -10 -20|010101010101010101010101010101010101010101010101012121212121010121010101010101010101034343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343|-2axa0 Rc0 1fA0 14M0 1fc0 1g00 1co0 1dc0 1co0 1oo0 1400 1dc0 19A0 1io0 1io0 WM0 1o00 14o0 1o00 17c0 1io0 17c0 1fA0 1a00 1lc0 17c0 1io0 17c0 1fA0 1a00 1io0 17c0 1io0 17c0 1fA0 1cM0 1io0 17c0 1fA0 1a00 1io0 17c0 1io0 17c0 1fA0 1a00 1io0 1qM0 Dc0 2Rz0 Dc0 1zc0 Oo0 1zc0 Rc0 1wo0 17c0 1iM0 FA0 xB0 1fA0 1a00 14o0 bb0 LA0 xB0 Rc0 1wo0 11A0 1o00 17c0 1fA0 1a00 1fA0 1cM0 1fA0 1a00 17c0 1fA0 1a00 1io0 17c0 1lc0 17c0 1fA0 10Jz0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|30e3","Europe/Helsinki|HMT EET EEST|-1D.N -20 -30|0121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-1WuND.N OULD.N 1dA0 1xGq0 1cM0 1cM0 1cM0 1cN0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|12e5","Europe/Kaliningrad|CET CEST EET EEST MSK MSD +03|-10 -20 -20 -30 -30 -40 -30|01010101010101232454545454545454543232323232323232323232323232323232323232323262|-2aFe0 11d0 1iO0 11A0 1o00 11A0 Qrc0 6i00 WM0 1fA0 1cM0 1cM0 1cM0 390 7A0 1en0 12N0 1pbb0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cN0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 8Hz0|44e4","Europe/Kiev|KMT EET MSK CEST CET MSD EEST|-22.4 -20 -30 -20 -10 -40 -30|0123434252525252525252525256161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161|-1Pc22.4 eUo2.4 rnz0 2Hg0 WM0 1fA0 da0 1v4m0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 Db0 3220 1cK0 1cL0 1cN0 1cL0 1cN0 1cL0 1cQ0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|34e5","Europe/Kirov|LMT +03 +04 +05|-3i.M -30 -40 -50|01232323232323232321212121212121212121212121212121212121212121|-22WM0 qH90 23CL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 2pB0 1cM0 1fA0 1cM0 3Co0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 8Hz0|48e4","Europe/Lisbon|LMT WET WEST WEMT CET CEST|A.J 0 -10 -20 -10 -20|012121212121212121212121212121212121212121212321232123212321212121212121212121212121212121212121214121212121212121212121212121212124545454212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-2le00 aPX0 Sp0 LX0 1vc0 Tc0 1uM0 SM0 1vc0 Tc0 1vc0 SM0 1vc0 6600 1co0 3E00 17c0 1fA0 1a00 1io0 1a00 1io0 17c0 3I00 17c0 1cM0 1cM0 3Fc0 1cM0 1a00 1fA0 1io0 17c0 1cM0 1cM0 1a00 1fA0 1io0 1qM0 Dc0 1tA0 1cM0 1dc0 1400 gL0 IM0 s10 U00 dX0 Rc0 pd0 Rc0 gL0 Oo0 pd0 Rc0 gL0 Oo0 pd0 14o0 1cM0 1cP0 1cM0 1cM0 1cM0 1cM0 1cM0 3Co0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 pvy0 1cM0 1cM0 1fA0 1cM0 1cM0 1cN0 1cL0 1cN0 1cM0 1cM0 1cM0 1cM0 1cN0 1cL0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|27e5","Europe/Luxembourg|LMT CET CEST WET WEST WEST WET|-o.A -10 -20 0 -10 -20 -10|0121212134343434343434343434343434343434343434343434565651212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-2DG0o.A t6mo.A TB0 1nX0 Up0 1o20 11A0 rW0 CM0 1qP0 R90 1EO0 UK0 1u20 10m0 1ip0 1in0 17e0 19W0 1fB0 1db0 1cp0 1in0 17d0 1fz0 1a10 1in0 1a10 1in0 17f0 1fA0 1a00 1io0 17c0 1cM0 1cM0 1a00 1io0 1cM0 1cM0 1a00 1fA0 1io0 17c0 1cM0 1cM0 1a00 1fA0 1io0 1qM0 Dc0 vA0 60L0 WM0 1fA0 1cM0 17c0 1io0 16M0 1C00 Uo0 1eeo0 1a00 1fA0 1cM0 1cM0 1cM0 1fA0 1a00 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|54e4","Europe/Madrid|WET WEST WEMT CET CEST|0 -10 -20 -10 -20|010101010101010101210343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343|-25Td0 19B0 1cL0 1dd0 b1z0 18p0 3HX0 17d0 1fz0 1a10 1io0 1a00 1in0 17d0 iIn0 Hd0 1cL0 bb0 1200 2s20 14n0 5aL0 Mp0 1vz0 17d0 1in0 17d0 1in0 17d0 1in0 17d0 6hX0 11B0 XHX0 1a10 1fz0 1a10 19X0 1cN0 1fz0 1a10 1fC0 1cM0 1cM0 1cM0 1fA0 1a00 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|62e5","Europe/Malta|CET CEST|-10 -20|0101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010|-2arB0 Lz0 1cN0 1db0 1410 1on0 Wp0 1qL0 17d0 1cL0 M3B0 5M20 WM0 1fA0 1co0 17c0 1iM0 16m0 1de0 1lc0 14m0 1lc0 WO0 1qM0 GTW0 On0 1C10 LA0 1C00 LA0 1EM0 LA0 1C00 LA0 1zc0 Oo0 1C00 Oo0 1co0 1cM0 1lA0 Xc0 1qq0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1iN0 19z0 1fB0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|42e4","Europe/Minsk|MMT EET MSK CEST CET MSD EEST +03|-1O -20 -30 -20 -10 -40 -30 -30|01234343252525252525252525261616161616161616161616161616161616161617|-1Pc1O eUnO qNX0 3gQ0 WM0 1fA0 1cM0 Al0 1tsn0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 3Fc0 1cN0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0|19e5","Europe/Monaco|PMT WET WEST WEMT CET CEST|-9.l 0 -10 -20 -10 -20|01212121212121212121212121212121212121212121212121232323232345454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454|-2nco9.l cNb9.l HA0 19A0 1iM0 11c0 1oo0 Wo0 1rc0 QM0 1EM0 UM0 1u00 10o0 1io0 1wo0 Rc0 1a00 1fA0 1cM0 1cM0 1io0 17c0 1fA0 1a00 1io0 1a00 1io0 17c0 1fA0 1a00 1io0 17c0 1cM0 1cM0 1a00 1io0 1cM0 1cM0 1a00 1fA0 1io0 17c0 1cM0 1cM0 1a00 1fA0 1io0 1qM0 Df0 2RV0 11z0 11B0 1ze0 WM0 1fA0 1cM0 1fa0 1aq0 16M0 1ekn0 1cL0 1fC0 1a00 1fA0 1cM0 1cM0 1cM0 1fA0 1a00 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|38e3","Europe/Moscow|MMT MMT MST MDST MSD MSK +05 EET EEST MSK|-2u.h -2v.j -3v.j -4v.j -40 -30 -50 -20 -30 -40|012132345464575454545454545454545458754545454545454545454545454545454545454595|-2ag2u.h 2pyW.W 1bA0 11X0 GN0 1Hb0 c4v.j ik0 3DA0 dz0 15A0 c10 2q10 iM10 23CL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cN0 IM0 rX0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 8Hz0|16e6","Europe/Paris|PMT WET WEST CEST CET WEMT|-9.l 0 -10 -20 -10 -20|0121212121212121212121212121212121212121212121212123434352543434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434|-2nco8.l cNb8.l HA0 19A0 1iM0 11c0 1oo0 Wo0 1rc0 QM0 1EM0 UM0 1u00 10o0 1io0 1wo0 Rc0 1a00 1fA0 1cM0 1cM0 1io0 17c0 1fA0 1a00 1io0 1a00 1io0 17c0 1fA0 1a00 1io0 17c0 1cM0 1cM0 1a00 1io0 1cM0 1cM0 1a00 1fA0 1io0 17c0 1cM0 1cM0 1a00 1fA0 1io0 1qM0 Df0 Ik0 5M30 WM0 1fA0 1cM0 Vx0 hB0 1aq0 16M0 1ekn0 1cL0 1fC0 1a00 1fA0 1cM0 1cM0 1cM0 1fA0 1a00 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|11e6","Europe/Riga|RMT LST EET MSK CEST CET MSD EEST|-1A.y -2A.y -20 -30 -20 -10 -40 -30|010102345454536363636363636363727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272|-25TzA.y 11A0 1iM0 ko0 gWm0 yDXA.y 2bX0 3fE0 WM0 1fA0 1cM0 1cM0 4m0 1sLy0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cN0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cN0 1o00 11A0 1o00 11A0 1qM0 3oo0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|64e4","Europe/Rome|CET CEST|-10 -20|0101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010|-2arB0 Lz0 1cN0 1db0 1410 1on0 Wp0 1qL0 17d0 1cL0 M3B0 5M20 WM0 1fA0 1cM0 16M0 1iM0 16m0 1de0 1lc0 14m0 1lc0 WO0 1qM0 GTW0 On0 1C10 LA0 1C00 LA0 1EM0 LA0 1C00 LA0 1zc0 Oo0 1C00 Oo0 1C00 LA0 1zc0 Oo0 1C00 LA0 1C00 LA0 1zc0 Oo0 1C00 Oo0 1zc0 Oo0 1fC0 1a00 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|39e5","Europe/Samara|LMT +03 +04 +05|-3k.k -30 -40 -50|0123232323232323232121232323232323232323232323232323232323212|-22WM0 qH90 23CL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 2pB0 1cM0 1fA0 2y10 14m0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 2sp0 WM0|12e5","Europe/Saratov|LMT +03 +04 +05|-34.i -30 -40 -50|012323232323232321212121212121212121212121212121212121212121212|-22WM0 qH90 23CL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 2pB0 1cM0 1cM0 1cM0 1fA0 1cM0 3Co0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 8Hz0 5810|","Europe/Simferopol|SMT EET MSK CEST CET MSD EEST MSK|-2g -20 -30 -20 -10 -40 -30 -40|012343432525252525252525252161616525252616161616161616161616161616161616172|-1Pc2g eUog rEn0 2qs0 WM0 1fA0 1cM0 3V0 1u0L0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1Q00 4eL0 1cL0 1cN0 1cL0 1cN0 dX0 WL0 1cN0 1cL0 1fB0 1o30 11B0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11z0 1nW0|33e4","Europe/Sofia|EET CET CEST EEST|-20 -10 -20 -30|01212103030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030|-168L0 WM0 1fA0 1cM0 1cM0 1cN0 1mKH0 1dd0 1fb0 1ap0 1fb0 1a20 1fy0 1a30 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cK0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1fB0 1nX0 11E0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|12e5","Europe/Stockholm|CET CEST|-10 -20|01010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010|-2azC0 TB0 2yDe0 1a00 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|15e5","Europe/Tallinn|TMT CET CEST EET MSK MSD EEST|-1D -10 -20 -20 -30 -40 -30|012103421212454545454545454546363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363|-26oND teD 11A0 1Ta0 4rXl KSLD 2FX0 2Jg0 WM0 1fA0 1cM0 18J0 1sTX0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cN0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o10 11A0 1qM0 5QM0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|41e4","Europe/Tirane|LMT CET CEST|-1j.k -10 -20|01212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-2glBj.k 14pcj.k 5LC0 WM0 4M0 1fCK0 10n0 1op0 11z0 1pd0 11z0 1qN0 WL0 1qp0 Xb0 1qp0 Xb0 1qp0 11z0 1lB0 11z0 1qN0 11z0 1iN0 16n0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|42e4","Europe/Ulyanovsk|LMT +03 +04 +05 +02|-3d.A -30 -40 -50 -20|01232323232323232321214121212121212121212121212121212121212121212|-22WM0 qH90 23CL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 2pB0 1cM0 1fA0 2pB0 IM0 rX0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 8Hz0 3rd0|13e5","Europe/Uzhgorod|CET CEST MSK MSD EET EEST|-10 -20 -30 -40 -20 -30|010101023232323232323232320454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454|-1cqL0 6i00 WM0 1fA0 1cM0 1ml0 1Cp0 1r3W0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1Q00 1Nf0 2pw0 1cL0 1cN0 1cL0 1cN0 1cL0 1cQ0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|11e4","Europe/Vienna|CET CEST|-10 -20|0101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010|-2aFe0 11d0 1iO0 11A0 1o00 11A0 3KM0 14o0 LA00 6i00 WM0 1fA0 1cM0 1cM0 1cM0 400 2qM0 1ao0 1co0 1cM0 1io0 17c0 1gHa0 19X0 1cP0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|18e5","Europe/Vilnius|WMT KMT CET EET MSK CEST MSD EEST|-1o -1z.A -10 -20 -30 -20 -40 -30|012324525254646464646464646473737373737373737352537373737373737373737373737373737373737373737373737373737373737373737373|-293do 6ILM.o 1Ooz.A zz0 Mfd0 29W0 3is0 WM0 1fA0 1cM0 LV0 1tgL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cN0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11B0 1o00 11A0 1qM0 8io0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|54e4","Europe/Volgograd|LMT +03 +04 +05|-2V.E -30 -40 -50|012323232323232321212121212121212121212121212121212121212121212|-21IqV.E psLV.E 23CL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 2pB0 1cM0 1cM0 1cM0 1fA0 1cM0 3Co0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 8Hz0 9Jd0|10e5","Europe/Warsaw|WMT CET CEST EET EEST|-1o -10 -20 -20 -30|012121234312121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-2ctdo 1LXo 11d0 1iO0 11A0 1o00 11A0 1on0 11A0 6zy0 HWP0 5IM0 WM0 1fA0 1cM0 1dz0 1mL0 1en0 15B0 1aq0 1nA0 11A0 1io0 17c0 1fA0 1a00 iDX0 LA0 1cM0 1cM0 1C00 Oo0 1cM0 1cM0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1C00 LA0 uso0 1a00 1fA0 1cM0 1cM0 1cM0 1fA0 1a00 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cN0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|17e5","Europe/Zaporozhye|+0220 EET MSK CEST CET MSD EEST|-2k -20 -30 -20 -10 -40 -30|01234342525252525252525252526161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161|-1Pc2k eUok rdb0 2RE0 WM0 1fA0 8m0 1v9a0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cK0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cQ0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|77e4","HST|HST|a0|0||","Indian/Chagos|LMT +05 +06|-4N.E -50 -60|012|-2xosN.E 3AGLN.E|30e2","Indian/Cocos|+0630|-6u|0||596","Indian/Kerguelen|-00 +05|0 -50|01|-MG00|130","Indian/Mahe|LMT +04|-3F.M -40|01|-2yO3F.M|79e3","Indian/Maldives|MMT +05|-4S -50|01|-olgS|35e4","Indian/Mauritius|LMT +04 +05|-3O -40 -50|012121|-2xorO 34unO 14L0 12kr0 11z0|15e4","Indian/Reunion|LMT +04|-3F.Q -40|01|-2mDDF.Q|84e4","Pacific/Kwajalein|+11 +10 +09 -12 +12|-b0 -a0 -90 c0 -c0|012034|-1kln0 akp0 6Up0 12ry0 Wan0|14e3","MET|MET MEST|-10 -20|01010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010|-2aFe0 11d0 1iO0 11A0 1o00 11A0 Qrc0 6i00 WM0 1fA0 1cM0 1cM0 1cM0 16M0 1gMM0 1a00 1fA0 1cM0 1cM0 1cM0 1fA0 1a00 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|","MST|MST|70|0||","MST7MDT|MST MDT MWT MPT|70 60 60 60|010102301010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010|-261r0 1nX0 11B0 1nX0 SgN0 8x20 ix0 QwN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 s10 1Vz0 LB0 1BX0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|","Pacific/Chatham|+1215 +1245 +1345|-cf -cJ -dJ|012121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212|-WqAf 1adef IM0 1C00 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1qM0 14o0 1lc0 14o0 1lc0 14o0 1lc0 17c0 1io0 17c0 1io0 17c0 1io0 17c0 1lc0 14o0 1lc0 14o0 1lc0 17c0 1io0 17c0 1io0 17c0 1lc0 14o0 1lc0 14o0 1lc0 17c0 1io0 17c0 1io0 17c0 1io0 17c0 1io0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1io0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00|600","Pacific/Apia|LMT -1130 -11 -10 +14 +13|bq.U bu b0 a0 -e0 -d0|01232345454545454545454545454545454545454545454545454545454|-2nDMx.4 1yW03.4 2rRbu 1ff0 1a00 CI0 AQ0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1io0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00|37e3","Pacific/Bougainville|+10 +09 +11|-a0 -90 -b0|0102|-16Wy0 7CN0 2MQp0|18e4","Pacific/Chuuk|+10 +09|-a0 -90|01010|-2ewy0 axB0 RVX0 axd0|49e3","Pacific/Efate|LMT +11 +12|-bd.g -b0 -c0|0121212121212121212121|-2l9nd.g 2Szcd.g 1cL0 1oN0 10L0 1fB0 19X0 1fB0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1fB0 Lz0 1Nd0 An0|66e3","Pacific/Enderbury|-12 -11 +13|c0 b0 -d0|012|nIc0 B7X0|1","Pacific/Fakaofo|-11 +13|b0 -d0|01|1Gfn0|483","Pacific/Fiji|LMT +12 +13|-bT.I -c0 -d0|0121212121212121212121212121212121212121212121212121212121212121|-2bUzT.I 3m8NT.I LA0 1EM0 IM0 nJc0 LA0 1o00 Rc0 1wo0 Ao0 1Nc0 Ao0 1Q00 xz0 1SN0 uM0 1SM0 uM0 1VA0 s00 1VA0 s00 1VA0 s00 20o0 pc0 20o0 s00 20o0 pc0 20o0 pc0 20o0 pc0 20o0 pc0 20o0 s00 1VA0 s00 20o0 pc0 20o0 pc0 20o0 pc0 20o0 pc0 20o0 s00 20o0 pc0 20o0 pc0 20o0 pc0 20o0 pc0 20o0 s00 1VA0 s00|88e4","Pacific/Galapagos|LMT -05 -06|5W.o 50 60|01212|-1yVS1.A 2dTz1.A gNd0 rz0|25e3","Pacific/Gambier|LMT -09|8X.M 90|01|-2jof0.c|125","Pacific/Guadalcanal|LMT +11|-aD.M -b0|01|-2joyD.M|11e4","Pacific/Guam|GST +09 GDT ChST|-a0 -90 -b0 -a0|01020202020202020203|-18jK0 6pB0 AhB0 3QL0 g2p0 3p91 WOX rX0 1zd0 Rb0 1wp0 Rb0 5xd0 rX0 5sN0 zb1 1C0X On0 ULb0|17e4","Pacific/Honolulu|HST HDT HWT HPT HST|au 9u 9u 9u a0|0102304|-1thLu 8x0 lef0 8wWu iAu 46p0|37e4","Pacific/Kiritimati|-1040 -10 +14|aE a0 -e0|012|nIaE B7Xk|51e2","Pacific/Kosrae|+11 +09 +10 +12|-b0 -90 -a0 -c0|01021030|-2ewz0 axC0 HBy0 akp0 axd0 WOK0 1bdz0|66e2","Pacific/Majuro|+11 +09 +10 +12|-b0 -90 -a0 -c0|0102103|-2ewz0 axC0 HBy0 akp0 6RB0 12um0|28e3","Pacific/Marquesas|LMT -0930|9i 9u|01|-2joeG|86e2","Pacific/Pago_Pago|LMT SST|bm.M b0|01|-2nDMB.c|37e2","Pacific/Nauru|LMT +1130 +09 +12|-b7.E -bu -90 -c0|01213|-1Xdn7.E QCnB.E 7mqu 1lnbu|10e3","Pacific/Niue|-1120 -1130 -11|bk bu b0|012|-KfME 17y0a|12e2","Pacific/Norfolk|+1112 +1130 +1230 +11 +12|-bc -bu -cu -b0 -c0|012134343434343434343434343434343434343434|-Kgbc W01G Oo0 1COo0 9Jcu 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0|25e4","Pacific/Noumea|LMT +11 +12|-b5.M -b0 -c0|01212121|-2l9n5.M 2EqM5.M xX0 1PB0 yn0 HeP0 Ao0|98e3","Pacific/Pitcairn|-0830 -08|8u 80|01|18Vku|56","Pacific/Pohnpei|+11 +09 +10|-b0 -90 -a0|010210|-2ewz0 axC0 HBy0 akp0 axd0|34e3","Pacific/Rarotonga|-1030 -0930 -10|au 9u a0|012121212121212121212121212|lyWu IL0 1zcu Onu 1zcu Onu 1zcu Rbu 1zcu Onu 1zcu Onu 1zcu Onu 1zcu Onu 1zcu Onu 1zcu Rbu 1zcu Onu 1zcu Onu 1zcu Onu|13e3","Pacific/Tahiti|LMT -10|9W.g a0|01|-2joe1.I|18e4","Pacific/Tongatapu|+1220 +13 +14|-ck -d0 -e0|0121212121|-1aB0k 2n5dk 15A0 1wo0 xz0 1Q10 xz0 zWN0 s00|75e3","PST8PDT|PST PDT PWT PPT|80 70 70 70|010102301010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010|-261q0 1nX0 11B0 1nX0 SgN0 8x10 iy0 QwN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 s10 1Vz0 LB0 1BX0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|","WET|WET WEST|0 -10|010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010|hDB0 1a00 1fA0 1cM0 1cM0 1cM0 1fA0 1a00 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|"],"links":["Africa/Abidjan|Africa/Bamako","Africa/Abidjan|Africa/Banjul","Africa/Abidjan|Africa/Conakry","Africa/Abidjan|Africa/Dakar","Africa/Abidjan|Africa/Freetown","Africa/Abidjan|Africa/Lome","Africa/Abidjan|Africa/Nouakchott","Africa/Abidjan|Africa/Ouagadougou","Africa/Abidjan|Africa/Timbuktu","Africa/Abidjan|Atlantic/St_Helena","Africa/Cairo|Egypt","Africa/Johannesburg|Africa/Maseru","Africa/Johannesburg|Africa/Mbabane","Africa/Lagos|Africa/Bangui","Africa/Lagos|Africa/Brazzaville","Africa/Lagos|Africa/Douala","Africa/Lagos|Africa/Kinshasa","Africa/Lagos|Africa/Libreville","Africa/Lagos|Africa/Luanda","Africa/Lagos|Africa/Malabo","Africa/Lagos|Africa/Niamey","Africa/Lagos|Africa/Porto-Novo","Africa/Maputo|Africa/Blantyre","Africa/Maputo|Africa/Bujumbura","Africa/Maputo|Africa/Gaborone","Africa/Maputo|Africa/Harare","Africa/Maputo|Africa/Kigali","Africa/Maputo|Africa/Lubumbashi","Africa/Maputo|Africa/Lusaka","Africa/Nairobi|Africa/Addis_Ababa","Africa/Nairobi|Africa/Asmara","Africa/Nairobi|Africa/Asmera","Africa/Nairobi|Africa/Dar_es_Salaam","Africa/Nairobi|Africa/Djibouti","Africa/Nairobi|Africa/Kampala","Africa/Nairobi|Africa/Mogadishu","Africa/Nairobi|Indian/Antananarivo","Africa/Nairobi|Indian/Comoro","Africa/Nairobi|Indian/Mayotte","Africa/Tripoli|Libya","America/Adak|America/Atka","America/Adak|US/Aleutian","America/Anchorage|US/Alaska","America/Argentina/Buenos_Aires|America/Buenos_Aires","America/Argentina/Catamarca|America/Argentina/ComodRivadavia","America/Argentina/Catamarca|America/Catamarca","America/Argentina/Cordoba|America/Cordoba","America/Argentina/Cordoba|America/Rosario","America/Argentina/Jujuy|America/Jujuy","America/Argentina/Mendoza|America/Mendoza","America/Atikokan|America/Coral_Harbour","America/Chicago|US/Central","America/Curacao|America/Aruba","America/Curacao|America/Kralendijk","America/Curacao|America/Lower_Princes","America/Denver|America/Shiprock","America/Denver|Navajo","America/Denver|US/Mountain","America/Detroit|US/Michigan","America/Edmonton|Canada/Mountain","America/Fort_Wayne|America/Indiana/Indianapolis","America/Fort_Wayne|America/Indianapolis","America/Fort_Wayne|US/East-Indiana","America/Halifax|Canada/Atlantic","America/Havana|Cuba","America/Indiana/Knox|America/Knox_IN","America/Indiana/Knox|US/Indiana-Starke","America/Jamaica|Jamaica","America/Kentucky/Louisville|America/Louisville","America/Los_Angeles|US/Pacific","America/Los_Angeles|US/Pacific-New","America/Manaus|Brazil/West","America/Mazatlan|Mexico/BajaSur","America/Mexico_City|Mexico/General","America/New_York|US/Eastern","America/Noronha|Brazil/DeNoronha","America/Panama|America/Cayman","America/Phoenix|US/Arizona","America/Port_of_Spain|America/Anguilla","America/Port_of_Spain|America/Antigua","America/Port_of_Spain|America/Dominica","America/Port_of_Spain|America/Grenada","America/Port_of_Spain|America/Guadeloupe","America/Port_of_Spain|America/Marigot","America/Port_of_Spain|America/Montserrat","America/Port_of_Spain|America/St_Barthelemy","America/Port_of_Spain|America/St_Kitts","America/Port_of_Spain|America/St_Lucia","America/Port_of_Spain|America/St_Thomas","America/Port_of_Spain|America/St_Vincent","America/Port_of_Spain|America/Tortola","America/Port_of_Spain|America/Virgin","America/Regina|Canada/Saskatchewan","America/Rio_Branco|America/Porto_Acre","America/Rio_Branco|Brazil/Acre","America/Santiago|Chile/Continental","America/Sao_Paulo|Brazil/East","America/St_Johns|Canada/Newfoundland","America/Tijuana|America/Ensenada","America/Tijuana|America/Santa_Isabel","America/Tijuana|Mexico/BajaNorte","America/Toronto|America/Montreal","America/Toronto|Canada/Eastern","America/Vancouver|Canada/Pacific","America/Whitehorse|Canada/Yukon","America/Winnipeg|Canada/Central","Asia/Ashgabat|Asia/Ashkhabad","Asia/Bangkok|Asia/Phnom_Penh","Asia/Bangkok|Asia/Vientiane","Asia/Dhaka|Asia/Dacca","Asia/Dubai|Asia/Muscat","Asia/Ho_Chi_Minh|Asia/Saigon","Asia/Hong_Kong|Hongkong","Asia/Jerusalem|Asia/Tel_Aviv","Asia/Jerusalem|Israel","Asia/Kathmandu|Asia/Katmandu","Asia/Kolkata|Asia/Calcutta","Asia/Kuala_Lumpur|Asia/Singapore","Asia/Kuala_Lumpur|Singapore","Asia/Macau|Asia/Macao","Asia/Makassar|Asia/Ujung_Pandang","Asia/Nicosia|Europe/Nicosia","Asia/Qatar|Asia/Bahrain","Asia/Rangoon|Asia/Yangon","Asia/Riyadh|Asia/Aden","Asia/Riyadh|Asia/Kuwait","Asia/Seoul|ROK","Asia/Shanghai|Asia/Chongqing","Asia/Shanghai|Asia/Chungking","Asia/Shanghai|Asia/Harbin","Asia/Shanghai|PRC","Asia/Taipei|ROC","Asia/Tehran|Iran","Asia/Thimphu|Asia/Thimbu","Asia/Tokyo|Japan","Asia/Ulaanbaatar|Asia/Ulan_Bator","Asia/Urumqi|Asia/Kashgar","Atlantic/Faroe|Atlantic/Faeroe","Atlantic/Reykjavik|Iceland","Atlantic/South_Georgia|Etc/GMT+2","Australia/Adelaide|Australia/South","Australia/Brisbane|Australia/Queensland","Australia/Broken_Hill|Australia/Yancowinna","Australia/Darwin|Australia/North","Australia/Hobart|Australia/Tasmania","Australia/Lord_Howe|Australia/LHI","Australia/Melbourne|Australia/Victoria","Australia/Perth|Australia/West","Australia/Sydney|Australia/ACT","Australia/Sydney|Australia/Canberra","Australia/Sydney|Australia/NSW","Etc/GMT-0|Etc/GMT","Etc/GMT-0|Etc/GMT+0","Etc/GMT-0|Etc/GMT0","Etc/GMT-0|Etc/Greenwich","Etc/GMT-0|GMT","Etc/GMT-0|GMT+0","Etc/GMT-0|GMT-0","Etc/GMT-0|GMT0","Etc/GMT-0|Greenwich","Etc/UTC|Etc/UCT","Etc/UTC|Etc/Universal","Etc/UTC|Etc/Zulu","Etc/UTC|UCT","Etc/UTC|UTC","Etc/UTC|Universal","Etc/UTC|Zulu","Europe/Belgrade|Europe/Ljubljana","Europe/Belgrade|Europe/Podgorica","Europe/Belgrade|Europe/Sarajevo","Europe/Belgrade|Europe/Skopje","Europe/Belgrade|Europe/Zagreb","Europe/Chisinau|Europe/Tiraspol","Europe/Dublin|Eire","Europe/Helsinki|Europe/Mariehamn","Europe/Istanbul|Asia/Istanbul","Europe/Istanbul|Turkey","Europe/Lisbon|Portugal","Europe/London|Europe/Belfast","Europe/London|Europe/Guernsey","Europe/London|Europe/Isle_of_Man","Europe/London|Europe/Jersey","Europe/London|GB","Europe/London|GB-Eire","Europe/Moscow|W-SU","Europe/Oslo|Arctic/Longyearbyen","Europe/Oslo|Atlantic/Jan_Mayen","Europe/Prague|Europe/Bratislava","Europe/Rome|Europe/San_Marino","Europe/Rome|Europe/Vatican","Europe/Warsaw|Poland","Europe/Zurich|Europe/Busingen","Europe/Zurich|Europe/Vaduz","Indian/Christmas|Etc/GMT-7","Pacific/Auckland|Antarctica/McMurdo","Pacific/Auckland|Antarctica/South_Pole","Pacific/Auckland|NZ","Pacific/Chatham|NZ-CHAT","Pacific/Chuuk|Pacific/Truk","Pacific/Chuuk|Pacific/Yap","Pacific/Easter|Chile/EasterIsland","Pacific/Guam|Pacific/Saipan","Pacific/Honolulu|Pacific/Johnston","Pacific/Honolulu|US/Hawaii","Pacific/Kwajalein|Kwajalein","Pacific/Pago_Pago|Pacific/Midway","Pacific/Pago_Pago|Pacific/Samoa","Pacific/Pago_Pago|US/Samoa","Pacific/Palau|Etc/GMT-9","Pacific/Pohnpei|Pacific/Ponape","Pacific/Port_Moresby|Etc/GMT-10","Pacific/Tarawa|Etc/GMT-12","Pacific/Tarawa|Pacific/Funafuti","Pacific/Tarawa|Pacific/Wake","Pacific/Tarawa|Pacific/Wallis"],"countries":["AD|Europe/Andorra","AE|Asia/Dubai","AF|Asia/Kabul","AG|America/Port_of_Spain America/Antigua","AI|America/Port_of_Spain America/Anguilla","AL|Europe/Tirane","AM|Asia/Yerevan","AO|Africa/Lagos Africa/Luanda","AQ|Antarctica/Casey Antarctica/Davis Antarctica/DumontDUrville Antarctica/Mawson Antarctica/Palmer Antarctica/Rothera Antarctica/Syowa Antarctica/Troll Antarctica/Vostok Pacific/Auckland Antarctica/McMurdo","AR|America/Argentina/Buenos_Aires America/Argentina/Cordoba America/Argentina/Salta America/Argentina/Jujuy America/Argentina/Tucuman America/Argentina/Catamarca America/Argentina/La_Rioja America/Argentina/San_Juan America/Argentina/Mendoza America/Argentina/San_Luis America/Argentina/Rio_Gallegos America/Argentina/Ushuaia","AS|Pacific/Pago_Pago","AT|Europe/Vienna","AU|Australia/Lord_Howe Antarctica/Macquarie Australia/Hobart Australia/Currie Australia/Melbourne Australia/Sydney Australia/Broken_Hill Australia/Brisbane Australia/Lindeman Australia/Adelaide Australia/Darwin Australia/Perth Australia/Eucla","AW|America/Curacao America/Aruba","AX|Europe/Helsinki Europe/Mariehamn","AZ|Asia/Baku","BA|Europe/Belgrade Europe/Sarajevo","BB|America/Barbados","BD|Asia/Dhaka","BE|Europe/Brussels","BF|Africa/Abidjan Africa/Ouagadougou","BG|Europe/Sofia","BH|Asia/Qatar Asia/Bahrain","BI|Africa/Maputo Africa/Bujumbura","BJ|Africa/Lagos Africa/Porto-Novo","BL|America/Port_of_Spain America/St_Barthelemy","BM|Atlantic/Bermuda","BN|Asia/Brunei","BO|America/La_Paz","BQ|America/Curacao America/Kralendijk","BR|America/Noronha America/Belem America/Fortaleza America/Recife America/Araguaina America/Maceio America/Bahia America/Sao_Paulo America/Campo_Grande America/Cuiaba America/Santarem America/Porto_Velho America/Boa_Vista America/Manaus America/Eirunepe America/Rio_Branco","BS|America/Nassau","BT|Asia/Thimphu","BW|Africa/Maputo Africa/Gaborone","BY|Europe/Minsk","BZ|America/Belize","CA|America/St_Johns America/Halifax America/Glace_Bay America/Moncton America/Goose_Bay America/Blanc-Sablon America/Toronto America/Nipigon America/Thunder_Bay America/Iqaluit America/Pangnirtung America/Atikokan America/Winnipeg America/Rainy_River America/Resolute America/Rankin_Inlet America/Regina America/Swift_Current America/Edmonton America/Cambridge_Bay America/Yellowknife America/Inuvik America/Creston America/Dawson_Creek America/Fort_Nelson America/Vancouver America/Whitehorse America/Dawson","CC|Indian/Cocos","CD|Africa/Maputo Africa/Lagos Africa/Kinshasa Africa/Lubumbashi","CF|Africa/Lagos Africa/Bangui","CG|Africa/Lagos Africa/Brazzaville","CH|Europe/Zurich","CI|Africa/Abidjan","CK|Pacific/Rarotonga","CL|America/Santiago America/Punta_Arenas Pacific/Easter","CM|Africa/Lagos Africa/Douala","CN|Asia/Shanghai Asia/Urumqi","CO|America/Bogota","CR|America/Costa_Rica","CU|America/Havana","CV|Atlantic/Cape_Verde","CW|America/Curacao","CX|Indian/Christmas","CY|Asia/Nicosia Asia/Famagusta","CZ|Europe/Prague","DE|Europe/Zurich Europe/Berlin Europe/Busingen","DJ|Africa/Nairobi Africa/Djibouti","DK|Europe/Copenhagen","DM|America/Port_of_Spain America/Dominica","DO|America/Santo_Domingo","DZ|Africa/Algiers","EC|America/Guayaquil Pacific/Galapagos","EE|Europe/Tallinn","EG|Africa/Cairo","EH|Africa/El_Aaiun","ER|Africa/Nairobi Africa/Asmara","ES|Europe/Madrid Africa/Ceuta Atlantic/Canary","ET|Africa/Nairobi Africa/Addis_Ababa","FI|Europe/Helsinki","FJ|Pacific/Fiji","FK|Atlantic/Stanley","FM|Pacific/Chuuk Pacific/Pohnpei Pacific/Kosrae","FO|Atlantic/Faroe","FR|Europe/Paris","GA|Africa/Lagos Africa/Libreville","GB|Europe/London","GD|America/Port_of_Spain America/Grenada","GE|Asia/Tbilisi","GF|America/Cayenne","GG|Europe/London Europe/Guernsey","GH|Africa/Accra","GI|Europe/Gibraltar","GL|America/Godthab America/Danmarkshavn America/Scoresbysund America/Thule","GM|Africa/Abidjan Africa/Banjul","GN|Africa/Abidjan Africa/Conakry","GP|America/Port_of_Spain America/Guadeloupe","GQ|Africa/Lagos Africa/Malabo","GR|Europe/Athens","GS|Atlantic/South_Georgia","GT|America/Guatemala","GU|Pacific/Guam","GW|Africa/Bissau","GY|America/Guyana","HK|Asia/Hong_Kong","HN|America/Tegucigalpa","HR|Europe/Belgrade Europe/Zagreb","HT|America/Port-au-Prince","HU|Europe/Budapest","ID|Asia/Jakarta Asia/Pontianak Asia/Makassar Asia/Jayapura","IE|Europe/Dublin","IL|Asia/Jerusalem","IM|Europe/London Europe/Isle_of_Man","IN|Asia/Kolkata","IO|Indian/Chagos","IQ|Asia/Baghdad","IR|Asia/Tehran","IS|Atlantic/Reykjavik","IT|Europe/Rome","JE|Europe/London Europe/Jersey","JM|America/Jamaica","JO|Asia/Amman","JP|Asia/Tokyo","KE|Africa/Nairobi","KG|Asia/Bishkek","KH|Asia/Bangkok Asia/Phnom_Penh","KI|Pacific/Tarawa Pacific/Enderbury Pacific/Kiritimati","KM|Africa/Nairobi Indian/Comoro","KN|America/Port_of_Spain America/St_Kitts","KP|Asia/Pyongyang","KR|Asia/Seoul","KW|Asia/Riyadh Asia/Kuwait","KY|America/Panama America/Cayman","KZ|Asia/Almaty Asia/Qyzylorda Asia/Qostanay Asia/Aqtobe Asia/Aqtau Asia/Atyrau Asia/Oral","LA|Asia/Bangkok Asia/Vientiane","LB|Asia/Beirut","LC|America/Port_of_Spain America/St_Lucia","LI|Europe/Zurich Europe/Vaduz","LK|Asia/Colombo","LR|Africa/Monrovia","LS|Africa/Johannesburg Africa/Maseru","LT|Europe/Vilnius","LU|Europe/Luxembourg","LV|Europe/Riga","LY|Africa/Tripoli","MA|Africa/Casablanca","MC|Europe/Monaco","MD|Europe/Chisinau","ME|Europe/Belgrade Europe/Podgorica","MF|America/Port_of_Spain America/Marigot","MG|Africa/Nairobi Indian/Antananarivo","MH|Pacific/Majuro Pacific/Kwajalein","MK|Europe/Belgrade Europe/Skopje","ML|Africa/Abidjan Africa/Bamako","MM|Asia/Yangon","MN|Asia/Ulaanbaatar Asia/Hovd Asia/Choibalsan","MO|Asia/Macau","MP|Pacific/Guam Pacific/Saipan","MQ|America/Martinique","MR|Africa/Abidjan Africa/Nouakchott","MS|America/Port_of_Spain America/Montserrat","MT|Europe/Malta","MU|Indian/Mauritius","MV|Indian/Maldives","MW|Africa/Maputo Africa/Blantyre","MX|America/Mexico_City America/Cancun America/Merida America/Monterrey America/Matamoros America/Mazatlan America/Chihuahua America/Ojinaga America/Hermosillo America/Tijuana America/Bahia_Banderas","MY|Asia/Kuala_Lumpur Asia/Kuching","MZ|Africa/Maputo","NA|Africa/Windhoek","NC|Pacific/Noumea","NE|Africa/Lagos Africa/Niamey","NF|Pacific/Norfolk","NG|Africa/Lagos","NI|America/Managua","NL|Europe/Amsterdam","NO|Europe/Oslo","NP|Asia/Kathmandu","NR|Pacific/Nauru","NU|Pacific/Niue","NZ|Pacific/Auckland Pacific/Chatham","OM|Asia/Dubai Asia/Muscat","PA|America/Panama","PE|America/Lima","PF|Pacific/Tahiti Pacific/Marquesas Pacific/Gambier","PG|Pacific/Port_Moresby Pacific/Bougainville","PH|Asia/Manila","PK|Asia/Karachi","PL|Europe/Warsaw","PM|America/Miquelon","PN|Pacific/Pitcairn","PR|America/Puerto_Rico","PS|Asia/Gaza Asia/Hebron","PT|Europe/Lisbon Atlantic/Madeira Atlantic/Azores","PW|Pacific/Palau","PY|America/Asuncion","QA|Asia/Qatar","RE|Indian/Reunion","RO|Europe/Bucharest","RS|Europe/Belgrade","RU|Europe/Kaliningrad Europe/Moscow Europe/Simferopol Europe/Kirov Europe/Astrakhan Europe/Volgograd Europe/Saratov Europe/Ulyanovsk Europe/Samara Asia/Yekaterinburg Asia/Omsk Asia/Novosibirsk Asia/Barnaul Asia/Tomsk Asia/Novokuznetsk Asia/Krasnoyarsk Asia/Irkutsk Asia/Chita Asia/Yakutsk Asia/Khandyga Asia/Vladivostok Asia/Ust-Nera Asia/Magadan Asia/Sakhalin Asia/Srednekolymsk Asia/Kamchatka Asia/Anadyr","RW|Africa/Maputo Africa/Kigali","SA|Asia/Riyadh","SB|Pacific/Guadalcanal","SC|Indian/Mahe","SD|Africa/Khartoum","SE|Europe/Stockholm","SG|Asia/Singapore","SH|Africa/Abidjan Atlantic/St_Helena","SI|Europe/Belgrade Europe/Ljubljana","SJ|Europe/Oslo Arctic/Longyearbyen","SK|Europe/Prague Europe/Bratislava","SL|Africa/Abidjan Africa/Freetown","SM|Europe/Rome Europe/San_Marino","SN|Africa/Abidjan Africa/Dakar","SO|Africa/Nairobi Africa/Mogadishu","SR|America/Paramaribo","SS|Africa/Juba","ST|Africa/Sao_Tome","SV|America/El_Salvador","SX|America/Curacao America/Lower_Princes","SY|Asia/Damascus","SZ|Africa/Johannesburg Africa/Mbabane","TC|America/Grand_Turk","TD|Africa/Ndjamena","TF|Indian/Reunion Indian/Kerguelen","TG|Africa/Abidjan Africa/Lome","TH|Asia/Bangkok","TJ|Asia/Dushanbe","TK|Pacific/Fakaofo","TL|Asia/Dili","TM|Asia/Ashgabat","TN|Africa/Tunis","TO|Pacific/Tongatapu","TR|Europe/Istanbul","TT|America/Port_of_Spain","TV|Pacific/Funafuti","TW|Asia/Taipei","TZ|Africa/Nairobi Africa/Dar_es_Salaam","UA|Europe/Simferopol Europe/Kiev Europe/Uzhgorod Europe/Zaporozhye","UG|Africa/Nairobi Africa/Kampala","UM|Pacific/Pago_Pago Pacific/Wake Pacific/Honolulu Pacific/Midway","US|America/New_York America/Detroit America/Kentucky/Louisville America/Kentucky/Monticello America/Indiana/Indianapolis America/Indiana/Vincennes America/Indiana/Winamac America/Indiana/Marengo America/Indiana/Petersburg America/Indiana/Vevay America/Chicago America/Indiana/Tell_City America/Indiana/Knox America/Menominee America/North_Dakota/Center America/North_Dakota/New_Salem America/North_Dakota/Beulah America/Denver America/Boise America/Phoenix America/Los_Angeles America/Anchorage America/Juneau America/Sitka America/Metlakatla America/Yakutat America/Nome America/Adak Pacific/Honolulu","UY|America/Montevideo","UZ|Asia/Samarkand Asia/Tashkent","VA|Europe/Rome Europe/Vatican","VC|America/Port_of_Spain America/St_Vincent","VE|America/Caracas","VG|America/Port_of_Spain America/Tortola","VI|America/Port_of_Spain America/St_Thomas","VN|Asia/Bangkok Asia/Ho_Chi_Minh","VU|Pacific/Efate","WF|Pacific/Wallis","WS|Pacific/Apia","YE|Asia/Riyadh Asia/Aden","YT|Africa/Nairobi Indian/Mayotte","ZA|Africa/Johannesburg","ZM|Africa/Maputo Africa/Lusaka","ZW|Africa/Maputo Africa/Harare"]}');
      } }, a = {};
      function n(t2) {
        var c = a[t2];
        if (void 0 !== c) return c.exports;
        var s = a[t2] = { id: t2, loaded: false, exports: {} };
        return e[t2].call(s.exports, s, s.exports, n), s.loaded = true, s.exports;
      }
      n.n = (e2) => {
        var a2 = e2 && e2.__esModule ? () => e2.default : () => e2;
        return n.d(a2, { a: a2 }), a2;
      }, n.d = (e2, a2) => {
        for (var t2 in a2) n.o(a2, t2) && !n.o(e2, t2) && Object.defineProperty(e2, t2, { enumerable: true, get: a2[t2] });
      }, n.g = (function() {
        if ("object" == typeof globalThis) return globalThis;
        try {
          return this || new Function("return this")();
        } catch (e2) {
          if ("object" == typeof window) return window;
        }
      })(), n.o = (e2, a2) => Object.prototype.hasOwnProperty.call(e2, a2), n.r = (e2) => {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e2, "__esModule", { value: true });
      }, n.nmd = (e2) => (e2.paths = [], e2.children || (e2.children = []), e2);
      var t = {};
      (() => {
        "use strict";
        n.r(t), n.d(t, { default: () => m });
        var e2 = n(9034), a2 = n.n(e2);
        const c = { de: { LTMS: "HH:mm:ss,SSS", ls: "D.M.YYYY HH:mm:ss", lms: "D.M.YYYY HH:mm:ss,SSS", lls: "D. MMM YYYY HH:mm:ss", llms: "D. MMM YYYY HH:mm:ss,SSS", LLS: "D. MMMM YYYY HH:mm:ss", LLMS: "D. MMMM YYYY HH:mm:ss,SSS" }, "en-gb": { LTMS: "HH:mm:ss.SSS", ls: "D/M/YYYY HH:mm:ss", lms: "D/M/YYYY HH:mm:ss.SSS", lls: "D MMM YYYY HH:mm:ss", llms: "D MMM YYYY HH:mm:ss.SSS", LLS: "D MMMM YYYY HH:mm:ss", LLMS: "D MMMM YYYY HH:mm:ss.SSS" }, en: { LTMS: "h:mm:ss.SSS A", ls: "M/D/YYYY h:mm:ss A", lms: "M/D/YYYY h:mm:ss.SSS A", lls: "MMM D, YYYY h:mm:ss A", llms: "MMM D, YYYY h:mm:ss.SSS A", LLS: "MMMM D, YYYY h:mm:ss A", LLMS: "MMMM D, YYYY h:mm:ss.SSS A" }, fr: { LTMS: "HH:mm:ss,SSS", ls: "D/M/YYYY HH:mm:ss", lms: "D/M/YYYY HH:mm:ss,SSS", lls: "D MMM YYYY HH:mm:ss", llms: "D MMM YYYY HH:mm:ss,SSS", LLS: "D MMMM YYYY HH:mm:ss", LLMS: "D MMMM YYYY HH:mm:ss,SSS" }, it: { LTMS: "HH:mm:ss,SSS", ls: "D/M/YYYY HH:mm:ss", lms: "D/M/YYYY HH:mm:ss,SSS", lls: "D MMM YYYY HH:mm:ss", llms: "D MMM YYYY HH:mm:ss,SSS", LLS: "D MMMM YYYY HH:mm:ss", LLMS: "D MMMM YYYY HH:mm:ss,SSS" }, ja: { LTMS: "HH:mm:ss.SSS", ls: "YYYY/MM/DD HH:mm:ss", lms: "YYYY/MM/DD HH:mm:ss.SSS", lls: "YYYY年M月D日 HH:mm:ss", llms: "YYYY年M月D日 HH:mm:ss.SSS", LLS: "YYYY年M月D日 HH:mm:ss", LLMS: "YYYY年M月D日 HH:mm:ss.SSS" }, ko: { LTMS: "A h:mm:ss.SSS", ls: "YYYY.MM.DD A h:mm:ss", lms: "YYYY.MM.DD A h:mm:ss.SSS", lls: "YYYY년 MMMM D일 A h:mm:ss", llms: "YYYY년 MMMM D일 A h:mm:ss.SSS", LLS: "YYYY년 MMMM D일 A h:mm:ss", LLMS: "YYYY년 MMMM D일 A h:mm:ss.SSS" }, "zh-cn": { LTMS: "HH:mm:ss.SSS", ls: "YYYY年MMMD日 HH:mm:ss", lms: "YYYY年MMMD日 HH:mm:ss.SSS", lls: "YYYY年MMMD日 HH:mm:ss", llms: "YYYY年MMMD日 HH:mm:ss.SSS", LLS: "YYYY年MMMD日Ah点mm分s秒", LLMS: "YYYY年MMMD日 HH:mm:ss.SSS" }, "zh-tw": { LTMS: "HH:mm:ss.SSS", ls: "YYYY年MMMD日 HH:mm:ss", lms: "YYYY年MMMD日 HH:mm:ss.SSS", lls: "YYYY年MMMD日 HH:mm:ss", llms: "YYYY年MMMD日 HH:mm:ss.SSS", LLS: "YYYY年MMMD日 HH:mm:ss", LLMS: "YYYY年MMMD日 HH:mm:ss.SSS" } };
        n(2428), n(6337);
        var s = n(7097), o = n.n(s);
        const i = require_id(), r = require_config();
        var M, d = n(2153), _ = o()((function(e3, n2) {
          if (!e3) throw new Error("Serialized Splunk timezone is required when adding or setting time zones.");
          var t2 = n2 || (0, i.createGUID)();
          return a2().tz.add(a2().tz.pack((0, d.default)(e3, t2))), t2;
        })), u = o()((function(e3) {
          return M = _(e3);
        }));
        r.serverTimezoneInfo && u(r.serverTimezoneInfo), a2().newSplunkTime = function(e3) {
          var n2 = e3 || {}, t2 = n2.time, c2 = n2.format, s2 = n2.strict, o2 = void 0 !== s2 && s2, i2 = e3 && e3.locale || r.locale;
          if (!M) throw new Error("The Splunk server timezone data is not available.");
          return a2().tz(t2, c2, i2, o2, M);
        }, a2().addSplunkTimezone = _, a2().setDefaultSplunkTimezone = u, a2().getDefaultSplunkTimezone = function() {
          return M;
        }, a2().fn.splunkFormat = function(e3) {
          var a3 = this, n2 = this.locale(), t2 = c[n2], s2 = e3 || "";
          if (!t2) throw new Error("moment().splunkFormat() does not support the locale ".concat(n2));
          return ["LLMS", "LLS", "lls", "ls", "llms", "lms", "LTMS"].some((function(n3) {
            var c2 = e3.indexOf(n3);
            if (c2 > -1) {
              var o2 = a3.format(t2[n3]);
              return s2 = "".concat(s2.substring(0, c2), "[").concat(o2, "]").concat(s2.substring(c2 + n3.length)), true;
            }
            return false;
          })), this.format(s2);
        };
        const m = a2();
      })(), module2.exports = t;
    })();
  }
});

// node_modules/fflate/lib/browser.cjs
var require_browser = __commonJS({
  "node_modules/fflate/lib/browser.cjs"(exports2) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var ch2 = {};
    var node_worker_1 = {};
    node_worker_1["default"] = (function(c, id, msg, transfer, cb) {
      var w = new Worker(ch2[id] || (ch2[id] = URL.createObjectURL(new Blob([
        c + ';addEventListener("error",function(e){e=e.error;postMessage({$e$:[e.message,e.code,e.stack]})})'
      ], { type: "text/javascript" }))));
      w.onmessage = function(e) {
        var d = e.data, ed = d.$e$;
        if (ed) {
          var err2 = new Error(ed[0]);
          err2["code"] = ed[1];
          err2.stack = ed[2];
          cb(err2, null);
        } else
          cb(null, d);
      };
      w.postMessage(msg, transfer);
      return w;
    });
    var u8 = Uint8Array;
    var u16 = Uint16Array;
    var i32 = Int32Array;
    var fleb = new u8([
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      2,
      2,
      2,
      2,
      3,
      3,
      3,
      3,
      4,
      4,
      4,
      4,
      5,
      5,
      5,
      5,
      0,
      /* unused */
      0,
      0,
      /* impossible */
      0
    ]);
    var fdeb = new u8([
      0,
      0,
      0,
      0,
      1,
      1,
      2,
      2,
      3,
      3,
      4,
      4,
      5,
      5,
      6,
      6,
      7,
      7,
      8,
      8,
      9,
      9,
      10,
      10,
      11,
      11,
      12,
      12,
      13,
      13,
      /* unused */
      0,
      0
    ]);
    var clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
    var freb = function(eb, start) {
      var b = new u16(31);
      for (var i2 = 0; i2 < 31; ++i2) {
        b[i2] = start += 1 << eb[i2 - 1];
      }
      var r = new i32(b[30]);
      for (var i2 = 1; i2 < 30; ++i2) {
        for (var j = b[i2]; j < b[i2 + 1]; ++j) {
          r[j] = j - b[i2] << 5 | i2;
        }
      }
      return { b, r };
    };
    var _a = freb(fleb, 2);
    var fl = _a.b;
    var revfl = _a.r;
    fl[28] = 258, revfl[258] = 28;
    var _b = freb(fdeb, 0);
    var fd = _b.b;
    var revfd = _b.r;
    var rev = new u16(32768);
    for (i = 0; i < 32768; ++i) {
      x = (i & 43690) >> 1 | (i & 21845) << 1;
      x = (x & 52428) >> 2 | (x & 13107) << 2;
      x = (x & 61680) >> 4 | (x & 3855) << 4;
      rev[i] = ((x & 65280) >> 8 | (x & 255) << 8) >> 1;
    }
    var x;
    var i;
    var hMap = (function(cd, mb, r) {
      var s = cd.length;
      var i2 = 0;
      var l = new u16(mb);
      for (; i2 < s; ++i2) {
        if (cd[i2])
          ++l[cd[i2] - 1];
      }
      var le = new u16(mb);
      for (i2 = 1; i2 < mb; ++i2) {
        le[i2] = le[i2 - 1] + l[i2 - 1] << 1;
      }
      var co;
      if (r) {
        co = new u16(1 << mb);
        var rvb = 15 - mb;
        for (i2 = 0; i2 < s; ++i2) {
          if (cd[i2]) {
            var sv = i2 << 4 | cd[i2];
            var r_1 = mb - cd[i2];
            var v = le[cd[i2] - 1]++ << r_1;
            for (var m = v | (1 << r_1) - 1; v <= m; ++v) {
              co[rev[v] >> rvb] = sv;
            }
          }
        }
      } else {
        co = new u16(s);
        for (i2 = 0; i2 < s; ++i2) {
          if (cd[i2]) {
            co[i2] = rev[le[cd[i2] - 1]++] >> 15 - cd[i2];
          }
        }
      }
      return co;
    });
    var flt = new u8(288);
    for (i = 0; i < 144; ++i)
      flt[i] = 8;
    var i;
    for (i = 144; i < 256; ++i)
      flt[i] = 9;
    var i;
    for (i = 256; i < 280; ++i)
      flt[i] = 7;
    var i;
    for (i = 280; i < 288; ++i)
      flt[i] = 8;
    var i;
    var fdt = new u8(32);
    for (i = 0; i < 32; ++i)
      fdt[i] = 5;
    var i;
    var flm = hMap(flt, 9, 0);
    var flrm = hMap(flt, 9, 1);
    var fdm = hMap(fdt, 5, 0);
    var fdrm = hMap(fdt, 5, 1);
    var max = function(a) {
      var m = a[0];
      for (var i2 = 1; i2 < a.length; ++i2) {
        if (a[i2] > m)
          m = a[i2];
      }
      return m;
    };
    var bits = function(d, p, m) {
      var o = p / 8 | 0;
      return (d[o] | d[o + 1] << 8) >> (p & 7) & m;
    };
    var bits16 = function(d, p) {
      var o = p / 8 | 0;
      return (d[o] | d[o + 1] << 8 | d[o + 2] << 16) >> (p & 7);
    };
    var shft = function(p) {
      return (p + 7) / 8 | 0;
    };
    var slc = function(v, s, e) {
      if (s == null || s < 0)
        s = 0;
      if (e == null || e > v.length)
        e = v.length;
      return new u8(v.subarray(s, e));
    };
    exports2.FlateErrorCode = {
      UnexpectedEOF: 0,
      InvalidBlockType: 1,
      InvalidLengthLiteral: 2,
      InvalidDistance: 3,
      StreamFinished: 4,
      NoStreamHandler: 5,
      InvalidHeader: 6,
      NoCallback: 7,
      InvalidUTF8: 8,
      ExtraFieldTooLong: 9,
      InvalidDate: 10,
      FilenameTooLong: 11,
      StreamFinishing: 12,
      InvalidZipData: 13,
      UnknownCompressionMethod: 14
    };
    var ec = [
      "unexpected EOF",
      "invalid block type",
      "invalid length/literal",
      "invalid distance",
      "stream finished",
      "no stream handler",
      ,
      "no callback",
      "invalid UTF-8 data",
      "extra field too long",
      "date not in range 1980-2099",
      "filename too long",
      "stream finishing",
      "invalid zip data"
      // determined by unknown compression method
    ];
    var err = function(ind, msg, nt) {
      var e = new Error(msg || ec[ind]);
      e.code = ind;
      if (Error.captureStackTrace)
        Error.captureStackTrace(e, err);
      if (!nt)
        throw e;
      return e;
    };
    var inflt = function(dat, st, buf, dict) {
      var sl = dat.length, dl = dict ? dict.length : 0;
      if (!sl || st.f && !st.l)
        return buf || new u8(0);
      var noBuf = !buf;
      var resize = noBuf || st.i != 2;
      var noSt = st.i;
      if (noBuf)
        buf = new u8(sl * 3);
      var cbuf = function(l2) {
        var bl = buf.length;
        if (l2 > bl) {
          var nbuf = new u8(Math.max(bl * 2, l2));
          nbuf.set(buf);
          buf = nbuf;
        }
      };
      var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;
      var tbts = sl * 8;
      do {
        if (!lm) {
          final = bits(dat, pos, 1);
          var type = bits(dat, pos + 1, 3);
          pos += 3;
          if (!type) {
            var s = shft(pos) + 4, l = dat[s - 4] | dat[s - 3] << 8, t = s + l;
            if (t > sl) {
              if (noSt)
                err(0);
              break;
            }
            if (resize)
              cbuf(bt + l);
            buf.set(dat.subarray(s, t), bt);
            st.b = bt += l, st.p = pos = t * 8, st.f = final;
            continue;
          } else if (type == 1)
            lm = flrm, dm = fdrm, lbt = 9, dbt = 5;
          else if (type == 2) {
            var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;
            var tl = hLit + bits(dat, pos + 5, 31) + 1;
            pos += 14;
            var ldt = new u8(tl);
            var clt = new u8(19);
            for (var i2 = 0; i2 < hcLen; ++i2) {
              clt[clim[i2]] = bits(dat, pos + i2 * 3, 7);
            }
            pos += hcLen * 3;
            var clb = max(clt), clbmsk = (1 << clb) - 1;
            var clm = hMap(clt, clb, 1);
            for (var i2 = 0; i2 < tl; ) {
              var r = clm[bits(dat, pos, clbmsk)];
              pos += r & 15;
              var s = r >> 4;
              if (s < 16) {
                ldt[i2++] = s;
              } else {
                var c = 0, n = 0;
                if (s == 16)
                  n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i2 - 1];
                else if (s == 17)
                  n = 3 + bits(dat, pos, 7), pos += 3;
                else if (s == 18)
                  n = 11 + bits(dat, pos, 127), pos += 7;
                while (n--)
                  ldt[i2++] = c;
              }
            }
            var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);
            lbt = max(lt);
            dbt = max(dt);
            lm = hMap(lt, lbt, 1);
            dm = hMap(dt, dbt, 1);
          } else
            err(1);
          if (pos > tbts) {
            if (noSt)
              err(0);
            break;
          }
        }
        if (resize)
          cbuf(bt + 131072);
        var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;
        var lpos = pos;
        for (; ; lpos = pos) {
          var c = lm[bits16(dat, pos) & lms], sym = c >> 4;
          pos += c & 15;
          if (pos > tbts) {
            if (noSt)
              err(0);
            break;
          }
          if (!c)
            err(2);
          if (sym < 256)
            buf[bt++] = sym;
          else if (sym == 256) {
            lpos = pos, lm = null;
            break;
          } else {
            var add = sym - 254;
            if (sym > 264) {
              var i2 = sym - 257, b = fleb[i2];
              add = bits(dat, pos, (1 << b) - 1) + fl[i2];
              pos += b;
            }
            var d = dm[bits16(dat, pos) & dms], dsym = d >> 4;
            if (!d)
              err(3);
            pos += d & 15;
            var dt = fd[dsym];
            if (dsym > 3) {
              var b = fdeb[dsym];
              dt += bits16(dat, pos) & (1 << b) - 1, pos += b;
            }
            if (pos > tbts) {
              if (noSt)
                err(0);
              break;
            }
            if (resize)
              cbuf(bt + 131072);
            var end = bt + add;
            if (bt < dt) {
              var shift = dl - dt, dend = Math.min(dt, end);
              if (shift + bt < 0)
                err(3);
              for (; bt < dend; ++bt)
                buf[bt] = dict[shift + bt];
            }
            for (; bt < end; ++bt)
              buf[bt] = buf[bt - dt];
          }
        }
        st.l = lm, st.p = lpos, st.b = bt, st.f = final;
        if (lm)
          final = 1, st.m = lbt, st.d = dm, st.n = dbt;
      } while (!final);
      return bt != buf.length && noBuf ? slc(buf, 0, bt) : buf.subarray(0, bt);
    };
    var wbits = function(d, p, v) {
      v <<= p & 7;
      var o = p / 8 | 0;
      d[o] |= v;
      d[o + 1] |= v >> 8;
    };
    var wbits16 = function(d, p, v) {
      v <<= p & 7;
      var o = p / 8 | 0;
      d[o] |= v;
      d[o + 1] |= v >> 8;
      d[o + 2] |= v >> 16;
    };
    var hTree = function(d, mb) {
      var t = [];
      for (var i2 = 0; i2 < d.length; ++i2) {
        if (d[i2])
          t.push({ s: i2, f: d[i2] });
      }
      var s = t.length;
      var t2 = t.slice();
      if (!s)
        return { t: et, l: 0 };
      if (s == 1) {
        var v = new u8(t[0].s + 1);
        v[t[0].s] = 1;
        return { t: v, l: 1 };
      }
      t.sort(function(a, b) {
        return a.f - b.f;
      });
      t.push({ s: -1, f: 25001 });
      var l = t[0], r = t[1], i0 = 0, i1 = 1, i22 = 2;
      t[0] = { s: -1, f: l.f + r.f, l, r };
      while (i1 != s - 1) {
        l = t[t[i0].f < t[i22].f ? i0++ : i22++];
        r = t[i0 != i1 && t[i0].f < t[i22].f ? i0++ : i22++];
        t[i1++] = { s: -1, f: l.f + r.f, l, r };
      }
      var maxSym = t2[0].s;
      for (var i2 = 1; i2 < s; ++i2) {
        if (t2[i2].s > maxSym)
          maxSym = t2[i2].s;
      }
      var tr = new u16(maxSym + 1);
      var mbt = ln(t[i1 - 1], tr, 0);
      if (mbt > mb) {
        var i2 = 0, dt = 0;
        var lft = mbt - mb, cst = 1 << lft;
        t2.sort(function(a, b) {
          return tr[b.s] - tr[a.s] || a.f - b.f;
        });
        for (; i2 < s; ++i2) {
          var i2_1 = t2[i2].s;
          if (tr[i2_1] > mb) {
            dt += cst - (1 << mbt - tr[i2_1]);
            tr[i2_1] = mb;
          } else
            break;
        }
        dt >>= lft;
        while (dt > 0) {
          var i2_2 = t2[i2].s;
          if (tr[i2_2] < mb)
            dt -= 1 << mb - tr[i2_2]++ - 1;
          else
            ++i2;
        }
        for (; i2 >= 0 && dt; --i2) {
          var i2_3 = t2[i2].s;
          if (tr[i2_3] == mb) {
            --tr[i2_3];
            ++dt;
          }
        }
        mbt = mb;
      }
      return { t: new u8(tr), l: mbt };
    };
    var ln = function(n, l, d) {
      return n.s == -1 ? Math.max(ln(n.l, l, d + 1), ln(n.r, l, d + 1)) : l[n.s] = d;
    };
    var lc = function(c) {
      var s = c.length;
      while (s && !c[--s])
        ;
      var cl = new u16(++s);
      var cli = 0, cln = c[0], cls = 1;
      var w = function(v) {
        cl[cli++] = v;
      };
      for (var i2 = 1; i2 <= s; ++i2) {
        if (c[i2] == cln && i2 != s)
          ++cls;
        else {
          if (!cln && cls > 2) {
            for (; cls > 138; cls -= 138)
              w(32754);
            if (cls > 2) {
              w(cls > 10 ? cls - 11 << 5 | 28690 : cls - 3 << 5 | 12305);
              cls = 0;
            }
          } else if (cls > 3) {
            w(cln), --cls;
            for (; cls > 6; cls -= 6)
              w(8304);
            if (cls > 2)
              w(cls - 3 << 5 | 8208), cls = 0;
          }
          while (cls--)
            w(cln);
          cls = 1;
          cln = c[i2];
        }
      }
      return { c: cl.subarray(0, cli), n: s };
    };
    var clen = function(cf, cl) {
      var l = 0;
      for (var i2 = 0; i2 < cl.length; ++i2)
        l += cf[i2] * cl[i2];
      return l;
    };
    var wfblk = function(out, pos, dat) {
      var s = dat.length;
      var o = shft(pos + 2);
      out[o] = s & 255;
      out[o + 1] = s >> 8;
      out[o + 2] = out[o] ^ 255;
      out[o + 3] = out[o + 1] ^ 255;
      for (var i2 = 0; i2 < s; ++i2)
        out[o + i2 + 4] = dat[i2];
      return (o + 4 + s) * 8;
    };
    var wblk = function(dat, out, final, syms, lf, df, eb, li, bs, bl, p) {
      wbits(out, p++, final);
      ++lf[256];
      var _a2 = hTree(lf, 15), dlt = _a2.t, mlb = _a2.l;
      var _b2 = hTree(df, 15), ddt = _b2.t, mdb = _b2.l;
      var _c = lc(dlt), lclt = _c.c, nlc = _c.n;
      var _d = lc(ddt), lcdt = _d.c, ndc = _d.n;
      var lcfreq = new u16(19);
      for (var i2 = 0; i2 < lclt.length; ++i2)
        ++lcfreq[lclt[i2] & 31];
      for (var i2 = 0; i2 < lcdt.length; ++i2)
        ++lcfreq[lcdt[i2] & 31];
      var _e = hTree(lcfreq, 7), lct = _e.t, mlcb = _e.l;
      var nlcc = 19;
      for (; nlcc > 4 && !lct[clim[nlcc - 1]]; --nlcc)
        ;
      var flen = bl + 5 << 3;
      var ftlen = clen(lf, flt) + clen(df, fdt) + eb;
      var dtlen = clen(lf, dlt) + clen(df, ddt) + eb + 14 + 3 * nlcc + clen(lcfreq, lct) + 2 * lcfreq[16] + 3 * lcfreq[17] + 7 * lcfreq[18];
      if (bs >= 0 && flen <= ftlen && flen <= dtlen)
        return wfblk(out, p, dat.subarray(bs, bs + bl));
      var lm, ll, dm, dl;
      wbits(out, p, 1 + (dtlen < ftlen)), p += 2;
      if (dtlen < ftlen) {
        lm = hMap(dlt, mlb, 0), ll = dlt, dm = hMap(ddt, mdb, 0), dl = ddt;
        var llm = hMap(lct, mlcb, 0);
        wbits(out, p, nlc - 257);
        wbits(out, p + 5, ndc - 1);
        wbits(out, p + 10, nlcc - 4);
        p += 14;
        for (var i2 = 0; i2 < nlcc; ++i2)
          wbits(out, p + 3 * i2, lct[clim[i2]]);
        p += 3 * nlcc;
        var lcts = [lclt, lcdt];
        for (var it = 0; it < 2; ++it) {
          var clct = lcts[it];
          for (var i2 = 0; i2 < clct.length; ++i2) {
            var len = clct[i2] & 31;
            wbits(out, p, llm[len]), p += lct[len];
            if (len > 15)
              wbits(out, p, clct[i2] >> 5 & 127), p += clct[i2] >> 12;
          }
        }
      } else {
        lm = flm, ll = flt, dm = fdm, dl = fdt;
      }
      for (var i2 = 0; i2 < li; ++i2) {
        var sym = syms[i2];
        if (sym > 255) {
          var len = sym >> 18 & 31;
          wbits16(out, p, lm[len + 257]), p += ll[len + 257];
          if (len > 7)
            wbits(out, p, sym >> 23 & 31), p += fleb[len];
          var dst = sym & 31;
          wbits16(out, p, dm[dst]), p += dl[dst];
          if (dst > 3)
            wbits16(out, p, sym >> 5 & 8191), p += fdeb[dst];
        } else {
          wbits16(out, p, lm[sym]), p += ll[sym];
        }
      }
      wbits16(out, p, lm[256]);
      return p + ll[256];
    };
    var deo = new i32([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]);
    var et = new u8(0);
    var dflt = function(dat, lvl, plvl, pre, post, st) {
      var s = st.z || dat.length;
      var o = new u8(pre + s + 5 * (1 + Math.ceil(s / 7e3)) + post);
      var w = o.subarray(pre, o.length - post);
      var lst = st.l;
      var pos = (st.r || 0) & 7;
      if (lvl) {
        if (pos)
          w[0] = st.r >> 3;
        var opt = deo[lvl - 1];
        var n = opt >> 13, c = opt & 8191;
        var msk_1 = (1 << plvl) - 1;
        var prev = st.p || new u16(32768), head = st.h || new u16(msk_1 + 1);
        var bs1_1 = Math.ceil(plvl / 3), bs2_1 = 2 * bs1_1;
        var hsh = function(i3) {
          return (dat[i3] ^ dat[i3 + 1] << bs1_1 ^ dat[i3 + 2] << bs2_1) & msk_1;
        };
        var syms = new i32(25e3);
        var lf = new u16(288), df = new u16(32);
        var lc_1 = 0, eb = 0, i2 = st.i || 0, li = 0, wi = st.w || 0, bs = 0;
        for (; i2 + 2 < s; ++i2) {
          var hv = hsh(i2);
          var imod = i2 & 32767, pimod = head[hv];
          prev[imod] = pimod;
          head[hv] = imod;
          if (wi <= i2) {
            var rem = s - i2;
            if ((lc_1 > 7e3 || li > 24576) && (rem > 423 || !lst)) {
              pos = wblk(dat, w, 0, syms, lf, df, eb, li, bs, i2 - bs, pos);
              li = lc_1 = eb = 0, bs = i2;
              for (var j = 0; j < 286; ++j)
                lf[j] = 0;
              for (var j = 0; j < 30; ++j)
                df[j] = 0;
            }
            var l = 2, d = 0, ch_1 = c, dif = imod - pimod & 32767;
            if (rem > 2 && hv == hsh(i2 - dif)) {
              var maxn = Math.min(n, rem) - 1;
              var maxd = Math.min(32767, i2);
              var ml = Math.min(258, rem);
              while (dif <= maxd && --ch_1 && imod != pimod) {
                if (dat[i2 + l] == dat[i2 + l - dif]) {
                  var nl = 0;
                  for (; nl < ml && dat[i2 + nl] == dat[i2 + nl - dif]; ++nl)
                    ;
                  if (nl > l) {
                    l = nl, d = dif;
                    if (nl > maxn)
                      break;
                    var mmd = Math.min(dif, nl - 2);
                    var md = 0;
                    for (var j = 0; j < mmd; ++j) {
                      var ti = i2 - dif + j & 32767;
                      var pti = prev[ti];
                      var cd = ti - pti & 32767;
                      if (cd > md)
                        md = cd, pimod = ti;
                    }
                  }
                }
                imod = pimod, pimod = prev[imod];
                dif += imod - pimod & 32767;
              }
            }
            if (d) {
              syms[li++] = 268435456 | revfl[l] << 18 | revfd[d];
              var lin = revfl[l] & 31, din = revfd[d] & 31;
              eb += fleb[lin] + fdeb[din];
              ++lf[257 + lin];
              ++df[din];
              wi = i2 + l;
              ++lc_1;
            } else {
              syms[li++] = dat[i2];
              ++lf[dat[i2]];
            }
          }
        }
        for (i2 = Math.max(i2, wi); i2 < s; ++i2) {
          syms[li++] = dat[i2];
          ++lf[dat[i2]];
        }
        pos = wblk(dat, w, lst, syms, lf, df, eb, li, bs, i2 - bs, pos);
        if (!lst) {
          st.r = pos & 7 | w[pos / 8 | 0] << 3;
          pos -= 7;
          st.h = head, st.p = prev, st.i = i2, st.w = wi;
        }
      } else {
        for (var i2 = st.w || 0; i2 < s + lst; i2 += 65535) {
          var e = i2 + 65535;
          if (e >= s) {
            w[pos / 8 | 0] = lst;
            e = s;
          }
          pos = wfblk(w, pos + 1, dat.subarray(i2, e));
        }
        st.i = s;
      }
      return slc(o, 0, pre + shft(pos) + post);
    };
    var crct = (function() {
      var t = new Int32Array(256);
      for (var i2 = 0; i2 < 256; ++i2) {
        var c = i2, k = 9;
        while (--k)
          c = (c & 1 && -306674912) ^ c >>> 1;
        t[i2] = c;
      }
      return t;
    })();
    var crc = function() {
      var c = -1;
      return {
        p: function(d) {
          var cr = c;
          for (var i2 = 0; i2 < d.length; ++i2)
            cr = crct[cr & 255 ^ d[i2]] ^ cr >>> 8;
          c = cr;
        },
        d: function() {
          return ~c;
        }
      };
    };
    var adler = function() {
      var a = 1, b = 0;
      return {
        p: function(d) {
          var n = a, m = b;
          var l = d.length | 0;
          for (var i2 = 0; i2 != l; ) {
            var e = Math.min(i2 + 2655, l);
            for (; i2 < e; ++i2)
              m += n += d[i2];
            n = (n & 65535) + 15 * (n >> 16), m = (m & 65535) + 15 * (m >> 16);
          }
          a = n, b = m;
        },
        d: function() {
          a %= 65521, b %= 65521;
          return (a & 255) << 24 | (a & 65280) << 8 | (b & 255) << 8 | b >> 8;
        }
      };
    };
    var dopt = function(dat, opt, pre, post, st) {
      if (!st) {
        st = { l: 1 };
        if (opt.dictionary) {
          var dict = opt.dictionary.subarray(-32768);
          var newDat = new u8(dict.length + dat.length);
          newDat.set(dict);
          newDat.set(dat, dict.length);
          dat = newDat;
          st.w = dict.length;
        }
      }
      return dflt(dat, opt.level == null ? 6 : opt.level, opt.mem == null ? st.l ? Math.ceil(Math.max(8, Math.min(13, Math.log(dat.length))) * 1.5) : 20 : 12 + opt.mem, pre, post, st);
    };
    var mrg = function(a, b) {
      var o = {};
      for (var k in a)
        o[k] = a[k];
      for (var k in b)
        o[k] = b[k];
      return o;
    };
    var wcln = function(fn, fnStr, td2) {
      var dt = fn();
      var st = fn.toString();
      var ks = st.slice(st.indexOf("[") + 1, st.lastIndexOf("]")).replace(/\s+/g, "").split(",");
      for (var i2 = 0; i2 < dt.length; ++i2) {
        var v = dt[i2], k = ks[i2];
        if (typeof v == "function") {
          fnStr += ";" + k + "=";
          var st_1 = v.toString();
          if (v.prototype) {
            if (st_1.indexOf("[native code]") != -1) {
              var spInd = st_1.indexOf(" ", 8) + 1;
              fnStr += st_1.slice(spInd, st_1.indexOf("(", spInd));
            } else {
              fnStr += st_1;
              for (var t in v.prototype)
                fnStr += ";" + k + ".prototype." + t + "=" + v.prototype[t].toString();
            }
          } else
            fnStr += st_1;
        } else
          td2[k] = v;
      }
      return fnStr;
    };
    var ch = [];
    var cbfs = function(v) {
      var tl = [];
      for (var k in v) {
        if (v[k].buffer) {
          tl.push((v[k] = new v[k].constructor(v[k])).buffer);
        }
      }
      return tl;
    };
    var wrkr = function(fns, init, id, cb) {
      if (!ch[id]) {
        var fnStr = "", td_1 = {}, m = fns.length - 1;
        for (var i2 = 0; i2 < m; ++i2)
          fnStr = wcln(fns[i2], fnStr, td_1);
        ch[id] = { c: wcln(fns[m], fnStr, td_1), e: td_1 };
      }
      var td2 = mrg({}, ch[id].e);
      return (0, node_worker_1.default)(ch[id].c + ";onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=" + init.toString() + "}", id, td2, cbfs(td2), cb);
    };
    var bInflt = function() {
      return [u8, u16, i32, fleb, fdeb, clim, fl, fd, flrm, fdrm, rev, ec, hMap, max, bits, bits16, shft, slc, err, inflt, inflateSync, pbf, gopt];
    };
    var bDflt = function() {
      return [u8, u16, i32, fleb, fdeb, clim, revfl, revfd, flm, flt, fdm, fdt, rev, deo, et, hMap, wbits, wbits16, hTree, ln, lc, clen, wfblk, wblk, shft, slc, dflt, dopt, deflateSync, pbf];
    };
    var gze = function() {
      return [gzh, gzhl, wbytes, crc, crct];
    };
    var guze = function() {
      return [gzs, gzl];
    };
    var zle = function() {
      return [zlh, wbytes, adler];
    };
    var zule = function() {
      return [zls];
    };
    var pbf = function(msg) {
      return postMessage(msg, [msg.buffer]);
    };
    var gopt = function(o) {
      return o && {
        out: o.size && new u8(o.size),
        dictionary: o.dictionary
      };
    };
    var cbify = function(dat, opts, fns, init, id, cb) {
      var w = wrkr(fns, init, id, function(err2, dat2) {
        w.terminate();
        cb(err2, dat2);
      });
      w.postMessage([dat, opts], opts.consume ? [dat.buffer] : []);
      return function() {
        w.terminate();
      };
    };
    var astrm = function(strm) {
      strm.ondata = function(dat, final) {
        return postMessage([dat, final], [dat.buffer]);
      };
      return function(ev) {
        if (ev.data.length) {
          strm.push(ev.data[0], ev.data[1]);
          postMessage([ev.data[0].length]);
        } else
          strm.flush();
      };
    };
    var astrmify = function(fns, strm, opts, init, id, flush, ext) {
      var t;
      var w = wrkr(fns, init, id, function(err2, dat) {
        if (err2)
          w.terminate(), strm.ondata.call(strm, err2);
        else if (!Array.isArray(dat))
          ext(dat);
        else if (dat.length == 1) {
          strm.queuedSize -= dat[0];
          if (strm.ondrain)
            strm.ondrain(dat[0]);
        } else {
          if (dat[1])
            w.terminate();
          strm.ondata.call(strm, err2, dat[0], dat[1]);
        }
      });
      w.postMessage(opts);
      strm.queuedSize = 0;
      strm.push = function(d, f) {
        if (!strm.ondata)
          err(5);
        if (t)
          strm.ondata(err(4, 0, 1), null, !!f);
        strm.queuedSize += d.length;
        w.postMessage([d, t = f], [d.buffer]);
      };
      strm.terminate = function() {
        w.terminate();
      };
      if (flush) {
        strm.flush = function() {
          w.postMessage([]);
        };
      }
    };
    var b2 = function(d, b) {
      return d[b] | d[b + 1] << 8;
    };
    var b4 = function(d, b) {
      return (d[b] | d[b + 1] << 8 | d[b + 2] << 16 | d[b + 3] << 24) >>> 0;
    };
    var b8 = function(d, b) {
      return b4(d, b) + b4(d, b + 4) * 4294967296;
    };
    var wbytes = function(d, b, v) {
      for (; v; ++b)
        d[b] = v, v >>>= 8;
    };
    var gzh = function(c, o) {
      var fn = o.filename;
      c[0] = 31, c[1] = 139, c[2] = 8, c[8] = o.level < 2 ? 4 : o.level == 9 ? 2 : 0, c[9] = 3;
      if (o.mtime != 0)
        wbytes(c, 4, Math.floor(new Date(o.mtime || Date.now()) / 1e3));
      if (fn) {
        c[3] = 8;
        for (var i2 = 0; i2 <= fn.length; ++i2)
          c[i2 + 10] = fn.charCodeAt(i2);
      }
    };
    var gzs = function(d) {
      if (d[0] != 31 || d[1] != 139 || d[2] != 8)
        err(6, "invalid gzip data");
      var flg = d[3];
      var st = 10;
      if (flg & 4)
        st += (d[10] | d[11] << 8) + 2;
      for (var zs = (flg >> 3 & 1) + (flg >> 4 & 1); zs > 0; zs -= !d[st++])
        ;
      return st + (flg & 2);
    };
    var gzl = function(d) {
      var l = d.length;
      return (d[l - 4] | d[l - 3] << 8 | d[l - 2] << 16 | d[l - 1] << 24) >>> 0;
    };
    var gzhl = function(o) {
      return 10 + (o.filename ? o.filename.length + 1 : 0);
    };
    var zlh = function(c, o) {
      var lv = o.level, fl2 = lv == 0 ? 0 : lv < 6 ? 1 : lv == 9 ? 3 : 2;
      c[0] = 120, c[1] = fl2 << 6 | (o.dictionary && 32);
      c[1] |= 31 - (c[0] << 8 | c[1]) % 31;
      if (o.dictionary) {
        var h = adler();
        h.p(o.dictionary);
        wbytes(c, 2, h.d());
      }
    };
    var zls = function(d, dict) {
      if ((d[0] & 15) != 8 || d[0] >> 4 > 7 || (d[0] << 8 | d[1]) % 31)
        err(6, "invalid zlib data");
      if ((d[1] >> 5 & 1) == +!dict)
        err(6, "invalid zlib data: " + (d[1] & 32 ? "need" : "unexpected") + " dictionary");
      return (d[1] >> 3 & 4) + 2;
    };
    function StrmOpt(opts, cb) {
      if (typeof opts == "function")
        cb = opts, opts = {};
      this.ondata = cb;
      return opts;
    }
    var Deflate = (function() {
      function Deflate2(opts, cb) {
        if (typeof opts == "function")
          cb = opts, opts = {};
        this.ondata = cb;
        this.o = opts || {};
        this.s = { l: 0, i: 32768, w: 32768, z: 32768 };
        this.b = new u8(98304);
        if (this.o.dictionary) {
          var dict = this.o.dictionary.subarray(-32768);
          this.b.set(dict, 32768 - dict.length);
          this.s.i = 32768 - dict.length;
        }
      }
      Deflate2.prototype.p = function(c, f) {
        this.ondata(dopt(c, this.o, 0, 0, this.s), f);
      };
      Deflate2.prototype.push = function(chunk, final) {
        if (!this.ondata)
          err(5);
        if (this.s.l)
          err(4);
        var endLen = chunk.length + this.s.z;
        if (endLen > this.b.length) {
          if (endLen > 2 * this.b.length - 32768) {
            var newBuf = new u8(endLen & -32768);
            newBuf.set(this.b.subarray(0, this.s.z));
            this.b = newBuf;
          }
          var split = this.b.length - this.s.z;
          this.b.set(chunk.subarray(0, split), this.s.z);
          this.s.z = this.b.length;
          this.p(this.b, false);
          this.b.set(this.b.subarray(-32768));
          this.b.set(chunk.subarray(split), 32768);
          this.s.z = chunk.length - split + 32768;
          this.s.i = 32766, this.s.w = 32768;
        } else {
          this.b.set(chunk, this.s.z);
          this.s.z += chunk.length;
        }
        this.s.l = final & 1;
        if (this.s.z > this.s.w + 8191 || final) {
          this.p(this.b, final || false);
          this.s.w = this.s.i, this.s.i -= 2;
        }
      };
      Deflate2.prototype.flush = function() {
        if (!this.ondata)
          err(5);
        if (this.s.l)
          err(4);
        this.p(this.b, false);
        this.s.w = this.s.i, this.s.i -= 2;
      };
      return Deflate2;
    })();
    exports2.Deflate = Deflate;
    var AsyncDeflate = /* @__PURE__ */ (function() {
      function AsyncDeflate2(opts, cb) {
        astrmify([
          bDflt,
          function() {
            return [astrm, Deflate];
          }
        ], this, StrmOpt.call(this, opts, cb), function(ev) {
          var strm = new Deflate(ev.data);
          onmessage = astrm(strm);
        }, 6, 1);
      }
      return AsyncDeflate2;
    })();
    exports2.AsyncDeflate = AsyncDeflate;
    function deflate(data, opts, cb) {
      if (!cb)
        cb = opts, opts = {};
      if (typeof cb != "function")
        err(7);
      return cbify(data, opts, [
        bDflt
      ], function(ev) {
        return pbf(deflateSync(ev.data[0], ev.data[1]));
      }, 0, cb);
    }
    exports2.deflate = deflate;
    function deflateSync(data, opts) {
      return dopt(data, opts || {}, 0, 0);
    }
    exports2.deflateSync = deflateSync;
    var Inflate = (function() {
      function Inflate2(opts, cb) {
        if (typeof opts == "function")
          cb = opts, opts = {};
        this.ondata = cb;
        var dict = opts && opts.dictionary && opts.dictionary.subarray(-32768);
        this.s = { i: 0, b: dict ? dict.length : 0 };
        this.o = new u8(32768);
        this.p = new u8(0);
        if (dict)
          this.o.set(dict);
      }
      Inflate2.prototype.e = function(c) {
        if (!this.ondata)
          err(5);
        if (this.d)
          err(4);
        if (!this.p.length)
          this.p = c;
        else if (c.length) {
          var n = new u8(this.p.length + c.length);
          n.set(this.p), n.set(c, this.p.length), this.p = n;
        }
      };
      Inflate2.prototype.c = function(final) {
        this.s.i = +(this.d = final || false);
        var bts = this.s.b;
        var dt = inflt(this.p, this.s, this.o);
        this.ondata(slc(dt, bts, this.s.b), this.d);
        this.o = slc(dt, this.s.b - 32768), this.s.b = this.o.length;
        this.p = slc(this.p, this.s.p / 8 | 0), this.s.p &= 7;
      };
      Inflate2.prototype.push = function(chunk, final) {
        this.e(chunk), this.c(final);
      };
      return Inflate2;
    })();
    exports2.Inflate = Inflate;
    var AsyncInflate = /* @__PURE__ */ (function() {
      function AsyncInflate2(opts, cb) {
        astrmify([
          bInflt,
          function() {
            return [astrm, Inflate];
          }
        ], this, StrmOpt.call(this, opts, cb), function(ev) {
          var strm = new Inflate(ev.data);
          onmessage = astrm(strm);
        }, 7, 0);
      }
      return AsyncInflate2;
    })();
    exports2.AsyncInflate = AsyncInflate;
    function inflate(data, opts, cb) {
      if (!cb)
        cb = opts, opts = {};
      if (typeof cb != "function")
        err(7);
      return cbify(data, opts, [
        bInflt
      ], function(ev) {
        return pbf(inflateSync(ev.data[0], gopt(ev.data[1])));
      }, 1, cb);
    }
    exports2.inflate = inflate;
    function inflateSync(data, opts) {
      return inflt(data, { i: 2 }, opts && opts.out, opts && opts.dictionary);
    }
    exports2.inflateSync = inflateSync;
    var Gzip = (function() {
      function Gzip2(opts, cb) {
        this.c = crc();
        this.l = 0;
        this.v = 1;
        Deflate.call(this, opts, cb);
      }
      Gzip2.prototype.push = function(chunk, final) {
        this.c.p(chunk);
        this.l += chunk.length;
        Deflate.prototype.push.call(this, chunk, final);
      };
      Gzip2.prototype.p = function(c, f) {
        var raw = dopt(c, this.o, this.v && gzhl(this.o), f && 8, this.s);
        if (this.v)
          gzh(raw, this.o), this.v = 0;
        if (f)
          wbytes(raw, raw.length - 8, this.c.d()), wbytes(raw, raw.length - 4, this.l);
        this.ondata(raw, f);
      };
      Gzip2.prototype.flush = function() {
        Deflate.prototype.flush.call(this);
      };
      return Gzip2;
    })();
    exports2.Gzip = Gzip;
    exports2.Compress = Gzip;
    var AsyncGzip = /* @__PURE__ */ (function() {
      function AsyncGzip2(opts, cb) {
        astrmify([
          bDflt,
          gze,
          function() {
            return [astrm, Deflate, Gzip];
          }
        ], this, StrmOpt.call(this, opts, cb), function(ev) {
          var strm = new Gzip(ev.data);
          onmessage = astrm(strm);
        }, 8, 1);
      }
      return AsyncGzip2;
    })();
    exports2.AsyncGzip = AsyncGzip;
    exports2.AsyncCompress = AsyncGzip;
    function gzip(data, opts, cb) {
      if (!cb)
        cb = opts, opts = {};
      if (typeof cb != "function")
        err(7);
      return cbify(data, opts, [
        bDflt,
        gze,
        function() {
          return [gzipSync];
        }
      ], function(ev) {
        return pbf(gzipSync(ev.data[0], ev.data[1]));
      }, 2, cb);
    }
    exports2.gzip = gzip;
    exports2.compress = gzip;
    function gzipSync(data, opts) {
      if (!opts)
        opts = {};
      var c = crc(), l = data.length;
      c.p(data);
      var d = dopt(data, opts, gzhl(opts), 8), s = d.length;
      return gzh(d, opts), wbytes(d, s - 8, c.d()), wbytes(d, s - 4, l), d;
    }
    exports2.gzipSync = gzipSync;
    exports2.compressSync = gzipSync;
    var Gunzip = (function() {
      function Gunzip2(opts, cb) {
        this.v = 1;
        this.r = 0;
        Inflate.call(this, opts, cb);
      }
      Gunzip2.prototype.push = function(chunk, final) {
        Inflate.prototype.e.call(this, chunk);
        this.r += chunk.length;
        if (this.v) {
          var p = this.p.subarray(this.v - 1);
          var s = p.length > 3 ? gzs(p) : 4;
          if (s > p.length) {
            if (!final)
              return;
          } else if (this.v > 1 && this.onmember) {
            this.onmember(this.r - p.length);
          }
          this.p = p.subarray(s), this.v = 0;
        }
        Inflate.prototype.c.call(this, final);
        if (this.s.f && !this.s.l && !final) {
          this.v = shft(this.s.p) + 9;
          this.s = { i: 0 };
          this.o = new u8(0);
          this.push(new u8(0), final);
        }
      };
      return Gunzip2;
    })();
    exports2.Gunzip = Gunzip;
    var AsyncGunzip = /* @__PURE__ */ (function() {
      function AsyncGunzip2(opts, cb) {
        var _this = this;
        astrmify([
          bInflt,
          guze,
          function() {
            return [astrm, Inflate, Gunzip];
          }
        ], this, StrmOpt.call(this, opts, cb), function(ev) {
          var strm = new Gunzip(ev.data);
          strm.onmember = function(offset) {
            return postMessage(offset);
          };
          onmessage = astrm(strm);
        }, 9, 0, function(offset) {
          return _this.onmember && _this.onmember(offset);
        });
      }
      return AsyncGunzip2;
    })();
    exports2.AsyncGunzip = AsyncGunzip;
    function gunzip(data, opts, cb) {
      if (!cb)
        cb = opts, opts = {};
      if (typeof cb != "function")
        err(7);
      return cbify(data, opts, [
        bInflt,
        guze,
        function() {
          return [gunzipSync];
        }
      ], function(ev) {
        return pbf(gunzipSync(ev.data[0], ev.data[1]));
      }, 3, cb);
    }
    exports2.gunzip = gunzip;
    function gunzipSync(data, opts) {
      var st = gzs(data);
      if (st + 8 > data.length)
        err(6, "invalid gzip data");
      return inflt(data.subarray(st, -8), { i: 2 }, opts && opts.out || new u8(gzl(data)), opts && opts.dictionary);
    }
    exports2.gunzipSync = gunzipSync;
    var Zlib = (function() {
      function Zlib2(opts, cb) {
        this.c = adler();
        this.v = 1;
        Deflate.call(this, opts, cb);
      }
      Zlib2.prototype.push = function(chunk, final) {
        this.c.p(chunk);
        Deflate.prototype.push.call(this, chunk, final);
      };
      Zlib2.prototype.p = function(c, f) {
        var raw = dopt(c, this.o, this.v && (this.o.dictionary ? 6 : 2), f && 4, this.s);
        if (this.v)
          zlh(raw, this.o), this.v = 0;
        if (f)
          wbytes(raw, raw.length - 4, this.c.d());
        this.ondata(raw, f);
      };
      Zlib2.prototype.flush = function() {
        Deflate.prototype.flush.call(this);
      };
      return Zlib2;
    })();
    exports2.Zlib = Zlib;
    var AsyncZlib = /* @__PURE__ */ (function() {
      function AsyncZlib2(opts, cb) {
        astrmify([
          bDflt,
          zle,
          function() {
            return [astrm, Deflate, Zlib];
          }
        ], this, StrmOpt.call(this, opts, cb), function(ev) {
          var strm = new Zlib(ev.data);
          onmessage = astrm(strm);
        }, 10, 1);
      }
      return AsyncZlib2;
    })();
    exports2.AsyncZlib = AsyncZlib;
    function zlib(data, opts, cb) {
      if (!cb)
        cb = opts, opts = {};
      if (typeof cb != "function")
        err(7);
      return cbify(data, opts, [
        bDflt,
        zle,
        function() {
          return [zlibSync];
        }
      ], function(ev) {
        return pbf(zlibSync(ev.data[0], ev.data[1]));
      }, 4, cb);
    }
    exports2.zlib = zlib;
    function zlibSync(data, opts) {
      if (!opts)
        opts = {};
      var a = adler();
      a.p(data);
      var d = dopt(data, opts, opts.dictionary ? 6 : 2, 4);
      return zlh(d, opts), wbytes(d, d.length - 4, a.d()), d;
    }
    exports2.zlibSync = zlibSync;
    var Unzlib = (function() {
      function Unzlib2(opts, cb) {
        Inflate.call(this, opts, cb);
        this.v = opts && opts.dictionary ? 2 : 1;
      }
      Unzlib2.prototype.push = function(chunk, final) {
        Inflate.prototype.e.call(this, chunk);
        if (this.v) {
          if (this.p.length < 6 && !final)
            return;
          this.p = this.p.subarray(zls(this.p, this.v - 1)), this.v = 0;
        }
        if (final) {
          if (this.p.length < 4)
            err(6, "invalid zlib data");
          this.p = this.p.subarray(0, -4);
        }
        Inflate.prototype.c.call(this, final);
      };
      return Unzlib2;
    })();
    exports2.Unzlib = Unzlib;
    var AsyncUnzlib = /* @__PURE__ */ (function() {
      function AsyncUnzlib2(opts, cb) {
        astrmify([
          bInflt,
          zule,
          function() {
            return [astrm, Inflate, Unzlib];
          }
        ], this, StrmOpt.call(this, opts, cb), function(ev) {
          var strm = new Unzlib(ev.data);
          onmessage = astrm(strm);
        }, 11, 0);
      }
      return AsyncUnzlib2;
    })();
    exports2.AsyncUnzlib = AsyncUnzlib;
    function unzlib(data, opts, cb) {
      if (!cb)
        cb = opts, opts = {};
      if (typeof cb != "function")
        err(7);
      return cbify(data, opts, [
        bInflt,
        zule,
        function() {
          return [unzlibSync];
        }
      ], function(ev) {
        return pbf(unzlibSync(ev.data[0], gopt(ev.data[1])));
      }, 5, cb);
    }
    exports2.unzlib = unzlib;
    function unzlibSync(data, opts) {
      return inflt(data.subarray(zls(data, opts && opts.dictionary), -4), { i: 2 }, opts && opts.out, opts && opts.dictionary);
    }
    exports2.unzlibSync = unzlibSync;
    var Decompress = (function() {
      function Decompress2(opts, cb) {
        this.o = StrmOpt.call(this, opts, cb) || {};
        this.G = Gunzip;
        this.I = Inflate;
        this.Z = Unzlib;
      }
      Decompress2.prototype.i = function() {
        var _this = this;
        this.s.ondata = function(dat, final) {
          _this.ondata(dat, final);
        };
      };
      Decompress2.prototype.push = function(chunk, final) {
        if (!this.ondata)
          err(5);
        if (!this.s) {
          if (this.p && this.p.length) {
            var n = new u8(this.p.length + chunk.length);
            n.set(this.p), n.set(chunk, this.p.length);
          } else
            this.p = chunk;
          if (this.p.length > 2) {
            this.s = this.p[0] == 31 && this.p[1] == 139 && this.p[2] == 8 ? new this.G(this.o) : (this.p[0] & 15) != 8 || this.p[0] >> 4 > 7 || (this.p[0] << 8 | this.p[1]) % 31 ? new this.I(this.o) : new this.Z(this.o);
            this.i();
            this.s.push(this.p, final);
            this.p = null;
          }
        } else
          this.s.push(chunk, final);
      };
      return Decompress2;
    })();
    exports2.Decompress = Decompress;
    var AsyncDecompress = (function() {
      function AsyncDecompress2(opts, cb) {
        Decompress.call(this, opts, cb);
        this.queuedSize = 0;
        this.G = AsyncGunzip;
        this.I = AsyncInflate;
        this.Z = AsyncUnzlib;
      }
      AsyncDecompress2.prototype.i = function() {
        var _this = this;
        this.s.ondata = function(err2, dat, final) {
          _this.ondata(err2, dat, final);
        };
        this.s.ondrain = function(size) {
          _this.queuedSize -= size;
          if (_this.ondrain)
            _this.ondrain(size);
        };
      };
      AsyncDecompress2.prototype.push = function(chunk, final) {
        this.queuedSize += chunk.length;
        Decompress.prototype.push.call(this, chunk, final);
      };
      return AsyncDecompress2;
    })();
    exports2.AsyncDecompress = AsyncDecompress;
    function decompress(data, opts, cb) {
      if (!cb)
        cb = opts, opts = {};
      if (typeof cb != "function")
        err(7);
      return data[0] == 31 && data[1] == 139 && data[2] == 8 ? gunzip(data, opts, cb) : (data[0] & 15) != 8 || data[0] >> 4 > 7 || (data[0] << 8 | data[1]) % 31 ? inflate(data, opts, cb) : unzlib(data, opts, cb);
    }
    exports2.decompress = decompress;
    function decompressSync(data, opts) {
      return data[0] == 31 && data[1] == 139 && data[2] == 8 ? gunzipSync(data, opts) : (data[0] & 15) != 8 || data[0] >> 4 > 7 || (data[0] << 8 | data[1]) % 31 ? inflateSync(data, opts) : unzlibSync(data, opts);
    }
    exports2.decompressSync = decompressSync;
    var fltn = function(d, p, t, o) {
      for (var k in d) {
        var val = d[k], n = p + k, op = o;
        if (Array.isArray(val))
          op = mrg(o, val[1]), val = val[0];
        if (val instanceof u8)
          t[n] = [val, op];
        else {
          t[n += "/"] = [new u8(0), op];
          fltn(val, n, t, o);
        }
      }
    };
    var te = typeof TextEncoder != "undefined" && new TextEncoder();
    var td = typeof TextDecoder != "undefined" && new TextDecoder();
    var tds = 0;
    try {
      td.decode(et, { stream: true });
      tds = 1;
    } catch (e) {
    }
    var dutf8 = function(d) {
      for (var r = "", i2 = 0; ; ) {
        var c = d[i2++];
        var eb = (c > 127) + (c > 223) + (c > 239);
        if (i2 + eb > d.length)
          return { s: r, r: slc(d, i2 - 1) };
        if (!eb)
          r += String.fromCharCode(c);
        else if (eb == 3) {
          c = ((c & 15) << 18 | (d[i2++] & 63) << 12 | (d[i2++] & 63) << 6 | d[i2++] & 63) - 65536, r += String.fromCharCode(55296 | c >> 10, 56320 | c & 1023);
        } else if (eb & 1)
          r += String.fromCharCode((c & 31) << 6 | d[i2++] & 63);
        else
          r += String.fromCharCode((c & 15) << 12 | (d[i2++] & 63) << 6 | d[i2++] & 63);
      }
    };
    var DecodeUTF8 = (function() {
      function DecodeUTF82(cb) {
        this.ondata = cb;
        if (tds)
          this.t = new TextDecoder();
        else
          this.p = et;
      }
      DecodeUTF82.prototype.push = function(chunk, final) {
        if (!this.ondata)
          err(5);
        final = !!final;
        if (this.t) {
          this.ondata(this.t.decode(chunk, { stream: true }), final);
          if (final) {
            if (this.t.decode().length)
              err(8);
            this.t = null;
          }
          return;
        }
        if (!this.p)
          err(4);
        var dat = new u8(this.p.length + chunk.length);
        dat.set(this.p);
        dat.set(chunk, this.p.length);
        var _a2 = dutf8(dat), s = _a2.s, r = _a2.r;
        if (final) {
          if (r.length)
            err(8);
          this.p = null;
        } else
          this.p = r;
        this.ondata(s, final);
      };
      return DecodeUTF82;
    })();
    exports2.DecodeUTF8 = DecodeUTF8;
    var EncodeUTF8 = (function() {
      function EncodeUTF82(cb) {
        this.ondata = cb;
      }
      EncodeUTF82.prototype.push = function(chunk, final) {
        if (!this.ondata)
          err(5);
        if (this.d)
          err(4);
        this.ondata(strToU8(chunk), this.d = final || false);
      };
      return EncodeUTF82;
    })();
    exports2.EncodeUTF8 = EncodeUTF8;
    function strToU8(str, latin1) {
      if (latin1) {
        var ar_1 = new u8(str.length);
        for (var i2 = 0; i2 < str.length; ++i2)
          ar_1[i2] = str.charCodeAt(i2);
        return ar_1;
      }
      if (te)
        return te.encode(str);
      var l = str.length;
      var ar = new u8(str.length + (str.length >> 1));
      var ai = 0;
      var w = function(v) {
        ar[ai++] = v;
      };
      for (var i2 = 0; i2 < l; ++i2) {
        if (ai + 5 > ar.length) {
          var n = new u8(ai + 8 + (l - i2 << 1));
          n.set(ar);
          ar = n;
        }
        var c = str.charCodeAt(i2);
        if (c < 128 || latin1)
          w(c);
        else if (c < 2048)
          w(192 | c >> 6), w(128 | c & 63);
        else if (c > 55295 && c < 57344)
          c = 65536 + (c & 1023 << 10) | str.charCodeAt(++i2) & 1023, w(240 | c >> 18), w(128 | c >> 12 & 63), w(128 | c >> 6 & 63), w(128 | c & 63);
        else
          w(224 | c >> 12), w(128 | c >> 6 & 63), w(128 | c & 63);
      }
      return slc(ar, 0, ai);
    }
    exports2.strToU8 = strToU8;
    function strFromU8(dat, latin1) {
      if (latin1) {
        var r = "";
        for (var i2 = 0; i2 < dat.length; i2 += 16384)
          r += String.fromCharCode.apply(null, dat.subarray(i2, i2 + 16384));
        return r;
      } else if (td) {
        return td.decode(dat);
      } else {
        var _a2 = dutf8(dat), s = _a2.s, r = _a2.r;
        if (r.length)
          err(8);
        return s;
      }
    }
    exports2.strFromU8 = strFromU8;
    var dbf = function(l) {
      return l == 1 ? 3 : l < 6 ? 2 : l == 9 ? 1 : 0;
    };
    var slzh = function(d, b) {
      return b + 30 + b2(d, b + 26) + b2(d, b + 28);
    };
    var zh = function(d, b, z) {
      var fnl = b2(d, b + 28), fn = strFromU8(d.subarray(b + 46, b + 46 + fnl), !(b2(d, b + 8) & 2048)), es = b + 46 + fnl, bs = b4(d, b + 20);
      var _a2 = z && bs == 4294967295 ? z64e(d, es) : [bs, b4(d, b + 24), b4(d, b + 42)], sc = _a2[0], su = _a2[1], off = _a2[2];
      return [b2(d, b + 10), sc, su, fn, es + b2(d, b + 30) + b2(d, b + 32), off];
    };
    var z64e = function(d, b) {
      for (; b2(d, b) != 1; b += 4 + b2(d, b + 2))
        ;
      return [b8(d, b + 12), b8(d, b + 4), b8(d, b + 20)];
    };
    var exfl = function(ex) {
      var le = 0;
      if (ex) {
        for (var k in ex) {
          var l = ex[k].length;
          if (l > 65535)
            err(9);
          le += l + 4;
        }
      }
      return le;
    };
    var wzh = function(d, b, f, fn, u, c, ce, co) {
      var fl2 = fn.length, ex = f.extra, col = co && co.length;
      var exl = exfl(ex);
      wbytes(d, b, ce != null ? 33639248 : 67324752), b += 4;
      if (ce != null)
        d[b++] = 20, d[b++] = f.os;
      d[b] = 20, b += 2;
      d[b++] = f.flag << 1 | (c < 0 && 8), d[b++] = u && 8;
      d[b++] = f.compression & 255, d[b++] = f.compression >> 8;
      var dt = new Date(f.mtime == null ? Date.now() : f.mtime), y = dt.getFullYear() - 1980;
      if (y < 0 || y > 119)
        err(10);
      wbytes(d, b, y << 25 | dt.getMonth() + 1 << 21 | dt.getDate() << 16 | dt.getHours() << 11 | dt.getMinutes() << 5 | dt.getSeconds() >> 1), b += 4;
      if (c != -1) {
        wbytes(d, b, f.crc);
        wbytes(d, b + 4, c < 0 ? -c - 2 : c);
        wbytes(d, b + 8, f.size);
      }
      wbytes(d, b + 12, fl2);
      wbytes(d, b + 14, exl), b += 16;
      if (ce != null) {
        wbytes(d, b, col);
        wbytes(d, b + 6, f.attrs);
        wbytes(d, b + 10, ce), b += 14;
      }
      d.set(fn, b);
      b += fl2;
      if (exl) {
        for (var k in ex) {
          var exf = ex[k], l = exf.length;
          wbytes(d, b, +k);
          wbytes(d, b + 2, l);
          d.set(exf, b + 4), b += 4 + l;
        }
      }
      if (col)
        d.set(co, b), b += col;
      return b;
    };
    var wzf = function(o, b, c, d, e) {
      wbytes(o, b, 101010256);
      wbytes(o, b + 8, c);
      wbytes(o, b + 10, c);
      wbytes(o, b + 12, d);
      wbytes(o, b + 16, e);
    };
    var ZipPassThrough = (function() {
      function ZipPassThrough2(filename) {
        this.filename = filename;
        this.c = crc();
        this.size = 0;
        this.compression = 0;
      }
      ZipPassThrough2.prototype.process = function(chunk, final) {
        this.ondata(null, chunk, final);
      };
      ZipPassThrough2.prototype.push = function(chunk, final) {
        if (!this.ondata)
          err(5);
        this.c.p(chunk);
        this.size += chunk.length;
        if (final)
          this.crc = this.c.d();
        this.process(chunk, final || false);
      };
      return ZipPassThrough2;
    })();
    exports2.ZipPassThrough = ZipPassThrough;
    var ZipDeflate = (function() {
      function ZipDeflate2(filename, opts) {
        var _this = this;
        if (!opts)
          opts = {};
        ZipPassThrough.call(this, filename);
        this.d = new Deflate(opts, function(dat, final) {
          _this.ondata(null, dat, final);
        });
        this.compression = 8;
        this.flag = dbf(opts.level);
      }
      ZipDeflate2.prototype.process = function(chunk, final) {
        try {
          this.d.push(chunk, final);
        } catch (e) {
          this.ondata(e, null, final);
        }
      };
      ZipDeflate2.prototype.push = function(chunk, final) {
        ZipPassThrough.prototype.push.call(this, chunk, final);
      };
      return ZipDeflate2;
    })();
    exports2.ZipDeflate = ZipDeflate;
    var AsyncZipDeflate = (function() {
      function AsyncZipDeflate2(filename, opts) {
        var _this = this;
        if (!opts)
          opts = {};
        ZipPassThrough.call(this, filename);
        this.d = new AsyncDeflate(opts, function(err2, dat, final) {
          _this.ondata(err2, dat, final);
        });
        this.compression = 8;
        this.flag = dbf(opts.level);
        this.terminate = this.d.terminate;
      }
      AsyncZipDeflate2.prototype.process = function(chunk, final) {
        this.d.push(chunk, final);
      };
      AsyncZipDeflate2.prototype.push = function(chunk, final) {
        ZipPassThrough.prototype.push.call(this, chunk, final);
      };
      return AsyncZipDeflate2;
    })();
    exports2.AsyncZipDeflate = AsyncZipDeflate;
    var Zip = (function() {
      function Zip2(cb) {
        this.ondata = cb;
        this.u = [];
        this.d = 1;
      }
      Zip2.prototype.add = function(file) {
        var _this = this;
        if (!this.ondata)
          err(5);
        if (this.d & 2)
          this.ondata(err(4 + (this.d & 1) * 8, 0, 1), null, false);
        else {
          var f = strToU8(file.filename), fl_1 = f.length;
          var com = file.comment, o = com && strToU8(com);
          var u = fl_1 != file.filename.length || o && com.length != o.length;
          var hl_1 = fl_1 + exfl(file.extra) + 30;
          if (fl_1 > 65535)
            this.ondata(err(11, 0, 1), null, false);
          var header = new u8(hl_1);
          wzh(header, 0, file, f, u, -1);
          var chks_1 = [header];
          var pAll_1 = function() {
            for (var _i = 0, chks_2 = chks_1; _i < chks_2.length; _i++) {
              var chk = chks_2[_i];
              _this.ondata(null, chk, false);
            }
            chks_1 = [];
          };
          var tr_1 = this.d;
          this.d = 0;
          var ind_1 = this.u.length;
          var uf_1 = mrg(file, {
            f,
            u,
            o,
            t: function() {
              if (file.terminate)
                file.terminate();
            },
            r: function() {
              pAll_1();
              if (tr_1) {
                var nxt = _this.u[ind_1 + 1];
                if (nxt)
                  nxt.r();
                else
                  _this.d = 1;
              }
              tr_1 = 1;
            }
          });
          var cl_1 = 0;
          file.ondata = function(err2, dat, final) {
            if (err2) {
              _this.ondata(err2, dat, final);
              _this.terminate();
            } else {
              cl_1 += dat.length;
              chks_1.push(dat);
              if (final) {
                var dd = new u8(16);
                wbytes(dd, 0, 134695760);
                wbytes(dd, 4, file.crc);
                wbytes(dd, 8, cl_1);
                wbytes(dd, 12, file.size);
                chks_1.push(dd);
                uf_1.c = cl_1, uf_1.b = hl_1 + cl_1 + 16, uf_1.crc = file.crc, uf_1.size = file.size;
                if (tr_1)
                  uf_1.r();
                tr_1 = 1;
              } else if (tr_1)
                pAll_1();
            }
          };
          this.u.push(uf_1);
        }
      };
      Zip2.prototype.end = function() {
        var _this = this;
        if (this.d & 2) {
          this.ondata(err(4 + (this.d & 1) * 8, 0, 1), null, true);
          return;
        }
        if (this.d)
          this.e();
        else
          this.u.push({
            r: function() {
              if (!(_this.d & 1))
                return;
              _this.u.splice(-1, 1);
              _this.e();
            },
            t: function() {
            }
          });
        this.d = 3;
      };
      Zip2.prototype.e = function() {
        var bt = 0, l = 0, tl = 0;
        for (var _i = 0, _a2 = this.u; _i < _a2.length; _i++) {
          var f = _a2[_i];
          tl += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0);
        }
        var out = new u8(tl + 22);
        for (var _b2 = 0, _c = this.u; _b2 < _c.length; _b2++) {
          var f = _c[_b2];
          wzh(out, bt, f, f.f, f.u, -f.c - 2, l, f.o);
          bt += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0), l += f.b;
        }
        wzf(out, bt, this.u.length, tl, l);
        this.ondata(null, out, true);
        this.d = 2;
      };
      Zip2.prototype.terminate = function() {
        for (var _i = 0, _a2 = this.u; _i < _a2.length; _i++) {
          var f = _a2[_i];
          f.t();
        }
        this.d = 2;
      };
      return Zip2;
    })();
    exports2.Zip = Zip;
    function zip(data, opts, cb) {
      if (!cb)
        cb = opts, opts = {};
      if (typeof cb != "function")
        err(7);
      var r = {};
      fltn(data, "", r, opts);
      var k = Object.keys(r);
      var lft = k.length, o = 0, tot = 0;
      var slft = lft, files = new Array(lft);
      var term = [];
      var tAll = function() {
        for (var i3 = 0; i3 < term.length; ++i3)
          term[i3]();
      };
      var cbd = function(a, b) {
        mt(function() {
          cb(a, b);
        });
      };
      mt(function() {
        cbd = cb;
      });
      var cbf = function() {
        var out = new u8(tot + 22), oe = o, cdl = tot - o;
        tot = 0;
        for (var i3 = 0; i3 < slft; ++i3) {
          var f = files[i3];
          try {
            var l = f.c.length;
            wzh(out, tot, f, f.f, f.u, l);
            var badd = 30 + f.f.length + exfl(f.extra);
            var loc = tot + badd;
            out.set(f.c, loc);
            wzh(out, o, f, f.f, f.u, l, tot, f.m), o += 16 + badd + (f.m ? f.m.length : 0), tot = loc + l;
          } catch (e) {
            return cbd(e, null);
          }
        }
        wzf(out, o, files.length, cdl, oe);
        cbd(null, out);
      };
      if (!lft)
        cbf();
      var _loop_1 = function(i3) {
        var fn = k[i3];
        var _a2 = r[fn], file = _a2[0], p = _a2[1];
        var c = crc(), size = file.length;
        c.p(file);
        var f = strToU8(fn), s = f.length;
        var com = p.comment, m = com && strToU8(com), ms = m && m.length;
        var exl = exfl(p.extra);
        var compression = p.level == 0 ? 0 : 8;
        var cbl = function(e, d) {
          if (e) {
            tAll();
            cbd(e, null);
          } else {
            var l = d.length;
            files[i3] = mrg(p, {
              size,
              crc: c.d(),
              c: d,
              f,
              m,
              u: s != fn.length || m && com.length != ms,
              compression
            });
            o += 30 + s + exl + l;
            tot += 76 + 2 * (s + exl) + (ms || 0) + l;
            if (!--lft)
              cbf();
          }
        };
        if (s > 65535)
          cbl(err(11, 0, 1), null);
        if (!compression)
          cbl(null, file);
        else if (size < 16e4) {
          try {
            cbl(null, deflateSync(file, p));
          } catch (e) {
            cbl(e, null);
          }
        } else
          term.push(deflate(file, p, cbl));
      };
      for (var i2 = 0; i2 < slft; ++i2) {
        _loop_1(i2);
      }
      return tAll;
    }
    exports2.zip = zip;
    function zipSync(data, opts) {
      if (!opts)
        opts = {};
      var r = {};
      var files = [];
      fltn(data, "", r, opts);
      var o = 0;
      var tot = 0;
      for (var fn in r) {
        var _a2 = r[fn], file = _a2[0], p = _a2[1];
        var compression = p.level == 0 ? 0 : 8;
        var f = strToU8(fn), s = f.length;
        var com = p.comment, m = com && strToU8(com), ms = m && m.length;
        var exl = exfl(p.extra);
        if (s > 65535)
          err(11);
        var d = compression ? deflateSync(file, p) : file, l = d.length;
        var c = crc();
        c.p(file);
        files.push(mrg(p, {
          size: file.length,
          crc: c.d(),
          c: d,
          f,
          m,
          u: s != fn.length || m && com.length != ms,
          o,
          compression
        }));
        o += 30 + s + exl + l;
        tot += 76 + 2 * (s + exl) + (ms || 0) + l;
      }
      var out = new u8(tot + 22), oe = o, cdl = tot - o;
      for (var i2 = 0; i2 < files.length; ++i2) {
        var f = files[i2];
        wzh(out, f.o, f, f.f, f.u, f.c.length);
        var badd = 30 + f.f.length + exfl(f.extra);
        out.set(f.c, f.o + badd);
        wzh(out, o, f, f.f, f.u, f.c.length, f.o, f.m), o += 16 + badd + (f.m ? f.m.length : 0);
      }
      wzf(out, o, files.length, cdl, oe);
      return out;
    }
    exports2.zipSync = zipSync;
    var UnzipPassThrough = (function() {
      function UnzipPassThrough2() {
      }
      UnzipPassThrough2.prototype.push = function(data, final) {
        this.ondata(null, data, final);
      };
      UnzipPassThrough2.compression = 0;
      return UnzipPassThrough2;
    })();
    exports2.UnzipPassThrough = UnzipPassThrough;
    var UnzipInflate = (function() {
      function UnzipInflate2() {
        var _this = this;
        this.i = new Inflate(function(dat, final) {
          _this.ondata(null, dat, final);
        });
      }
      UnzipInflate2.prototype.push = function(data, final) {
        try {
          this.i.push(data, final);
        } catch (e) {
          this.ondata(e, null, final);
        }
      };
      UnzipInflate2.compression = 8;
      return UnzipInflate2;
    })();
    exports2.UnzipInflate = UnzipInflate;
    var AsyncUnzipInflate = (function() {
      function AsyncUnzipInflate2(_, sz) {
        var _this = this;
        if (sz < 32e4) {
          this.i = new Inflate(function(dat, final) {
            _this.ondata(null, dat, final);
          });
        } else {
          this.i = new AsyncInflate(function(err2, dat, final) {
            _this.ondata(err2, dat, final);
          });
          this.terminate = this.i.terminate;
        }
      }
      AsyncUnzipInflate2.prototype.push = function(data, final) {
        if (this.i.terminate)
          data = slc(data, 0);
        this.i.push(data, final);
      };
      AsyncUnzipInflate2.compression = 8;
      return AsyncUnzipInflate2;
    })();
    exports2.AsyncUnzipInflate = AsyncUnzipInflate;
    var Unzip = (function() {
      function Unzip2(cb) {
        this.onfile = cb;
        this.k = [];
        this.o = {
          0: UnzipPassThrough
        };
        this.p = et;
      }
      Unzip2.prototype.push = function(chunk, final) {
        var _this = this;
        if (!this.onfile)
          err(5);
        if (!this.p)
          err(4);
        if (this.c > 0) {
          var len = Math.min(this.c, chunk.length);
          var toAdd = chunk.subarray(0, len);
          this.c -= len;
          if (this.d)
            this.d.push(toAdd, !this.c);
          else
            this.k[0].push(toAdd);
          chunk = chunk.subarray(len);
          if (chunk.length)
            return this.push(chunk, final);
        } else {
          var f = 0, i2 = 0, is = void 0, buf = void 0;
          if (!this.p.length)
            buf = chunk;
          else if (!chunk.length)
            buf = this.p;
          else {
            buf = new u8(this.p.length + chunk.length);
            buf.set(this.p), buf.set(chunk, this.p.length);
          }
          var l = buf.length, oc = this.c, add = oc && this.d;
          var _loop_2 = function() {
            var _a2;
            var sig = b4(buf, i2);
            if (sig == 67324752) {
              f = 1, is = i2;
              this_1.d = null;
              this_1.c = 0;
              var bf = b2(buf, i2 + 6), cmp_1 = b2(buf, i2 + 8), u = bf & 2048, dd = bf & 8, fnl = b2(buf, i2 + 26), es = b2(buf, i2 + 28);
              if (l > i2 + 30 + fnl + es) {
                var chks_3 = [];
                this_1.k.unshift(chks_3);
                f = 2;
                var sc_1 = b4(buf, i2 + 18), su_1 = b4(buf, i2 + 22);
                var fn_1 = strFromU8(buf.subarray(i2 + 30, i2 += 30 + fnl), !u);
                if (sc_1 == 4294967295) {
                  _a2 = dd ? [-2] : z64e(buf, i2), sc_1 = _a2[0], su_1 = _a2[1];
                } else if (dd)
                  sc_1 = -1;
                i2 += es;
                this_1.c = sc_1;
                var d_1;
                var file_1 = {
                  name: fn_1,
                  compression: cmp_1,
                  start: function() {
                    if (!file_1.ondata)
                      err(5);
                    if (!sc_1)
                      file_1.ondata(null, et, true);
                    else {
                      var ctr = _this.o[cmp_1];
                      if (!ctr)
                        file_1.ondata(err(14, "unknown compression type " + cmp_1, 1), null, false);
                      d_1 = sc_1 < 0 ? new ctr(fn_1) : new ctr(fn_1, sc_1, su_1);
                      d_1.ondata = function(err2, dat3, final2) {
                        file_1.ondata(err2, dat3, final2);
                      };
                      for (var _i = 0, chks_4 = chks_3; _i < chks_4.length; _i++) {
                        var dat2 = chks_4[_i];
                        d_1.push(dat2, false);
                      }
                      if (_this.k[0] == chks_3 && _this.c)
                        _this.d = d_1;
                      else
                        d_1.push(et, true);
                    }
                  },
                  terminate: function() {
                    if (d_1 && d_1.terminate)
                      d_1.terminate();
                  }
                };
                if (sc_1 >= 0)
                  file_1.size = sc_1, file_1.originalSize = su_1;
                this_1.onfile(file_1);
              }
              return "break";
            } else if (oc) {
              if (sig == 134695760) {
                is = i2 += 12 + (oc == -2 && 8), f = 3, this_1.c = 0;
                return "break";
              } else if (sig == 33639248) {
                is = i2 -= 4, f = 3, this_1.c = 0;
                return "break";
              }
            }
          };
          var this_1 = this;
          for (; i2 < l - 4; ++i2) {
            var state_1 = _loop_2();
            if (state_1 === "break")
              break;
          }
          this.p = et;
          if (oc < 0) {
            var dat = f ? buf.subarray(0, is - 12 - (oc == -2 && 8) - (b4(buf, is - 16) == 134695760 && 4)) : buf.subarray(0, i2);
            if (add)
              add.push(dat, !!f);
            else
              this.k[+(f == 2)].push(dat);
          }
          if (f & 2)
            return this.push(buf.subarray(i2), final);
          this.p = buf.subarray(i2);
        }
        if (final) {
          if (this.c)
            err(13);
          this.p = null;
        }
      };
      Unzip2.prototype.register = function(decoder) {
        this.o[decoder.compression] = decoder;
      };
      return Unzip2;
    })();
    exports2.Unzip = Unzip;
    var mt = typeof queueMicrotask == "function" ? queueMicrotask : typeof setTimeout == "function" ? setTimeout : function(fn) {
      fn();
    };
    function unzip(data, opts, cb) {
      if (!cb)
        cb = opts, opts = {};
      if (typeof cb != "function")
        err(7);
      var term = [];
      var tAll = function() {
        for (var i3 = 0; i3 < term.length; ++i3)
          term[i3]();
      };
      var files = {};
      var cbd = function(a, b) {
        mt(function() {
          cb(a, b);
        });
      };
      mt(function() {
        cbd = cb;
      });
      var e = data.length - 22;
      for (; b4(data, e) != 101010256; --e) {
        if (!e || data.length - e > 65558) {
          cbd(err(13, 0, 1), null);
          return tAll;
        }
      }
      ;
      var lft = b2(data, e + 8);
      if (lft) {
        var c = lft;
        var o = b4(data, e + 16);
        var z = o == 4294967295 || c == 65535;
        if (z) {
          var ze = b4(data, e - 12);
          z = b4(data, ze) == 101075792;
          if (z) {
            c = lft = b4(data, ze + 32);
            o = b4(data, ze + 48);
          }
        }
        var fltr = opts && opts.filter;
        var _loop_3 = function(i3) {
          var _a2 = zh(data, o, z), c_1 = _a2[0], sc = _a2[1], su = _a2[2], fn = _a2[3], no = _a2[4], off = _a2[5], b = slzh(data, off);
          o = no;
          var cbl = function(e2, d) {
            if (e2) {
              tAll();
              cbd(e2, null);
            } else {
              if (d)
                files[fn] = d;
              if (!--lft)
                cbd(null, files);
            }
          };
          if (!fltr || fltr({
            name: fn,
            size: sc,
            originalSize: su,
            compression: c_1
          })) {
            if (!c_1)
              cbl(null, slc(data, b, b + sc));
            else if (c_1 == 8) {
              var infl = data.subarray(b, b + sc);
              if (su < 524288 || sc > 0.8 * su) {
                try {
                  cbl(null, inflateSync(infl, { out: new u8(su) }));
                } catch (e2) {
                  cbl(e2, null);
                }
              } else
                term.push(inflate(infl, { size: su }, cbl));
            } else
              cbl(err(14, "unknown compression type " + c_1, 1), null);
          } else
            cbl(null, null);
        };
        for (var i2 = 0; i2 < c; ++i2) {
          _loop_3(i2);
        }
      } else
        cbd(null, {});
      return tAll;
    }
    exports2.unzip = unzip;
    function unzipSync(data, opts) {
      var files = {};
      var e = data.length - 22;
      for (; b4(data, e) != 101010256; --e) {
        if (!e || data.length - e > 65558)
          err(13);
      }
      ;
      var c = b2(data, e + 8);
      if (!c)
        return {};
      var o = b4(data, e + 16);
      var z = o == 4294967295 || c == 65535;
      if (z) {
        var ze = b4(data, e - 12);
        z = b4(data, ze) == 101075792;
        if (z) {
          c = b4(data, ze + 32);
          o = b4(data, ze + 48);
        }
      }
      var fltr = opts && opts.filter;
      for (var i2 = 0; i2 < c; ++i2) {
        var _a2 = zh(data, o, z), c_2 = _a2[0], sc = _a2[1], su = _a2[2], fn = _a2[3], no = _a2[4], off = _a2[5], b = slzh(data, off);
        o = no;
        if (!fltr || fltr({
          name: fn,
          size: sc,
          originalSize: su,
          compression: c_2
        })) {
          if (!c_2)
            files[fn] = slc(data, b, b + sc);
          else if (c_2 == 8)
            files[fn] = inflateSync(data.subarray(b, b + sc), { out: new u8(su) });
          else
            err(14, "unknown compression type " + c_2);
        }
      }
      return files;
    }
    exports2.unzipSync = unzipSync;
  }
});

// node_modules/jsonata/jsonata.js
var require_jsonata = __commonJS({
  "node_modules/jsonata/jsonata.js"(exports2, module2) {
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    (function(f) {
      if (typeof exports2 === "object" && typeof module2 !== "undefined") {
        module2.exports = f();
      } else if (typeof define === "function" && define.amd) {
        define([], f);
      } else {
        var g;
        if (typeof window !== "undefined") {
          g = window;
        } else if (typeof global !== "undefined") {
          g = global;
        } else if (typeof self !== "undefined") {
          g = self;
        } else {
          g = this;
        }
        g.jsonata = f();
      }
    })(function() {
      var define2, module3, exports3;
      return (/* @__PURE__ */ (function() {
        function r(e, n, t) {
          function o(i2, f) {
            if (!n[i2]) {
              if (!e[i2]) {
                var c = "function" == typeof __require && __require;
                if (!f && c) return c(i2, true);
                if (u) return u(i2, true);
                var a = new Error("Cannot find module '" + i2 + "'");
                throw a.code = "MODULE_NOT_FOUND", a;
              }
              var p = n[i2] = { exports: {} };
              e[i2][0].call(p.exports, function(r2) {
                var n2 = e[i2][1][r2];
                return o(n2 || r2);
              }, p, p.exports, r, e, n, t);
            }
            return n[i2].exports;
          }
          for (var u = "function" == typeof __require && __require, i = 0; i < t.length; i++) o(t[i]);
          return o;
        }
        return r;
      })())({ 1: [function(require2, module4, exports4) {
        const utils = require2("./utils");
        const dateTime = (function() {
          "use strict";
          const stringToArray = utils.stringToArray;
          const few = [
            "Zero",
            "One",
            "Two",
            "Three",
            "Four",
            "Five",
            "Six",
            "Seven",
            "Eight",
            "Nine",
            "Ten",
            "Eleven",
            "Twelve",
            "Thirteen",
            "Fourteen",
            "Fifteen",
            "Sixteen",
            "Seventeen",
            "Eighteen",
            "Nineteen"
          ];
          const ordinals = [
            "Zeroth",
            "First",
            "Second",
            "Third",
            "Fourth",
            "Fifth",
            "Sixth",
            "Seventh",
            "Eighth",
            "Ninth",
            "Tenth",
            "Eleventh",
            "Twelfth",
            "Thirteenth",
            "Fourteenth",
            "Fifteenth",
            "Sixteenth",
            "Seventeenth",
            "Eighteenth",
            "Nineteenth"
          ];
          const decades = ["Twenty", "Thirty", "Forty", "Fifty", "Sixty", "Seventy", "Eighty", "Ninety", "Hundred"];
          const magnitudes = ["Thousand", "Million", "Billion", "Trillion"];
          function numberToWords(value, ordinal) {
            var lookup = function(num, prev, ord) {
              var words2 = "";
              if (num <= 19) {
                words2 = (prev ? " and " : "") + (ord ? ordinals[num] : few[num]);
              } else if (num < 100) {
                const tens = Math.floor(num / 10);
                const remainder = num % 10;
                words2 = (prev ? " and " : "") + decades[tens - 2];
                if (remainder > 0) {
                  words2 += "-" + lookup(remainder, false, ord);
                } else if (ord) {
                  words2 = words2.substring(0, words2.length - 1) + "ieth";
                }
              } else if (num < 1e3) {
                const hundreds = Math.floor(num / 100);
                const remainder = num % 100;
                words2 = (prev ? ", " : "") + few[hundreds] + " Hundred";
                if (remainder > 0) {
                  words2 += lookup(remainder, true, ord);
                } else if (ord) {
                  words2 += "th";
                }
              } else {
                var mag = Math.floor(Math.log10(num) / 3);
                if (mag > magnitudes.length) {
                  mag = magnitudes.length;
                }
                const factor = Math.pow(10, mag * 3);
                const mant = Math.floor(num / factor);
                const remainder = num - mant * factor;
                words2 = (prev ? ", " : "") + lookup(mant, false, false) + " " + magnitudes[mag - 1];
                if (remainder > 0) {
                  words2 += lookup(remainder, true, ord);
                } else if (ord) {
                  words2 += "th";
                }
              }
              return words2;
            };
            var words = lookup(value, false, ordinal);
            return words;
          }
          const wordValues = {};
          few.forEach(function(word, index) {
            wordValues[word.toLowerCase()] = index;
          });
          ordinals.forEach(function(word, index) {
            wordValues[word.toLowerCase()] = index;
          });
          decades.forEach(function(word, index) {
            const lword = word.toLowerCase();
            wordValues[lword] = (index + 2) * 10;
            wordValues[lword.substring(0, word.length - 1) + "ieth"] = wordValues[lword];
          });
          wordValues.hundredth = 100;
          magnitudes.forEach(function(word, index) {
            const lword = word.toLowerCase();
            const val = Math.pow(10, (index + 1) * 3);
            wordValues[lword] = val;
            wordValues[lword + "th"] = val;
          });
          function wordsToNumber(text) {
            const parts = text.split(/,\s|\sand\s|[\s\\-]/);
            const values = parts.map((part) => wordValues[part]);
            let segs = [0];
            values.forEach((value) => {
              if (value < 100) {
                let top = segs.pop();
                if (top >= 1e3) {
                  segs.push(top);
                  top = 0;
                }
                segs.push(top + value);
              } else {
                segs.push(segs.pop() * value);
              }
            });
            const result = segs.reduce((a, b) => a + b, 0);
            return result;
          }
          const romanNumerals = [
            [1e3, "m"],
            [900, "cm"],
            [500, "d"],
            [400, "cd"],
            [100, "c"],
            [90, "xc"],
            [50, "l"],
            [40, "xl"],
            [10, "x"],
            [9, "ix"],
            [5, "v"],
            [4, "iv"],
            [1, "i"]
          ];
          const romanValues = { "M": 1e3, "D": 500, "C": 100, "L": 50, "X": 10, "V": 5, "I": 1 };
          function decimalToRoman(value) {
            for (var index = 0; index < romanNumerals.length; index++) {
              const numeral = romanNumerals[index];
              if (value >= numeral[0]) {
                return numeral[1] + decimalToRoman(value - numeral[0]);
              }
            }
            return "";
          }
          function romanToDecimal(roman) {
            var decimal = 0;
            var max = 1;
            for (var i = roman.length - 1; i >= 0; i--) {
              const digit = roman[i];
              const value = romanValues[digit];
              if (value < max) {
                decimal -= value;
              } else {
                max = value;
                decimal += value;
              }
            }
            return decimal;
          }
          function decimalToLetters(value, aChar) {
            var letters = [];
            var aCode = aChar.charCodeAt(0);
            while (value > 0) {
              letters.unshift(String.fromCharCode((value - 1) % 26 + aCode));
              value = Math.floor((value - 1) / 26);
            }
            return letters.join("");
          }
          function lettersToDecimal(letters, aChar) {
            var aCode = aChar.charCodeAt(0);
            var decimal = 0;
            for (var i = 0; i < letters.length; i++) {
              decimal += (letters.charCodeAt(letters.length - i - 1) - aCode + 1) * Math.pow(26, i);
            }
            return decimal;
          }
          function formatInteger(value, picture) {
            if (typeof value === "undefined") {
              return void 0;
            }
            value = Math.floor(value);
            const format = analyseIntegerPicture(picture);
            return _formatInteger(value, format);
          }
          const formats = {
            DECIMAL: "decimal",
            LETTERS: "letters",
            ROMAN: "roman",
            WORDS: "words",
            SEQUENCE: "sequence"
          };
          const tcase = {
            UPPER: "upper",
            LOWER: "lower",
            TITLE: "title"
          };
          function _formatInteger(value, format) {
            let formattedInteger;
            const negative = value < 0;
            value = Math.abs(value);
            switch (format.primary) {
              case formats.LETTERS:
                formattedInteger = decimalToLetters(value, format.case === tcase.UPPER ? "A" : "a");
                break;
              case formats.ROMAN:
                formattedInteger = decimalToRoman(value);
                if (format.case === tcase.UPPER) {
                  formattedInteger = formattedInteger.toUpperCase();
                }
                break;
              case formats.WORDS:
                formattedInteger = numberToWords(value, format.ordinal);
                if (format.case === tcase.UPPER) {
                  formattedInteger = formattedInteger.toUpperCase();
                } else if (format.case === tcase.LOWER) {
                  formattedInteger = formattedInteger.toLowerCase();
                }
                break;
              case formats.DECIMAL:
                formattedInteger = "" + value;
                var padLength = format.mandatoryDigits - formattedInteger.length;
                if (padLength > 0) {
                  var padding = new Array(padLength + 1).join("0");
                  formattedInteger = padding + formattedInteger;
                }
                if (format.zeroCode !== 48) {
                  formattedInteger = stringToArray(formattedInteger).map((code) => {
                    return String.fromCodePoint(code.codePointAt(0) + format.zeroCode - 48);
                  }).join("");
                }
                if (format.regular) {
                  const n = Math.floor((formattedInteger.length - 1) / format.groupingSeparators.position);
                  for (let ii = n; ii > 0; ii--) {
                    const pos = formattedInteger.length - ii * format.groupingSeparators.position;
                    formattedInteger = formattedInteger.substr(0, pos) + format.groupingSeparators.character + formattedInteger.substr(pos);
                  }
                } else {
                  format.groupingSeparators.reverse().forEach((separator) => {
                    const pos = formattedInteger.length - separator.position;
                    formattedInteger = formattedInteger.substr(0, pos) + separator.character + formattedInteger.substr(pos);
                  });
                }
                if (format.ordinal) {
                  var suffix123 = { "1": "st", "2": "nd", "3": "rd" };
                  var lastDigit = formattedInteger[formattedInteger.length - 1];
                  var suffix = suffix123[lastDigit];
                  if (!suffix || formattedInteger.length > 1 && formattedInteger[formattedInteger.length - 2] === "1") {
                    suffix = "th";
                  }
                  formattedInteger = formattedInteger + suffix;
                }
                break;
              case formats.SEQUENCE:
                throw {
                  code: "D3130",
                  value: format.token
                };
            }
            if (negative) {
              formattedInteger = "-" + formattedInteger;
            }
            return formattedInteger;
          }
          const decimalGroups = [48, 1632, 1776, 1984, 2406, 2534, 2662, 2790, 2918, 3046, 3174, 3302, 3430, 3558, 3664, 3792, 3872, 4160, 4240, 6112, 6160, 6470, 6608, 6784, 6800, 6992, 7088, 7232, 7248, 42528, 43216, 43264, 43472, 43504, 43600, 44016, 65296];
          function analyseIntegerPicture(picture) {
            const format = {
              type: "integer",
              primary: formats.DECIMAL,
              case: tcase.LOWER,
              ordinal: false
            };
            let primaryFormat, formatModifier;
            const semicolon = picture.lastIndexOf(";");
            if (semicolon === -1) {
              primaryFormat = picture;
            } else {
              primaryFormat = picture.substring(0, semicolon);
              formatModifier = picture.substring(semicolon + 1);
              if (formatModifier[0] === "o") {
                format.ordinal = true;
              }
            }
            switch (primaryFormat) {
              case "A":
                format.case = tcase.UPPER;
              /* eslnt-disable-next-line no-fallthrough */
              case "a":
                format.primary = formats.LETTERS;
                break;
              case "I":
                format.case = tcase.UPPER;
              /* eslnt-disable-next-line no-fallthrough */
              case "i":
                format.primary = formats.ROMAN;
                break;
              case "W":
                format.case = tcase.UPPER;
                format.primary = formats.WORDS;
                break;
              case "Ww":
                format.case = tcase.TITLE;
                format.primary = formats.WORDS;
                break;
              case "w":
                format.primary = formats.WORDS;
                break;
              default: {
                let zeroCode = null;
                let mandatoryDigits = 0;
                let optionalDigits = 0;
                let groupingSeparators = [];
                let separatorPosition = 0;
                const formatCodepoints = stringToArray(primaryFormat).map((c) => c.codePointAt(0)).reverse();
                formatCodepoints.forEach((codePoint) => {
                  let digit = false;
                  for (let ii = 0; ii < decimalGroups.length; ii++) {
                    const group = decimalGroups[ii];
                    if (codePoint >= group && codePoint <= group + 9) {
                      digit = true;
                      mandatoryDigits++;
                      separatorPosition++;
                      if (zeroCode === null) {
                        zeroCode = group;
                      } else if (group !== zeroCode) {
                        throw {
                          code: "D3131"
                        };
                      }
                      break;
                    }
                  }
                  if (!digit) {
                    if (codePoint === 35) {
                      separatorPosition++;
                      optionalDigits++;
                    } else {
                      groupingSeparators.push({
                        position: separatorPosition,
                        character: String.fromCodePoint(codePoint)
                      });
                    }
                  }
                });
                if (mandatoryDigits > 0) {
                  format.primary = formats.DECIMAL;
                  format.zeroCode = zeroCode;
                  format.mandatoryDigits = mandatoryDigits;
                  format.optionalDigits = optionalDigits;
                  const regularRepeat = function(separators) {
                    if (separators.length === 0) {
                      return 0;
                    }
                    const sepChar = separators[0].character;
                    for (let ii = 1; ii < separators.length; ii++) {
                      if (separators[ii].character !== sepChar) {
                        return 0;
                      }
                    }
                    const indexes = separators.map((separator) => separator.position);
                    const gcd = function(a, b) {
                      return b === 0 ? a : gcd(b, a % b);
                    };
                    const factor = indexes.reduce(gcd);
                    for (let index = 1; index <= indexes.length; index++) {
                      if (indexes.indexOf(index * factor) === -1) {
                        return 0;
                      }
                    }
                    return factor;
                  };
                  const regular = regularRepeat(groupingSeparators);
                  if (regular > 0) {
                    format.regular = true;
                    format.groupingSeparators = {
                      position: regular,
                      character: groupingSeparators[0].character
                    };
                  } else {
                    format.regular = false;
                    format.groupingSeparators = groupingSeparators;
                  }
                } else {
                  format.primary = formats.SEQUENCE;
                  format.token = primaryFormat;
                }
              }
            }
            return format;
          }
          const defaultPresentationModifiers = {
            Y: "1",
            M: "1",
            D: "1",
            d: "1",
            F: "n",
            W: "1",
            w: "1",
            X: "1",
            x: "1",
            H: "1",
            h: "1",
            P: "n",
            m: "01",
            s: "01",
            f: "1",
            Z: "01:01",
            z: "01:01",
            C: "n",
            E: "n"
          };
          function analyseDateTimePicture(picture) {
            var spec = [];
            const format = {
              type: "datetime",
              parts: spec
            };
            const addLiteral = function(start2, end) {
              if (end > start2) {
                let literal = picture.substring(start2, end);
                literal = literal.split("]]").join("]");
                spec.push({ type: "literal", value: literal });
              }
            };
            var start = 0, pos = 0;
            while (pos < picture.length) {
              if (picture.charAt(pos) === "[") {
                if (picture.charAt(pos + 1) === "[") {
                  addLiteral(start, pos);
                  spec.push({ type: "literal", value: "[" });
                  pos += 2;
                  start = pos;
                  continue;
                }
                addLiteral(start, pos);
                start = pos;
                pos = picture.indexOf("]", start);
                if (pos === -1) {
                  throw {
                    code: "D3135"
                  };
                }
                let marker = picture.substring(start + 1, pos);
                marker = marker.split(/\s+/).join("");
                var def = {
                  type: "marker",
                  component: marker.charAt(0)
                  // 1. The component specifier is always present and is always a single letter.
                };
                var comma = marker.lastIndexOf(",");
                var presMod;
                if (comma !== -1) {
                  const widthMod = marker.substring(comma + 1);
                  const dash = widthMod.indexOf("-");
                  let min, max;
                  const parseWidth = function(wm) {
                    if (typeof wm === "undefined" || wm === "*") {
                      return void 0;
                    } else {
                      return parseInt(wm);
                    }
                  };
                  if (dash === -1) {
                    min = widthMod;
                  } else {
                    min = widthMod.substring(0, dash);
                    max = widthMod.substring(dash + 1);
                  }
                  const widthDef = {
                    min: parseWidth(min),
                    max: parseWidth(max)
                  };
                  def.width = widthDef;
                  presMod = marker.substring(1, comma);
                } else {
                  presMod = marker.substring(1);
                }
                if (presMod.length === 1) {
                  def.presentation1 = presMod;
                } else if (presMod.length > 1) {
                  var lastChar = presMod.charAt(presMod.length - 1);
                  if ("atco".indexOf(lastChar) !== -1) {
                    def.presentation2 = lastChar;
                    if (lastChar === "o") {
                      def.ordinal = true;
                    }
                    def.presentation1 = presMod.substring(0, presMod.length - 1);
                  } else {
                    def.presentation1 = presMod;
                  }
                } else {
                  def.presentation1 = defaultPresentationModifiers[def.component];
                }
                if (typeof def.presentation1 === "undefined") {
                  throw {
                    code: "D3132",
                    value: def.component
                  };
                }
                if (def.presentation1[0] === "n") {
                  def.names = tcase.LOWER;
                } else if (def.presentation1[0] === "N") {
                  if (def.presentation1[1] === "n") {
                    def.names = tcase.TITLE;
                  } else {
                    def.names = tcase.UPPER;
                  }
                } else if ("YMDdFWwXxHhmsf".indexOf(def.component) !== -1) {
                  var integerPattern = def.presentation1;
                  if (def.presentation2) {
                    integerPattern += ";" + def.presentation2;
                  }
                  def.integerFormat = analyseIntegerPicture(integerPattern);
                  if (def.width && def.width.min !== void 0) {
                    if (def.integerFormat.mandatoryDigits < def.width.min) {
                      def.integerFormat.mandatoryDigits = def.width.min;
                    }
                  }
                  if (def.component === "Y") {
                    def.n = -1;
                    if (def.width && def.width.max !== void 0) {
                      def.n = def.width.max;
                      def.integerFormat.mandatoryDigits = def.n;
                    } else {
                      var w = def.integerFormat.mandatoryDigits + def.integerFormat.optionalDigits;
                      if (w >= 2) {
                        def.n = w;
                      }
                    }
                  }
                  const previousPart = spec[spec.length - 1];
                  if (previousPart && previousPart.integerFormat) {
                    previousPart.integerFormat.parseWidth = previousPart.integerFormat.mandatoryDigits;
                  }
                }
                if (def.component === "Z" || def.component === "z") {
                  def.integerFormat = analyseIntegerPicture(def.presentation1);
                }
                spec.push(def);
                start = pos + 1;
              }
              pos++;
            }
            addLiteral(start, pos);
            return format;
          }
          const days = ["", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"];
          const months = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
          const millisInADay = 1e3 * 60 * 60 * 24;
          const startOfFirstWeek = function(ym) {
            const jan1 = Date.UTC(ym.year, ym.month);
            var dayOfJan1 = new Date(jan1).getUTCDay();
            if (dayOfJan1 === 0) {
              dayOfJan1 = 7;
            }
            return dayOfJan1 > 4 ? jan1 + (8 - dayOfJan1) * millisInADay : jan1 - (dayOfJan1 - 1) * millisInADay;
          };
          const yearMonth = function(year, month) {
            return {
              year,
              month,
              nextMonth: function() {
                return month === 11 ? yearMonth(year + 1, 0) : yearMonth(year, month + 1);
              },
              previousMonth: function() {
                return month === 0 ? yearMonth(year - 1, 11) : yearMonth(year, month - 1);
              },
              nextYear: function() {
                return yearMonth(year + 1, month);
              },
              previousYear: function() {
                return yearMonth(year - 1, month);
              }
            };
          };
          const deltaWeeks = function(start, end) {
            return (end - start) / (millisInADay * 7) + 1;
          };
          const getDateTimeFragment = (date, component) => {
            let componentValue;
            switch (component) {
              case "Y":
                componentValue = date.getUTCFullYear();
                break;
              case "M":
                componentValue = date.getUTCMonth() + 1;
                break;
              case "D":
                componentValue = date.getUTCDate();
                break;
              case "d": {
                const today = Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate());
                const firstJan = Date.UTC(date.getUTCFullYear(), 0);
                componentValue = (today - firstJan) / millisInADay + 1;
                break;
              }
              case "F":
                componentValue = date.getUTCDay();
                if (componentValue === 0) {
                  componentValue = 7;
                }
                break;
              case "W": {
                const thisYear = yearMonth(date.getUTCFullYear(), 0);
                const startOfWeek1 = startOfFirstWeek(thisYear);
                const today = Date.UTC(thisYear.year, date.getUTCMonth(), date.getUTCDate());
                let week = deltaWeeks(startOfWeek1, today);
                if (week > 52) {
                  const startOfFollowingYear = startOfFirstWeek(thisYear.nextYear());
                  if (today >= startOfFollowingYear) {
                    week = 1;
                  }
                } else if (week < 1) {
                  const startOfPreviousYear = startOfFirstWeek(thisYear.previousYear());
                  week = deltaWeeks(startOfPreviousYear, today);
                }
                componentValue = Math.floor(week);
                break;
              }
              case "w": {
                const thisMonth = yearMonth(date.getUTCFullYear(), date.getUTCMonth());
                const startOfWeek1 = startOfFirstWeek(thisMonth);
                const today = Date.UTC(thisMonth.year, thisMonth.month, date.getUTCDate());
                let week = deltaWeeks(startOfWeek1, today);
                if (week > 4) {
                  const startOfFollowingMonth = startOfFirstWeek(thisMonth.nextMonth());
                  if (today >= startOfFollowingMonth) {
                    week = 1;
                  }
                } else if (week < 1) {
                  const startOfPreviousMonth = startOfFirstWeek(thisMonth.previousMonth());
                  week = deltaWeeks(startOfPreviousMonth, today);
                }
                componentValue = Math.floor(week);
                break;
              }
              case "X": {
                const thisYear = yearMonth(date.getUTCFullYear(), 0);
                const startOfISOYear = startOfFirstWeek(thisYear);
                const endOfISOYear = startOfFirstWeek(thisYear.nextYear());
                const now = date.getTime();
                if (now < startOfISOYear) {
                  componentValue = thisYear.year - 1;
                } else if (now >= endOfISOYear) {
                  componentValue = thisYear.year + 1;
                } else {
                  componentValue = thisYear.year;
                }
                break;
              }
              case "x": {
                const thisMonth = yearMonth(date.getUTCFullYear(), date.getUTCMonth());
                const startOfISOMonth = startOfFirstWeek(thisMonth);
                const nextMonth = thisMonth.nextMonth();
                const endOfISOMonth = startOfFirstWeek(nextMonth);
                const now = date.getTime();
                if (now < startOfISOMonth) {
                  componentValue = thisMonth.previousMonth().month + 1;
                } else if (now >= endOfISOMonth) {
                  componentValue = nextMonth.month + 1;
                } else {
                  componentValue = thisMonth.month + 1;
                }
                break;
              }
              case "H":
                componentValue = date.getUTCHours();
                break;
              case "h":
                componentValue = date.getUTCHours();
                componentValue = componentValue % 12;
                if (componentValue === 0) {
                  componentValue = 12;
                }
                break;
              case "P":
                componentValue = date.getUTCHours() >= 12 ? "pm" : "am";
                break;
              case "m":
                componentValue = date.getUTCMinutes();
                break;
              case "s":
                componentValue = date.getUTCSeconds();
                break;
              case "f":
                componentValue = date.getUTCMilliseconds();
                break;
              case "Z":
              // timezone
              case "z":
                break;
              case "C":
                componentValue = "ISO";
                break;
              case "E":
                componentValue = "ISO";
                break;
            }
            return componentValue;
          };
          let iso8601Spec = null;
          function formatDateTime(millis, picture, timezone) {
            var offsetHours = 0;
            var offsetMinutes = 0;
            if (typeof timezone !== "undefined") {
              const offset = parseInt(timezone);
              offsetHours = Math.floor(offset / 100);
              offsetMinutes = offset % 100;
            }
            var formatComponent = function(date, markerSpec) {
              var componentValue = getDateTimeFragment(date, markerSpec.component);
              if ("YMDdFWwXxHhms".indexOf(markerSpec.component) !== -1) {
                if (markerSpec.component === "Y") {
                  if (markerSpec.n !== -1) {
                    componentValue = componentValue % Math.pow(10, markerSpec.n);
                  }
                }
                if (markerSpec.names) {
                  if (markerSpec.component === "M" || markerSpec.component === "x") {
                    componentValue = months[componentValue - 1];
                  } else if (markerSpec.component === "F") {
                    componentValue = days[componentValue];
                  } else {
                    throw {
                      code: "D3133",
                      value: markerSpec.component
                    };
                  }
                  if (markerSpec.names === tcase.UPPER) {
                    componentValue = componentValue.toUpperCase();
                  } else if (markerSpec.names === tcase.LOWER) {
                    componentValue = componentValue.toLowerCase();
                  }
                  if (markerSpec.width && componentValue.length > markerSpec.width.max) {
                    componentValue = componentValue.substring(0, markerSpec.width.max);
                  }
                } else {
                  componentValue = _formatInteger(componentValue, markerSpec.integerFormat);
                }
              } else if (markerSpec.component === "f") {
                componentValue = _formatInteger(componentValue, markerSpec.integerFormat);
              } else if (markerSpec.component === "Z" || markerSpec.component === "z") {
                const offset = offsetHours * 100 + offsetMinutes;
                if (markerSpec.integerFormat.regular) {
                  componentValue = _formatInteger(offset, markerSpec.integerFormat);
                } else {
                  const numDigits = markerSpec.integerFormat.mandatoryDigits;
                  if (numDigits === 1 || numDigits === 2) {
                    componentValue = _formatInteger(offsetHours, markerSpec.integerFormat);
                    if (offsetMinutes !== 0) {
                      componentValue += ":" + formatInteger(offsetMinutes, "00");
                    }
                  } else if (numDigits === 3 || numDigits === 4) {
                    componentValue = _formatInteger(offset, markerSpec.integerFormat);
                  } else {
                    throw {
                      code: "D3134",
                      value: numDigits
                    };
                  }
                }
                if (offset >= 0) {
                  componentValue = "+" + componentValue;
                }
                if (markerSpec.component === "z") {
                  componentValue = "GMT" + componentValue;
                }
                if (offset === 0 && markerSpec.presentation2 === "t") {
                  componentValue = "Z";
                }
              } else if (markerSpec.component === "P") {
                if (markerSpec.names === tcase.UPPER) {
                  componentValue = componentValue.toUpperCase();
                }
              }
              return componentValue;
            };
            let formatSpec;
            if (typeof picture === "undefined") {
              if (iso8601Spec === null) {
                iso8601Spec = analyseDateTimePicture("[Y0001]-[M01]-[D01]T[H01]:[m01]:[s01].[f001][Z01:01t]");
              }
              formatSpec = iso8601Spec;
            } else {
              formatSpec = analyseDateTimePicture(picture);
            }
            const offsetMillis = (60 * offsetHours + offsetMinutes) * 60 * 1e3;
            const dateTime2 = new Date(millis + offsetMillis);
            let result = "";
            formatSpec.parts.forEach(function(part) {
              if (part.type === "literal") {
                result += part.value;
              } else {
                result += formatComponent(dateTime2, part);
              }
            });
            return result;
          }
          function generateRegex(formatSpec) {
            var matcher = {};
            if (formatSpec.type === "datetime") {
              matcher.type = "datetime";
              matcher.parts = formatSpec.parts.map(function(part) {
                var res = {};
                if (part.type === "literal") {
                  res.regex = part.value.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
                } else if (part.component === "Z" || part.component === "z") {
                  let separator;
                  if (!Array.isArray(part.integerFormat.groupingSeparators)) {
                    separator = part.integerFormat.groupingSeparators;
                  }
                  res.regex = "";
                  if (part.component === "z") {
                    res.regex = "GMT";
                  }
                  res.regex += "[-+][0-9]+";
                  if (separator) {
                    res.regex += separator.character + "[0-9]+";
                  }
                  res.parse = function(value) {
                    if (part.component === "z") {
                      value = value.substring(3);
                    }
                    let offsetHours = 0, offsetMinutes = 0;
                    if (separator) {
                      offsetHours = Number.parseInt(value.substring(0, value.indexOf(separator.character)));
                      offsetMinutes = Number.parseInt(value.substring(value.indexOf(separator.character) + 1));
                    } else {
                      const numdigits = value.length - 1;
                      if (numdigits <= 2) {
                        offsetHours = Number.parseInt(value);
                      } else {
                        offsetHours = Number.parseInt(value.substring(0, 3));
                        offsetMinutes = Number.parseInt(value.substring(3));
                      }
                    }
                    return offsetHours * 60 + offsetMinutes;
                  };
                } else if (part.integerFormat) {
                  res = generateRegex(part.integerFormat);
                } else {
                  res.regex = "[a-zA-Z]+";
                  var lookup = {};
                  if (part.component === "M" || part.component === "x") {
                    months.forEach(function(name, index) {
                      if (part.width && part.width.max) {
                        lookup[name.substring(0, part.width.max)] = index + 1;
                      } else {
                        lookup[name] = index + 1;
                      }
                    });
                  } else if (part.component === "F") {
                    days.forEach(function(name, index) {
                      if (index > 0) {
                        if (part.width && part.width.max) {
                          lookup[name.substring(0, part.width.max)] = index;
                        } else {
                          lookup[name] = index;
                        }
                      }
                    });
                  } else if (part.component === "P") {
                    lookup = { "am": 0, "AM": 0, "pm": 1, "PM": 1 };
                  } else {
                    throw {
                      code: "D3133",
                      value: part.component
                    };
                  }
                  res.parse = function(value) {
                    return lookup[value];
                  };
                }
                res.component = part.component;
                return res;
              });
            } else {
              matcher.type = "integer";
              const isUpper = formatSpec.case === tcase.UPPER;
              switch (formatSpec.primary) {
                case formats.LETTERS:
                  matcher.regex = isUpper ? "[A-Z]+" : "[a-z]+";
                  matcher.parse = function(value) {
                    return lettersToDecimal(value, isUpper ? "A" : "a");
                  };
                  break;
                case formats.ROMAN:
                  matcher.regex = isUpper ? "[MDCLXVI]+" : "[mdclxvi]+";
                  matcher.parse = function(value) {
                    return romanToDecimal(isUpper ? value : value.toUpperCase());
                  };
                  break;
                case formats.WORDS:
                  matcher.regex = "(?:" + Object.keys(wordValues).concat("and", "[\\-, ]").join("|") + ")+";
                  matcher.parse = function(value) {
                    return wordsToNumber(value.toLowerCase());
                  };
                  break;
                case formats.DECIMAL:
                  matcher.regex = "[0-9]";
                  if (formatSpec.parseWidth) {
                    matcher.regex += `{${formatSpec.parseWidth}}`;
                  } else {
                    matcher.regex += "+";
                  }
                  if (formatSpec.ordinal) {
                    matcher.regex += "(?:th|st|nd|rd)";
                  }
                  matcher.parse = function(value) {
                    let digits = value;
                    if (formatSpec.ordinal) {
                      digits = value.substring(0, value.length - 2);
                    }
                    if (formatSpec.regular) {
                      digits = digits.split(",").join("");
                    } else {
                      formatSpec.groupingSeparators.forEach((sep) => {
                        digits = digits.split(sep.character).join("");
                      });
                    }
                    if (formatSpec.zeroCode !== 48) {
                      digits = digits.split("").map((char) => String.fromCodePoint(char.codePointAt(0) - formatSpec.zeroCode + 48)).join("");
                    }
                    return parseInt(digits);
                  };
                  break;
                case formats.SEQUENCE:
                  throw {
                    code: "D3130",
                    value: formatSpec.token
                  };
              }
            }
            return matcher;
          }
          function parseInteger(value, picture) {
            if (typeof value === "undefined") {
              return void 0;
            }
            const formatSpec = analyseIntegerPicture(picture);
            const matchSpec = generateRegex(formatSpec);
            const result = matchSpec.parse(value);
            return result;
          }
          function parseDateTime(timestamp, picture) {
            const formatSpec = analyseDateTimePicture(picture);
            const matchSpec = generateRegex(formatSpec);
            const fullRegex = "^" + matchSpec.parts.map((part) => "(" + part.regex + ")").join("") + "$";
            const matcher = new RegExp(fullRegex, "i");
            var info = matcher.exec(timestamp);
            if (info !== null) {
              const dmA = 161;
              const dmB = 130;
              const dmC = 84;
              const dmD = 72;
              const tmA = 23;
              const tmB = 47;
              const components = {};
              for (let i = 1; i < info.length; i++) {
                const mpart = matchSpec.parts[i - 1];
                if (mpart.parse) {
                  components[mpart.component] = mpart.parse(info[i]);
                }
              }
              if (Object.getOwnPropertyNames(components).length === 0) {
                return void 0;
              }
              let mask = 0;
              const shift = (bit) => {
                mask <<= 1;
                mask += bit ? 1 : 0;
              };
              const isType = (type) => {
                return !(~type & mask) && !!(type & mask);
              };
              "YXMxWwdD".split("").forEach((part) => shift(components[part]));
              const dateA = isType(dmA);
              const dateB = !dateA && isType(dmB);
              const dateC = isType(dmC);
              const dateD = !dateC && isType(dmD);
              mask = 0;
              "PHhmsf".split("").forEach((part) => shift(components[part]));
              const timeA = isType(tmA);
              const timeB = !timeA && isType(tmB);
              const dateComps = dateB ? "YD" : dateC ? "XxwF" : dateD ? "XWF" : "YMD";
              const timeComps = timeB ? "Phmsf" : "Hmsf";
              const comps = dateComps + timeComps;
              const now = this.environment.timestamp;
              let startSpecified = false;
              let endSpecified = false;
              comps.split("").forEach((part) => {
                if (typeof components[part] === "undefined") {
                  if (startSpecified) {
                    components[part] = "MDd".indexOf(part) !== -1 ? 1 : 0;
                    endSpecified = true;
                  } else {
                    components[part] = getDateTimeFragment(now, part);
                  }
                } else {
                  startSpecified = true;
                  if (endSpecified) {
                    throw {
                      code: "D3136"
                    };
                  }
                }
              });
              if (components.M > 0) {
                components.M -= 1;
              } else {
                components.M = 0;
              }
              if (dateB) {
                const firstJan = Date.UTC(components.Y, 0);
                const offsetMillis = (components.d - 1) * 1e3 * 60 * 60 * 24;
                const derivedDate = new Date(firstJan + offsetMillis);
                components.M = derivedDate.getUTCMonth();
                components.D = derivedDate.getUTCDate();
              }
              if (dateC) {
                throw {
                  code: "D3136"
                };
              }
              if (dateD) {
                throw {
                  code: "D3136"
                };
              }
              if (timeB) {
                components.H = components.h === 12 ? 0 : components.h;
                if (components.P === 1) {
                  components.H += 12;
                }
              }
              var millis = Date.UTC(components.Y, components.M, components.D, components.H, components.m, components.s, components.f);
              if (components.Z || components.z) {
                millis -= (components.Z || components.z) * 60 * 1e3;
              }
              return millis;
            }
          }
          var iso8601regex = new RegExp("^\\d{4}(-[01]\\d)*(-[0-3]\\d)*(T[0-2]\\d:[0-5]\\d:[0-5]\\d)*(\\.\\d+)?([+-][0-2]\\d:?[0-5]\\d|Z)?$");
          function toMillis(timestamp, picture) {
            if (typeof timestamp === "undefined") {
              return void 0;
            }
            if (typeof picture === "undefined") {
              if (!iso8601regex.test(timestamp)) {
                throw {
                  stack: new Error().stack,
                  code: "D3110",
                  value: timestamp
                };
              }
              return Date.parse(timestamp);
            } else {
              return parseDateTime.call(this, timestamp, picture);
            }
          }
          function fromMillis(millis, picture, timezone) {
            if (typeof millis === "undefined") {
              return void 0;
            }
            return formatDateTime.call(this, millis, picture, timezone);
          }
          return {
            formatInteger,
            parseInteger,
            fromMillis,
            toMillis
          };
        })();
        module4.exports = dateTime;
      }, { "./utils": 6 }], 2: [function(require2, module4, exports4) {
        (function(global2) {
          (function() {
            var utils = require2("./utils");
            const functions = (() => {
              "use strict";
              var isNumeric = utils.isNumeric;
              var isArrayOfStrings = utils.isArrayOfStrings;
              var isArrayOfNumbers = utils.isArrayOfNumbers;
              var createSequence = utils.createSequence;
              var isSequence = utils.isSequence;
              var isFunction = utils.isFunction;
              var isLambda = utils.isLambda;
              var isPromise = utils.isPromise;
              var getFunctionArity = utils.getFunctionArity;
              var deepEquals = utils.isDeepEqual;
              var stringToArray = utils.stringToArray;
              function sum(args) {
                if (typeof args === "undefined") {
                  return void 0;
                }
                var total = 0;
                args.forEach(function(num) {
                  total += num;
                });
                return total;
              }
              function count(args) {
                if (typeof args === "undefined") {
                  return 0;
                }
                return args.length;
              }
              function max(args) {
                if (typeof args === "undefined" || args.length === 0) {
                  return void 0;
                }
                return Math.max.apply(Math, args);
              }
              function min(args) {
                if (typeof args === "undefined" || args.length === 0) {
                  return void 0;
                }
                return Math.min.apply(Math, args);
              }
              function average(args) {
                if (typeof args === "undefined" || args.length === 0) {
                  return void 0;
                }
                var total = 0;
                args.forEach(function(num) {
                  total += num;
                });
                return total / args.length;
              }
              function string(arg, prettify = false) {
                if (typeof arg === "undefined") {
                  return void 0;
                }
                var str;
                if (typeof arg === "string") {
                  str = arg;
                } else if (isFunction(arg)) {
                  str = "";
                } else if (typeof arg === "number" && !isFinite(arg)) {
                  throw {
                    code: "D3001",
                    value: arg,
                    stack: new Error().stack
                  };
                } else {
                  var space = prettify ? 2 : 0;
                  if (Array.isArray(arg) && arg.outerWrapper) {
                    arg = arg[0];
                  }
                  str = JSON.stringify(arg, function(key, val) {
                    return typeof val !== "undefined" && val !== null && val.toPrecision && isNumeric(val) ? Number(val.toPrecision(15)) : val && isFunction(val) ? "" : val;
                  }, space);
                }
                return str;
              }
              function substring(str, start, length2) {
                if (typeof str === "undefined") {
                  return void 0;
                }
                var strArray = stringToArray(str);
                var strLength = strArray.length;
                if (strLength + start < 0) {
                  start = 0;
                }
                if (typeof length2 !== "undefined") {
                  if (length2 <= 0) {
                    return "";
                  }
                  var end = start >= 0 ? start + length2 : strLength + start + length2;
                  return strArray.slice(start, end).join("");
                }
                return strArray.slice(start).join("");
              }
              function substringBefore(str, chars) {
                if (typeof str === "undefined") {
                  return void 0;
                }
                var pos = str.indexOf(chars);
                if (pos > -1) {
                  return str.substr(0, pos);
                } else {
                  return str;
                }
              }
              function substringAfter(str, chars) {
                if (typeof str === "undefined") {
                  return void 0;
                }
                var pos = str.indexOf(chars);
                if (pos > -1) {
                  return str.substr(pos + chars.length);
                } else {
                  return str;
                }
              }
              function lowercase(str) {
                if (typeof str === "undefined") {
                  return void 0;
                }
                return str.toLowerCase();
              }
              function uppercase(str) {
                if (typeof str === "undefined") {
                  return void 0;
                }
                return str.toUpperCase();
              }
              function length(str) {
                if (typeof str === "undefined") {
                  return void 0;
                }
                return stringToArray(str).length;
              }
              function trim(str) {
                if (typeof str === "undefined") {
                  return void 0;
                }
                var result = str.replace(/[ \t\n\r]+/gm, " ");
                if (result.charAt(0) === " ") {
                  result = result.substring(1);
                }
                if (result.charAt(result.length - 1) === " ") {
                  result = result.substring(0, result.length - 1);
                }
                return result;
              }
              function pad(str, width, char) {
                if (typeof str === "undefined") {
                  return void 0;
                }
                if (typeof char === "undefined" || char.length === 0) {
                  char = " ";
                }
                var result;
                width = Math.trunc(width);
                var padLength = Math.abs(width) - length(str);
                if (padLength > 0) {
                  var padding = new Array(padLength + 1).join(char);
                  if (char.length > 1) {
                    padding = substring(padding, 0, padLength);
                  }
                  if (width > 0) {
                    result = str + padding;
                  } else {
                    result = padding + str;
                  }
                } else {
                  result = str;
                }
                return result;
              }
              async function evaluateMatcher(matcher, str) {
                var result = matcher.apply(this, [str]);
                if (isPromise(result)) {
                  result = await result;
                }
                if (result && !(typeof result.start === "number" || result.end === "number" || Array.isArray(result.groups) || isFunction(result.next))) {
                  throw {
                    code: "T1010",
                    stack: new Error().stack
                  };
                }
                return result;
              }
              async function contains(str, token) {
                if (typeof str === "undefined") {
                  return void 0;
                }
                var result;
                if (typeof token === "string") {
                  result = str.indexOf(token) !== -1;
                } else {
                  var matches = await evaluateMatcher(token, str);
                  result = typeof matches !== "undefined";
                }
                return result;
              }
              async function match(str, regex, limit) {
                if (typeof str === "undefined") {
                  return void 0;
                }
                if (limit < 0) {
                  throw {
                    stack: new Error().stack,
                    value: limit,
                    code: "D3040",
                    index: 3
                  };
                }
                var result = createSequence();
                if (typeof limit === "undefined" || limit > 0) {
                  var count2 = 0;
                  var matches = await evaluateMatcher(regex, str);
                  if (typeof matches !== "undefined") {
                    while (typeof matches !== "undefined" && (typeof limit === "undefined" || count2 < limit)) {
                      result.push({
                        match: matches.match,
                        index: matches.start,
                        groups: matches.groups
                      });
                      matches = await evaluateMatcher(matches.next);
                      count2++;
                    }
                  }
                }
                return result;
              }
              async function replace(str, pattern, replacement, limit) {
                if (typeof str === "undefined") {
                  return void 0;
                }
                var self2 = this;
                if (pattern === "") {
                  throw {
                    code: "D3010",
                    stack: new Error().stack,
                    value: pattern,
                    index: 2
                  };
                }
                if (limit < 0) {
                  throw {
                    code: "D3011",
                    stack: new Error().stack,
                    value: limit,
                    index: 4
                  };
                }
                var replacer;
                if (typeof replacement === "string") {
                  replacer = function(regexMatch) {
                    var substitute = "";
                    var position2 = 0;
                    var index2 = replacement.indexOf("$", position2);
                    while (index2 !== -1 && position2 < replacement.length) {
                      substitute += replacement.substring(position2, index2);
                      position2 = index2 + 1;
                      var dollarVal = replacement.charAt(position2);
                      if (dollarVal === "$") {
                        substitute += "$";
                        position2++;
                      } else if (dollarVal === "0") {
                        substitute += regexMatch.match;
                        position2++;
                      } else {
                        var maxDigits;
                        if (regexMatch.groups.length === 0) {
                          maxDigits = 1;
                        } else {
                          maxDigits = Math.floor(Math.log(regexMatch.groups.length) * Math.LOG10E) + 1;
                        }
                        index2 = parseInt(replacement.substring(position2, position2 + maxDigits), 10);
                        if (maxDigits > 1 && index2 > regexMatch.groups.length) {
                          index2 = parseInt(replacement.substring(position2, position2 + maxDigits - 1), 10);
                        }
                        if (!isNaN(index2)) {
                          if (regexMatch.groups.length > 0) {
                            var submatch = regexMatch.groups[index2 - 1];
                            if (typeof submatch !== "undefined") {
                              substitute += submatch;
                            }
                          }
                          position2 += index2.toString().length;
                        } else {
                          substitute += "$";
                        }
                      }
                      index2 = replacement.indexOf("$", position2);
                    }
                    substitute += replacement.substring(position2);
                    return substitute;
                  };
                } else {
                  replacer = replacement;
                }
                var result = "";
                var position = 0;
                if (typeof limit === "undefined" || limit > 0) {
                  var count2 = 0;
                  if (typeof pattern === "string") {
                    var index = str.indexOf(pattern, position);
                    while (index !== -1 && (typeof limit === "undefined" || count2 < limit)) {
                      result += str.substring(position, index);
                      result += replacement;
                      position = index + pattern.length;
                      count2++;
                      index = str.indexOf(pattern, position);
                    }
                    result += str.substring(position);
                  } else {
                    var matches = await evaluateMatcher(pattern, str);
                    if (typeof matches !== "undefined") {
                      while (typeof matches !== "undefined" && (typeof limit === "undefined" || count2 < limit)) {
                        result += str.substring(position, matches.start);
                        var replacedWith = replacer.apply(self2, [matches]);
                        if (isPromise(replacedWith)) {
                          replacedWith = await replacedWith;
                        }
                        if (typeof replacedWith === "string") {
                          result += replacedWith;
                        } else {
                          throw {
                            code: "D3012",
                            stack: new Error().stack,
                            value: replacedWith
                          };
                        }
                        position = matches.start + matches.match.length;
                        count2++;
                        matches = await evaluateMatcher(matches.next);
                      }
                      result += str.substring(position);
                    } else {
                      result = str;
                    }
                  }
                } else {
                  result = str;
                }
                return result;
              }
              function base64encode(str) {
                if (typeof str === "undefined") {
                  return void 0;
                }
                var btoa2 = typeof window !== "undefined" ? (
                  /* istanbul ignore next */
                  window.btoa
                ) : function(str2) {
                  return new global2.Buffer.from(str2, "binary").toString("base64");
                };
                return btoa2(str);
              }
              function base64decode(str) {
                if (typeof str === "undefined") {
                  return void 0;
                }
                var atob2 = typeof window !== "undefined" ? (
                  /* istanbul ignore next */
                  window.atob
                ) : function(str2) {
                  return new global2.Buffer.from(str2, "base64").toString("binary");
                };
                return atob2(str);
              }
              function encodeUrlComponent(str) {
                if (typeof str === "undefined") {
                  return void 0;
                }
                var returnVal;
                try {
                  returnVal = encodeURIComponent(str);
                } catch (e) {
                  throw {
                    code: "D3140",
                    stack: new Error().stack,
                    value: str,
                    functionName: "encodeUrlComponent"
                  };
                }
                return returnVal;
              }
              function encodeUrl(str) {
                if (typeof str === "undefined") {
                  return void 0;
                }
                var returnVal;
                try {
                  returnVal = encodeURI(str);
                } catch (e) {
                  throw {
                    code: "D3140",
                    stack: new Error().stack,
                    value: str,
                    functionName: "encodeUrl"
                  };
                }
                return returnVal;
              }
              function decodeUrlComponent(str) {
                if (typeof str === "undefined") {
                  return void 0;
                }
                var returnVal;
                try {
                  returnVal = decodeURIComponent(str);
                } catch (e) {
                  throw {
                    code: "D3140",
                    stack: new Error().stack,
                    value: str,
                    functionName: "decodeUrlComponent"
                  };
                }
                return returnVal;
              }
              function decodeUrl(str) {
                if (typeof str === "undefined") {
                  return void 0;
                }
                var returnVal;
                try {
                  returnVal = decodeURI(str);
                } catch (e) {
                  throw {
                    code: "D3140",
                    stack: new Error().stack,
                    value: str,
                    functionName: "decodeUrl"
                  };
                }
                return returnVal;
              }
              async function split(str, separator, limit) {
                if (typeof str === "undefined") {
                  return void 0;
                }
                if (limit < 0) {
                  throw {
                    code: "D3020",
                    stack: new Error().stack,
                    value: limit,
                    index: 3
                  };
                }
                var result = [];
                if (typeof limit === "undefined" || limit > 0) {
                  if (typeof separator === "string") {
                    result = str.split(separator, limit);
                  } else {
                    var count2 = 0;
                    var matches = await evaluateMatcher(separator, str);
                    if (typeof matches !== "undefined") {
                      var start = 0;
                      while (typeof matches !== "undefined" && (typeof limit === "undefined" || count2 < limit)) {
                        result.push(str.substring(start, matches.start));
                        start = matches.end;
                        matches = await evaluateMatcher(matches.next);
                        count2++;
                      }
                      if (typeof limit === "undefined" || count2 < limit) {
                        result.push(str.substring(start));
                      }
                    } else {
                      result.push(str);
                    }
                  }
                }
                return result;
              }
              function join(strs, separator) {
                if (typeof strs === "undefined") {
                  return void 0;
                }
                if (typeof separator === "undefined") {
                  separator = "";
                }
                return strs.join(separator);
              }
              function formatNumber(value, picture, options) {
                if (typeof value === "undefined") {
                  return void 0;
                }
                var defaults = {
                  "decimal-separator": ".",
                  "grouping-separator": ",",
                  "exponent-separator": "e",
                  "infinity": "Infinity",
                  "minus-sign": "-",
                  "NaN": "NaN",
                  "percent": "%",
                  "per-mille": "‰",
                  "zero-digit": "0",
                  "digit": "#",
                  "pattern-separator": ";"
                };
                var properties = defaults;
                if (typeof options !== "undefined") {
                  Object.keys(options).forEach(function(key) {
                    properties[key] = options[key];
                  });
                }
                var decimalDigitFamily = [];
                var zeroCharCode = properties["zero-digit"].charCodeAt(0);
                for (var ii = zeroCharCode; ii < zeroCharCode + 10; ii++) {
                  decimalDigitFamily.push(String.fromCharCode(ii));
                }
                var activeChars = decimalDigitFamily.concat([properties["decimal-separator"], properties["exponent-separator"], properties["grouping-separator"], properties.digit, properties["pattern-separator"]]);
                var subPictures = picture.split(properties["pattern-separator"]);
                if (subPictures.length > 2) {
                  throw {
                    code: "D3080",
                    stack: new Error().stack
                  };
                }
                var splitParts = function(subpicture) {
                  var prefix = (function() {
                    var ch;
                    for (var ii2 = 0; ii2 < subpicture.length; ii2++) {
                      ch = subpicture.charAt(ii2);
                      if (activeChars.indexOf(ch) !== -1 && ch !== properties["exponent-separator"]) {
                        return subpicture.substring(0, ii2);
                      }
                    }
                  })();
                  var suffix = (function() {
                    var ch;
                    for (var ii2 = subpicture.length - 1; ii2 >= 0; ii2--) {
                      ch = subpicture.charAt(ii2);
                      if (activeChars.indexOf(ch) !== -1 && ch !== properties["exponent-separator"]) {
                        return subpicture.substring(ii2 + 1);
                      }
                    }
                  })();
                  var activePart = subpicture.substring(prefix.length, subpicture.length - suffix.length);
                  var mantissaPart, exponentPart, integerPart, fractionalPart;
                  var exponentPosition = subpicture.indexOf(properties["exponent-separator"], prefix.length);
                  if (exponentPosition === -1 || exponentPosition > subpicture.length - suffix.length) {
                    mantissaPart = activePart;
                    exponentPart = void 0;
                  } else {
                    mantissaPart = activePart.substring(0, exponentPosition);
                    exponentPart = activePart.substring(exponentPosition + 1);
                  }
                  var decimalPosition = mantissaPart.indexOf(properties["decimal-separator"]);
                  if (decimalPosition === -1) {
                    integerPart = mantissaPart;
                    fractionalPart = suffix;
                  } else {
                    integerPart = mantissaPart.substring(0, decimalPosition);
                    fractionalPart = mantissaPart.substring(decimalPosition + 1);
                  }
                  return {
                    prefix,
                    suffix,
                    activePart,
                    mantissaPart,
                    exponentPart,
                    integerPart,
                    fractionalPart,
                    subpicture
                  };
                };
                var validate = function(parts2) {
                  var error2;
                  var ii2;
                  var subpicture = parts2.subpicture;
                  var decimalPos2 = subpicture.indexOf(properties["decimal-separator"]);
                  if (decimalPos2 !== subpicture.lastIndexOf(properties["decimal-separator"])) {
                    error2 = "D3081";
                  }
                  if (subpicture.indexOf(properties.percent) !== subpicture.lastIndexOf(properties.percent)) {
                    error2 = "D3082";
                  }
                  if (subpicture.indexOf(properties["per-mille"]) !== subpicture.lastIndexOf(properties["per-mille"])) {
                    error2 = "D3083";
                  }
                  if (subpicture.indexOf(properties.percent) !== -1 && subpicture.indexOf(properties["per-mille"]) !== -1) {
                    error2 = "D3084";
                  }
                  var valid = false;
                  for (ii2 = 0; ii2 < parts2.mantissaPart.length; ii2++) {
                    var ch = parts2.mantissaPart.charAt(ii2);
                    if (decimalDigitFamily.indexOf(ch) !== -1 || ch === properties.digit) {
                      valid = true;
                      break;
                    }
                  }
                  if (!valid) {
                    error2 = "D3085";
                  }
                  var charTypes = parts2.activePart.split("").map(function(char) {
                    return activeChars.indexOf(char) === -1 ? "p" : "a";
                  }).join("");
                  if (charTypes.indexOf("p") !== -1) {
                    error2 = "D3086";
                  }
                  if (decimalPos2 !== -1) {
                    if (subpicture.charAt(decimalPos2 - 1) === properties["grouping-separator"] || subpicture.charAt(decimalPos2 + 1) === properties["grouping-separator"]) {
                      error2 = "D3087";
                    }
                  } else if (parts2.integerPart.charAt(parts2.integerPart.length - 1) === properties["grouping-separator"]) {
                    error2 = "D3088";
                  }
                  if (subpicture.indexOf(properties["grouping-separator"] + properties["grouping-separator"]) !== -1) {
                    error2 = "D3089";
                  }
                  var optionalDigitPos = parts2.integerPart.indexOf(properties.digit);
                  if (optionalDigitPos !== -1 && parts2.integerPart.substring(0, optionalDigitPos).split("").filter(function(char) {
                    return decimalDigitFamily.indexOf(char) > -1;
                  }).length > 0) {
                    error2 = "D3090";
                  }
                  optionalDigitPos = parts2.fractionalPart.lastIndexOf(properties.digit);
                  if (optionalDigitPos !== -1 && parts2.fractionalPart.substring(optionalDigitPos).split("").filter(function(char) {
                    return decimalDigitFamily.indexOf(char) > -1;
                  }).length > 0) {
                    error2 = "D3091";
                  }
                  var exponentExists = typeof parts2.exponentPart === "string";
                  if (exponentExists && parts2.exponentPart.length > 0 && (subpicture.indexOf(properties.percent) !== -1 || subpicture.indexOf(properties["per-mille"]) !== -1)) {
                    error2 = "D3092";
                  }
                  if (exponentExists && (parts2.exponentPart.length === 0 || parts2.exponentPart.split("").filter(function(char) {
                    return decimalDigitFamily.indexOf(char) === -1;
                  }).length > 0)) {
                    error2 = "D3093";
                  }
                  if (error2) {
                    throw {
                      code: error2,
                      stack: new Error().stack
                    };
                  }
                };
                var analyse = function(parts2) {
                  var getGroupingPositions = function(part, toLeft) {
                    var positions = [];
                    var groupingPosition = part.indexOf(properties["grouping-separator"]);
                    while (groupingPosition !== -1) {
                      var charsToTheRight = (toLeft ? part.substring(0, groupingPosition) : part.substring(groupingPosition)).split("").filter(function(char) {
                        return decimalDigitFamily.indexOf(char) !== -1 || char === properties.digit;
                      }).length;
                      positions.push(charsToTheRight);
                      groupingPosition = parts2.integerPart.indexOf(properties["grouping-separator"], groupingPosition + 1);
                    }
                    return positions;
                  };
                  var integerPartGroupingPositions = getGroupingPositions(parts2.integerPart);
                  var regular = function(indexes) {
                    if (indexes.length === 0) {
                      return 0;
                    }
                    var gcd = function(a, b) {
                      return b === 0 ? a : gcd(b, a % b);
                    };
                    var factor = indexes.reduce(gcd);
                    for (var index = 1; index <= indexes.length; index++) {
                      if (indexes.indexOf(index * factor) === -1) {
                        return 0;
                      }
                    }
                    return factor;
                  };
                  var regularGrouping = regular(integerPartGroupingPositions);
                  var fractionalPartGroupingPositions = getGroupingPositions(parts2.fractionalPart, true);
                  var minimumIntegerPartSize = parts2.integerPart.split("").filter(function(char) {
                    return decimalDigitFamily.indexOf(char) !== -1;
                  }).length;
                  var scalingFactor = minimumIntegerPartSize;
                  var fractionalPartArray = parts2.fractionalPart.split("");
                  var minimumFactionalPartSize = fractionalPartArray.filter(function(char) {
                    return decimalDigitFamily.indexOf(char) !== -1;
                  }).length;
                  var maximumFactionalPartSize = fractionalPartArray.filter(function(char) {
                    return decimalDigitFamily.indexOf(char) !== -1 || char === properties.digit;
                  }).length;
                  var exponentPresent = typeof parts2.exponentPart === "string";
                  if (minimumIntegerPartSize === 0 && maximumFactionalPartSize === 0) {
                    if (exponentPresent) {
                      minimumFactionalPartSize = 1;
                      maximumFactionalPartSize = 1;
                    } else {
                      minimumIntegerPartSize = 1;
                    }
                  }
                  if (exponentPresent && minimumIntegerPartSize === 0 && parts2.integerPart.indexOf(properties.digit) !== -1) {
                    minimumIntegerPartSize = 1;
                  }
                  if (minimumIntegerPartSize === 0 && minimumFactionalPartSize === 0) {
                    minimumFactionalPartSize = 1;
                  }
                  var minimumExponentSize = 0;
                  if (exponentPresent) {
                    minimumExponentSize = parts2.exponentPart.split("").filter(function(char) {
                      return decimalDigitFamily.indexOf(char) !== -1;
                    }).length;
                  }
                  return {
                    integerPartGroupingPositions,
                    regularGrouping,
                    minimumIntegerPartSize,
                    scalingFactor,
                    prefix: parts2.prefix,
                    fractionalPartGroupingPositions,
                    minimumFactionalPartSize,
                    maximumFactionalPartSize,
                    minimumExponentSize,
                    suffix: parts2.suffix,
                    picture: parts2.subpicture
                  };
                };
                var parts = subPictures.map(splitParts);
                parts.forEach(validate);
                var variables = parts.map(analyse);
                var minus_sign = properties["minus-sign"];
                var zero_digit = properties["zero-digit"];
                var decimal_separator = properties["decimal-separator"];
                var grouping_separator = properties["grouping-separator"];
                if (variables.length === 1) {
                  variables.push(JSON.parse(JSON.stringify(variables[0])));
                  variables[1].prefix = minus_sign + variables[1].prefix;
                }
                var pic;
                if (value >= 0) {
                  pic = variables[0];
                } else {
                  pic = variables[1];
                }
                var adjustedNumber;
                if (pic.picture.indexOf(properties.percent) !== -1) {
                  adjustedNumber = value * 100;
                } else if (pic.picture.indexOf(properties["per-mille"]) !== -1) {
                  adjustedNumber = value * 1e3;
                } else {
                  adjustedNumber = value;
                }
                var mantissa, exponent;
                if (pic.minimumExponentSize === 0) {
                  mantissa = adjustedNumber;
                } else {
                  var maxMantissa = Math.pow(10, pic.scalingFactor);
                  var minMantissa = Math.pow(10, pic.scalingFactor - 1);
                  mantissa = adjustedNumber;
                  exponent = 0;
                  while (mantissa < minMantissa) {
                    mantissa *= 10;
                    exponent -= 1;
                  }
                  while (mantissa > maxMantissa) {
                    mantissa /= 10;
                    exponent += 1;
                  }
                }
                var roundedNumber = round(mantissa, pic.maximumFactionalPartSize);
                var makeString = function(value2, dp) {
                  var str = Math.abs(value2).toFixed(dp);
                  if (zero_digit !== "0") {
                    str = str.split("").map(function(digit) {
                      if (digit >= "0" && digit <= "9") {
                        return decimalDigitFamily[digit.charCodeAt(0) - 48];
                      } else {
                        return digit;
                      }
                    }).join("");
                  }
                  return str;
                };
                var stringValue = makeString(roundedNumber, pic.maximumFactionalPartSize);
                var decimalPos = stringValue.indexOf(".");
                if (decimalPos === -1) {
                  stringValue = stringValue + decimal_separator;
                } else {
                  stringValue = stringValue.replace(".", decimal_separator);
                }
                while (stringValue.charAt(0) === zero_digit) {
                  stringValue = stringValue.substring(1);
                }
                while (stringValue.charAt(stringValue.length - 1) === zero_digit) {
                  stringValue = stringValue.substring(0, stringValue.length - 1);
                }
                decimalPos = stringValue.indexOf(decimal_separator);
                var padLeft = pic.minimumIntegerPartSize - decimalPos;
                var padRight = pic.minimumFactionalPartSize - (stringValue.length - decimalPos - 1);
                stringValue = (padLeft > 0 ? new Array(padLeft + 1).join(zero_digit) : "") + stringValue;
                stringValue = stringValue + (padRight > 0 ? new Array(padRight + 1).join(zero_digit) : "");
                decimalPos = stringValue.indexOf(decimal_separator);
                if (pic.regularGrouping > 0) {
                  var groupCount = Math.floor((decimalPos - 1) / pic.regularGrouping);
                  for (var group = 1; group <= groupCount; group++) {
                    stringValue = [stringValue.slice(0, decimalPos - group * pic.regularGrouping), grouping_separator, stringValue.slice(decimalPos - group * pic.regularGrouping)].join("");
                  }
                } else {
                  pic.integerPartGroupingPositions.forEach(function(pos) {
                    stringValue = [stringValue.slice(0, decimalPos - pos), grouping_separator, stringValue.slice(decimalPos - pos)].join("");
                    decimalPos++;
                  });
                }
                decimalPos = stringValue.indexOf(decimal_separator);
                pic.fractionalPartGroupingPositions.forEach(function(pos) {
                  stringValue = [stringValue.slice(0, pos + decimalPos + 1), grouping_separator, stringValue.slice(pos + decimalPos + 1)].join("");
                });
                decimalPos = stringValue.indexOf(decimal_separator);
                if (pic.picture.indexOf(decimal_separator) === -1 || decimalPos === stringValue.length - 1) {
                  stringValue = stringValue.substring(0, stringValue.length - 1);
                }
                if (typeof exponent !== "undefined") {
                  var stringExponent = makeString(exponent, 0);
                  padLeft = pic.minimumExponentSize - stringExponent.length;
                  if (padLeft > 0) {
                    stringExponent = new Array(padLeft + 1).join(zero_digit) + stringExponent;
                  }
                  stringValue = stringValue + properties["exponent-separator"] + (exponent < 0 ? minus_sign : "") + stringExponent;
                }
                stringValue = pic.prefix + stringValue + pic.suffix;
                return stringValue;
              }
              function formatBase(value, radix) {
                if (typeof value === "undefined") {
                  return void 0;
                }
                value = round(value);
                if (typeof radix === "undefined") {
                  radix = 10;
                } else {
                  radix = round(radix);
                }
                if (radix < 2 || radix > 36) {
                  throw {
                    code: "D3100",
                    stack: new Error().stack,
                    value: radix
                  };
                }
                var result = value.toString(radix);
                return result;
              }
              function number(arg) {
                var result;
                if (typeof arg === "undefined") {
                  return void 0;
                }
                if (typeof arg === "number") {
                  result = arg;
                } else if (typeof arg === "string" && /^-?[0-9]+(\.[0-9]+)?([Ee][-+]?[0-9]+)?$/.test(arg) && !isNaN(parseFloat(arg)) && isFinite(arg)) {
                  result = parseFloat(arg);
                } else if (typeof arg === "string" && /^(0[xX][0-9A-Fa-f]+)|(0[oO][0-7]+)|(0[bB][0-1]+)$/.test(arg)) {
                  result = Number(arg);
                } else if (arg === true) {
                  result = 1;
                } else if (arg === false) {
                  result = 0;
                } else {
                  throw {
                    code: "D3030",
                    value: arg,
                    stack: new Error().stack,
                    index: 1
                  };
                }
                return result;
              }
              function abs(arg) {
                var result;
                if (typeof arg === "undefined") {
                  return void 0;
                }
                result = Math.abs(arg);
                return result;
              }
              function floor(arg) {
                var result;
                if (typeof arg === "undefined") {
                  return void 0;
                }
                result = Math.floor(arg);
                return result;
              }
              function ceil(arg) {
                var result;
                if (typeof arg === "undefined") {
                  return void 0;
                }
                result = Math.ceil(arg);
                return result;
              }
              function round(arg, precision) {
                var result;
                if (typeof arg === "undefined") {
                  return void 0;
                }
                if (precision) {
                  var value = arg.toString().split("e");
                  arg = +(value[0] + "e" + (value[1] ? +value[1] + precision : precision));
                }
                result = Math.round(arg);
                var diff = result - arg;
                if (Math.abs(diff) === 0.5 && Math.abs(result % 2) === 1) {
                  result = result - 1;
                }
                if (precision) {
                  value = result.toString().split("e");
                  result = +(value[0] + "e" + (value[1] ? +value[1] - precision : -precision));
                }
                if (Object.is(result, -0)) {
                  result = 0;
                }
                return result;
              }
              function sqrt(arg) {
                var result;
                if (typeof arg === "undefined") {
                  return void 0;
                }
                if (arg < 0) {
                  throw {
                    stack: new Error().stack,
                    code: "D3060",
                    index: 1,
                    value: arg
                  };
                }
                result = Math.sqrt(arg);
                return result;
              }
              function power(arg, exp) {
                var result;
                if (typeof arg === "undefined") {
                  return void 0;
                }
                result = Math.pow(arg, exp);
                if (!isFinite(result)) {
                  throw {
                    stack: new Error().stack,
                    code: "D3061",
                    index: 1,
                    value: arg,
                    exp
                  };
                }
                return result;
              }
              function random() {
                return Math.random();
              }
              function boolean(arg) {
                if (typeof arg === "undefined") {
                  return void 0;
                }
                var result = false;
                if (Array.isArray(arg)) {
                  if (arg.length === 1) {
                    result = boolean(arg[0]);
                  } else if (arg.length > 1) {
                    var trues = arg.filter(function(val) {
                      return boolean(val);
                    });
                    result = trues.length > 0;
                  }
                } else if (typeof arg === "string") {
                  if (arg.length > 0) {
                    result = true;
                  }
                } else if (isNumeric(arg)) {
                  if (arg !== 0) {
                    result = true;
                  }
                } else if (arg !== null && typeof arg === "object" && !isFunction(arg)) {
                  if (Object.keys(arg).length > 0) {
                    result = true;
                  }
                } else if (typeof arg === "boolean" && arg === true) {
                  result = true;
                }
                return result;
              }
              function not(arg) {
                if (typeof arg === "undefined") {
                  return void 0;
                }
                return !boolean(arg);
              }
              function hofFuncArgs(func, arg1, arg2, arg3) {
                var func_args = [arg1];
                var length2 = getFunctionArity(func);
                if (length2 >= 2) {
                  func_args.push(arg2);
                }
                if (length2 >= 3) {
                  func_args.push(arg3);
                }
                return func_args;
              }
              async function map(arr, func) {
                if (typeof arr === "undefined") {
                  return void 0;
                }
                var result = createSequence();
                for (var i = 0; i < arr.length; i++) {
                  var func_args = hofFuncArgs(func, arr[i], i, arr);
                  var res = await func.apply(this, func_args);
                  if (typeof res !== "undefined") {
                    result.push(res);
                  }
                }
                return result;
              }
              async function filter(arr, func) {
                if (typeof arr === "undefined") {
                  return void 0;
                }
                var result = createSequence();
                for (var i = 0; i < arr.length; i++) {
                  var entry = arr[i];
                  var func_args = hofFuncArgs(func, entry, i, arr);
                  var res = await func.apply(this, func_args);
                  if (boolean(res)) {
                    result.push(entry);
                  }
                }
                return result;
              }
              async function single(arr, func) {
                if (typeof arr === "undefined") {
                  return void 0;
                }
                var hasFoundMatch = false;
                var result;
                for (var i = 0; i < arr.length; i++) {
                  var entry = arr[i];
                  var positiveResult = true;
                  if (typeof func !== "undefined") {
                    var func_args = hofFuncArgs(func, entry, i, arr);
                    var res = await func.apply(this, func_args);
                    positiveResult = boolean(res);
                  }
                  if (positiveResult) {
                    if (!hasFoundMatch) {
                      result = entry;
                      hasFoundMatch = true;
                    } else {
                      throw {
                        stack: new Error().stack,
                        code: "D3138",
                        index: i
                      };
                    }
                  }
                }
                if (!hasFoundMatch) {
                  throw {
                    stack: new Error().stack,
                    code: "D3139"
                  };
                }
                return result;
              }
              function zip() {
                var result = [];
                var args = Array.prototype.slice.call(arguments);
                var length2 = Math.min.apply(Math, args.map(function(arg) {
                  if (Array.isArray(arg)) {
                    return arg.length;
                  }
                  return 0;
                }));
                for (var i = 0; i < length2; i++) {
                  var tuple = args.map((arg) => {
                    return arg[i];
                  });
                  result.push(tuple);
                }
                return result;
              }
              async function foldLeft(sequence, func, init) {
                if (typeof sequence === "undefined") {
                  return void 0;
                }
                var result;
                var arity = getFunctionArity(func);
                if (arity < 2) {
                  throw {
                    stack: new Error().stack,
                    code: "D3050",
                    index: 1
                  };
                }
                var index;
                if (typeof init === "undefined" && sequence.length > 0) {
                  result = sequence[0];
                  index = 1;
                } else {
                  result = init;
                  index = 0;
                }
                while (index < sequence.length) {
                  var args = [result, sequence[index]];
                  if (arity >= 3) {
                    args.push(index);
                  }
                  if (arity >= 4) {
                    args.push(sequence);
                  }
                  result = await func.apply(this, args);
                  index++;
                }
                return result;
              }
              function keys(arg) {
                var result = createSequence();
                if (Array.isArray(arg)) {
                  var merge2 = {};
                  arg.forEach(function(item) {
                    var allkeys = keys(item);
                    allkeys.forEach(function(key) {
                      merge2[key] = true;
                    });
                  });
                  result = keys(merge2);
                } else if (arg !== null && typeof arg === "object" && !isFunction(arg)) {
                  Object.keys(arg).forEach((key) => result.push(key));
                }
                return result;
              }
              function lookup(input, key) {
                var result;
                if (Array.isArray(input)) {
                  result = createSequence();
                  for (var ii = 0; ii < input.length; ii++) {
                    var res = lookup(input[ii], key);
                    if (typeof res !== "undefined") {
                      if (Array.isArray(res)) {
                        res.forEach((val) => result.push(val));
                      } else {
                        result.push(res);
                      }
                    }
                  }
                } else if (input !== null && typeof input === "object" && !isFunction(input)) {
                  result = input[key];
                }
                return result;
              }
              function append(arg1, arg2) {
                if (typeof arg1 === "undefined") {
                  return arg2;
                }
                if (typeof arg2 === "undefined") {
                  return arg1;
                }
                if (!Array.isArray(arg1)) {
                  arg1 = createSequence(arg1);
                }
                if (!Array.isArray(arg2)) {
                  arg2 = [arg2];
                }
                return arg1.concat(arg2);
              }
              function exists(arg) {
                if (typeof arg === "undefined") {
                  return false;
                } else {
                  return true;
                }
              }
              function spread(arg) {
                var result = createSequence();
                if (Array.isArray(arg)) {
                  arg.forEach(function(item) {
                    result = append(result, spread(item));
                  });
                } else if (arg !== null && typeof arg === "object" && !isLambda(arg)) {
                  for (var key in arg) {
                    var obj = {};
                    obj[key] = arg[key];
                    result.push(obj);
                  }
                } else {
                  result = arg;
                }
                return result;
              }
              function merge(arg) {
                if (typeof arg === "undefined") {
                  return void 0;
                }
                var result = {};
                arg.forEach(function(obj) {
                  for (var prop in obj) {
                    result[prop] = obj[prop];
                  }
                });
                return result;
              }
              function reverse(arr) {
                if (typeof arr === "undefined") {
                  return void 0;
                }
                if (arr.length <= 1) {
                  return arr;
                }
                var length2 = arr.length;
                var result = new Array(length2);
                for (var i = 0; i < length2; i++) {
                  result[length2 - i - 1] = arr[i];
                }
                return result;
              }
              async function each(obj, func) {
                var result = createSequence();
                for (var key in obj) {
                  var func_args = hofFuncArgs(func, obj[key], key, obj);
                  var val = await func.apply(this, func_args);
                  if (typeof val !== "undefined") {
                    result.push(val);
                  }
                }
                return result;
              }
              function error(message) {
                throw {
                  code: "D3137",
                  stack: new Error().stack,
                  message: message || "$error() function evaluated"
                };
              }
              function assert(condition, message) {
                if (!condition) {
                  throw {
                    code: "D3141",
                    stack: new Error().stack,
                    message: message || "$assert() statement failed"
                  };
                }
                return void 0;
              }
              function type(value) {
                if (value === void 0) {
                  return void 0;
                }
                if (value === null) {
                  return "null";
                }
                if (isNumeric(value)) {
                  return "number";
                }
                if (typeof value === "string") {
                  return "string";
                }
                if (typeof value === "boolean") {
                  return "boolean";
                }
                if (Array.isArray(value)) {
                  return "array";
                }
                if (isFunction(value)) {
                  return "function";
                }
                return "object";
              }
              async function sort(arr, comparator) {
                if (typeof arr === "undefined") {
                  return void 0;
                }
                if (arr.length <= 1) {
                  return arr;
                }
                var comp;
                if (typeof comparator === "undefined") {
                  if (!isArrayOfNumbers(arr) && !isArrayOfStrings(arr)) {
                    throw {
                      stack: new Error().stack,
                      code: "D3070",
                      index: 1
                    };
                  }
                  comp = async function(a, b) {
                    return a > b;
                  };
                } else {
                  comp = comparator;
                }
                var merge2 = async function(l, r) {
                  var merge_iter = async function(result2, left, right) {
                    if (left.length === 0) {
                      Array.prototype.push.apply(result2, right);
                    } else if (right.length === 0) {
                      Array.prototype.push.apply(result2, left);
                    } else if (await comp(left[0], right[0])) {
                      result2.push(right[0]);
                      await merge_iter(result2, left, right.slice(1));
                    } else {
                      result2.push(left[0]);
                      await merge_iter(result2, left.slice(1), right);
                    }
                  };
                  var merged = [];
                  await merge_iter(merged, l, r);
                  return merged;
                };
                var msort = async function(array) {
                  if (!Array.isArray(array) || array.length <= 1) {
                    return array;
                  } else {
                    var middle = Math.floor(array.length / 2);
                    var left = array.slice(0, middle);
                    var right = array.slice(middle);
                    left = await msort(left);
                    right = await msort(right);
                    return await merge2(left, right);
                  }
                };
                var result = await msort(arr);
                return result;
              }
              function shuffle(arr) {
                if (typeof arr === "undefined") {
                  return void 0;
                }
                if (arr.length <= 1) {
                  return arr;
                }
                var result = new Array(arr.length);
                for (var i = 0; i < arr.length; i++) {
                  var j = Math.floor(Math.random() * (i + 1));
                  if (i !== j) {
                    result[i] = result[j];
                  }
                  result[j] = arr[i];
                }
                return result;
              }
              function distinct(arr) {
                if (typeof arr === "undefined") {
                  return void 0;
                }
                if (!Array.isArray(arr) || arr.length <= 1) {
                  return arr;
                }
                var results = isSequence(arr) ? createSequence() : [];
                for (var ii = 0; ii < arr.length; ii++) {
                  var value = arr[ii];
                  var includes = false;
                  for (var jj = 0; jj < results.length; jj++) {
                    if (deepEquals(value, results[jj])) {
                      includes = true;
                      break;
                    }
                  }
                  if (!includes) {
                    results.push(value);
                  }
                }
                return results;
              }
              async function sift(arg, func) {
                var result = {};
                for (var item in arg) {
                  var entry = arg[item];
                  var func_args = hofFuncArgs(func, entry, item, arg);
                  var res = await func.apply(this, func_args);
                  if (boolean(res)) {
                    result[item] = entry;
                  }
                }
                if (Object.keys(result).length === 0) {
                  result = void 0;
                }
                return result;
              }
              return {
                sum,
                count,
                max,
                min,
                average,
                string,
                substring,
                substringBefore,
                substringAfter,
                lowercase,
                uppercase,
                length,
                trim,
                pad,
                match,
                contains,
                replace,
                split,
                join,
                formatNumber,
                formatBase,
                number,
                floor,
                ceil,
                round,
                abs,
                sqrt,
                power,
                random,
                boolean,
                not,
                map,
                zip,
                filter,
                single,
                foldLeft,
                sift,
                keys,
                lookup,
                append,
                exists,
                spread,
                merge,
                reverse,
                each,
                error,
                assert,
                type,
                sort,
                shuffle,
                distinct,
                base64encode,
                base64decode,
                encodeUrlComponent,
                encodeUrl,
                decodeUrlComponent,
                decodeUrl
              };
            })();
            module4.exports = functions;
          }).call(this);
        }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
      }, { "./utils": 6 }], 3: [function(require2, module4, exports4) {
        var datetime = require2("./datetime");
        var fn = require2("./functions");
        var utils = require2("./utils");
        var parser = require2("./parser");
        var parseSignature = require2("./signature");
        var jsonata = (function() {
          "use strict";
          var isNumeric = utils.isNumeric;
          var isArrayOfStrings = utils.isArrayOfStrings;
          var isArrayOfNumbers = utils.isArrayOfNumbers;
          var createSequence = utils.createSequence;
          var isSequence = utils.isSequence;
          var isFunction = utils.isFunction;
          var isLambda = utils.isLambda;
          var isIterable = utils.isIterable;
          var isPromise = utils.isPromise;
          var getFunctionArity = utils.getFunctionArity;
          var isDeepEqual = utils.isDeepEqual;
          var staticFrame = createFrame(null);
          async function evaluate(expr, input, environment) {
            var result;
            var entryCallback = environment.lookup(Symbol.for("jsonata.__evaluate_entry"));
            if (entryCallback) {
              await entryCallback(expr, input, environment);
            }
            switch (expr.type) {
              case "path":
                result = await evaluatePath(expr, input, environment);
                break;
              case "binary":
                result = await evaluateBinary(expr, input, environment);
                break;
              case "unary":
                result = await evaluateUnary(expr, input, environment);
                break;
              case "name":
                result = evaluateName(expr, input, environment);
                break;
              case "string":
              case "number":
              case "value":
                result = evaluateLiteral(expr, input, environment);
                break;
              case "wildcard":
                result = evaluateWildcard(expr, input, environment);
                break;
              case "descendant":
                result = evaluateDescendants(expr, input, environment);
                break;
              case "parent":
                result = environment.lookup(expr.slot.label);
                break;
              case "condition":
                result = await evaluateCondition(expr, input, environment);
                break;
              case "block":
                result = await evaluateBlock(expr, input, environment);
                break;
              case "bind":
                result = await evaluateBindExpression(expr, input, environment);
                break;
              case "regex":
                result = evaluateRegex(expr, input, environment);
                break;
              case "function":
                result = await evaluateFunction(expr, input, environment);
                break;
              case "variable":
                result = evaluateVariable(expr, input, environment);
                break;
              case "lambda":
                result = evaluateLambda(expr, input, environment);
                break;
              case "partial":
                result = await evaluatePartialApplication(expr, input, environment);
                break;
              case "apply":
                result = await evaluateApplyExpression(expr, input, environment);
                break;
              case "transform":
                result = evaluateTransformExpression(expr, input, environment);
                break;
            }
            if (Object.prototype.hasOwnProperty.call(expr, "predicate")) {
              for (var ii = 0; ii < expr.predicate.length; ii++) {
                result = await evaluateFilter(expr.predicate[ii].expr, result, environment);
              }
            }
            if (expr.type !== "path" && Object.prototype.hasOwnProperty.call(expr, "group")) {
              result = await evaluateGroupExpression(expr.group, result, environment);
            }
            var exitCallback = environment.lookup(Symbol.for("jsonata.__evaluate_exit"));
            if (exitCallback) {
              await exitCallback(expr, input, environment, result);
            }
            if (result && isSequence(result) && !result.tupleStream) {
              if (expr.keepArray) {
                result.keepSingleton = true;
              }
              if (result.length === 0) {
                result = void 0;
              } else if (result.length === 1) {
                result = result.keepSingleton ? result : result[0];
              }
            }
            return result;
          }
          async function evaluatePath(expr, input, environment) {
            var inputSequence;
            if (Array.isArray(input) && expr.steps[0].type !== "variable") {
              inputSequence = input;
            } else {
              inputSequence = createSequence(input);
            }
            var resultSequence;
            var isTupleStream = false;
            var tupleBindings = void 0;
            for (var ii = 0; ii < expr.steps.length; ii++) {
              var step = expr.steps[ii];
              if (step.tuple) {
                isTupleStream = true;
              }
              if (ii === 0 && step.consarray) {
                resultSequence = await evaluate(step, inputSequence, environment);
              } else {
                if (isTupleStream) {
                  tupleBindings = await evaluateTupleStep(step, inputSequence, tupleBindings, environment);
                } else {
                  resultSequence = await evaluateStep(step, inputSequence, environment, ii === expr.steps.length - 1);
                }
              }
              if (!isTupleStream && (typeof resultSequence === "undefined" || resultSequence.length === 0)) {
                break;
              }
              if (typeof step.focus === "undefined") {
                inputSequence = resultSequence;
              }
            }
            if (isTupleStream) {
              if (expr.tuple) {
                resultSequence = tupleBindings;
              } else {
                resultSequence = createSequence();
                for (ii = 0; ii < tupleBindings.length; ii++) {
                  resultSequence.push(tupleBindings[ii]["@"]);
                }
              }
            }
            if (expr.keepSingletonArray) {
              if (Array.isArray(resultSequence) && resultSequence.cons && !resultSequence.sequence) {
                resultSequence = createSequence(resultSequence);
              }
              resultSequence.keepSingleton = true;
            }
            if (expr.hasOwnProperty("group")) {
              resultSequence = await evaluateGroupExpression(expr.group, isTupleStream ? tupleBindings : resultSequence, environment);
            }
            return resultSequence;
          }
          function createFrameFromTuple(environment, tuple) {
            var frame = createFrame(environment);
            for (const prop in tuple) {
              frame.bind(prop, tuple[prop]);
            }
            return frame;
          }
          async function evaluateStep(expr, input, environment, lastStep) {
            var result;
            if (expr.type === "sort") {
              result = await evaluateSortExpression(expr, input, environment);
              if (expr.stages) {
                result = await evaluateStages(expr.stages, result, environment);
              }
              return result;
            }
            result = createSequence();
            for (var ii = 0; ii < input.length; ii++) {
              var res = await evaluate(expr, input[ii], environment);
              if (expr.stages) {
                for (var ss = 0; ss < expr.stages.length; ss++) {
                  res = await evaluateFilter(expr.stages[ss].expr, res, environment);
                }
              }
              if (typeof res !== "undefined") {
                result.push(res);
              }
            }
            var resultSequence = createSequence();
            if (lastStep && result.length === 1 && Array.isArray(result[0]) && !isSequence(result[0])) {
              resultSequence = result[0];
            } else {
              result.forEach(function(res2) {
                if (!Array.isArray(res2) || res2.cons) {
                  resultSequence.push(res2);
                } else {
                  res2.forEach((val) => resultSequence.push(val));
                }
              });
            }
            return resultSequence;
          }
          async function evaluateStages(stages, input, environment) {
            var result = input;
            for (var ss = 0; ss < stages.length; ss++) {
              var stage = stages[ss];
              switch (stage.type) {
                case "filter":
                  result = await evaluateFilter(stage.expr, result, environment);
                  break;
                case "index":
                  for (var ee = 0; ee < result.length; ee++) {
                    var tuple = result[ee];
                    tuple[stage.value] = ee;
                  }
                  break;
              }
            }
            return result;
          }
          async function evaluateTupleStep(expr, input, tupleBindings, environment) {
            var result;
            if (expr.type === "sort") {
              if (tupleBindings) {
                result = await evaluateSortExpression(expr, tupleBindings, environment);
              } else {
                var sorted = await evaluateSortExpression(expr, input, environment);
                result = createSequence();
                result.tupleStream = true;
                for (var ss = 0; ss < sorted.length; ss++) {
                  var tuple = { "@": sorted[ss] };
                  tuple[expr.index] = ss;
                  result.push(tuple);
                }
              }
              if (expr.stages) {
                result = await evaluateStages(expr.stages, result, environment);
              }
              return result;
            }
            result = createSequence();
            result.tupleStream = true;
            var stepEnv = environment;
            if (tupleBindings === void 0) {
              tupleBindings = input.map((item) => {
                return { "@": item };
              });
            }
            for (var ee = 0; ee < tupleBindings.length; ee++) {
              stepEnv = createFrameFromTuple(environment, tupleBindings[ee]);
              var res = await evaluate(expr, tupleBindings[ee]["@"], stepEnv);
              if (typeof res !== "undefined") {
                if (!Array.isArray(res)) {
                  res = [res];
                }
                for (var bb = 0; bb < res.length; bb++) {
                  tuple = {};
                  Object.assign(tuple, tupleBindings[ee]);
                  if (res.tupleStream) {
                    Object.assign(tuple, res[bb]);
                  } else {
                    if (expr.focus) {
                      tuple[expr.focus] = res[bb];
                      tuple["@"] = tupleBindings[ee]["@"];
                    } else {
                      tuple["@"] = res[bb];
                    }
                    if (expr.index) {
                      tuple[expr.index] = bb;
                    }
                    if (expr.ancestor) {
                      tuple[expr.ancestor.label] = tupleBindings[ee]["@"];
                    }
                  }
                  result.push(tuple);
                }
              }
            }
            if (expr.stages) {
              result = await evaluateStages(expr.stages, result, environment);
            }
            return result;
          }
          async function evaluateFilter(predicate, input, environment) {
            var results = createSequence();
            if (input && input.tupleStream) {
              results.tupleStream = true;
            }
            if (!Array.isArray(input)) {
              input = createSequence(input);
            }
            if (predicate.type === "number") {
              var index = Math.floor(predicate.value);
              if (index < 0) {
                index = input.length + index;
              }
              var item = await input[index];
              if (typeof item !== "undefined") {
                if (Array.isArray(item)) {
                  results = item;
                } else {
                  results.push(item);
                }
              }
            } else {
              for (index = 0; index < input.length; index++) {
                var item = input[index];
                var context = item;
                var env = environment;
                if (input.tupleStream) {
                  context = item["@"];
                  env = createFrameFromTuple(environment, item);
                }
                var res = await evaluate(predicate, context, env);
                if (isNumeric(res)) {
                  res = [res];
                }
                if (isArrayOfNumbers(res)) {
                  res.forEach(function(ires) {
                    var ii = Math.floor(ires);
                    if (ii < 0) {
                      ii = input.length + ii;
                    }
                    if (ii === index) {
                      results.push(item);
                    }
                  });
                } else if (fn.boolean(res)) {
                  results.push(item);
                }
              }
            }
            return results;
          }
          async function evaluateBinary(expr, input, environment) {
            var result;
            var lhs = await evaluate(expr.lhs, input, environment);
            var op = expr.value;
            var evalrhs = async () => await evaluate(expr.rhs, input, environment);
            if (op === "and" || op === "or") {
              try {
                return await evaluateBooleanExpression(lhs, evalrhs, op);
              } catch (err) {
                err.position = expr.position;
                err.token = op;
                throw err;
              }
            }
            var rhs = await evalrhs();
            try {
              switch (op) {
                case "+":
                case "-":
                case "*":
                case "/":
                case "%":
                  result = evaluateNumericExpression(lhs, rhs, op);
                  break;
                case "=":
                case "!=":
                  result = evaluateEqualityExpression(lhs, rhs, op);
                  break;
                case "<":
                case "<=":
                case ">":
                case ">=":
                  result = evaluateComparisonExpression(lhs, rhs, op);
                  break;
                case "&":
                  result = evaluateStringConcat(lhs, rhs);
                  break;
                case "..":
                  result = evaluateRangeExpression(lhs, rhs);
                  break;
                case "in":
                  result = evaluateIncludesExpression(lhs, rhs);
                  break;
              }
            } catch (err) {
              err.position = expr.position;
              err.token = op;
              throw err;
            }
            return result;
          }
          async function evaluateUnary(expr, input, environment) {
            var result;
            switch (expr.value) {
              case "-":
                result = await evaluate(expr.expression, input, environment);
                if (typeof result === "undefined") {
                  result = void 0;
                } else if (isNumeric(result)) {
                  result = -result;
                } else {
                  throw {
                    code: "D1002",
                    stack: new Error().stack,
                    position: expr.position,
                    token: expr.value,
                    value: result
                  };
                }
                break;
              case "[":
                result = [];
                let generators = await Promise.all(expr.expressions.map(async (item2, idx) => {
                  environment.isParallelCall = idx > 0;
                  return [item2, await evaluate(item2, input, environment)];
                }));
                for (let generator of generators) {
                  var [item, value] = generator;
                  if (typeof value !== "undefined") {
                    if (item.value === "[") {
                      result.push(value);
                    } else {
                      result = fn.append(result, value);
                    }
                  }
                }
                if (expr.consarray) {
                  Object.defineProperty(result, "cons", {
                    enumerable: false,
                    configurable: false,
                    value: true
                  });
                }
                break;
              case "{":
                result = await evaluateGroupExpression(expr, input, environment);
                break;
            }
            return result;
          }
          function evaluateName(expr, input, environment) {
            return fn.lookup(input, expr.value);
          }
          function evaluateLiteral(expr) {
            return expr.value;
          }
          function evaluateWildcard(expr, input) {
            var results = createSequence();
            if (Array.isArray(input) && input.outerWrapper && input.length > 0) {
              input = input[0];
            }
            if (input !== null && typeof input === "object") {
              Object.keys(input).forEach(function(key) {
                var value = input[key];
                if (Array.isArray(value)) {
                  value = flatten(value);
                  results = fn.append(results, value);
                } else {
                  results.push(value);
                }
              });
            }
            return results;
          }
          function flatten(arg, flattened) {
            if (typeof flattened === "undefined") {
              flattened = [];
            }
            if (Array.isArray(arg)) {
              arg.forEach(function(item) {
                flatten(item, flattened);
              });
            } else {
              flattened.push(arg);
            }
            return flattened;
          }
          function evaluateDescendants(expr, input) {
            var result;
            var resultSequence = createSequence();
            if (typeof input !== "undefined") {
              recurseDescendants(input, resultSequence);
              if (resultSequence.length === 1) {
                result = resultSequence[0];
              } else {
                result = resultSequence;
              }
            }
            return result;
          }
          function recurseDescendants(input, results) {
            if (!Array.isArray(input)) {
              results.push(input);
            }
            if (Array.isArray(input)) {
              input.forEach(function(member) {
                recurseDescendants(member, results);
              });
            } else if (input !== null && typeof input === "object") {
              Object.keys(input).forEach(function(key) {
                recurseDescendants(input[key], results);
              });
            }
          }
          function evaluateNumericExpression(lhs, rhs, op) {
            var result;
            if (typeof lhs !== "undefined" && !isNumeric(lhs)) {
              throw {
                code: "T2001",
                stack: new Error().stack,
                value: lhs
              };
            }
            if (typeof rhs !== "undefined" && !isNumeric(rhs)) {
              throw {
                code: "T2002",
                stack: new Error().stack,
                value: rhs
              };
            }
            if (typeof lhs === "undefined" || typeof rhs === "undefined") {
              return result;
            }
            switch (op) {
              case "+":
                result = lhs + rhs;
                break;
              case "-":
                result = lhs - rhs;
                break;
              case "*":
                result = lhs * rhs;
                break;
              case "/":
                result = lhs / rhs;
                break;
              case "%":
                result = lhs % rhs;
                break;
            }
            return result;
          }
          function evaluateEqualityExpression(lhs, rhs, op) {
            var result;
            var ltype = typeof lhs;
            var rtype = typeof rhs;
            if (ltype === "undefined" || rtype === "undefined") {
              return false;
            }
            switch (op) {
              case "=":
                result = isDeepEqual(lhs, rhs);
                break;
              case "!=":
                result = !isDeepEqual(lhs, rhs);
                break;
            }
            return result;
          }
          function evaluateComparisonExpression(lhs, rhs, op) {
            var result;
            var ltype = typeof lhs;
            var rtype = typeof rhs;
            var lcomparable = ltype === "undefined" || ltype === "string" || ltype === "number";
            var rcomparable = rtype === "undefined" || rtype === "string" || rtype === "number";
            if (!lcomparable || !rcomparable) {
              throw {
                code: "T2010",
                stack: new Error().stack,
                value: !(ltype === "string" || ltype === "number") ? lhs : rhs
              };
            }
            if (ltype === "undefined" || rtype === "undefined") {
              return void 0;
            }
            if (ltype !== rtype) {
              throw {
                code: "T2009",
                stack: new Error().stack,
                value: lhs,
                value2: rhs
              };
            }
            switch (op) {
              case "<":
                result = lhs < rhs;
                break;
              case "<=":
                result = lhs <= rhs;
                break;
              case ">":
                result = lhs > rhs;
                break;
              case ">=":
                result = lhs >= rhs;
                break;
            }
            return result;
          }
          function evaluateIncludesExpression(lhs, rhs) {
            var result = false;
            if (typeof lhs === "undefined" || typeof rhs === "undefined") {
              return false;
            }
            if (!Array.isArray(rhs)) {
              rhs = [rhs];
            }
            for (var i = 0; i < rhs.length; i++) {
              if (rhs[i] === lhs) {
                result = true;
                break;
              }
            }
            return result;
          }
          async function evaluateBooleanExpression(lhs, evalrhs, op) {
            var result;
            var lBool = boolize(lhs);
            switch (op) {
              case "and":
                result = lBool && boolize(await evalrhs());
                break;
              case "or":
                result = lBool || boolize(await evalrhs());
                break;
            }
            return result;
          }
          function boolize(value) {
            var booledValue = fn.boolean(value);
            return typeof booledValue === "undefined" ? false : booledValue;
          }
          function evaluateStringConcat(lhs, rhs) {
            var result;
            var lstr = "";
            var rstr = "";
            if (typeof lhs !== "undefined") {
              lstr = fn.string(lhs);
            }
            if (typeof rhs !== "undefined") {
              rstr = fn.string(rhs);
            }
            result = lstr.concat(rstr);
            return result;
          }
          async function evaluateGroupExpression(expr, input, environment) {
            var result = {};
            var groups = {};
            var reduce = input && input.tupleStream ? true : false;
            if (!Array.isArray(input)) {
              input = createSequence(input);
            }
            if (input.length === 0) {
              input.push(void 0);
            }
            for (var itemIndex = 0; itemIndex < input.length; itemIndex++) {
              var item = input[itemIndex];
              var env = reduce ? createFrameFromTuple(environment, item) : environment;
              for (var pairIndex = 0; pairIndex < expr.lhs.length; pairIndex++) {
                var pair = expr.lhs[pairIndex];
                var key = await evaluate(pair[0], reduce ? item["@"] : item, env);
                if (typeof key !== "string" && key !== void 0) {
                  throw {
                    code: "T1003",
                    stack: new Error().stack,
                    position: expr.position,
                    value: key
                  };
                }
                if (key !== void 0) {
                  var entry = { data: item, exprIndex: pairIndex };
                  if (groups.hasOwnProperty(key)) {
                    if (groups[key].exprIndex !== pairIndex) {
                      throw {
                        code: "D1009",
                        stack: new Error().stack,
                        position: expr.position,
                        value: key
                      };
                    }
                    groups[key].data = fn.append(groups[key].data, item);
                  } else {
                    groups[key] = entry;
                  }
                }
              }
            }
            let generators = await Promise.all(Object.keys(groups).map(async (key2, idx) => {
              let entry2 = groups[key2];
              var context = entry2.data;
              var env2 = environment;
              if (reduce) {
                var tuple = reduceTupleStream(entry2.data);
                context = tuple["@"];
                delete tuple["@"];
                env2 = createFrameFromTuple(environment, tuple);
              }
              environment.isParallelCall = idx > 0;
              return [key2, await evaluate(expr.lhs[entry2.exprIndex][1], context, env2)];
            }));
            for (let generator of generators) {
              var [key, value] = await generator;
              if (typeof value !== "undefined") {
                result[key] = value;
              }
            }
            return result;
          }
          function reduceTupleStream(tupleStream) {
            if (!Array.isArray(tupleStream)) {
              return tupleStream;
            }
            var result = {};
            Object.assign(result, tupleStream[0]);
            for (var ii = 1; ii < tupleStream.length; ii++) {
              for (const prop in tupleStream[ii]) {
                result[prop] = fn.append(result[prop], tupleStream[ii][prop]);
              }
            }
            return result;
          }
          function evaluateRangeExpression(lhs, rhs) {
            var result;
            if (typeof lhs !== "undefined" && !Number.isInteger(lhs)) {
              throw {
                code: "T2003",
                stack: new Error().stack,
                value: lhs
              };
            }
            if (typeof rhs !== "undefined" && !Number.isInteger(rhs)) {
              throw {
                code: "T2004",
                stack: new Error().stack,
                value: rhs
              };
            }
            if (typeof lhs === "undefined" || typeof rhs === "undefined") {
              return result;
            }
            if (lhs > rhs) {
              return result;
            }
            var size = rhs - lhs + 1;
            if (size > 1e7) {
              throw {
                code: "D2014",
                stack: new Error().stack,
                value: size
              };
            }
            result = new Array(size);
            for (var item = lhs, index = 0; item <= rhs; item++, index++) {
              result[index] = item;
            }
            result.sequence = true;
            return result;
          }
          async function evaluateBindExpression(expr, input, environment) {
            var value = await evaluate(expr.rhs, input, environment);
            environment.bind(expr.lhs.value, value);
            return value;
          }
          async function evaluateCondition(expr, input, environment) {
            var result;
            var condition = await evaluate(expr.condition, input, environment);
            if (fn.boolean(condition)) {
              result = await evaluate(expr.then, input, environment);
            } else if (typeof expr.else !== "undefined") {
              result = await evaluate(expr.else, input, environment);
            }
            return result;
          }
          async function evaluateBlock(expr, input, environment) {
            var result;
            var frame = createFrame(environment);
            for (var ii = 0; ii < expr.expressions.length; ii++) {
              result = await evaluate(expr.expressions[ii], input, frame);
            }
            return result;
          }
          function evaluateRegex(expr) {
            var re = new jsonata2.RegexEngine(expr.value);
            var closure = function(str, fromIndex) {
              var result;
              re.lastIndex = fromIndex || 0;
              var match = re.exec(str);
              if (match !== null) {
                result = {
                  match: match[0],
                  start: match.index,
                  end: match.index + match[0].length,
                  groups: []
                };
                if (match.length > 1) {
                  for (var i = 1; i < match.length; i++) {
                    result.groups.push(match[i]);
                  }
                }
                result.next = function() {
                  if (re.lastIndex >= str.length) {
                    return void 0;
                  } else {
                    var next = closure(str, re.lastIndex);
                    if (next && next.match === "") {
                      throw {
                        code: "D1004",
                        stack: new Error().stack,
                        position: expr.position,
                        value: expr.value.source
                      };
                    }
                    return next;
                  }
                };
              }
              return result;
            };
            return closure;
          }
          function evaluateVariable(expr, input, environment) {
            var result;
            if (expr.value === "") {
              result = input && input.outerWrapper ? input[0] : input;
            } else {
              result = environment.lookup(expr.value);
            }
            return result;
          }
          async function evaluateSortExpression(expr, input, environment) {
            var result;
            var lhs = input;
            var isTupleSort = input.tupleStream ? true : false;
            var comparator = async function(a, b) {
              var comp = 0;
              for (var index = 0; comp === 0 && index < expr.terms.length; index++) {
                var term = expr.terms[index];
                var context = a;
                var env = environment;
                if (isTupleSort) {
                  context = a["@"];
                  env = createFrameFromTuple(environment, a);
                }
                var aa = await evaluate(term.expression, context, env);
                context = b;
                env = environment;
                if (isTupleSort) {
                  context = b["@"];
                  env = createFrameFromTuple(environment, b);
                }
                var bb = await evaluate(term.expression, context, env);
                var atype = typeof aa;
                var btype = typeof bb;
                if (atype === "undefined") {
                  comp = btype === "undefined" ? 0 : 1;
                  continue;
                }
                if (btype === "undefined") {
                  comp = -1;
                  continue;
                }
                if (!(atype === "string" || atype === "number") || !(btype === "string" || btype === "number")) {
                  throw {
                    code: "T2008",
                    stack: new Error().stack,
                    position: expr.position,
                    value: !(atype === "string" || atype === "number") ? aa : bb
                  };
                }
                if (atype !== btype) {
                  throw {
                    code: "T2007",
                    stack: new Error().stack,
                    position: expr.position,
                    value: aa,
                    value2: bb
                  };
                }
                if (aa === bb) {
                  continue;
                } else if (aa < bb) {
                  comp = -1;
                } else {
                  comp = 1;
                }
                if (term.descending === true) {
                  comp = -comp;
                }
              }
              return comp === 1;
            };
            var focus = {
              environment,
              input
            };
            result = await fn.sort.apply(focus, [lhs, comparator]);
            return result;
          }
          function evaluateTransformExpression(expr, input, environment) {
            var transformer = async function(obj) {
              if (typeof obj === "undefined") {
                return void 0;
              }
              var cloneFunction = environment.lookup("clone");
              if (!isFunction(cloneFunction)) {
                throw {
                  code: "T2013",
                  stack: new Error().stack,
                  position: expr.position
                };
              }
              var result = await apply(cloneFunction, [obj], null, environment);
              var matches = await evaluate(expr.pattern, result, environment);
              if (typeof matches !== "undefined") {
                if (!Array.isArray(matches)) {
                  matches = [matches];
                }
                for (var ii = 0; ii < matches.length; ii++) {
                  var match = matches[ii];
                  if (match && (match.isPrototypeOf(result) || match instanceof Object.constructor)) {
                    throw {
                      code: "D1010",
                      stack: new Error().stack,
                      position: expr.position
                    };
                  }
                  var update = await evaluate(expr.update, match, environment);
                  var updateType = typeof update;
                  if (updateType !== "undefined") {
                    if (updateType !== "object" || update === null || Array.isArray(update)) {
                      throw {
                        code: "T2011",
                        stack: new Error().stack,
                        position: expr.update.position,
                        value: update
                      };
                    }
                    for (var prop in update) {
                      match[prop] = update[prop];
                    }
                  }
                  if (typeof expr.delete !== "undefined") {
                    var deletions = await evaluate(expr.delete, match, environment);
                    if (typeof deletions !== "undefined") {
                      var val = deletions;
                      if (!Array.isArray(deletions)) {
                        deletions = [deletions];
                      }
                      if (!isArrayOfStrings(deletions)) {
                        throw {
                          code: "T2012",
                          stack: new Error().stack,
                          position: expr.delete.position,
                          value: val
                        };
                      }
                      for (var jj = 0; jj < deletions.length; jj++) {
                        if (typeof match === "object" && match !== null) {
                          delete match[deletions[jj]];
                        }
                      }
                    }
                  }
                }
              }
              return result;
            };
            return defineFunction(transformer, "<(oa):o>");
          }
          var chainAST = parser("function($f, $g) { function($x){ $g($f($x)) } }");
          async function evaluateApplyExpression(expr, input, environment) {
            var result;
            var lhs = await evaluate(expr.lhs, input, environment);
            if (expr.rhs.type === "function") {
              result = await evaluateFunction(expr.rhs, input, environment, { context: lhs });
            } else {
              var func = await evaluate(expr.rhs, input, environment);
              if (!isFunction(func)) {
                throw {
                  code: "T2006",
                  stack: new Error().stack,
                  position: expr.position,
                  value: func
                };
              }
              if (isFunction(lhs)) {
                var chain = await evaluate(chainAST, null, environment);
                result = await apply(chain, [lhs, func], null, environment);
              } else {
                result = await apply(func, [lhs], null, environment);
              }
            }
            return result;
          }
          async function evaluateFunction(expr, input, environment, applyto) {
            var result;
            var proc = await evaluate(expr.procedure, input, environment);
            if (typeof proc === "undefined" && expr.procedure.type === "path" && environment.lookup(expr.procedure.steps[0].value)) {
              throw {
                code: "T1005",
                stack: new Error().stack,
                position: expr.position,
                token: expr.procedure.steps[0].value
              };
            }
            var evaluatedArgs = [];
            if (typeof applyto !== "undefined") {
              evaluatedArgs.push(applyto.context);
            }
            for (var jj = 0; jj < expr.arguments.length; jj++) {
              const arg = await evaluate(expr.arguments[jj], input, environment);
              if (isFunction(arg)) {
                const closure = async function(...params) {
                  return await apply(arg, params, null, environment);
                };
                closure.arity = getFunctionArity(arg);
                evaluatedArgs.push(closure);
              } else {
                evaluatedArgs.push(arg);
              }
            }
            var procName = expr.procedure.type === "path" ? expr.procedure.steps[0].value : expr.procedure.value;
            try {
              if (typeof proc === "object") {
                proc.token = procName;
                proc.position = expr.position;
              }
              result = await apply(proc, evaluatedArgs, input, environment);
            } catch (err) {
              if (!err.position) {
                err.position = expr.position;
              }
              if (!err.token) {
                err.token = procName;
              }
              throw err;
            }
            return result;
          }
          async function apply(proc, args, input, environment) {
            var result;
            result = await applyInner(proc, args, input, environment);
            while (isLambda(result) && result.thunk === true) {
              var next = await evaluate(result.body.procedure, result.input, result.environment);
              if (result.body.procedure.type === "variable") {
                next.token = result.body.procedure.value;
              }
              next.position = result.body.procedure.position;
              var evaluatedArgs = [];
              for (var ii = 0; ii < result.body.arguments.length; ii++) {
                evaluatedArgs.push(await evaluate(result.body.arguments[ii], result.input, result.environment));
              }
              result = await applyInner(next, evaluatedArgs, input, environment);
            }
            return result;
          }
          async function applyInner(proc, args, input, environment) {
            var result;
            try {
              var validatedArgs = args;
              if (proc) {
                validatedArgs = validateArguments(proc.signature, args, input);
              }
              if (isLambda(proc)) {
                result = await applyProcedure(proc, validatedArgs);
              } else if (proc && proc._jsonata_function === true) {
                var focus = {
                  environment,
                  input
                };
                result = proc.implementation.apply(focus, validatedArgs);
                if (isIterable(result)) {
                  result = result.next().value;
                }
                if (isPromise(result)) {
                  result = await result;
                }
              } else if (typeof proc === "function") {
                result = proc.apply(input, validatedArgs);
                if (isPromise(result)) {
                  result = await result;
                }
              } else {
                throw {
                  code: "T1006",
                  stack: new Error().stack
                };
              }
            } catch (err) {
              if (proc) {
                if (typeof err.token == "undefined" && typeof proc.token !== "undefined") {
                  err.token = proc.token;
                }
                err.position = proc.position || err.position;
              }
              throw err;
            }
            return result;
          }
          function evaluateLambda(expr, input, environment) {
            var procedure = {
              _jsonata_lambda: true,
              input,
              environment,
              arguments: expr.arguments,
              signature: expr.signature,
              body: expr.body
            };
            if (expr.thunk === true) {
              procedure.thunk = true;
            }
            procedure.apply = async function(self2, args) {
              return await apply(procedure, args, input, !!self2 ? self2.environment : environment);
            };
            return procedure;
          }
          async function evaluatePartialApplication(expr, input, environment) {
            var result;
            var evaluatedArgs = [];
            for (var ii = 0; ii < expr.arguments.length; ii++) {
              var arg = expr.arguments[ii];
              if (arg.type === "operator" && arg.value === "?") {
                evaluatedArgs.push(arg);
              } else {
                evaluatedArgs.push(await evaluate(arg, input, environment));
              }
            }
            var proc = await evaluate(expr.procedure, input, environment);
            if (typeof proc === "undefined" && expr.procedure.type === "path" && environment.lookup(expr.procedure.steps[0].value)) {
              throw {
                code: "T1007",
                stack: new Error().stack,
                position: expr.position,
                token: expr.procedure.steps[0].value
              };
            }
            if (isLambda(proc)) {
              result = partialApplyProcedure(proc, evaluatedArgs);
            } else if (proc && proc._jsonata_function === true) {
              result = partialApplyNativeFunction(proc.implementation, evaluatedArgs);
            } else if (typeof proc === "function") {
              result = partialApplyNativeFunction(proc, evaluatedArgs);
            } else {
              throw {
                code: "T1008",
                stack: new Error().stack,
                position: expr.position,
                token: expr.procedure.type === "path" ? expr.procedure.steps[0].value : expr.procedure.value
              };
            }
            return result;
          }
          function validateArguments(signature, args, context) {
            if (typeof signature === "undefined") {
              return args;
            }
            var validatedArgs = signature.validate(args, context);
            return validatedArgs;
          }
          async function applyProcedure(proc, args) {
            var result;
            var env = createFrame(proc.environment);
            proc.arguments.forEach(function(param, index) {
              env.bind(param.value, args[index]);
            });
            if (typeof proc.body === "function") {
              result = await applyNativeFunction(proc.body, env);
            } else {
              result = await evaluate(proc.body, proc.input, env);
            }
            return result;
          }
          function partialApplyProcedure(proc, args) {
            var env = createFrame(proc.environment);
            var unboundArgs = [];
            proc.arguments.forEach(function(param, index) {
              var arg = args[index];
              if (arg && arg.type === "operator" && arg.value === "?") {
                unboundArgs.push(param);
              } else {
                env.bind(param.value, arg);
              }
            });
            var procedure = {
              _jsonata_lambda: true,
              input: proc.input,
              environment: env,
              arguments: unboundArgs,
              body: proc.body
            };
            return procedure;
          }
          function partialApplyNativeFunction(native, args) {
            var sigArgs = getNativeFunctionArguments(native);
            sigArgs = sigArgs.map(function(sigArg) {
              return "$" + sigArg.trim();
            });
            var body = "function(" + sigArgs.join(", ") + "){ _ }";
            var bodyAST = parser(body);
            bodyAST.body = native;
            var partial = partialApplyProcedure(bodyAST, args);
            return partial;
          }
          async function applyNativeFunction(proc, env) {
            var sigArgs = getNativeFunctionArguments(proc);
            var args = sigArgs.map(function(sigArg) {
              return env.lookup(sigArg.trim());
            });
            var focus = {
              environment: env
            };
            var result = proc.apply(focus, args);
            if (isPromise(result)) {
              result = await result;
            }
            return result;
          }
          function getNativeFunctionArguments(func) {
            var signature = func.toString();
            var sigParens = /\(([^)]*)\)/.exec(signature)[1];
            var sigArgs = sigParens.split(",");
            return sigArgs;
          }
          function defineFunction(func, signature) {
            var definition = {
              _jsonata_function: true,
              implementation: func
            };
            if (typeof signature !== "undefined") {
              definition.signature = parseSignature(signature);
            }
            return definition;
          }
          async function functionEval(expr, focus) {
            if (typeof expr === "undefined") {
              return void 0;
            }
            var input = this.input;
            if (typeof focus !== "undefined") {
              input = focus;
              if (Array.isArray(input) && !isSequence(input)) {
                input = createSequence(input);
                input.outerWrapper = true;
              }
            }
            try {
              var ast = parser(expr, false);
            } catch (err) {
              populateMessage(err);
              throw {
                stack: new Error().stack,
                code: "D3120",
                value: err.message,
                error: err
              };
            }
            try {
              var result = await evaluate(ast, input, this.environment);
            } catch (err) {
              populateMessage(err);
              throw {
                stack: new Error().stack,
                code: "D3121",
                value: err.message,
                error: err
              };
            }
            return result;
          }
          function functionClone(arg) {
            if (typeof arg === "undefined") {
              return void 0;
            }
            return JSON.parse(fn.string(arg));
          }
          function createFrame(enclosingEnvironment) {
            var bindings = {};
            const newFrame = {
              bind: function(name, value) {
                bindings[name] = value;
              },
              lookup: function(name) {
                var value;
                if (bindings.hasOwnProperty(name)) {
                  value = bindings[name];
                } else if (enclosingEnvironment) {
                  value = enclosingEnvironment.lookup(name);
                }
                return value;
              },
              timestamp: enclosingEnvironment ? enclosingEnvironment.timestamp : null,
              async: enclosingEnvironment ? enclosingEnvironment.async : false,
              isParallelCall: enclosingEnvironment ? enclosingEnvironment.isParallelCall : false,
              global: enclosingEnvironment ? enclosingEnvironment.global : {
                ancestry: [null]
              }
            };
            if (enclosingEnvironment) {
              var framePushCallback = enclosingEnvironment.lookup(Symbol.for("jsonata.__createFrame_push"));
              if (framePushCallback) {
                framePushCallback(enclosingEnvironment, newFrame);
              }
            }
            return newFrame;
          }
          staticFrame.bind("sum", defineFunction(fn.sum, "<a<n>:n>"));
          staticFrame.bind("count", defineFunction(fn.count, "<a:n>"));
          staticFrame.bind("max", defineFunction(fn.max, "<a<n>:n>"));
          staticFrame.bind("min", defineFunction(fn.min, "<a<n>:n>"));
          staticFrame.bind("average", defineFunction(fn.average, "<a<n>:n>"));
          staticFrame.bind("string", defineFunction(fn.string, "<x-b?:s>"));
          staticFrame.bind("substring", defineFunction(fn.substring, "<s-nn?:s>"));
          staticFrame.bind("substringBefore", defineFunction(fn.substringBefore, "<s-s:s>"));
          staticFrame.bind("substringAfter", defineFunction(fn.substringAfter, "<s-s:s>"));
          staticFrame.bind("lowercase", defineFunction(fn.lowercase, "<s-:s>"));
          staticFrame.bind("uppercase", defineFunction(fn.uppercase, "<s-:s>"));
          staticFrame.bind("length", defineFunction(fn.length, "<s-:n>"));
          staticFrame.bind("trim", defineFunction(fn.trim, "<s-:s>"));
          staticFrame.bind("pad", defineFunction(fn.pad, "<s-ns?:s>"));
          staticFrame.bind("match", defineFunction(fn.match, "<s-f<s:o>n?:a<o>>"));
          staticFrame.bind("contains", defineFunction(fn.contains, "<s-(sf):b>"));
          staticFrame.bind("replace", defineFunction(fn.replace, "<s-(sf)(sf)n?:s>"));
          staticFrame.bind("split", defineFunction(fn.split, "<s-(sf)n?:a<s>>"));
          staticFrame.bind("join", defineFunction(fn.join, "<a<s>s?:s>"));
          staticFrame.bind("formatNumber", defineFunction(fn.formatNumber, "<n-so?:s>"));
          staticFrame.bind("formatBase", defineFunction(fn.formatBase, "<n-n?:s>"));
          staticFrame.bind("formatInteger", defineFunction(datetime.formatInteger, "<n-s:s>"));
          staticFrame.bind("parseInteger", defineFunction(datetime.parseInteger, "<s-s:n>"));
          staticFrame.bind("number", defineFunction(fn.number, "<(nsb)-:n>"));
          staticFrame.bind("floor", defineFunction(fn.floor, "<n-:n>"));
          staticFrame.bind("ceil", defineFunction(fn.ceil, "<n-:n>"));
          staticFrame.bind("round", defineFunction(fn.round, "<n-n?:n>"));
          staticFrame.bind("abs", defineFunction(fn.abs, "<n-:n>"));
          staticFrame.bind("sqrt", defineFunction(fn.sqrt, "<n-:n>"));
          staticFrame.bind("power", defineFunction(fn.power, "<n-n:n>"));
          staticFrame.bind("random", defineFunction(fn.random, "<:n>"));
          staticFrame.bind("boolean", defineFunction(fn.boolean, "<x-:b>"));
          staticFrame.bind("not", defineFunction(fn.not, "<x-:b>"));
          staticFrame.bind("map", defineFunction(fn.map, "<af>"));
          staticFrame.bind("zip", defineFunction(fn.zip, "<a+>"));
          staticFrame.bind("filter", defineFunction(fn.filter, "<af>"));
          staticFrame.bind("single", defineFunction(fn.single, "<af?>"));
          staticFrame.bind("reduce", defineFunction(fn.foldLeft, "<afj?:j>"));
          staticFrame.bind("sift", defineFunction(fn.sift, "<o-f?:o>"));
          staticFrame.bind("keys", defineFunction(fn.keys, "<x-:a<s>>"));
          staticFrame.bind("lookup", defineFunction(fn.lookup, "<x-s:x>"));
          staticFrame.bind("append", defineFunction(fn.append, "<xx:a>"));
          staticFrame.bind("exists", defineFunction(fn.exists, "<x:b>"));
          staticFrame.bind("spread", defineFunction(fn.spread, "<x-:a<o>>"));
          staticFrame.bind("merge", defineFunction(fn.merge, "<a<o>:o>"));
          staticFrame.bind("reverse", defineFunction(fn.reverse, "<a:a>"));
          staticFrame.bind("each", defineFunction(fn.each, "<o-f:a>"));
          staticFrame.bind("error", defineFunction(fn.error, "<s?:x>"));
          staticFrame.bind("assert", defineFunction(fn.assert, "<bs?:x>"));
          staticFrame.bind("type", defineFunction(fn.type, "<x:s>"));
          staticFrame.bind("sort", defineFunction(fn.sort, "<af?:a>"));
          staticFrame.bind("shuffle", defineFunction(fn.shuffle, "<a:a>"));
          staticFrame.bind("distinct", defineFunction(fn.distinct, "<x:x>"));
          staticFrame.bind("base64encode", defineFunction(fn.base64encode, "<s-:s>"));
          staticFrame.bind("base64decode", defineFunction(fn.base64decode, "<s-:s>"));
          staticFrame.bind("encodeUrlComponent", defineFunction(fn.encodeUrlComponent, "<s-:s>"));
          staticFrame.bind("encodeUrl", defineFunction(fn.encodeUrl, "<s-:s>"));
          staticFrame.bind("decodeUrlComponent", defineFunction(fn.decodeUrlComponent, "<s-:s>"));
          staticFrame.bind("decodeUrl", defineFunction(fn.decodeUrl, "<s-:s>"));
          staticFrame.bind("eval", defineFunction(functionEval, "<sx?:x>"));
          staticFrame.bind("toMillis", defineFunction(datetime.toMillis, "<s-s?:n>"));
          staticFrame.bind("fromMillis", defineFunction(datetime.fromMillis, "<n-s?s?:s>"));
          staticFrame.bind("clone", defineFunction(functionClone, "<(oa)-:o>"));
          var errorCodes = {
            "S0101": "String literal must be terminated by a matching quote",
            "S0102": "Number out of range: {{token}}",
            "S0103": "Unsupported escape sequence: \\{{token}}",
            "S0104": "The escape sequence \\u must be followed by 4 hex digits",
            "S0105": "Quoted property name must be terminated with a backquote (`)",
            "S0106": "Comment has no closing tag",
            "S0201": "Syntax error: {{token}}",
            "S0202": "Expected {{value}}, got {{token}}",
            "S0203": "Expected {{value}} before end of expression",
            "S0204": "Unknown operator: {{token}}",
            "S0205": "Unexpected token: {{token}}",
            "S0206": "Unknown expression type: {{token}}",
            "S0207": "Unexpected end of expression",
            "S0208": "Parameter {{value}} of function definition must be a variable name (start with $)",
            "S0209": "A predicate cannot follow a grouping expression in a step",
            "S0210": "Each step can only have one grouping expression",
            "S0211": "The symbol {{token}} cannot be used as a unary operator",
            "S0212": "The left side of := must be a variable name (start with $)",
            "S0213": "The literal value {{value}} cannot be used as a step within a path expression",
            "S0214": "The right side of {{token}} must be a variable name (start with $)",
            "S0215": "A context variable binding must precede any predicates on a step",
            "S0216": "A context variable binding must precede the 'order-by' clause on a step",
            "S0217": "The object representing the 'parent' cannot be derived from this expression",
            "S0301": "Empty regular expressions are not allowed",
            "S0302": "No terminating / in regular expression",
            "S0402": "Choice groups containing parameterized types are not supported",
            "S0401": "Type parameters can only be applied to functions and arrays",
            "S0500": "Attempted to evaluate an expression containing syntax error(s)",
            "T0410": "Argument {{index}} of function {{token}} does not match function signature",
            "T0411": "Context value is not a compatible type with argument {{index}} of function {{token}}",
            "T0412": "Argument {{index}} of function {{token}} must be an array of {{type}}",
            "D1001": "Number out of range: {{value}}",
            "D1002": "Cannot negate a non-numeric value: {{value}}",
            "T1003": "Key in object structure must evaluate to a string; got: {{value}}",
            "D1004": "Regular expression matches zero length string",
            "T1005": "Attempted to invoke a non-function. Did you mean ${{{token}}}?",
            "T1006": "Attempted to invoke a non-function",
            "T1007": "Attempted to partially apply a non-function. Did you mean ${{{token}}}?",
            "T1008": "Attempted to partially apply a non-function",
            "D1009": "Multiple key definitions evaluate to same key: {{value}}",
            "D1010": "Attempted to access the Javascript object prototype",
            // Javascript specific 
            "T1010": "The matcher function argument passed to function {{token}} does not return the correct object structure",
            "T2001": "The left side of the {{token}} operator must evaluate to a number",
            "T2002": "The right side of the {{token}} operator must evaluate to a number",
            "T2003": "The left side of the range operator (..) must evaluate to an integer",
            "T2004": "The right side of the range operator (..) must evaluate to an integer",
            "D2005": "The left side of := must be a variable name (start with $)",
            // defunct - replaced by S0212 parser error
            "T2006": "The right side of the function application operator ~> must be a function",
            "T2007": "Type mismatch when comparing values {{value}} and {{value2}} in order-by clause",
            "T2008": "The expressions within an order-by clause must evaluate to numeric or string values",
            "T2009": "The values {{value}} and {{value2}} either side of operator {{token}} must be of the same data type",
            "T2010": "The expressions either side of operator {{token}} must evaluate to numeric or string values",
            "T2011": "The insert/update clause of the transform expression must evaluate to an object: {{value}}",
            "T2012": "The delete clause of the transform expression must evaluate to a string or array of strings: {{value}}",
            "T2013": "The transform expression clones the input object using the $clone() function.  This has been overridden in the current scope by a non-function.",
            "D2014": "The size of the sequence allocated by the range operator (..) must not exceed 1e6.  Attempted to allocate {{value}}.",
            "D3001": "Attempting to invoke string function on Infinity or NaN",
            "D3010": "Second argument of replace function cannot be an empty string",
            "D3011": "Fourth argument of replace function must evaluate to a positive number",
            "D3012": "Attempted to replace a matched string with a non-string value",
            "D3020": "Third argument of split function must evaluate to a positive number",
            "D3030": "Unable to cast value to a number: {{value}}",
            "D3040": "Third argument of match function must evaluate to a positive number",
            "D3050": "The second argument of reduce function must be a function with at least two arguments",
            "D3060": "The sqrt function cannot be applied to a negative number: {{value}}",
            "D3061": "The power function has resulted in a value that cannot be represented as a JSON number: base={{value}}, exponent={{exp}}",
            "D3070": "The single argument form of the sort function can only be applied to an array of strings or an array of numbers.  Use the second argument to specify a comparison function",
            "D3080": "The picture string must only contain a maximum of two sub-pictures",
            "D3081": "The sub-picture must not contain more than one instance of the 'decimal-separator' character",
            "D3082": "The sub-picture must not contain more than one instance of the 'percent' character",
            "D3083": "The sub-picture must not contain more than one instance of the 'per-mille' character",
            "D3084": "The sub-picture must not contain both a 'percent' and a 'per-mille' character",
            "D3085": "The mantissa part of a sub-picture must contain at least one character that is either an 'optional digit character' or a member of the 'decimal digit family'",
            "D3086": "The sub-picture must not contain a passive character that is preceded by an active character and that is followed by another active character",
            "D3087": "The sub-picture must not contain a 'grouping-separator' character that appears adjacent to a 'decimal-separator' character",
            "D3088": "The sub-picture must not contain a 'grouping-separator' at the end of the integer part",
            "D3089": "The sub-picture must not contain two adjacent instances of the 'grouping-separator' character",
            "D3090": "The integer part of the sub-picture must not contain a member of the 'decimal digit family' that is followed by an instance of the 'optional digit character'",
            "D3091": "The fractional part of the sub-picture must not contain an instance of the 'optional digit character' that is followed by a member of the 'decimal digit family'",
            "D3092": "A sub-picture that contains a 'percent' or 'per-mille' character must not contain a character treated as an 'exponent-separator'",
            "D3093": "The exponent part of the sub-picture must comprise only of one or more characters that are members of the 'decimal digit family'",
            "D3100": "The radix of the formatBase function must be between 2 and 36.  It was given {{value}}",
            "D3110": "The argument of the toMillis function must be an ISO 8601 formatted timestamp. Given {{value}}",
            "D3120": "Syntax error in expression passed to function eval: {{value}}",
            "D3121": "Dynamic error evaluating the expression passed to function eval: {{value}}",
            "D3130": "Formatting or parsing an integer as a sequence starting with {{value}} is not supported by this implementation",
            "D3131": "In a decimal digit pattern, all digits must be from the same decimal group",
            "D3132": "Unknown component specifier {{value}} in date/time picture string",
            "D3133": "The 'name' modifier can only be applied to months and days in the date/time picture string, not {{value}}",
            "D3134": "The timezone integer format specifier cannot have more than four digits",
            "D3135": "No matching closing bracket ']' in date/time picture string",
            "D3136": "The date/time picture string is missing specifiers required to parse the timestamp",
            "D3137": "{{{message}}}",
            "D3138": "The $single() function expected exactly 1 matching result.  Instead it matched more.",
            "D3139": "The $single() function expected exactly 1 matching result.  Instead it matched 0.",
            "D3140": "Malformed URL passed to ${{{functionName}}}(): {{value}}",
            "D3141": "{{{message}}}"
          };
          function populateMessage(err) {
            var template = errorCodes[err.code];
            if (typeof template !== "undefined") {
              var message = template.replace(/\{\{\{([^}]+)}}}/g, function() {
                return err[arguments[1]];
              });
              message = message.replace(/\{\{([^}]+)}}/g, function() {
                return JSON.stringify(err[arguments[1]]);
              });
              err.message = message;
            }
          }
          function jsonata2(expr, options) {
            var ast;
            var errors;
            try {
              ast = parser(expr, options && options.recover);
              errors = ast.errors;
              delete ast.errors;
            } catch (err) {
              populateMessage(err);
              throw err;
            }
            var environment = createFrame(staticFrame);
            var timestamp = /* @__PURE__ */ new Date();
            environment.bind("now", defineFunction(function(picture, timezone) {
              return datetime.fromMillis(timestamp.getTime(), picture, timezone);
            }, "<s?s?:s>"));
            environment.bind("millis", defineFunction(function() {
              return timestamp.getTime();
            }, "<:n>"));
            if (options && options.RegexEngine) {
              jsonata2.RegexEngine = options.RegexEngine;
            } else {
              jsonata2.RegexEngine = RegExp;
            }
            return {
              evaluate: async function(input, bindings, callback) {
                if (typeof errors !== "undefined") {
                  var err = {
                    code: "S0500",
                    position: 0
                  };
                  populateMessage(err);
                  throw err;
                }
                if (typeof bindings !== "undefined") {
                  var exec_env;
                  exec_env = createFrame(environment);
                  for (var v in bindings) {
                    exec_env.bind(v, bindings[v]);
                  }
                } else {
                  exec_env = environment;
                }
                exec_env.bind("$", input);
                timestamp = /* @__PURE__ */ new Date();
                exec_env.timestamp = timestamp;
                if (Array.isArray(input) && !isSequence(input)) {
                  input = createSequence(input);
                  input.outerWrapper = true;
                }
                var it;
                try {
                  it = await evaluate(ast, input, exec_env);
                  if (typeof callback === "function") {
                    callback(null, it);
                  }
                  return it;
                } catch (err2) {
                  populateMessage(err2);
                  throw err2;
                }
              },
              assign: function(name, value) {
                environment.bind(name, value);
              },
              registerFunction: function(name, implementation, signature) {
                var func = defineFunction(implementation, signature);
                environment.bind(name, func);
              },
              ast: function() {
                return ast;
              },
              errors: function() {
                return errors;
              }
            };
          }
          jsonata2.parser = parser;
          return jsonata2;
        })();
        module4.exports = jsonata;
      }, { "./datetime": 1, "./functions": 2, "./parser": 4, "./signature": 5, "./utils": 6 }], 4: [function(require2, module4, exports4) {
        var parseSignature = require2("./signature");
        const parser = (() => {
          "use strict";
          var operators = {
            ".": 75,
            "[": 80,
            "]": 0,
            "{": 70,
            "}": 0,
            "(": 80,
            ")": 0,
            ",": 0,
            "@": 80,
            "#": 80,
            ";": 80,
            ":": 80,
            "?": 20,
            "+": 50,
            "-": 50,
            "*": 60,
            "/": 60,
            "%": 60,
            "|": 20,
            "=": 40,
            "<": 40,
            ">": 40,
            "^": 40,
            "**": 60,
            "..": 20,
            ":=": 10,
            "!=": 40,
            "<=": 40,
            ">=": 40,
            "~>": 40,
            "?:": 40,
            "??": 40,
            "and": 30,
            "or": 25,
            "in": 40,
            "&": 50,
            "!": 0,
            // not an operator, but needed as a stop character for name tokens
            "~": 0
            // not an operator, but needed as a stop character for name tokens
          };
          var escapes = {
            // JSON string escape sequences - see json.org
            '"': '"',
            "\\": "\\",
            "/": "/",
            "b": "\b",
            "f": "\f",
            "n": "\n",
            "r": "\r",
            "t": "	"
          };
          var tokenizer = function(path) {
            var position = 0;
            var length = path.length;
            var create = function(type, value) {
              var obj = { type, value, position };
              return obj;
            };
            var scanRegex = function() {
              var start = position;
              var depth = 0;
              var pattern;
              var flags;
              var isClosingSlash = function(position2) {
                if (path.charAt(position2) === "/" && depth === 0) {
                  var backslashCount = 0;
                  while (path.charAt(position2 - (backslashCount + 1)) === "\\") {
                    backslashCount++;
                  }
                  if (backslashCount % 2 === 0) {
                    return true;
                  }
                }
                return false;
              };
              while (position < length) {
                var currentChar = path.charAt(position);
                if (isClosingSlash(position)) {
                  pattern = path.substring(start, position);
                  if (pattern === "") {
                    throw {
                      code: "S0301",
                      stack: new Error().stack,
                      position
                    };
                  }
                  position++;
                  currentChar = path.charAt(position);
                  start = position;
                  while (currentChar === "i" || currentChar === "m") {
                    position++;
                    currentChar = path.charAt(position);
                  }
                  flags = path.substring(start, position) + "g";
                  return new RegExp(pattern, flags);
                }
                if ((currentChar === "(" || currentChar === "[" || currentChar === "{") && path.charAt(position - 1) !== "\\") {
                  depth++;
                }
                if ((currentChar === ")" || currentChar === "]" || currentChar === "}") && path.charAt(position - 1) !== "\\") {
                  depth--;
                }
                position++;
              }
              throw {
                code: "S0302",
                stack: new Error().stack,
                position
              };
            };
            var next = function(prefix) {
              if (position >= length) return null;
              var currentChar = path.charAt(position);
              while (position < length && " 	\n\r\v".indexOf(currentChar) > -1) {
                position++;
                currentChar = path.charAt(position);
              }
              if (currentChar === "/" && path.charAt(position + 1) === "*") {
                var commentStart = position;
                position += 2;
                currentChar = path.charAt(position);
                while (!(currentChar === "*" && path.charAt(position + 1) === "/")) {
                  currentChar = path.charAt(++position);
                  if (position >= length) {
                    throw {
                      code: "S0106",
                      stack: new Error().stack,
                      position: commentStart
                    };
                  }
                }
                position += 2;
                currentChar = path.charAt(position);
                return next(prefix);
              }
              if (prefix !== true && currentChar === "/") {
                position++;
                return create("regex", scanRegex());
              }
              if (currentChar === "." && path.charAt(position + 1) === ".") {
                position += 2;
                return create("operator", "..");
              }
              if (currentChar === ":" && path.charAt(position + 1) === "=") {
                position += 2;
                return create("operator", ":=");
              }
              if (currentChar === "!" && path.charAt(position + 1) === "=") {
                position += 2;
                return create("operator", "!=");
              }
              if (currentChar === ">" && path.charAt(position + 1) === "=") {
                position += 2;
                return create("operator", ">=");
              }
              if (currentChar === "<" && path.charAt(position + 1) === "=") {
                position += 2;
                return create("operator", "<=");
              }
              if (currentChar === "*" && path.charAt(position + 1) === "*") {
                position += 2;
                return create("operator", "**");
              }
              if (currentChar === "~" && path.charAt(position + 1) === ">") {
                position += 2;
                return create("operator", "~>");
              }
              if (currentChar === "?" && path.charAt(position + 1) === ":") {
                position += 2;
                return create("operator", "?:");
              }
              if (currentChar === "?" && path.charAt(position + 1) === "?") {
                position += 2;
                return create("operator", "??");
              }
              if (Object.prototype.hasOwnProperty.call(operators, currentChar)) {
                position++;
                return create("operator", currentChar);
              }
              if (currentChar === '"' || currentChar === "'") {
                var quoteType = currentChar;
                position++;
                var qstr = "";
                while (position < length) {
                  currentChar = path.charAt(position);
                  if (currentChar === "\\") {
                    position++;
                    currentChar = path.charAt(position);
                    if (Object.prototype.hasOwnProperty.call(escapes, currentChar)) {
                      qstr += escapes[currentChar];
                    } else if (currentChar === "u") {
                      var octets = path.substr(position + 1, 4);
                      if (/^[0-9a-fA-F]+$/.test(octets)) {
                        var codepoint = parseInt(octets, 16);
                        qstr += String.fromCharCode(codepoint);
                        position += 4;
                      } else {
                        throw {
                          code: "S0104",
                          stack: new Error().stack,
                          position
                        };
                      }
                    } else {
                      throw {
                        code: "S0103",
                        stack: new Error().stack,
                        position,
                        token: currentChar
                      };
                    }
                  } else if (currentChar === quoteType) {
                    position++;
                    return create("string", qstr);
                  } else {
                    qstr += currentChar;
                  }
                  position++;
                }
                throw {
                  code: "S0101",
                  stack: new Error().stack,
                  position
                };
              }
              var numregex = /^-?(0|([1-9][0-9]*))(\.[0-9]+)?([Ee][-+]?[0-9]+)?/;
              var match = numregex.exec(path.substring(position));
              if (match !== null) {
                var num = parseFloat(match[0]);
                if (!isNaN(num) && isFinite(num)) {
                  position += match[0].length;
                  return create("number", num);
                } else {
                  throw {
                    code: "S0102",
                    stack: new Error().stack,
                    position,
                    token: match[0]
                  };
                }
              }
              var name;
              if (currentChar === "`") {
                position++;
                var end = path.indexOf("`", position);
                if (end !== -1) {
                  name = path.substring(position, end);
                  position = end + 1;
                  return create("name", name);
                }
                position = length;
                throw {
                  code: "S0105",
                  stack: new Error().stack,
                  position
                };
              }
              var i = position;
              var ch;
              for (; ; ) {
                ch = path.charAt(i);
                if (i === length || " 	\n\r\v".indexOf(ch) > -1 || Object.prototype.hasOwnProperty.call(operators, ch)) {
                  if (path.charAt(position) === "$") {
                    name = path.substring(position + 1, i);
                    position = i;
                    return create("variable", name);
                  } else {
                    name = path.substring(position, i);
                    position = i;
                    switch (name) {
                      case "or":
                      case "in":
                      case "and":
                        return create("operator", name);
                      case "true":
                        return create("value", true);
                      case "false":
                        return create("value", false);
                      case "null":
                        return create("value", null);
                      default:
                        if (position === length && name === "") {
                          return null;
                        }
                        return create("name", name);
                    }
                  }
                } else {
                  i++;
                }
              }
            };
            return next;
          };
          var parser2 = function(source, recover) {
            var node;
            var lexer;
            var symbol_table = {};
            var errors = [];
            var remainingTokens = function() {
              var remaining = [];
              if (node.id !== "(end)") {
                remaining.push({ type: node.type, value: node.value, position: node.position });
              }
              var nxt = lexer();
              while (nxt !== null) {
                remaining.push(nxt);
                nxt = lexer();
              }
              return remaining;
            };
            var base_symbol = {
              nud: function() {
                var err2 = {
                  code: "S0211",
                  token: this.value,
                  position: this.position
                };
                if (recover) {
                  err2.remaining = remainingTokens();
                  err2.type = "error";
                  errors.push(err2);
                  return err2;
                } else {
                  err2.stack = new Error().stack;
                  throw err2;
                }
              }
            };
            var symbol = function(id, bp) {
              var s = symbol_table[id];
              bp = bp || 0;
              if (s) {
                if (bp >= s.lbp) {
                  s.lbp = bp;
                }
              } else {
                s = Object.create(base_symbol);
                s.id = s.value = id;
                s.lbp = bp;
                symbol_table[id] = s;
              }
              return s;
            };
            var handleError = function(err2) {
              if (recover) {
                err2.remaining = remainingTokens();
                errors.push(err2);
                var symbol2 = symbol_table["(error)"];
                node = Object.create(symbol2);
                node.error = err2;
                node.type = "(error)";
                return node;
              } else {
                err2.stack = new Error().stack;
                throw err2;
              }
            };
            var advance = function(id, infix2) {
              if (id && node.id !== id) {
                var code;
                if (node.id === "(end)") {
                  code = "S0203";
                } else {
                  code = "S0202";
                }
                var err2 = {
                  code,
                  position: node.position,
                  token: node.value,
                  value: id
                };
                return handleError(err2);
              }
              var next_token = lexer(infix2);
              if (next_token === null) {
                node = symbol_table["(end)"];
                node.position = source.length;
                return node;
              }
              var value = next_token.value;
              var type = next_token.type;
              var symbol2;
              switch (type) {
                case "name":
                case "variable":
                  symbol2 = symbol_table["(name)"];
                  break;
                case "operator":
                  symbol2 = symbol_table[value];
                  if (!symbol2) {
                    return handleError({
                      code: "S0204",
                      stack: new Error().stack,
                      position: next_token.position,
                      token: value
                    });
                  }
                  break;
                case "string":
                case "number":
                case "value":
                  symbol2 = symbol_table["(literal)"];
                  break;
                case "regex":
                  type = "regex";
                  symbol2 = symbol_table["(regex)"];
                  break;
                /* istanbul ignore next */
                default:
                  return handleError({
                    code: "S0205",
                    stack: new Error().stack,
                    position: next_token.position,
                    token: value
                  });
              }
              node = Object.create(symbol2);
              node.value = value;
              node.type = type;
              node.position = next_token.position;
              return node;
            };
            var expression = function(rbp) {
              var left;
              var t = node;
              advance(null, true);
              left = t.nud();
              while (rbp < node.lbp) {
                t = node;
                advance();
                left = t.led(left);
              }
              return left;
            };
            var terminal = function(id) {
              var s = symbol(id, 0);
              s.nud = function() {
                return this;
              };
            };
            var infix = function(id, bp, led) {
              var bindingPower = bp || operators[id];
              var s = symbol(id, bindingPower);
              s.led = led || function(left) {
                this.lhs = left;
                this.rhs = expression(bindingPower);
                this.type = "binary";
                return this;
              };
              return s;
            };
            var infixr = function(id, bp, led) {
              var s = symbol(id, bp);
              s.led = led;
              return s;
            };
            var prefix = function(id, nud) {
              var s = symbol(id);
              s.nud = nud || function() {
                this.expression = expression(70);
                this.type = "unary";
                return this;
              };
              return s;
            };
            terminal("(end)");
            terminal("(name)");
            terminal("(literal)");
            terminal("(regex)");
            symbol(":");
            symbol(";");
            symbol(",");
            symbol(")");
            symbol("]");
            symbol("}");
            symbol("..");
            infix(".");
            infix("+");
            infix("-");
            infix("*");
            infix("/");
            infix("%");
            infix("=");
            infix("<");
            infix(">");
            infix("!=");
            infix("<=");
            infix(">=");
            infix("&");
            infix("and");
            infix("or");
            infix("in");
            terminal("and");
            terminal("or");
            terminal("in");
            prefix("-");
            infix("~>");
            infix("??", operators["??"], function(left) {
              this.type = "condition";
              this.condition = {
                type: "function",
                value: "(",
                procedure: { type: "variable", value: "exists" },
                arguments: [left]
              };
              this.then = left;
              this.else = expression(0);
              return this;
            });
            infixr("(error)", 10, function(left) {
              this.lhs = left;
              this.error = node.error;
              this.remaining = remainingTokens();
              this.type = "error";
              return this;
            });
            prefix("*", function() {
              this.type = "wildcard";
              return this;
            });
            prefix("**", function() {
              this.type = "descendant";
              return this;
            });
            prefix("%", function() {
              this.type = "parent";
              return this;
            });
            infix("(", operators["("], function(left) {
              this.procedure = left;
              this.type = "function";
              this.arguments = [];
              if (node.id !== ")") {
                for (; ; ) {
                  if (node.type === "operator" && node.id === "?") {
                    this.type = "partial";
                    this.arguments.push(node);
                    advance("?");
                  } else {
                    this.arguments.push(expression(0));
                  }
                  if (node.id !== ",") break;
                  advance(",");
                }
              }
              advance(")", true);
              if (left.type === "name" && (left.value === "function" || left.value === "λ")) {
                this.arguments.forEach(function(arg, index) {
                  if (arg.type !== "variable") {
                    return handleError({
                      code: "S0208",
                      stack: new Error().stack,
                      position: arg.position,
                      token: arg.value,
                      value: index + 1
                    });
                  }
                });
                this.type = "lambda";
                if (node.id === "<") {
                  var sigPos = node.position;
                  var depth = 1;
                  var sig = "<";
                  while (depth > 0 && node.id !== "{" && node.id !== "(end)") {
                    var tok = advance();
                    if (tok.id === ">") {
                      depth--;
                    } else if (tok.id === "<") {
                      depth++;
                    }
                    sig += tok.value;
                  }
                  advance(">");
                  try {
                    this.signature = parseSignature(sig);
                  } catch (err2) {
                    err2.position = sigPos + err2.offset;
                    return handleError(err2);
                  }
                }
                advance("{");
                this.body = expression(0);
                advance("}");
              }
              return this;
            });
            prefix("(", function() {
              var expressions = [];
              while (node.id !== ")") {
                expressions.push(expression(0));
                if (node.id !== ";") {
                  break;
                }
                advance(";");
              }
              advance(")", true);
              this.type = "block";
              this.expressions = expressions;
              return this;
            });
            prefix("[", function() {
              var a = [];
              if (node.id !== "]") {
                for (; ; ) {
                  var item = expression(0);
                  if (node.id === "..") {
                    var range = { type: "binary", value: "..", position: node.position, lhs: item };
                    advance("..");
                    range.rhs = expression(0);
                    item = range;
                  }
                  a.push(item);
                  if (node.id !== ",") {
                    break;
                  }
                  advance(",");
                }
              }
              advance("]", true);
              this.expressions = a;
              this.type = "unary";
              return this;
            });
            infix("[", operators["["], function(left) {
              if (node.id === "]") {
                var step = left;
                while (step && step.type === "binary" && step.value === "[") {
                  step = step.lhs;
                }
                step.keepArray = true;
                advance("]");
                return left;
              } else {
                this.lhs = left;
                this.rhs = expression(operators["]"]);
                this.type = "binary";
                advance("]", true);
                return this;
              }
            });
            infix("^", operators["^"], function(left) {
              advance("(");
              var terms = [];
              for (; ; ) {
                var term = {
                  descending: false
                };
                if (node.id === "<") {
                  advance("<");
                } else if (node.id === ">") {
                  term.descending = true;
                  advance(">");
                } else {
                }
                term.expression = expression(0);
                terms.push(term);
                if (node.id !== ",") {
                  break;
                }
                advance(",");
              }
              advance(")");
              this.lhs = left;
              this.rhs = terms;
              this.type = "binary";
              return this;
            });
            var objectParser = function(left) {
              var a = [];
              if (node.id !== "}") {
                for (; ; ) {
                  var n = expression(0);
                  advance(":");
                  var v = expression(0);
                  a.push([n, v]);
                  if (node.id !== ",") {
                    break;
                  }
                  advance(",");
                }
              }
              advance("}", true);
              if (typeof left === "undefined") {
                this.lhs = a;
                this.type = "unary";
              } else {
                this.lhs = left;
                this.rhs = a;
                this.type = "binary";
              }
              return this;
            };
            prefix("{", objectParser);
            infix("{", operators["{"], objectParser);
            infixr(":=", operators[":="], function(left) {
              if (left.type !== "variable") {
                return handleError({
                  code: "S0212",
                  stack: new Error().stack,
                  position: left.position,
                  token: left.value
                });
              }
              this.lhs = left;
              this.rhs = expression(operators[":="] - 1);
              this.type = "binary";
              return this;
            });
            infix("@", operators["@"], function(left) {
              this.lhs = left;
              this.rhs = expression(operators["@"]);
              if (this.rhs.type !== "variable") {
                return handleError({
                  code: "S0214",
                  stack: new Error().stack,
                  position: this.rhs.position,
                  token: "@"
                });
              }
              this.type = "binary";
              return this;
            });
            infix("#", operators["#"], function(left) {
              this.lhs = left;
              this.rhs = expression(operators["#"]);
              if (this.rhs.type !== "variable") {
                return handleError({
                  code: "S0214",
                  stack: new Error().stack,
                  position: this.rhs.position,
                  token: "#"
                });
              }
              this.type = "binary";
              return this;
            });
            infix("?", operators["?"], function(left) {
              this.type = "condition";
              this.condition = left;
              this.then = expression(0);
              if (node.id === ":") {
                advance(":");
                this.else = expression(0);
              }
              return this;
            });
            infix("?:", operators["?:"], function(left) {
              this.type = "condition";
              this.condition = left;
              this.then = left;
              this.else = expression(0);
              return this;
            });
            prefix("|", function() {
              this.type = "transform";
              this.pattern = expression(0);
              advance("|");
              this.update = expression(0);
              if (node.id === ",") {
                advance(",");
                this.delete = expression(0);
              }
              advance("|");
              return this;
            });
            var tailCallOptimize = function(expr2) {
              var result;
              if (expr2.type === "function" && !expr2.predicate) {
                var thunk = { type: "lambda", thunk: true, arguments: [], position: expr2.position };
                thunk.body = expr2;
                result = thunk;
              } else if (expr2.type === "condition") {
                expr2.then = tailCallOptimize(expr2.then);
                if (typeof expr2.else !== "undefined") {
                  expr2.else = tailCallOptimize(expr2.else);
                }
                result = expr2;
              } else if (expr2.type === "block") {
                var length = expr2.expressions.length;
                if (length > 0) {
                  expr2.expressions[length - 1] = tailCallOptimize(expr2.expressions[length - 1]);
                }
                result = expr2;
              } else {
                result = expr2;
              }
              return result;
            };
            var ancestorLabel = 0;
            var ancestorIndex = 0;
            var ancestry = [];
            var seekParent = function(node2, slot) {
              switch (node2.type) {
                case "name":
                case "wildcard":
                  slot.level--;
                  if (slot.level === 0) {
                    if (typeof node2.ancestor === "undefined") {
                      node2.ancestor = slot;
                    } else {
                      ancestry[slot.index].slot.label = node2.ancestor.label;
                      node2.ancestor = slot;
                    }
                    node2.tuple = true;
                  }
                  break;
                case "parent":
                  slot.level++;
                  break;
                case "block":
                  if (node2.expressions.length > 0) {
                    node2.tuple = true;
                    slot = seekParent(node2.expressions[node2.expressions.length - 1], slot);
                  }
                  break;
                case "path":
                  node2.tuple = true;
                  var index = node2.steps.length - 1;
                  slot = seekParent(node2.steps[index--], slot);
                  while (slot.level > 0 && index >= 0) {
                    slot = seekParent(node2.steps[index--], slot);
                  }
                  break;
                default:
                  throw {
                    code: "S0217",
                    token: node2.type,
                    position: node2.position
                  };
              }
              return slot;
            };
            var pushAncestry = function(result, value) {
              if (typeof value.seekingParent !== "undefined" || value.type === "parent") {
                var slots = typeof value.seekingParent !== "undefined" ? value.seekingParent : [];
                if (value.type === "parent") {
                  slots.push(value.slot);
                }
                if (typeof result.seekingParent === "undefined") {
                  result.seekingParent = slots;
                } else {
                  Array.prototype.push.apply(result.seekingParent, slots);
                }
              }
            };
            var resolveAncestry = function(path) {
              var index = path.steps.length - 1;
              var laststep = path.steps[index];
              var slots = typeof laststep.seekingParent !== "undefined" ? laststep.seekingParent : [];
              if (laststep.type === "parent") {
                slots.push(laststep.slot);
              }
              for (var is = 0; is < slots.length; is++) {
                var slot = slots[is];
                index = path.steps.length - 2;
                while (slot.level > 0) {
                  if (index < 0) {
                    if (typeof path.seekingParent === "undefined") {
                      path.seekingParent = [slot];
                    } else {
                      path.seekingParent.push(slot);
                    }
                    break;
                  }
                  var step = path.steps[index--];
                  while (index >= 0 && step.focus && path.steps[index].focus) {
                    step = path.steps[index--];
                  }
                  slot = seekParent(step, slot);
                }
              }
            };
            var processAST = function(expr2) {
              var result;
              switch (expr2.type) {
                case "binary":
                  switch (expr2.value) {
                    case ".":
                      var lstep = processAST(expr2.lhs);
                      if (lstep.type === "path") {
                        result = lstep;
                      } else {
                        result = { type: "path", steps: [lstep] };
                      }
                      if (lstep.type === "parent") {
                        result.seekingParent = [lstep.slot];
                      }
                      var rest = processAST(expr2.rhs);
                      if (rest.type === "function" && rest.procedure.type === "path" && rest.procedure.steps.length === 1 && rest.procedure.steps[0].type === "name" && result.steps[result.steps.length - 1].type === "function") {
                        result.steps[result.steps.length - 1].nextFunction = rest.procedure.steps[0].value;
                      }
                      if (rest.type === "path") {
                        Array.prototype.push.apply(result.steps, rest.steps);
                      } else {
                        if (typeof rest.predicate !== "undefined") {
                          rest.stages = rest.predicate;
                          delete rest.predicate;
                        }
                        result.steps.push(rest);
                      }
                      result.steps.filter(function(step2) {
                        if (step2.type === "number" || step2.type === "value") {
                          throw {
                            code: "S0213",
                            stack: new Error().stack,
                            position: step2.position,
                            value: step2.value
                          };
                        }
                        return step2.type === "string";
                      }).forEach(function(lit) {
                        lit.type = "name";
                      });
                      if (result.steps.filter(function(step2) {
                        return step2.keepArray === true;
                      }).length > 0) {
                        result.keepSingletonArray = true;
                      }
                      var firststep = result.steps[0];
                      if (firststep.type === "unary" && firststep.value === "[") {
                        firststep.consarray = true;
                      }
                      var laststep = result.steps[result.steps.length - 1];
                      if (laststep.type === "unary" && laststep.value === "[") {
                        laststep.consarray = true;
                      }
                      resolveAncestry(result);
                      break;
                    case "[":
                      result = processAST(expr2.lhs);
                      var step = result;
                      var type = "predicate";
                      if (result.type === "path") {
                        step = result.steps[result.steps.length - 1];
                        type = "stages";
                      }
                      if (typeof step.group !== "undefined") {
                        throw {
                          code: "S0209",
                          stack: new Error().stack,
                          position: expr2.position
                        };
                      }
                      if (typeof step[type] === "undefined") {
                        step[type] = [];
                      }
                      var predicate = processAST(expr2.rhs);
                      if (typeof predicate.seekingParent !== "undefined") {
                        predicate.seekingParent.forEach((slot) => {
                          if (slot.level === 1) {
                            seekParent(step, slot);
                          } else {
                            slot.level--;
                          }
                        });
                        pushAncestry(step, predicate);
                      }
                      step[type].push({ type: "filter", expr: predicate, position: expr2.position });
                      break;
                    case "{":
                      result = processAST(expr2.lhs);
                      if (typeof result.group !== "undefined") {
                        throw {
                          code: "S0210",
                          stack: new Error().stack,
                          position: expr2.position
                        };
                      }
                      result.group = {
                        lhs: expr2.rhs.map(function(pair) {
                          return [processAST(pair[0]), processAST(pair[1])];
                        }),
                        position: expr2.position
                      };
                      break;
                    case "^":
                      result = processAST(expr2.lhs);
                      if (result.type !== "path") {
                        result = { type: "path", steps: [result] };
                      }
                      var sortStep = { type: "sort", position: expr2.position };
                      sortStep.terms = expr2.rhs.map(function(terms) {
                        var expression2 = processAST(terms.expression);
                        pushAncestry(sortStep, expression2);
                        return {
                          descending: terms.descending,
                          expression: expression2
                        };
                      });
                      result.steps.push(sortStep);
                      resolveAncestry(result);
                      break;
                    case ":=":
                      result = { type: "bind", value: expr2.value, position: expr2.position };
                      result.lhs = processAST(expr2.lhs);
                      result.rhs = processAST(expr2.rhs);
                      pushAncestry(result, result.rhs);
                      break;
                    case "@":
                      result = processAST(expr2.lhs);
                      step = result;
                      if (result.type === "path") {
                        step = result.steps[result.steps.length - 1];
                      }
                      if (typeof step.stages !== "undefined" || typeof step.predicate !== "undefined") {
                        throw {
                          code: "S0215",
                          stack: new Error().stack,
                          position: expr2.position
                        };
                      }
                      if (step.type === "sort") {
                        throw {
                          code: "S0216",
                          stack: new Error().stack,
                          position: expr2.position
                        };
                      }
                      if (expr2.keepArray) {
                        step.keepArray = true;
                      }
                      step.focus = expr2.rhs.value;
                      step.tuple = true;
                      break;
                    case "#":
                      result = processAST(expr2.lhs);
                      step = result;
                      if (result.type === "path") {
                        step = result.steps[result.steps.length - 1];
                      } else {
                        result = { type: "path", steps: [result] };
                        if (typeof step.predicate !== "undefined") {
                          step.stages = step.predicate;
                          delete step.predicate;
                        }
                      }
                      if (typeof step.stages === "undefined") {
                        step.index = expr2.rhs.value;
                      } else {
                        step.stages.push({ type: "index", value: expr2.rhs.value, position: expr2.position });
                      }
                      step.tuple = true;
                      break;
                    case "~>":
                      result = { type: "apply", value: expr2.value, position: expr2.position };
                      result.lhs = processAST(expr2.lhs);
                      result.rhs = processAST(expr2.rhs);
                      result.keepArray = result.lhs.keepArray || result.rhs.keepArray;
                      break;
                    default:
                      result = { type: expr2.type, value: expr2.value, position: expr2.position };
                      result.lhs = processAST(expr2.lhs);
                      result.rhs = processAST(expr2.rhs);
                      pushAncestry(result, result.lhs);
                      pushAncestry(result, result.rhs);
                  }
                  break;
                case "unary":
                  result = { type: expr2.type, value: expr2.value, position: expr2.position };
                  if (expr2.value === "[") {
                    result.expressions = expr2.expressions.map(function(item) {
                      var value = processAST(item);
                      pushAncestry(result, value);
                      return value;
                    });
                  } else if (expr2.value === "{") {
                    result.lhs = expr2.lhs.map(function(pair) {
                      var key = processAST(pair[0]);
                      pushAncestry(result, key);
                      var value = processAST(pair[1]);
                      pushAncestry(result, value);
                      return [key, value];
                    });
                  } else {
                    result.expression = processAST(expr2.expression);
                    if (expr2.value === "-" && result.expression.type === "number") {
                      result = result.expression;
                      result.value = -result.value;
                    } else {
                      pushAncestry(result, result.expression);
                    }
                  }
                  break;
                case "function":
                case "partial":
                  result = { type: expr2.type, name: expr2.name, value: expr2.value, position: expr2.position };
                  result.arguments = expr2.arguments.map(function(arg) {
                    var argAST = processAST(arg);
                    pushAncestry(result, argAST);
                    return argAST;
                  });
                  result.procedure = processAST(expr2.procedure);
                  break;
                case "lambda":
                  result = {
                    type: expr2.type,
                    arguments: expr2.arguments,
                    signature: expr2.signature,
                    position: expr2.position
                  };
                  var body = processAST(expr2.body);
                  result.body = tailCallOptimize(body);
                  break;
                case "condition":
                  result = { type: expr2.type, position: expr2.position };
                  result.condition = processAST(expr2.condition);
                  pushAncestry(result, result.condition);
                  result.then = processAST(expr2.then);
                  pushAncestry(result, result.then);
                  if (typeof expr2.else !== "undefined") {
                    result.else = processAST(expr2.else);
                    pushAncestry(result, result.else);
                  }
                  break;
                case "transform":
                  result = { type: expr2.type, position: expr2.position };
                  result.pattern = processAST(expr2.pattern);
                  result.update = processAST(expr2.update);
                  if (typeof expr2.delete !== "undefined") {
                    result.delete = processAST(expr2.delete);
                  }
                  break;
                case "block":
                  result = { type: expr2.type, position: expr2.position };
                  result.expressions = expr2.expressions.map(function(item) {
                    var part = processAST(item);
                    pushAncestry(result, part);
                    if (part.consarray || part.type === "path" && part.steps[0].consarray) {
                      result.consarray = true;
                    }
                    return part;
                  });
                  break;
                case "name":
                  result = { type: "path", steps: [expr2] };
                  if (expr2.keepArray) {
                    result.keepSingletonArray = true;
                  }
                  break;
                case "parent":
                  result = { type: "parent", slot: { label: "!" + ancestorLabel++, level: 1, index: ancestorIndex++ } };
                  ancestry.push(result);
                  break;
                case "string":
                case "number":
                case "value":
                case "wildcard":
                case "descendant":
                case "variable":
                case "regex":
                  result = expr2;
                  break;
                case "operator":
                  if (expr2.value === "and" || expr2.value === "or" || expr2.value === "in") {
                    expr2.type = "name";
                    result = processAST(expr2);
                  } else if (expr2.value === "?") {
                    result = expr2;
                  } else {
                    throw {
                      code: "S0201",
                      stack: new Error().stack,
                      position: expr2.position,
                      token: expr2.value
                    };
                  }
                  break;
                case "error":
                  result = expr2;
                  if (expr2.lhs) {
                    result = processAST(expr2.lhs);
                  }
                  break;
                default:
                  var code = "S0206";
                  if (expr2.id === "(end)") {
                    code = "S0207";
                  }
                  var err2 = {
                    code,
                    position: expr2.position,
                    token: expr2.value
                  };
                  if (recover) {
                    errors.push(err2);
                    return { type: "error", error: err2 };
                  } else {
                    err2.stack = new Error().stack;
                    throw err2;
                  }
              }
              if (expr2.keepArray) {
                result.keepArray = true;
              }
              return result;
            };
            lexer = tokenizer(source);
            advance();
            var expr = expression(0);
            if (node.id !== "(end)") {
              var err = {
                code: "S0201",
                position: node.position,
                token: node.value
              };
              handleError(err);
            }
            expr = processAST(expr);
            if (expr.type === "parent" || typeof expr.seekingParent !== "undefined") {
              throw {
                code: "S0217",
                token: expr.type,
                position: expr.position
              };
            }
            if (errors.length > 0) {
              expr.errors = errors;
            }
            return expr;
          };
          return parser2;
        })();
        module4.exports = parser;
      }, { "./signature": 5 }], 5: [function(require2, module4, exports4) {
        var utils = require2("./utils");
        const signature = (() => {
          "use strict";
          var arraySignatureMapping = {
            "a": "arrays",
            "b": "booleans",
            "f": "functions",
            "n": "numbers",
            "o": "objects",
            "s": "strings"
          };
          function parseSignature(signature2) {
            var position = 1;
            var params = [];
            var param = {};
            var prevParam = param;
            while (position < signature2.length) {
              var symbol = signature2.charAt(position);
              if (symbol === ":") {
                break;
              }
              var next = function() {
                params.push(param);
                prevParam = param;
                param = {};
              };
              var findClosingBracket = function(str, start, openSymbol, closeSymbol) {
                var depth = 1;
                var position2 = start;
                while (position2 < str.length) {
                  position2++;
                  symbol = str.charAt(position2);
                  if (symbol === closeSymbol) {
                    depth--;
                    if (depth === 0) {
                      break;
                    }
                  } else if (symbol === openSymbol) {
                    depth++;
                  }
                }
                return position2;
              };
              switch (symbol) {
                case "s":
                // string
                case "n":
                // number
                case "b":
                // boolean
                case "l":
                // not so sure about expecting null?
                case "o":
                  param.regex = "[" + symbol + "m]";
                  param.type = symbol;
                  next();
                  break;
                case "a":
                  param.regex = "[asnblfom]";
                  param.type = symbol;
                  param.array = true;
                  next();
                  break;
                case "f":
                  param.regex = "f";
                  param.type = symbol;
                  next();
                  break;
                case "j":
                  param.regex = "[asnblom]";
                  param.type = symbol;
                  next();
                  break;
                case "x":
                  param.regex = "[asnblfom]";
                  param.type = symbol;
                  next();
                  break;
                case "-":
                  prevParam.context = true;
                  prevParam.contextRegex = new RegExp(prevParam.regex);
                  prevParam.regex += "?";
                  break;
                case "?":
                // optional param
                case "+":
                  prevParam.regex += symbol;
                  break;
                case "(":
                  var endParen = findClosingBracket(signature2, position, "(", ")");
                  var choice = signature2.substring(position + 1, endParen);
                  if (choice.indexOf("<") === -1) {
                    param.regex = "[" + choice + "m]";
                  } else {
                    throw {
                      code: "S0402",
                      stack: new Error().stack,
                      value: choice,
                      offset: position
                    };
                  }
                  param.type = "(" + choice + ")";
                  position = endParen;
                  next();
                  break;
                case "<":
                  if (prevParam.type === "a" || prevParam.type === "f") {
                    var endPos = findClosingBracket(signature2, position, "<", ">");
                    prevParam.subtype = signature2.substring(position + 1, endPos);
                    position = endPos;
                  } else {
                    throw {
                      code: "S0401",
                      stack: new Error().stack,
                      value: prevParam.type,
                      offset: position
                    };
                  }
                  break;
              }
              position++;
            }
            var regexStr = "^" + params.map(function(param2) {
              return "(" + param2.regex + ")";
            }).join("") + "$";
            var regex = new RegExp(regexStr);
            var getSymbol = function(value) {
              var symbol2;
              if (utils.isFunction(value)) {
                symbol2 = "f";
              } else {
                var type = typeof value;
                switch (type) {
                  case "string":
                    symbol2 = "s";
                    break;
                  case "number":
                    symbol2 = "n";
                    break;
                  case "boolean":
                    symbol2 = "b";
                    break;
                  case "object":
                    if (value === null) {
                      symbol2 = "l";
                    } else if (Array.isArray(value)) {
                      symbol2 = "a";
                    } else {
                      symbol2 = "o";
                    }
                    break;
                  case "undefined":
                  default:
                    symbol2 = "m";
                }
              }
              return symbol2;
            };
            var throwValidationError = function(badArgs, badSig) {
              var partialPattern = "^";
              var goodTo = 0;
              for (var index = 0; index < params.length; index++) {
                partialPattern += params[index].regex;
                var match = badSig.match(partialPattern);
                if (match === null) {
                  throw {
                    code: "T0410",
                    stack: new Error().stack,
                    value: badArgs[goodTo],
                    index: goodTo + 1
                  };
                }
                goodTo = match[0].length;
              }
              throw {
                code: "T0410",
                stack: new Error().stack,
                value: badArgs[goodTo],
                index: goodTo + 1
              };
            };
            return {
              definition: signature2,
              validate: function(args, context) {
                var suppliedSig = "";
                args.forEach(function(arg) {
                  suppliedSig += getSymbol(arg);
                });
                var isValid = regex.exec(suppliedSig);
                if (isValid) {
                  var validatedArgs = [];
                  var argIndex = 0;
                  params.forEach(function(param2, index) {
                    var arg = args[argIndex];
                    var match = isValid[index + 1];
                    if (match === "") {
                      if (param2.context && param2.contextRegex) {
                        var contextType = getSymbol(context);
                        if (param2.contextRegex.test(contextType)) {
                          validatedArgs.push(context);
                        } else {
                          throw {
                            code: "T0411",
                            stack: new Error().stack,
                            value: context,
                            index: argIndex + 1
                          };
                        }
                      } else {
                        validatedArgs.push(arg);
                        argIndex++;
                      }
                    } else {
                      match.split("").forEach(function(single) {
                        if (param2.type === "a") {
                          if (single === "m") {
                            arg = void 0;
                          } else {
                            arg = args[argIndex];
                            var arrayOK = true;
                            if (typeof param2.subtype !== "undefined") {
                              if (single !== "a" && match !== param2.subtype) {
                                arrayOK = false;
                              } else if (single === "a") {
                                if (arg.length > 0) {
                                  var itemType = getSymbol(arg[0]);
                                  if (itemType !== param2.subtype.charAt(0)) {
                                    arrayOK = false;
                                  } else {
                                    var differentItems = arg.filter(function(val) {
                                      return getSymbol(val) !== itemType;
                                    });
                                    arrayOK = differentItems.length === 0;
                                  }
                                }
                              }
                            }
                            if (!arrayOK) {
                              throw {
                                code: "T0412",
                                stack: new Error().stack,
                                value: arg,
                                index: argIndex + 1,
                                type: arraySignatureMapping[param2.subtype]
                              };
                            }
                            if (single !== "a") {
                              arg = [arg];
                            }
                          }
                          validatedArgs.push(arg);
                          argIndex++;
                        } else {
                          validatedArgs.push(arg);
                          argIndex++;
                        }
                      });
                    }
                  });
                  return validatedArgs;
                }
                throwValidationError(args, suppliedSig);
              }
            };
          }
          return parseSignature;
        })();
        module4.exports = signature;
      }, { "./utils": 6 }], 6: [function(require2, module4, exports4) {
        const utils = (() => {
          "use strict";
          function isNumeric(n) {
            var isNum = false;
            if (typeof n === "number") {
              isNum = !isNaN(n);
              if (isNum && !isFinite(n)) {
                throw {
                  code: "D1001",
                  value: n,
                  stack: new Error().stack
                };
              }
            }
            return isNum;
          }
          function isArrayOfStrings(arg) {
            var result = false;
            if (Array.isArray(arg)) {
              result = arg.filter(function(item) {
                return typeof item !== "string";
              }).length === 0;
            }
            return result;
          }
          function isArrayOfNumbers(arg) {
            var result = false;
            if (Array.isArray(arg)) {
              result = arg.filter(function(item) {
                return !isNumeric(item);
              }).length === 0;
            }
            return result;
          }
          function createSequence() {
            var sequence = [];
            sequence.sequence = true;
            if (arguments.length === 1) {
              sequence.push(arguments[0]);
            }
            return sequence;
          }
          function isSequence(value) {
            return value.sequence === true && Array.isArray(value);
          }
          function isFunction(arg) {
            return arg && (arg._jsonata_function === true || arg._jsonata_lambda === true) || typeof arg === "function";
          }
          function getFunctionArity(func) {
            var arity = typeof func.arity === "number" ? func.arity : typeof func.implementation === "function" ? func.implementation.length : typeof func.length === "number" ? func.length : func.arguments.length;
            return arity;
          }
          function isLambda(arg) {
            return arg && arg._jsonata_lambda === true;
          }
          var iteratorSymbol = (typeof Symbol === "function" ? Symbol : {}).iterator || "@@iterator";
          function isIterable(arg) {
            return typeof arg === "object" && arg !== null && iteratorSymbol in arg && "next" in arg && typeof arg.next === "function";
          }
          function isDeepEqual(lhs, rhs) {
            if (lhs === rhs) {
              return true;
            }
            if (typeof lhs === "object" && typeof rhs === "object" && lhs !== null && rhs !== null) {
              if (Array.isArray(lhs) && Array.isArray(rhs)) {
                if (lhs.length !== rhs.length) {
                  return false;
                }
                for (var ii = 0; ii < lhs.length; ii++) {
                  if (!isDeepEqual(lhs[ii], rhs[ii])) {
                    return false;
                  }
                }
                return true;
              }
              var lkeys = Object.getOwnPropertyNames(lhs);
              var rkeys = Object.getOwnPropertyNames(rhs);
              if (lkeys.length !== rkeys.length) {
                return false;
              }
              lkeys = lkeys.sort();
              rkeys = rkeys.sort();
              for (ii = 0; ii < lkeys.length; ii++) {
                if (lkeys[ii] !== rkeys[ii]) {
                  return false;
                }
              }
              for (ii = 0; ii < lkeys.length; ii++) {
                var key = lkeys[ii];
                if (!isDeepEqual(lhs[key], rhs[key])) {
                  return false;
                }
              }
              return true;
            }
            return false;
          }
          function isPromise(arg) {
            return typeof arg === "object" && arg !== null && "then" in arg && typeof arg.then === "function";
          }
          function stringToArray(str) {
            var arr = [];
            for (let char of str) {
              arr.push(char);
            }
            return arr;
          }
          return {
            isNumeric,
            isArrayOfStrings,
            isArrayOfNumbers,
            createSequence,
            isSequence,
            isFunction,
            isLambda,
            isIterable,
            getFunctionArity,
            isDeepEqual,
            stringToArray,
            isPromise
          };
        })();
        module4.exports = utils;
      }, {}] }, {}, [3])(3);
    });
  }
});

// node_modules/randombytes/index.js
var require_randombytes = __commonJS({
  "node_modules/randombytes/index.js"(exports2, module2) {
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    module2.exports = require_crypto_browserify().randomBytes;
  }
});

// node_modules/create-hash/index.js
var require_create_hash = __commonJS({
  "node_modules/create-hash/index.js"(exports2, module2) {
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    module2.exports = require_crypto_browserify().createHash;
  }
});

// node_modules/create-hmac/index.js
var require_create_hmac = __commonJS({
  "node_modules/create-hmac/index.js"(exports2, module2) {
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    module2.exports = require_crypto_browserify().createHmac;
  }
});

// node_modules/browserify-sign/browser/algorithms.json
var require_algorithms = __commonJS({
  "node_modules/browserify-sign/browser/algorithms.json"(exports2, module2) {
    module2.exports = {
      sha224WithRSAEncryption: {
        sign: "rsa",
        hash: "sha224",
        id: "302d300d06096086480165030402040500041c"
      },
      "RSA-SHA224": {
        sign: "ecdsa/rsa",
        hash: "sha224",
        id: "302d300d06096086480165030402040500041c"
      },
      sha256WithRSAEncryption: {
        sign: "rsa",
        hash: "sha256",
        id: "3031300d060960864801650304020105000420"
      },
      "RSA-SHA256": {
        sign: "ecdsa/rsa",
        hash: "sha256",
        id: "3031300d060960864801650304020105000420"
      },
      sha384WithRSAEncryption: {
        sign: "rsa",
        hash: "sha384",
        id: "3041300d060960864801650304020205000430"
      },
      "RSA-SHA384": {
        sign: "ecdsa/rsa",
        hash: "sha384",
        id: "3041300d060960864801650304020205000430"
      },
      sha512WithRSAEncryption: {
        sign: "rsa",
        hash: "sha512",
        id: "3051300d060960864801650304020305000440"
      },
      "RSA-SHA512": {
        sign: "ecdsa/rsa",
        hash: "sha512",
        id: "3051300d060960864801650304020305000440"
      },
      "RSA-SHA1": {
        sign: "rsa",
        hash: "sha1",
        id: "3021300906052b0e03021a05000414"
      },
      "ecdsa-with-SHA1": {
        sign: "ecdsa",
        hash: "sha1",
        id: ""
      },
      sha256: {
        sign: "ecdsa",
        hash: "sha256",
        id: ""
      },
      sha224: {
        sign: "ecdsa",
        hash: "sha224",
        id: ""
      },
      sha384: {
        sign: "ecdsa",
        hash: "sha384",
        id: ""
      },
      sha512: {
        sign: "ecdsa",
        hash: "sha512",
        id: ""
      },
      "DSA-SHA": {
        sign: "dsa",
        hash: "sha1",
        id: ""
      },
      "DSA-SHA1": {
        sign: "dsa",
        hash: "sha1",
        id: ""
      },
      DSA: {
        sign: "dsa",
        hash: "sha1",
        id: ""
      },
      "DSA-WITH-SHA224": {
        sign: "dsa",
        hash: "sha224",
        id: ""
      },
      "DSA-SHA224": {
        sign: "dsa",
        hash: "sha224",
        id: ""
      },
      "DSA-WITH-SHA256": {
        sign: "dsa",
        hash: "sha256",
        id: ""
      },
      "DSA-SHA256": {
        sign: "dsa",
        hash: "sha256",
        id: ""
      },
      "DSA-WITH-SHA384": {
        sign: "dsa",
        hash: "sha384",
        id: ""
      },
      "DSA-SHA384": {
        sign: "dsa",
        hash: "sha384",
        id: ""
      },
      "DSA-WITH-SHA512": {
        sign: "dsa",
        hash: "sha512",
        id: ""
      },
      "DSA-SHA512": {
        sign: "dsa",
        hash: "sha512",
        id: ""
      },
      "DSA-RIPEMD160": {
        sign: "dsa",
        hash: "rmd160",
        id: ""
      },
      ripemd160WithRSA: {
        sign: "rsa",
        hash: "rmd160",
        id: "3021300906052b2403020105000414"
      },
      "RSA-RIPEMD160": {
        sign: "rsa",
        hash: "rmd160",
        id: "3021300906052b2403020105000414"
      },
      md5WithRSAEncryption: {
        sign: "rsa",
        hash: "md5",
        id: "3020300c06082a864886f70d020505000410"
      },
      "RSA-MD5": {
        sign: "rsa",
        hash: "md5",
        id: "3020300c06082a864886f70d020505000410"
      }
    };
  }
});

// node_modules/browserify-sign/algos.js
var require_algos = __commonJS({
  "node_modules/browserify-sign/algos.js"(exports2, module2) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    module2.exports = require_algorithms();
  }
});

// node_modules/pbkdf2/lib/precondition.js
var require_precondition = __commonJS({
  "node_modules/pbkdf2/lib/precondition.js"(exports2, module2) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var MAX_ALLOC = Math.pow(2, 30) - 1;
    module2.exports = function(iterations, keylen) {
      if (typeof iterations !== "number") {
        throw new TypeError("Iterations not a number");
      }
      if (iterations < 0) {
        throw new TypeError("Bad iterations");
      }
      if (typeof keylen !== "number") {
        throw new TypeError("Key length not a number");
      }
      if (keylen < 0 || keylen > MAX_ALLOC || keylen !== keylen) {
        throw new TypeError("Bad key length");
      }
    };
  }
});

// node_modules/pbkdf2/lib/default-encoding.js
var require_default_encoding = __commonJS({
  "node_modules/pbkdf2/lib/default-encoding.js"(exports2, module2) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var defaultEncoding;
    if (global.process && global.process.browser) {
      defaultEncoding = "utf-8";
    } else if (global.process && global.process.version) {
      pVersionMajor = parseInt(process.version.split(".")[0].slice(1), 10);
      defaultEncoding = pVersionMajor >= 6 ? "utf-8" : "binary";
    } else {
      defaultEncoding = "utf-8";
    }
    var pVersionMajor;
    module2.exports = defaultEncoding;
  }
});

// node_modules/isarray/index.js
var require_isarray = __commonJS({
  "node_modules/isarray/index.js"(exports2, module2) {
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var toString = {}.toString;
    module2.exports = Array.isArray || function(arr) {
      return toString.call(arr) == "[object Array]";
    };
  }
});

// node_modules/typed-array-buffer/index.js
var require_typed_array_buffer = __commonJS({
  "node_modules/typed-array-buffer/index.js"(exports2, module2) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var $TypeError = require_type();
    var callBound = require_call_bound();
    var $typedArrayBuffer = callBound("TypedArray.prototype.buffer", true);
    var isTypedArray = require_is_typed_array();
    module2.exports = $typedArrayBuffer || function typedArrayBuffer(x) {
      if (!isTypedArray(x)) {
        throw new $TypeError("Not a Typed Array");
      }
      return x.buffer;
    };
  }
});

// node_modules/to-buffer/index.js
var require_to_buffer = __commonJS({
  "node_modules/to-buffer/index.js"(exports2, module2) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var Buffer2 = require_safe_buffer().Buffer;
    var isArray = require_isarray();
    var typedArrayBuffer = require_typed_array_buffer();
    var isView = ArrayBuffer.isView || function isView2(obj) {
      try {
        typedArrayBuffer(obj);
        return true;
      } catch (e) {
        return false;
      }
    };
    var useUint8Array = typeof Uint8Array !== "undefined";
    var useArrayBuffer = typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined";
    var useFromArrayBuffer = useArrayBuffer && (Buffer2.prototype instanceof Uint8Array || Buffer2.TYPED_ARRAY_SUPPORT);
    module2.exports = function toBuffer(data, encoding) {
      if (data instanceof Buffer2) {
        return data;
      }
      if (typeof data === "string") {
        return Buffer2.from(data, encoding);
      }
      if (useArrayBuffer && isView(data)) {
        if (data.byteLength === 0) {
          return Buffer2.alloc(0);
        }
        if (useFromArrayBuffer) {
          var res = Buffer2.from(data.buffer, data.byteOffset, data.byteLength);
          if (res.byteLength === data.byteLength) {
            return res;
          }
        }
        var uint8 = data instanceof Uint8Array ? data : new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
        var result = Buffer2.from(uint8);
        if (result.length === data.byteLength) {
          return result;
        }
      }
      if (useUint8Array && data instanceof Uint8Array) {
        return Buffer2.from(data);
      }
      var isArr = isArray(data);
      if (isArr) {
        for (var i = 0; i < data.length; i += 1) {
          var x = data[i];
          if (typeof x !== "number" || x < 0 || x > 255 || ~~x !== x) {
            throw new RangeError("Array items must be numbers in the range 0-255.");
          }
        }
      }
      if (isArr || Buffer2.isBuffer(data) && data.constructor && typeof data.constructor.isBuffer === "function" && data.constructor.isBuffer(data)) {
        return Buffer2.from(data);
      }
      throw new TypeError('The "data" argument must be a string, an Array, a Buffer, a Uint8Array, or a DataView.');
    };
  }
});

// node_modules/pbkdf2/lib/to-buffer.js
var require_to_buffer2 = __commonJS({
  "node_modules/pbkdf2/lib/to-buffer.js"(exports2, module2) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var Buffer2 = require_safe_buffer().Buffer;
    var toBuffer = require_to_buffer();
    var useUint8Array = typeof Uint8Array !== "undefined";
    var useArrayBuffer = useUint8Array && typeof ArrayBuffer !== "undefined";
    var isView = useArrayBuffer && ArrayBuffer.isView;
    module2.exports = function(thing, encoding, name) {
      if (typeof thing === "string" || Buffer2.isBuffer(thing) || useUint8Array && thing instanceof Uint8Array || isView && isView(thing)) {
        return toBuffer(thing, encoding);
      }
      throw new TypeError(name + " must be a string, a Buffer, a Uint8Array, or a DataView");
    };
  }
});

// node_modules/pbkdf2/node_modules/create-hash/make-hash.js
var require_make_hash = __commonJS({
  "node_modules/pbkdf2/node_modules/create-hash/make-hash.js"(exports2, module2) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var intSize = 4;
    var zeroBuffer = new Buffer(intSize);
    zeroBuffer.fill(0);
    var charSize = 8;
    var hashSize = 16;
    function toArray(buf) {
      if (buf.length % intSize !== 0) {
        var len = buf.length + (intSize - buf.length % intSize);
        buf = Buffer.concat([buf, zeroBuffer], len);
      }
      var arr = new Array(buf.length >>> 2);
      for (var i = 0, j = 0; i < buf.length; i += intSize, j++) {
        arr[j] = buf.readInt32LE(i);
      }
      return arr;
    }
    module2.exports = function hash(buf, fn) {
      var arr = fn(toArray(buf), buf.length * charSize);
      buf = new Buffer(hashSize);
      for (var i = 0; i < arr.length; i++) {
        buf.writeInt32LE(arr[i], i << 2, true);
      }
      return buf;
    };
  }
});

// node_modules/pbkdf2/node_modules/create-hash/md5.js
var require_md5 = __commonJS({
  "node_modules/pbkdf2/node_modules/create-hash/md5.js"(exports2, module2) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var makeHash = require_make_hash();
    function core_md5(x, len) {
      x[len >> 5] |= 128 << len % 32;
      x[(len + 64 >>> 9 << 4) + 14] = len;
      var a = 1732584193;
      var b = -271733879;
      var c = -1732584194;
      var d = 271733878;
      for (var i = 0; i < x.length; i += 16) {
        var olda = a;
        var oldb = b;
        var oldc = c;
        var oldd = d;
        a = md5_ff(a, b, c, d, x[i + 0], 7, -680876936);
        d = md5_ff(d, a, b, c, x[i + 1], 12, -389564586);
        c = md5_ff(c, d, a, b, x[i + 2], 17, 606105819);
        b = md5_ff(b, c, d, a, x[i + 3], 22, -1044525330);
        a = md5_ff(a, b, c, d, x[i + 4], 7, -176418897);
        d = md5_ff(d, a, b, c, x[i + 5], 12, 1200080426);
        c = md5_ff(c, d, a, b, x[i + 6], 17, -1473231341);
        b = md5_ff(b, c, d, a, x[i + 7], 22, -45705983);
        a = md5_ff(a, b, c, d, x[i + 8], 7, 1770035416);
        d = md5_ff(d, a, b, c, x[i + 9], 12, -1958414417);
        c = md5_ff(c, d, a, b, x[i + 10], 17, -42063);
        b = md5_ff(b, c, d, a, x[i + 11], 22, -1990404162);
        a = md5_ff(a, b, c, d, x[i + 12], 7, 1804603682);
        d = md5_ff(d, a, b, c, x[i + 13], 12, -40341101);
        c = md5_ff(c, d, a, b, x[i + 14], 17, -1502002290);
        b = md5_ff(b, c, d, a, x[i + 15], 22, 1236535329);
        a = md5_gg(a, b, c, d, x[i + 1], 5, -165796510);
        d = md5_gg(d, a, b, c, x[i + 6], 9, -1069501632);
        c = md5_gg(c, d, a, b, x[i + 11], 14, 643717713);
        b = md5_gg(b, c, d, a, x[i + 0], 20, -373897302);
        a = md5_gg(a, b, c, d, x[i + 5], 5, -701558691);
        d = md5_gg(d, a, b, c, x[i + 10], 9, 38016083);
        c = md5_gg(c, d, a, b, x[i + 15], 14, -660478335);
        b = md5_gg(b, c, d, a, x[i + 4], 20, -405537848);
        a = md5_gg(a, b, c, d, x[i + 9], 5, 568446438);
        d = md5_gg(d, a, b, c, x[i + 14], 9, -1019803690);
        c = md5_gg(c, d, a, b, x[i + 3], 14, -187363961);
        b = md5_gg(b, c, d, a, x[i + 8], 20, 1163531501);
        a = md5_gg(a, b, c, d, x[i + 13], 5, -1444681467);
        d = md5_gg(d, a, b, c, x[i + 2], 9, -51403784);
        c = md5_gg(c, d, a, b, x[i + 7], 14, 1735328473);
        b = md5_gg(b, c, d, a, x[i + 12], 20, -1926607734);
        a = md5_hh(a, b, c, d, x[i + 5], 4, -378558);
        d = md5_hh(d, a, b, c, x[i + 8], 11, -2022574463);
        c = md5_hh(c, d, a, b, x[i + 11], 16, 1839030562);
        b = md5_hh(b, c, d, a, x[i + 14], 23, -35309556);
        a = md5_hh(a, b, c, d, x[i + 1], 4, -1530992060);
        d = md5_hh(d, a, b, c, x[i + 4], 11, 1272893353);
        c = md5_hh(c, d, a, b, x[i + 7], 16, -155497632);
        b = md5_hh(b, c, d, a, x[i + 10], 23, -1094730640);
        a = md5_hh(a, b, c, d, x[i + 13], 4, 681279174);
        d = md5_hh(d, a, b, c, x[i + 0], 11, -358537222);
        c = md5_hh(c, d, a, b, x[i + 3], 16, -722521979);
        b = md5_hh(b, c, d, a, x[i + 6], 23, 76029189);
        a = md5_hh(a, b, c, d, x[i + 9], 4, -640364487);
        d = md5_hh(d, a, b, c, x[i + 12], 11, -421815835);
        c = md5_hh(c, d, a, b, x[i + 15], 16, 530742520);
        b = md5_hh(b, c, d, a, x[i + 2], 23, -995338651);
        a = md5_ii(a, b, c, d, x[i + 0], 6, -198630844);
        d = md5_ii(d, a, b, c, x[i + 7], 10, 1126891415);
        c = md5_ii(c, d, a, b, x[i + 14], 15, -1416354905);
        b = md5_ii(b, c, d, a, x[i + 5], 21, -57434055);
        a = md5_ii(a, b, c, d, x[i + 12], 6, 1700485571);
        d = md5_ii(d, a, b, c, x[i + 3], 10, -1894986606);
        c = md5_ii(c, d, a, b, x[i + 10], 15, -1051523);
        b = md5_ii(b, c, d, a, x[i + 1], 21, -2054922799);
        a = md5_ii(a, b, c, d, x[i + 8], 6, 1873313359);
        d = md5_ii(d, a, b, c, x[i + 15], 10, -30611744);
        c = md5_ii(c, d, a, b, x[i + 6], 15, -1560198380);
        b = md5_ii(b, c, d, a, x[i + 13], 21, 1309151649);
        a = md5_ii(a, b, c, d, x[i + 4], 6, -145523070);
        d = md5_ii(d, a, b, c, x[i + 11], 10, -1120210379);
        c = md5_ii(c, d, a, b, x[i + 2], 15, 718787259);
        b = md5_ii(b, c, d, a, x[i + 9], 21, -343485551);
        a = safe_add(a, olda);
        b = safe_add(b, oldb);
        c = safe_add(c, oldc);
        d = safe_add(d, oldd);
      }
      return [a, b, c, d];
    }
    function md5_cmn(q, a, b, x, s, t) {
      return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s), b);
    }
    function md5_ff(a, b, c, d, x, s, t) {
      return md5_cmn(b & c | ~b & d, a, b, x, s, t);
    }
    function md5_gg(a, b, c, d, x, s, t) {
      return md5_cmn(b & d | c & ~d, a, b, x, s, t);
    }
    function md5_hh(a, b, c, d, x, s, t) {
      return md5_cmn(b ^ c ^ d, a, b, x, s, t);
    }
    function md5_ii(a, b, c, d, x, s, t) {
      return md5_cmn(c ^ (b | ~d), a, b, x, s, t);
    }
    function safe_add(x, y) {
      var lsw = (x & 65535) + (y & 65535);
      var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
      return msw << 16 | lsw & 65535;
    }
    function bit_rol(num, cnt) {
      return num << cnt | num >>> 32 - cnt;
    }
    module2.exports = function md5(buf) {
      return makeHash(buf, core_md5);
    };
  }
});

// node_modules/pbkdf2/node_modules/hash-base/index.js
var require_hash_base = __commonJS({
  "node_modules/pbkdf2/node_modules/hash-base/index.js"(exports2, module2) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var Transform = require_stream_browserify().Transform;
    var inherits = require_inherits();
    function HashBase(blockSize) {
      Transform.call(this);
      this._block = new Buffer(blockSize);
      this._blockSize = blockSize;
      this._blockOffset = 0;
      this._length = [0, 0, 0, 0];
      this._finalized = false;
    }
    inherits(HashBase, Transform);
    HashBase.prototype._transform = function(chunk, encoding, callback) {
      var error = null;
      try {
        if (encoding !== "buffer") chunk = new Buffer(chunk, encoding);
        this.update(chunk);
      } catch (err) {
        error = err;
      }
      callback(error);
    };
    HashBase.prototype._flush = function(callback) {
      var error = null;
      try {
        this.push(this._digest());
      } catch (err) {
        error = err;
      }
      callback(error);
    };
    HashBase.prototype.update = function(data, encoding) {
      if (!Buffer.isBuffer(data) && typeof data !== "string") throw new TypeError("Data must be a string or a buffer");
      if (this._finalized) throw new Error("Digest already called");
      if (!Buffer.isBuffer(data)) data = new Buffer(data, encoding || "binary");
      var block = this._block;
      var offset = 0;
      while (this._blockOffset + data.length - offset >= this._blockSize) {
        for (var i = this._blockOffset; i < this._blockSize; ) block[i++] = data[offset++];
        this._update();
        this._blockOffset = 0;
      }
      while (offset < data.length) block[this._blockOffset++] = data[offset++];
      for (var j = 0, carry = data.length * 8; carry > 0; ++j) {
        this._length[j] += carry;
        carry = this._length[j] / 4294967296 | 0;
        if (carry > 0) this._length[j] -= 4294967296 * carry;
      }
      return this;
    };
    HashBase.prototype._update = function(data) {
      throw new Error("_update is not implemented");
    };
    HashBase.prototype.digest = function(encoding) {
      if (this._finalized) throw new Error("Digest already called");
      this._finalized = true;
      var digest = this._digest();
      if (encoding !== void 0) digest = digest.toString(encoding);
      return digest;
    };
    HashBase.prototype._digest = function() {
      throw new Error("_digest is not implemented");
    };
    module2.exports = HashBase;
  }
});

// node_modules/pbkdf2/node_modules/ripemd160/index.js
var require_ripemd160 = __commonJS({
  "node_modules/pbkdf2/node_modules/ripemd160/index.js"(exports2, module2) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var inherits = require_inherits();
    var HashBase = require_hash_base();
    function RIPEMD160() {
      HashBase.call(this, 64);
      this._a = 1732584193;
      this._b = 4023233417;
      this._c = 2562383102;
      this._d = 271733878;
      this._e = 3285377520;
    }
    inherits(RIPEMD160, HashBase);
    RIPEMD160.prototype._update = function() {
      var m = new Array(16);
      for (var i = 0; i < 16; ++i) m[i] = this._block.readInt32LE(i * 4);
      var al = this._a;
      var bl = this._b;
      var cl = this._c;
      var dl = this._d;
      var el = this._e;
      al = fn1(al, bl, cl, dl, el, m[0], 0, 11);
      cl = rotl(cl, 10);
      el = fn1(el, al, bl, cl, dl, m[1], 0, 14);
      bl = rotl(bl, 10);
      dl = fn1(dl, el, al, bl, cl, m[2], 0, 15);
      al = rotl(al, 10);
      cl = fn1(cl, dl, el, al, bl, m[3], 0, 12);
      el = rotl(el, 10);
      bl = fn1(bl, cl, dl, el, al, m[4], 0, 5);
      dl = rotl(dl, 10);
      al = fn1(al, bl, cl, dl, el, m[5], 0, 8);
      cl = rotl(cl, 10);
      el = fn1(el, al, bl, cl, dl, m[6], 0, 7);
      bl = rotl(bl, 10);
      dl = fn1(dl, el, al, bl, cl, m[7], 0, 9);
      al = rotl(al, 10);
      cl = fn1(cl, dl, el, al, bl, m[8], 0, 11);
      el = rotl(el, 10);
      bl = fn1(bl, cl, dl, el, al, m[9], 0, 13);
      dl = rotl(dl, 10);
      al = fn1(al, bl, cl, dl, el, m[10], 0, 14);
      cl = rotl(cl, 10);
      el = fn1(el, al, bl, cl, dl, m[11], 0, 15);
      bl = rotl(bl, 10);
      dl = fn1(dl, el, al, bl, cl, m[12], 0, 6);
      al = rotl(al, 10);
      cl = fn1(cl, dl, el, al, bl, m[13], 0, 7);
      el = rotl(el, 10);
      bl = fn1(bl, cl, dl, el, al, m[14], 0, 9);
      dl = rotl(dl, 10);
      al = fn1(al, bl, cl, dl, el, m[15], 0, 8);
      cl = rotl(cl, 10);
      el = fn2(el, al, bl, cl, dl, m[7], 1518500249, 7);
      bl = rotl(bl, 10);
      dl = fn2(dl, el, al, bl, cl, m[4], 1518500249, 6);
      al = rotl(al, 10);
      cl = fn2(cl, dl, el, al, bl, m[13], 1518500249, 8);
      el = rotl(el, 10);
      bl = fn2(bl, cl, dl, el, al, m[1], 1518500249, 13);
      dl = rotl(dl, 10);
      al = fn2(al, bl, cl, dl, el, m[10], 1518500249, 11);
      cl = rotl(cl, 10);
      el = fn2(el, al, bl, cl, dl, m[6], 1518500249, 9);
      bl = rotl(bl, 10);
      dl = fn2(dl, el, al, bl, cl, m[15], 1518500249, 7);
      al = rotl(al, 10);
      cl = fn2(cl, dl, el, al, bl, m[3], 1518500249, 15);
      el = rotl(el, 10);
      bl = fn2(bl, cl, dl, el, al, m[12], 1518500249, 7);
      dl = rotl(dl, 10);
      al = fn2(al, bl, cl, dl, el, m[0], 1518500249, 12);
      cl = rotl(cl, 10);
      el = fn2(el, al, bl, cl, dl, m[9], 1518500249, 15);
      bl = rotl(bl, 10);
      dl = fn2(dl, el, al, bl, cl, m[5], 1518500249, 9);
      al = rotl(al, 10);
      cl = fn2(cl, dl, el, al, bl, m[2], 1518500249, 11);
      el = rotl(el, 10);
      bl = fn2(bl, cl, dl, el, al, m[14], 1518500249, 7);
      dl = rotl(dl, 10);
      al = fn2(al, bl, cl, dl, el, m[11], 1518500249, 13);
      cl = rotl(cl, 10);
      el = fn2(el, al, bl, cl, dl, m[8], 1518500249, 12);
      bl = rotl(bl, 10);
      dl = fn3(dl, el, al, bl, cl, m[3], 1859775393, 11);
      al = rotl(al, 10);
      cl = fn3(cl, dl, el, al, bl, m[10], 1859775393, 13);
      el = rotl(el, 10);
      bl = fn3(bl, cl, dl, el, al, m[14], 1859775393, 6);
      dl = rotl(dl, 10);
      al = fn3(al, bl, cl, dl, el, m[4], 1859775393, 7);
      cl = rotl(cl, 10);
      el = fn3(el, al, bl, cl, dl, m[9], 1859775393, 14);
      bl = rotl(bl, 10);
      dl = fn3(dl, el, al, bl, cl, m[15], 1859775393, 9);
      al = rotl(al, 10);
      cl = fn3(cl, dl, el, al, bl, m[8], 1859775393, 13);
      el = rotl(el, 10);
      bl = fn3(bl, cl, dl, el, al, m[1], 1859775393, 15);
      dl = rotl(dl, 10);
      al = fn3(al, bl, cl, dl, el, m[2], 1859775393, 14);
      cl = rotl(cl, 10);
      el = fn3(el, al, bl, cl, dl, m[7], 1859775393, 8);
      bl = rotl(bl, 10);
      dl = fn3(dl, el, al, bl, cl, m[0], 1859775393, 13);
      al = rotl(al, 10);
      cl = fn3(cl, dl, el, al, bl, m[6], 1859775393, 6);
      el = rotl(el, 10);
      bl = fn3(bl, cl, dl, el, al, m[13], 1859775393, 5);
      dl = rotl(dl, 10);
      al = fn3(al, bl, cl, dl, el, m[11], 1859775393, 12);
      cl = rotl(cl, 10);
      el = fn3(el, al, bl, cl, dl, m[5], 1859775393, 7);
      bl = rotl(bl, 10);
      dl = fn3(dl, el, al, bl, cl, m[12], 1859775393, 5);
      al = rotl(al, 10);
      cl = fn4(cl, dl, el, al, bl, m[1], 2400959708, 11);
      el = rotl(el, 10);
      bl = fn4(bl, cl, dl, el, al, m[9], 2400959708, 12);
      dl = rotl(dl, 10);
      al = fn4(al, bl, cl, dl, el, m[11], 2400959708, 14);
      cl = rotl(cl, 10);
      el = fn4(el, al, bl, cl, dl, m[10], 2400959708, 15);
      bl = rotl(bl, 10);
      dl = fn4(dl, el, al, bl, cl, m[0], 2400959708, 14);
      al = rotl(al, 10);
      cl = fn4(cl, dl, el, al, bl, m[8], 2400959708, 15);
      el = rotl(el, 10);
      bl = fn4(bl, cl, dl, el, al, m[12], 2400959708, 9);
      dl = rotl(dl, 10);
      al = fn4(al, bl, cl, dl, el, m[4], 2400959708, 8);
      cl = rotl(cl, 10);
      el = fn4(el, al, bl, cl, dl, m[13], 2400959708, 9);
      bl = rotl(bl, 10);
      dl = fn4(dl, el, al, bl, cl, m[3], 2400959708, 14);
      al = rotl(al, 10);
      cl = fn4(cl, dl, el, al, bl, m[7], 2400959708, 5);
      el = rotl(el, 10);
      bl = fn4(bl, cl, dl, el, al, m[15], 2400959708, 6);
      dl = rotl(dl, 10);
      al = fn4(al, bl, cl, dl, el, m[14], 2400959708, 8);
      cl = rotl(cl, 10);
      el = fn4(el, al, bl, cl, dl, m[5], 2400959708, 6);
      bl = rotl(bl, 10);
      dl = fn4(dl, el, al, bl, cl, m[6], 2400959708, 5);
      al = rotl(al, 10);
      cl = fn4(cl, dl, el, al, bl, m[2], 2400959708, 12);
      el = rotl(el, 10);
      bl = fn5(bl, cl, dl, el, al, m[4], 2840853838, 9);
      dl = rotl(dl, 10);
      al = fn5(al, bl, cl, dl, el, m[0], 2840853838, 15);
      cl = rotl(cl, 10);
      el = fn5(el, al, bl, cl, dl, m[5], 2840853838, 5);
      bl = rotl(bl, 10);
      dl = fn5(dl, el, al, bl, cl, m[9], 2840853838, 11);
      al = rotl(al, 10);
      cl = fn5(cl, dl, el, al, bl, m[7], 2840853838, 6);
      el = rotl(el, 10);
      bl = fn5(bl, cl, dl, el, al, m[12], 2840853838, 8);
      dl = rotl(dl, 10);
      al = fn5(al, bl, cl, dl, el, m[2], 2840853838, 13);
      cl = rotl(cl, 10);
      el = fn5(el, al, bl, cl, dl, m[10], 2840853838, 12);
      bl = rotl(bl, 10);
      dl = fn5(dl, el, al, bl, cl, m[14], 2840853838, 5);
      al = rotl(al, 10);
      cl = fn5(cl, dl, el, al, bl, m[1], 2840853838, 12);
      el = rotl(el, 10);
      bl = fn5(bl, cl, dl, el, al, m[3], 2840853838, 13);
      dl = rotl(dl, 10);
      al = fn5(al, bl, cl, dl, el, m[8], 2840853838, 14);
      cl = rotl(cl, 10);
      el = fn5(el, al, bl, cl, dl, m[11], 2840853838, 11);
      bl = rotl(bl, 10);
      dl = fn5(dl, el, al, bl, cl, m[6], 2840853838, 8);
      al = rotl(al, 10);
      cl = fn5(cl, dl, el, al, bl, m[15], 2840853838, 5);
      el = rotl(el, 10);
      bl = fn5(bl, cl, dl, el, al, m[13], 2840853838, 6);
      dl = rotl(dl, 10);
      var ar = this._a;
      var br = this._b;
      var cr = this._c;
      var dr = this._d;
      var er = this._e;
      ar = fn5(ar, br, cr, dr, er, m[5], 1352829926, 8);
      cr = rotl(cr, 10);
      er = fn5(er, ar, br, cr, dr, m[14], 1352829926, 9);
      br = rotl(br, 10);
      dr = fn5(dr, er, ar, br, cr, m[7], 1352829926, 9);
      ar = rotl(ar, 10);
      cr = fn5(cr, dr, er, ar, br, m[0], 1352829926, 11);
      er = rotl(er, 10);
      br = fn5(br, cr, dr, er, ar, m[9], 1352829926, 13);
      dr = rotl(dr, 10);
      ar = fn5(ar, br, cr, dr, er, m[2], 1352829926, 15);
      cr = rotl(cr, 10);
      er = fn5(er, ar, br, cr, dr, m[11], 1352829926, 15);
      br = rotl(br, 10);
      dr = fn5(dr, er, ar, br, cr, m[4], 1352829926, 5);
      ar = rotl(ar, 10);
      cr = fn5(cr, dr, er, ar, br, m[13], 1352829926, 7);
      er = rotl(er, 10);
      br = fn5(br, cr, dr, er, ar, m[6], 1352829926, 7);
      dr = rotl(dr, 10);
      ar = fn5(ar, br, cr, dr, er, m[15], 1352829926, 8);
      cr = rotl(cr, 10);
      er = fn5(er, ar, br, cr, dr, m[8], 1352829926, 11);
      br = rotl(br, 10);
      dr = fn5(dr, er, ar, br, cr, m[1], 1352829926, 14);
      ar = rotl(ar, 10);
      cr = fn5(cr, dr, er, ar, br, m[10], 1352829926, 14);
      er = rotl(er, 10);
      br = fn5(br, cr, dr, er, ar, m[3], 1352829926, 12);
      dr = rotl(dr, 10);
      ar = fn5(ar, br, cr, dr, er, m[12], 1352829926, 6);
      cr = rotl(cr, 10);
      er = fn4(er, ar, br, cr, dr, m[6], 1548603684, 9);
      br = rotl(br, 10);
      dr = fn4(dr, er, ar, br, cr, m[11], 1548603684, 13);
      ar = rotl(ar, 10);
      cr = fn4(cr, dr, er, ar, br, m[3], 1548603684, 15);
      er = rotl(er, 10);
      br = fn4(br, cr, dr, er, ar, m[7], 1548603684, 7);
      dr = rotl(dr, 10);
      ar = fn4(ar, br, cr, dr, er, m[0], 1548603684, 12);
      cr = rotl(cr, 10);
      er = fn4(er, ar, br, cr, dr, m[13], 1548603684, 8);
      br = rotl(br, 10);
      dr = fn4(dr, er, ar, br, cr, m[5], 1548603684, 9);
      ar = rotl(ar, 10);
      cr = fn4(cr, dr, er, ar, br, m[10], 1548603684, 11);
      er = rotl(er, 10);
      br = fn4(br, cr, dr, er, ar, m[14], 1548603684, 7);
      dr = rotl(dr, 10);
      ar = fn4(ar, br, cr, dr, er, m[15], 1548603684, 7);
      cr = rotl(cr, 10);
      er = fn4(er, ar, br, cr, dr, m[8], 1548603684, 12);
      br = rotl(br, 10);
      dr = fn4(dr, er, ar, br, cr, m[12], 1548603684, 7);
      ar = rotl(ar, 10);
      cr = fn4(cr, dr, er, ar, br, m[4], 1548603684, 6);
      er = rotl(er, 10);
      br = fn4(br, cr, dr, er, ar, m[9], 1548603684, 15);
      dr = rotl(dr, 10);
      ar = fn4(ar, br, cr, dr, er, m[1], 1548603684, 13);
      cr = rotl(cr, 10);
      er = fn4(er, ar, br, cr, dr, m[2], 1548603684, 11);
      br = rotl(br, 10);
      dr = fn3(dr, er, ar, br, cr, m[15], 1836072691, 9);
      ar = rotl(ar, 10);
      cr = fn3(cr, dr, er, ar, br, m[5], 1836072691, 7);
      er = rotl(er, 10);
      br = fn3(br, cr, dr, er, ar, m[1], 1836072691, 15);
      dr = rotl(dr, 10);
      ar = fn3(ar, br, cr, dr, er, m[3], 1836072691, 11);
      cr = rotl(cr, 10);
      er = fn3(er, ar, br, cr, dr, m[7], 1836072691, 8);
      br = rotl(br, 10);
      dr = fn3(dr, er, ar, br, cr, m[14], 1836072691, 6);
      ar = rotl(ar, 10);
      cr = fn3(cr, dr, er, ar, br, m[6], 1836072691, 6);
      er = rotl(er, 10);
      br = fn3(br, cr, dr, er, ar, m[9], 1836072691, 14);
      dr = rotl(dr, 10);
      ar = fn3(ar, br, cr, dr, er, m[11], 1836072691, 12);
      cr = rotl(cr, 10);
      er = fn3(er, ar, br, cr, dr, m[8], 1836072691, 13);
      br = rotl(br, 10);
      dr = fn3(dr, er, ar, br, cr, m[12], 1836072691, 5);
      ar = rotl(ar, 10);
      cr = fn3(cr, dr, er, ar, br, m[2], 1836072691, 14);
      er = rotl(er, 10);
      br = fn3(br, cr, dr, er, ar, m[10], 1836072691, 13);
      dr = rotl(dr, 10);
      ar = fn3(ar, br, cr, dr, er, m[0], 1836072691, 13);
      cr = rotl(cr, 10);
      er = fn3(er, ar, br, cr, dr, m[4], 1836072691, 7);
      br = rotl(br, 10);
      dr = fn3(dr, er, ar, br, cr, m[13], 1836072691, 5);
      ar = rotl(ar, 10);
      cr = fn2(cr, dr, er, ar, br, m[8], 2053994217, 15);
      er = rotl(er, 10);
      br = fn2(br, cr, dr, er, ar, m[6], 2053994217, 5);
      dr = rotl(dr, 10);
      ar = fn2(ar, br, cr, dr, er, m[4], 2053994217, 8);
      cr = rotl(cr, 10);
      er = fn2(er, ar, br, cr, dr, m[1], 2053994217, 11);
      br = rotl(br, 10);
      dr = fn2(dr, er, ar, br, cr, m[3], 2053994217, 14);
      ar = rotl(ar, 10);
      cr = fn2(cr, dr, er, ar, br, m[11], 2053994217, 14);
      er = rotl(er, 10);
      br = fn2(br, cr, dr, er, ar, m[15], 2053994217, 6);
      dr = rotl(dr, 10);
      ar = fn2(ar, br, cr, dr, er, m[0], 2053994217, 14);
      cr = rotl(cr, 10);
      er = fn2(er, ar, br, cr, dr, m[5], 2053994217, 6);
      br = rotl(br, 10);
      dr = fn2(dr, er, ar, br, cr, m[12], 2053994217, 9);
      ar = rotl(ar, 10);
      cr = fn2(cr, dr, er, ar, br, m[2], 2053994217, 12);
      er = rotl(er, 10);
      br = fn2(br, cr, dr, er, ar, m[13], 2053994217, 9);
      dr = rotl(dr, 10);
      ar = fn2(ar, br, cr, dr, er, m[9], 2053994217, 12);
      cr = rotl(cr, 10);
      er = fn2(er, ar, br, cr, dr, m[7], 2053994217, 5);
      br = rotl(br, 10);
      dr = fn2(dr, er, ar, br, cr, m[10], 2053994217, 15);
      ar = rotl(ar, 10);
      cr = fn2(cr, dr, er, ar, br, m[14], 2053994217, 8);
      er = rotl(er, 10);
      br = fn1(br, cr, dr, er, ar, m[12], 0, 8);
      dr = rotl(dr, 10);
      ar = fn1(ar, br, cr, dr, er, m[15], 0, 5);
      cr = rotl(cr, 10);
      er = fn1(er, ar, br, cr, dr, m[10], 0, 12);
      br = rotl(br, 10);
      dr = fn1(dr, er, ar, br, cr, m[4], 0, 9);
      ar = rotl(ar, 10);
      cr = fn1(cr, dr, er, ar, br, m[1], 0, 12);
      er = rotl(er, 10);
      br = fn1(br, cr, dr, er, ar, m[5], 0, 5);
      dr = rotl(dr, 10);
      ar = fn1(ar, br, cr, dr, er, m[8], 0, 14);
      cr = rotl(cr, 10);
      er = fn1(er, ar, br, cr, dr, m[7], 0, 6);
      br = rotl(br, 10);
      dr = fn1(dr, er, ar, br, cr, m[6], 0, 8);
      ar = rotl(ar, 10);
      cr = fn1(cr, dr, er, ar, br, m[2], 0, 13);
      er = rotl(er, 10);
      br = fn1(br, cr, dr, er, ar, m[13], 0, 6);
      dr = rotl(dr, 10);
      ar = fn1(ar, br, cr, dr, er, m[14], 0, 5);
      cr = rotl(cr, 10);
      er = fn1(er, ar, br, cr, dr, m[0], 0, 15);
      br = rotl(br, 10);
      dr = fn1(dr, er, ar, br, cr, m[3], 0, 13);
      ar = rotl(ar, 10);
      cr = fn1(cr, dr, er, ar, br, m[9], 0, 11);
      er = rotl(er, 10);
      br = fn1(br, cr, dr, er, ar, m[11], 0, 11);
      dr = rotl(dr, 10);
      var t = this._b + cl + dr | 0;
      this._b = this._c + dl + er | 0;
      this._c = this._d + el + ar | 0;
      this._d = this._e + al + br | 0;
      this._e = this._a + bl + cr | 0;
      this._a = t;
    };
    RIPEMD160.prototype._digest = function() {
      this._block[this._blockOffset++] = 128;
      if (this._blockOffset > 56) {
        this._block.fill(0, this._blockOffset, 64);
        this._update();
        this._blockOffset = 0;
      }
      this._block.fill(0, this._blockOffset, 56);
      this._block.writeUInt32LE(this._length[0], 56);
      this._block.writeUInt32LE(this._length[1], 60);
      this._update();
      var buffer = new Buffer(20);
      buffer.writeInt32LE(this._a, 0);
      buffer.writeInt32LE(this._b, 4);
      buffer.writeInt32LE(this._c, 8);
      buffer.writeInt32LE(this._d, 12);
      buffer.writeInt32LE(this._e, 16);
      return buffer;
    };
    function rotl(x, n) {
      return x << n | x >>> 32 - n;
    }
    function fn1(a, b, c, d, e, m, k, s) {
      return rotl(a + (b ^ c ^ d) + m + k | 0, s) + e | 0;
    }
    function fn2(a, b, c, d, e, m, k, s) {
      return rotl(a + (b & c | ~b & d) + m + k | 0, s) + e | 0;
    }
    function fn3(a, b, c, d, e, m, k, s) {
      return rotl(a + ((b | ~c) ^ d) + m + k | 0, s) + e | 0;
    }
    function fn4(a, b, c, d, e, m, k, s) {
      return rotl(a + (b & d | c & ~d) + m + k | 0, s) + e | 0;
    }
    function fn5(a, b, c, d, e, m, k, s) {
      return rotl(a + (b ^ (c | ~d)) + m + k | 0, s) + e | 0;
    }
    module2.exports = RIPEMD160;
  }
});

// node_modules/sha.js/hash.js
var require_hash = __commonJS({
  "node_modules/sha.js/hash.js"(exports2, module2) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var Buffer2 = require_safe_buffer().Buffer;
    var toBuffer = require_to_buffer();
    function Hash(blockSize, finalSize) {
      this._block = Buffer2.alloc(blockSize);
      this._finalSize = finalSize;
      this._blockSize = blockSize;
      this._len = 0;
    }
    Hash.prototype.update = function(data, enc) {
      data = toBuffer(data, enc || "utf8");
      var block = this._block;
      var blockSize = this._blockSize;
      var length = data.length;
      var accum = this._len;
      for (var offset = 0; offset < length; ) {
        var assigned = accum % blockSize;
        var remainder = Math.min(length - offset, blockSize - assigned);
        for (var i = 0; i < remainder; i++) {
          block[assigned + i] = data[offset + i];
        }
        accum += remainder;
        offset += remainder;
        if (accum % blockSize === 0) {
          this._update(block);
        }
      }
      this._len += length;
      return this;
    };
    Hash.prototype.digest = function(enc) {
      var rem = this._len % this._blockSize;
      this._block[rem] = 128;
      this._block.fill(0, rem + 1);
      if (rem >= this._finalSize) {
        this._update(this._block);
        this._block.fill(0);
      }
      var bits = this._len * 8;
      if (bits <= 4294967295) {
        this._block.writeUInt32BE(bits, this._blockSize - 4);
      } else {
        var lowBits = (bits & 4294967295) >>> 0;
        var highBits = (bits - lowBits) / 4294967296;
        this._block.writeUInt32BE(highBits, this._blockSize - 8);
        this._block.writeUInt32BE(lowBits, this._blockSize - 4);
      }
      this._update(this._block);
      var hash = this._hash();
      return enc ? hash.toString(enc) : hash;
    };
    Hash.prototype._update = function() {
      throw new Error("_update must be implemented by subclass");
    };
    module2.exports = Hash;
  }
});

// node_modules/sha.js/sha.js
var require_sha = __commonJS({
  "node_modules/sha.js/sha.js"(exports2, module2) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var inherits = require_inherits();
    var Hash = require_hash();
    var Buffer2 = require_safe_buffer().Buffer;
    var K = [
      1518500249,
      1859775393,
      2400959708 | 0,
      3395469782 | 0
    ];
    var W = new Array(80);
    function Sha() {
      this.init();
      this._w = W;
      Hash.call(this, 64, 56);
    }
    inherits(Sha, Hash);
    Sha.prototype.init = function() {
      this._a = 1732584193;
      this._b = 4023233417;
      this._c = 2562383102;
      this._d = 271733878;
      this._e = 3285377520;
      return this;
    };
    function rotl5(num) {
      return num << 5 | num >>> 27;
    }
    function rotl30(num) {
      return num << 30 | num >>> 2;
    }
    function ft(s, b, c, d) {
      if (s === 0) {
        return b & c | ~b & d;
      }
      if (s === 2) {
        return b & c | b & d | c & d;
      }
      return b ^ c ^ d;
    }
    Sha.prototype._update = function(M) {
      var w = this._w;
      var a = this._a | 0;
      var b = this._b | 0;
      var c = this._c | 0;
      var d = this._d | 0;
      var e = this._e | 0;
      for (var i = 0; i < 16; ++i) {
        w[i] = M.readInt32BE(i * 4);
      }
      for (; i < 80; ++i) {
        w[i] = w[i - 3] ^ w[i - 8] ^ w[i - 14] ^ w[i - 16];
      }
      for (var j = 0; j < 80; ++j) {
        var s = ~~(j / 20);
        var t = rotl5(a) + ft(s, b, c, d) + e + w[j] + K[s] | 0;
        e = d;
        d = c;
        c = rotl30(b);
        b = a;
        a = t;
      }
      this._a = a + this._a | 0;
      this._b = b + this._b | 0;
      this._c = c + this._c | 0;
      this._d = d + this._d | 0;
      this._e = e + this._e | 0;
    };
    Sha.prototype._hash = function() {
      var H = Buffer2.allocUnsafe(20);
      H.writeInt32BE(this._a | 0, 0);
      H.writeInt32BE(this._b | 0, 4);
      H.writeInt32BE(this._c | 0, 8);
      H.writeInt32BE(this._d | 0, 12);
      H.writeInt32BE(this._e | 0, 16);
      return H;
    };
    module2.exports = Sha;
  }
});

// node_modules/sha.js/sha1.js
var require_sha1 = __commonJS({
  "node_modules/sha.js/sha1.js"(exports2, module2) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var inherits = require_inherits();
    var Hash = require_hash();
    var Buffer2 = require_safe_buffer().Buffer;
    var K = [
      1518500249,
      1859775393,
      2400959708 | 0,
      3395469782 | 0
    ];
    var W = new Array(80);
    function Sha1() {
      this.init();
      this._w = W;
      Hash.call(this, 64, 56);
    }
    inherits(Sha1, Hash);
    Sha1.prototype.init = function() {
      this._a = 1732584193;
      this._b = 4023233417;
      this._c = 2562383102;
      this._d = 271733878;
      this._e = 3285377520;
      return this;
    };
    function rotl1(num) {
      return num << 1 | num >>> 31;
    }
    function rotl5(num) {
      return num << 5 | num >>> 27;
    }
    function rotl30(num) {
      return num << 30 | num >>> 2;
    }
    function ft(s, b, c, d) {
      if (s === 0) {
        return b & c | ~b & d;
      }
      if (s === 2) {
        return b & c | b & d | c & d;
      }
      return b ^ c ^ d;
    }
    Sha1.prototype._update = function(M) {
      var w = this._w;
      var a = this._a | 0;
      var b = this._b | 0;
      var c = this._c | 0;
      var d = this._d | 0;
      var e = this._e | 0;
      for (var i = 0; i < 16; ++i) {
        w[i] = M.readInt32BE(i * 4);
      }
      for (; i < 80; ++i) {
        w[i] = rotl1(w[i - 3] ^ w[i - 8] ^ w[i - 14] ^ w[i - 16]);
      }
      for (var j = 0; j < 80; ++j) {
        var s = ~~(j / 20);
        var t = rotl5(a) + ft(s, b, c, d) + e + w[j] + K[s] | 0;
        e = d;
        d = c;
        c = rotl30(b);
        b = a;
        a = t;
      }
      this._a = a + this._a | 0;
      this._b = b + this._b | 0;
      this._c = c + this._c | 0;
      this._d = d + this._d | 0;
      this._e = e + this._e | 0;
    };
    Sha1.prototype._hash = function() {
      var H = Buffer2.allocUnsafe(20);
      H.writeInt32BE(this._a | 0, 0);
      H.writeInt32BE(this._b | 0, 4);
      H.writeInt32BE(this._c | 0, 8);
      H.writeInt32BE(this._d | 0, 12);
      H.writeInt32BE(this._e | 0, 16);
      return H;
    };
    module2.exports = Sha1;
  }
});

// node_modules/sha.js/sha256.js
var require_sha256 = __commonJS({
  "node_modules/sha.js/sha256.js"(exports2, module2) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var inherits = require_inherits();
    var Hash = require_hash();
    var Buffer2 = require_safe_buffer().Buffer;
    var K = [
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ];
    var W = new Array(64);
    function Sha256() {
      this.init();
      this._w = W;
      Hash.call(this, 64, 56);
    }
    inherits(Sha256, Hash);
    Sha256.prototype.init = function() {
      this._a = 1779033703;
      this._b = 3144134277;
      this._c = 1013904242;
      this._d = 2773480762;
      this._e = 1359893119;
      this._f = 2600822924;
      this._g = 528734635;
      this._h = 1541459225;
      return this;
    };
    function ch(x, y, z) {
      return z ^ x & (y ^ z);
    }
    function maj(x, y, z) {
      return x & y | z & (x | y);
    }
    function sigma0(x) {
      return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10);
    }
    function sigma1(x) {
      return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7);
    }
    function gamma0(x) {
      return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ x >>> 3;
    }
    function gamma1(x) {
      return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ x >>> 10;
    }
    Sha256.prototype._update = function(M) {
      var w = this._w;
      var a = this._a | 0;
      var b = this._b | 0;
      var c = this._c | 0;
      var d = this._d | 0;
      var e = this._e | 0;
      var f = this._f | 0;
      var g = this._g | 0;
      var h = this._h | 0;
      for (var i = 0; i < 16; ++i) {
        w[i] = M.readInt32BE(i * 4);
      }
      for (; i < 64; ++i) {
        w[i] = gamma1(w[i - 2]) + w[i - 7] + gamma0(w[i - 15]) + w[i - 16] | 0;
      }
      for (var j = 0; j < 64; ++j) {
        var T1 = h + sigma1(e) + ch(e, f, g) + K[j] + w[j] | 0;
        var T2 = sigma0(a) + maj(a, b, c) | 0;
        h = g;
        g = f;
        f = e;
        e = d + T1 | 0;
        d = c;
        c = b;
        b = a;
        a = T1 + T2 | 0;
      }
      this._a = a + this._a | 0;
      this._b = b + this._b | 0;
      this._c = c + this._c | 0;
      this._d = d + this._d | 0;
      this._e = e + this._e | 0;
      this._f = f + this._f | 0;
      this._g = g + this._g | 0;
      this._h = h + this._h | 0;
    };
    Sha256.prototype._hash = function() {
      var H = Buffer2.allocUnsafe(32);
      H.writeInt32BE(this._a, 0);
      H.writeInt32BE(this._b, 4);
      H.writeInt32BE(this._c, 8);
      H.writeInt32BE(this._d, 12);
      H.writeInt32BE(this._e, 16);
      H.writeInt32BE(this._f, 20);
      H.writeInt32BE(this._g, 24);
      H.writeInt32BE(this._h, 28);
      return H;
    };
    module2.exports = Sha256;
  }
});

// node_modules/sha.js/sha224.js
var require_sha224 = __commonJS({
  "node_modules/sha.js/sha224.js"(exports2, module2) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var inherits = require_inherits();
    var Sha256 = require_sha256();
    var Hash = require_hash();
    var Buffer2 = require_safe_buffer().Buffer;
    var W = new Array(64);
    function Sha224() {
      this.init();
      this._w = W;
      Hash.call(this, 64, 56);
    }
    inherits(Sha224, Sha256);
    Sha224.prototype.init = function() {
      this._a = 3238371032;
      this._b = 914150663;
      this._c = 812702999;
      this._d = 4144912697;
      this._e = 4290775857;
      this._f = 1750603025;
      this._g = 1694076839;
      this._h = 3204075428;
      return this;
    };
    Sha224.prototype._hash = function() {
      var H = Buffer2.allocUnsafe(28);
      H.writeInt32BE(this._a, 0);
      H.writeInt32BE(this._b, 4);
      H.writeInt32BE(this._c, 8);
      H.writeInt32BE(this._d, 12);
      H.writeInt32BE(this._e, 16);
      H.writeInt32BE(this._f, 20);
      H.writeInt32BE(this._g, 24);
      return H;
    };
    module2.exports = Sha224;
  }
});

// node_modules/sha.js/sha512.js
var require_sha512 = __commonJS({
  "node_modules/sha.js/sha512.js"(exports2, module2) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var inherits = require_inherits();
    var Hash = require_hash();
    var Buffer2 = require_safe_buffer().Buffer;
    var K = [
      1116352408,
      3609767458,
      1899447441,
      602891725,
      3049323471,
      3964484399,
      3921009573,
      2173295548,
      961987163,
      4081628472,
      1508970993,
      3053834265,
      2453635748,
      2937671579,
      2870763221,
      3664609560,
      3624381080,
      2734883394,
      310598401,
      1164996542,
      607225278,
      1323610764,
      1426881987,
      3590304994,
      1925078388,
      4068182383,
      2162078206,
      991336113,
      2614888103,
      633803317,
      3248222580,
      3479774868,
      3835390401,
      2666613458,
      4022224774,
      944711139,
      264347078,
      2341262773,
      604807628,
      2007800933,
      770255983,
      1495990901,
      1249150122,
      1856431235,
      1555081692,
      3175218132,
      1996064986,
      2198950837,
      2554220882,
      3999719339,
      2821834349,
      766784016,
      2952996808,
      2566594879,
      3210313671,
      3203337956,
      3336571891,
      1034457026,
      3584528711,
      2466948901,
      113926993,
      3758326383,
      338241895,
      168717936,
      666307205,
      1188179964,
      773529912,
      1546045734,
      1294757372,
      1522805485,
      1396182291,
      2643833823,
      1695183700,
      2343527390,
      1986661051,
      1014477480,
      2177026350,
      1206759142,
      2456956037,
      344077627,
      2730485921,
      1290863460,
      2820302411,
      3158454273,
      3259730800,
      3505952657,
      3345764771,
      106217008,
      3516065817,
      3606008344,
      3600352804,
      1432725776,
      4094571909,
      1467031594,
      275423344,
      851169720,
      430227734,
      3100823752,
      506948616,
      1363258195,
      659060556,
      3750685593,
      883997877,
      3785050280,
      958139571,
      3318307427,
      1322822218,
      3812723403,
      1537002063,
      2003034995,
      1747873779,
      3602036899,
      1955562222,
      1575990012,
      2024104815,
      1125592928,
      2227730452,
      2716904306,
      2361852424,
      442776044,
      2428436474,
      593698344,
      2756734187,
      3733110249,
      3204031479,
      2999351573,
      3329325298,
      3815920427,
      3391569614,
      3928383900,
      3515267271,
      566280711,
      3940187606,
      3454069534,
      4118630271,
      4000239992,
      116418474,
      1914138554,
      174292421,
      2731055270,
      289380356,
      3203993006,
      460393269,
      320620315,
      685471733,
      587496836,
      852142971,
      1086792851,
      1017036298,
      365543100,
      1126000580,
      2618297676,
      1288033470,
      3409855158,
      1501505948,
      4234509866,
      1607167915,
      987167468,
      1816402316,
      1246189591
    ];
    var W = new Array(160);
    function Sha512() {
      this.init();
      this._w = W;
      Hash.call(this, 128, 112);
    }
    inherits(Sha512, Hash);
    Sha512.prototype.init = function() {
      this._ah = 1779033703;
      this._bh = 3144134277;
      this._ch = 1013904242;
      this._dh = 2773480762;
      this._eh = 1359893119;
      this._fh = 2600822924;
      this._gh = 528734635;
      this._hh = 1541459225;
      this._al = 4089235720;
      this._bl = 2227873595;
      this._cl = 4271175723;
      this._dl = 1595750129;
      this._el = 2917565137;
      this._fl = 725511199;
      this._gl = 4215389547;
      this._hl = 327033209;
      return this;
    };
    function Ch(x, y, z) {
      return z ^ x & (y ^ z);
    }
    function maj(x, y, z) {
      return x & y | z & (x | y);
    }
    function sigma0(x, xl) {
      return (x >>> 28 | xl << 4) ^ (xl >>> 2 | x << 30) ^ (xl >>> 7 | x << 25);
    }
    function sigma1(x, xl) {
      return (x >>> 14 | xl << 18) ^ (x >>> 18 | xl << 14) ^ (xl >>> 9 | x << 23);
    }
    function Gamma0(x, xl) {
      return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ x >>> 7;
    }
    function Gamma0l(x, xl) {
      return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7 | xl << 25);
    }
    function Gamma1(x, xl) {
      return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ x >>> 6;
    }
    function Gamma1l(x, xl) {
      return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6 | xl << 26);
    }
    function getCarry(a, b) {
      return a >>> 0 < b >>> 0 ? 1 : 0;
    }
    Sha512.prototype._update = function(M) {
      var w = this._w;
      var ah = this._ah | 0;
      var bh = this._bh | 0;
      var ch = this._ch | 0;
      var dh = this._dh | 0;
      var eh = this._eh | 0;
      var fh = this._fh | 0;
      var gh = this._gh | 0;
      var hh = this._hh | 0;
      var al = this._al | 0;
      var bl = this._bl | 0;
      var cl = this._cl | 0;
      var dl = this._dl | 0;
      var el = this._el | 0;
      var fl = this._fl | 0;
      var gl = this._gl | 0;
      var hl = this._hl | 0;
      for (var i = 0; i < 32; i += 2) {
        w[i] = M.readInt32BE(i * 4);
        w[i + 1] = M.readInt32BE(i * 4 + 4);
      }
      for (; i < 160; i += 2) {
        var xh = w[i - 15 * 2];
        var xl = w[i - 15 * 2 + 1];
        var gamma0 = Gamma0(xh, xl);
        var gamma0l = Gamma0l(xl, xh);
        xh = w[i - 2 * 2];
        xl = w[i - 2 * 2 + 1];
        var gamma1 = Gamma1(xh, xl);
        var gamma1l = Gamma1l(xl, xh);
        var Wi7h = w[i - 7 * 2];
        var Wi7l = w[i - 7 * 2 + 1];
        var Wi16h = w[i - 16 * 2];
        var Wi16l = w[i - 16 * 2 + 1];
        var Wil = gamma0l + Wi7l | 0;
        var Wih = gamma0 + Wi7h + getCarry(Wil, gamma0l) | 0;
        Wil = Wil + gamma1l | 0;
        Wih = Wih + gamma1 + getCarry(Wil, gamma1l) | 0;
        Wil = Wil + Wi16l | 0;
        Wih = Wih + Wi16h + getCarry(Wil, Wi16l) | 0;
        w[i] = Wih;
        w[i + 1] = Wil;
      }
      for (var j = 0; j < 160; j += 2) {
        Wih = w[j];
        Wil = w[j + 1];
        var majh = maj(ah, bh, ch);
        var majl = maj(al, bl, cl);
        var sigma0h = sigma0(ah, al);
        var sigma0l = sigma0(al, ah);
        var sigma1h = sigma1(eh, el);
        var sigma1l = sigma1(el, eh);
        var Kih = K[j];
        var Kil = K[j + 1];
        var chh = Ch(eh, fh, gh);
        var chl = Ch(el, fl, gl);
        var t1l = hl + sigma1l | 0;
        var t1h = hh + sigma1h + getCarry(t1l, hl) | 0;
        t1l = t1l + chl | 0;
        t1h = t1h + chh + getCarry(t1l, chl) | 0;
        t1l = t1l + Kil | 0;
        t1h = t1h + Kih + getCarry(t1l, Kil) | 0;
        t1l = t1l + Wil | 0;
        t1h = t1h + Wih + getCarry(t1l, Wil) | 0;
        var t2l = sigma0l + majl | 0;
        var t2h = sigma0h + majh + getCarry(t2l, sigma0l) | 0;
        hh = gh;
        hl = gl;
        gh = fh;
        gl = fl;
        fh = eh;
        fl = el;
        el = dl + t1l | 0;
        eh = dh + t1h + getCarry(el, dl) | 0;
        dh = ch;
        dl = cl;
        ch = bh;
        cl = bl;
        bh = ah;
        bl = al;
        al = t1l + t2l | 0;
        ah = t1h + t2h + getCarry(al, t1l) | 0;
      }
      this._al = this._al + al | 0;
      this._bl = this._bl + bl | 0;
      this._cl = this._cl + cl | 0;
      this._dl = this._dl + dl | 0;
      this._el = this._el + el | 0;
      this._fl = this._fl + fl | 0;
      this._gl = this._gl + gl | 0;
      this._hl = this._hl + hl | 0;
      this._ah = this._ah + ah + getCarry(this._al, al) | 0;
      this._bh = this._bh + bh + getCarry(this._bl, bl) | 0;
      this._ch = this._ch + ch + getCarry(this._cl, cl) | 0;
      this._dh = this._dh + dh + getCarry(this._dl, dl) | 0;
      this._eh = this._eh + eh + getCarry(this._el, el) | 0;
      this._fh = this._fh + fh + getCarry(this._fl, fl) | 0;
      this._gh = this._gh + gh + getCarry(this._gl, gl) | 0;
      this._hh = this._hh + hh + getCarry(this._hl, hl) | 0;
    };
    Sha512.prototype._hash = function() {
      var H = Buffer2.allocUnsafe(64);
      function writeInt64BE(h, l, offset) {
        H.writeInt32BE(h, offset);
        H.writeInt32BE(l, offset + 4);
      }
      writeInt64BE(this._ah, this._al, 0);
      writeInt64BE(this._bh, this._bl, 8);
      writeInt64BE(this._ch, this._cl, 16);
      writeInt64BE(this._dh, this._dl, 24);
      writeInt64BE(this._eh, this._el, 32);
      writeInt64BE(this._fh, this._fl, 40);
      writeInt64BE(this._gh, this._gl, 48);
      writeInt64BE(this._hh, this._hl, 56);
      return H;
    };
    module2.exports = Sha512;
  }
});

// node_modules/sha.js/sha384.js
var require_sha384 = __commonJS({
  "node_modules/sha.js/sha384.js"(exports2, module2) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var inherits = require_inherits();
    var SHA512 = require_sha512();
    var Hash = require_hash();
    var Buffer2 = require_safe_buffer().Buffer;
    var W = new Array(160);
    function Sha384() {
      this.init();
      this._w = W;
      Hash.call(this, 128, 112);
    }
    inherits(Sha384, SHA512);
    Sha384.prototype.init = function() {
      this._ah = 3418070365;
      this._bh = 1654270250;
      this._ch = 2438529370;
      this._dh = 355462360;
      this._eh = 1731405415;
      this._fh = 2394180231;
      this._gh = 3675008525;
      this._hh = 1203062813;
      this._al = 3238371032;
      this._bl = 914150663;
      this._cl = 812702999;
      this._dl = 4144912697;
      this._el = 4290775857;
      this._fl = 1750603025;
      this._gl = 1694076839;
      this._hl = 3204075428;
      return this;
    };
    Sha384.prototype._hash = function() {
      var H = Buffer2.allocUnsafe(48);
      function writeInt64BE(h, l, offset) {
        H.writeInt32BE(h, offset);
        H.writeInt32BE(l, offset + 4);
      }
      writeInt64BE(this._ah, this._al, 0);
      writeInt64BE(this._bh, this._bl, 8);
      writeInt64BE(this._ch, this._cl, 16);
      writeInt64BE(this._dh, this._dl, 24);
      writeInt64BE(this._eh, this._el, 32);
      writeInt64BE(this._fh, this._fl, 40);
      return H;
    };
    module2.exports = Sha384;
  }
});

// node_modules/sha.js/index.js
var require_sha2 = __commonJS({
  "node_modules/sha.js/index.js"(exports2, module2) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    module2.exports = function SHA(algorithm) {
      var alg = algorithm.toLowerCase();
      var Algorithm = module2.exports[alg];
      if (!Algorithm) {
        throw new Error(alg + " is not supported (we accept pull requests)");
      }
      return new Algorithm();
    };
    module2.exports.sha = require_sha();
    module2.exports.sha1 = require_sha1();
    module2.exports.sha224 = require_sha224();
    module2.exports.sha256 = require_sha256();
    module2.exports.sha384 = require_sha384();
    module2.exports.sha512 = require_sha512();
  }
});

// node_modules/pbkdf2/lib/sync-browser.js
var require_sync_browser = __commonJS({
  "node_modules/pbkdf2/lib/sync-browser.js"(exports2, module2) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var md5 = require_md5();
    var RIPEMD160 = require_ripemd160();
    var sha = require_sha2();
    var Buffer2 = require_safe_buffer().Buffer;
    var checkParameters = require_precondition();
    var defaultEncoding = require_default_encoding();
    var toBuffer = require_to_buffer2();
    var ZEROS = Buffer2.alloc(128);
    var sizes = {
      __proto__: null,
      md5: 16,
      sha1: 20,
      sha224: 28,
      sha256: 32,
      sha384: 48,
      sha512: 64,
      "sha512-256": 32,
      ripemd160: 20,
      rmd160: 20
    };
    var mapping = {
      __proto__: null,
      "sha-1": "sha1",
      "sha-224": "sha224",
      "sha-256": "sha256",
      "sha-384": "sha384",
      "sha-512": "sha512",
      "ripemd-160": "ripemd160"
    };
    function rmd160Func(data) {
      return new RIPEMD160().update(data).digest();
    }
    function getDigest(alg) {
      function shaFunc(data) {
        return sha(alg).update(data).digest();
      }
      if (alg === "rmd160" || alg === "ripemd160") {
        return rmd160Func;
      }
      if (alg === "md5") {
        return md5;
      }
      return shaFunc;
    }
    function Hmac(alg, key, saltLen) {
      var hash = getDigest(alg);
      var blocksize = alg === "sha512" || alg === "sha384" ? 128 : 64;
      if (key.length > blocksize) {
        key = hash(key);
      } else if (key.length < blocksize) {
        key = Buffer2.concat([key, ZEROS], blocksize);
      }
      var ipad = Buffer2.allocUnsafe(blocksize + sizes[alg]);
      var opad = Buffer2.allocUnsafe(blocksize + sizes[alg]);
      for (var i = 0; i < blocksize; i++) {
        ipad[i] = key[i] ^ 54;
        opad[i] = key[i] ^ 92;
      }
      var ipad1 = Buffer2.allocUnsafe(blocksize + saltLen + 4);
      ipad.copy(ipad1, 0, 0, blocksize);
      this.ipad1 = ipad1;
      this.ipad2 = ipad;
      this.opad = opad;
      this.alg = alg;
      this.blocksize = blocksize;
      this.hash = hash;
      this.size = sizes[alg];
    }
    Hmac.prototype.run = function(data, ipad) {
      data.copy(ipad, this.blocksize);
      var h = this.hash(ipad);
      h.copy(this.opad, this.blocksize);
      return this.hash(this.opad);
    };
    function pbkdf2(password, salt, iterations, keylen, digest) {
      checkParameters(iterations, keylen);
      password = toBuffer(password, defaultEncoding, "Password");
      salt = toBuffer(salt, defaultEncoding, "Salt");
      var lowerDigest = (digest || "sha1").toLowerCase();
      var mappedDigest = mapping[lowerDigest] || lowerDigest;
      var size = sizes[mappedDigest];
      if (typeof size !== "number" || !size) {
        throw new TypeError("Digest algorithm not supported: " + digest);
      }
      var hmac = new Hmac(mappedDigest, password, salt.length);
      var DK = Buffer2.allocUnsafe(keylen);
      var block1 = Buffer2.allocUnsafe(salt.length + 4);
      salt.copy(block1, 0, 0, salt.length);
      var destPos = 0;
      var hLen = size;
      var l = Math.ceil(keylen / hLen);
      for (var i = 1; i <= l; i++) {
        block1.writeUInt32BE(i, salt.length);
        var T = hmac.run(block1, hmac.ipad1);
        var U = T;
        for (var j = 1; j < iterations; j++) {
          U = hmac.run(U, hmac.ipad2);
          for (var k = 0; k < hLen; k++) {
            T[k] ^= U[k];
          }
        }
        T.copy(DK, destPos);
        destPos += hLen;
      }
      return DK;
    }
    module2.exports = pbkdf2;
  }
});

// node_modules/pbkdf2/lib/async.js
var require_async = __commonJS({
  "node_modules/pbkdf2/lib/async.js"(exports2, module2) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var Buffer2 = require_safe_buffer().Buffer;
    var checkParameters = require_precondition();
    var defaultEncoding = require_default_encoding();
    var sync = require_sync_browser();
    var toBuffer = require_to_buffer2();
    var ZERO_BUF;
    var subtle = global.crypto && global.crypto.subtle;
    var toBrowser = {
      sha: "SHA-1",
      "sha-1": "SHA-1",
      sha1: "SHA-1",
      sha256: "SHA-256",
      "sha-256": "SHA-256",
      sha384: "SHA-384",
      "sha-384": "SHA-384",
      "sha-512": "SHA-512",
      sha512: "SHA-512"
    };
    var checks = [];
    var nextTick;
    function getNextTick() {
      if (nextTick) {
        return nextTick;
      }
      if (global.process && global.process.nextTick) {
        nextTick = global.process.nextTick;
      } else if (global.queueMicrotask) {
        nextTick = global.queueMicrotask;
      } else if (global.setImmediate) {
        nextTick = global.setImmediate;
      } else {
        nextTick = global.setTimeout;
      }
      return nextTick;
    }
    function browserPbkdf2(password, salt, iterations, length, algo) {
      return subtle.importKey("raw", password, { name: "PBKDF2" }, false, ["deriveBits"]).then(function(key) {
        return subtle.deriveBits({
          name: "PBKDF2",
          salt,
          iterations,
          hash: {
            name: algo
          }
        }, key, length << 3);
      }).then(function(res) {
        return Buffer2.from(res);
      });
    }
    function checkNative(algo) {
      if (global.process && !global.process.browser) {
        return Promise.resolve(false);
      }
      if (!subtle || !subtle.importKey || !subtle.deriveBits) {
        return Promise.resolve(false);
      }
      if (checks[algo] !== void 0) {
        return checks[algo];
      }
      ZERO_BUF = ZERO_BUF || Buffer2.alloc(8);
      var prom = browserPbkdf2(ZERO_BUF, ZERO_BUF, 10, 128, algo).then(
        function() {
          return true;
        },
        function() {
          return false;
        }
      );
      checks[algo] = prom;
      return prom;
    }
    function resolvePromise(promise, callback) {
      promise.then(function(out) {
        getNextTick()(function() {
          callback(null, out);
        });
      }, function(e) {
        getNextTick()(function() {
          callback(e);
        });
      });
    }
    module2.exports = function(password, salt, iterations, keylen, digest, callback) {
      if (typeof digest === "function") {
        callback = digest;
        digest = void 0;
      }
      digest = digest || "sha1";
      var algo = toBrowser[digest.toLowerCase()];
      if (!algo || typeof global.Promise !== "function") {
        getNextTick()(function() {
          var out;
          try {
            out = sync(password, salt, iterations, keylen, digest);
          } catch (e) {
            callback(e);
            return;
          }
          callback(null, out);
        });
        return;
      }
      checkParameters(iterations, keylen);
      password = toBuffer(password, defaultEncoding, "Password");
      salt = toBuffer(salt, defaultEncoding, "Salt");
      if (typeof callback !== "function") {
        throw new Error("No callback provided to pbkdf2");
      }
      resolvePromise(checkNative(algo).then(function(resp) {
        if (resp) {
          return browserPbkdf2(password, salt, iterations, keylen, algo);
        }
        return sync(password, salt, iterations, keylen, digest);
      }), callback);
    };
  }
});

// node_modules/pbkdf2/index.js
var require_pbkdf2 = __commonJS({
  "node_modules/pbkdf2/index.js"(exports2) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var nativeImpl = require_crypto_browserify();
    var checkParameters = require_precondition();
    var defaultEncoding = require_default_encoding();
    var toBuffer = require_to_buffer2();
    function nativePBKDF2(password, salt, iterations, keylen, digest, callback) {
      checkParameters(iterations, keylen);
      password = toBuffer(password, defaultEncoding, "Password");
      salt = toBuffer(salt, defaultEncoding, "Salt");
      if (typeof digest === "function") {
        callback = digest;
        digest = "sha1";
      }
      if (typeof callback !== "function") {
        throw new Error("No callback provided to pbkdf2");
      }
      return nativeImpl.pbkdf2(password, salt, iterations, keylen, digest, callback);
    }
    function nativePBKDF2Sync(password, salt, iterations, keylen, digest) {
      checkParameters(iterations, keylen);
      password = toBuffer(password, defaultEncoding, "Password");
      salt = toBuffer(salt, defaultEncoding, "Salt");
      digest = digest || "sha1";
      return nativeImpl.pbkdf2Sync(password, salt, iterations, keylen, digest);
    }
    if (!nativeImpl.pbkdf2Sync || nativeImpl.pbkdf2Sync.toString().indexOf("keylen, digest") === -1) {
      exports2.pbkdf2Sync = require_sync_browser();
      exports2.pbkdf2 = require_async();
    } else {
      exports2.pbkdf2Sync = nativePBKDF2Sync;
      exports2.pbkdf2 = nativePBKDF2;
    }
  }
});

// node_modules/browserify-cipher/index.js
var require_browserify_cipher = __commonJS({
  "node_modules/browserify-cipher/index.js"(exports2) {
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var crypto2 = require_crypto_browserify();
    exports2.createCipher = exports2.Cipher = crypto2.createCipher;
    exports2.createCipheriv = exports2.Cipheriv = crypto2.createCipheriv;
    exports2.createDecipher = exports2.Decipher = crypto2.createDecipher;
    exports2.createDecipheriv = exports2.Decipheriv = crypto2.createDecipheriv;
    exports2.listCiphers = exports2.getCiphers = crypto2.getCiphers;
  }
});

// node_modules/diffie-hellman/index.js
var require_diffie_hellman = __commonJS({
  "node_modules/diffie-hellman/index.js"(exports2) {
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var crypto2 = require_crypto_browserify();
    exports2.DiffieHellmanGroup = crypto2.DiffieHellmanGroup;
    exports2.createDiffieHellmanGroup = crypto2.createDiffieHellmanGroup;
    exports2.getDiffieHellman = crypto2.getDiffieHellman;
    exports2.createDiffieHellman = crypto2.createDiffieHellman;
    exports2.DiffieHellman = crypto2.DiffieHellman;
  }
});

// node_modules/browserify-sign/index.js
var require_browserify_sign = __commonJS({
  "node_modules/browserify-sign/index.js"(exports2) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var crypto2 = require_crypto_browserify();
    exports2.createSign = crypto2.createSign;
    exports2.Sign = crypto2.Sign;
    exports2.createVerify = crypto2.createVerify;
    exports2.Verify = crypto2.Verify;
  }
});

// node_modules/elliptic/package.json
var require_package = __commonJS({
  "node_modules/elliptic/package.json"(exports2, module2) {
    module2.exports = {
      name: "elliptic",
      version: "6.6.1",
      description: "EC cryptography",
      main: "lib/elliptic.js",
      files: [
        "lib"
      ],
      scripts: {
        lint: "eslint lib test",
        "lint:fix": "npm run lint -- --fix",
        unit: "istanbul test _mocha --reporter=spec test/index.js",
        test: "npm run lint && npm run unit",
        version: "grunt dist && git add dist/"
      },
      repository: {
        type: "git",
        url: "git@github.com:indutny/elliptic"
      },
      keywords: [
        "EC",
        "Elliptic",
        "curve",
        "Cryptography"
      ],
      author: "Fedor Indutny <fedor@indutny.com>",
      license: "MIT",
      bugs: {
        url: "https://github.com/indutny/elliptic/issues"
      },
      homepage: "https://github.com/indutny/elliptic",
      devDependencies: {
        brfs: "^2.0.2",
        coveralls: "^3.1.0",
        eslint: "^7.6.0",
        grunt: "^1.2.1",
        "grunt-browserify": "^5.3.0",
        "grunt-cli": "^1.3.2",
        "grunt-contrib-connect": "^3.0.0",
        "grunt-contrib-copy": "^1.0.0",
        "grunt-contrib-uglify": "^5.0.0",
        "grunt-mocha-istanbul": "^5.0.2",
        "grunt-saucelabs": "^9.0.1",
        istanbul: "^0.4.5",
        mocha: "^8.0.1"
      },
      dependencies: {
        "bn.js": "^4.11.9",
        brorand: "^1.1.0",
        "hash.js": "^1.0.0",
        "hmac-drbg": "^1.0.1",
        inherits: "^2.0.4",
        "minimalistic-assert": "^1.0.1",
        "minimalistic-crypto-utils": "^1.0.1"
      }
    };
  }
});

// node_modules/elliptic/node_modules/bn.js/lib/bn.js
var require_bn = __commonJS({
  "node_modules/elliptic/node_modules/bn.js/lib/bn.js"(exports2, module2) {
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    (function(module3, exports3) {
      "use strict";
      function assert(val, msg) {
        if (!val) throw new Error(msg || "Assertion failed");
      }
      function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN(number, base, endian) {
        if (BN.isBN(number)) {
          return number;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number !== null) {
          if (base === "le" || base === "be") {
            endian = base;
            base = 10;
          }
          this._init(number || 0, base || 10, endian || "be");
        }
      }
      if (typeof module3 === "object") {
        module3.exports = BN;
      } else {
        exports3.BN = BN;
      }
      BN.BN = BN;
      BN.wordSize = 26;
      var Buffer2;
      try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
          Buffer2 = window.Buffer;
        } else {
          Buffer2 = (init_dist(), __toCommonJS(dist_exports)).Buffer;
        }
      } catch (e) {
      }
      BN.isBN = function isBN(num) {
        if (num instanceof BN) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
      };
      BN.max = function max(left, right) {
        if (left.cmp(right) > 0) return left;
        return right;
      };
      BN.min = function min(left, right) {
        if (left.cmp(right) < 0) return left;
        return right;
      };
      BN.prototype._init = function init(number, base, endian) {
        if (typeof number === "number") {
          return this._initNumber(number, base, endian);
        }
        if (typeof number === "object") {
          return this._initArray(number, base, endian);
        }
        if (base === "hex") {
          base = 16;
        }
        assert(base === (base | 0) && base >= 2 && base <= 36);
        number = number.toString().replace(/\s+/g, "");
        var start = 0;
        if (number[0] === "-") {
          start++;
          this.negative = 1;
        }
        if (start < number.length) {
          if (base === 16) {
            this._parseHex(number, start, endian);
          } else {
            this._parseBase(number, base, start);
            if (endian === "le") {
              this._initArray(this.toArray(), base, endian);
            }
          }
        }
      };
      BN.prototype._initNumber = function _initNumber(number, base, endian) {
        if (number < 0) {
          this.negative = 1;
          number = -number;
        }
        if (number < 67108864) {
          this.words = [number & 67108863];
          this.length = 1;
        } else if (number < 4503599627370496) {
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert(number < 9007199254740992);
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le") return;
        this._initArray(this.toArray(), base, endian);
      };
      BN.prototype._initArray = function _initArray(number, base, endian) {
        assert(typeof number.length === "number");
        if (number.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var j, w;
        var off = 0;
        if (endian === "be") {
          for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
            w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        } else if (endian === "le") {
          for (i = 0, j = 0; i < number.length; i += 3) {
            w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        }
        return this.strip();
      };
      function parseHex4Bits(string, index) {
        var c = string.charCodeAt(index);
        if (c >= 65 && c <= 70) {
          return c - 55;
        } else if (c >= 97 && c <= 102) {
          return c - 87;
        } else {
          return c - 48 & 15;
        }
      }
      function parseHexByte(string, lowerBound, index) {
        var r = parseHex4Bits(string, index);
        if (index - 1 >= lowerBound) {
          r |= parseHex4Bits(string, index - 1) << 4;
        }
        return r;
      }
      BN.prototype._parseHex = function _parseHex(number, start, endian) {
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var off = 0;
        var j = 0;
        var w;
        if (endian === "be") {
          for (i = number.length - 1; i >= start; i -= 2) {
            w = parseHexByte(number, start, i) << off;
            this.words[j] |= w & 67108863;
            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w >>> 26;
            } else {
              off += 8;
            }
          }
        } else {
          var parseLength = number.length - start;
          for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
            w = parseHexByte(number, start, i) << off;
            this.words[j] |= w & 67108863;
            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w >>> 26;
            } else {
              off += 8;
            }
          }
        }
        this.strip();
      };
      function parseBase(str, start, end, mul) {
        var r = 0;
        var len = Math.min(str.length, end);
        for (var i = start; i < len; i++) {
          var c = str.charCodeAt(i) - 48;
          r *= mul;
          if (c >= 49) {
            r += c - 49 + 10;
          } else if (c >= 17) {
            r += c - 17 + 10;
          } else {
            r += c;
          }
        }
        return r;
      }
      BN.prototype._parseBase = function _parseBase(number, base, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base | 0;
        var total = number.length - start;
        var mod = total % limbLen;
        var end = Math.min(total, total - mod) + start;
        var word = 0;
        for (var i = start; i < end; i += limbLen) {
          word = parseBase(number, i, i + limbLen, base);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod !== 0) {
          var pow = 1;
          word = parseBase(number, i, number.length, base);
          for (i = 0; i < mod; i++) {
            pow *= base;
          }
          this.imuln(pow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        this.strip();
      };
      BN.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          dest.words[i] = this.words[i];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      BN.prototype.clone = function clone() {
        var r = new BN(null);
        this.copy(r);
        return r;
      };
      BN.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN.prototype.strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      BN.prototype.inspect = function inspect() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var zeros = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN.prototype.toString = function toString(base, padding) {
        base = base || 10;
        padding = padding | 0 || 1;
        var out;
        if (base === 16 || base === "hex") {
          out = "";
          var off = 0;
          var carry = 0;
          for (var i = 0; i < this.length; i++) {
            var w = this.words[i];
            var word = ((w << off | carry) & 16777215).toString(16);
            carry = w >>> 24 - off & 16777215;
            off += 2;
            if (off >= 26) {
              off -= 26;
              i--;
            }
            if (carry !== 0 || i !== this.length - 1) {
              out = zeros[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base === (base | 0) && base >= 2 && base <= 36) {
          var groupSize = groupSizes[base];
          var groupBase = groupBases[base];
          out = "";
          var c = this.clone();
          c.negative = 0;
          while (!c.isZero()) {
            var r = c.modn(groupBase).toString(base);
            c = c.idivn(groupBase);
            if (!c.isZero()) {
              out = zeros[groupSize - r.length] + r + out;
            } else {
              out = r + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert(false, "Base should be between 2 and 36");
      };
      BN.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN.prototype.toJSON = function toJSON() {
        return this.toString(16);
      };
      BN.prototype.toBuffer = function toBuffer(endian, length) {
        assert(typeof Buffer2 !== "undefined");
        return this.toArrayLike(Buffer2, endian, length);
      };
      BN.prototype.toArray = function toArray(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
      BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        var byteLength = this.byteLength();
        var reqLength = length || Math.max(1, byteLength);
        assert(byteLength <= reqLength, "byte array longer than desired length");
        assert(reqLength > 0, "Requested array length <= 0");
        this.strip();
        var littleEndian = endian === "le";
        var res = new ArrayType(reqLength);
        var b, i;
        var q = this.clone();
        if (!littleEndian) {
          for (i = 0; i < reqLength - byteLength; i++) {
            res[i] = 0;
          }
          for (i = 0; !q.isZero(); i++) {
            b = q.andln(255);
            q.iushrn(8);
            res[reqLength - i - 1] = b;
          }
        } else {
          for (i = 0; !q.isZero(); i++) {
            b = q.andln(255);
            q.iushrn(8);
            res[i] = b;
          }
          for (; i < reqLength; i++) {
            res[i] = 0;
          }
        }
        return res;
      };
      if (Math.clz32) {
        BN.prototype._countBits = function _countBits(w) {
          return 32 - Math.clz32(w);
        };
      } else {
        BN.prototype._countBits = function _countBits(w) {
          var t = w;
          var r = 0;
          if (t >= 4096) {
            r += 13;
            t >>>= 13;
          }
          if (t >= 64) {
            r += 7;
            t >>>= 7;
          }
          if (t >= 8) {
            r += 4;
            t >>>= 4;
          }
          if (t >= 2) {
            r += 2;
            t >>>= 2;
          }
          return r + t;
        };
      }
      BN.prototype._zeroBits = function _zeroBits(w) {
        if (w === 0) return 26;
        var t = w;
        var r = 0;
        if ((t & 8191) === 0) {
          r += 13;
          t >>>= 13;
        }
        if ((t & 127) === 0) {
          r += 7;
          t >>>= 7;
        }
        if ((t & 15) === 0) {
          r += 4;
          t >>>= 4;
        }
        if ((t & 3) === 0) {
          r += 2;
          t >>>= 2;
        }
        if ((t & 1) === 0) {
          r++;
        }
        return r;
      };
      BN.prototype.bitLength = function bitLength() {
        var w = this.words[this.length - 1];
        var hi = this._countBits(w);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num) {
        var w = new Array(num.bitLength());
        for (var bit = 0; bit < w.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w[bit] = (num.words[off] & 1 << wbit) >>> wbit;
        }
        return w;
      }
      BN.prototype.zeroBits = function zeroBits() {
        if (this.isZero()) return 0;
        var r = 0;
        for (var i = 0; i < this.length; i++) {
          var b = this._zeroBits(this.words[i]);
          r += b;
          if (b !== 26) break;
        }
        return r;
      };
      BN.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN.prototype.neg = function neg() {
        return this.clone().ineg();
      };
      BN.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i = 0; i < num.length; i++) {
          this.words[i] = this.words[i] | num.words[i];
        }
        return this.strip();
      };
      BN.prototype.ior = function ior(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN.prototype.or = function or(num) {
        if (this.length > num.length) return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN.prototype.uor = function uor(num) {
        if (this.length > num.length) return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN.prototype.iuand = function iuand(num) {
        var b;
        if (this.length > num.length) {
          b = num;
        } else {
          b = this;
        }
        for (var i = 0; i < b.length; i++) {
          this.words[i] = this.words[i] & num.words[i];
        }
        this.length = b.length;
        return this.strip();
      };
      BN.prototype.iand = function iand(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN.prototype.and = function and(num) {
        if (this.length > num.length) return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN.prototype.uand = function uand(num) {
        if (this.length > num.length) return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN.prototype.iuxor = function iuxor(num) {
        var a;
        var b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        for (var i = 0; i < b.length; i++) {
          this.words[i] = a.words[i] ^ b.words[i];
        }
        if (this !== a) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = a.length;
        return this.strip();
      };
      BN.prototype.ixor = function ixor(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN.prototype.xor = function xor(num) {
        if (this.length > num.length) return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN.prototype.uxor = function uxor(num) {
        if (this.length > num.length) return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN.prototype.inotn = function inotn(width) {
        assert(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i = 0; i < bytesNeeded; i++) {
          this.words[i] = ~this.words[i] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;
        }
        return this.strip();
      };
      BN.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN.prototype.setn = function setn(bit, val) {
        assert(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this.strip();
      };
      BN.prototype.iadd = function iadd(num) {
        var r;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r = this.isub(num);
          num.negative = 1;
          return r._normSign();
        }
        var a, b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i = 0; i < b.length; i++) {
          r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
          this.words[i] = r & 67108863;
          carry = r >>> 26;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          this.words[i] = r & 67108863;
          carry = r >>> 26;
        }
        this.length = a.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        return this;
      };
      BN.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length) return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r = this.iadd(num);
          num.negative = 1;
          return r._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a, b;
        if (cmp > 0) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i = 0; i < b.length; i++) {
          r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 67108863;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 67108863;
        }
        if (carry === 0 && i < a.length && a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = Math.max(this.length, i);
        if (a !== this) {
          this.negative = 1;
        }
        return this.strip();
      };
      BN.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len = self2.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a = self2.words[0] | 0;
        var b = num.words[0] | 0;
        var r = a * b;
        var lo = r & 67108863;
        var carry = r / 67108864 | 0;
        out.words[0] = lo;
        for (var k = 1; k < len; k++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i = k - j | 0;
            a = self2.words[i] | 0;
            b = num.words[j] | 0;
            r = a * b + rword;
            ncarry += r / 67108864 | 0;
            rword = r & 67108863;
          }
          out.words[k] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k] = carry | 0;
        } else {
          out.length--;
        }
        return out.strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num, out) {
        var a = self2.words;
        var b = num.words;
        var o = out.words;
        var c = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a2 = a[2] | 0;
        var al2 = a2 & 8191;
        var ah2 = a2 >>> 13;
        var a3 = a[3] | 0;
        var al3 = a3 & 8191;
        var ah3 = a3 >>> 13;
        var a4 = a[4] | 0;
        var al4 = a4 & 8191;
        var ah4 = a4 >>> 13;
        var a5 = a[5] | 0;
        var al5 = a5 & 8191;
        var ah5 = a5 >>> 13;
        var a6 = a[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b0 = b[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b2 = b[2] | 0;
        var bl2 = b2 & 8191;
        var bh2 = b2 >>> 13;
        var b3 = b[3] | 0;
        var bl3 = b3 & 8191;
        var bh3 = b3 >>> 13;
        var b4 = b[4] | 0;
        var bl4 = b4 & 8191;
        var bh4 = b4 >>> 13;
        var b5 = b[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
        w2 &= 67108863;
        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
        w3 &= 67108863;
        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
        w4 &= 67108863;
        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
        w5 &= 67108863;
        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o[0] = w0;
        o[1] = w1;
        o[2] = w2;
        o[3] = w3;
        o[4] = w4;
        o[5] = w5;
        o[6] = w6;
        o[7] = w7;
        o[8] = w8;
        o[9] = w9;
        o[10] = w10;
        o[11] = w11;
        o[12] = w12;
        o[13] = w13;
        o[14] = w14;
        o[15] = w15;
        o[16] = w16;
        o[17] = w17;
        o[18] = w18;
        if (c !== 0) {
          o[19] = c;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k = 0; k < out.length - 1; k++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i = k - j;
            var a = self2.words[i] | 0;
            var b = num.words[j] | 0;
            var r = a * b;
            var lo = r & 67108863;
            ncarry = ncarry + (r / 67108864 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 67108863;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k] = carry;
        } else {
          out.length--;
        }
        return out.strip();
      }
      function jumboMulTo(self2, num, out) {
        var fftm = new FFTM();
        return fftm.mulp(self2, num, out);
      }
      BN.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      function FFTM(x, y) {
        this.x = x;
        this.y = y;
      }
      FFTM.prototype.makeRBT = function makeRBT(N) {
        var t = new Array(N);
        var l = BN.prototype._countBits(N) - 1;
        for (var i = 0; i < N; i++) {
          t[i] = this.revBin(i, l, N);
        }
        return t;
      };
      FFTM.prototype.revBin = function revBin(x, l, N) {
        if (x === 0 || x === N - 1) return x;
        var rb = 0;
        for (var i = 0; i < l; i++) {
          rb |= (x & 1) << l - i - 1;
          x >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
        for (var i = 0; i < N; i++) {
          rtws[i] = rws[rbt[i]];
          itws[i] = iws[rbt[i]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N);
        for (var s = 1; s < N; s <<= 1) {
          var l = s << 1;
          var rtwdf = Math.cos(2 * Math.PI / l);
          var itwdf = Math.sin(2 * Math.PI / l);
          for (var p = 0; p < N; p += l) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j = 0; j < s; j++) {
              var re = rtws[p + j];
              var ie = itws[p + j];
              var ro = rtws[p + j + s];
              var io = itws[p + j + s];
              var rx = rtwdf_ * ro - itwdf_ * io;
              io = rtwdf_ * io + itwdf_ * ro;
              ro = rx;
              rtws[p + j] = re + ro;
              itws[p + j] = ie + io;
              rtws[p + j + s] = re - ro;
              itws[p + j + s] = ie - io;
              if (j !== l) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
        var N = Math.max(m, n) | 1;
        var odd = N & 1;
        var i = 0;
        for (N = N / 2 | 0; N; N = N >>> 1) {
          i++;
        }
        return 1 << i + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
        if (N <= 1) return;
        for (var i = 0; i < N / 2; i++) {
          var t = rws[i];
          rws[i] = rws[N - i - 1];
          rws[N - i - 1] = t;
          t = iws[i];
          iws[i] = -iws[N - i - 1];
          iws[N - i - 1] = -t;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws, N) {
        var carry = 0;
        for (var i = 0; i < N / 2; i++) {
          var w = Math.round(ws[2 * i + 1] / N) * 8192 + Math.round(ws[2 * i] / N) + carry;
          ws[i] = w & 67108863;
          if (w < 67108864) {
            carry = 0;
          } else {
            carry = w / 67108864 | 0;
          }
        }
        return ws;
      };
      FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
        var carry = 0;
        for (var i = 0; i < len; i++) {
          carry = carry + (ws[i] | 0);
          rws[2 * i] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i = 2 * len; i < N; ++i) {
          rws[i] = 0;
        }
        assert(carry === 0);
        assert((carry & ~8191) === 0);
      };
      FFTM.prototype.stub = function stub(N) {
        var ph = new Array(N);
        for (var i = 0; i < N; i++) {
          ph[i] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x, y, out) {
        var N = 2 * this.guessLen13b(x.length, y.length);
        var rbt = this.makeRBT(N);
        var _ = this.stub(N);
        var rws = new Array(N);
        var rwst = new Array(N);
        var iwst = new Array(N);
        var nrws = new Array(N);
        var nrwst = new Array(N);
        var niwst = new Array(N);
        var rmws = out.words;
        rmws.length = N;
        this.convert13b(x.words, x.length, rws, N);
        this.convert13b(y.words, y.length, nrws, N);
        this.transform(rws, _, rwst, iwst, N, rbt);
        this.transform(nrws, _, nrwst, niwst, N, rbt);
        for (var i = 0; i < N; i++) {
          var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
          iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
          rwst[i] = rx;
        }
        this.conjugate(rwst, iwst, N);
        this.transform(rwst, iwst, rmws, _, N, rbt);
        this.conjugate(rmws, _, N);
        this.normalize13b(rmws, N);
        out.negative = x.negative ^ y.negative;
        out.length = x.length + y.length;
        return out.strip();
      };
      BN.prototype.mul = function mul(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN.prototype.mulf = function mulf(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN.prototype.imuln = function imuln(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        var carry = 0;
        for (var i = 0; i < this.length; i++) {
          var w = (this.words[i] | 0) * num;
          var lo = (w & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w / 67108864 | 0;
          carry += lo >>> 26;
          this.words[i] = lo & 67108863;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        this.length = num === 0 ? 1 : this.length;
        return this;
      };
      BN.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN.prototype.pow = function pow(num) {
        var w = toBitArray(num);
        if (w.length === 0) return new BN(1);
        var res = this;
        for (var i = 0; i < w.length; i++, res = res.sqr()) {
          if (w[i] !== 0) break;
        }
        if (++i < w.length) {
          for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
            if (w[i] === 0) continue;
            res = res.mul(q);
          }
        }
        return res;
      };
      BN.prototype.iushln = function iushln(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        var carryMask = 67108863 >>> 26 - r << 26 - r;
        var i;
        if (r !== 0) {
          var carry = 0;
          for (i = 0; i < this.length; i++) {
            var newCarry = this.words[i] & carryMask;
            var c = (this.words[i] | 0) - newCarry << r;
            this.words[i] = c | carry;
            carry = newCarry >>> 26 - r;
          }
          if (carry) {
            this.words[i] = carry;
            this.length++;
          }
        }
        if (s !== 0) {
          for (i = this.length - 1; i >= 0; i--) {
            this.words[i + s] = this.words[i];
          }
          for (i = 0; i < s; i++) {
            this.words[i] = 0;
          }
          this.length += s;
        }
        return this.strip();
      };
      BN.prototype.ishln = function ishln(bits) {
        assert(this.negative === 0);
        return this.iushln(bits);
      };
      BN.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert(typeof bits === "number" && bits >= 0);
        var h;
        if (hint) {
          h = (hint - hint % 26) / 26;
        } else {
          h = 0;
        }
        var r = bits % 26;
        var s = Math.min((bits - r) / 26, this.length);
        var mask = 67108863 ^ 67108863 >>> r << r;
        var maskedWords = extended;
        h -= s;
        h = Math.max(0, h);
        if (maskedWords) {
          for (var i = 0; i < s; i++) {
            maskedWords.words[i] = this.words[i];
          }
          maskedWords.length = s;
        }
        if (s === 0) {
        } else if (this.length > s) {
          this.length -= s;
          for (i = 0; i < this.length; i++) {
            this.words[i] = this.words[i + s];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
          var word = this.words[i] | 0;
          this.words[i] = carry << 26 - r | word >>> r;
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this.strip();
      };
      BN.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN.prototype.testn = function testn(bit) {
        assert(typeof bit === "number" && bit >= 0);
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        if (this.length <= s) return false;
        var w = this.words[s];
        return !!(w & q);
      };
      BN.prototype.imaskn = function imaskn(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        assert(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s) {
          return this;
        }
        if (r !== 0) {
          s++;
        }
        this.length = Math.min(s, this.length);
        if (r !== 0) {
          var mask = 67108863 ^ 67108863 >>> r << r;
          this.words[this.length - 1] &= mask;
        }
        return this.strip();
      };
      BN.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN.prototype.iaddn = function iaddn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0) return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) < num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) {
          this.words[i] -= 67108864;
          if (i === this.length - 1) {
            this.words[i + 1] = 1;
          } else {
            this.words[i + 1]++;
          }
        }
        this.length = Math.max(this.length, i + 1);
        return this;
      };
      BN.prototype.isubn = function isubn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0) return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i = 0; i < this.length && this.words[i] < 0; i++) {
            this.words[i] += 67108864;
            this.words[i + 1] -= 1;
          }
        }
        return this.strip();
      };
      BN.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len = num.length + shift;
        var i;
        this._expand(len);
        var w;
        var carry = 0;
        for (i = 0; i < num.length; i++) {
          w = (this.words[i + shift] | 0) + carry;
          var right = (num.words[i] | 0) * mul;
          w -= right & 67108863;
          carry = (w >> 26) - (right / 67108864 | 0);
          this.words[i + shift] = w & 67108863;
        }
        for (; i < this.length - shift; i++) {
          w = (this.words[i + shift] | 0) + carry;
          carry = w >> 26;
          this.words[i + shift] = w & 67108863;
        }
        if (carry === 0) return this.strip();
        assert(carry === -1);
        carry = 0;
        for (i = 0; i < this.length; i++) {
          w = -(this.words[i] | 0) + carry;
          carry = w >> 26;
          this.words[i] = w & 67108863;
        }
        this.negative = 1;
        return this.strip();
      };
      BN.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a = this.clone();
        var b = num;
        var bhi = b.words[b.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b = b.ushln(shift);
          a.iushln(shift);
          bhi = b.words[b.length - 1] | 0;
        }
        var m = a.length - b.length;
        var q;
        if (mode !== "mod") {
          q = new BN(null);
          q.length = m + 1;
          q.words = new Array(q.length);
          for (var i = 0; i < q.length; i++) {
            q.words[i] = 0;
          }
        }
        var diff = a.clone()._ishlnsubmul(b, 1, m);
        if (diff.negative === 0) {
          a = diff;
          if (q) {
            q.words[m] = 1;
          }
        }
        for (var j = m - 1; j >= 0; j--) {
          var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a._ishlnsubmul(b, qj, j);
          while (a.negative !== 0) {
            qj--;
            a.negative = 0;
            a._ishlnsubmul(b, 1, j);
            if (!a.isZero()) {
              a.negative ^= 1;
            }
          }
          if (q) {
            q.words[j] = qj;
          }
        }
        if (q) {
          q.strip();
        }
        a.strip();
        if (mode !== "div" && shift !== 0) {
          a.iushrn(shift);
        }
        return {
          div: q || null,
          mod: a
        };
      };
      BN.prototype.divmod = function divmod(num, mode, positive) {
        assert(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN(0),
            mod: new BN(0)
          };
        }
        var div, mod, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.iadd(num);
            }
          }
          return {
            div,
            mod
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.isub(num);
            }
          }
          return {
            div: res.div,
            mod
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN(this.modn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN(this.modn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN.prototype.mod = function mod(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero()) return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r2 = num.andln(1);
        var cmp = mod.cmp(half);
        if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN.prototype.modn = function modn(num) {
        assert(num <= 67108863);
        var p = (1 << 26) % num;
        var acc = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          acc = (p * acc + (this.words[i] | 0)) % num;
        }
        return acc;
      };
      BN.prototype.idivn = function idivn(num) {
        assert(num <= 67108863);
        var carry = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var w = (this.words[i] | 0) + carry * 67108864;
          this.words[i] = w / num | 0;
          carry = w % num;
        }
        return this.strip();
      };
      BN.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN.prototype.egcd = function egcd(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var x = this;
        var y = p.clone();
        if (x.negative !== 0) {
          x = x.umod(p);
        } else {
          x = x.clone();
        }
        var A = new BN(1);
        var B = new BN(0);
        var C = new BN(0);
        var D = new BN(1);
        var g = 0;
        while (x.isEven() && y.isEven()) {
          x.iushrn(1);
          y.iushrn(1);
          ++g;
        }
        var yp = y.clone();
        var xp = x.clone();
        while (!x.isZero()) {
          for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1) ;
          if (i > 0) {
            x.iushrn(i);
            while (i-- > 0) {
              if (A.isOdd() || B.isOdd()) {
                A.iadd(yp);
                B.isub(xp);
              }
              A.iushrn(1);
              B.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1) ;
          if (j > 0) {
            y.iushrn(j);
            while (j-- > 0) {
              if (C.isOdd() || D.isOdd()) {
                C.iadd(yp);
                D.isub(xp);
              }
              C.iushrn(1);
              D.iushrn(1);
            }
          }
          if (x.cmp(y) >= 0) {
            x.isub(y);
            A.isub(C);
            B.isub(D);
          } else {
            y.isub(x);
            C.isub(A);
            D.isub(B);
          }
        }
        return {
          a: C,
          b: D,
          gcd: y.iushln(g)
        };
      };
      BN.prototype._invmp = function _invmp(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var a = this;
        var b = p.clone();
        if (a.negative !== 0) {
          a = a.umod(p);
        } else {
          a = a.clone();
        }
        var x1 = new BN(1);
        var x2 = new BN(0);
        var delta = b.clone();
        while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
          for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1) ;
          if (i > 0) {
            a.iushrn(i);
            while (i-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1) ;
          if (j > 0) {
            b.iushrn(j);
            while (j-- > 0) {
              if (x2.isOdd()) {
                x2.iadd(delta);
              }
              x2.iushrn(1);
            }
          }
          if (a.cmp(b) >= 0) {
            a.isub(b);
            x1.isub(x2);
          } else {
            b.isub(a);
            x2.isub(x1);
          }
        }
        var res;
        if (a.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x2;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p);
        }
        return res;
      };
      BN.prototype.gcd = function gcd(num) {
        if (this.isZero()) return num.abs();
        if (num.isZero()) return this.abs();
        var a = this.clone();
        var b = num.clone();
        a.negative = 0;
        b.negative = 0;
        for (var shift = 0; a.isEven() && b.isEven(); shift++) {
          a.iushrn(1);
          b.iushrn(1);
        }
        do {
          while (a.isEven()) {
            a.iushrn(1);
          }
          while (b.isEven()) {
            b.iushrn(1);
          }
          var r = a.cmp(b);
          if (r < 0) {
            var t = a;
            a = b;
            b = t;
          } else if (r === 0 || b.cmpn(1) === 0) {
            break;
          }
          a.isub(b);
        } while (true);
        return b.iushln(shift);
      };
      BN.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN.prototype.bincn = function bincn(bit) {
        assert(typeof bit === "number");
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        if (this.length <= s) {
          this._expand(s + 1);
          this.words[s] |= q;
          return this;
        }
        var carry = q;
        for (var i = s; carry !== 0 && i < this.length; i++) {
          var w = this.words[i] | 0;
          w += carry;
          carry = w >>> 26;
          w &= 67108863;
          this.words[i] = w;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        return this;
      };
      BN.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative) return -1;
        if (this.negative === 0 && negative) return 1;
        this.strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert(num <= 67108863, "Number is too big");
          var w = this.words[0] | 0;
          res = w === num ? 0 : w < num ? -1 : 1;
        }
        if (this.negative !== 0) return -res | 0;
        return res;
      };
      BN.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0) return -1;
        if (this.negative === 0 && num.negative !== 0) return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0) return -res | 0;
        return res;
      };
      BN.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length) return 1;
        if (this.length < num.length) return -1;
        var res = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var a = this.words[i] | 0;
          var b = num.words[i] | 0;
          if (a === b) continue;
          if (a < b) {
            res = -1;
          } else if (a > b) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
      };
      BN.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
      };
      BN.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      };
      BN.red = function red(num) {
        return new Red(num);
      };
      BN.prototype.toRed = function toRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        assert(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN.prototype.fromRed = function fromRed() {
        assert(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN.prototype.forceRed = function forceRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN.prototype.redAdd = function redAdd(num) {
        assert(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN.prototype.redIAdd = function redIAdd(num) {
        assert(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN.prototype.redSub = function redSub(num) {
        assert(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN.prototype.redISub = function redISub(num) {
        assert(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN.prototype.redShl = function redShl(num) {
        assert(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN.prototype.redMul = function redMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN.prototype.redIMul = function redIMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN.prototype.redSqr = function redSqr() {
        assert(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN.prototype.redISqr = function redISqr() {
        assert(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN.prototype.redSqrt = function redSqrt() {
        assert(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN.prototype.redInvm = function redInvm() {
        assert(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN.prototype.redNeg = function redNeg() {
        assert(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN.prototype.redPow = function redPow(num) {
        assert(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name, p) {
        this.name = name;
        this.p = new BN(p, 16);
        this.n = this.p.bitLength();
        this.k = new BN(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r = num;
        var rlen;
        do {
          this.split(r, this.tmp);
          r = this.imulK(r);
          r = r.iadd(this.tmp);
          rlen = r.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
        if (cmp === 0) {
          r.words[0] = 0;
          r.length = 1;
        } else if (cmp > 0) {
          r.isub(this.p);
        } else {
          if (r.strip !== void 0) {
            r.strip();
          } else {
            r._strip();
          }
        }
        return r;
      };
      MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      inherits(K256, MPrime);
      K256.prototype.split = function split(input, output) {
        var mask = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i = 0; i < outLen; i++) {
          output.words[i] = input.words[i];
        }
        output.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for (i = 10; i < input.length; i++) {
          var next = input.words[i] | 0;
          input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo = 0;
        for (var i = 0; i < num.length; i++) {
          var w = num.words[i] | 0;
          lo += w * 977;
          num.words[i] = lo & 67108863;
          lo = w * 64 + (lo / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      inherits(P224, MPrime);
      function P192() {
        MPrime.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      inherits(P192, MPrime);
      function P25519() {
        MPrime.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      inherits(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i = 0; i < num.length; i++) {
          var hi = (num.words[i] | 0) * 19 + carry;
          var lo = hi & 67108863;
          hi >>>= 26;
          num.words[i] = lo;
          carry = hi;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN._prime = function prime(name) {
        if (primes[name]) return primes[name];
        var prime2;
        if (name === "k256") {
          prime2 = new K256();
        } else if (name === "p224") {
          prime2 = new P224();
        } else if (name === "p192") {
          prime2 = new P192();
        } else if (name === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name);
        }
        primes[name] = prime2;
        return prime2;
      };
      function Red(m) {
        if (typeof m === "string") {
          var prime = BN._prime(m);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert(m.gtn(1), "modulus must be greater than 1");
          this.m = m;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a) {
        assert(a.negative === 0, "red works only with positives");
        assert(a.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a, b) {
        assert((a.negative | b.negative) === 0, "red works only with positives");
        assert(
          a.red && a.red === b.red,
          "red works only with red numbers"
        );
      };
      Red.prototype.imod = function imod(a) {
        if (this.prime) return this.prime.ireduce(a)._forceRed(this);
        return a.umod(this.m)._forceRed(this);
      };
      Red.prototype.neg = function neg(a) {
        if (a.isZero()) {
          return a.clone();
        }
        return this.m.sub(a)._forceRed(this);
      };
      Red.prototype.add = function add(a, b) {
        this._verify2(a, b);
        var res = a.add(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a, b) {
        this._verify2(a, b);
        var res = a.iadd(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a, b) {
        this._verify2(a, b);
        var res = a.sub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a, b) {
        this._verify2(a, b);
        var res = a.isub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a, num) {
        this._verify1(a);
        return this.imod(a.ushln(num));
      };
      Red.prototype.imul = function imul(a, b) {
        this._verify2(a, b);
        return this.imod(a.imul(b));
      };
      Red.prototype.mul = function mul(a, b) {
        this._verify2(a, b);
        return this.imod(a.mul(b));
      };
      Red.prototype.isqr = function isqr(a) {
        return this.imul(a, a.clone());
      };
      Red.prototype.sqr = function sqr(a) {
        return this.mul(a, a);
      };
      Red.prototype.sqrt = function sqrt(a) {
        if (a.isZero()) return a.clone();
        var mod3 = this.m.andln(3);
        assert(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow = this.m.add(new BN(1)).iushrn(2);
          return this.pow(a, pow);
        }
        var q = this.m.subn(1);
        var s = 0;
        while (!q.isZero() && q.andln(1) === 0) {
          s++;
          q.iushrn(1);
        }
        assert(!q.isZero());
        var one = new BN(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z = this.m.bitLength();
        z = new BN(2 * z * z).toRed(this);
        while (this.pow(z, lpow).cmp(nOne) !== 0) {
          z.redIAdd(nOne);
        }
        var c = this.pow(z, q);
        var r = this.pow(a, q.addn(1).iushrn(1));
        var t = this.pow(a, q);
        var m = s;
        while (t.cmp(one) !== 0) {
          var tmp = t;
          for (var i = 0; tmp.cmp(one) !== 0; i++) {
            tmp = tmp.redSqr();
          }
          assert(i < m);
          var b = this.pow(c, new BN(1).iushln(m - i - 1));
          r = r.redMul(b);
          c = b.redSqr();
          t = t.redMul(c);
          m = i;
        }
        return r;
      };
      Red.prototype.invm = function invm(a) {
        var inv = a._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow(a, num) {
        if (num.isZero()) return new BN(1).toRed(this);
        if (num.cmpn(1) === 0) return a.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN(1).toRed(this);
        wnd[1] = a;
        for (var i = 2; i < wnd.length; i++) {
          wnd[i] = this.mul(wnd[i - 1], a);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i = num.length - 1; i >= 0; i--) {
          var word = num.words[i];
          for (var j = start - 1; j >= 0; j--) {
            var bit = word >> j & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r = num.umod(this.m);
        return r === num ? r.clone() : r;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m) {
        Red.call(this, m);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r = this.imod(num.mul(this.rinv));
        r.red = null;
        return r;
      };
      Mont.prototype.imul = function imul(a, b) {
        if (a.isZero() || b.isZero()) {
          a.words[0] = 0;
          a.length = 1;
          return a;
        }
        var t = a.imul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul(a, b) {
        if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);
        var t = a.mul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a) {
        var res = this.imod(a._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module2 === "undefined" || module2, exports2);
  }
});

// node_modules/minimalistic-assert/index.js
var require_minimalistic_assert = __commonJS({
  "node_modules/minimalistic-assert/index.js"(exports2, module2) {
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    module2.exports = assert;
    function assert(val, msg) {
      if (!val)
        throw new Error(msg || "Assertion failed");
    }
    assert.equal = function assertEqual(l, r, msg) {
      if (l != r)
        throw new Error(msg || "Assertion failed: " + l + " != " + r);
    };
  }
});

// node_modules/minimalistic-crypto-utils/lib/utils.js
var require_utils = __commonJS({
  "node_modules/minimalistic-crypto-utils/lib/utils.js"(exports2) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var utils = exports2;
    function toArray(msg, enc) {
      if (Array.isArray(msg))
        return msg.slice();
      if (!msg)
        return [];
      var res = [];
      if (typeof msg !== "string") {
        for (var i = 0; i < msg.length; i++)
          res[i] = msg[i] | 0;
        return res;
      }
      if (enc === "hex") {
        msg = msg.replace(/[^a-z0-9]+/ig, "");
        if (msg.length % 2 !== 0)
          msg = "0" + msg;
        for (var i = 0; i < msg.length; i += 2)
          res.push(parseInt(msg[i] + msg[i + 1], 16));
      } else {
        for (var i = 0; i < msg.length; i++) {
          var c = msg.charCodeAt(i);
          var hi = c >> 8;
          var lo = c & 255;
          if (hi)
            res.push(hi, lo);
          else
            res.push(lo);
        }
      }
      return res;
    }
    utils.toArray = toArray;
    function zero2(word) {
      if (word.length === 1)
        return "0" + word;
      else
        return word;
    }
    utils.zero2 = zero2;
    function toHex(msg) {
      var res = "";
      for (var i = 0; i < msg.length; i++)
        res += zero2(msg[i].toString(16));
      return res;
    }
    utils.toHex = toHex;
    utils.encode = function encode(arr, enc) {
      if (enc === "hex")
        return toHex(arr);
      else
        return arr;
    };
  }
});

// node_modules/elliptic/lib/elliptic/utils.js
var require_utils2 = __commonJS({
  "node_modules/elliptic/lib/elliptic/utils.js"(exports2) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var utils = exports2;
    var BN = require_bn();
    var minAssert = require_minimalistic_assert();
    var minUtils = require_utils();
    utils.assert = minAssert;
    utils.toArray = minUtils.toArray;
    utils.zero2 = minUtils.zero2;
    utils.toHex = minUtils.toHex;
    utils.encode = minUtils.encode;
    function getNAF(num, w, bits) {
      var naf = new Array(Math.max(num.bitLength(), bits) + 1);
      var i;
      for (i = 0; i < naf.length; i += 1) {
        naf[i] = 0;
      }
      var ws = 1 << w + 1;
      var k = num.clone();
      for (i = 0; i < naf.length; i++) {
        var z;
        var mod = k.andln(ws - 1);
        if (k.isOdd()) {
          if (mod > (ws >> 1) - 1)
            z = (ws >> 1) - mod;
          else
            z = mod;
          k.isubn(z);
        } else {
          z = 0;
        }
        naf[i] = z;
        k.iushrn(1);
      }
      return naf;
    }
    utils.getNAF = getNAF;
    function getJSF(k1, k2) {
      var jsf = [
        [],
        []
      ];
      k1 = k1.clone();
      k2 = k2.clone();
      var d1 = 0;
      var d2 = 0;
      var m8;
      while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {
        var m14 = k1.andln(3) + d1 & 3;
        var m24 = k2.andln(3) + d2 & 3;
        if (m14 === 3)
          m14 = -1;
        if (m24 === 3)
          m24 = -1;
        var u1;
        if ((m14 & 1) === 0) {
          u1 = 0;
        } else {
          m8 = k1.andln(7) + d1 & 7;
          if ((m8 === 3 || m8 === 5) && m24 === 2)
            u1 = -m14;
          else
            u1 = m14;
        }
        jsf[0].push(u1);
        var u2;
        if ((m24 & 1) === 0) {
          u2 = 0;
        } else {
          m8 = k2.andln(7) + d2 & 7;
          if ((m8 === 3 || m8 === 5) && m14 === 2)
            u2 = -m24;
          else
            u2 = m24;
        }
        jsf[1].push(u2);
        if (2 * d1 === u1 + 1)
          d1 = 1 - d1;
        if (2 * d2 === u2 + 1)
          d2 = 1 - d2;
        k1.iushrn(1);
        k2.iushrn(1);
      }
      return jsf;
    }
    utils.getJSF = getJSF;
    function cachedProperty(obj, name, computer) {
      var key = "_" + name;
      obj.prototype[name] = function cachedProperty2() {
        return this[key] !== void 0 ? this[key] : this[key] = computer.call(this);
      };
    }
    utils.cachedProperty = cachedProperty;
    function parseBytes(bytes) {
      return typeof bytes === "string" ? utils.toArray(bytes, "hex") : bytes;
    }
    utils.parseBytes = parseBytes;
    function intFromLE(bytes) {
      return new BN(bytes, "hex", "le");
    }
    utils.intFromLE = intFromLE;
  }
});

// node_modules/brorand/index.js
var require_brorand = __commonJS({
  "node_modules/brorand/index.js"(exports2, module2) {
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var r;
    module2.exports = function rand(len) {
      if (!r)
        r = new Rand(null);
      return r.generate(len);
    };
    function Rand(rand) {
      this.rand = rand;
    }
    module2.exports.Rand = Rand;
    Rand.prototype.generate = function generate(len) {
      return this._rand(len);
    };
    Rand.prototype._rand = function _rand(n) {
      if (this.rand.getBytes)
        return this.rand.getBytes(n);
      var res = new Uint8Array(n);
      for (var i = 0; i < res.length; i++)
        res[i] = this.rand.getByte();
      return res;
    };
    if (typeof self === "object") {
      if (self.crypto && self.crypto.getRandomValues) {
        Rand.prototype._rand = function _rand(n) {
          var arr = new Uint8Array(n);
          self.crypto.getRandomValues(arr);
          return arr;
        };
      } else if (self.msCrypto && self.msCrypto.getRandomValues) {
        Rand.prototype._rand = function _rand(n) {
          var arr = new Uint8Array(n);
          self.msCrypto.getRandomValues(arr);
          return arr;
        };
      } else if (typeof window === "object") {
        Rand.prototype._rand = function() {
          throw new Error("Not implemented yet");
        };
      }
    } else {
      try {
        crypto2 = require_crypto_browserify();
        if (typeof crypto2.randomBytes !== "function")
          throw new Error("Not supported");
        Rand.prototype._rand = function _rand(n) {
          return crypto2.randomBytes(n);
        };
      } catch (e) {
      }
    }
    var crypto2;
  }
});

// node_modules/elliptic/lib/elliptic/curve/base.js
var require_base = __commonJS({
  "node_modules/elliptic/lib/elliptic/curve/base.js"(exports2, module2) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var BN = require_bn();
    var utils = require_utils2();
    var getNAF = utils.getNAF;
    var getJSF = utils.getJSF;
    var assert = utils.assert;
    function BaseCurve(type, conf) {
      this.type = type;
      this.p = new BN(conf.p, 16);
      this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p);
      this.zero = new BN(0).toRed(this.red);
      this.one = new BN(1).toRed(this.red);
      this.two = new BN(2).toRed(this.red);
      this.n = conf.n && new BN(conf.n, 16);
      this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);
      this._wnafT1 = new Array(4);
      this._wnafT2 = new Array(4);
      this._wnafT3 = new Array(4);
      this._wnafT4 = new Array(4);
      this._bitLength = this.n ? this.n.bitLength() : 0;
      var adjustCount = this.n && this.p.div(this.n);
      if (!adjustCount || adjustCount.cmpn(100) > 0) {
        this.redN = null;
      } else {
        this._maxwellTrick = true;
        this.redN = this.n.toRed(this.red);
      }
    }
    module2.exports = BaseCurve;
    BaseCurve.prototype.point = function point() {
      throw new Error("Not implemented");
    };
    BaseCurve.prototype.validate = function validate() {
      throw new Error("Not implemented");
    };
    BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {
      assert(p.precomputed);
      var doubles = p._getDoubles();
      var naf = getNAF(k, 1, this._bitLength);
      var I = (1 << doubles.step + 1) - (doubles.step % 2 === 0 ? 2 : 1);
      I /= 3;
      var repr = [];
      var j;
      var nafW;
      for (j = 0; j < naf.length; j += doubles.step) {
        nafW = 0;
        for (var l = j + doubles.step - 1; l >= j; l--)
          nafW = (nafW << 1) + naf[l];
        repr.push(nafW);
      }
      var a = this.jpoint(null, null, null);
      var b = this.jpoint(null, null, null);
      for (var i = I; i > 0; i--) {
        for (j = 0; j < repr.length; j++) {
          nafW = repr[j];
          if (nafW === i)
            b = b.mixedAdd(doubles.points[j]);
          else if (nafW === -i)
            b = b.mixedAdd(doubles.points[j].neg());
        }
        a = a.add(b);
      }
      return a.toP();
    };
    BaseCurve.prototype._wnafMul = function _wnafMul(p, k) {
      var w = 4;
      var nafPoints = p._getNAFPoints(w);
      w = nafPoints.wnd;
      var wnd = nafPoints.points;
      var naf = getNAF(k, w, this._bitLength);
      var acc = this.jpoint(null, null, null);
      for (var i = naf.length - 1; i >= 0; i--) {
        for (var l = 0; i >= 0 && naf[i] === 0; i--)
          l++;
        if (i >= 0)
          l++;
        acc = acc.dblp(l);
        if (i < 0)
          break;
        var z = naf[i];
        assert(z !== 0);
        if (p.type === "affine") {
          if (z > 0)
            acc = acc.mixedAdd(wnd[z - 1 >> 1]);
          else
            acc = acc.mixedAdd(wnd[-z - 1 >> 1].neg());
        } else {
          if (z > 0)
            acc = acc.add(wnd[z - 1 >> 1]);
          else
            acc = acc.add(wnd[-z - 1 >> 1].neg());
        }
      }
      return p.type === "affine" ? acc.toP() : acc;
    };
    BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW, points, coeffs, len, jacobianResult) {
      var wndWidth = this._wnafT1;
      var wnd = this._wnafT2;
      var naf = this._wnafT3;
      var max = 0;
      var i;
      var j;
      var p;
      for (i = 0; i < len; i++) {
        p = points[i];
        var nafPoints = p._getNAFPoints(defW);
        wndWidth[i] = nafPoints.wnd;
        wnd[i] = nafPoints.points;
      }
      for (i = len - 1; i >= 1; i -= 2) {
        var a = i - 1;
        var b = i;
        if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
          naf[a] = getNAF(coeffs[a], wndWidth[a], this._bitLength);
          naf[b] = getNAF(coeffs[b], wndWidth[b], this._bitLength);
          max = Math.max(naf[a].length, max);
          max = Math.max(naf[b].length, max);
          continue;
        }
        var comb = [
          points[a],
          /* 1 */
          null,
          /* 3 */
          null,
          /* 5 */
          points[b]
          /* 7 */
        ];
        if (points[a].y.cmp(points[b].y) === 0) {
          comb[1] = points[a].add(points[b]);
          comb[2] = points[a].toJ().mixedAdd(points[b].neg());
        } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {
          comb[1] = points[a].toJ().mixedAdd(points[b]);
          comb[2] = points[a].add(points[b].neg());
        } else {
          comb[1] = points[a].toJ().mixedAdd(points[b]);
          comb[2] = points[a].toJ().mixedAdd(points[b].neg());
        }
        var index = [
          -3,
          /* -1 -1 */
          -1,
          /* -1 0 */
          -5,
          /* -1 1 */
          -7,
          /* 0 -1 */
          0,
          /* 0 0 */
          7,
          /* 0 1 */
          5,
          /* 1 -1 */
          1,
          /* 1 0 */
          3
          /* 1 1 */
        ];
        var jsf = getJSF(coeffs[a], coeffs[b]);
        max = Math.max(jsf[0].length, max);
        naf[a] = new Array(max);
        naf[b] = new Array(max);
        for (j = 0; j < max; j++) {
          var ja = jsf[0][j] | 0;
          var jb = jsf[1][j] | 0;
          naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];
          naf[b][j] = 0;
          wnd[a] = comb;
        }
      }
      var acc = this.jpoint(null, null, null);
      var tmp = this._wnafT4;
      for (i = max; i >= 0; i--) {
        var k = 0;
        while (i >= 0) {
          var zero = true;
          for (j = 0; j < len; j++) {
            tmp[j] = naf[j][i] | 0;
            if (tmp[j] !== 0)
              zero = false;
          }
          if (!zero)
            break;
          k++;
          i--;
        }
        if (i >= 0)
          k++;
        acc = acc.dblp(k);
        if (i < 0)
          break;
        for (j = 0; j < len; j++) {
          var z = tmp[j];
          p;
          if (z === 0)
            continue;
          else if (z > 0)
            p = wnd[j][z - 1 >> 1];
          else if (z < 0)
            p = wnd[j][-z - 1 >> 1].neg();
          if (p.type === "affine")
            acc = acc.mixedAdd(p);
          else
            acc = acc.add(p);
        }
      }
      for (i = 0; i < len; i++)
        wnd[i] = null;
      if (jacobianResult)
        return acc;
      else
        return acc.toP();
    };
    function BasePoint(curve, type) {
      this.curve = curve;
      this.type = type;
      this.precomputed = null;
    }
    BaseCurve.BasePoint = BasePoint;
    BasePoint.prototype.eq = function eq() {
      throw new Error("Not implemented");
    };
    BasePoint.prototype.validate = function validate() {
      return this.curve.validate(this);
    };
    BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
      bytes = utils.toArray(bytes, enc);
      var len = this.p.byteLength();
      if ((bytes[0] === 4 || bytes[0] === 6 || bytes[0] === 7) && bytes.length - 1 === 2 * len) {
        if (bytes[0] === 6)
          assert(bytes[bytes.length - 1] % 2 === 0);
        else if (bytes[0] === 7)
          assert(bytes[bytes.length - 1] % 2 === 1);
        var res = this.point(
          bytes.slice(1, 1 + len),
          bytes.slice(1 + len, 1 + 2 * len)
        );
        return res;
      } else if ((bytes[0] === 2 || bytes[0] === 3) && bytes.length - 1 === len) {
        return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 3);
      }
      throw new Error("Unknown point format");
    };
    BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
      return this.encode(enc, true);
    };
    BasePoint.prototype._encode = function _encode(compact) {
      var len = this.curve.p.byteLength();
      var x = this.getX().toArray("be", len);
      if (compact)
        return [this.getY().isEven() ? 2 : 3].concat(x);
      return [4].concat(x, this.getY().toArray("be", len));
    };
    BasePoint.prototype.encode = function encode(enc, compact) {
      return utils.encode(this._encode(compact), enc);
    };
    BasePoint.prototype.precompute = function precompute(power) {
      if (this.precomputed)
        return this;
      var precomputed = {
        doubles: null,
        naf: null,
        beta: null
      };
      precomputed.naf = this._getNAFPoints(8);
      precomputed.doubles = this._getDoubles(4, power);
      precomputed.beta = this._getBeta();
      this.precomputed = precomputed;
      return this;
    };
    BasePoint.prototype._hasDoubles = function _hasDoubles(k) {
      if (!this.precomputed)
        return false;
      var doubles = this.precomputed.doubles;
      if (!doubles)
        return false;
      return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
    };
    BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
      if (this.precomputed && this.precomputed.doubles)
        return this.precomputed.doubles;
      var doubles = [this];
      var acc = this;
      for (var i = 0; i < power; i += step) {
        for (var j = 0; j < step; j++)
          acc = acc.dbl();
        doubles.push(acc);
      }
      return {
        step,
        points: doubles
      };
    };
    BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
      if (this.precomputed && this.precomputed.naf)
        return this.precomputed.naf;
      var res = [this];
      var max = (1 << wnd) - 1;
      var dbl = max === 1 ? null : this.dbl();
      for (var i = 1; i < max; i++)
        res[i] = res[i - 1].add(dbl);
      return {
        wnd,
        points: res
      };
    };
    BasePoint.prototype._getBeta = function _getBeta() {
      return null;
    };
    BasePoint.prototype.dblp = function dblp(k) {
      var r = this;
      for (var i = 0; i < k; i++)
        r = r.dbl();
      return r;
    };
  }
});

// node_modules/elliptic/lib/elliptic/curve/short.js
var require_short = __commonJS({
  "node_modules/elliptic/lib/elliptic/curve/short.js"(exports2, module2) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var utils = require_utils2();
    var BN = require_bn();
    var inherits = require_inherits();
    var Base = require_base();
    var assert = utils.assert;
    function ShortCurve(conf) {
      Base.call(this, "short", conf);
      this.a = new BN(conf.a, 16).toRed(this.red);
      this.b = new BN(conf.b, 16).toRed(this.red);
      this.tinv = this.two.redInvm();
      this.zeroA = this.a.fromRed().cmpn(0) === 0;
      this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;
      this.endo = this._getEndomorphism(conf);
      this._endoWnafT1 = new Array(4);
      this._endoWnafT2 = new Array(4);
    }
    inherits(ShortCurve, Base);
    module2.exports = ShortCurve;
    ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
      if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
        return;
      var beta;
      var lambda;
      if (conf.beta) {
        beta = new BN(conf.beta, 16).toRed(this.red);
      } else {
        var betas = this._getEndoRoots(this.p);
        beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
        beta = beta.toRed(this.red);
      }
      if (conf.lambda) {
        lambda = new BN(conf.lambda, 16);
      } else {
        var lambdas = this._getEndoRoots(this.n);
        if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
          lambda = lambdas[0];
        } else {
          lambda = lambdas[1];
          assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
        }
      }
      var basis;
      if (conf.basis) {
        basis = conf.basis.map(function(vec) {
          return {
            a: new BN(vec.a, 16),
            b: new BN(vec.b, 16)
          };
        });
      } else {
        basis = this._getEndoBasis(lambda);
      }
      return {
        beta,
        lambda,
        basis
      };
    };
    ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
      var red = num === this.p ? this.red : BN.mont(num);
      var tinv = new BN(2).toRed(red).redInvm();
      var ntinv = tinv.redNeg();
      var s = new BN(3).toRed(red).redNeg().redSqrt().redMul(tinv);
      var l1 = ntinv.redAdd(s).fromRed();
      var l2 = ntinv.redSub(s).fromRed();
      return [l1, l2];
    };
    ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
      var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));
      var u = lambda;
      var v = this.n.clone();
      var x1 = new BN(1);
      var y1 = new BN(0);
      var x2 = new BN(0);
      var y2 = new BN(1);
      var a0;
      var b0;
      var a1;
      var b1;
      var a2;
      var b2;
      var prevR;
      var i = 0;
      var r;
      var x;
      while (u.cmpn(0) !== 0) {
        var q = v.div(u);
        r = v.sub(q.mul(u));
        x = x2.sub(q.mul(x1));
        var y = y2.sub(q.mul(y1));
        if (!a1 && r.cmp(aprxSqrt) < 0) {
          a0 = prevR.neg();
          b0 = x1;
          a1 = r.neg();
          b1 = x;
        } else if (a1 && ++i === 2) {
          break;
        }
        prevR = r;
        v = u;
        u = r;
        x2 = x1;
        x1 = x;
        y2 = y1;
        y1 = y;
      }
      a2 = r.neg();
      b2 = x;
      var len1 = a1.sqr().add(b1.sqr());
      var len2 = a2.sqr().add(b2.sqr());
      if (len2.cmp(len1) >= 0) {
        a2 = a0;
        b2 = b0;
      }
      if (a1.negative) {
        a1 = a1.neg();
        b1 = b1.neg();
      }
      if (a2.negative) {
        a2 = a2.neg();
        b2 = b2.neg();
      }
      return [
        { a: a1, b: b1 },
        { a: a2, b: b2 }
      ];
    };
    ShortCurve.prototype._endoSplit = function _endoSplit(k) {
      var basis = this.endo.basis;
      var v1 = basis[0];
      var v2 = basis[1];
      var c1 = v2.b.mul(k).divRound(this.n);
      var c2 = v1.b.neg().mul(k).divRound(this.n);
      var p1 = c1.mul(v1.a);
      var p2 = c2.mul(v2.a);
      var q1 = c1.mul(v1.b);
      var q2 = c2.mul(v2.b);
      var k1 = k.sub(p1).sub(p2);
      var k2 = q1.add(q2).neg();
      return { k1, k2 };
    };
    ShortCurve.prototype.pointFromX = function pointFromX(x, odd) {
      x = new BN(x, 16);
      if (!x.red)
        x = x.toRed(this.red);
      var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
      var y = y2.redSqrt();
      if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      var isOdd = y.fromRed().isOdd();
      if (odd && !isOdd || !odd && isOdd)
        y = y.redNeg();
      return this.point(x, y);
    };
    ShortCurve.prototype.validate = function validate(point) {
      if (point.inf)
        return true;
      var x = point.x;
      var y = point.y;
      var ax = this.a.redMul(x);
      var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
      return y.redSqr().redISub(rhs).cmpn(0) === 0;
    };
    ShortCurve.prototype._endoWnafMulAdd = function _endoWnafMulAdd(points, coeffs, jacobianResult) {
      var npoints = this._endoWnafT1;
      var ncoeffs = this._endoWnafT2;
      for (var i = 0; i < points.length; i++) {
        var split = this._endoSplit(coeffs[i]);
        var p = points[i];
        var beta = p._getBeta();
        if (split.k1.negative) {
          split.k1.ineg();
          p = p.neg(true);
        }
        if (split.k2.negative) {
          split.k2.ineg();
          beta = beta.neg(true);
        }
        npoints[i * 2] = p;
        npoints[i * 2 + 1] = beta;
        ncoeffs[i * 2] = split.k1;
        ncoeffs[i * 2 + 1] = split.k2;
      }
      var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);
      for (var j = 0; j < i * 2; j++) {
        npoints[j] = null;
        ncoeffs[j] = null;
      }
      return res;
    };
    function Point(curve, x, y, isRed) {
      Base.BasePoint.call(this, curve, "affine");
      if (x === null && y === null) {
        this.x = null;
        this.y = null;
        this.inf = true;
      } else {
        this.x = new BN(x, 16);
        this.y = new BN(y, 16);
        if (isRed) {
          this.x.forceRed(this.curve.red);
          this.y.forceRed(this.curve.red);
        }
        if (!this.x.red)
          this.x = this.x.toRed(this.curve.red);
        if (!this.y.red)
          this.y = this.y.toRed(this.curve.red);
        this.inf = false;
      }
    }
    inherits(Point, Base.BasePoint);
    ShortCurve.prototype.point = function point(x, y, isRed) {
      return new Point(this, x, y, isRed);
    };
    ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
      return Point.fromJSON(this, obj, red);
    };
    Point.prototype._getBeta = function _getBeta() {
      if (!this.curve.endo)
        return;
      var pre = this.precomputed;
      if (pre && pre.beta)
        return pre.beta;
      var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
      if (pre) {
        var curve = this.curve;
        var endoMul = function(p) {
          return curve.point(p.x.redMul(curve.endo.beta), p.y);
        };
        pre.beta = beta;
        beta.precomputed = {
          beta: null,
          naf: pre.naf && {
            wnd: pre.naf.wnd,
            points: pre.naf.points.map(endoMul)
          },
          doubles: pre.doubles && {
            step: pre.doubles.step,
            points: pre.doubles.points.map(endoMul)
          }
        };
      }
      return beta;
    };
    Point.prototype.toJSON = function toJSON() {
      if (!this.precomputed)
        return [this.x, this.y];
      return [this.x, this.y, this.precomputed && {
        doubles: this.precomputed.doubles && {
          step: this.precomputed.doubles.step,
          points: this.precomputed.doubles.points.slice(1)
        },
        naf: this.precomputed.naf && {
          wnd: this.precomputed.naf.wnd,
          points: this.precomputed.naf.points.slice(1)
        }
      }];
    };
    Point.fromJSON = function fromJSON(curve, obj, red) {
      if (typeof obj === "string")
        obj = JSON.parse(obj);
      var res = curve.point(obj[0], obj[1], red);
      if (!obj[2])
        return res;
      function obj2point(obj2) {
        return curve.point(obj2[0], obj2[1], red);
      }
      var pre = obj[2];
      res.precomputed = {
        beta: null,
        doubles: pre.doubles && {
          step: pre.doubles.step,
          points: [res].concat(pre.doubles.points.map(obj2point))
        },
        naf: pre.naf && {
          wnd: pre.naf.wnd,
          points: [res].concat(pre.naf.points.map(obj2point))
        }
      };
      return res;
    };
    Point.prototype.inspect = function inspect() {
      if (this.isInfinity())
        return "<EC Point Infinity>";
      return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
    };
    Point.prototype.isInfinity = function isInfinity() {
      return this.inf;
    };
    Point.prototype.add = function add(p) {
      if (this.inf)
        return p;
      if (p.inf)
        return this;
      if (this.eq(p))
        return this.dbl();
      if (this.neg().eq(p))
        return this.curve.point(null, null);
      if (this.x.cmp(p.x) === 0)
        return this.curve.point(null, null);
      var c = this.y.redSub(p.y);
      if (c.cmpn(0) !== 0)
        c = c.redMul(this.x.redSub(p.x).redInvm());
      var nx = c.redSqr().redISub(this.x).redISub(p.x);
      var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
      return this.curve.point(nx, ny);
    };
    Point.prototype.dbl = function dbl() {
      if (this.inf)
        return this;
      var ys1 = this.y.redAdd(this.y);
      if (ys1.cmpn(0) === 0)
        return this.curve.point(null, null);
      var a = this.curve.a;
      var x2 = this.x.redSqr();
      var dyinv = ys1.redInvm();
      var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);
      var nx = c.redSqr().redISub(this.x.redAdd(this.x));
      var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
      return this.curve.point(nx, ny);
    };
    Point.prototype.getX = function getX() {
      return this.x.fromRed();
    };
    Point.prototype.getY = function getY() {
      return this.y.fromRed();
    };
    Point.prototype.mul = function mul(k) {
      k = new BN(k, 16);
      if (this.isInfinity())
        return this;
      else if (this._hasDoubles(k))
        return this.curve._fixedNafMul(this, k);
      else if (this.curve.endo)
        return this.curve._endoWnafMulAdd([this], [k]);
      else
        return this.curve._wnafMul(this, k);
    };
    Point.prototype.mulAdd = function mulAdd(k1, p2, k2) {
      var points = [this, p2];
      var coeffs = [k1, k2];
      if (this.curve.endo)
        return this.curve._endoWnafMulAdd(points, coeffs);
      else
        return this.curve._wnafMulAdd(1, points, coeffs, 2);
    };
    Point.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {
      var points = [this, p2];
      var coeffs = [k1, k2];
      if (this.curve.endo)
        return this.curve._endoWnafMulAdd(points, coeffs, true);
      else
        return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
    };
    Point.prototype.eq = function eq(p) {
      return this === p || this.inf === p.inf && (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
    };
    Point.prototype.neg = function neg(_precompute) {
      if (this.inf)
        return this;
      var res = this.curve.point(this.x, this.y.redNeg());
      if (_precompute && this.precomputed) {
        var pre = this.precomputed;
        var negate = function(p) {
          return p.neg();
        };
        res.precomputed = {
          naf: pre.naf && {
            wnd: pre.naf.wnd,
            points: pre.naf.points.map(negate)
          },
          doubles: pre.doubles && {
            step: pre.doubles.step,
            points: pre.doubles.points.map(negate)
          }
        };
      }
      return res;
    };
    Point.prototype.toJ = function toJ() {
      if (this.inf)
        return this.curve.jpoint(null, null, null);
      var res = this.curve.jpoint(this.x, this.y, this.curve.one);
      return res;
    };
    function JPoint(curve, x, y, z) {
      Base.BasePoint.call(this, curve, "jacobian");
      if (x === null && y === null && z === null) {
        this.x = this.curve.one;
        this.y = this.curve.one;
        this.z = new BN(0);
      } else {
        this.x = new BN(x, 16);
        this.y = new BN(y, 16);
        this.z = new BN(z, 16);
      }
      if (!this.x.red)
        this.x = this.x.toRed(this.curve.red);
      if (!this.y.red)
        this.y = this.y.toRed(this.curve.red);
      if (!this.z.red)
        this.z = this.z.toRed(this.curve.red);
      this.zOne = this.z === this.curve.one;
    }
    inherits(JPoint, Base.BasePoint);
    ShortCurve.prototype.jpoint = function jpoint(x, y, z) {
      return new JPoint(this, x, y, z);
    };
    JPoint.prototype.toP = function toP() {
      if (this.isInfinity())
        return this.curve.point(null, null);
      var zinv = this.z.redInvm();
      var zinv2 = zinv.redSqr();
      var ax = this.x.redMul(zinv2);
      var ay = this.y.redMul(zinv2).redMul(zinv);
      return this.curve.point(ax, ay);
    };
    JPoint.prototype.neg = function neg() {
      return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
    };
    JPoint.prototype.add = function add(p) {
      if (this.isInfinity())
        return p;
      if (p.isInfinity())
        return this;
      var pz2 = p.z.redSqr();
      var z2 = this.z.redSqr();
      var u1 = this.x.redMul(pz2);
      var u2 = p.x.redMul(z2);
      var s1 = this.y.redMul(pz2.redMul(p.z));
      var s2 = p.y.redMul(z2.redMul(this.z));
      var h = u1.redSub(u2);
      var r = s1.redSub(s2);
      if (h.cmpn(0) === 0) {
        if (r.cmpn(0) !== 0)
          return this.curve.jpoint(null, null, null);
        else
          return this.dbl();
      }
      var h2 = h.redSqr();
      var h3 = h2.redMul(h);
      var v = u1.redMul(h2);
      var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
      var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
      var nz = this.z.redMul(p.z).redMul(h);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.mixedAdd = function mixedAdd(p) {
      if (this.isInfinity())
        return p.toJ();
      if (p.isInfinity())
        return this;
      var z2 = this.z.redSqr();
      var u1 = this.x;
      var u2 = p.x.redMul(z2);
      var s1 = this.y;
      var s2 = p.y.redMul(z2).redMul(this.z);
      var h = u1.redSub(u2);
      var r = s1.redSub(s2);
      if (h.cmpn(0) === 0) {
        if (r.cmpn(0) !== 0)
          return this.curve.jpoint(null, null, null);
        else
          return this.dbl();
      }
      var h2 = h.redSqr();
      var h3 = h2.redMul(h);
      var v = u1.redMul(h2);
      var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
      var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
      var nz = this.z.redMul(h);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.dblp = function dblp(pow) {
      if (pow === 0)
        return this;
      if (this.isInfinity())
        return this;
      if (!pow)
        return this.dbl();
      var i;
      if (this.curve.zeroA || this.curve.threeA) {
        var r = this;
        for (i = 0; i < pow; i++)
          r = r.dbl();
        return r;
      }
      var a = this.curve.a;
      var tinv = this.curve.tinv;
      var jx = this.x;
      var jy = this.y;
      var jz = this.z;
      var jz4 = jz.redSqr().redSqr();
      var jyd = jy.redAdd(jy);
      for (i = 0; i < pow; i++) {
        var jx2 = jx.redSqr();
        var jyd2 = jyd.redSqr();
        var jyd4 = jyd2.redSqr();
        var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
        var t1 = jx.redMul(jyd2);
        var nx = c.redSqr().redISub(t1.redAdd(t1));
        var t2 = t1.redISub(nx);
        var dny = c.redMul(t2);
        dny = dny.redIAdd(dny).redISub(jyd4);
        var nz = jyd.redMul(jz);
        if (i + 1 < pow)
          jz4 = jz4.redMul(jyd4);
        jx = nx;
        jz = nz;
        jyd = dny;
      }
      return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
    };
    JPoint.prototype.dbl = function dbl() {
      if (this.isInfinity())
        return this;
      if (this.curve.zeroA)
        return this._zeroDbl();
      else if (this.curve.threeA)
        return this._threeDbl();
      else
        return this._dbl();
    };
    JPoint.prototype._zeroDbl = function _zeroDbl() {
      var nx;
      var ny;
      var nz;
      if (this.zOne) {
        var xx = this.x.redSqr();
        var yy = this.y.redSqr();
        var yyyy = yy.redSqr();
        var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
        s = s.redIAdd(s);
        var m = xx.redAdd(xx).redIAdd(xx);
        var t = m.redSqr().redISub(s).redISub(s);
        var yyyy8 = yyyy.redIAdd(yyyy);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        nx = t;
        ny = m.redMul(s.redISub(t)).redISub(yyyy8);
        nz = this.y.redAdd(this.y);
      } else {
        var a = this.x.redSqr();
        var b = this.y.redSqr();
        var c = b.redSqr();
        var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
        d = d.redIAdd(d);
        var e = a.redAdd(a).redIAdd(a);
        var f = e.redSqr();
        var c8 = c.redIAdd(c);
        c8 = c8.redIAdd(c8);
        c8 = c8.redIAdd(c8);
        nx = f.redISub(d).redISub(d);
        ny = e.redMul(d.redISub(nx)).redISub(c8);
        nz = this.y.redMul(this.z);
        nz = nz.redIAdd(nz);
      }
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype._threeDbl = function _threeDbl() {
      var nx;
      var ny;
      var nz;
      if (this.zOne) {
        var xx = this.x.redSqr();
        var yy = this.y.redSqr();
        var yyyy = yy.redSqr();
        var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
        s = s.redIAdd(s);
        var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
        var t = m.redSqr().redISub(s).redISub(s);
        nx = t;
        var yyyy8 = yyyy.redIAdd(yyyy);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        ny = m.redMul(s.redISub(t)).redISub(yyyy8);
        nz = this.y.redAdd(this.y);
      } else {
        var delta = this.z.redSqr();
        var gamma = this.y.redSqr();
        var beta = this.x.redMul(gamma);
        var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
        alpha = alpha.redAdd(alpha).redIAdd(alpha);
        var beta4 = beta.redIAdd(beta);
        beta4 = beta4.redIAdd(beta4);
        var beta8 = beta4.redAdd(beta4);
        nx = alpha.redSqr().redISub(beta8);
        nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
        var ggamma8 = gamma.redSqr();
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
      }
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype._dbl = function _dbl() {
      var a = this.curve.a;
      var jx = this.x;
      var jy = this.y;
      var jz = this.z;
      var jz4 = jz.redSqr().redSqr();
      var jx2 = jx.redSqr();
      var jy2 = jy.redSqr();
      var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
      var jxd4 = jx.redAdd(jx);
      jxd4 = jxd4.redIAdd(jxd4);
      var t1 = jxd4.redMul(jy2);
      var nx = c.redSqr().redISub(t1.redAdd(t1));
      var t2 = t1.redISub(nx);
      var jyd8 = jy2.redSqr();
      jyd8 = jyd8.redIAdd(jyd8);
      jyd8 = jyd8.redIAdd(jyd8);
      jyd8 = jyd8.redIAdd(jyd8);
      var ny = c.redMul(t2).redISub(jyd8);
      var nz = jy.redAdd(jy).redMul(jz);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.trpl = function trpl() {
      if (!this.curve.zeroA)
        return this.dbl().add(this);
      var xx = this.x.redSqr();
      var yy = this.y.redSqr();
      var zz = this.z.redSqr();
      var yyyy = yy.redSqr();
      var m = xx.redAdd(xx).redIAdd(xx);
      var mm = m.redSqr();
      var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
      e = e.redIAdd(e);
      e = e.redAdd(e).redIAdd(e);
      e = e.redISub(mm);
      var ee = e.redSqr();
      var t = yyyy.redIAdd(yyyy);
      t = t.redIAdd(t);
      t = t.redIAdd(t);
      t = t.redIAdd(t);
      var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);
      var yyu4 = yy.redMul(u);
      yyu4 = yyu4.redIAdd(yyu4);
      yyu4 = yyu4.redIAdd(yyu4);
      var nx = this.x.redMul(ee).redISub(yyu4);
      nx = nx.redIAdd(nx);
      nx = nx.redIAdd(nx);
      var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));
      ny = ny.redIAdd(ny);
      ny = ny.redIAdd(ny);
      ny = ny.redIAdd(ny);
      var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.mul = function mul(k, kbase) {
      k = new BN(k, kbase);
      return this.curve._wnafMul(this, k);
    };
    JPoint.prototype.eq = function eq(p) {
      if (p.type === "affine")
        return this.eq(p.toJ());
      if (this === p)
        return true;
      var z2 = this.z.redSqr();
      var pz2 = p.z.redSqr();
      if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)
        return false;
      var z3 = z2.redMul(this.z);
      var pz3 = pz2.redMul(p.z);
      return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
    };
    JPoint.prototype.eqXToP = function eqXToP(x) {
      var zs = this.z.redSqr();
      var rx = x.toRed(this.curve.red).redMul(zs);
      if (this.x.cmp(rx) === 0)
        return true;
      var xc = x.clone();
      var t = this.curve.redN.redMul(zs);
      for (; ; ) {
        xc.iadd(this.curve.n);
        if (xc.cmp(this.curve.p) >= 0)
          return false;
        rx.redIAdd(t);
        if (this.x.cmp(rx) === 0)
          return true;
      }
    };
    JPoint.prototype.inspect = function inspect() {
      if (this.isInfinity())
        return "<EC JPoint Infinity>";
      return "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
    };
    JPoint.prototype.isInfinity = function isInfinity() {
      return this.z.cmpn(0) === 0;
    };
  }
});

// node_modules/elliptic/lib/elliptic/curve/mont.js
var require_mont = __commonJS({
  "node_modules/elliptic/lib/elliptic/curve/mont.js"(exports2, module2) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var BN = require_bn();
    var inherits = require_inherits();
    var Base = require_base();
    var utils = require_utils2();
    function MontCurve(conf) {
      Base.call(this, "mont", conf);
      this.a = new BN(conf.a, 16).toRed(this.red);
      this.b = new BN(conf.b, 16).toRed(this.red);
      this.i4 = new BN(4).toRed(this.red).redInvm();
      this.two = new BN(2).toRed(this.red);
      this.a24 = this.i4.redMul(this.a.redAdd(this.two));
    }
    inherits(MontCurve, Base);
    module2.exports = MontCurve;
    MontCurve.prototype.validate = function validate(point) {
      var x = point.normalize().x;
      var x2 = x.redSqr();
      var rhs = x2.redMul(x).redAdd(x2.redMul(this.a)).redAdd(x);
      var y = rhs.redSqrt();
      return y.redSqr().cmp(rhs) === 0;
    };
    function Point(curve, x, z) {
      Base.BasePoint.call(this, curve, "projective");
      if (x === null && z === null) {
        this.x = this.curve.one;
        this.z = this.curve.zero;
      } else {
        this.x = new BN(x, 16);
        this.z = new BN(z, 16);
        if (!this.x.red)
          this.x = this.x.toRed(this.curve.red);
        if (!this.z.red)
          this.z = this.z.toRed(this.curve.red);
      }
    }
    inherits(Point, Base.BasePoint);
    MontCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
      return this.point(utils.toArray(bytes, enc), 1);
    };
    MontCurve.prototype.point = function point(x, z) {
      return new Point(this, x, z);
    };
    MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
      return Point.fromJSON(this, obj);
    };
    Point.prototype.precompute = function precompute() {
    };
    Point.prototype._encode = function _encode() {
      return this.getX().toArray("be", this.curve.p.byteLength());
    };
    Point.fromJSON = function fromJSON(curve, obj) {
      return new Point(curve, obj[0], obj[1] || curve.one);
    };
    Point.prototype.inspect = function inspect() {
      if (this.isInfinity())
        return "<EC Point Infinity>";
      return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
    };
    Point.prototype.isInfinity = function isInfinity() {
      return this.z.cmpn(0) === 0;
    };
    Point.prototype.dbl = function dbl() {
      var a = this.x.redAdd(this.z);
      var aa = a.redSqr();
      var b = this.x.redSub(this.z);
      var bb = b.redSqr();
      var c = aa.redSub(bb);
      var nx = aa.redMul(bb);
      var nz = c.redMul(bb.redAdd(this.curve.a24.redMul(c)));
      return this.curve.point(nx, nz);
    };
    Point.prototype.add = function add() {
      throw new Error("Not supported on Montgomery curve");
    };
    Point.prototype.diffAdd = function diffAdd(p, diff) {
      var a = this.x.redAdd(this.z);
      var b = this.x.redSub(this.z);
      var c = p.x.redAdd(p.z);
      var d = p.x.redSub(p.z);
      var da = d.redMul(a);
      var cb = c.redMul(b);
      var nx = diff.z.redMul(da.redAdd(cb).redSqr());
      var nz = diff.x.redMul(da.redISub(cb).redSqr());
      return this.curve.point(nx, nz);
    };
    Point.prototype.mul = function mul(k) {
      var t = k.clone();
      var a = this;
      var b = this.curve.point(null, null);
      var c = this;
      for (var bits = []; t.cmpn(0) !== 0; t.iushrn(1))
        bits.push(t.andln(1));
      for (var i = bits.length - 1; i >= 0; i--) {
        if (bits[i] === 0) {
          a = a.diffAdd(b, c);
          b = b.dbl();
        } else {
          b = a.diffAdd(b, c);
          a = a.dbl();
        }
      }
      return b;
    };
    Point.prototype.mulAdd = function mulAdd() {
      throw new Error("Not supported on Montgomery curve");
    };
    Point.prototype.jumlAdd = function jumlAdd() {
      throw new Error("Not supported on Montgomery curve");
    };
    Point.prototype.eq = function eq(other) {
      return this.getX().cmp(other.getX()) === 0;
    };
    Point.prototype.normalize = function normalize() {
      this.x = this.x.redMul(this.z.redInvm());
      this.z = this.curve.one;
      return this;
    };
    Point.prototype.getX = function getX() {
      this.normalize();
      return this.x.fromRed();
    };
  }
});

// node_modules/elliptic/lib/elliptic/curve/edwards.js
var require_edwards = __commonJS({
  "node_modules/elliptic/lib/elliptic/curve/edwards.js"(exports2, module2) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var utils = require_utils2();
    var BN = require_bn();
    var inherits = require_inherits();
    var Base = require_base();
    var assert = utils.assert;
    function EdwardsCurve(conf) {
      this.twisted = (conf.a | 0) !== 1;
      this.mOneA = this.twisted && (conf.a | 0) === -1;
      this.extended = this.mOneA;
      Base.call(this, "edwards", conf);
      this.a = new BN(conf.a, 16).umod(this.red.m);
      this.a = this.a.toRed(this.red);
      this.c = new BN(conf.c, 16).toRed(this.red);
      this.c2 = this.c.redSqr();
      this.d = new BN(conf.d, 16).toRed(this.red);
      this.dd = this.d.redAdd(this.d);
      assert(!this.twisted || this.c.fromRed().cmpn(1) === 0);
      this.oneC = (conf.c | 0) === 1;
    }
    inherits(EdwardsCurve, Base);
    module2.exports = EdwardsCurve;
    EdwardsCurve.prototype._mulA = function _mulA(num) {
      if (this.mOneA)
        return num.redNeg();
      else
        return this.a.redMul(num);
    };
    EdwardsCurve.prototype._mulC = function _mulC(num) {
      if (this.oneC)
        return num;
      else
        return this.c.redMul(num);
    };
    EdwardsCurve.prototype.jpoint = function jpoint(x, y, z, t) {
      return this.point(x, y, z, t);
    };
    EdwardsCurve.prototype.pointFromX = function pointFromX(x, odd) {
      x = new BN(x, 16);
      if (!x.red)
        x = x.toRed(this.red);
      var x2 = x.redSqr();
      var rhs = this.c2.redSub(this.a.redMul(x2));
      var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x2));
      var y2 = rhs.redMul(lhs.redInvm());
      var y = y2.redSqrt();
      if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      var isOdd = y.fromRed().isOdd();
      if (odd && !isOdd || !odd && isOdd)
        y = y.redNeg();
      return this.point(x, y);
    };
    EdwardsCurve.prototype.pointFromY = function pointFromY(y, odd) {
      y = new BN(y, 16);
      if (!y.red)
        y = y.toRed(this.red);
      var y2 = y.redSqr();
      var lhs = y2.redSub(this.c2);
      var rhs = y2.redMul(this.d).redMul(this.c2).redSub(this.a);
      var x2 = lhs.redMul(rhs.redInvm());
      if (x2.cmp(this.zero) === 0) {
        if (odd)
          throw new Error("invalid point");
        else
          return this.point(this.zero, y);
      }
      var x = x2.redSqrt();
      if (x.redSqr().redSub(x2).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      if (x.fromRed().isOdd() !== odd)
        x = x.redNeg();
      return this.point(x, y);
    };
    EdwardsCurve.prototype.validate = function validate(point) {
      if (point.isInfinity())
        return true;
      point.normalize();
      var x2 = point.x.redSqr();
      var y2 = point.y.redSqr();
      var lhs = x2.redMul(this.a).redAdd(y2);
      var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y2)));
      return lhs.cmp(rhs) === 0;
    };
    function Point(curve, x, y, z, t) {
      Base.BasePoint.call(this, curve, "projective");
      if (x === null && y === null && z === null) {
        this.x = this.curve.zero;
        this.y = this.curve.one;
        this.z = this.curve.one;
        this.t = this.curve.zero;
        this.zOne = true;
      } else {
        this.x = new BN(x, 16);
        this.y = new BN(y, 16);
        this.z = z ? new BN(z, 16) : this.curve.one;
        this.t = t && new BN(t, 16);
        if (!this.x.red)
          this.x = this.x.toRed(this.curve.red);
        if (!this.y.red)
          this.y = this.y.toRed(this.curve.red);
        if (!this.z.red)
          this.z = this.z.toRed(this.curve.red);
        if (this.t && !this.t.red)
          this.t = this.t.toRed(this.curve.red);
        this.zOne = this.z === this.curve.one;
        if (this.curve.extended && !this.t) {
          this.t = this.x.redMul(this.y);
          if (!this.zOne)
            this.t = this.t.redMul(this.z.redInvm());
        }
      }
    }
    inherits(Point, Base.BasePoint);
    EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
      return Point.fromJSON(this, obj);
    };
    EdwardsCurve.prototype.point = function point(x, y, z, t) {
      return new Point(this, x, y, z, t);
    };
    Point.fromJSON = function fromJSON(curve, obj) {
      return new Point(curve, obj[0], obj[1], obj[2]);
    };
    Point.prototype.inspect = function inspect() {
      if (this.isInfinity())
        return "<EC Point Infinity>";
      return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
    };
    Point.prototype.isInfinity = function isInfinity() {
      return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
    };
    Point.prototype._extDbl = function _extDbl() {
      var a = this.x.redSqr();
      var b = this.y.redSqr();
      var c = this.z.redSqr();
      c = c.redIAdd(c);
      var d = this.curve._mulA(a);
      var e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b);
      var g = d.redAdd(b);
      var f = g.redSub(c);
      var h = d.redSub(b);
      var nx = e.redMul(f);
      var ny = g.redMul(h);
      var nt = e.redMul(h);
      var nz = f.redMul(g);
      return this.curve.point(nx, ny, nz, nt);
    };
    Point.prototype._projDbl = function _projDbl() {
      var b = this.x.redAdd(this.y).redSqr();
      var c = this.x.redSqr();
      var d = this.y.redSqr();
      var nx;
      var ny;
      var nz;
      var e;
      var h;
      var j;
      if (this.curve.twisted) {
        e = this.curve._mulA(c);
        var f = e.redAdd(d);
        if (this.zOne) {
          nx = b.redSub(c).redSub(d).redMul(f.redSub(this.curve.two));
          ny = f.redMul(e.redSub(d));
          nz = f.redSqr().redSub(f).redSub(f);
        } else {
          h = this.z.redSqr();
          j = f.redSub(h).redISub(h);
          nx = b.redSub(c).redISub(d).redMul(j);
          ny = f.redMul(e.redSub(d));
          nz = f.redMul(j);
        }
      } else {
        e = c.redAdd(d);
        h = this.curve._mulC(this.z).redSqr();
        j = e.redSub(h).redSub(h);
        nx = this.curve._mulC(b.redISub(e)).redMul(j);
        ny = this.curve._mulC(e).redMul(c.redISub(d));
        nz = e.redMul(j);
      }
      return this.curve.point(nx, ny, nz);
    };
    Point.prototype.dbl = function dbl() {
      if (this.isInfinity())
        return this;
      if (this.curve.extended)
        return this._extDbl();
      else
        return this._projDbl();
    };
    Point.prototype._extAdd = function _extAdd(p) {
      var a = this.y.redSub(this.x).redMul(p.y.redSub(p.x));
      var b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x));
      var c = this.t.redMul(this.curve.dd).redMul(p.t);
      var d = this.z.redMul(p.z.redAdd(p.z));
      var e = b.redSub(a);
      var f = d.redSub(c);
      var g = d.redAdd(c);
      var h = b.redAdd(a);
      var nx = e.redMul(f);
      var ny = g.redMul(h);
      var nt = e.redMul(h);
      var nz = f.redMul(g);
      return this.curve.point(nx, ny, nz, nt);
    };
    Point.prototype._projAdd = function _projAdd(p) {
      var a = this.z.redMul(p.z);
      var b = a.redSqr();
      var c = this.x.redMul(p.x);
      var d = this.y.redMul(p.y);
      var e = this.curve.d.redMul(c).redMul(d);
      var f = b.redSub(e);
      var g = b.redAdd(e);
      var tmp = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y)).redISub(c).redISub(d);
      var nx = a.redMul(f).redMul(tmp);
      var ny;
      var nz;
      if (this.curve.twisted) {
        ny = a.redMul(g).redMul(d.redSub(this.curve._mulA(c)));
        nz = f.redMul(g);
      } else {
        ny = a.redMul(g).redMul(d.redSub(c));
        nz = this.curve._mulC(f).redMul(g);
      }
      return this.curve.point(nx, ny, nz);
    };
    Point.prototype.add = function add(p) {
      if (this.isInfinity())
        return p;
      if (p.isInfinity())
        return this;
      if (this.curve.extended)
        return this._extAdd(p);
      else
        return this._projAdd(p);
    };
    Point.prototype.mul = function mul(k) {
      if (this._hasDoubles(k))
        return this.curve._fixedNafMul(this, k);
      else
        return this.curve._wnafMul(this, k);
    };
    Point.prototype.mulAdd = function mulAdd(k1, p, k2) {
      return this.curve._wnafMulAdd(1, [this, p], [k1, k2], 2, false);
    };
    Point.prototype.jmulAdd = function jmulAdd(k1, p, k2) {
      return this.curve._wnafMulAdd(1, [this, p], [k1, k2], 2, true);
    };
    Point.prototype.normalize = function normalize() {
      if (this.zOne)
        return this;
      var zi = this.z.redInvm();
      this.x = this.x.redMul(zi);
      this.y = this.y.redMul(zi);
      if (this.t)
        this.t = this.t.redMul(zi);
      this.z = this.curve.one;
      this.zOne = true;
      return this;
    };
    Point.prototype.neg = function neg() {
      return this.curve.point(
        this.x.redNeg(),
        this.y,
        this.z,
        this.t && this.t.redNeg()
      );
    };
    Point.prototype.getX = function getX() {
      this.normalize();
      return this.x.fromRed();
    };
    Point.prototype.getY = function getY() {
      this.normalize();
      return this.y.fromRed();
    };
    Point.prototype.eq = function eq(other) {
      return this === other || this.getX().cmp(other.getX()) === 0 && this.getY().cmp(other.getY()) === 0;
    };
    Point.prototype.eqXToP = function eqXToP(x) {
      var rx = x.toRed(this.curve.red).redMul(this.z);
      if (this.x.cmp(rx) === 0)
        return true;
      var xc = x.clone();
      var t = this.curve.redN.redMul(this.z);
      for (; ; ) {
        xc.iadd(this.curve.n);
        if (xc.cmp(this.curve.p) >= 0)
          return false;
        rx.redIAdd(t);
        if (this.x.cmp(rx) === 0)
          return true;
      }
    };
    Point.prototype.toP = Point.prototype.normalize;
    Point.prototype.mixedAdd = Point.prototype.add;
  }
});

// node_modules/elliptic/lib/elliptic/curve/index.js
var require_curve = __commonJS({
  "node_modules/elliptic/lib/elliptic/curve/index.js"(exports2) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var curve = exports2;
    curve.base = require_base();
    curve.short = require_short();
    curve.mont = require_mont();
    curve.edwards = require_edwards();
  }
});

// node_modules/hash.js/lib/hash/utils.js
var require_utils3 = __commonJS({
  "node_modules/hash.js/lib/hash/utils.js"(exports2) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var assert = require_minimalistic_assert();
    var inherits = require_inherits();
    exports2.inherits = inherits;
    function isSurrogatePair(msg, i) {
      if ((msg.charCodeAt(i) & 64512) !== 55296) {
        return false;
      }
      if (i < 0 || i + 1 >= msg.length) {
        return false;
      }
      return (msg.charCodeAt(i + 1) & 64512) === 56320;
    }
    function toArray(msg, enc) {
      if (Array.isArray(msg))
        return msg.slice();
      if (!msg)
        return [];
      var res = [];
      if (typeof msg === "string") {
        if (!enc) {
          var p = 0;
          for (var i = 0; i < msg.length; i++) {
            var c = msg.charCodeAt(i);
            if (c < 128) {
              res[p++] = c;
            } else if (c < 2048) {
              res[p++] = c >> 6 | 192;
              res[p++] = c & 63 | 128;
            } else if (isSurrogatePair(msg, i)) {
              c = 65536 + ((c & 1023) << 10) + (msg.charCodeAt(++i) & 1023);
              res[p++] = c >> 18 | 240;
              res[p++] = c >> 12 & 63 | 128;
              res[p++] = c >> 6 & 63 | 128;
              res[p++] = c & 63 | 128;
            } else {
              res[p++] = c >> 12 | 224;
              res[p++] = c >> 6 & 63 | 128;
              res[p++] = c & 63 | 128;
            }
          }
        } else if (enc === "hex") {
          msg = msg.replace(/[^a-z0-9]+/ig, "");
          if (msg.length % 2 !== 0)
            msg = "0" + msg;
          for (i = 0; i < msg.length; i += 2)
            res.push(parseInt(msg[i] + msg[i + 1], 16));
        }
      } else {
        for (i = 0; i < msg.length; i++)
          res[i] = msg[i] | 0;
      }
      return res;
    }
    exports2.toArray = toArray;
    function toHex(msg) {
      var res = "";
      for (var i = 0; i < msg.length; i++)
        res += zero2(msg[i].toString(16));
      return res;
    }
    exports2.toHex = toHex;
    function htonl(w) {
      var res = w >>> 24 | w >>> 8 & 65280 | w << 8 & 16711680 | (w & 255) << 24;
      return res >>> 0;
    }
    exports2.htonl = htonl;
    function toHex32(msg, endian) {
      var res = "";
      for (var i = 0; i < msg.length; i++) {
        var w = msg[i];
        if (endian === "little")
          w = htonl(w);
        res += zero8(w.toString(16));
      }
      return res;
    }
    exports2.toHex32 = toHex32;
    function zero2(word) {
      if (word.length === 1)
        return "0" + word;
      else
        return word;
    }
    exports2.zero2 = zero2;
    function zero8(word) {
      if (word.length === 7)
        return "0" + word;
      else if (word.length === 6)
        return "00" + word;
      else if (word.length === 5)
        return "000" + word;
      else if (word.length === 4)
        return "0000" + word;
      else if (word.length === 3)
        return "00000" + word;
      else if (word.length === 2)
        return "000000" + word;
      else if (word.length === 1)
        return "0000000" + word;
      else
        return word;
    }
    exports2.zero8 = zero8;
    function join32(msg, start, end, endian) {
      var len = end - start;
      assert(len % 4 === 0);
      var res = new Array(len / 4);
      for (var i = 0, k = start; i < res.length; i++, k += 4) {
        var w;
        if (endian === "big")
          w = msg[k] << 24 | msg[k + 1] << 16 | msg[k + 2] << 8 | msg[k + 3];
        else
          w = msg[k + 3] << 24 | msg[k + 2] << 16 | msg[k + 1] << 8 | msg[k];
        res[i] = w >>> 0;
      }
      return res;
    }
    exports2.join32 = join32;
    function split32(msg, endian) {
      var res = new Array(msg.length * 4);
      for (var i = 0, k = 0; i < msg.length; i++, k += 4) {
        var m = msg[i];
        if (endian === "big") {
          res[k] = m >>> 24;
          res[k + 1] = m >>> 16 & 255;
          res[k + 2] = m >>> 8 & 255;
          res[k + 3] = m & 255;
        } else {
          res[k + 3] = m >>> 24;
          res[k + 2] = m >>> 16 & 255;
          res[k + 1] = m >>> 8 & 255;
          res[k] = m & 255;
        }
      }
      return res;
    }
    exports2.split32 = split32;
    function rotr32(w, b) {
      return w >>> b | w << 32 - b;
    }
    exports2.rotr32 = rotr32;
    function rotl32(w, b) {
      return w << b | w >>> 32 - b;
    }
    exports2.rotl32 = rotl32;
    function sum32(a, b) {
      return a + b >>> 0;
    }
    exports2.sum32 = sum32;
    function sum32_3(a, b, c) {
      return a + b + c >>> 0;
    }
    exports2.sum32_3 = sum32_3;
    function sum32_4(a, b, c, d) {
      return a + b + c + d >>> 0;
    }
    exports2.sum32_4 = sum32_4;
    function sum32_5(a, b, c, d, e) {
      return a + b + c + d + e >>> 0;
    }
    exports2.sum32_5 = sum32_5;
    function sum64(buf, pos, ah, al) {
      var bh = buf[pos];
      var bl = buf[pos + 1];
      var lo = al + bl >>> 0;
      var hi = (lo < al ? 1 : 0) + ah + bh;
      buf[pos] = hi >>> 0;
      buf[pos + 1] = lo;
    }
    exports2.sum64 = sum64;
    function sum64_hi(ah, al, bh, bl) {
      var lo = al + bl >>> 0;
      var hi = (lo < al ? 1 : 0) + ah + bh;
      return hi >>> 0;
    }
    exports2.sum64_hi = sum64_hi;
    function sum64_lo(ah, al, bh, bl) {
      var lo = al + bl;
      return lo >>> 0;
    }
    exports2.sum64_lo = sum64_lo;
    function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
      var carry = 0;
      var lo = al;
      lo = lo + bl >>> 0;
      carry += lo < al ? 1 : 0;
      lo = lo + cl >>> 0;
      carry += lo < cl ? 1 : 0;
      lo = lo + dl >>> 0;
      carry += lo < dl ? 1 : 0;
      var hi = ah + bh + ch + dh + carry;
      return hi >>> 0;
    }
    exports2.sum64_4_hi = sum64_4_hi;
    function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
      var lo = al + bl + cl + dl;
      return lo >>> 0;
    }
    exports2.sum64_4_lo = sum64_4_lo;
    function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
      var carry = 0;
      var lo = al;
      lo = lo + bl >>> 0;
      carry += lo < al ? 1 : 0;
      lo = lo + cl >>> 0;
      carry += lo < cl ? 1 : 0;
      lo = lo + dl >>> 0;
      carry += lo < dl ? 1 : 0;
      lo = lo + el >>> 0;
      carry += lo < el ? 1 : 0;
      var hi = ah + bh + ch + dh + eh + carry;
      return hi >>> 0;
    }
    exports2.sum64_5_hi = sum64_5_hi;
    function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
      var lo = al + bl + cl + dl + el;
      return lo >>> 0;
    }
    exports2.sum64_5_lo = sum64_5_lo;
    function rotr64_hi(ah, al, num) {
      var r = al << 32 - num | ah >>> num;
      return r >>> 0;
    }
    exports2.rotr64_hi = rotr64_hi;
    function rotr64_lo(ah, al, num) {
      var r = ah << 32 - num | al >>> num;
      return r >>> 0;
    }
    exports2.rotr64_lo = rotr64_lo;
    function shr64_hi(ah, al, num) {
      return ah >>> num;
    }
    exports2.shr64_hi = shr64_hi;
    function shr64_lo(ah, al, num) {
      var r = ah << 32 - num | al >>> num;
      return r >>> 0;
    }
    exports2.shr64_lo = shr64_lo;
  }
});

// node_modules/hash.js/lib/hash/common.js
var require_common = __commonJS({
  "node_modules/hash.js/lib/hash/common.js"(exports2) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var utils = require_utils3();
    var assert = require_minimalistic_assert();
    function BlockHash() {
      this.pending = null;
      this.pendingTotal = 0;
      this.blockSize = this.constructor.blockSize;
      this.outSize = this.constructor.outSize;
      this.hmacStrength = this.constructor.hmacStrength;
      this.padLength = this.constructor.padLength / 8;
      this.endian = "big";
      this._delta8 = this.blockSize / 8;
      this._delta32 = this.blockSize / 32;
    }
    exports2.BlockHash = BlockHash;
    BlockHash.prototype.update = function update(msg, enc) {
      msg = utils.toArray(msg, enc);
      if (!this.pending)
        this.pending = msg;
      else
        this.pending = this.pending.concat(msg);
      this.pendingTotal += msg.length;
      if (this.pending.length >= this._delta8) {
        msg = this.pending;
        var r = msg.length % this._delta8;
        this.pending = msg.slice(msg.length - r, msg.length);
        if (this.pending.length === 0)
          this.pending = null;
        msg = utils.join32(msg, 0, msg.length - r, this.endian);
        for (var i = 0; i < msg.length; i += this._delta32)
          this._update(msg, i, i + this._delta32);
      }
      return this;
    };
    BlockHash.prototype.digest = function digest(enc) {
      this.update(this._pad());
      assert(this.pending === null);
      return this._digest(enc);
    };
    BlockHash.prototype._pad = function pad() {
      var len = this.pendingTotal;
      var bytes = this._delta8;
      var k = bytes - (len + this.padLength) % bytes;
      var res = new Array(k + this.padLength);
      res[0] = 128;
      for (var i = 1; i < k; i++)
        res[i] = 0;
      len <<= 3;
      if (this.endian === "big") {
        for (var t = 8; t < this.padLength; t++)
          res[i++] = 0;
        res[i++] = 0;
        res[i++] = 0;
        res[i++] = 0;
        res[i++] = 0;
        res[i++] = len >>> 24 & 255;
        res[i++] = len >>> 16 & 255;
        res[i++] = len >>> 8 & 255;
        res[i++] = len & 255;
      } else {
        res[i++] = len & 255;
        res[i++] = len >>> 8 & 255;
        res[i++] = len >>> 16 & 255;
        res[i++] = len >>> 24 & 255;
        res[i++] = 0;
        res[i++] = 0;
        res[i++] = 0;
        res[i++] = 0;
        for (t = 8; t < this.padLength; t++)
          res[i++] = 0;
      }
      return res;
    };
  }
});

// node_modules/hash.js/lib/hash/sha/common.js
var require_common2 = __commonJS({
  "node_modules/hash.js/lib/hash/sha/common.js"(exports2) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var utils = require_utils3();
    var rotr32 = utils.rotr32;
    function ft_1(s, x, y, z) {
      if (s === 0)
        return ch32(x, y, z);
      if (s === 1 || s === 3)
        return p32(x, y, z);
      if (s === 2)
        return maj32(x, y, z);
    }
    exports2.ft_1 = ft_1;
    function ch32(x, y, z) {
      return x & y ^ ~x & z;
    }
    exports2.ch32 = ch32;
    function maj32(x, y, z) {
      return x & y ^ x & z ^ y & z;
    }
    exports2.maj32 = maj32;
    function p32(x, y, z) {
      return x ^ y ^ z;
    }
    exports2.p32 = p32;
    function s0_256(x) {
      return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
    }
    exports2.s0_256 = s0_256;
    function s1_256(x) {
      return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
    }
    exports2.s1_256 = s1_256;
    function g0_256(x) {
      return rotr32(x, 7) ^ rotr32(x, 18) ^ x >>> 3;
    }
    exports2.g0_256 = g0_256;
    function g1_256(x) {
      return rotr32(x, 17) ^ rotr32(x, 19) ^ x >>> 10;
    }
    exports2.g1_256 = g1_256;
  }
});

// node_modules/hash.js/lib/hash/sha/1.js
var require__ = __commonJS({
  "node_modules/hash.js/lib/hash/sha/1.js"(exports2, module2) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var utils = require_utils3();
    var common = require_common();
    var shaCommon = require_common2();
    var rotl32 = utils.rotl32;
    var sum32 = utils.sum32;
    var sum32_5 = utils.sum32_5;
    var ft_1 = shaCommon.ft_1;
    var BlockHash = common.BlockHash;
    var sha1_K = [
      1518500249,
      1859775393,
      2400959708,
      3395469782
    ];
    function SHA1() {
      if (!(this instanceof SHA1))
        return new SHA1();
      BlockHash.call(this);
      this.h = [
        1732584193,
        4023233417,
        2562383102,
        271733878,
        3285377520
      ];
      this.W = new Array(80);
    }
    utils.inherits(SHA1, BlockHash);
    module2.exports = SHA1;
    SHA1.blockSize = 512;
    SHA1.outSize = 160;
    SHA1.hmacStrength = 80;
    SHA1.padLength = 64;
    SHA1.prototype._update = function _update(msg, start) {
      var W = this.W;
      for (var i = 0; i < 16; i++)
        W[i] = msg[start + i];
      for (; i < W.length; i++)
        W[i] = rotl32(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);
      var a = this.h[0];
      var b = this.h[1];
      var c = this.h[2];
      var d = this.h[3];
      var e = this.h[4];
      for (i = 0; i < W.length; i++) {
        var s = ~~(i / 20);
        var t = sum32_5(rotl32(a, 5), ft_1(s, b, c, d), e, W[i], sha1_K[s]);
        e = d;
        d = c;
        c = rotl32(b, 30);
        b = a;
        a = t;
      }
      this.h[0] = sum32(this.h[0], a);
      this.h[1] = sum32(this.h[1], b);
      this.h[2] = sum32(this.h[2], c);
      this.h[3] = sum32(this.h[3], d);
      this.h[4] = sum32(this.h[4], e);
    };
    SHA1.prototype._digest = function digest(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h, "big");
      else
        return utils.split32(this.h, "big");
    };
  }
});

// node_modules/hash.js/lib/hash/sha/256.js
var require__2 = __commonJS({
  "node_modules/hash.js/lib/hash/sha/256.js"(exports2, module2) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var utils = require_utils3();
    var common = require_common();
    var shaCommon = require_common2();
    var assert = require_minimalistic_assert();
    var sum32 = utils.sum32;
    var sum32_4 = utils.sum32_4;
    var sum32_5 = utils.sum32_5;
    var ch32 = shaCommon.ch32;
    var maj32 = shaCommon.maj32;
    var s0_256 = shaCommon.s0_256;
    var s1_256 = shaCommon.s1_256;
    var g0_256 = shaCommon.g0_256;
    var g1_256 = shaCommon.g1_256;
    var BlockHash = common.BlockHash;
    var sha256_K = [
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ];
    function SHA256() {
      if (!(this instanceof SHA256))
        return new SHA256();
      BlockHash.call(this);
      this.h = [
        1779033703,
        3144134277,
        1013904242,
        2773480762,
        1359893119,
        2600822924,
        528734635,
        1541459225
      ];
      this.k = sha256_K;
      this.W = new Array(64);
    }
    utils.inherits(SHA256, BlockHash);
    module2.exports = SHA256;
    SHA256.blockSize = 512;
    SHA256.outSize = 256;
    SHA256.hmacStrength = 192;
    SHA256.padLength = 64;
    SHA256.prototype._update = function _update(msg, start) {
      var W = this.W;
      for (var i = 0; i < 16; i++)
        W[i] = msg[start + i];
      for (; i < W.length; i++)
        W[i] = sum32_4(g1_256(W[i - 2]), W[i - 7], g0_256(W[i - 15]), W[i - 16]);
      var a = this.h[0];
      var b = this.h[1];
      var c = this.h[2];
      var d = this.h[3];
      var e = this.h[4];
      var f = this.h[5];
      var g = this.h[6];
      var h = this.h[7];
      assert(this.k.length === W.length);
      for (i = 0; i < W.length; i++) {
        var T1 = sum32_5(h, s1_256(e), ch32(e, f, g), this.k[i], W[i]);
        var T2 = sum32(s0_256(a), maj32(a, b, c));
        h = g;
        g = f;
        f = e;
        e = sum32(d, T1);
        d = c;
        c = b;
        b = a;
        a = sum32(T1, T2);
      }
      this.h[0] = sum32(this.h[0], a);
      this.h[1] = sum32(this.h[1], b);
      this.h[2] = sum32(this.h[2], c);
      this.h[3] = sum32(this.h[3], d);
      this.h[4] = sum32(this.h[4], e);
      this.h[5] = sum32(this.h[5], f);
      this.h[6] = sum32(this.h[6], g);
      this.h[7] = sum32(this.h[7], h);
    };
    SHA256.prototype._digest = function digest(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h, "big");
      else
        return utils.split32(this.h, "big");
    };
  }
});

// node_modules/hash.js/lib/hash/sha/224.js
var require__3 = __commonJS({
  "node_modules/hash.js/lib/hash/sha/224.js"(exports2, module2) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var utils = require_utils3();
    var SHA256 = require__2();
    function SHA224() {
      if (!(this instanceof SHA224))
        return new SHA224();
      SHA256.call(this);
      this.h = [
        3238371032,
        914150663,
        812702999,
        4144912697,
        4290775857,
        1750603025,
        1694076839,
        3204075428
      ];
    }
    utils.inherits(SHA224, SHA256);
    module2.exports = SHA224;
    SHA224.blockSize = 512;
    SHA224.outSize = 224;
    SHA224.hmacStrength = 192;
    SHA224.padLength = 64;
    SHA224.prototype._digest = function digest(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h.slice(0, 7), "big");
      else
        return utils.split32(this.h.slice(0, 7), "big");
    };
  }
});

// node_modules/hash.js/lib/hash/sha/512.js
var require__4 = __commonJS({
  "node_modules/hash.js/lib/hash/sha/512.js"(exports2, module2) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var utils = require_utils3();
    var common = require_common();
    var assert = require_minimalistic_assert();
    var rotr64_hi = utils.rotr64_hi;
    var rotr64_lo = utils.rotr64_lo;
    var shr64_hi = utils.shr64_hi;
    var shr64_lo = utils.shr64_lo;
    var sum64 = utils.sum64;
    var sum64_hi = utils.sum64_hi;
    var sum64_lo = utils.sum64_lo;
    var sum64_4_hi = utils.sum64_4_hi;
    var sum64_4_lo = utils.sum64_4_lo;
    var sum64_5_hi = utils.sum64_5_hi;
    var sum64_5_lo = utils.sum64_5_lo;
    var BlockHash = common.BlockHash;
    var sha512_K = [
      1116352408,
      3609767458,
      1899447441,
      602891725,
      3049323471,
      3964484399,
      3921009573,
      2173295548,
      961987163,
      4081628472,
      1508970993,
      3053834265,
      2453635748,
      2937671579,
      2870763221,
      3664609560,
      3624381080,
      2734883394,
      310598401,
      1164996542,
      607225278,
      1323610764,
      1426881987,
      3590304994,
      1925078388,
      4068182383,
      2162078206,
      991336113,
      2614888103,
      633803317,
      3248222580,
      3479774868,
      3835390401,
      2666613458,
      4022224774,
      944711139,
      264347078,
      2341262773,
      604807628,
      2007800933,
      770255983,
      1495990901,
      1249150122,
      1856431235,
      1555081692,
      3175218132,
      1996064986,
      2198950837,
      2554220882,
      3999719339,
      2821834349,
      766784016,
      2952996808,
      2566594879,
      3210313671,
      3203337956,
      3336571891,
      1034457026,
      3584528711,
      2466948901,
      113926993,
      3758326383,
      338241895,
      168717936,
      666307205,
      1188179964,
      773529912,
      1546045734,
      1294757372,
      1522805485,
      1396182291,
      2643833823,
      1695183700,
      2343527390,
      1986661051,
      1014477480,
      2177026350,
      1206759142,
      2456956037,
      344077627,
      2730485921,
      1290863460,
      2820302411,
      3158454273,
      3259730800,
      3505952657,
      3345764771,
      106217008,
      3516065817,
      3606008344,
      3600352804,
      1432725776,
      4094571909,
      1467031594,
      275423344,
      851169720,
      430227734,
      3100823752,
      506948616,
      1363258195,
      659060556,
      3750685593,
      883997877,
      3785050280,
      958139571,
      3318307427,
      1322822218,
      3812723403,
      1537002063,
      2003034995,
      1747873779,
      3602036899,
      1955562222,
      1575990012,
      2024104815,
      1125592928,
      2227730452,
      2716904306,
      2361852424,
      442776044,
      2428436474,
      593698344,
      2756734187,
      3733110249,
      3204031479,
      2999351573,
      3329325298,
      3815920427,
      3391569614,
      3928383900,
      3515267271,
      566280711,
      3940187606,
      3454069534,
      4118630271,
      4000239992,
      116418474,
      1914138554,
      174292421,
      2731055270,
      289380356,
      3203993006,
      460393269,
      320620315,
      685471733,
      587496836,
      852142971,
      1086792851,
      1017036298,
      365543100,
      1126000580,
      2618297676,
      1288033470,
      3409855158,
      1501505948,
      4234509866,
      1607167915,
      987167468,
      1816402316,
      1246189591
    ];
    function SHA512() {
      if (!(this instanceof SHA512))
        return new SHA512();
      BlockHash.call(this);
      this.h = [
        1779033703,
        4089235720,
        3144134277,
        2227873595,
        1013904242,
        4271175723,
        2773480762,
        1595750129,
        1359893119,
        2917565137,
        2600822924,
        725511199,
        528734635,
        4215389547,
        1541459225,
        327033209
      ];
      this.k = sha512_K;
      this.W = new Array(160);
    }
    utils.inherits(SHA512, BlockHash);
    module2.exports = SHA512;
    SHA512.blockSize = 1024;
    SHA512.outSize = 512;
    SHA512.hmacStrength = 192;
    SHA512.padLength = 128;
    SHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {
      var W = this.W;
      for (var i = 0; i < 32; i++)
        W[i] = msg[start + i];
      for (; i < W.length; i += 2) {
        var c0_hi = g1_512_hi(W[i - 4], W[i - 3]);
        var c0_lo = g1_512_lo(W[i - 4], W[i - 3]);
        var c1_hi = W[i - 14];
        var c1_lo = W[i - 13];
        var c2_hi = g0_512_hi(W[i - 30], W[i - 29]);
        var c2_lo = g0_512_lo(W[i - 30], W[i - 29]);
        var c3_hi = W[i - 32];
        var c3_lo = W[i - 31];
        W[i] = sum64_4_hi(
          c0_hi,
          c0_lo,
          c1_hi,
          c1_lo,
          c2_hi,
          c2_lo,
          c3_hi,
          c3_lo
        );
        W[i + 1] = sum64_4_lo(
          c0_hi,
          c0_lo,
          c1_hi,
          c1_lo,
          c2_hi,
          c2_lo,
          c3_hi,
          c3_lo
        );
      }
    };
    SHA512.prototype._update = function _update(msg, start) {
      this._prepareBlock(msg, start);
      var W = this.W;
      var ah = this.h[0];
      var al = this.h[1];
      var bh = this.h[2];
      var bl = this.h[3];
      var ch = this.h[4];
      var cl = this.h[5];
      var dh = this.h[6];
      var dl = this.h[7];
      var eh = this.h[8];
      var el = this.h[9];
      var fh = this.h[10];
      var fl = this.h[11];
      var gh = this.h[12];
      var gl = this.h[13];
      var hh = this.h[14];
      var hl = this.h[15];
      assert(this.k.length === W.length);
      for (var i = 0; i < W.length; i += 2) {
        var c0_hi = hh;
        var c0_lo = hl;
        var c1_hi = s1_512_hi(eh, el);
        var c1_lo = s1_512_lo(eh, el);
        var c2_hi = ch64_hi(eh, el, fh, fl, gh, gl);
        var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
        var c3_hi = this.k[i];
        var c3_lo = this.k[i + 1];
        var c4_hi = W[i];
        var c4_lo = W[i + 1];
        var T1_hi = sum64_5_hi(
          c0_hi,
          c0_lo,
          c1_hi,
          c1_lo,
          c2_hi,
          c2_lo,
          c3_hi,
          c3_lo,
          c4_hi,
          c4_lo
        );
        var T1_lo = sum64_5_lo(
          c0_hi,
          c0_lo,
          c1_hi,
          c1_lo,
          c2_hi,
          c2_lo,
          c3_hi,
          c3_lo,
          c4_hi,
          c4_lo
        );
        c0_hi = s0_512_hi(ah, al);
        c0_lo = s0_512_lo(ah, al);
        c1_hi = maj64_hi(ah, al, bh, bl, ch, cl);
        c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);
        var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
        var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);
        hh = gh;
        hl = gl;
        gh = fh;
        gl = fl;
        fh = eh;
        fl = el;
        eh = sum64_hi(dh, dl, T1_hi, T1_lo);
        el = sum64_lo(dl, dl, T1_hi, T1_lo);
        dh = ch;
        dl = cl;
        ch = bh;
        cl = bl;
        bh = ah;
        bl = al;
        ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
        al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
      }
      sum64(this.h, 0, ah, al);
      sum64(this.h, 2, bh, bl);
      sum64(this.h, 4, ch, cl);
      sum64(this.h, 6, dh, dl);
      sum64(this.h, 8, eh, el);
      sum64(this.h, 10, fh, fl);
      sum64(this.h, 12, gh, gl);
      sum64(this.h, 14, hh, hl);
    };
    SHA512.prototype._digest = function digest(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h, "big");
      else
        return utils.split32(this.h, "big");
    };
    function ch64_hi(xh, xl, yh, yl, zh) {
      var r = xh & yh ^ ~xh & zh;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function ch64_lo(xh, xl, yh, yl, zh, zl) {
      var r = xl & yl ^ ~xl & zl;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function maj64_hi(xh, xl, yh, yl, zh) {
      var r = xh & yh ^ xh & zh ^ yh & zh;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function maj64_lo(xh, xl, yh, yl, zh, zl) {
      var r = xl & yl ^ xl & zl ^ yl & zl;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function s0_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 28);
      var c1_hi = rotr64_hi(xl, xh, 2);
      var c2_hi = rotr64_hi(xl, xh, 7);
      var r = c0_hi ^ c1_hi ^ c2_hi;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function s0_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 28);
      var c1_lo = rotr64_lo(xl, xh, 2);
      var c2_lo = rotr64_lo(xl, xh, 7);
      var r = c0_lo ^ c1_lo ^ c2_lo;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function s1_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 14);
      var c1_hi = rotr64_hi(xh, xl, 18);
      var c2_hi = rotr64_hi(xl, xh, 9);
      var r = c0_hi ^ c1_hi ^ c2_hi;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function s1_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 14);
      var c1_lo = rotr64_lo(xh, xl, 18);
      var c2_lo = rotr64_lo(xl, xh, 9);
      var r = c0_lo ^ c1_lo ^ c2_lo;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function g0_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 1);
      var c1_hi = rotr64_hi(xh, xl, 8);
      var c2_hi = shr64_hi(xh, xl, 7);
      var r = c0_hi ^ c1_hi ^ c2_hi;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function g0_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 1);
      var c1_lo = rotr64_lo(xh, xl, 8);
      var c2_lo = shr64_lo(xh, xl, 7);
      var r = c0_lo ^ c1_lo ^ c2_lo;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function g1_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 19);
      var c1_hi = rotr64_hi(xl, xh, 29);
      var c2_hi = shr64_hi(xh, xl, 6);
      var r = c0_hi ^ c1_hi ^ c2_hi;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function g1_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 19);
      var c1_lo = rotr64_lo(xl, xh, 29);
      var c2_lo = shr64_lo(xh, xl, 6);
      var r = c0_lo ^ c1_lo ^ c2_lo;
      if (r < 0)
        r += 4294967296;
      return r;
    }
  }
});

// node_modules/hash.js/lib/hash/sha/384.js
var require__5 = __commonJS({
  "node_modules/hash.js/lib/hash/sha/384.js"(exports2, module2) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var utils = require_utils3();
    var SHA512 = require__4();
    function SHA384() {
      if (!(this instanceof SHA384))
        return new SHA384();
      SHA512.call(this);
      this.h = [
        3418070365,
        3238371032,
        1654270250,
        914150663,
        2438529370,
        812702999,
        355462360,
        4144912697,
        1731405415,
        4290775857,
        2394180231,
        1750603025,
        3675008525,
        1694076839,
        1203062813,
        3204075428
      ];
    }
    utils.inherits(SHA384, SHA512);
    module2.exports = SHA384;
    SHA384.blockSize = 1024;
    SHA384.outSize = 384;
    SHA384.hmacStrength = 192;
    SHA384.padLength = 128;
    SHA384.prototype._digest = function digest(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h.slice(0, 12), "big");
      else
        return utils.split32(this.h.slice(0, 12), "big");
    };
  }
});

// node_modules/hash.js/lib/hash/sha.js
var require_sha3 = __commonJS({
  "node_modules/hash.js/lib/hash/sha.js"(exports2) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    exports2.sha1 = require__();
    exports2.sha224 = require__3();
    exports2.sha256 = require__2();
    exports2.sha384 = require__5();
    exports2.sha512 = require__4();
  }
});

// node_modules/hash.js/lib/hash/ripemd.js
var require_ripemd = __commonJS({
  "node_modules/hash.js/lib/hash/ripemd.js"(exports2) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var utils = require_utils3();
    var common = require_common();
    var rotl32 = utils.rotl32;
    var sum32 = utils.sum32;
    var sum32_3 = utils.sum32_3;
    var sum32_4 = utils.sum32_4;
    var BlockHash = common.BlockHash;
    function RIPEMD160() {
      if (!(this instanceof RIPEMD160))
        return new RIPEMD160();
      BlockHash.call(this);
      this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
      this.endian = "little";
    }
    utils.inherits(RIPEMD160, BlockHash);
    exports2.ripemd160 = RIPEMD160;
    RIPEMD160.blockSize = 512;
    RIPEMD160.outSize = 160;
    RIPEMD160.hmacStrength = 192;
    RIPEMD160.padLength = 64;
    RIPEMD160.prototype._update = function update(msg, start) {
      var A = this.h[0];
      var B = this.h[1];
      var C = this.h[2];
      var D = this.h[3];
      var E = this.h[4];
      var Ah = A;
      var Bh = B;
      var Ch = C;
      var Dh = D;
      var Eh = E;
      for (var j = 0; j < 80; j++) {
        var T = sum32(
          rotl32(
            sum32_4(A, f(j, B, C, D), msg[r[j] + start], K(j)),
            s[j]
          ),
          E
        );
        A = E;
        E = D;
        D = rotl32(C, 10);
        C = B;
        B = T;
        T = sum32(
          rotl32(
            sum32_4(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)),
            sh[j]
          ),
          Eh
        );
        Ah = Eh;
        Eh = Dh;
        Dh = rotl32(Ch, 10);
        Ch = Bh;
        Bh = T;
      }
      T = sum32_3(this.h[1], C, Dh);
      this.h[1] = sum32_3(this.h[2], D, Eh);
      this.h[2] = sum32_3(this.h[3], E, Ah);
      this.h[3] = sum32_3(this.h[4], A, Bh);
      this.h[4] = sum32_3(this.h[0], B, Ch);
      this.h[0] = T;
    };
    RIPEMD160.prototype._digest = function digest(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h, "little");
      else
        return utils.split32(this.h, "little");
    };
    function f(j, x, y, z) {
      if (j <= 15)
        return x ^ y ^ z;
      else if (j <= 31)
        return x & y | ~x & z;
      else if (j <= 47)
        return (x | ~y) ^ z;
      else if (j <= 63)
        return x & z | y & ~z;
      else
        return x ^ (y | ~z);
    }
    function K(j) {
      if (j <= 15)
        return 0;
      else if (j <= 31)
        return 1518500249;
      else if (j <= 47)
        return 1859775393;
      else if (j <= 63)
        return 2400959708;
      else
        return 2840853838;
    }
    function Kh(j) {
      if (j <= 15)
        return 1352829926;
      else if (j <= 31)
        return 1548603684;
      else if (j <= 47)
        return 1836072691;
      else if (j <= 63)
        return 2053994217;
      else
        return 0;
    }
    var r = [
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      7,
      4,
      13,
      1,
      10,
      6,
      15,
      3,
      12,
      0,
      9,
      5,
      2,
      14,
      11,
      8,
      3,
      10,
      14,
      4,
      9,
      15,
      8,
      1,
      2,
      7,
      0,
      6,
      13,
      11,
      5,
      12,
      1,
      9,
      11,
      10,
      0,
      8,
      12,
      4,
      13,
      3,
      7,
      15,
      14,
      5,
      6,
      2,
      4,
      0,
      5,
      9,
      7,
      12,
      2,
      10,
      14,
      1,
      3,
      8,
      11,
      6,
      15,
      13
    ];
    var rh = [
      5,
      14,
      7,
      0,
      9,
      2,
      11,
      4,
      13,
      6,
      15,
      8,
      1,
      10,
      3,
      12,
      6,
      11,
      3,
      7,
      0,
      13,
      5,
      10,
      14,
      15,
      8,
      12,
      4,
      9,
      1,
      2,
      15,
      5,
      1,
      3,
      7,
      14,
      6,
      9,
      11,
      8,
      12,
      2,
      10,
      0,
      4,
      13,
      8,
      6,
      4,
      1,
      3,
      11,
      15,
      0,
      5,
      12,
      2,
      13,
      9,
      7,
      10,
      14,
      12,
      15,
      10,
      4,
      1,
      5,
      8,
      7,
      6,
      2,
      13,
      14,
      0,
      3,
      9,
      11
    ];
    var s = [
      11,
      14,
      15,
      12,
      5,
      8,
      7,
      9,
      11,
      13,
      14,
      15,
      6,
      7,
      9,
      8,
      7,
      6,
      8,
      13,
      11,
      9,
      7,
      15,
      7,
      12,
      15,
      9,
      11,
      7,
      13,
      12,
      11,
      13,
      6,
      7,
      14,
      9,
      13,
      15,
      14,
      8,
      13,
      6,
      5,
      12,
      7,
      5,
      11,
      12,
      14,
      15,
      14,
      15,
      9,
      8,
      9,
      14,
      5,
      6,
      8,
      6,
      5,
      12,
      9,
      15,
      5,
      11,
      6,
      8,
      13,
      12,
      5,
      12,
      13,
      14,
      11,
      8,
      5,
      6
    ];
    var sh = [
      8,
      9,
      9,
      11,
      13,
      15,
      15,
      5,
      7,
      7,
      8,
      11,
      14,
      14,
      12,
      6,
      9,
      13,
      15,
      7,
      12,
      8,
      9,
      11,
      7,
      7,
      12,
      7,
      6,
      15,
      13,
      11,
      9,
      7,
      15,
      11,
      8,
      6,
      6,
      14,
      12,
      13,
      5,
      14,
      13,
      13,
      7,
      5,
      15,
      5,
      8,
      11,
      14,
      14,
      6,
      14,
      6,
      9,
      12,
      9,
      12,
      5,
      15,
      8,
      8,
      5,
      12,
      9,
      12,
      5,
      14,
      6,
      8,
      13,
      6,
      5,
      15,
      13,
      11,
      11
    ];
  }
});

// node_modules/hash.js/lib/hash/hmac.js
var require_hmac = __commonJS({
  "node_modules/hash.js/lib/hash/hmac.js"(exports2, module2) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var utils = require_utils3();
    var assert = require_minimalistic_assert();
    function Hmac(hash, key, enc) {
      if (!(this instanceof Hmac))
        return new Hmac(hash, key, enc);
      this.Hash = hash;
      this.blockSize = hash.blockSize / 8;
      this.outSize = hash.outSize / 8;
      this.inner = null;
      this.outer = null;
      this._init(utils.toArray(key, enc));
    }
    module2.exports = Hmac;
    Hmac.prototype._init = function init(key) {
      if (key.length > this.blockSize)
        key = new this.Hash().update(key).digest();
      assert(key.length <= this.blockSize);
      for (var i = key.length; i < this.blockSize; i++)
        key.push(0);
      for (i = 0; i < key.length; i++)
        key[i] ^= 54;
      this.inner = new this.Hash().update(key);
      for (i = 0; i < key.length; i++)
        key[i] ^= 106;
      this.outer = new this.Hash().update(key);
    };
    Hmac.prototype.update = function update(msg, enc) {
      this.inner.update(msg, enc);
      return this;
    };
    Hmac.prototype.digest = function digest(enc) {
      this.outer.update(this.inner.digest());
      return this.outer.digest(enc);
    };
  }
});

// node_modules/hash.js/lib/hash.js
var require_hash2 = __commonJS({
  "node_modules/hash.js/lib/hash.js"(exports2) {
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var hash = exports2;
    hash.utils = require_utils3();
    hash.common = require_common();
    hash.sha = require_sha3();
    hash.ripemd = require_ripemd();
    hash.hmac = require_hmac();
    hash.sha1 = hash.sha.sha1;
    hash.sha256 = hash.sha.sha256;
    hash.sha224 = hash.sha.sha224;
    hash.sha384 = hash.sha.sha384;
    hash.sha512 = hash.sha.sha512;
    hash.ripemd160 = hash.ripemd.ripemd160;
  }
});

// node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js
var require_secp256k1 = __commonJS({
  "node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js"(exports2, module2) {
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    module2.exports = {
      doubles: {
        step: 4,
        points: [
          [
            "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
            "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
          ],
          [
            "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
            "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
          ],
          [
            "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
            "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
          ],
          [
            "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
            "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
          ],
          [
            "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
            "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
          ],
          [
            "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
            "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
          ],
          [
            "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
            "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
          ],
          [
            "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
            "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
          ],
          [
            "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
            "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
          ],
          [
            "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
            "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
          ],
          [
            "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
            "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
          ],
          [
            "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
            "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
          ],
          [
            "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
            "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
          ],
          [
            "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
            "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
          ],
          [
            "6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
            "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
          ],
          [
            "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
            "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
          ],
          [
            "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
            "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
          ],
          [
            "948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
            "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
          ],
          [
            "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
            "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
          ],
          [
            "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
            "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
          ],
          [
            "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
            "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
          ],
          [
            "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
            "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
          ],
          [
            "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
            "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
          ],
          [
            "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
            "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
          ],
          [
            "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
            "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
          ],
          [
            "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
            "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
          ],
          [
            "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
            "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
          ],
          [
            "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
            "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
          ],
          [
            "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
            "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
          ],
          [
            "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
            "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
          ],
          [
            "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
            "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
          ],
          [
            "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
            "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
          ],
          [
            "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
            "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
          ],
          [
            "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
            "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
          ],
          [
            "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
            "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
          ],
          [
            "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
            "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
          ],
          [
            "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
            "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
          ],
          [
            "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
            "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
          ],
          [
            "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
            "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
          ],
          [
            "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
            "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
          ],
          [
            "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
            "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
          ],
          [
            "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
            "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
          ],
          [
            "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
            "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
          ],
          [
            "928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
            "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
          ],
          [
            "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
            "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
          ],
          [
            "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
            "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
          ],
          [
            "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
            "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
          ],
          [
            "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
            "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
          ],
          [
            "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
            "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
          ],
          [
            "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
            "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
          ],
          [
            "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
            "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
          ],
          [
            "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
            "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
          ],
          [
            "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
            "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
          ],
          [
            "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
            "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
          ],
          [
            "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
            "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
          ],
          [
            "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
            "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
          ],
          [
            "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
            "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
          ],
          [
            "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
            "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
          ],
          [
            "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
            "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
          ],
          [
            "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
            "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
          ],
          [
            "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
            "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
          ],
          [
            "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
            "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
          ],
          [
            "8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
            "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
          ],
          [
            "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
            "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
          ],
          [
            "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
            "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
          ]
        ]
      },
      naf: {
        wnd: 7,
        points: [
          [
            "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
            "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
          ],
          [
            "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
            "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
          ],
          [
            "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
            "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
          ],
          [
            "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
            "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
          ],
          [
            "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
            "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
          ],
          [
            "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
            "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
          ],
          [
            "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
            "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
          ],
          [
            "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
            "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
          ],
          [
            "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
            "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
          ],
          [
            "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
            "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
          ],
          [
            "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
            "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
          ],
          [
            "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
            "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
          ],
          [
            "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
            "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
          ],
          [
            "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
            "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
          ],
          [
            "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
            "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
          ],
          [
            "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
            "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
          ],
          [
            "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
            "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
          ],
          [
            "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
            "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
          ],
          [
            "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
            "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
          ],
          [
            "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
            "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
          ],
          [
            "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
            "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
          ],
          [
            "49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
            "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
          ],
          [
            "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
            "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
          ],
          [
            "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
            "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
          ],
          [
            "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
            "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
          ],
          [
            "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
            "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
          ],
          [
            "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
            "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
          ],
          [
            "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
            "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
          ],
          [
            "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
            "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
          ],
          [
            "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
            "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
          ],
          [
            "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
            "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
          ],
          [
            "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
            "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
          ],
          [
            "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
            "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
          ],
          [
            "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
            "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
          ],
          [
            "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
            "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
          ],
          [
            "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
            "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
          ],
          [
            "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
            "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
          ],
          [
            "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
            "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
          ],
          [
            "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
            "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
          ],
          [
            "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
            "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
          ],
          [
            "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
            "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
          ],
          [
            "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
            "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
          ],
          [
            "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
            "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
          ],
          [
            "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
            "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
          ],
          [
            "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
            "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
          ],
          [
            "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
            "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
          ],
          [
            "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
            "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
          ],
          [
            "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
            "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
          ],
          [
            "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
            "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
          ],
          [
            "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
            "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
          ],
          [
            "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
            "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
          ],
          [
            "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
            "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
          ],
          [
            "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
            "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
          ],
          [
            "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
            "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
          ],
          [
            "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
            "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
          ],
          [
            "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
            "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
          ],
          [
            "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
            "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
          ],
          [
            "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
            "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
          ],
          [
            "78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
            "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
          ],
          [
            "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
            "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
          ],
          [
            "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
            "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
          ],
          [
            "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
            "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
          ],
          [
            "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
            "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
          ],
          [
            "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
            "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
          ],
          [
            "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
            "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
          ],
          [
            "336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
            "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
          ],
          [
            "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
            "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
          ],
          [
            "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
            "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
          ],
          [
            "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
            "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
          ],
          [
            "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
            "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
          ],
          [
            "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
            "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
          ],
          [
            "4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
            "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
          ],
          [
            "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
            "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
          ],
          [
            "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
            "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
          ],
          [
            "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
            "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
          ],
          [
            "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
            "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
          ],
          [
            "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
            "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
          ],
          [
            "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
            "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
          ],
          [
            "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
            "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
          ],
          [
            "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
            "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
          ],
          [
            "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
            "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
          ],
          [
            "c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
            "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
          ],
          [
            "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
            "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
          ],
          [
            "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
            "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
          ],
          [
            "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
            "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
          ],
          [
            "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
            "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
          ],
          [
            "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
            "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
          ],
          [
            "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
            "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
          ],
          [
            "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
            "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
          ],
          [
            "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
            "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
          ],
          [
            "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
            "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
          ],
          [
            "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
            "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
          ],
          [
            "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
            "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
          ],
          [
            "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
            "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
          ],
          [
            "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
            "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
          ],
          [
            "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
            "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
          ],
          [
            "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
            "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
          ],
          [
            "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
            "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
          ],
          [
            "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
            "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
          ],
          [
            "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
            "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
          ],
          [
            "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
            "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
          ],
          [
            "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
            "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
          ],
          [
            "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
            "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
          ],
          [
            "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
            "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
          ],
          [
            "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
            "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
          ],
          [
            "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
            "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
          ],
          [
            "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
            "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
          ],
          [
            "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
            "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
          ],
          [
            "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
            "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
          ],
          [
            "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
            "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
          ],
          [
            "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
            "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
          ],
          [
            "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
            "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
          ],
          [
            "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
            "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
          ],
          [
            "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
            "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
          ],
          [
            "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
            "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
          ],
          [
            "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
            "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
          ],
          [
            "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
            "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
          ],
          [
            "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
            "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
          ],
          [
            "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
            "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
          ],
          [
            "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
            "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
          ],
          [
            "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
            "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
          ],
          [
            "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
            "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
          ],
          [
            "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
            "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
          ],
          [
            "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
            "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
          ],
          [
            "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
            "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
          ],
          [
            "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
            "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
          ],
          [
            "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
            "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
          ]
        ]
      }
    };
  }
});

// node_modules/elliptic/lib/elliptic/curves.js
var require_curves = __commonJS({
  "node_modules/elliptic/lib/elliptic/curves.js"(exports2) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var curves = exports2;
    var hash = require_hash2();
    var curve = require_curve();
    var utils = require_utils2();
    var assert = utils.assert;
    function PresetCurve(options) {
      if (options.type === "short")
        this.curve = new curve.short(options);
      else if (options.type === "edwards")
        this.curve = new curve.edwards(options);
      else
        this.curve = new curve.mont(options);
      this.g = this.curve.g;
      this.n = this.curve.n;
      this.hash = options.hash;
      assert(this.g.validate(), "Invalid curve");
      assert(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
    }
    curves.PresetCurve = PresetCurve;
    function defineCurve(name, options) {
      Object.defineProperty(curves, name, {
        configurable: true,
        enumerable: true,
        get: function() {
          var curve2 = new PresetCurve(options);
          Object.defineProperty(curves, name, {
            configurable: true,
            enumerable: true,
            value: curve2
          });
          return curve2;
        }
      });
    }
    defineCurve("p192", {
      type: "short",
      prime: "p192",
      p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
      b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
      n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
      hash: hash.sha256,
      gRed: false,
      g: [
        "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
        "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
      ]
    });
    defineCurve("p224", {
      type: "short",
      prime: "p224",
      p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
      b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
      n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
      hash: hash.sha256,
      gRed: false,
      g: [
        "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
        "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
      ]
    });
    defineCurve("p256", {
      type: "short",
      prime: null,
      p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
      a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
      b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
      n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
      hash: hash.sha256,
      gRed: false,
      g: [
        "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
        "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
      ]
    });
    defineCurve("p384", {
      type: "short",
      prime: null,
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
      a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
      b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
      n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
      hash: hash.sha384,
      gRed: false,
      g: [
        "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
        "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
      ]
    });
    defineCurve("p521", {
      type: "short",
      prime: null,
      p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
      a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
      b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
      n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
      hash: hash.sha512,
      gRed: false,
      g: [
        "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
        "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
      ]
    });
    defineCurve("curve25519", {
      type: "mont",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "76d06",
      b: "1",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: hash.sha256,
      gRed: false,
      g: [
        "9"
      ]
    });
    defineCurve("ed25519", {
      type: "edwards",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "-1",
      c: "1",
      // -121665 * (121666^(-1)) (mod P)
      d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: hash.sha256,
      gRed: false,
      g: [
        "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
        // 4/5
        "6666666666666666666666666666666666666666666666666666666666666658"
      ]
    });
    var pre;
    try {
      pre = require_secp256k1();
    } catch (e) {
      pre = void 0;
    }
    defineCurve("secp256k1", {
      type: "short",
      prime: "k256",
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
      a: "0",
      b: "7",
      n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
      h: "1",
      hash: hash.sha256,
      // Precomputed endomorphism
      beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
      lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
      basis: [
        {
          a: "3086d221a7d46bcde86c90e49284eb15",
          b: "-e4437ed6010e88286f547fa90abfe4c3"
        },
        {
          a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
          b: "3086d221a7d46bcde86c90e49284eb15"
        }
      ],
      gRed: false,
      g: [
        "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
        "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
        pre
      ]
    });
  }
});

// node_modules/hmac-drbg/lib/hmac-drbg.js
var require_hmac_drbg = __commonJS({
  "node_modules/hmac-drbg/lib/hmac-drbg.js"(exports2, module2) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var hash = require_hash2();
    var utils = require_utils();
    var assert = require_minimalistic_assert();
    function HmacDRBG(options) {
      if (!(this instanceof HmacDRBG))
        return new HmacDRBG(options);
      this.hash = options.hash;
      this.predResist = !!options.predResist;
      this.outLen = this.hash.outSize;
      this.minEntropy = options.minEntropy || this.hash.hmacStrength;
      this._reseed = null;
      this.reseedInterval = null;
      this.K = null;
      this.V = null;
      var entropy = utils.toArray(options.entropy, options.entropyEnc || "hex");
      var nonce = utils.toArray(options.nonce, options.nonceEnc || "hex");
      var pers = utils.toArray(options.pers, options.persEnc || "hex");
      assert(
        entropy.length >= this.minEntropy / 8,
        "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
      );
      this._init(entropy, nonce, pers);
    }
    module2.exports = HmacDRBG;
    HmacDRBG.prototype._init = function init(entropy, nonce, pers) {
      var seed = entropy.concat(nonce).concat(pers);
      this.K = new Array(this.outLen / 8);
      this.V = new Array(this.outLen / 8);
      for (var i = 0; i < this.V.length; i++) {
        this.K[i] = 0;
        this.V[i] = 1;
      }
      this._update(seed);
      this._reseed = 1;
      this.reseedInterval = 281474976710656;
    };
    HmacDRBG.prototype._hmac = function hmac() {
      return new hash.hmac(this.hash, this.K);
    };
    HmacDRBG.prototype._update = function update(seed) {
      var kmac = this._hmac().update(this.V).update([0]);
      if (seed)
        kmac = kmac.update(seed);
      this.K = kmac.digest();
      this.V = this._hmac().update(this.V).digest();
      if (!seed)
        return;
      this.K = this._hmac().update(this.V).update([1]).update(seed).digest();
      this.V = this._hmac().update(this.V).digest();
    };
    HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {
      if (typeof entropyEnc !== "string") {
        addEnc = add;
        add = entropyEnc;
        entropyEnc = null;
      }
      entropy = utils.toArray(entropy, entropyEnc);
      add = utils.toArray(add, addEnc);
      assert(
        entropy.length >= this.minEntropy / 8,
        "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
      );
      this._update(entropy.concat(add || []));
      this._reseed = 1;
    };
    HmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {
      if (this._reseed > this.reseedInterval)
        throw new Error("Reseed is required");
      if (typeof enc !== "string") {
        addEnc = add;
        add = enc;
        enc = null;
      }
      if (add) {
        add = utils.toArray(add, addEnc || "hex");
        this._update(add);
      }
      var temp = [];
      while (temp.length < len) {
        this.V = this._hmac().update(this.V).digest();
        temp = temp.concat(this.V);
      }
      var res = temp.slice(0, len);
      this._update(add);
      this._reseed++;
      return utils.encode(res, enc);
    };
  }
});

// node_modules/elliptic/lib/elliptic/ec/key.js
var require_key = __commonJS({
  "node_modules/elliptic/lib/elliptic/ec/key.js"(exports2, module2) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var BN = require_bn();
    var utils = require_utils2();
    var assert = utils.assert;
    function KeyPair(ec, options) {
      this.ec = ec;
      this.priv = null;
      this.pub = null;
      if (options.priv)
        this._importPrivate(options.priv, options.privEnc);
      if (options.pub)
        this._importPublic(options.pub, options.pubEnc);
    }
    module2.exports = KeyPair;
    KeyPair.fromPublic = function fromPublic(ec, pub, enc) {
      if (pub instanceof KeyPair)
        return pub;
      return new KeyPair(ec, {
        pub,
        pubEnc: enc
      });
    };
    KeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {
      if (priv instanceof KeyPair)
        return priv;
      return new KeyPair(ec, {
        priv,
        privEnc: enc
      });
    };
    KeyPair.prototype.validate = function validate() {
      var pub = this.getPublic();
      if (pub.isInfinity())
        return { result: false, reason: "Invalid public key" };
      if (!pub.validate())
        return { result: false, reason: "Public key is not a point" };
      if (!pub.mul(this.ec.curve.n).isInfinity())
        return { result: false, reason: "Public key * N != O" };
      return { result: true, reason: null };
    };
    KeyPair.prototype.getPublic = function getPublic(compact, enc) {
      if (typeof compact === "string") {
        enc = compact;
        compact = null;
      }
      if (!this.pub)
        this.pub = this.ec.g.mul(this.priv);
      if (!enc)
        return this.pub;
      return this.pub.encode(enc, compact);
    };
    KeyPair.prototype.getPrivate = function getPrivate(enc) {
      if (enc === "hex")
        return this.priv.toString(16, 2);
      else
        return this.priv;
    };
    KeyPair.prototype._importPrivate = function _importPrivate(key, enc) {
      this.priv = new BN(key, enc || 16);
      this.priv = this.priv.umod(this.ec.curve.n);
    };
    KeyPair.prototype._importPublic = function _importPublic(key, enc) {
      if (key.x || key.y) {
        if (this.ec.curve.type === "mont") {
          assert(key.x, "Need x coordinate");
        } else if (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") {
          assert(key.x && key.y, "Need both x and y coordinate");
        }
        this.pub = this.ec.curve.point(key.x, key.y);
        return;
      }
      this.pub = this.ec.curve.decodePoint(key, enc);
    };
    KeyPair.prototype.derive = function derive(pub) {
      if (!pub.validate()) {
        assert(pub.validate(), "public point not validated");
      }
      return pub.mul(this.priv).getX();
    };
    KeyPair.prototype.sign = function sign(msg, enc, options) {
      return this.ec.sign(msg, this, enc, options);
    };
    KeyPair.prototype.verify = function verify(msg, signature, options) {
      return this.ec.verify(msg, signature, this, void 0, options);
    };
    KeyPair.prototype.inspect = function inspect() {
      return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
    };
  }
});

// node_modules/elliptic/lib/elliptic/ec/signature.js
var require_signature = __commonJS({
  "node_modules/elliptic/lib/elliptic/ec/signature.js"(exports2, module2) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var BN = require_bn();
    var utils = require_utils2();
    var assert = utils.assert;
    function Signature(options, enc) {
      if (options instanceof Signature)
        return options;
      if (this._importDER(options, enc))
        return;
      assert(options.r && options.s, "Signature without r or s");
      this.r = new BN(options.r, 16);
      this.s = new BN(options.s, 16);
      if (options.recoveryParam === void 0)
        this.recoveryParam = null;
      else
        this.recoveryParam = options.recoveryParam;
    }
    module2.exports = Signature;
    function Position() {
      this.place = 0;
    }
    function getLength(buf, p) {
      var initial = buf[p.place++];
      if (!(initial & 128)) {
        return initial;
      }
      var octetLen = initial & 15;
      if (octetLen === 0 || octetLen > 4) {
        return false;
      }
      if (buf[p.place] === 0) {
        return false;
      }
      var val = 0;
      for (var i = 0, off = p.place; i < octetLen; i++, off++) {
        val <<= 8;
        val |= buf[off];
        val >>>= 0;
      }
      if (val <= 127) {
        return false;
      }
      p.place = off;
      return val;
    }
    function rmPadding(buf) {
      var i = 0;
      var len = buf.length - 1;
      while (!buf[i] && !(buf[i + 1] & 128) && i < len) {
        i++;
      }
      if (i === 0) {
        return buf;
      }
      return buf.slice(i);
    }
    Signature.prototype._importDER = function _importDER(data, enc) {
      data = utils.toArray(data, enc);
      var p = new Position();
      if (data[p.place++] !== 48) {
        return false;
      }
      var len = getLength(data, p);
      if (len === false) {
        return false;
      }
      if (len + p.place !== data.length) {
        return false;
      }
      if (data[p.place++] !== 2) {
        return false;
      }
      var rlen = getLength(data, p);
      if (rlen === false) {
        return false;
      }
      if ((data[p.place] & 128) !== 0) {
        return false;
      }
      var r = data.slice(p.place, rlen + p.place);
      p.place += rlen;
      if (data[p.place++] !== 2) {
        return false;
      }
      var slen = getLength(data, p);
      if (slen === false) {
        return false;
      }
      if (data.length !== slen + p.place) {
        return false;
      }
      if ((data[p.place] & 128) !== 0) {
        return false;
      }
      var s = data.slice(p.place, slen + p.place);
      if (r[0] === 0) {
        if (r[1] & 128) {
          r = r.slice(1);
        } else {
          return false;
        }
      }
      if (s[0] === 0) {
        if (s[1] & 128) {
          s = s.slice(1);
        } else {
          return false;
        }
      }
      this.r = new BN(r);
      this.s = new BN(s);
      this.recoveryParam = null;
      return true;
    };
    function constructLength(arr, len) {
      if (len < 128) {
        arr.push(len);
        return;
      }
      var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
      arr.push(octets | 128);
      while (--octets) {
        arr.push(len >>> (octets << 3) & 255);
      }
      arr.push(len);
    }
    Signature.prototype.toDER = function toDER(enc) {
      var r = this.r.toArray();
      var s = this.s.toArray();
      if (r[0] & 128)
        r = [0].concat(r);
      if (s[0] & 128)
        s = [0].concat(s);
      r = rmPadding(r);
      s = rmPadding(s);
      while (!s[0] && !(s[1] & 128)) {
        s = s.slice(1);
      }
      var arr = [2];
      constructLength(arr, r.length);
      arr = arr.concat(r);
      arr.push(2);
      constructLength(arr, s.length);
      var backHalf = arr.concat(s);
      var res = [48];
      constructLength(res, backHalf.length);
      res = res.concat(backHalf);
      return utils.encode(res, enc);
    };
  }
});

// node_modules/elliptic/lib/elliptic/ec/index.js
var require_ec = __commonJS({
  "node_modules/elliptic/lib/elliptic/ec/index.js"(exports2, module2) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var BN = require_bn();
    var HmacDRBG = require_hmac_drbg();
    var utils = require_utils2();
    var curves = require_curves();
    var rand = require_brorand();
    var assert = utils.assert;
    var KeyPair = require_key();
    var Signature = require_signature();
    function EC(options) {
      if (!(this instanceof EC))
        return new EC(options);
      if (typeof options === "string") {
        assert(
          Object.prototype.hasOwnProperty.call(curves, options),
          "Unknown curve " + options
        );
        options = curves[options];
      }
      if (options instanceof curves.PresetCurve)
        options = { curve: options };
      this.curve = options.curve.curve;
      this.n = this.curve.n;
      this.nh = this.n.ushrn(1);
      this.g = this.curve.g;
      this.g = options.curve.g;
      this.g.precompute(options.curve.n.bitLength() + 1);
      this.hash = options.hash || options.curve.hash;
    }
    module2.exports = EC;
    EC.prototype.keyPair = function keyPair(options) {
      return new KeyPair(this, options);
    };
    EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
      return KeyPair.fromPrivate(this, priv, enc);
    };
    EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
      return KeyPair.fromPublic(this, pub, enc);
    };
    EC.prototype.genKeyPair = function genKeyPair(options) {
      if (!options)
        options = {};
      var drbg = new HmacDRBG({
        hash: this.hash,
        pers: options.pers,
        persEnc: options.persEnc || "utf8",
        entropy: options.entropy || rand(this.hash.hmacStrength),
        entropyEnc: options.entropy && options.entropyEnc || "utf8",
        nonce: this.n.toArray()
      });
      var bytes = this.n.byteLength();
      var ns2 = this.n.sub(new BN(2));
      for (; ; ) {
        var priv = new BN(drbg.generate(bytes));
        if (priv.cmp(ns2) > 0)
          continue;
        priv.iaddn(1);
        return this.keyFromPrivate(priv);
      }
    };
    EC.prototype._truncateToN = function _truncateToN(msg, truncOnly, bitLength) {
      var byteLength;
      if (BN.isBN(msg) || typeof msg === "number") {
        msg = new BN(msg, 16);
        byteLength = msg.byteLength();
      } else if (typeof msg === "object") {
        byteLength = msg.length;
        msg = new BN(msg, 16);
      } else {
        var str = msg.toString();
        byteLength = str.length + 1 >>> 1;
        msg = new BN(str, 16);
      }
      if (typeof bitLength !== "number") {
        bitLength = byteLength * 8;
      }
      var delta = bitLength - this.n.bitLength();
      if (delta > 0)
        msg = msg.ushrn(delta);
      if (!truncOnly && msg.cmp(this.n) >= 0)
        return msg.sub(this.n);
      else
        return msg;
    };
    EC.prototype.sign = function sign(msg, key, enc, options) {
      if (typeof enc === "object") {
        options = enc;
        enc = null;
      }
      if (!options)
        options = {};
      if (typeof msg !== "string" && typeof msg !== "number" && !BN.isBN(msg)) {
        assert(
          typeof msg === "object" && msg && typeof msg.length === "number",
          "Expected message to be an array-like, a hex string, or a BN instance"
        );
        assert(msg.length >>> 0 === msg.length);
        for (var i = 0; i < msg.length; i++) assert((msg[i] & 255) === msg[i]);
      }
      key = this.keyFromPrivate(key, enc);
      msg = this._truncateToN(msg, false, options.msgBitLength);
      assert(!msg.isNeg(), "Can not sign a negative message");
      var bytes = this.n.byteLength();
      var bkey = key.getPrivate().toArray("be", bytes);
      var nonce = msg.toArray("be", bytes);
      assert(new BN(nonce).eq(msg), "Can not sign message");
      var drbg = new HmacDRBG({
        hash: this.hash,
        entropy: bkey,
        nonce,
        pers: options.pers,
        persEnc: options.persEnc || "utf8"
      });
      var ns1 = this.n.sub(new BN(1));
      for (var iter = 0; ; iter++) {
        var k = options.k ? options.k(iter) : new BN(drbg.generate(this.n.byteLength()));
        k = this._truncateToN(k, true);
        if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)
          continue;
        var kp = this.g.mul(k);
        if (kp.isInfinity())
          continue;
        var kpX = kp.getX();
        var r = kpX.umod(this.n);
        if (r.cmpn(0) === 0)
          continue;
        var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));
        s = s.umod(this.n);
        if (s.cmpn(0) === 0)
          continue;
        var recoveryParam = (kp.getY().isOdd() ? 1 : 0) | (kpX.cmp(r) !== 0 ? 2 : 0);
        if (options.canonical && s.cmp(this.nh) > 0) {
          s = this.n.sub(s);
          recoveryParam ^= 1;
        }
        return new Signature({ r, s, recoveryParam });
      }
    };
    EC.prototype.verify = function verify(msg, signature, key, enc, options) {
      if (!options)
        options = {};
      msg = this._truncateToN(msg, false, options.msgBitLength);
      key = this.keyFromPublic(key, enc);
      signature = new Signature(signature, "hex");
      var r = signature.r;
      var s = signature.s;
      if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)
        return false;
      if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)
        return false;
      var sinv = s.invm(this.n);
      var u1 = sinv.mul(msg).umod(this.n);
      var u2 = sinv.mul(r).umod(this.n);
      var p;
      if (!this.curve._maxwellTrick) {
        p = this.g.mulAdd(u1, key.getPublic(), u2);
        if (p.isInfinity())
          return false;
        return p.getX().umod(this.n).cmp(r) === 0;
      }
      p = this.g.jmulAdd(u1, key.getPublic(), u2);
      if (p.isInfinity())
        return false;
      return p.eqXToP(r);
    };
    EC.prototype.recoverPubKey = function(msg, signature, j, enc) {
      assert((3 & j) === j, "The recovery param is more than two bits");
      signature = new Signature(signature, enc);
      var n = this.n;
      var e = new BN(msg);
      var r = signature.r;
      var s = signature.s;
      var isYOdd = j & 1;
      var isSecondKey = j >> 1;
      if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
        throw new Error("Unable to find sencond key candinate");
      if (isSecondKey)
        r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);
      else
        r = this.curve.pointFromX(r, isYOdd);
      var rInv = signature.r.invm(n);
      var s1 = n.sub(e).mul(rInv).umod(n);
      var s2 = s.mul(rInv).umod(n);
      return this.g.mulAdd(s1, r, s2);
    };
    EC.prototype.getKeyRecoveryParam = function(e, signature, Q, enc) {
      signature = new Signature(signature, enc);
      if (signature.recoveryParam !== null)
        return signature.recoveryParam;
      for (var i = 0; i < 4; i++) {
        var Qprime;
        try {
          Qprime = this.recoverPubKey(e, signature, i);
        } catch (e2) {
          continue;
        }
        if (Qprime.eq(Q))
          return i;
      }
      throw new Error("Unable to find valid recovery factor");
    };
  }
});

// node_modules/elliptic/lib/elliptic/eddsa/key.js
var require_key2 = __commonJS({
  "node_modules/elliptic/lib/elliptic/eddsa/key.js"(exports2, module2) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var utils = require_utils2();
    var assert = utils.assert;
    var parseBytes = utils.parseBytes;
    var cachedProperty = utils.cachedProperty;
    function KeyPair(eddsa, params) {
      this.eddsa = eddsa;
      this._secret = parseBytes(params.secret);
      if (eddsa.isPoint(params.pub))
        this._pub = params.pub;
      else
        this._pubBytes = parseBytes(params.pub);
    }
    KeyPair.fromPublic = function fromPublic(eddsa, pub) {
      if (pub instanceof KeyPair)
        return pub;
      return new KeyPair(eddsa, { pub });
    };
    KeyPair.fromSecret = function fromSecret(eddsa, secret) {
      if (secret instanceof KeyPair)
        return secret;
      return new KeyPair(eddsa, { secret });
    };
    KeyPair.prototype.secret = function secret() {
      return this._secret;
    };
    cachedProperty(KeyPair, "pubBytes", function pubBytes() {
      return this.eddsa.encodePoint(this.pub());
    });
    cachedProperty(KeyPair, "pub", function pub() {
      if (this._pubBytes)
        return this.eddsa.decodePoint(this._pubBytes);
      return this.eddsa.g.mul(this.priv());
    });
    cachedProperty(KeyPair, "privBytes", function privBytes() {
      var eddsa = this.eddsa;
      var hash = this.hash();
      var lastIx = eddsa.encodingLength - 1;
      var a = hash.slice(0, eddsa.encodingLength);
      a[0] &= 248;
      a[lastIx] &= 127;
      a[lastIx] |= 64;
      return a;
    });
    cachedProperty(KeyPair, "priv", function priv() {
      return this.eddsa.decodeInt(this.privBytes());
    });
    cachedProperty(KeyPair, "hash", function hash() {
      return this.eddsa.hash().update(this.secret()).digest();
    });
    cachedProperty(KeyPair, "messagePrefix", function messagePrefix() {
      return this.hash().slice(this.eddsa.encodingLength);
    });
    KeyPair.prototype.sign = function sign(message) {
      assert(this._secret, "KeyPair can only verify");
      return this.eddsa.sign(message, this);
    };
    KeyPair.prototype.verify = function verify(message, sig) {
      return this.eddsa.verify(message, sig, this);
    };
    KeyPair.prototype.getSecret = function getSecret(enc) {
      assert(this._secret, "KeyPair is public only");
      return utils.encode(this.secret(), enc);
    };
    KeyPair.prototype.getPublic = function getPublic(enc) {
      return utils.encode(this.pubBytes(), enc);
    };
    module2.exports = KeyPair;
  }
});

// node_modules/elliptic/lib/elliptic/eddsa/signature.js
var require_signature2 = __commonJS({
  "node_modules/elliptic/lib/elliptic/eddsa/signature.js"(exports2, module2) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var BN = require_bn();
    var utils = require_utils2();
    var assert = utils.assert;
    var cachedProperty = utils.cachedProperty;
    var parseBytes = utils.parseBytes;
    function Signature(eddsa, sig) {
      this.eddsa = eddsa;
      if (typeof sig !== "object")
        sig = parseBytes(sig);
      if (Array.isArray(sig)) {
        assert(sig.length === eddsa.encodingLength * 2, "Signature has invalid size");
        sig = {
          R: sig.slice(0, eddsa.encodingLength),
          S: sig.slice(eddsa.encodingLength)
        };
      }
      assert(sig.R && sig.S, "Signature without R or S");
      if (eddsa.isPoint(sig.R))
        this._R = sig.R;
      if (sig.S instanceof BN)
        this._S = sig.S;
      this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
      this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
    }
    cachedProperty(Signature, "S", function S() {
      return this.eddsa.decodeInt(this.Sencoded());
    });
    cachedProperty(Signature, "R", function R() {
      return this.eddsa.decodePoint(this.Rencoded());
    });
    cachedProperty(Signature, "Rencoded", function Rencoded() {
      return this.eddsa.encodePoint(this.R());
    });
    cachedProperty(Signature, "Sencoded", function Sencoded() {
      return this.eddsa.encodeInt(this.S());
    });
    Signature.prototype.toBytes = function toBytes() {
      return this.Rencoded().concat(this.Sencoded());
    };
    Signature.prototype.toHex = function toHex() {
      return utils.encode(this.toBytes(), "hex").toUpperCase();
    };
    module2.exports = Signature;
  }
});

// node_modules/elliptic/lib/elliptic/eddsa/index.js
var require_eddsa = __commonJS({
  "node_modules/elliptic/lib/elliptic/eddsa/index.js"(exports2, module2) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var hash = require_hash2();
    var curves = require_curves();
    var utils = require_utils2();
    var assert = utils.assert;
    var parseBytes = utils.parseBytes;
    var KeyPair = require_key2();
    var Signature = require_signature2();
    function EDDSA(curve) {
      assert(curve === "ed25519", "only tested with ed25519 so far");
      if (!(this instanceof EDDSA))
        return new EDDSA(curve);
      curve = curves[curve].curve;
      this.curve = curve;
      this.g = curve.g;
      this.g.precompute(curve.n.bitLength() + 1);
      this.pointClass = curve.point().constructor;
      this.encodingLength = Math.ceil(curve.n.bitLength() / 8);
      this.hash = hash.sha512;
    }
    module2.exports = EDDSA;
    EDDSA.prototype.sign = function sign(message, secret) {
      message = parseBytes(message);
      var key = this.keyFromSecret(secret);
      var r = this.hashInt(key.messagePrefix(), message);
      var R = this.g.mul(r);
      var Rencoded = this.encodePoint(R);
      var s_ = this.hashInt(Rencoded, key.pubBytes(), message).mul(key.priv());
      var S = r.add(s_).umod(this.curve.n);
      return this.makeSignature({ R, S, Rencoded });
    };
    EDDSA.prototype.verify = function verify(message, sig, pub) {
      message = parseBytes(message);
      sig = this.makeSignature(sig);
      if (sig.S().gte(sig.eddsa.curve.n) || sig.S().isNeg()) {
        return false;
      }
      var key = this.keyFromPublic(pub);
      var h = this.hashInt(sig.Rencoded(), key.pubBytes(), message);
      var SG = this.g.mul(sig.S());
      var RplusAh = sig.R().add(key.pub().mul(h));
      return RplusAh.eq(SG);
    };
    EDDSA.prototype.hashInt = function hashInt() {
      var hash2 = this.hash();
      for (var i = 0; i < arguments.length; i++)
        hash2.update(arguments[i]);
      return utils.intFromLE(hash2.digest()).umod(this.curve.n);
    };
    EDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {
      return KeyPair.fromPublic(this, pub);
    };
    EDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {
      return KeyPair.fromSecret(this, secret);
    };
    EDDSA.prototype.makeSignature = function makeSignature(sig) {
      if (sig instanceof Signature)
        return sig;
      return new Signature(this, sig);
    };
    EDDSA.prototype.encodePoint = function encodePoint(point) {
      var enc = point.getY().toArray("le", this.encodingLength);
      enc[this.encodingLength - 1] |= point.getX().isOdd() ? 128 : 0;
      return enc;
    };
    EDDSA.prototype.decodePoint = function decodePoint(bytes) {
      bytes = utils.parseBytes(bytes);
      var lastIx = bytes.length - 1;
      var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & ~128);
      var xIsOdd = (bytes[lastIx] & 128) !== 0;
      var y = utils.intFromLE(normed);
      return this.curve.pointFromY(y, xIsOdd);
    };
    EDDSA.prototype.encodeInt = function encodeInt(num) {
      return num.toArray("le", this.encodingLength);
    };
    EDDSA.prototype.decodeInt = function decodeInt(bytes) {
      return utils.intFromLE(bytes);
    };
    EDDSA.prototype.isPoint = function isPoint(val) {
      return val instanceof this.pointClass;
    };
  }
});

// node_modules/elliptic/lib/elliptic.js
var require_elliptic = __commonJS({
  "node_modules/elliptic/lib/elliptic.js"(exports2) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var elliptic = exports2;
    elliptic.version = require_package().version;
    elliptic.utils = require_utils2();
    elliptic.rand = require_brorand();
    elliptic.curve = require_curve();
    elliptic.curves = require_curves();
    elliptic.ec = require_ec();
    elliptic.eddsa = require_eddsa();
  }
});

// node_modules/create-ecdh/node_modules/bn.js/lib/bn.js
var require_bn2 = __commonJS({
  "node_modules/create-ecdh/node_modules/bn.js/lib/bn.js"(exports2, module2) {
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    (function(module3, exports3) {
      "use strict";
      function assert(val, msg) {
        if (!val) throw new Error(msg || "Assertion failed");
      }
      function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN(number, base, endian) {
        if (BN.isBN(number)) {
          return number;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number !== null) {
          if (base === "le" || base === "be") {
            endian = base;
            base = 10;
          }
          this._init(number || 0, base || 10, endian || "be");
        }
      }
      if (typeof module3 === "object") {
        module3.exports = BN;
      } else {
        exports3.BN = BN;
      }
      BN.BN = BN;
      BN.wordSize = 26;
      var Buffer2;
      try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
          Buffer2 = window.Buffer;
        } else {
          Buffer2 = (init_dist(), __toCommonJS(dist_exports)).Buffer;
        }
      } catch (e) {
      }
      BN.isBN = function isBN(num) {
        if (num instanceof BN) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
      };
      BN.max = function max(left, right) {
        if (left.cmp(right) > 0) return left;
        return right;
      };
      BN.min = function min(left, right) {
        if (left.cmp(right) < 0) return left;
        return right;
      };
      BN.prototype._init = function init(number, base, endian) {
        if (typeof number === "number") {
          return this._initNumber(number, base, endian);
        }
        if (typeof number === "object") {
          return this._initArray(number, base, endian);
        }
        if (base === "hex") {
          base = 16;
        }
        assert(base === (base | 0) && base >= 2 && base <= 36);
        number = number.toString().replace(/\s+/g, "");
        var start = 0;
        if (number[0] === "-") {
          start++;
          this.negative = 1;
        }
        if (start < number.length) {
          if (base === 16) {
            this._parseHex(number, start, endian);
          } else {
            this._parseBase(number, base, start);
            if (endian === "le") {
              this._initArray(this.toArray(), base, endian);
            }
          }
        }
      };
      BN.prototype._initNumber = function _initNumber(number, base, endian) {
        if (number < 0) {
          this.negative = 1;
          number = -number;
        }
        if (number < 67108864) {
          this.words = [number & 67108863];
          this.length = 1;
        } else if (number < 4503599627370496) {
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert(number < 9007199254740992);
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le") return;
        this._initArray(this.toArray(), base, endian);
      };
      BN.prototype._initArray = function _initArray(number, base, endian) {
        assert(typeof number.length === "number");
        if (number.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var j, w;
        var off = 0;
        if (endian === "be") {
          for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
            w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        } else if (endian === "le") {
          for (i = 0, j = 0; i < number.length; i += 3) {
            w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        }
        return this.strip();
      };
      function parseHex4Bits(string, index) {
        var c = string.charCodeAt(index);
        if (c >= 65 && c <= 70) {
          return c - 55;
        } else if (c >= 97 && c <= 102) {
          return c - 87;
        } else {
          return c - 48 & 15;
        }
      }
      function parseHexByte(string, lowerBound, index) {
        var r = parseHex4Bits(string, index);
        if (index - 1 >= lowerBound) {
          r |= parseHex4Bits(string, index - 1) << 4;
        }
        return r;
      }
      BN.prototype._parseHex = function _parseHex(number, start, endian) {
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var off = 0;
        var j = 0;
        var w;
        if (endian === "be") {
          for (i = number.length - 1; i >= start; i -= 2) {
            w = parseHexByte(number, start, i) << off;
            this.words[j] |= w & 67108863;
            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w >>> 26;
            } else {
              off += 8;
            }
          }
        } else {
          var parseLength = number.length - start;
          for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
            w = parseHexByte(number, start, i) << off;
            this.words[j] |= w & 67108863;
            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w >>> 26;
            } else {
              off += 8;
            }
          }
        }
        this.strip();
      };
      function parseBase(str, start, end, mul) {
        var r = 0;
        var len = Math.min(str.length, end);
        for (var i = start; i < len; i++) {
          var c = str.charCodeAt(i) - 48;
          r *= mul;
          if (c >= 49) {
            r += c - 49 + 10;
          } else if (c >= 17) {
            r += c - 17 + 10;
          } else {
            r += c;
          }
        }
        return r;
      }
      BN.prototype._parseBase = function _parseBase(number, base, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base | 0;
        var total = number.length - start;
        var mod = total % limbLen;
        var end = Math.min(total, total - mod) + start;
        var word = 0;
        for (var i = start; i < end; i += limbLen) {
          word = parseBase(number, i, i + limbLen, base);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod !== 0) {
          var pow = 1;
          word = parseBase(number, i, number.length, base);
          for (i = 0; i < mod; i++) {
            pow *= base;
          }
          this.imuln(pow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        this.strip();
      };
      BN.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          dest.words[i] = this.words[i];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      BN.prototype.clone = function clone() {
        var r = new BN(null);
        this.copy(r);
        return r;
      };
      BN.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN.prototype.strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      BN.prototype.inspect = function inspect() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var zeros = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN.prototype.toString = function toString(base, padding) {
        base = base || 10;
        padding = padding | 0 || 1;
        var out;
        if (base === 16 || base === "hex") {
          out = "";
          var off = 0;
          var carry = 0;
          for (var i = 0; i < this.length; i++) {
            var w = this.words[i];
            var word = ((w << off | carry) & 16777215).toString(16);
            carry = w >>> 24 - off & 16777215;
            off += 2;
            if (off >= 26) {
              off -= 26;
              i--;
            }
            if (carry !== 0 || i !== this.length - 1) {
              out = zeros[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base === (base | 0) && base >= 2 && base <= 36) {
          var groupSize = groupSizes[base];
          var groupBase = groupBases[base];
          out = "";
          var c = this.clone();
          c.negative = 0;
          while (!c.isZero()) {
            var r = c.modn(groupBase).toString(base);
            c = c.idivn(groupBase);
            if (!c.isZero()) {
              out = zeros[groupSize - r.length] + r + out;
            } else {
              out = r + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert(false, "Base should be between 2 and 36");
      };
      BN.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN.prototype.toJSON = function toJSON() {
        return this.toString(16);
      };
      BN.prototype.toBuffer = function toBuffer(endian, length) {
        assert(typeof Buffer2 !== "undefined");
        return this.toArrayLike(Buffer2, endian, length);
      };
      BN.prototype.toArray = function toArray(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
      BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        var byteLength = this.byteLength();
        var reqLength = length || Math.max(1, byteLength);
        assert(byteLength <= reqLength, "byte array longer than desired length");
        assert(reqLength > 0, "Requested array length <= 0");
        this.strip();
        var littleEndian = endian === "le";
        var res = new ArrayType(reqLength);
        var b, i;
        var q = this.clone();
        if (!littleEndian) {
          for (i = 0; i < reqLength - byteLength; i++) {
            res[i] = 0;
          }
          for (i = 0; !q.isZero(); i++) {
            b = q.andln(255);
            q.iushrn(8);
            res[reqLength - i - 1] = b;
          }
        } else {
          for (i = 0; !q.isZero(); i++) {
            b = q.andln(255);
            q.iushrn(8);
            res[i] = b;
          }
          for (; i < reqLength; i++) {
            res[i] = 0;
          }
        }
        return res;
      };
      if (Math.clz32) {
        BN.prototype._countBits = function _countBits(w) {
          return 32 - Math.clz32(w);
        };
      } else {
        BN.prototype._countBits = function _countBits(w) {
          var t = w;
          var r = 0;
          if (t >= 4096) {
            r += 13;
            t >>>= 13;
          }
          if (t >= 64) {
            r += 7;
            t >>>= 7;
          }
          if (t >= 8) {
            r += 4;
            t >>>= 4;
          }
          if (t >= 2) {
            r += 2;
            t >>>= 2;
          }
          return r + t;
        };
      }
      BN.prototype._zeroBits = function _zeroBits(w) {
        if (w === 0) return 26;
        var t = w;
        var r = 0;
        if ((t & 8191) === 0) {
          r += 13;
          t >>>= 13;
        }
        if ((t & 127) === 0) {
          r += 7;
          t >>>= 7;
        }
        if ((t & 15) === 0) {
          r += 4;
          t >>>= 4;
        }
        if ((t & 3) === 0) {
          r += 2;
          t >>>= 2;
        }
        if ((t & 1) === 0) {
          r++;
        }
        return r;
      };
      BN.prototype.bitLength = function bitLength() {
        var w = this.words[this.length - 1];
        var hi = this._countBits(w);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num) {
        var w = new Array(num.bitLength());
        for (var bit = 0; bit < w.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w[bit] = (num.words[off] & 1 << wbit) >>> wbit;
        }
        return w;
      }
      BN.prototype.zeroBits = function zeroBits() {
        if (this.isZero()) return 0;
        var r = 0;
        for (var i = 0; i < this.length; i++) {
          var b = this._zeroBits(this.words[i]);
          r += b;
          if (b !== 26) break;
        }
        return r;
      };
      BN.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN.prototype.neg = function neg() {
        return this.clone().ineg();
      };
      BN.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i = 0; i < num.length; i++) {
          this.words[i] = this.words[i] | num.words[i];
        }
        return this.strip();
      };
      BN.prototype.ior = function ior(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN.prototype.or = function or(num) {
        if (this.length > num.length) return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN.prototype.uor = function uor(num) {
        if (this.length > num.length) return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN.prototype.iuand = function iuand(num) {
        var b;
        if (this.length > num.length) {
          b = num;
        } else {
          b = this;
        }
        for (var i = 0; i < b.length; i++) {
          this.words[i] = this.words[i] & num.words[i];
        }
        this.length = b.length;
        return this.strip();
      };
      BN.prototype.iand = function iand(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN.prototype.and = function and(num) {
        if (this.length > num.length) return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN.prototype.uand = function uand(num) {
        if (this.length > num.length) return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN.prototype.iuxor = function iuxor(num) {
        var a;
        var b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        for (var i = 0; i < b.length; i++) {
          this.words[i] = a.words[i] ^ b.words[i];
        }
        if (this !== a) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = a.length;
        return this.strip();
      };
      BN.prototype.ixor = function ixor(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN.prototype.xor = function xor(num) {
        if (this.length > num.length) return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN.prototype.uxor = function uxor(num) {
        if (this.length > num.length) return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN.prototype.inotn = function inotn(width) {
        assert(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i = 0; i < bytesNeeded; i++) {
          this.words[i] = ~this.words[i] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;
        }
        return this.strip();
      };
      BN.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN.prototype.setn = function setn(bit, val) {
        assert(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this.strip();
      };
      BN.prototype.iadd = function iadd(num) {
        var r;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r = this.isub(num);
          num.negative = 1;
          return r._normSign();
        }
        var a, b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i = 0; i < b.length; i++) {
          r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
          this.words[i] = r & 67108863;
          carry = r >>> 26;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          this.words[i] = r & 67108863;
          carry = r >>> 26;
        }
        this.length = a.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        return this;
      };
      BN.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length) return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r = this.iadd(num);
          num.negative = 1;
          return r._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a, b;
        if (cmp > 0) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i = 0; i < b.length; i++) {
          r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 67108863;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 67108863;
        }
        if (carry === 0 && i < a.length && a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = Math.max(this.length, i);
        if (a !== this) {
          this.negative = 1;
        }
        return this.strip();
      };
      BN.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len = self2.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a = self2.words[0] | 0;
        var b = num.words[0] | 0;
        var r = a * b;
        var lo = r & 67108863;
        var carry = r / 67108864 | 0;
        out.words[0] = lo;
        for (var k = 1; k < len; k++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i = k - j | 0;
            a = self2.words[i] | 0;
            b = num.words[j] | 0;
            r = a * b + rword;
            ncarry += r / 67108864 | 0;
            rword = r & 67108863;
          }
          out.words[k] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k] = carry | 0;
        } else {
          out.length--;
        }
        return out.strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num, out) {
        var a = self2.words;
        var b = num.words;
        var o = out.words;
        var c = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a2 = a[2] | 0;
        var al2 = a2 & 8191;
        var ah2 = a2 >>> 13;
        var a3 = a[3] | 0;
        var al3 = a3 & 8191;
        var ah3 = a3 >>> 13;
        var a4 = a[4] | 0;
        var al4 = a4 & 8191;
        var ah4 = a4 >>> 13;
        var a5 = a[5] | 0;
        var al5 = a5 & 8191;
        var ah5 = a5 >>> 13;
        var a6 = a[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b0 = b[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b2 = b[2] | 0;
        var bl2 = b2 & 8191;
        var bh2 = b2 >>> 13;
        var b3 = b[3] | 0;
        var bl3 = b3 & 8191;
        var bh3 = b3 >>> 13;
        var b4 = b[4] | 0;
        var bl4 = b4 & 8191;
        var bh4 = b4 >>> 13;
        var b5 = b[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
        w2 &= 67108863;
        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
        w3 &= 67108863;
        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
        w4 &= 67108863;
        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
        w5 &= 67108863;
        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o[0] = w0;
        o[1] = w1;
        o[2] = w2;
        o[3] = w3;
        o[4] = w4;
        o[5] = w5;
        o[6] = w6;
        o[7] = w7;
        o[8] = w8;
        o[9] = w9;
        o[10] = w10;
        o[11] = w11;
        o[12] = w12;
        o[13] = w13;
        o[14] = w14;
        o[15] = w15;
        o[16] = w16;
        o[17] = w17;
        o[18] = w18;
        if (c !== 0) {
          o[19] = c;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k = 0; k < out.length - 1; k++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i = k - j;
            var a = self2.words[i] | 0;
            var b = num.words[j] | 0;
            var r = a * b;
            var lo = r & 67108863;
            ncarry = ncarry + (r / 67108864 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 67108863;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k] = carry;
        } else {
          out.length--;
        }
        return out.strip();
      }
      function jumboMulTo(self2, num, out) {
        var fftm = new FFTM();
        return fftm.mulp(self2, num, out);
      }
      BN.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      function FFTM(x, y) {
        this.x = x;
        this.y = y;
      }
      FFTM.prototype.makeRBT = function makeRBT(N) {
        var t = new Array(N);
        var l = BN.prototype._countBits(N) - 1;
        for (var i = 0; i < N; i++) {
          t[i] = this.revBin(i, l, N);
        }
        return t;
      };
      FFTM.prototype.revBin = function revBin(x, l, N) {
        if (x === 0 || x === N - 1) return x;
        var rb = 0;
        for (var i = 0; i < l; i++) {
          rb |= (x & 1) << l - i - 1;
          x >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
        for (var i = 0; i < N; i++) {
          rtws[i] = rws[rbt[i]];
          itws[i] = iws[rbt[i]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N);
        for (var s = 1; s < N; s <<= 1) {
          var l = s << 1;
          var rtwdf = Math.cos(2 * Math.PI / l);
          var itwdf = Math.sin(2 * Math.PI / l);
          for (var p = 0; p < N; p += l) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j = 0; j < s; j++) {
              var re = rtws[p + j];
              var ie = itws[p + j];
              var ro = rtws[p + j + s];
              var io = itws[p + j + s];
              var rx = rtwdf_ * ro - itwdf_ * io;
              io = rtwdf_ * io + itwdf_ * ro;
              ro = rx;
              rtws[p + j] = re + ro;
              itws[p + j] = ie + io;
              rtws[p + j + s] = re - ro;
              itws[p + j + s] = ie - io;
              if (j !== l) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
        var N = Math.max(m, n) | 1;
        var odd = N & 1;
        var i = 0;
        for (N = N / 2 | 0; N; N = N >>> 1) {
          i++;
        }
        return 1 << i + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
        if (N <= 1) return;
        for (var i = 0; i < N / 2; i++) {
          var t = rws[i];
          rws[i] = rws[N - i - 1];
          rws[N - i - 1] = t;
          t = iws[i];
          iws[i] = -iws[N - i - 1];
          iws[N - i - 1] = -t;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws, N) {
        var carry = 0;
        for (var i = 0; i < N / 2; i++) {
          var w = Math.round(ws[2 * i + 1] / N) * 8192 + Math.round(ws[2 * i] / N) + carry;
          ws[i] = w & 67108863;
          if (w < 67108864) {
            carry = 0;
          } else {
            carry = w / 67108864 | 0;
          }
        }
        return ws;
      };
      FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
        var carry = 0;
        for (var i = 0; i < len; i++) {
          carry = carry + (ws[i] | 0);
          rws[2 * i] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i = 2 * len; i < N; ++i) {
          rws[i] = 0;
        }
        assert(carry === 0);
        assert((carry & ~8191) === 0);
      };
      FFTM.prototype.stub = function stub(N) {
        var ph = new Array(N);
        for (var i = 0; i < N; i++) {
          ph[i] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x, y, out) {
        var N = 2 * this.guessLen13b(x.length, y.length);
        var rbt = this.makeRBT(N);
        var _ = this.stub(N);
        var rws = new Array(N);
        var rwst = new Array(N);
        var iwst = new Array(N);
        var nrws = new Array(N);
        var nrwst = new Array(N);
        var niwst = new Array(N);
        var rmws = out.words;
        rmws.length = N;
        this.convert13b(x.words, x.length, rws, N);
        this.convert13b(y.words, y.length, nrws, N);
        this.transform(rws, _, rwst, iwst, N, rbt);
        this.transform(nrws, _, nrwst, niwst, N, rbt);
        for (var i = 0; i < N; i++) {
          var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
          iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
          rwst[i] = rx;
        }
        this.conjugate(rwst, iwst, N);
        this.transform(rwst, iwst, rmws, _, N, rbt);
        this.conjugate(rmws, _, N);
        this.normalize13b(rmws, N);
        out.negative = x.negative ^ y.negative;
        out.length = x.length + y.length;
        return out.strip();
      };
      BN.prototype.mul = function mul(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN.prototype.mulf = function mulf(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN.prototype.imuln = function imuln(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        var carry = 0;
        for (var i = 0; i < this.length; i++) {
          var w = (this.words[i] | 0) * num;
          var lo = (w & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w / 67108864 | 0;
          carry += lo >>> 26;
          this.words[i] = lo & 67108863;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        this.length = num === 0 ? 1 : this.length;
        return this;
      };
      BN.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN.prototype.pow = function pow(num) {
        var w = toBitArray(num);
        if (w.length === 0) return new BN(1);
        var res = this;
        for (var i = 0; i < w.length; i++, res = res.sqr()) {
          if (w[i] !== 0) break;
        }
        if (++i < w.length) {
          for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
            if (w[i] === 0) continue;
            res = res.mul(q);
          }
        }
        return res;
      };
      BN.prototype.iushln = function iushln(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        var carryMask = 67108863 >>> 26 - r << 26 - r;
        var i;
        if (r !== 0) {
          var carry = 0;
          for (i = 0; i < this.length; i++) {
            var newCarry = this.words[i] & carryMask;
            var c = (this.words[i] | 0) - newCarry << r;
            this.words[i] = c | carry;
            carry = newCarry >>> 26 - r;
          }
          if (carry) {
            this.words[i] = carry;
            this.length++;
          }
        }
        if (s !== 0) {
          for (i = this.length - 1; i >= 0; i--) {
            this.words[i + s] = this.words[i];
          }
          for (i = 0; i < s; i++) {
            this.words[i] = 0;
          }
          this.length += s;
        }
        return this.strip();
      };
      BN.prototype.ishln = function ishln(bits) {
        assert(this.negative === 0);
        return this.iushln(bits);
      };
      BN.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert(typeof bits === "number" && bits >= 0);
        var h;
        if (hint) {
          h = (hint - hint % 26) / 26;
        } else {
          h = 0;
        }
        var r = bits % 26;
        var s = Math.min((bits - r) / 26, this.length);
        var mask = 67108863 ^ 67108863 >>> r << r;
        var maskedWords = extended;
        h -= s;
        h = Math.max(0, h);
        if (maskedWords) {
          for (var i = 0; i < s; i++) {
            maskedWords.words[i] = this.words[i];
          }
          maskedWords.length = s;
        }
        if (s === 0) {
        } else if (this.length > s) {
          this.length -= s;
          for (i = 0; i < this.length; i++) {
            this.words[i] = this.words[i + s];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
          var word = this.words[i] | 0;
          this.words[i] = carry << 26 - r | word >>> r;
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this.strip();
      };
      BN.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN.prototype.testn = function testn(bit) {
        assert(typeof bit === "number" && bit >= 0);
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        if (this.length <= s) return false;
        var w = this.words[s];
        return !!(w & q);
      };
      BN.prototype.imaskn = function imaskn(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        assert(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s) {
          return this;
        }
        if (r !== 0) {
          s++;
        }
        this.length = Math.min(s, this.length);
        if (r !== 0) {
          var mask = 67108863 ^ 67108863 >>> r << r;
          this.words[this.length - 1] &= mask;
        }
        return this.strip();
      };
      BN.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN.prototype.iaddn = function iaddn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0) return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) < num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) {
          this.words[i] -= 67108864;
          if (i === this.length - 1) {
            this.words[i + 1] = 1;
          } else {
            this.words[i + 1]++;
          }
        }
        this.length = Math.max(this.length, i + 1);
        return this;
      };
      BN.prototype.isubn = function isubn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0) return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i = 0; i < this.length && this.words[i] < 0; i++) {
            this.words[i] += 67108864;
            this.words[i + 1] -= 1;
          }
        }
        return this.strip();
      };
      BN.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len = num.length + shift;
        var i;
        this._expand(len);
        var w;
        var carry = 0;
        for (i = 0; i < num.length; i++) {
          w = (this.words[i + shift] | 0) + carry;
          var right = (num.words[i] | 0) * mul;
          w -= right & 67108863;
          carry = (w >> 26) - (right / 67108864 | 0);
          this.words[i + shift] = w & 67108863;
        }
        for (; i < this.length - shift; i++) {
          w = (this.words[i + shift] | 0) + carry;
          carry = w >> 26;
          this.words[i + shift] = w & 67108863;
        }
        if (carry === 0) return this.strip();
        assert(carry === -1);
        carry = 0;
        for (i = 0; i < this.length; i++) {
          w = -(this.words[i] | 0) + carry;
          carry = w >> 26;
          this.words[i] = w & 67108863;
        }
        this.negative = 1;
        return this.strip();
      };
      BN.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a = this.clone();
        var b = num;
        var bhi = b.words[b.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b = b.ushln(shift);
          a.iushln(shift);
          bhi = b.words[b.length - 1] | 0;
        }
        var m = a.length - b.length;
        var q;
        if (mode !== "mod") {
          q = new BN(null);
          q.length = m + 1;
          q.words = new Array(q.length);
          for (var i = 0; i < q.length; i++) {
            q.words[i] = 0;
          }
        }
        var diff = a.clone()._ishlnsubmul(b, 1, m);
        if (diff.negative === 0) {
          a = diff;
          if (q) {
            q.words[m] = 1;
          }
        }
        for (var j = m - 1; j >= 0; j--) {
          var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a._ishlnsubmul(b, qj, j);
          while (a.negative !== 0) {
            qj--;
            a.negative = 0;
            a._ishlnsubmul(b, 1, j);
            if (!a.isZero()) {
              a.negative ^= 1;
            }
          }
          if (q) {
            q.words[j] = qj;
          }
        }
        if (q) {
          q.strip();
        }
        a.strip();
        if (mode !== "div" && shift !== 0) {
          a.iushrn(shift);
        }
        return {
          div: q || null,
          mod: a
        };
      };
      BN.prototype.divmod = function divmod(num, mode, positive) {
        assert(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN(0),
            mod: new BN(0)
          };
        }
        var div, mod, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.iadd(num);
            }
          }
          return {
            div,
            mod
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.isub(num);
            }
          }
          return {
            div: res.div,
            mod
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN(this.modn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN(this.modn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN.prototype.mod = function mod(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero()) return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r2 = num.andln(1);
        var cmp = mod.cmp(half);
        if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN.prototype.modn = function modn(num) {
        assert(num <= 67108863);
        var p = (1 << 26) % num;
        var acc = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          acc = (p * acc + (this.words[i] | 0)) % num;
        }
        return acc;
      };
      BN.prototype.idivn = function idivn(num) {
        assert(num <= 67108863);
        var carry = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var w = (this.words[i] | 0) + carry * 67108864;
          this.words[i] = w / num | 0;
          carry = w % num;
        }
        return this.strip();
      };
      BN.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN.prototype.egcd = function egcd(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var x = this;
        var y = p.clone();
        if (x.negative !== 0) {
          x = x.umod(p);
        } else {
          x = x.clone();
        }
        var A = new BN(1);
        var B = new BN(0);
        var C = new BN(0);
        var D = new BN(1);
        var g = 0;
        while (x.isEven() && y.isEven()) {
          x.iushrn(1);
          y.iushrn(1);
          ++g;
        }
        var yp = y.clone();
        var xp = x.clone();
        while (!x.isZero()) {
          for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1) ;
          if (i > 0) {
            x.iushrn(i);
            while (i-- > 0) {
              if (A.isOdd() || B.isOdd()) {
                A.iadd(yp);
                B.isub(xp);
              }
              A.iushrn(1);
              B.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1) ;
          if (j > 0) {
            y.iushrn(j);
            while (j-- > 0) {
              if (C.isOdd() || D.isOdd()) {
                C.iadd(yp);
                D.isub(xp);
              }
              C.iushrn(1);
              D.iushrn(1);
            }
          }
          if (x.cmp(y) >= 0) {
            x.isub(y);
            A.isub(C);
            B.isub(D);
          } else {
            y.isub(x);
            C.isub(A);
            D.isub(B);
          }
        }
        return {
          a: C,
          b: D,
          gcd: y.iushln(g)
        };
      };
      BN.prototype._invmp = function _invmp(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var a = this;
        var b = p.clone();
        if (a.negative !== 0) {
          a = a.umod(p);
        } else {
          a = a.clone();
        }
        var x1 = new BN(1);
        var x2 = new BN(0);
        var delta = b.clone();
        while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
          for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1) ;
          if (i > 0) {
            a.iushrn(i);
            while (i-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1) ;
          if (j > 0) {
            b.iushrn(j);
            while (j-- > 0) {
              if (x2.isOdd()) {
                x2.iadd(delta);
              }
              x2.iushrn(1);
            }
          }
          if (a.cmp(b) >= 0) {
            a.isub(b);
            x1.isub(x2);
          } else {
            b.isub(a);
            x2.isub(x1);
          }
        }
        var res;
        if (a.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x2;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p);
        }
        return res;
      };
      BN.prototype.gcd = function gcd(num) {
        if (this.isZero()) return num.abs();
        if (num.isZero()) return this.abs();
        var a = this.clone();
        var b = num.clone();
        a.negative = 0;
        b.negative = 0;
        for (var shift = 0; a.isEven() && b.isEven(); shift++) {
          a.iushrn(1);
          b.iushrn(1);
        }
        do {
          while (a.isEven()) {
            a.iushrn(1);
          }
          while (b.isEven()) {
            b.iushrn(1);
          }
          var r = a.cmp(b);
          if (r < 0) {
            var t = a;
            a = b;
            b = t;
          } else if (r === 0 || b.cmpn(1) === 0) {
            break;
          }
          a.isub(b);
        } while (true);
        return b.iushln(shift);
      };
      BN.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN.prototype.bincn = function bincn(bit) {
        assert(typeof bit === "number");
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        if (this.length <= s) {
          this._expand(s + 1);
          this.words[s] |= q;
          return this;
        }
        var carry = q;
        for (var i = s; carry !== 0 && i < this.length; i++) {
          var w = this.words[i] | 0;
          w += carry;
          carry = w >>> 26;
          w &= 67108863;
          this.words[i] = w;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        return this;
      };
      BN.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative) return -1;
        if (this.negative === 0 && negative) return 1;
        this.strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert(num <= 67108863, "Number is too big");
          var w = this.words[0] | 0;
          res = w === num ? 0 : w < num ? -1 : 1;
        }
        if (this.negative !== 0) return -res | 0;
        return res;
      };
      BN.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0) return -1;
        if (this.negative === 0 && num.negative !== 0) return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0) return -res | 0;
        return res;
      };
      BN.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length) return 1;
        if (this.length < num.length) return -1;
        var res = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var a = this.words[i] | 0;
          var b = num.words[i] | 0;
          if (a === b) continue;
          if (a < b) {
            res = -1;
          } else if (a > b) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
      };
      BN.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
      };
      BN.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      };
      BN.red = function red(num) {
        return new Red(num);
      };
      BN.prototype.toRed = function toRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        assert(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN.prototype.fromRed = function fromRed() {
        assert(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN.prototype.forceRed = function forceRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN.prototype.redAdd = function redAdd(num) {
        assert(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN.prototype.redIAdd = function redIAdd(num) {
        assert(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN.prototype.redSub = function redSub(num) {
        assert(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN.prototype.redISub = function redISub(num) {
        assert(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN.prototype.redShl = function redShl(num) {
        assert(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN.prototype.redMul = function redMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN.prototype.redIMul = function redIMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN.prototype.redSqr = function redSqr() {
        assert(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN.prototype.redISqr = function redISqr() {
        assert(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN.prototype.redSqrt = function redSqrt() {
        assert(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN.prototype.redInvm = function redInvm() {
        assert(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN.prototype.redNeg = function redNeg() {
        assert(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN.prototype.redPow = function redPow(num) {
        assert(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name, p) {
        this.name = name;
        this.p = new BN(p, 16);
        this.n = this.p.bitLength();
        this.k = new BN(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r = num;
        var rlen;
        do {
          this.split(r, this.tmp);
          r = this.imulK(r);
          r = r.iadd(this.tmp);
          rlen = r.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
        if (cmp === 0) {
          r.words[0] = 0;
          r.length = 1;
        } else if (cmp > 0) {
          r.isub(this.p);
        } else {
          if (r.strip !== void 0) {
            r.strip();
          } else {
            r._strip();
          }
        }
        return r;
      };
      MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      inherits(K256, MPrime);
      K256.prototype.split = function split(input, output) {
        var mask = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i = 0; i < outLen; i++) {
          output.words[i] = input.words[i];
        }
        output.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for (i = 10; i < input.length; i++) {
          var next = input.words[i] | 0;
          input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo = 0;
        for (var i = 0; i < num.length; i++) {
          var w = num.words[i] | 0;
          lo += w * 977;
          num.words[i] = lo & 67108863;
          lo = w * 64 + (lo / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      inherits(P224, MPrime);
      function P192() {
        MPrime.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      inherits(P192, MPrime);
      function P25519() {
        MPrime.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      inherits(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i = 0; i < num.length; i++) {
          var hi = (num.words[i] | 0) * 19 + carry;
          var lo = hi & 67108863;
          hi >>>= 26;
          num.words[i] = lo;
          carry = hi;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN._prime = function prime(name) {
        if (primes[name]) return primes[name];
        var prime2;
        if (name === "k256") {
          prime2 = new K256();
        } else if (name === "p224") {
          prime2 = new P224();
        } else if (name === "p192") {
          prime2 = new P192();
        } else if (name === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name);
        }
        primes[name] = prime2;
        return prime2;
      };
      function Red(m) {
        if (typeof m === "string") {
          var prime = BN._prime(m);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert(m.gtn(1), "modulus must be greater than 1");
          this.m = m;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a) {
        assert(a.negative === 0, "red works only with positives");
        assert(a.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a, b) {
        assert((a.negative | b.negative) === 0, "red works only with positives");
        assert(
          a.red && a.red === b.red,
          "red works only with red numbers"
        );
      };
      Red.prototype.imod = function imod(a) {
        if (this.prime) return this.prime.ireduce(a)._forceRed(this);
        return a.umod(this.m)._forceRed(this);
      };
      Red.prototype.neg = function neg(a) {
        if (a.isZero()) {
          return a.clone();
        }
        return this.m.sub(a)._forceRed(this);
      };
      Red.prototype.add = function add(a, b) {
        this._verify2(a, b);
        var res = a.add(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a, b) {
        this._verify2(a, b);
        var res = a.iadd(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a, b) {
        this._verify2(a, b);
        var res = a.sub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a, b) {
        this._verify2(a, b);
        var res = a.isub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a, num) {
        this._verify1(a);
        return this.imod(a.ushln(num));
      };
      Red.prototype.imul = function imul(a, b) {
        this._verify2(a, b);
        return this.imod(a.imul(b));
      };
      Red.prototype.mul = function mul(a, b) {
        this._verify2(a, b);
        return this.imod(a.mul(b));
      };
      Red.prototype.isqr = function isqr(a) {
        return this.imul(a, a.clone());
      };
      Red.prototype.sqr = function sqr(a) {
        return this.mul(a, a);
      };
      Red.prototype.sqrt = function sqrt(a) {
        if (a.isZero()) return a.clone();
        var mod3 = this.m.andln(3);
        assert(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow = this.m.add(new BN(1)).iushrn(2);
          return this.pow(a, pow);
        }
        var q = this.m.subn(1);
        var s = 0;
        while (!q.isZero() && q.andln(1) === 0) {
          s++;
          q.iushrn(1);
        }
        assert(!q.isZero());
        var one = new BN(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z = this.m.bitLength();
        z = new BN(2 * z * z).toRed(this);
        while (this.pow(z, lpow).cmp(nOne) !== 0) {
          z.redIAdd(nOne);
        }
        var c = this.pow(z, q);
        var r = this.pow(a, q.addn(1).iushrn(1));
        var t = this.pow(a, q);
        var m = s;
        while (t.cmp(one) !== 0) {
          var tmp = t;
          for (var i = 0; tmp.cmp(one) !== 0; i++) {
            tmp = tmp.redSqr();
          }
          assert(i < m);
          var b = this.pow(c, new BN(1).iushln(m - i - 1));
          r = r.redMul(b);
          c = b.redSqr();
          t = t.redMul(c);
          m = i;
        }
        return r;
      };
      Red.prototype.invm = function invm(a) {
        var inv = a._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow(a, num) {
        if (num.isZero()) return new BN(1).toRed(this);
        if (num.cmpn(1) === 0) return a.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN(1).toRed(this);
        wnd[1] = a;
        for (var i = 2; i < wnd.length; i++) {
          wnd[i] = this.mul(wnd[i - 1], a);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i = num.length - 1; i >= 0; i--) {
          var word = num.words[i];
          for (var j = start - 1; j >= 0; j--) {
            var bit = word >> j & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r = num.umod(this.m);
        return r === num ? r.clone() : r;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m) {
        Red.call(this, m);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r = this.imod(num.mul(this.rinv));
        r.red = null;
        return r;
      };
      Mont.prototype.imul = function imul(a, b) {
        if (a.isZero() || b.isZero()) {
          a.words[0] = 0;
          a.length = 1;
          return a;
        }
        var t = a.imul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul(a, b) {
        if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);
        var t = a.mul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a) {
        var res = this.imod(a._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module2 === "undefined" || module2, exports2);
  }
});

// node_modules/create-ecdh/browser.js
var require_browser2 = __commonJS({
  "node_modules/create-ecdh/browser.js"(exports2, module2) {
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var elliptic = require_elliptic();
    var BN = require_bn2();
    module2.exports = function createECDH(curve) {
      return new ECDH(curve);
    };
    var aliases = {
      secp256k1: {
        name: "secp256k1",
        byteLength: 32
      },
      secp224r1: {
        name: "p224",
        byteLength: 28
      },
      prime256v1: {
        name: "p256",
        byteLength: 32
      },
      prime192v1: {
        name: "p192",
        byteLength: 24
      },
      ed25519: {
        name: "ed25519",
        byteLength: 32
      },
      secp384r1: {
        name: "p384",
        byteLength: 48
      },
      secp521r1: {
        name: "p521",
        byteLength: 66
      }
    };
    aliases.p224 = aliases.secp224r1;
    aliases.p256 = aliases.secp256r1 = aliases.prime256v1;
    aliases.p192 = aliases.secp192r1 = aliases.prime192v1;
    aliases.p384 = aliases.secp384r1;
    aliases.p521 = aliases.secp521r1;
    function ECDH(curve) {
      this.curveType = aliases[curve];
      if (!this.curveType) {
        this.curveType = {
          name: curve
        };
      }
      this.curve = new elliptic.ec(this.curveType.name);
      this.keys = void 0;
    }
    ECDH.prototype.generateKeys = function(enc, format) {
      this.keys = this.curve.genKeyPair();
      return this.getPublicKey(enc, format);
    };
    ECDH.prototype.computeSecret = function(other, inenc, enc) {
      inenc = inenc || "utf8";
      if (!Buffer.isBuffer(other)) {
        other = new Buffer(other, inenc);
      }
      var otherPub = this.curve.keyFromPublic(other).getPublic();
      var out = otherPub.mul(this.keys.getPrivate()).getX();
      return formatReturnValue(out, enc, this.curveType.byteLength);
    };
    ECDH.prototype.getPublicKey = function(enc, format) {
      var key = this.keys.getPublic(format === "compressed", true);
      if (format === "hybrid") {
        if (key[key.length - 1] % 2) {
          key[0] = 7;
        } else {
          key[0] = 6;
        }
      }
      return formatReturnValue(key, enc);
    };
    ECDH.prototype.getPrivateKey = function(enc) {
      return formatReturnValue(this.keys.getPrivate(), enc);
    };
    ECDH.prototype.setPublicKey = function(pub, enc) {
      enc = enc || "utf8";
      if (!Buffer.isBuffer(pub)) {
        pub = new Buffer(pub, enc);
      }
      this.keys._importPublic(pub);
      return this;
    };
    ECDH.prototype.setPrivateKey = function(priv, enc) {
      enc = enc || "utf8";
      if (!Buffer.isBuffer(priv)) {
        priv = new Buffer(priv, enc);
      }
      var _priv = new BN(priv);
      _priv = _priv.toString(16);
      this.keys = this.curve.genKeyPair();
      this.keys._importPrivate(_priv);
      return this;
    };
    function formatReturnValue(bn, enc, len) {
      if (!Array.isArray(bn)) {
        bn = bn.toArray();
      }
      var buf = new Buffer(bn);
      if (len && buf.length < len) {
        var zeros = new Buffer(len - buf.length);
        zeros.fill(0);
        buf = Buffer.concat([zeros, buf]);
      }
      if (!enc) {
        return buf;
      } else {
        return buf.toString(enc);
      }
    }
  }
});

// node_modules/create-ecdh/index.js
var require_create_ecdh = __commonJS({
  "node_modules/create-ecdh/index.js"(exports2, module2) {
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var createECDH = require_crypto_browserify().createECDH;
    module2.exports = createECDH || require_browser2();
  }
});

// node_modules/asn1.js/node_modules/bn.js/lib/bn.js
var require_bn3 = __commonJS({
  "node_modules/asn1.js/node_modules/bn.js/lib/bn.js"(exports2, module2) {
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    (function(module3, exports3) {
      "use strict";
      function assert(val, msg) {
        if (!val) throw new Error(msg || "Assertion failed");
      }
      function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN(number, base, endian) {
        if (BN.isBN(number)) {
          return number;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number !== null) {
          if (base === "le" || base === "be") {
            endian = base;
            base = 10;
          }
          this._init(number || 0, base || 10, endian || "be");
        }
      }
      if (typeof module3 === "object") {
        module3.exports = BN;
      } else {
        exports3.BN = BN;
      }
      BN.BN = BN;
      BN.wordSize = 26;
      var Buffer2;
      try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
          Buffer2 = window.Buffer;
        } else {
          Buffer2 = (init_dist(), __toCommonJS(dist_exports)).Buffer;
        }
      } catch (e) {
      }
      BN.isBN = function isBN(num) {
        if (num instanceof BN) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
      };
      BN.max = function max(left, right) {
        if (left.cmp(right) > 0) return left;
        return right;
      };
      BN.min = function min(left, right) {
        if (left.cmp(right) < 0) return left;
        return right;
      };
      BN.prototype._init = function init(number, base, endian) {
        if (typeof number === "number") {
          return this._initNumber(number, base, endian);
        }
        if (typeof number === "object") {
          return this._initArray(number, base, endian);
        }
        if (base === "hex") {
          base = 16;
        }
        assert(base === (base | 0) && base >= 2 && base <= 36);
        number = number.toString().replace(/\s+/g, "");
        var start = 0;
        if (number[0] === "-") {
          start++;
          this.negative = 1;
        }
        if (start < number.length) {
          if (base === 16) {
            this._parseHex(number, start, endian);
          } else {
            this._parseBase(number, base, start);
            if (endian === "le") {
              this._initArray(this.toArray(), base, endian);
            }
          }
        }
      };
      BN.prototype._initNumber = function _initNumber(number, base, endian) {
        if (number < 0) {
          this.negative = 1;
          number = -number;
        }
        if (number < 67108864) {
          this.words = [number & 67108863];
          this.length = 1;
        } else if (number < 4503599627370496) {
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert(number < 9007199254740992);
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le") return;
        this._initArray(this.toArray(), base, endian);
      };
      BN.prototype._initArray = function _initArray(number, base, endian) {
        assert(typeof number.length === "number");
        if (number.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var j, w;
        var off = 0;
        if (endian === "be") {
          for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
            w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        } else if (endian === "le") {
          for (i = 0, j = 0; i < number.length; i += 3) {
            w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        }
        return this.strip();
      };
      function parseHex4Bits(string, index) {
        var c = string.charCodeAt(index);
        if (c >= 65 && c <= 70) {
          return c - 55;
        } else if (c >= 97 && c <= 102) {
          return c - 87;
        } else {
          return c - 48 & 15;
        }
      }
      function parseHexByte(string, lowerBound, index) {
        var r = parseHex4Bits(string, index);
        if (index - 1 >= lowerBound) {
          r |= parseHex4Bits(string, index - 1) << 4;
        }
        return r;
      }
      BN.prototype._parseHex = function _parseHex(number, start, endian) {
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var off = 0;
        var j = 0;
        var w;
        if (endian === "be") {
          for (i = number.length - 1; i >= start; i -= 2) {
            w = parseHexByte(number, start, i) << off;
            this.words[j] |= w & 67108863;
            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w >>> 26;
            } else {
              off += 8;
            }
          }
        } else {
          var parseLength = number.length - start;
          for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
            w = parseHexByte(number, start, i) << off;
            this.words[j] |= w & 67108863;
            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w >>> 26;
            } else {
              off += 8;
            }
          }
        }
        this.strip();
      };
      function parseBase(str, start, end, mul) {
        var r = 0;
        var len = Math.min(str.length, end);
        for (var i = start; i < len; i++) {
          var c = str.charCodeAt(i) - 48;
          r *= mul;
          if (c >= 49) {
            r += c - 49 + 10;
          } else if (c >= 17) {
            r += c - 17 + 10;
          } else {
            r += c;
          }
        }
        return r;
      }
      BN.prototype._parseBase = function _parseBase(number, base, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base | 0;
        var total = number.length - start;
        var mod = total % limbLen;
        var end = Math.min(total, total - mod) + start;
        var word = 0;
        for (var i = start; i < end; i += limbLen) {
          word = parseBase(number, i, i + limbLen, base);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod !== 0) {
          var pow = 1;
          word = parseBase(number, i, number.length, base);
          for (i = 0; i < mod; i++) {
            pow *= base;
          }
          this.imuln(pow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        this.strip();
      };
      BN.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          dest.words[i] = this.words[i];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      BN.prototype.clone = function clone() {
        var r = new BN(null);
        this.copy(r);
        return r;
      };
      BN.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN.prototype.strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      BN.prototype.inspect = function inspect() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var zeros = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN.prototype.toString = function toString(base, padding) {
        base = base || 10;
        padding = padding | 0 || 1;
        var out;
        if (base === 16 || base === "hex") {
          out = "";
          var off = 0;
          var carry = 0;
          for (var i = 0; i < this.length; i++) {
            var w = this.words[i];
            var word = ((w << off | carry) & 16777215).toString(16);
            carry = w >>> 24 - off & 16777215;
            off += 2;
            if (off >= 26) {
              off -= 26;
              i--;
            }
            if (carry !== 0 || i !== this.length - 1) {
              out = zeros[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base === (base | 0) && base >= 2 && base <= 36) {
          var groupSize = groupSizes[base];
          var groupBase = groupBases[base];
          out = "";
          var c = this.clone();
          c.negative = 0;
          while (!c.isZero()) {
            var r = c.modn(groupBase).toString(base);
            c = c.idivn(groupBase);
            if (!c.isZero()) {
              out = zeros[groupSize - r.length] + r + out;
            } else {
              out = r + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert(false, "Base should be between 2 and 36");
      };
      BN.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN.prototype.toJSON = function toJSON() {
        return this.toString(16);
      };
      BN.prototype.toBuffer = function toBuffer(endian, length) {
        assert(typeof Buffer2 !== "undefined");
        return this.toArrayLike(Buffer2, endian, length);
      };
      BN.prototype.toArray = function toArray(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
      BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        var byteLength = this.byteLength();
        var reqLength = length || Math.max(1, byteLength);
        assert(byteLength <= reqLength, "byte array longer than desired length");
        assert(reqLength > 0, "Requested array length <= 0");
        this.strip();
        var littleEndian = endian === "le";
        var res = new ArrayType(reqLength);
        var b, i;
        var q = this.clone();
        if (!littleEndian) {
          for (i = 0; i < reqLength - byteLength; i++) {
            res[i] = 0;
          }
          for (i = 0; !q.isZero(); i++) {
            b = q.andln(255);
            q.iushrn(8);
            res[reqLength - i - 1] = b;
          }
        } else {
          for (i = 0; !q.isZero(); i++) {
            b = q.andln(255);
            q.iushrn(8);
            res[i] = b;
          }
          for (; i < reqLength; i++) {
            res[i] = 0;
          }
        }
        return res;
      };
      if (Math.clz32) {
        BN.prototype._countBits = function _countBits(w) {
          return 32 - Math.clz32(w);
        };
      } else {
        BN.prototype._countBits = function _countBits(w) {
          var t = w;
          var r = 0;
          if (t >= 4096) {
            r += 13;
            t >>>= 13;
          }
          if (t >= 64) {
            r += 7;
            t >>>= 7;
          }
          if (t >= 8) {
            r += 4;
            t >>>= 4;
          }
          if (t >= 2) {
            r += 2;
            t >>>= 2;
          }
          return r + t;
        };
      }
      BN.prototype._zeroBits = function _zeroBits(w) {
        if (w === 0) return 26;
        var t = w;
        var r = 0;
        if ((t & 8191) === 0) {
          r += 13;
          t >>>= 13;
        }
        if ((t & 127) === 0) {
          r += 7;
          t >>>= 7;
        }
        if ((t & 15) === 0) {
          r += 4;
          t >>>= 4;
        }
        if ((t & 3) === 0) {
          r += 2;
          t >>>= 2;
        }
        if ((t & 1) === 0) {
          r++;
        }
        return r;
      };
      BN.prototype.bitLength = function bitLength() {
        var w = this.words[this.length - 1];
        var hi = this._countBits(w);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num) {
        var w = new Array(num.bitLength());
        for (var bit = 0; bit < w.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w[bit] = (num.words[off] & 1 << wbit) >>> wbit;
        }
        return w;
      }
      BN.prototype.zeroBits = function zeroBits() {
        if (this.isZero()) return 0;
        var r = 0;
        for (var i = 0; i < this.length; i++) {
          var b = this._zeroBits(this.words[i]);
          r += b;
          if (b !== 26) break;
        }
        return r;
      };
      BN.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN.prototype.neg = function neg() {
        return this.clone().ineg();
      };
      BN.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i = 0; i < num.length; i++) {
          this.words[i] = this.words[i] | num.words[i];
        }
        return this.strip();
      };
      BN.prototype.ior = function ior(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN.prototype.or = function or(num) {
        if (this.length > num.length) return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN.prototype.uor = function uor(num) {
        if (this.length > num.length) return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN.prototype.iuand = function iuand(num) {
        var b;
        if (this.length > num.length) {
          b = num;
        } else {
          b = this;
        }
        for (var i = 0; i < b.length; i++) {
          this.words[i] = this.words[i] & num.words[i];
        }
        this.length = b.length;
        return this.strip();
      };
      BN.prototype.iand = function iand(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN.prototype.and = function and(num) {
        if (this.length > num.length) return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN.prototype.uand = function uand(num) {
        if (this.length > num.length) return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN.prototype.iuxor = function iuxor(num) {
        var a;
        var b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        for (var i = 0; i < b.length; i++) {
          this.words[i] = a.words[i] ^ b.words[i];
        }
        if (this !== a) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = a.length;
        return this.strip();
      };
      BN.prototype.ixor = function ixor(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN.prototype.xor = function xor(num) {
        if (this.length > num.length) return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN.prototype.uxor = function uxor(num) {
        if (this.length > num.length) return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN.prototype.inotn = function inotn(width) {
        assert(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i = 0; i < bytesNeeded; i++) {
          this.words[i] = ~this.words[i] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;
        }
        return this.strip();
      };
      BN.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN.prototype.setn = function setn(bit, val) {
        assert(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this.strip();
      };
      BN.prototype.iadd = function iadd(num) {
        var r;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r = this.isub(num);
          num.negative = 1;
          return r._normSign();
        }
        var a, b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i = 0; i < b.length; i++) {
          r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
          this.words[i] = r & 67108863;
          carry = r >>> 26;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          this.words[i] = r & 67108863;
          carry = r >>> 26;
        }
        this.length = a.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        return this;
      };
      BN.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length) return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r = this.iadd(num);
          num.negative = 1;
          return r._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a, b;
        if (cmp > 0) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i = 0; i < b.length; i++) {
          r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 67108863;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 67108863;
        }
        if (carry === 0 && i < a.length && a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = Math.max(this.length, i);
        if (a !== this) {
          this.negative = 1;
        }
        return this.strip();
      };
      BN.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len = self2.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a = self2.words[0] | 0;
        var b = num.words[0] | 0;
        var r = a * b;
        var lo = r & 67108863;
        var carry = r / 67108864 | 0;
        out.words[0] = lo;
        for (var k = 1; k < len; k++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i = k - j | 0;
            a = self2.words[i] | 0;
            b = num.words[j] | 0;
            r = a * b + rword;
            ncarry += r / 67108864 | 0;
            rword = r & 67108863;
          }
          out.words[k] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k] = carry | 0;
        } else {
          out.length--;
        }
        return out.strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num, out) {
        var a = self2.words;
        var b = num.words;
        var o = out.words;
        var c = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a2 = a[2] | 0;
        var al2 = a2 & 8191;
        var ah2 = a2 >>> 13;
        var a3 = a[3] | 0;
        var al3 = a3 & 8191;
        var ah3 = a3 >>> 13;
        var a4 = a[4] | 0;
        var al4 = a4 & 8191;
        var ah4 = a4 >>> 13;
        var a5 = a[5] | 0;
        var al5 = a5 & 8191;
        var ah5 = a5 >>> 13;
        var a6 = a[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b0 = b[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b2 = b[2] | 0;
        var bl2 = b2 & 8191;
        var bh2 = b2 >>> 13;
        var b3 = b[3] | 0;
        var bl3 = b3 & 8191;
        var bh3 = b3 >>> 13;
        var b4 = b[4] | 0;
        var bl4 = b4 & 8191;
        var bh4 = b4 >>> 13;
        var b5 = b[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
        w2 &= 67108863;
        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
        w3 &= 67108863;
        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
        w4 &= 67108863;
        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
        w5 &= 67108863;
        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o[0] = w0;
        o[1] = w1;
        o[2] = w2;
        o[3] = w3;
        o[4] = w4;
        o[5] = w5;
        o[6] = w6;
        o[7] = w7;
        o[8] = w8;
        o[9] = w9;
        o[10] = w10;
        o[11] = w11;
        o[12] = w12;
        o[13] = w13;
        o[14] = w14;
        o[15] = w15;
        o[16] = w16;
        o[17] = w17;
        o[18] = w18;
        if (c !== 0) {
          o[19] = c;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k = 0; k < out.length - 1; k++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i = k - j;
            var a = self2.words[i] | 0;
            var b = num.words[j] | 0;
            var r = a * b;
            var lo = r & 67108863;
            ncarry = ncarry + (r / 67108864 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 67108863;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k] = carry;
        } else {
          out.length--;
        }
        return out.strip();
      }
      function jumboMulTo(self2, num, out) {
        var fftm = new FFTM();
        return fftm.mulp(self2, num, out);
      }
      BN.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      function FFTM(x, y) {
        this.x = x;
        this.y = y;
      }
      FFTM.prototype.makeRBT = function makeRBT(N) {
        var t = new Array(N);
        var l = BN.prototype._countBits(N) - 1;
        for (var i = 0; i < N; i++) {
          t[i] = this.revBin(i, l, N);
        }
        return t;
      };
      FFTM.prototype.revBin = function revBin(x, l, N) {
        if (x === 0 || x === N - 1) return x;
        var rb = 0;
        for (var i = 0; i < l; i++) {
          rb |= (x & 1) << l - i - 1;
          x >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
        for (var i = 0; i < N; i++) {
          rtws[i] = rws[rbt[i]];
          itws[i] = iws[rbt[i]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N);
        for (var s = 1; s < N; s <<= 1) {
          var l = s << 1;
          var rtwdf = Math.cos(2 * Math.PI / l);
          var itwdf = Math.sin(2 * Math.PI / l);
          for (var p = 0; p < N; p += l) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j = 0; j < s; j++) {
              var re = rtws[p + j];
              var ie = itws[p + j];
              var ro = rtws[p + j + s];
              var io = itws[p + j + s];
              var rx = rtwdf_ * ro - itwdf_ * io;
              io = rtwdf_ * io + itwdf_ * ro;
              ro = rx;
              rtws[p + j] = re + ro;
              itws[p + j] = ie + io;
              rtws[p + j + s] = re - ro;
              itws[p + j + s] = ie - io;
              if (j !== l) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
        var N = Math.max(m, n) | 1;
        var odd = N & 1;
        var i = 0;
        for (N = N / 2 | 0; N; N = N >>> 1) {
          i++;
        }
        return 1 << i + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
        if (N <= 1) return;
        for (var i = 0; i < N / 2; i++) {
          var t = rws[i];
          rws[i] = rws[N - i - 1];
          rws[N - i - 1] = t;
          t = iws[i];
          iws[i] = -iws[N - i - 1];
          iws[N - i - 1] = -t;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws, N) {
        var carry = 0;
        for (var i = 0; i < N / 2; i++) {
          var w = Math.round(ws[2 * i + 1] / N) * 8192 + Math.round(ws[2 * i] / N) + carry;
          ws[i] = w & 67108863;
          if (w < 67108864) {
            carry = 0;
          } else {
            carry = w / 67108864 | 0;
          }
        }
        return ws;
      };
      FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
        var carry = 0;
        for (var i = 0; i < len; i++) {
          carry = carry + (ws[i] | 0);
          rws[2 * i] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i = 2 * len; i < N; ++i) {
          rws[i] = 0;
        }
        assert(carry === 0);
        assert((carry & ~8191) === 0);
      };
      FFTM.prototype.stub = function stub(N) {
        var ph = new Array(N);
        for (var i = 0; i < N; i++) {
          ph[i] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x, y, out) {
        var N = 2 * this.guessLen13b(x.length, y.length);
        var rbt = this.makeRBT(N);
        var _ = this.stub(N);
        var rws = new Array(N);
        var rwst = new Array(N);
        var iwst = new Array(N);
        var nrws = new Array(N);
        var nrwst = new Array(N);
        var niwst = new Array(N);
        var rmws = out.words;
        rmws.length = N;
        this.convert13b(x.words, x.length, rws, N);
        this.convert13b(y.words, y.length, nrws, N);
        this.transform(rws, _, rwst, iwst, N, rbt);
        this.transform(nrws, _, nrwst, niwst, N, rbt);
        for (var i = 0; i < N; i++) {
          var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
          iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
          rwst[i] = rx;
        }
        this.conjugate(rwst, iwst, N);
        this.transform(rwst, iwst, rmws, _, N, rbt);
        this.conjugate(rmws, _, N);
        this.normalize13b(rmws, N);
        out.negative = x.negative ^ y.negative;
        out.length = x.length + y.length;
        return out.strip();
      };
      BN.prototype.mul = function mul(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN.prototype.mulf = function mulf(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN.prototype.imuln = function imuln(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        var carry = 0;
        for (var i = 0; i < this.length; i++) {
          var w = (this.words[i] | 0) * num;
          var lo = (w & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w / 67108864 | 0;
          carry += lo >>> 26;
          this.words[i] = lo & 67108863;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        this.length = num === 0 ? 1 : this.length;
        return this;
      };
      BN.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN.prototype.pow = function pow(num) {
        var w = toBitArray(num);
        if (w.length === 0) return new BN(1);
        var res = this;
        for (var i = 0; i < w.length; i++, res = res.sqr()) {
          if (w[i] !== 0) break;
        }
        if (++i < w.length) {
          for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
            if (w[i] === 0) continue;
            res = res.mul(q);
          }
        }
        return res;
      };
      BN.prototype.iushln = function iushln(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        var carryMask = 67108863 >>> 26 - r << 26 - r;
        var i;
        if (r !== 0) {
          var carry = 0;
          for (i = 0; i < this.length; i++) {
            var newCarry = this.words[i] & carryMask;
            var c = (this.words[i] | 0) - newCarry << r;
            this.words[i] = c | carry;
            carry = newCarry >>> 26 - r;
          }
          if (carry) {
            this.words[i] = carry;
            this.length++;
          }
        }
        if (s !== 0) {
          for (i = this.length - 1; i >= 0; i--) {
            this.words[i + s] = this.words[i];
          }
          for (i = 0; i < s; i++) {
            this.words[i] = 0;
          }
          this.length += s;
        }
        return this.strip();
      };
      BN.prototype.ishln = function ishln(bits) {
        assert(this.negative === 0);
        return this.iushln(bits);
      };
      BN.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert(typeof bits === "number" && bits >= 0);
        var h;
        if (hint) {
          h = (hint - hint % 26) / 26;
        } else {
          h = 0;
        }
        var r = bits % 26;
        var s = Math.min((bits - r) / 26, this.length);
        var mask = 67108863 ^ 67108863 >>> r << r;
        var maskedWords = extended;
        h -= s;
        h = Math.max(0, h);
        if (maskedWords) {
          for (var i = 0; i < s; i++) {
            maskedWords.words[i] = this.words[i];
          }
          maskedWords.length = s;
        }
        if (s === 0) {
        } else if (this.length > s) {
          this.length -= s;
          for (i = 0; i < this.length; i++) {
            this.words[i] = this.words[i + s];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
          var word = this.words[i] | 0;
          this.words[i] = carry << 26 - r | word >>> r;
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this.strip();
      };
      BN.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN.prototype.testn = function testn(bit) {
        assert(typeof bit === "number" && bit >= 0);
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        if (this.length <= s) return false;
        var w = this.words[s];
        return !!(w & q);
      };
      BN.prototype.imaskn = function imaskn(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        assert(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s) {
          return this;
        }
        if (r !== 0) {
          s++;
        }
        this.length = Math.min(s, this.length);
        if (r !== 0) {
          var mask = 67108863 ^ 67108863 >>> r << r;
          this.words[this.length - 1] &= mask;
        }
        return this.strip();
      };
      BN.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN.prototype.iaddn = function iaddn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0) return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) < num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) {
          this.words[i] -= 67108864;
          if (i === this.length - 1) {
            this.words[i + 1] = 1;
          } else {
            this.words[i + 1]++;
          }
        }
        this.length = Math.max(this.length, i + 1);
        return this;
      };
      BN.prototype.isubn = function isubn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0) return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i = 0; i < this.length && this.words[i] < 0; i++) {
            this.words[i] += 67108864;
            this.words[i + 1] -= 1;
          }
        }
        return this.strip();
      };
      BN.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len = num.length + shift;
        var i;
        this._expand(len);
        var w;
        var carry = 0;
        for (i = 0; i < num.length; i++) {
          w = (this.words[i + shift] | 0) + carry;
          var right = (num.words[i] | 0) * mul;
          w -= right & 67108863;
          carry = (w >> 26) - (right / 67108864 | 0);
          this.words[i + shift] = w & 67108863;
        }
        for (; i < this.length - shift; i++) {
          w = (this.words[i + shift] | 0) + carry;
          carry = w >> 26;
          this.words[i + shift] = w & 67108863;
        }
        if (carry === 0) return this.strip();
        assert(carry === -1);
        carry = 0;
        for (i = 0; i < this.length; i++) {
          w = -(this.words[i] | 0) + carry;
          carry = w >> 26;
          this.words[i] = w & 67108863;
        }
        this.negative = 1;
        return this.strip();
      };
      BN.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a = this.clone();
        var b = num;
        var bhi = b.words[b.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b = b.ushln(shift);
          a.iushln(shift);
          bhi = b.words[b.length - 1] | 0;
        }
        var m = a.length - b.length;
        var q;
        if (mode !== "mod") {
          q = new BN(null);
          q.length = m + 1;
          q.words = new Array(q.length);
          for (var i = 0; i < q.length; i++) {
            q.words[i] = 0;
          }
        }
        var diff = a.clone()._ishlnsubmul(b, 1, m);
        if (diff.negative === 0) {
          a = diff;
          if (q) {
            q.words[m] = 1;
          }
        }
        for (var j = m - 1; j >= 0; j--) {
          var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a._ishlnsubmul(b, qj, j);
          while (a.negative !== 0) {
            qj--;
            a.negative = 0;
            a._ishlnsubmul(b, 1, j);
            if (!a.isZero()) {
              a.negative ^= 1;
            }
          }
          if (q) {
            q.words[j] = qj;
          }
        }
        if (q) {
          q.strip();
        }
        a.strip();
        if (mode !== "div" && shift !== 0) {
          a.iushrn(shift);
        }
        return {
          div: q || null,
          mod: a
        };
      };
      BN.prototype.divmod = function divmod(num, mode, positive) {
        assert(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN(0),
            mod: new BN(0)
          };
        }
        var div, mod, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.iadd(num);
            }
          }
          return {
            div,
            mod
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.isub(num);
            }
          }
          return {
            div: res.div,
            mod
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN(this.modn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN(this.modn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN.prototype.mod = function mod(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero()) return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r2 = num.andln(1);
        var cmp = mod.cmp(half);
        if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN.prototype.modn = function modn(num) {
        assert(num <= 67108863);
        var p = (1 << 26) % num;
        var acc = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          acc = (p * acc + (this.words[i] | 0)) % num;
        }
        return acc;
      };
      BN.prototype.idivn = function idivn(num) {
        assert(num <= 67108863);
        var carry = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var w = (this.words[i] | 0) + carry * 67108864;
          this.words[i] = w / num | 0;
          carry = w % num;
        }
        return this.strip();
      };
      BN.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN.prototype.egcd = function egcd(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var x = this;
        var y = p.clone();
        if (x.negative !== 0) {
          x = x.umod(p);
        } else {
          x = x.clone();
        }
        var A = new BN(1);
        var B = new BN(0);
        var C = new BN(0);
        var D = new BN(1);
        var g = 0;
        while (x.isEven() && y.isEven()) {
          x.iushrn(1);
          y.iushrn(1);
          ++g;
        }
        var yp = y.clone();
        var xp = x.clone();
        while (!x.isZero()) {
          for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1) ;
          if (i > 0) {
            x.iushrn(i);
            while (i-- > 0) {
              if (A.isOdd() || B.isOdd()) {
                A.iadd(yp);
                B.isub(xp);
              }
              A.iushrn(1);
              B.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1) ;
          if (j > 0) {
            y.iushrn(j);
            while (j-- > 0) {
              if (C.isOdd() || D.isOdd()) {
                C.iadd(yp);
                D.isub(xp);
              }
              C.iushrn(1);
              D.iushrn(1);
            }
          }
          if (x.cmp(y) >= 0) {
            x.isub(y);
            A.isub(C);
            B.isub(D);
          } else {
            y.isub(x);
            C.isub(A);
            D.isub(B);
          }
        }
        return {
          a: C,
          b: D,
          gcd: y.iushln(g)
        };
      };
      BN.prototype._invmp = function _invmp(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var a = this;
        var b = p.clone();
        if (a.negative !== 0) {
          a = a.umod(p);
        } else {
          a = a.clone();
        }
        var x1 = new BN(1);
        var x2 = new BN(0);
        var delta = b.clone();
        while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
          for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1) ;
          if (i > 0) {
            a.iushrn(i);
            while (i-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1) ;
          if (j > 0) {
            b.iushrn(j);
            while (j-- > 0) {
              if (x2.isOdd()) {
                x2.iadd(delta);
              }
              x2.iushrn(1);
            }
          }
          if (a.cmp(b) >= 0) {
            a.isub(b);
            x1.isub(x2);
          } else {
            b.isub(a);
            x2.isub(x1);
          }
        }
        var res;
        if (a.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x2;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p);
        }
        return res;
      };
      BN.prototype.gcd = function gcd(num) {
        if (this.isZero()) return num.abs();
        if (num.isZero()) return this.abs();
        var a = this.clone();
        var b = num.clone();
        a.negative = 0;
        b.negative = 0;
        for (var shift = 0; a.isEven() && b.isEven(); shift++) {
          a.iushrn(1);
          b.iushrn(1);
        }
        do {
          while (a.isEven()) {
            a.iushrn(1);
          }
          while (b.isEven()) {
            b.iushrn(1);
          }
          var r = a.cmp(b);
          if (r < 0) {
            var t = a;
            a = b;
            b = t;
          } else if (r === 0 || b.cmpn(1) === 0) {
            break;
          }
          a.isub(b);
        } while (true);
        return b.iushln(shift);
      };
      BN.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN.prototype.bincn = function bincn(bit) {
        assert(typeof bit === "number");
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        if (this.length <= s) {
          this._expand(s + 1);
          this.words[s] |= q;
          return this;
        }
        var carry = q;
        for (var i = s; carry !== 0 && i < this.length; i++) {
          var w = this.words[i] | 0;
          w += carry;
          carry = w >>> 26;
          w &= 67108863;
          this.words[i] = w;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        return this;
      };
      BN.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative) return -1;
        if (this.negative === 0 && negative) return 1;
        this.strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert(num <= 67108863, "Number is too big");
          var w = this.words[0] | 0;
          res = w === num ? 0 : w < num ? -1 : 1;
        }
        if (this.negative !== 0) return -res | 0;
        return res;
      };
      BN.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0) return -1;
        if (this.negative === 0 && num.negative !== 0) return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0) return -res | 0;
        return res;
      };
      BN.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length) return 1;
        if (this.length < num.length) return -1;
        var res = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var a = this.words[i] | 0;
          var b = num.words[i] | 0;
          if (a === b) continue;
          if (a < b) {
            res = -1;
          } else if (a > b) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
      };
      BN.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
      };
      BN.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      };
      BN.red = function red(num) {
        return new Red(num);
      };
      BN.prototype.toRed = function toRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        assert(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN.prototype.fromRed = function fromRed() {
        assert(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN.prototype.forceRed = function forceRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN.prototype.redAdd = function redAdd(num) {
        assert(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN.prototype.redIAdd = function redIAdd(num) {
        assert(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN.prototype.redSub = function redSub(num) {
        assert(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN.prototype.redISub = function redISub(num) {
        assert(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN.prototype.redShl = function redShl(num) {
        assert(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN.prototype.redMul = function redMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN.prototype.redIMul = function redIMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN.prototype.redSqr = function redSqr() {
        assert(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN.prototype.redISqr = function redISqr() {
        assert(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN.prototype.redSqrt = function redSqrt() {
        assert(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN.prototype.redInvm = function redInvm() {
        assert(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN.prototype.redNeg = function redNeg() {
        assert(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN.prototype.redPow = function redPow(num) {
        assert(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name, p) {
        this.name = name;
        this.p = new BN(p, 16);
        this.n = this.p.bitLength();
        this.k = new BN(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r = num;
        var rlen;
        do {
          this.split(r, this.tmp);
          r = this.imulK(r);
          r = r.iadd(this.tmp);
          rlen = r.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
        if (cmp === 0) {
          r.words[0] = 0;
          r.length = 1;
        } else if (cmp > 0) {
          r.isub(this.p);
        } else {
          if (r.strip !== void 0) {
            r.strip();
          } else {
            r._strip();
          }
        }
        return r;
      };
      MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      inherits(K256, MPrime);
      K256.prototype.split = function split(input, output) {
        var mask = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i = 0; i < outLen; i++) {
          output.words[i] = input.words[i];
        }
        output.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for (i = 10; i < input.length; i++) {
          var next = input.words[i] | 0;
          input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo = 0;
        for (var i = 0; i < num.length; i++) {
          var w = num.words[i] | 0;
          lo += w * 977;
          num.words[i] = lo & 67108863;
          lo = w * 64 + (lo / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      inherits(P224, MPrime);
      function P192() {
        MPrime.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      inherits(P192, MPrime);
      function P25519() {
        MPrime.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      inherits(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i = 0; i < num.length; i++) {
          var hi = (num.words[i] | 0) * 19 + carry;
          var lo = hi & 67108863;
          hi >>>= 26;
          num.words[i] = lo;
          carry = hi;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN._prime = function prime(name) {
        if (primes[name]) return primes[name];
        var prime2;
        if (name === "k256") {
          prime2 = new K256();
        } else if (name === "p224") {
          prime2 = new P224();
        } else if (name === "p192") {
          prime2 = new P192();
        } else if (name === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name);
        }
        primes[name] = prime2;
        return prime2;
      };
      function Red(m) {
        if (typeof m === "string") {
          var prime = BN._prime(m);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert(m.gtn(1), "modulus must be greater than 1");
          this.m = m;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a) {
        assert(a.negative === 0, "red works only with positives");
        assert(a.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a, b) {
        assert((a.negative | b.negative) === 0, "red works only with positives");
        assert(
          a.red && a.red === b.red,
          "red works only with red numbers"
        );
      };
      Red.prototype.imod = function imod(a) {
        if (this.prime) return this.prime.ireduce(a)._forceRed(this);
        return a.umod(this.m)._forceRed(this);
      };
      Red.prototype.neg = function neg(a) {
        if (a.isZero()) {
          return a.clone();
        }
        return this.m.sub(a)._forceRed(this);
      };
      Red.prototype.add = function add(a, b) {
        this._verify2(a, b);
        var res = a.add(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a, b) {
        this._verify2(a, b);
        var res = a.iadd(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a, b) {
        this._verify2(a, b);
        var res = a.sub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a, b) {
        this._verify2(a, b);
        var res = a.isub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a, num) {
        this._verify1(a);
        return this.imod(a.ushln(num));
      };
      Red.prototype.imul = function imul(a, b) {
        this._verify2(a, b);
        return this.imod(a.imul(b));
      };
      Red.prototype.mul = function mul(a, b) {
        this._verify2(a, b);
        return this.imod(a.mul(b));
      };
      Red.prototype.isqr = function isqr(a) {
        return this.imul(a, a.clone());
      };
      Red.prototype.sqr = function sqr(a) {
        return this.mul(a, a);
      };
      Red.prototype.sqrt = function sqrt(a) {
        if (a.isZero()) return a.clone();
        var mod3 = this.m.andln(3);
        assert(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow = this.m.add(new BN(1)).iushrn(2);
          return this.pow(a, pow);
        }
        var q = this.m.subn(1);
        var s = 0;
        while (!q.isZero() && q.andln(1) === 0) {
          s++;
          q.iushrn(1);
        }
        assert(!q.isZero());
        var one = new BN(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z = this.m.bitLength();
        z = new BN(2 * z * z).toRed(this);
        while (this.pow(z, lpow).cmp(nOne) !== 0) {
          z.redIAdd(nOne);
        }
        var c = this.pow(z, q);
        var r = this.pow(a, q.addn(1).iushrn(1));
        var t = this.pow(a, q);
        var m = s;
        while (t.cmp(one) !== 0) {
          var tmp = t;
          for (var i = 0; tmp.cmp(one) !== 0; i++) {
            tmp = tmp.redSqr();
          }
          assert(i < m);
          var b = this.pow(c, new BN(1).iushln(m - i - 1));
          r = r.redMul(b);
          c = b.redSqr();
          t = t.redMul(c);
          m = i;
        }
        return r;
      };
      Red.prototype.invm = function invm(a) {
        var inv = a._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow(a, num) {
        if (num.isZero()) return new BN(1).toRed(this);
        if (num.cmpn(1) === 0) return a.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN(1).toRed(this);
        wnd[1] = a;
        for (var i = 2; i < wnd.length; i++) {
          wnd[i] = this.mul(wnd[i - 1], a);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i = num.length - 1; i >= 0; i--) {
          var word = num.words[i];
          for (var j = start - 1; j >= 0; j--) {
            var bit = word >> j & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r = num.umod(this.m);
        return r === num ? r.clone() : r;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m) {
        Red.call(this, m);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r = this.imod(num.mul(this.rinv));
        r.red = null;
        return r;
      };
      Mont.prototype.imul = function imul(a, b) {
        if (a.isZero() || b.isZero()) {
          a.words[0] = 0;
          a.length = 1;
          return a;
        }
        var t = a.imul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul(a, b) {
        if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);
        var t = a.mul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a) {
        var res = this.imod(a._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module2 === "undefined" || module2, exports2);
  }
});

// node_modules/vm-browserify/index.js
var require_vm_browserify = __commonJS({
  "node_modules/vm-browserify/index.js"(exports, module) {
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var indexOf = function(xs, item) {
      if (xs.indexOf) return xs.indexOf(item);
      else for (var i = 0; i < xs.length; i++) {
        if (xs[i] === item) return i;
      }
      return -1;
    };
    var Object_keys = function(obj) {
      if (Object.keys) return Object.keys(obj);
      else {
        var res = [];
        for (var key in obj) res.push(key);
        return res;
      }
    };
    var forEach = function(xs, fn) {
      if (xs.forEach) return xs.forEach(fn);
      else for (var i = 0; i < xs.length; i++) {
        fn(xs[i], i, xs);
      }
    };
    var defineProp = (function() {
      try {
        Object.defineProperty({}, "_", {});
        return function(obj, name, value) {
          Object.defineProperty(obj, name, {
            writable: true,
            enumerable: false,
            configurable: true,
            value
          });
        };
      } catch (e) {
        return function(obj, name, value) {
          obj[name] = value;
        };
      }
    })();
    var globals = [
      "Array",
      "Boolean",
      "Date",
      "Error",
      "EvalError",
      "Function",
      "Infinity",
      "JSON",
      "Math",
      "NaN",
      "Number",
      "Object",
      "RangeError",
      "ReferenceError",
      "RegExp",
      "String",
      "SyntaxError",
      "TypeError",
      "URIError",
      "decodeURI",
      "decodeURIComponent",
      "encodeURI",
      "encodeURIComponent",
      "escape",
      "eval",
      "isFinite",
      "isNaN",
      "parseFloat",
      "parseInt",
      "undefined",
      "unescape"
    ];
    function Context() {
    }
    Context.prototype = {};
    var Script = exports.Script = function NodeScript(code) {
      if (!(this instanceof Script)) return new Script(code);
      this.code = code;
    };
    Script.prototype.runInContext = function(context) {
      if (!(context instanceof Context)) {
        throw new TypeError("needs a 'context' argument.");
      }
      var iframe = document.createElement("iframe");
      if (!iframe.style) iframe.style = {};
      iframe.style.display = "none";
      document.body.appendChild(iframe);
      var win = iframe.contentWindow;
      var wEval = win.eval, wExecScript = win.execScript;
      if (!wEval && wExecScript) {
        wExecScript.call(win, "null");
        wEval = win.eval;
      }
      forEach(Object_keys(context), function(key) {
        win[key] = context[key];
      });
      forEach(globals, function(key) {
        if (context[key]) {
          win[key] = context[key];
        }
      });
      var winKeys = Object_keys(win);
      var res = wEval.call(win, this.code);
      forEach(Object_keys(win), function(key) {
        if (key in context || indexOf(winKeys, key) === -1) {
          context[key] = win[key];
        }
      });
      forEach(globals, function(key) {
        if (!(key in context)) {
          defineProp(context, key, win[key]);
        }
      });
      document.body.removeChild(iframe);
      return res;
    };
    Script.prototype.runInThisContext = function() {
      return eval(this.code);
    };
    Script.prototype.runInNewContext = function(context) {
      var ctx = Script.createContext(context);
      var res = this.runInContext(ctx);
      if (context) {
        forEach(Object_keys(ctx), function(key) {
          context[key] = ctx[key];
        });
      }
      return res;
    };
    forEach(Object_keys(Script.prototype), function(name) {
      exports[name] = Script[name] = function(code) {
        var s = Script(code);
        return s[name].apply(s, [].slice.call(arguments, 1));
      };
    });
    exports.isContext = function(context) {
      return context instanceof Context;
    };
    exports.createScript = function(code) {
      return exports.Script(code);
    };
    exports.createContext = Script.createContext = function(context) {
      var copy = new Context();
      if (typeof context === "object") {
        forEach(Object_keys(context), function(key) {
          copy[key] = context[key];
        });
      }
      return copy;
    };
  }
});

// node_modules/asn1.js/lib/asn1/api.js
var require_api = __commonJS({
  "node_modules/asn1.js/lib/asn1/api.js"(exports2) {
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var asn1 = require_asn1();
    var inherits = require_inherits();
    var api = exports2;
    api.define = function define2(name, body) {
      return new Entity(name, body);
    };
    function Entity(name, body) {
      this.name = name;
      this.body = body;
      this.decoders = {};
      this.encoders = {};
    }
    Entity.prototype._createNamed = function createNamed(base) {
      var named;
      try {
        named = require_vm_browserify().runInThisContext(
          "(function " + this.name + "(entity) {\n  this._initNamed(entity);\n})"
        );
      } catch (e) {
        named = function(entity) {
          this._initNamed(entity);
        };
      }
      inherits(named, base);
      named.prototype._initNamed = function initnamed(entity) {
        base.call(this, entity);
      };
      return new named(this);
    };
    Entity.prototype._getDecoder = function _getDecoder(enc) {
      enc = enc || "der";
      if (!this.decoders.hasOwnProperty(enc))
        this.decoders[enc] = this._createNamed(asn1.decoders[enc]);
      return this.decoders[enc];
    };
    Entity.prototype.decode = function decode(data, enc, options) {
      return this._getDecoder(enc).decode(data, options);
    };
    Entity.prototype._getEncoder = function _getEncoder(enc) {
      enc = enc || "der";
      if (!this.encoders.hasOwnProperty(enc))
        this.encoders[enc] = this._createNamed(asn1.encoders[enc]);
      return this.encoders[enc];
    };
    Entity.prototype.encode = function encode(data, enc, reporter) {
      return this._getEncoder(enc).encode(data, reporter);
    };
  }
});

// node_modules/asn1.js/lib/asn1/base/reporter.js
var require_reporter = __commonJS({
  "node_modules/asn1.js/lib/asn1/base/reporter.js"(exports2) {
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var inherits = require_inherits();
    function Reporter(options) {
      this._reporterState = {
        obj: null,
        path: [],
        options: options || {},
        errors: []
      };
    }
    exports2.Reporter = Reporter;
    Reporter.prototype.isError = function isError(obj) {
      return obj instanceof ReporterError;
    };
    Reporter.prototype.save = function save() {
      var state = this._reporterState;
      return { obj: state.obj, pathLen: state.path.length };
    };
    Reporter.prototype.restore = function restore(data) {
      var state = this._reporterState;
      state.obj = data.obj;
      state.path = state.path.slice(0, data.pathLen);
    };
    Reporter.prototype.enterKey = function enterKey(key) {
      return this._reporterState.path.push(key);
    };
    Reporter.prototype.exitKey = function exitKey(index) {
      var state = this._reporterState;
      state.path = state.path.slice(0, index - 1);
    };
    Reporter.prototype.leaveKey = function leaveKey(index, key, value) {
      var state = this._reporterState;
      this.exitKey(index);
      if (state.obj !== null)
        state.obj[key] = value;
    };
    Reporter.prototype.path = function path() {
      return this._reporterState.path.join("/");
    };
    Reporter.prototype.enterObject = function enterObject() {
      var state = this._reporterState;
      var prev = state.obj;
      state.obj = {};
      return prev;
    };
    Reporter.prototype.leaveObject = function leaveObject(prev) {
      var state = this._reporterState;
      var now = state.obj;
      state.obj = prev;
      return now;
    };
    Reporter.prototype.error = function error(msg) {
      var err;
      var state = this._reporterState;
      var inherited = msg instanceof ReporterError;
      if (inherited) {
        err = msg;
      } else {
        err = new ReporterError(state.path.map(function(elem) {
          return "[" + JSON.stringify(elem) + "]";
        }).join(""), msg.message || msg, msg.stack);
      }
      if (!state.options.partial)
        throw err;
      if (!inherited)
        state.errors.push(err);
      return err;
    };
    Reporter.prototype.wrapResult = function wrapResult(result) {
      var state = this._reporterState;
      if (!state.options.partial)
        return result;
      return {
        result: this.isError(result) ? null : result,
        errors: state.errors
      };
    };
    function ReporterError(path, msg) {
      this.path = path;
      this.rethrow(msg);
    }
    inherits(ReporterError, Error);
    ReporterError.prototype.rethrow = function rethrow(msg) {
      this.message = msg + " at: " + (this.path || "(shallow)");
      if (Error.captureStackTrace)
        Error.captureStackTrace(this, ReporterError);
      if (!this.stack) {
        try {
          throw new Error(this.message);
        } catch (e) {
          this.stack = e.stack;
        }
      }
      return this;
    };
  }
});

// node_modules/asn1.js/lib/asn1/base/buffer.js
var require_buffer = __commonJS({
  "node_modules/asn1.js/lib/asn1/base/buffer.js"(exports2) {
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var inherits = require_inherits();
    var Reporter = require_base2().Reporter;
    var Buffer2 = (init_dist(), __toCommonJS(dist_exports)).Buffer;
    function DecoderBuffer(base, options) {
      Reporter.call(this, options);
      if (!Buffer2.isBuffer(base)) {
        this.error("Input not Buffer");
        return;
      }
      this.base = base;
      this.offset = 0;
      this.length = base.length;
    }
    inherits(DecoderBuffer, Reporter);
    exports2.DecoderBuffer = DecoderBuffer;
    DecoderBuffer.prototype.save = function save() {
      return { offset: this.offset, reporter: Reporter.prototype.save.call(this) };
    };
    DecoderBuffer.prototype.restore = function restore(save) {
      var res = new DecoderBuffer(this.base);
      res.offset = save.offset;
      res.length = this.offset;
      this.offset = save.offset;
      Reporter.prototype.restore.call(this, save.reporter);
      return res;
    };
    DecoderBuffer.prototype.isEmpty = function isEmpty() {
      return this.offset === this.length;
    };
    DecoderBuffer.prototype.readUInt8 = function readUInt8(fail) {
      if (this.offset + 1 <= this.length)
        return this.base.readUInt8(this.offset++, true);
      else
        return this.error(fail || "DecoderBuffer overrun");
    };
    DecoderBuffer.prototype.skip = function skip(bytes, fail) {
      if (!(this.offset + bytes <= this.length))
        return this.error(fail || "DecoderBuffer overrun");
      var res = new DecoderBuffer(this.base);
      res._reporterState = this._reporterState;
      res.offset = this.offset;
      res.length = this.offset + bytes;
      this.offset += bytes;
      return res;
    };
    DecoderBuffer.prototype.raw = function raw(save) {
      return this.base.slice(save ? save.offset : this.offset, this.length);
    };
    function EncoderBuffer(value, reporter) {
      if (Array.isArray(value)) {
        this.length = 0;
        this.value = value.map(function(item) {
          if (!(item instanceof EncoderBuffer))
            item = new EncoderBuffer(item, reporter);
          this.length += item.length;
          return item;
        }, this);
      } else if (typeof value === "number") {
        if (!(0 <= value && value <= 255))
          return reporter.error("non-byte EncoderBuffer value");
        this.value = value;
        this.length = 1;
      } else if (typeof value === "string") {
        this.value = value;
        this.length = Buffer2.byteLength(value);
      } else if (Buffer2.isBuffer(value)) {
        this.value = value;
        this.length = value.length;
      } else {
        return reporter.error("Unsupported type: " + typeof value);
      }
    }
    exports2.EncoderBuffer = EncoderBuffer;
    EncoderBuffer.prototype.join = function join(out, offset) {
      if (!out)
        out = new Buffer2(this.length);
      if (!offset)
        offset = 0;
      if (this.length === 0)
        return out;
      if (Array.isArray(this.value)) {
        this.value.forEach(function(item) {
          item.join(out, offset);
          offset += item.length;
        });
      } else {
        if (typeof this.value === "number")
          out[offset] = this.value;
        else if (typeof this.value === "string")
          out.write(this.value, offset);
        else if (Buffer2.isBuffer(this.value))
          this.value.copy(out, offset);
        offset += this.length;
      }
      return out;
    };
  }
});

// node_modules/asn1.js/lib/asn1/base/node.js
var require_node = __commonJS({
  "node_modules/asn1.js/lib/asn1/base/node.js"(exports2, module2) {
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var Reporter = require_base2().Reporter;
    var EncoderBuffer = require_base2().EncoderBuffer;
    var DecoderBuffer = require_base2().DecoderBuffer;
    var assert = require_minimalistic_assert();
    var tags = [
      "seq",
      "seqof",
      "set",
      "setof",
      "objid",
      "bool",
      "gentime",
      "utctime",
      "null_",
      "enum",
      "int",
      "objDesc",
      "bitstr",
      "bmpstr",
      "charstr",
      "genstr",
      "graphstr",
      "ia5str",
      "iso646str",
      "numstr",
      "octstr",
      "printstr",
      "t61str",
      "unistr",
      "utf8str",
      "videostr"
    ];
    var methods = [
      "key",
      "obj",
      "use",
      "optional",
      "explicit",
      "implicit",
      "def",
      "choice",
      "any",
      "contains"
    ].concat(tags);
    var overrided = [
      "_peekTag",
      "_decodeTag",
      "_use",
      "_decodeStr",
      "_decodeObjid",
      "_decodeTime",
      "_decodeNull",
      "_decodeInt",
      "_decodeBool",
      "_decodeList",
      "_encodeComposite",
      "_encodeStr",
      "_encodeObjid",
      "_encodeTime",
      "_encodeNull",
      "_encodeInt",
      "_encodeBool"
    ];
    function Node(enc, parent) {
      var state = {};
      this._baseState = state;
      state.enc = enc;
      state.parent = parent || null;
      state.children = null;
      state.tag = null;
      state.args = null;
      state.reverseArgs = null;
      state.choice = null;
      state.optional = false;
      state.any = false;
      state.obj = false;
      state.use = null;
      state.useDecoder = null;
      state.key = null;
      state["default"] = null;
      state.explicit = null;
      state.implicit = null;
      state.contains = null;
      if (!state.parent) {
        state.children = [];
        this._wrap();
      }
    }
    module2.exports = Node;
    var stateProps = [
      "enc",
      "parent",
      "children",
      "tag",
      "args",
      "reverseArgs",
      "choice",
      "optional",
      "any",
      "obj",
      "use",
      "alteredUse",
      "key",
      "default",
      "explicit",
      "implicit",
      "contains"
    ];
    Node.prototype.clone = function clone() {
      var state = this._baseState;
      var cstate = {};
      stateProps.forEach(function(prop) {
        cstate[prop] = state[prop];
      });
      var res = new this.constructor(cstate.parent);
      res._baseState = cstate;
      return res;
    };
    Node.prototype._wrap = function wrap() {
      var state = this._baseState;
      methods.forEach(function(method) {
        this[method] = function _wrappedMethod() {
          var clone = new this.constructor(this);
          state.children.push(clone);
          return clone[method].apply(clone, arguments);
        };
      }, this);
    };
    Node.prototype._init = function init(body) {
      var state = this._baseState;
      assert(state.parent === null);
      body.call(this);
      state.children = state.children.filter(function(child) {
        return child._baseState.parent === this;
      }, this);
      assert.equal(state.children.length, 1, "Root node can have only one child");
    };
    Node.prototype._useArgs = function useArgs(args) {
      var state = this._baseState;
      var children = args.filter(function(arg) {
        return arg instanceof this.constructor;
      }, this);
      args = args.filter(function(arg) {
        return !(arg instanceof this.constructor);
      }, this);
      if (children.length !== 0) {
        assert(state.children === null);
        state.children = children;
        children.forEach(function(child) {
          child._baseState.parent = this;
        }, this);
      }
      if (args.length !== 0) {
        assert(state.args === null);
        state.args = args;
        state.reverseArgs = args.map(function(arg) {
          if (typeof arg !== "object" || arg.constructor !== Object)
            return arg;
          var res = {};
          Object.keys(arg).forEach(function(key) {
            if (key == (key | 0))
              key |= 0;
            var value = arg[key];
            res[value] = key;
          });
          return res;
        });
      }
    };
    overrided.forEach(function(method) {
      Node.prototype[method] = function _overrided() {
        var state = this._baseState;
        throw new Error(method + " not implemented for encoding: " + state.enc);
      };
    });
    tags.forEach(function(tag) {
      Node.prototype[tag] = function _tagMethod() {
        var state = this._baseState;
        var args = Array.prototype.slice.call(arguments);
        assert(state.tag === null);
        state.tag = tag;
        this._useArgs(args);
        return this;
      };
    });
    Node.prototype.use = function use(item) {
      assert(item);
      var state = this._baseState;
      assert(state.use === null);
      state.use = item;
      return this;
    };
    Node.prototype.optional = function optional() {
      var state = this._baseState;
      state.optional = true;
      return this;
    };
    Node.prototype.def = function def(val) {
      var state = this._baseState;
      assert(state["default"] === null);
      state["default"] = val;
      state.optional = true;
      return this;
    };
    Node.prototype.explicit = function explicit(num) {
      var state = this._baseState;
      assert(state.explicit === null && state.implicit === null);
      state.explicit = num;
      return this;
    };
    Node.prototype.implicit = function implicit(num) {
      var state = this._baseState;
      assert(state.explicit === null && state.implicit === null);
      state.implicit = num;
      return this;
    };
    Node.prototype.obj = function obj() {
      var state = this._baseState;
      var args = Array.prototype.slice.call(arguments);
      state.obj = true;
      if (args.length !== 0)
        this._useArgs(args);
      return this;
    };
    Node.prototype.key = function key(newKey) {
      var state = this._baseState;
      assert(state.key === null);
      state.key = newKey;
      return this;
    };
    Node.prototype.any = function any() {
      var state = this._baseState;
      state.any = true;
      return this;
    };
    Node.prototype.choice = function choice(obj) {
      var state = this._baseState;
      assert(state.choice === null);
      state.choice = obj;
      this._useArgs(Object.keys(obj).map(function(key) {
        return obj[key];
      }));
      return this;
    };
    Node.prototype.contains = function contains(item) {
      var state = this._baseState;
      assert(state.use === null);
      state.contains = item;
      return this;
    };
    Node.prototype._decode = function decode(input, options) {
      var state = this._baseState;
      if (state.parent === null)
        return input.wrapResult(state.children[0]._decode(input, options));
      var result = state["default"];
      var present = true;
      var prevKey = null;
      if (state.key !== null)
        prevKey = input.enterKey(state.key);
      if (state.optional) {
        var tag = null;
        if (state.explicit !== null)
          tag = state.explicit;
        else if (state.implicit !== null)
          tag = state.implicit;
        else if (state.tag !== null)
          tag = state.tag;
        if (tag === null && !state.any) {
          var save = input.save();
          try {
            if (state.choice === null)
              this._decodeGeneric(state.tag, input, options);
            else
              this._decodeChoice(input, options);
            present = true;
          } catch (e) {
            present = false;
          }
          input.restore(save);
        } else {
          present = this._peekTag(input, tag, state.any);
          if (input.isError(present))
            return present;
        }
      }
      var prevObj;
      if (state.obj && present)
        prevObj = input.enterObject();
      if (present) {
        if (state.explicit !== null) {
          var explicit = this._decodeTag(input, state.explicit);
          if (input.isError(explicit))
            return explicit;
          input = explicit;
        }
        var start = input.offset;
        if (state.use === null && state.choice === null) {
          if (state.any)
            var save = input.save();
          var body = this._decodeTag(
            input,
            state.implicit !== null ? state.implicit : state.tag,
            state.any
          );
          if (input.isError(body))
            return body;
          if (state.any)
            result = input.raw(save);
          else
            input = body;
        }
        if (options && options.track && state.tag !== null)
          options.track(input.path(), start, input.length, "tagged");
        if (options && options.track && state.tag !== null)
          options.track(input.path(), input.offset, input.length, "content");
        if (state.any)
          result = result;
        else if (state.choice === null)
          result = this._decodeGeneric(state.tag, input, options);
        else
          result = this._decodeChoice(input, options);
        if (input.isError(result))
          return result;
        if (!state.any && state.choice === null && state.children !== null) {
          state.children.forEach(function decodeChildren(child) {
            child._decode(input, options);
          });
        }
        if (state.contains && (state.tag === "octstr" || state.tag === "bitstr")) {
          var data = new DecoderBuffer(result);
          result = this._getUse(state.contains, input._reporterState.obj)._decode(data, options);
        }
      }
      if (state.obj && present)
        result = input.leaveObject(prevObj);
      if (state.key !== null && (result !== null || present === true))
        input.leaveKey(prevKey, state.key, result);
      else if (prevKey !== null)
        input.exitKey(prevKey);
      return result;
    };
    Node.prototype._decodeGeneric = function decodeGeneric(tag, input, options) {
      var state = this._baseState;
      if (tag === "seq" || tag === "set")
        return null;
      if (tag === "seqof" || tag === "setof")
        return this._decodeList(input, tag, state.args[0], options);
      else if (/str$/.test(tag))
        return this._decodeStr(input, tag, options);
      else if (tag === "objid" && state.args)
        return this._decodeObjid(input, state.args[0], state.args[1], options);
      else if (tag === "objid")
        return this._decodeObjid(input, null, null, options);
      else if (tag === "gentime" || tag === "utctime")
        return this._decodeTime(input, tag, options);
      else if (tag === "null_")
        return this._decodeNull(input, options);
      else if (tag === "bool")
        return this._decodeBool(input, options);
      else if (tag === "objDesc")
        return this._decodeStr(input, tag, options);
      else if (tag === "int" || tag === "enum")
        return this._decodeInt(input, state.args && state.args[0], options);
      if (state.use !== null) {
        return this._getUse(state.use, input._reporterState.obj)._decode(input, options);
      } else {
        return input.error("unknown tag: " + tag);
      }
    };
    Node.prototype._getUse = function _getUse(entity, obj) {
      var state = this._baseState;
      state.useDecoder = this._use(entity, obj);
      assert(state.useDecoder._baseState.parent === null);
      state.useDecoder = state.useDecoder._baseState.children[0];
      if (state.implicit !== state.useDecoder._baseState.implicit) {
        state.useDecoder = state.useDecoder.clone();
        state.useDecoder._baseState.implicit = state.implicit;
      }
      return state.useDecoder;
    };
    Node.prototype._decodeChoice = function decodeChoice(input, options) {
      var state = this._baseState;
      var result = null;
      var match = false;
      Object.keys(state.choice).some(function(key) {
        var save = input.save();
        var node = state.choice[key];
        try {
          var value = node._decode(input, options);
          if (input.isError(value))
            return false;
          result = { type: key, value };
          match = true;
        } catch (e) {
          input.restore(save);
          return false;
        }
        return true;
      }, this);
      if (!match)
        return input.error("Choice not matched");
      return result;
    };
    Node.prototype._createEncoderBuffer = function createEncoderBuffer(data) {
      return new EncoderBuffer(data, this.reporter);
    };
    Node.prototype._encode = function encode(data, reporter, parent) {
      var state = this._baseState;
      if (state["default"] !== null && state["default"] === data)
        return;
      var result = this._encodeValue(data, reporter, parent);
      if (result === void 0)
        return;
      if (this._skipDefault(result, reporter, parent))
        return;
      return result;
    };
    Node.prototype._encodeValue = function encode(data, reporter, parent) {
      var state = this._baseState;
      if (state.parent === null)
        return state.children[0]._encode(data, reporter || new Reporter());
      var result = null;
      this.reporter = reporter;
      if (state.optional && data === void 0) {
        if (state["default"] !== null)
          data = state["default"];
        else
          return;
      }
      var content = null;
      var primitive = false;
      if (state.any) {
        result = this._createEncoderBuffer(data);
      } else if (state.choice) {
        result = this._encodeChoice(data, reporter);
      } else if (state.contains) {
        content = this._getUse(state.contains, parent)._encode(data, reporter);
        primitive = true;
      } else if (state.children) {
        content = state.children.map(function(child2) {
          if (child2._baseState.tag === "null_")
            return child2._encode(null, reporter, data);
          if (child2._baseState.key === null)
            return reporter.error("Child should have a key");
          var prevKey = reporter.enterKey(child2._baseState.key);
          if (typeof data !== "object")
            return reporter.error("Child expected, but input is not object");
          var res = child2._encode(data[child2._baseState.key], reporter, data);
          reporter.leaveKey(prevKey);
          return res;
        }, this).filter(function(child2) {
          return child2;
        });
        content = this._createEncoderBuffer(content);
      } else {
        if (state.tag === "seqof" || state.tag === "setof") {
          if (!(state.args && state.args.length === 1))
            return reporter.error("Too many args for : " + state.tag);
          if (!Array.isArray(data))
            return reporter.error("seqof/setof, but data is not Array");
          var child = this.clone();
          child._baseState.implicit = null;
          content = this._createEncoderBuffer(data.map(function(item) {
            var state2 = this._baseState;
            return this._getUse(state2.args[0], data)._encode(item, reporter);
          }, child));
        } else if (state.use !== null) {
          result = this._getUse(state.use, parent)._encode(data, reporter);
        } else {
          content = this._encodePrimitive(state.tag, data);
          primitive = true;
        }
      }
      var result;
      if (!state.any && state.choice === null) {
        var tag = state.implicit !== null ? state.implicit : state.tag;
        var cls = state.implicit === null ? "universal" : "context";
        if (tag === null) {
          if (state.use === null)
            reporter.error("Tag could be omitted only for .use()");
        } else {
          if (state.use === null)
            result = this._encodeComposite(tag, primitive, cls, content);
        }
      }
      if (state.explicit !== null)
        result = this._encodeComposite(state.explicit, false, "context", result);
      return result;
    };
    Node.prototype._encodeChoice = function encodeChoice(data, reporter) {
      var state = this._baseState;
      var node = state.choice[data.type];
      if (!node) {
        assert(
          false,
          data.type + " not found in " + JSON.stringify(Object.keys(state.choice))
        );
      }
      return node._encode(data.value, reporter);
    };
    Node.prototype._encodePrimitive = function encodePrimitive(tag, data) {
      var state = this._baseState;
      if (/str$/.test(tag))
        return this._encodeStr(data, tag);
      else if (tag === "objid" && state.args)
        return this._encodeObjid(data, state.reverseArgs[0], state.args[1]);
      else if (tag === "objid")
        return this._encodeObjid(data, null, null);
      else if (tag === "gentime" || tag === "utctime")
        return this._encodeTime(data, tag);
      else if (tag === "null_")
        return this._encodeNull();
      else if (tag === "int" || tag === "enum")
        return this._encodeInt(data, state.args && state.reverseArgs[0]);
      else if (tag === "bool")
        return this._encodeBool(data);
      else if (tag === "objDesc")
        return this._encodeStr(data, tag);
      else
        throw new Error("Unsupported tag: " + tag);
    };
    Node.prototype._isNumstr = function isNumstr(str) {
      return /^[0-9 ]*$/.test(str);
    };
    Node.prototype._isPrintstr = function isPrintstr(str) {
      return /^[A-Za-z0-9 '\(\)\+,\-\.\/:=\?]*$/.test(str);
    };
  }
});

// node_modules/asn1.js/lib/asn1/base/index.js
var require_base2 = __commonJS({
  "node_modules/asn1.js/lib/asn1/base/index.js"(exports2) {
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var base = exports2;
    base.Reporter = require_reporter().Reporter;
    base.DecoderBuffer = require_buffer().DecoderBuffer;
    base.EncoderBuffer = require_buffer().EncoderBuffer;
    base.Node = require_node();
  }
});

// node_modules/asn1.js/lib/asn1/constants/der.js
var require_der = __commonJS({
  "node_modules/asn1.js/lib/asn1/constants/der.js"(exports2) {
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var constants = require_constants();
    exports2.tagClass = {
      0: "universal",
      1: "application",
      2: "context",
      3: "private"
    };
    exports2.tagClassByName = constants._reverse(exports2.tagClass);
    exports2.tag = {
      0: "end",
      1: "bool",
      2: "int",
      3: "bitstr",
      4: "octstr",
      5: "null_",
      6: "objid",
      7: "objDesc",
      8: "external",
      9: "real",
      10: "enum",
      11: "embed",
      12: "utf8str",
      13: "relativeOid",
      16: "seq",
      17: "set",
      18: "numstr",
      19: "printstr",
      20: "t61str",
      21: "videostr",
      22: "ia5str",
      23: "utctime",
      24: "gentime",
      25: "graphstr",
      26: "iso646str",
      27: "genstr",
      28: "unistr",
      29: "charstr",
      30: "bmpstr"
    };
    exports2.tagByName = constants._reverse(exports2.tag);
  }
});

// node_modules/asn1.js/lib/asn1/constants/index.js
var require_constants = __commonJS({
  "node_modules/asn1.js/lib/asn1/constants/index.js"(exports2) {
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var constants = exports2;
    constants._reverse = function reverse(map) {
      var res = {};
      Object.keys(map).forEach(function(key) {
        if ((key | 0) == key)
          key = key | 0;
        var value = map[key];
        res[value] = key;
      });
      return res;
    };
    constants.der = require_der();
  }
});

// node_modules/asn1.js/lib/asn1/decoders/der.js
var require_der2 = __commonJS({
  "node_modules/asn1.js/lib/asn1/decoders/der.js"(exports2, module2) {
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var inherits = require_inherits();
    var asn1 = require_asn1();
    var base = asn1.base;
    var bignum = asn1.bignum;
    var der = asn1.constants.der;
    function DERDecoder(entity) {
      this.enc = "der";
      this.name = entity.name;
      this.entity = entity;
      this.tree = new DERNode();
      this.tree._init(entity.body);
    }
    module2.exports = DERDecoder;
    DERDecoder.prototype.decode = function decode(data, options) {
      if (!(data instanceof base.DecoderBuffer))
        data = new base.DecoderBuffer(data, options);
      return this.tree._decode(data, options);
    };
    function DERNode(parent) {
      base.Node.call(this, "der", parent);
    }
    inherits(DERNode, base.Node);
    DERNode.prototype._peekTag = function peekTag(buffer, tag, any) {
      if (buffer.isEmpty())
        return false;
      var state = buffer.save();
      var decodedTag = derDecodeTag(buffer, 'Failed to peek tag: "' + tag + '"');
      if (buffer.isError(decodedTag))
        return decodedTag;
      buffer.restore(state);
      return decodedTag.tag === tag || decodedTag.tagStr === tag || decodedTag.tagStr + "of" === tag || any;
    };
    DERNode.prototype._decodeTag = function decodeTag(buffer, tag, any) {
      var decodedTag = derDecodeTag(
        buffer,
        'Failed to decode tag of "' + tag + '"'
      );
      if (buffer.isError(decodedTag))
        return decodedTag;
      var len = derDecodeLen(
        buffer,
        decodedTag.primitive,
        'Failed to get length of "' + tag + '"'
      );
      if (buffer.isError(len))
        return len;
      if (!any && decodedTag.tag !== tag && decodedTag.tagStr !== tag && decodedTag.tagStr + "of" !== tag) {
        return buffer.error('Failed to match tag: "' + tag + '"');
      }
      if (decodedTag.primitive || len !== null)
        return buffer.skip(len, 'Failed to match body of: "' + tag + '"');
      var state = buffer.save();
      var res = this._skipUntilEnd(
        buffer,
        'Failed to skip indefinite length body: "' + this.tag + '"'
      );
      if (buffer.isError(res))
        return res;
      len = buffer.offset - state.offset;
      buffer.restore(state);
      return buffer.skip(len, 'Failed to match body of: "' + tag + '"');
    };
    DERNode.prototype._skipUntilEnd = function skipUntilEnd(buffer, fail) {
      while (true) {
        var tag = derDecodeTag(buffer, fail);
        if (buffer.isError(tag))
          return tag;
        var len = derDecodeLen(buffer, tag.primitive, fail);
        if (buffer.isError(len))
          return len;
        var res;
        if (tag.primitive || len !== null)
          res = buffer.skip(len);
        else
          res = this._skipUntilEnd(buffer, fail);
        if (buffer.isError(res))
          return res;
        if (tag.tagStr === "end")
          break;
      }
    };
    DERNode.prototype._decodeList = function decodeList(buffer, tag, decoder, options) {
      var result = [];
      while (!buffer.isEmpty()) {
        var possibleEnd = this._peekTag(buffer, "end");
        if (buffer.isError(possibleEnd))
          return possibleEnd;
        var res = decoder.decode(buffer, "der", options);
        if (buffer.isError(res) && possibleEnd)
          break;
        result.push(res);
      }
      return result;
    };
    DERNode.prototype._decodeStr = function decodeStr(buffer, tag) {
      if (tag === "bitstr") {
        var unused = buffer.readUInt8();
        if (buffer.isError(unused))
          return unused;
        return { unused, data: buffer.raw() };
      } else if (tag === "bmpstr") {
        var raw = buffer.raw();
        if (raw.length % 2 === 1)
          return buffer.error("Decoding of string type: bmpstr length mismatch");
        var str = "";
        for (var i = 0; i < raw.length / 2; i++) {
          str += String.fromCharCode(raw.readUInt16BE(i * 2));
        }
        return str;
      } else if (tag === "numstr") {
        var numstr = buffer.raw().toString("ascii");
        if (!this._isNumstr(numstr)) {
          return buffer.error("Decoding of string type: numstr unsupported characters");
        }
        return numstr;
      } else if (tag === "octstr") {
        return buffer.raw();
      } else if (tag === "objDesc") {
        return buffer.raw();
      } else if (tag === "printstr") {
        var printstr = buffer.raw().toString("ascii");
        if (!this._isPrintstr(printstr)) {
          return buffer.error("Decoding of string type: printstr unsupported characters");
        }
        return printstr;
      } else if (/str$/.test(tag)) {
        return buffer.raw().toString();
      } else {
        return buffer.error("Decoding of string type: " + tag + " unsupported");
      }
    };
    DERNode.prototype._decodeObjid = function decodeObjid(buffer, values, relative) {
      var result;
      var identifiers = [];
      var ident = 0;
      while (!buffer.isEmpty()) {
        var subident = buffer.readUInt8();
        ident <<= 7;
        ident |= subident & 127;
        if ((subident & 128) === 0) {
          identifiers.push(ident);
          ident = 0;
        }
      }
      if (subident & 128)
        identifiers.push(ident);
      var first = identifiers[0] / 40 | 0;
      var second = identifiers[0] % 40;
      if (relative)
        result = identifiers;
      else
        result = [first, second].concat(identifiers.slice(1));
      if (values) {
        var tmp = values[result.join(" ")];
        if (tmp === void 0)
          tmp = values[result.join(".")];
        if (tmp !== void 0)
          result = tmp;
      }
      return result;
    };
    DERNode.prototype._decodeTime = function decodeTime(buffer, tag) {
      var str = buffer.raw().toString();
      if (tag === "gentime") {
        var year = str.slice(0, 4) | 0;
        var mon = str.slice(4, 6) | 0;
        var day = str.slice(6, 8) | 0;
        var hour = str.slice(8, 10) | 0;
        var min = str.slice(10, 12) | 0;
        var sec = str.slice(12, 14) | 0;
      } else if (tag === "utctime") {
        var year = str.slice(0, 2) | 0;
        var mon = str.slice(2, 4) | 0;
        var day = str.slice(4, 6) | 0;
        var hour = str.slice(6, 8) | 0;
        var min = str.slice(8, 10) | 0;
        var sec = str.slice(10, 12) | 0;
        if (year < 70)
          year = 2e3 + year;
        else
          year = 1900 + year;
      } else {
        return buffer.error("Decoding " + tag + " time is not supported yet");
      }
      return Date.UTC(year, mon - 1, day, hour, min, sec, 0);
    };
    DERNode.prototype._decodeNull = function decodeNull(buffer) {
      return null;
    };
    DERNode.prototype._decodeBool = function decodeBool(buffer) {
      var res = buffer.readUInt8();
      if (buffer.isError(res))
        return res;
      else
        return res !== 0;
    };
    DERNode.prototype._decodeInt = function decodeInt(buffer, values) {
      var raw = buffer.raw();
      var res = new bignum(raw);
      if (values)
        res = values[res.toString(10)] || res;
      return res;
    };
    DERNode.prototype._use = function use(entity, obj) {
      if (typeof entity === "function")
        entity = entity(obj);
      return entity._getDecoder("der").tree;
    };
    function derDecodeTag(buf, fail) {
      var tag = buf.readUInt8(fail);
      if (buf.isError(tag))
        return tag;
      var cls = der.tagClass[tag >> 6];
      var primitive = (tag & 32) === 0;
      if ((tag & 31) === 31) {
        var oct = tag;
        tag = 0;
        while ((oct & 128) === 128) {
          oct = buf.readUInt8(fail);
          if (buf.isError(oct))
            return oct;
          tag <<= 7;
          tag |= oct & 127;
        }
      } else {
        tag &= 31;
      }
      var tagStr = der.tag[tag];
      return {
        cls,
        primitive,
        tag,
        tagStr
      };
    }
    function derDecodeLen(buf, primitive, fail) {
      var len = buf.readUInt8(fail);
      if (buf.isError(len))
        return len;
      if (!primitive && len === 128)
        return null;
      if ((len & 128) === 0) {
        return len;
      }
      var num = len & 127;
      if (num > 4)
        return buf.error("length octect is too long");
      len = 0;
      for (var i = 0; i < num; i++) {
        len <<= 8;
        var j = buf.readUInt8(fail);
        if (buf.isError(j))
          return j;
        len |= j;
      }
      return len;
    }
  }
});

// node_modules/asn1.js/lib/asn1/decoders/pem.js
var require_pem = __commonJS({
  "node_modules/asn1.js/lib/asn1/decoders/pem.js"(exports2, module2) {
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var inherits = require_inherits();
    var Buffer2 = (init_dist(), __toCommonJS(dist_exports)).Buffer;
    var DERDecoder = require_der2();
    function PEMDecoder(entity) {
      DERDecoder.call(this, entity);
      this.enc = "pem";
    }
    inherits(PEMDecoder, DERDecoder);
    module2.exports = PEMDecoder;
    PEMDecoder.prototype.decode = function decode(data, options) {
      var lines = data.toString().split(/[\r\n]+/g);
      var label = options.label.toUpperCase();
      var re = /^-----(BEGIN|END) ([^-]+)-----$/;
      var start = -1;
      var end = -1;
      for (var i = 0; i < lines.length; i++) {
        var match = lines[i].match(re);
        if (match === null)
          continue;
        if (match[2] !== label)
          continue;
        if (start === -1) {
          if (match[1] !== "BEGIN")
            break;
          start = i;
        } else {
          if (match[1] !== "END")
            break;
          end = i;
          break;
        }
      }
      if (start === -1 || end === -1)
        throw new Error("PEM section not found for: " + label);
      var base64 = lines.slice(start + 1, end).join("");
      base64.replace(/[^a-z0-9\+\/=]+/gi, "");
      var input = new Buffer2(base64, "base64");
      return DERDecoder.prototype.decode.call(this, input, options);
    };
  }
});

// node_modules/asn1.js/lib/asn1/decoders/index.js
var require_decoders = __commonJS({
  "node_modules/asn1.js/lib/asn1/decoders/index.js"(exports2) {
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var decoders = exports2;
    decoders.der = require_der2();
    decoders.pem = require_pem();
  }
});

// node_modules/asn1.js/lib/asn1/encoders/der.js
var require_der3 = __commonJS({
  "node_modules/asn1.js/lib/asn1/encoders/der.js"(exports2, module2) {
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var inherits = require_inherits();
    var Buffer2 = (init_dist(), __toCommonJS(dist_exports)).Buffer;
    var asn1 = require_asn1();
    var base = asn1.base;
    var der = asn1.constants.der;
    function DEREncoder(entity) {
      this.enc = "der";
      this.name = entity.name;
      this.entity = entity;
      this.tree = new DERNode();
      this.tree._init(entity.body);
    }
    module2.exports = DEREncoder;
    DEREncoder.prototype.encode = function encode(data, reporter) {
      return this.tree._encode(data, reporter).join();
    };
    function DERNode(parent) {
      base.Node.call(this, "der", parent);
    }
    inherits(DERNode, base.Node);
    DERNode.prototype._encodeComposite = function encodeComposite(tag, primitive, cls, content) {
      var encodedTag = encodeTag(tag, primitive, cls, this.reporter);
      if (content.length < 128) {
        var header = new Buffer2(2);
        header[0] = encodedTag;
        header[1] = content.length;
        return this._createEncoderBuffer([header, content]);
      }
      var lenOctets = 1;
      for (var i = content.length; i >= 256; i >>= 8)
        lenOctets++;
      var header = new Buffer2(1 + 1 + lenOctets);
      header[0] = encodedTag;
      header[1] = 128 | lenOctets;
      for (var i = 1 + lenOctets, j = content.length; j > 0; i--, j >>= 8)
        header[i] = j & 255;
      return this._createEncoderBuffer([header, content]);
    };
    DERNode.prototype._encodeStr = function encodeStr(str, tag) {
      if (tag === "bitstr") {
        return this._createEncoderBuffer([str.unused | 0, str.data]);
      } else if (tag === "bmpstr") {
        var buf = new Buffer2(str.length * 2);
        for (var i = 0; i < str.length; i++) {
          buf.writeUInt16BE(str.charCodeAt(i), i * 2);
        }
        return this._createEncoderBuffer(buf);
      } else if (tag === "numstr") {
        if (!this._isNumstr(str)) {
          return this.reporter.error("Encoding of string type: numstr supports only digits and space");
        }
        return this._createEncoderBuffer(str);
      } else if (tag === "printstr") {
        if (!this._isPrintstr(str)) {
          return this.reporter.error("Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark");
        }
        return this._createEncoderBuffer(str);
      } else if (/str$/.test(tag)) {
        return this._createEncoderBuffer(str);
      } else if (tag === "objDesc") {
        return this._createEncoderBuffer(str);
      } else {
        return this.reporter.error("Encoding of string type: " + tag + " unsupported");
      }
    };
    DERNode.prototype._encodeObjid = function encodeObjid(id, values, relative) {
      if (typeof id === "string") {
        if (!values)
          return this.reporter.error("string objid given, but no values map found");
        if (!values.hasOwnProperty(id))
          return this.reporter.error("objid not found in values map");
        id = values[id].split(/[\s\.]+/g);
        for (var i = 0; i < id.length; i++)
          id[i] |= 0;
      } else if (Array.isArray(id)) {
        id = id.slice();
        for (var i = 0; i < id.length; i++)
          id[i] |= 0;
      }
      if (!Array.isArray(id)) {
        return this.reporter.error("objid() should be either array or string, got: " + JSON.stringify(id));
      }
      if (!relative) {
        if (id[1] >= 40)
          return this.reporter.error("Second objid identifier OOB");
        id.splice(0, 2, id[0] * 40 + id[1]);
      }
      var size = 0;
      for (var i = 0; i < id.length; i++) {
        var ident = id[i];
        for (size++; ident >= 128; ident >>= 7)
          size++;
      }
      var objid = new Buffer2(size);
      var offset = objid.length - 1;
      for (var i = id.length - 1; i >= 0; i--) {
        var ident = id[i];
        objid[offset--] = ident & 127;
        while ((ident >>= 7) > 0)
          objid[offset--] = 128 | ident & 127;
      }
      return this._createEncoderBuffer(objid);
    };
    function two(num) {
      if (num < 10)
        return "0" + num;
      else
        return num;
    }
    DERNode.prototype._encodeTime = function encodeTime(time, tag) {
      var str;
      var date = new Date(time);
      if (tag === "gentime") {
        str = [
          two(date.getFullYear()),
          two(date.getUTCMonth() + 1),
          two(date.getUTCDate()),
          two(date.getUTCHours()),
          two(date.getUTCMinutes()),
          two(date.getUTCSeconds()),
          "Z"
        ].join("");
      } else if (tag === "utctime") {
        str = [
          two(date.getFullYear() % 100),
          two(date.getUTCMonth() + 1),
          two(date.getUTCDate()),
          two(date.getUTCHours()),
          two(date.getUTCMinutes()),
          two(date.getUTCSeconds()),
          "Z"
        ].join("");
      } else {
        this.reporter.error("Encoding " + tag + " time is not supported yet");
      }
      return this._encodeStr(str, "octstr");
    };
    DERNode.prototype._encodeNull = function encodeNull() {
      return this._createEncoderBuffer("");
    };
    DERNode.prototype._encodeInt = function encodeInt(num, values) {
      if (typeof num === "string") {
        if (!values)
          return this.reporter.error("String int or enum given, but no values map");
        if (!values.hasOwnProperty(num)) {
          return this.reporter.error("Values map doesn't contain: " + JSON.stringify(num));
        }
        num = values[num];
      }
      if (typeof num !== "number" && !Buffer2.isBuffer(num)) {
        var numArray = num.toArray();
        if (!num.sign && numArray[0] & 128) {
          numArray.unshift(0);
        }
        num = new Buffer2(numArray);
      }
      if (Buffer2.isBuffer(num)) {
        var size = num.length;
        if (num.length === 0)
          size++;
        var out = new Buffer2(size);
        num.copy(out);
        if (num.length === 0)
          out[0] = 0;
        return this._createEncoderBuffer(out);
      }
      if (num < 128)
        return this._createEncoderBuffer(num);
      if (num < 256)
        return this._createEncoderBuffer([0, num]);
      var size = 1;
      for (var i = num; i >= 256; i >>= 8)
        size++;
      var out = new Array(size);
      for (var i = out.length - 1; i >= 0; i--) {
        out[i] = num & 255;
        num >>= 8;
      }
      if (out[0] & 128) {
        out.unshift(0);
      }
      return this._createEncoderBuffer(new Buffer2(out));
    };
    DERNode.prototype._encodeBool = function encodeBool(value) {
      return this._createEncoderBuffer(value ? 255 : 0);
    };
    DERNode.prototype._use = function use(entity, obj) {
      if (typeof entity === "function")
        entity = entity(obj);
      return entity._getEncoder("der").tree;
    };
    DERNode.prototype._skipDefault = function skipDefault(dataBuffer, reporter, parent) {
      var state = this._baseState;
      var i;
      if (state["default"] === null)
        return false;
      var data = dataBuffer.join();
      if (state.defaultBuffer === void 0)
        state.defaultBuffer = this._encodeValue(state["default"], reporter, parent).join();
      if (data.length !== state.defaultBuffer.length)
        return false;
      for (i = 0; i < data.length; i++)
        if (data[i] !== state.defaultBuffer[i])
          return false;
      return true;
    };
    function encodeTag(tag, primitive, cls, reporter) {
      var res;
      if (tag === "seqof")
        tag = "seq";
      else if (tag === "setof")
        tag = "set";
      if (der.tagByName.hasOwnProperty(tag))
        res = der.tagByName[tag];
      else if (typeof tag === "number" && (tag | 0) === tag)
        res = tag;
      else
        return reporter.error("Unknown tag: " + tag);
      if (res >= 31)
        return reporter.error("Multi-octet tag encoding unsupported");
      if (!primitive)
        res |= 32;
      res |= der.tagClassByName[cls || "universal"] << 6;
      return res;
    }
  }
});

// node_modules/asn1.js/lib/asn1/encoders/pem.js
var require_pem2 = __commonJS({
  "node_modules/asn1.js/lib/asn1/encoders/pem.js"(exports2, module2) {
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var inherits = require_inherits();
    var DEREncoder = require_der3();
    function PEMEncoder(entity) {
      DEREncoder.call(this, entity);
      this.enc = "pem";
    }
    inherits(PEMEncoder, DEREncoder);
    module2.exports = PEMEncoder;
    PEMEncoder.prototype.encode = function encode(data, options) {
      var buf = DEREncoder.prototype.encode.call(this, data);
      var p = buf.toString("base64");
      var out = ["-----BEGIN " + options.label + "-----"];
      for (var i = 0; i < p.length; i += 64)
        out.push(p.slice(i, i + 64));
      out.push("-----END " + options.label + "-----");
      return out.join("\n");
    };
  }
});

// node_modules/asn1.js/lib/asn1/encoders/index.js
var require_encoders = __commonJS({
  "node_modules/asn1.js/lib/asn1/encoders/index.js"(exports2) {
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var encoders = exports2;
    encoders.der = require_der3();
    encoders.pem = require_pem2();
  }
});

// node_modules/asn1.js/lib/asn1.js
var require_asn1 = __commonJS({
  "node_modules/asn1.js/lib/asn1.js"(exports2) {
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var asn1 = exports2;
    asn1.bignum = require_bn3();
    asn1.define = require_api().define;
    asn1.base = require_base2();
    asn1.constants = require_constants();
    asn1.decoders = require_decoders();
    asn1.encoders = require_encoders();
  }
});

// node_modules/parse-asn1/certificate.js
var require_certificate = __commonJS({
  "node_modules/parse-asn1/certificate.js"(exports2, module2) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var asn = require_asn1();
    var Time = asn.define("Time", function() {
      this.choice({
        utcTime: this.utctime(),
        generalTime: this.gentime()
      });
    });
    var AttributeTypeValue = asn.define("AttributeTypeValue", function() {
      this.seq().obj(
        this.key("type").objid(),
        this.key("value").any()
      );
    });
    var AlgorithmIdentifier = asn.define("AlgorithmIdentifier", function() {
      this.seq().obj(
        this.key("algorithm").objid(),
        this.key("parameters").optional(),
        this.key("curve").objid().optional()
      );
    });
    var SubjectPublicKeyInfo = asn.define("SubjectPublicKeyInfo", function() {
      this.seq().obj(
        this.key("algorithm").use(AlgorithmIdentifier),
        this.key("subjectPublicKey").bitstr()
      );
    });
    var RelativeDistinguishedName = asn.define("RelativeDistinguishedName", function() {
      this.setof(AttributeTypeValue);
    });
    var RDNSequence = asn.define("RDNSequence", function() {
      this.seqof(RelativeDistinguishedName);
    });
    var Name = asn.define("Name", function() {
      this.choice({
        rdnSequence: this.use(RDNSequence)
      });
    });
    var Validity = asn.define("Validity", function() {
      this.seq().obj(
        this.key("notBefore").use(Time),
        this.key("notAfter").use(Time)
      );
    });
    var Extension = asn.define("Extension", function() {
      this.seq().obj(
        this.key("extnID").objid(),
        this.key("critical").bool().def(false),
        this.key("extnValue").octstr()
      );
    });
    var TBSCertificate = asn.define("TBSCertificate", function() {
      this.seq().obj(
        this.key("version").explicit(0)["int"]().optional(),
        this.key("serialNumber")["int"](),
        this.key("signature").use(AlgorithmIdentifier),
        this.key("issuer").use(Name),
        this.key("validity").use(Validity),
        this.key("subject").use(Name),
        this.key("subjectPublicKeyInfo").use(SubjectPublicKeyInfo),
        this.key("issuerUniqueID").implicit(1).bitstr().optional(),
        this.key("subjectUniqueID").implicit(2).bitstr().optional(),
        this.key("extensions").explicit(3).seqof(Extension).optional()
      );
    });
    var X509Certificate = asn.define("X509Certificate", function() {
      this.seq().obj(
        this.key("tbsCertificate").use(TBSCertificate),
        this.key("signatureAlgorithm").use(AlgorithmIdentifier),
        this.key("signatureValue").bitstr()
      );
    });
    module2.exports = X509Certificate;
  }
});

// node_modules/parse-asn1/asn1.js
var require_asn12 = __commonJS({
  "node_modules/parse-asn1/asn1.js"(exports2) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var asn1 = require_asn1();
    exports2.certificate = require_certificate();
    var RSAPrivateKey = asn1.define("RSAPrivateKey", function() {
      this.seq().obj(
        this.key("version")["int"](),
        this.key("modulus")["int"](),
        this.key("publicExponent")["int"](),
        this.key("privateExponent")["int"](),
        this.key("prime1")["int"](),
        this.key("prime2")["int"](),
        this.key("exponent1")["int"](),
        this.key("exponent2")["int"](),
        this.key("coefficient")["int"]()
      );
    });
    exports2.RSAPrivateKey = RSAPrivateKey;
    var RSAPublicKey = asn1.define("RSAPublicKey", function() {
      this.seq().obj(
        this.key("modulus")["int"](),
        this.key("publicExponent")["int"]()
      );
    });
    exports2.RSAPublicKey = RSAPublicKey;
    var AlgorithmIdentifier = asn1.define("AlgorithmIdentifier", function() {
      this.seq().obj(
        this.key("algorithm").objid(),
        this.key("none").null_().optional(),
        this.key("curve").objid().optional(),
        this.key("params").seq().obj(
          this.key("p")["int"](),
          this.key("q")["int"](),
          this.key("g")["int"]()
        ).optional()
      );
    });
    var PublicKey = asn1.define("SubjectPublicKeyInfo", function() {
      this.seq().obj(
        this.key("algorithm").use(AlgorithmIdentifier),
        this.key("subjectPublicKey").bitstr()
      );
    });
    exports2.PublicKey = PublicKey;
    var PrivateKeyInfo = asn1.define("PrivateKeyInfo", function() {
      this.seq().obj(
        this.key("version")["int"](),
        this.key("algorithm").use(AlgorithmIdentifier),
        this.key("subjectPrivateKey").octstr()
      );
    });
    exports2.PrivateKey = PrivateKeyInfo;
    var EncryptedPrivateKeyInfo = asn1.define("EncryptedPrivateKeyInfo", function() {
      this.seq().obj(
        this.key("algorithm").seq().obj(
          this.key("id").objid(),
          this.key("decrypt").seq().obj(
            this.key("kde").seq().obj(
              this.key("id").objid(),
              this.key("kdeparams").seq().obj(
                this.key("salt").octstr(),
                this.key("iters")["int"]()
              )
            ),
            this.key("cipher").seq().obj(
              this.key("algo").objid(),
              this.key("iv").octstr()
            )
          )
        ),
        this.key("subjectPrivateKey").octstr()
      );
    });
    exports2.EncryptedPrivateKey = EncryptedPrivateKeyInfo;
    var DSAPrivateKey = asn1.define("DSAPrivateKey", function() {
      this.seq().obj(
        this.key("version")["int"](),
        this.key("p")["int"](),
        this.key("q")["int"](),
        this.key("g")["int"](),
        this.key("pub_key")["int"](),
        this.key("priv_key")["int"]()
      );
    });
    exports2.DSAPrivateKey = DSAPrivateKey;
    exports2.DSAparam = asn1.define("DSAparam", function() {
      this["int"]();
    });
    var ECParameters = asn1.define("ECParameters", function() {
      this.choice({
        namedCurve: this.objid()
      });
    });
    var ECPrivateKey = asn1.define("ECPrivateKey", function() {
      this.seq().obj(
        this.key("version")["int"](),
        this.key("privateKey").octstr(),
        this.key("parameters").optional().explicit(0).use(ECParameters),
        this.key("publicKey").optional().explicit(1).bitstr()
      );
    });
    exports2.ECPrivateKey = ECPrivateKey;
    exports2.signature = asn1.define("signature", function() {
      this.seq().obj(
        this.key("r")["int"](),
        this.key("s")["int"]()
      );
    });
  }
});

// node_modules/parse-asn1/aesid.json
var require_aesid = __commonJS({
  "node_modules/parse-asn1/aesid.json"(exports2, module2) {
    module2.exports = {
      "2.16.840.1.101.3.4.1.1": "aes-128-ecb",
      "2.16.840.1.101.3.4.1.2": "aes-128-cbc",
      "2.16.840.1.101.3.4.1.3": "aes-128-ofb",
      "2.16.840.1.101.3.4.1.4": "aes-128-cfb",
      "2.16.840.1.101.3.4.1.21": "aes-192-ecb",
      "2.16.840.1.101.3.4.1.22": "aes-192-cbc",
      "2.16.840.1.101.3.4.1.23": "aes-192-ofb",
      "2.16.840.1.101.3.4.1.24": "aes-192-cfb",
      "2.16.840.1.101.3.4.1.41": "aes-256-ecb",
      "2.16.840.1.101.3.4.1.42": "aes-256-cbc",
      "2.16.840.1.101.3.4.1.43": "aes-256-ofb",
      "2.16.840.1.101.3.4.1.44": "aes-256-cfb"
    };
  }
});

// node_modules/hash-base/index.js
var require_hash_base2 = __commonJS({
  "node_modules/hash-base/index.js"(exports2, module2) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var Buffer2 = require_safe_buffer().Buffer;
    var Transform = require_stream_browserify().Transform;
    var inherits = require_inherits();
    function HashBase(blockSize) {
      Transform.call(this);
      this._block = Buffer2.allocUnsafe(blockSize);
      this._blockSize = blockSize;
      this._blockOffset = 0;
      this._length = [0, 0, 0, 0];
      this._finalized = false;
    }
    inherits(HashBase, Transform);
    HashBase.prototype._transform = function(chunk, encoding, callback) {
      var error = null;
      try {
        this.update(chunk, encoding);
      } catch (err) {
        error = err;
      }
      callback(error);
    };
    HashBase.prototype._flush = function(callback) {
      var error = null;
      try {
        this.push(this.digest());
      } catch (err) {
        error = err;
      }
      callback(error);
    };
    var useUint8Array = typeof Uint8Array !== "undefined";
    var useArrayBuffer = typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined" && ArrayBuffer.isView && (Buffer2.prototype instanceof Uint8Array || Buffer2.TYPED_ARRAY_SUPPORT);
    function toBuffer(data, encoding) {
      if (data instanceof Buffer2) return data;
      if (typeof data === "string") return Buffer2.from(data, encoding);
      if (useArrayBuffer && ArrayBuffer.isView(data)) {
        if (data.byteLength === 0) return Buffer2.alloc(0);
        var res = Buffer2.from(data.buffer, data.byteOffset, data.byteLength);
        if (res.byteLength === data.byteLength) return res;
      }
      if (useUint8Array && data instanceof Uint8Array) return Buffer2.from(data);
      if (Buffer2.isBuffer(data) && data.constructor && typeof data.constructor.isBuffer === "function" && data.constructor.isBuffer(data)) {
        return Buffer2.from(data);
      }
      throw new TypeError('The "data" argument must be of type string or an instance of Buffer, TypedArray, or DataView.');
    }
    HashBase.prototype.update = function(data, encoding) {
      if (this._finalized) throw new Error("Digest already called");
      data = toBuffer(data, encoding);
      var block = this._block;
      var offset = 0;
      while (this._blockOffset + data.length - offset >= this._blockSize) {
        for (var i = this._blockOffset; i < this._blockSize; ) block[i++] = data[offset++];
        this._update();
        this._blockOffset = 0;
      }
      while (offset < data.length) block[this._blockOffset++] = data[offset++];
      for (var j = 0, carry = data.length * 8; carry > 0; ++j) {
        this._length[j] += carry;
        carry = this._length[j] / 4294967296 | 0;
        if (carry > 0) this._length[j] -= 4294967296 * carry;
      }
      return this;
    };
    HashBase.prototype._update = function() {
      throw new Error("_update is not implemented");
    };
    HashBase.prototype.digest = function(encoding) {
      if (this._finalized) throw new Error("Digest already called");
      this._finalized = true;
      var digest = this._digest();
      if (encoding !== void 0) digest = digest.toString(encoding);
      this._block.fill(0);
      this._blockOffset = 0;
      for (var i = 0; i < 4; ++i) this._length[i] = 0;
      return digest;
    };
    HashBase.prototype._digest = function() {
      throw new Error("_digest is not implemented");
    };
    module2.exports = HashBase;
  }
});

// node_modules/md5.js/index.js
var require_md52 = __commonJS({
  "node_modules/md5.js/index.js"(exports2, module2) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var inherits = require_inherits();
    var HashBase = require_hash_base2();
    var Buffer2 = require_safe_buffer().Buffer;
    var ARRAY16 = new Array(16);
    function MD5() {
      HashBase.call(this, 64);
      this._a = 1732584193;
      this._b = 4023233417;
      this._c = 2562383102;
      this._d = 271733878;
    }
    inherits(MD5, HashBase);
    MD5.prototype._update = function() {
      var M = ARRAY16;
      for (var i = 0; i < 16; ++i) M[i] = this._block.readInt32LE(i * 4);
      var a = this._a;
      var b = this._b;
      var c = this._c;
      var d = this._d;
      a = fnF(a, b, c, d, M[0], 3614090360, 7);
      d = fnF(d, a, b, c, M[1], 3905402710, 12);
      c = fnF(c, d, a, b, M[2], 606105819, 17);
      b = fnF(b, c, d, a, M[3], 3250441966, 22);
      a = fnF(a, b, c, d, M[4], 4118548399, 7);
      d = fnF(d, a, b, c, M[5], 1200080426, 12);
      c = fnF(c, d, a, b, M[6], 2821735955, 17);
      b = fnF(b, c, d, a, M[7], 4249261313, 22);
      a = fnF(a, b, c, d, M[8], 1770035416, 7);
      d = fnF(d, a, b, c, M[9], 2336552879, 12);
      c = fnF(c, d, a, b, M[10], 4294925233, 17);
      b = fnF(b, c, d, a, M[11], 2304563134, 22);
      a = fnF(a, b, c, d, M[12], 1804603682, 7);
      d = fnF(d, a, b, c, M[13], 4254626195, 12);
      c = fnF(c, d, a, b, M[14], 2792965006, 17);
      b = fnF(b, c, d, a, M[15], 1236535329, 22);
      a = fnG(a, b, c, d, M[1], 4129170786, 5);
      d = fnG(d, a, b, c, M[6], 3225465664, 9);
      c = fnG(c, d, a, b, M[11], 643717713, 14);
      b = fnG(b, c, d, a, M[0], 3921069994, 20);
      a = fnG(a, b, c, d, M[5], 3593408605, 5);
      d = fnG(d, a, b, c, M[10], 38016083, 9);
      c = fnG(c, d, a, b, M[15], 3634488961, 14);
      b = fnG(b, c, d, a, M[4], 3889429448, 20);
      a = fnG(a, b, c, d, M[9], 568446438, 5);
      d = fnG(d, a, b, c, M[14], 3275163606, 9);
      c = fnG(c, d, a, b, M[3], 4107603335, 14);
      b = fnG(b, c, d, a, M[8], 1163531501, 20);
      a = fnG(a, b, c, d, M[13], 2850285829, 5);
      d = fnG(d, a, b, c, M[2], 4243563512, 9);
      c = fnG(c, d, a, b, M[7], 1735328473, 14);
      b = fnG(b, c, d, a, M[12], 2368359562, 20);
      a = fnH(a, b, c, d, M[5], 4294588738, 4);
      d = fnH(d, a, b, c, M[8], 2272392833, 11);
      c = fnH(c, d, a, b, M[11], 1839030562, 16);
      b = fnH(b, c, d, a, M[14], 4259657740, 23);
      a = fnH(a, b, c, d, M[1], 2763975236, 4);
      d = fnH(d, a, b, c, M[4], 1272893353, 11);
      c = fnH(c, d, a, b, M[7], 4139469664, 16);
      b = fnH(b, c, d, a, M[10], 3200236656, 23);
      a = fnH(a, b, c, d, M[13], 681279174, 4);
      d = fnH(d, a, b, c, M[0], 3936430074, 11);
      c = fnH(c, d, a, b, M[3], 3572445317, 16);
      b = fnH(b, c, d, a, M[6], 76029189, 23);
      a = fnH(a, b, c, d, M[9], 3654602809, 4);
      d = fnH(d, a, b, c, M[12], 3873151461, 11);
      c = fnH(c, d, a, b, M[15], 530742520, 16);
      b = fnH(b, c, d, a, M[2], 3299628645, 23);
      a = fnI(a, b, c, d, M[0], 4096336452, 6);
      d = fnI(d, a, b, c, M[7], 1126891415, 10);
      c = fnI(c, d, a, b, M[14], 2878612391, 15);
      b = fnI(b, c, d, a, M[5], 4237533241, 21);
      a = fnI(a, b, c, d, M[12], 1700485571, 6);
      d = fnI(d, a, b, c, M[3], 2399980690, 10);
      c = fnI(c, d, a, b, M[10], 4293915773, 15);
      b = fnI(b, c, d, a, M[1], 2240044497, 21);
      a = fnI(a, b, c, d, M[8], 1873313359, 6);
      d = fnI(d, a, b, c, M[15], 4264355552, 10);
      c = fnI(c, d, a, b, M[6], 2734768916, 15);
      b = fnI(b, c, d, a, M[13], 1309151649, 21);
      a = fnI(a, b, c, d, M[4], 4149444226, 6);
      d = fnI(d, a, b, c, M[11], 3174756917, 10);
      c = fnI(c, d, a, b, M[2], 718787259, 15);
      b = fnI(b, c, d, a, M[9], 3951481745, 21);
      this._a = this._a + a | 0;
      this._b = this._b + b | 0;
      this._c = this._c + c | 0;
      this._d = this._d + d | 0;
    };
    MD5.prototype._digest = function() {
      this._block[this._blockOffset++] = 128;
      if (this._blockOffset > 56) {
        this._block.fill(0, this._blockOffset, 64);
        this._update();
        this._blockOffset = 0;
      }
      this._block.fill(0, this._blockOffset, 56);
      this._block.writeUInt32LE(this._length[0], 56);
      this._block.writeUInt32LE(this._length[1], 60);
      this._update();
      var buffer = Buffer2.allocUnsafe(16);
      buffer.writeInt32LE(this._a, 0);
      buffer.writeInt32LE(this._b, 4);
      buffer.writeInt32LE(this._c, 8);
      buffer.writeInt32LE(this._d, 12);
      return buffer;
    };
    function rotl(x, n) {
      return x << n | x >>> 32 - n;
    }
    function fnF(a, b, c, d, m, k, s) {
      return rotl(a + (b & c | ~b & d) + m + k | 0, s) + b | 0;
    }
    function fnG(a, b, c, d, m, k, s) {
      return rotl(a + (b & d | c & ~d) + m + k | 0, s) + b | 0;
    }
    function fnH(a, b, c, d, m, k, s) {
      return rotl(a + (b ^ c ^ d) + m + k | 0, s) + b | 0;
    }
    function fnI(a, b, c, d, m, k, s) {
      return rotl(a + (c ^ (b | ~d)) + m + k | 0, s) + b | 0;
    }
    module2.exports = MD5;
  }
});

// node_modules/evp_bytestokey/index.js
var require_evp_bytestokey = __commonJS({
  "node_modules/evp_bytestokey/index.js"(exports2, module2) {
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var Buffer2 = require_safe_buffer().Buffer;
    var MD5 = require_md52();
    function EVP_BytesToKey(password, salt, keyBits, ivLen) {
      if (!Buffer2.isBuffer(password)) password = Buffer2.from(password, "binary");
      if (salt) {
        if (!Buffer2.isBuffer(salt)) salt = Buffer2.from(salt, "binary");
        if (salt.length !== 8) throw new RangeError("salt should be Buffer with 8 byte length");
      }
      var keyLen = keyBits / 8;
      var key = Buffer2.alloc(keyLen);
      var iv = Buffer2.alloc(ivLen || 0);
      var tmp = Buffer2.alloc(0);
      while (keyLen > 0 || ivLen > 0) {
        var hash = new MD5();
        hash.update(tmp);
        hash.update(password);
        if (salt) hash.update(salt);
        tmp = hash.digest();
        var used = 0;
        if (keyLen > 0) {
          var keyStart = key.length - keyLen;
          used = Math.min(keyLen, tmp.length);
          tmp.copy(key, keyStart, 0, used);
          keyLen -= used;
        }
        if (used < tmp.length && ivLen > 0) {
          var ivStart = iv.length - ivLen;
          var length = Math.min(ivLen, tmp.length - used);
          tmp.copy(iv, ivStart, used, used + length);
          ivLen -= length;
        }
      }
      tmp.fill(0);
      return { key, iv };
    }
    module2.exports = EVP_BytesToKey;
  }
});

// node_modules/browserify-aes/index.js
var require_browserify_aes = __commonJS({
  "node_modules/browserify-aes/index.js"(exports2) {
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var crypto2 = require_crypto_browserify();
    exports2.createCipher = exports2.Cipher = crypto2.createCipher;
    exports2.createCipheriv = exports2.Cipheriv = crypto2.createCipheriv;
    exports2.createDecipher = exports2.Decipher = crypto2.createDecipher;
    exports2.createDecipheriv = exports2.Decipheriv = crypto2.createDecipheriv;
    exports2.listCiphers = exports2.getCiphers = crypto2.getCiphers;
  }
});

// node_modules/parse-asn1/fixProc.js
var require_fixProc = __commonJS({
  "node_modules/parse-asn1/fixProc.js"(exports2, module2) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var findProc = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m;
    var startRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m;
    var fullRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m;
    var evp = require_evp_bytestokey();
    var ciphers = require_browserify_aes();
    var Buffer2 = require_safe_buffer().Buffer;
    module2.exports = function(okey, password) {
      var key = okey.toString();
      var match = key.match(findProc);
      var decrypted;
      if (!match) {
        var match2 = key.match(fullRegex);
        decrypted = Buffer2.from(match2[2].replace(/[\r\n]/g, ""), "base64");
      } else {
        var suite = "aes" + match[1];
        var iv = Buffer2.from(match[2], "hex");
        var cipherText = Buffer2.from(match[3].replace(/[\r\n]/g, ""), "base64");
        var cipherKey = evp(password, iv.slice(0, 8), parseInt(match[1], 10)).key;
        var out = [];
        var cipher = ciphers.createDecipheriv(suite, cipherKey, iv);
        out.push(cipher.update(cipherText));
        out.push(cipher["final"]());
        decrypted = Buffer2.concat(out);
      }
      var tag = key.match(startRegex)[1];
      return {
        tag,
        data: decrypted
      };
    };
  }
});

// node_modules/parse-asn1/index.js
var require_parse_asn1 = __commonJS({
  "node_modules/parse-asn1/index.js"(exports2, module2) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var asn1 = require_asn12();
    var aesid = require_aesid();
    var fixProc = require_fixProc();
    var ciphers = require_browserify_aes();
    var compat = require_pbkdf2();
    var Buffer2 = require_safe_buffer().Buffer;
    function decrypt(data, password) {
      var salt = data.algorithm.decrypt.kde.kdeparams.salt;
      var iters = parseInt(data.algorithm.decrypt.kde.kdeparams.iters.toString(), 10);
      var algo = aesid[data.algorithm.decrypt.cipher.algo.join(".")];
      var iv = data.algorithm.decrypt.cipher.iv;
      var cipherText = data.subjectPrivateKey;
      var keylen = parseInt(algo.split("-")[1], 10) / 8;
      var key = compat.pbkdf2Sync(password, salt, iters, keylen, "sha1");
      var cipher = ciphers.createDecipheriv(algo, key, iv);
      var out = [];
      out.push(cipher.update(cipherText));
      out.push(cipher["final"]());
      return Buffer2.concat(out);
    }
    function parseKeys(buffer) {
      var password;
      if (typeof buffer === "object" && !Buffer2.isBuffer(buffer)) {
        password = buffer.passphrase;
        buffer = buffer.key;
      }
      if (typeof buffer === "string") {
        buffer = Buffer2.from(buffer);
      }
      var stripped = fixProc(buffer, password);
      var type = stripped.tag;
      var data = stripped.data;
      var subtype, ndata;
      switch (type) {
        case "CERTIFICATE":
          ndata = asn1.certificate.decode(data, "der").tbsCertificate.subjectPublicKeyInfo;
        // falls through
        case "PUBLIC KEY":
          if (!ndata) {
            ndata = asn1.PublicKey.decode(data, "der");
          }
          subtype = ndata.algorithm.algorithm.join(".");
          switch (subtype) {
            case "1.2.840.113549.1.1.1":
              return asn1.RSAPublicKey.decode(ndata.subjectPublicKey.data, "der");
            case "1.2.840.10045.2.1":
              ndata.subjectPrivateKey = ndata.subjectPublicKey;
              return {
                type: "ec",
                data: ndata
              };
            case "1.2.840.10040.4.1":
              ndata.algorithm.params.pub_key = asn1.DSAparam.decode(ndata.subjectPublicKey.data, "der");
              return {
                type: "dsa",
                data: ndata.algorithm.params
              };
            default:
              throw new Error("unknown key id " + subtype);
          }
        // throw new Error('unknown key type ' + type)
        case "ENCRYPTED PRIVATE KEY":
          data = asn1.EncryptedPrivateKey.decode(data, "der");
          data = decrypt(data, password);
        // falls through
        case "PRIVATE KEY":
          ndata = asn1.PrivateKey.decode(data, "der");
          subtype = ndata.algorithm.algorithm.join(".");
          switch (subtype) {
            case "1.2.840.113549.1.1.1":
              return asn1.RSAPrivateKey.decode(ndata.subjectPrivateKey, "der");
            case "1.2.840.10045.2.1":
              return {
                curve: ndata.algorithm.curve,
                privateKey: asn1.ECPrivateKey.decode(ndata.subjectPrivateKey, "der").privateKey
              };
            case "1.2.840.10040.4.1":
              ndata.algorithm.params.priv_key = asn1.DSAparam.decode(ndata.subjectPrivateKey, "der");
              return {
                type: "dsa",
                params: ndata.algorithm.params
              };
            default:
              throw new Error("unknown key id " + subtype);
          }
        // throw new Error('unknown key type ' + type)
        case "RSA PUBLIC KEY":
          return asn1.RSAPublicKey.decode(data, "der");
        case "RSA PRIVATE KEY":
          return asn1.RSAPrivateKey.decode(data, "der");
        case "DSA PRIVATE KEY":
          return {
            type: "dsa",
            params: asn1.DSAPrivateKey.decode(data, "der")
          };
        case "EC PRIVATE KEY":
          data = asn1.ECPrivateKey.decode(data, "der");
          return {
            curve: data.parameters.value,
            privateKey: data.privateKey
          };
        default:
          throw new Error("unknown key type " + type);
      }
    }
    parseKeys.signature = asn1.signature;
    module2.exports = parseKeys;
  }
});

// node_modules/public-encrypt/mgf.js
var require_mgf = __commonJS({
  "node_modules/public-encrypt/mgf.js"(exports2, module2) {
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var createHash = require_create_hash();
    var Buffer2 = require_safe_buffer().Buffer;
    module2.exports = function(seed, len) {
      var t = Buffer2.alloc(0);
      var i = 0;
      var c;
      while (t.length < len) {
        c = i2ops(i++);
        t = Buffer2.concat([t, createHash("sha1").update(seed).update(c).digest()]);
      }
      return t.slice(0, len);
    };
    function i2ops(c) {
      var out = Buffer2.allocUnsafe(4);
      out.writeUInt32BE(c, 0);
      return out;
    }
  }
});

// node_modules/public-encrypt/xor.js
var require_xor = __commonJS({
  "node_modules/public-encrypt/xor.js"(exports2, module2) {
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    module2.exports = function xor(a, b) {
      var len = a.length;
      var i = -1;
      while (++i < len) {
        a[i] ^= b[i];
      }
      return a;
    };
  }
});

// node_modules/public-encrypt/node_modules/bn.js/lib/bn.js
var require_bn4 = __commonJS({
  "node_modules/public-encrypt/node_modules/bn.js/lib/bn.js"(exports2, module2) {
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    (function(module3, exports3) {
      "use strict";
      function assert(val, msg) {
        if (!val) throw new Error(msg || "Assertion failed");
      }
      function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN(number, base, endian) {
        if (BN.isBN(number)) {
          return number;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number !== null) {
          if (base === "le" || base === "be") {
            endian = base;
            base = 10;
          }
          this._init(number || 0, base || 10, endian || "be");
        }
      }
      if (typeof module3 === "object") {
        module3.exports = BN;
      } else {
        exports3.BN = BN;
      }
      BN.BN = BN;
      BN.wordSize = 26;
      var Buffer2;
      try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
          Buffer2 = window.Buffer;
        } else {
          Buffer2 = (init_dist(), __toCommonJS(dist_exports)).Buffer;
        }
      } catch (e) {
      }
      BN.isBN = function isBN(num) {
        if (num instanceof BN) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
      };
      BN.max = function max(left, right) {
        if (left.cmp(right) > 0) return left;
        return right;
      };
      BN.min = function min(left, right) {
        if (left.cmp(right) < 0) return left;
        return right;
      };
      BN.prototype._init = function init(number, base, endian) {
        if (typeof number === "number") {
          return this._initNumber(number, base, endian);
        }
        if (typeof number === "object") {
          return this._initArray(number, base, endian);
        }
        if (base === "hex") {
          base = 16;
        }
        assert(base === (base | 0) && base >= 2 && base <= 36);
        number = number.toString().replace(/\s+/g, "");
        var start = 0;
        if (number[0] === "-") {
          start++;
          this.negative = 1;
        }
        if (start < number.length) {
          if (base === 16) {
            this._parseHex(number, start, endian);
          } else {
            this._parseBase(number, base, start);
            if (endian === "le") {
              this._initArray(this.toArray(), base, endian);
            }
          }
        }
      };
      BN.prototype._initNumber = function _initNumber(number, base, endian) {
        if (number < 0) {
          this.negative = 1;
          number = -number;
        }
        if (number < 67108864) {
          this.words = [number & 67108863];
          this.length = 1;
        } else if (number < 4503599627370496) {
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert(number < 9007199254740992);
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le") return;
        this._initArray(this.toArray(), base, endian);
      };
      BN.prototype._initArray = function _initArray(number, base, endian) {
        assert(typeof number.length === "number");
        if (number.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var j, w;
        var off = 0;
        if (endian === "be") {
          for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
            w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        } else if (endian === "le") {
          for (i = 0, j = 0; i < number.length; i += 3) {
            w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        }
        return this.strip();
      };
      function parseHex4Bits(string, index) {
        var c = string.charCodeAt(index);
        if (c >= 65 && c <= 70) {
          return c - 55;
        } else if (c >= 97 && c <= 102) {
          return c - 87;
        } else {
          return c - 48 & 15;
        }
      }
      function parseHexByte(string, lowerBound, index) {
        var r = parseHex4Bits(string, index);
        if (index - 1 >= lowerBound) {
          r |= parseHex4Bits(string, index - 1) << 4;
        }
        return r;
      }
      BN.prototype._parseHex = function _parseHex(number, start, endian) {
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var off = 0;
        var j = 0;
        var w;
        if (endian === "be") {
          for (i = number.length - 1; i >= start; i -= 2) {
            w = parseHexByte(number, start, i) << off;
            this.words[j] |= w & 67108863;
            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w >>> 26;
            } else {
              off += 8;
            }
          }
        } else {
          var parseLength = number.length - start;
          for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
            w = parseHexByte(number, start, i) << off;
            this.words[j] |= w & 67108863;
            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w >>> 26;
            } else {
              off += 8;
            }
          }
        }
        this.strip();
      };
      function parseBase(str, start, end, mul) {
        var r = 0;
        var len = Math.min(str.length, end);
        for (var i = start; i < len; i++) {
          var c = str.charCodeAt(i) - 48;
          r *= mul;
          if (c >= 49) {
            r += c - 49 + 10;
          } else if (c >= 17) {
            r += c - 17 + 10;
          } else {
            r += c;
          }
        }
        return r;
      }
      BN.prototype._parseBase = function _parseBase(number, base, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base | 0;
        var total = number.length - start;
        var mod = total % limbLen;
        var end = Math.min(total, total - mod) + start;
        var word = 0;
        for (var i = start; i < end; i += limbLen) {
          word = parseBase(number, i, i + limbLen, base);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod !== 0) {
          var pow = 1;
          word = parseBase(number, i, number.length, base);
          for (i = 0; i < mod; i++) {
            pow *= base;
          }
          this.imuln(pow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        this.strip();
      };
      BN.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          dest.words[i] = this.words[i];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      BN.prototype.clone = function clone() {
        var r = new BN(null);
        this.copy(r);
        return r;
      };
      BN.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN.prototype.strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      BN.prototype.inspect = function inspect() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var zeros = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN.prototype.toString = function toString(base, padding) {
        base = base || 10;
        padding = padding | 0 || 1;
        var out;
        if (base === 16 || base === "hex") {
          out = "";
          var off = 0;
          var carry = 0;
          for (var i = 0; i < this.length; i++) {
            var w = this.words[i];
            var word = ((w << off | carry) & 16777215).toString(16);
            carry = w >>> 24 - off & 16777215;
            off += 2;
            if (off >= 26) {
              off -= 26;
              i--;
            }
            if (carry !== 0 || i !== this.length - 1) {
              out = zeros[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base === (base | 0) && base >= 2 && base <= 36) {
          var groupSize = groupSizes[base];
          var groupBase = groupBases[base];
          out = "";
          var c = this.clone();
          c.negative = 0;
          while (!c.isZero()) {
            var r = c.modn(groupBase).toString(base);
            c = c.idivn(groupBase);
            if (!c.isZero()) {
              out = zeros[groupSize - r.length] + r + out;
            } else {
              out = r + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert(false, "Base should be between 2 and 36");
      };
      BN.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN.prototype.toJSON = function toJSON() {
        return this.toString(16);
      };
      BN.prototype.toBuffer = function toBuffer(endian, length) {
        assert(typeof Buffer2 !== "undefined");
        return this.toArrayLike(Buffer2, endian, length);
      };
      BN.prototype.toArray = function toArray(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
      BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        var byteLength = this.byteLength();
        var reqLength = length || Math.max(1, byteLength);
        assert(byteLength <= reqLength, "byte array longer than desired length");
        assert(reqLength > 0, "Requested array length <= 0");
        this.strip();
        var littleEndian = endian === "le";
        var res = new ArrayType(reqLength);
        var b, i;
        var q = this.clone();
        if (!littleEndian) {
          for (i = 0; i < reqLength - byteLength; i++) {
            res[i] = 0;
          }
          for (i = 0; !q.isZero(); i++) {
            b = q.andln(255);
            q.iushrn(8);
            res[reqLength - i - 1] = b;
          }
        } else {
          for (i = 0; !q.isZero(); i++) {
            b = q.andln(255);
            q.iushrn(8);
            res[i] = b;
          }
          for (; i < reqLength; i++) {
            res[i] = 0;
          }
        }
        return res;
      };
      if (Math.clz32) {
        BN.prototype._countBits = function _countBits(w) {
          return 32 - Math.clz32(w);
        };
      } else {
        BN.prototype._countBits = function _countBits(w) {
          var t = w;
          var r = 0;
          if (t >= 4096) {
            r += 13;
            t >>>= 13;
          }
          if (t >= 64) {
            r += 7;
            t >>>= 7;
          }
          if (t >= 8) {
            r += 4;
            t >>>= 4;
          }
          if (t >= 2) {
            r += 2;
            t >>>= 2;
          }
          return r + t;
        };
      }
      BN.prototype._zeroBits = function _zeroBits(w) {
        if (w === 0) return 26;
        var t = w;
        var r = 0;
        if ((t & 8191) === 0) {
          r += 13;
          t >>>= 13;
        }
        if ((t & 127) === 0) {
          r += 7;
          t >>>= 7;
        }
        if ((t & 15) === 0) {
          r += 4;
          t >>>= 4;
        }
        if ((t & 3) === 0) {
          r += 2;
          t >>>= 2;
        }
        if ((t & 1) === 0) {
          r++;
        }
        return r;
      };
      BN.prototype.bitLength = function bitLength() {
        var w = this.words[this.length - 1];
        var hi = this._countBits(w);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num) {
        var w = new Array(num.bitLength());
        for (var bit = 0; bit < w.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w[bit] = (num.words[off] & 1 << wbit) >>> wbit;
        }
        return w;
      }
      BN.prototype.zeroBits = function zeroBits() {
        if (this.isZero()) return 0;
        var r = 0;
        for (var i = 0; i < this.length; i++) {
          var b = this._zeroBits(this.words[i]);
          r += b;
          if (b !== 26) break;
        }
        return r;
      };
      BN.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN.prototype.neg = function neg() {
        return this.clone().ineg();
      };
      BN.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i = 0; i < num.length; i++) {
          this.words[i] = this.words[i] | num.words[i];
        }
        return this.strip();
      };
      BN.prototype.ior = function ior(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN.prototype.or = function or(num) {
        if (this.length > num.length) return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN.prototype.uor = function uor(num) {
        if (this.length > num.length) return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN.prototype.iuand = function iuand(num) {
        var b;
        if (this.length > num.length) {
          b = num;
        } else {
          b = this;
        }
        for (var i = 0; i < b.length; i++) {
          this.words[i] = this.words[i] & num.words[i];
        }
        this.length = b.length;
        return this.strip();
      };
      BN.prototype.iand = function iand(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN.prototype.and = function and(num) {
        if (this.length > num.length) return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN.prototype.uand = function uand(num) {
        if (this.length > num.length) return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN.prototype.iuxor = function iuxor(num) {
        var a;
        var b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        for (var i = 0; i < b.length; i++) {
          this.words[i] = a.words[i] ^ b.words[i];
        }
        if (this !== a) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = a.length;
        return this.strip();
      };
      BN.prototype.ixor = function ixor(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN.prototype.xor = function xor(num) {
        if (this.length > num.length) return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN.prototype.uxor = function uxor(num) {
        if (this.length > num.length) return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN.prototype.inotn = function inotn(width) {
        assert(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i = 0; i < bytesNeeded; i++) {
          this.words[i] = ~this.words[i] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;
        }
        return this.strip();
      };
      BN.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN.prototype.setn = function setn(bit, val) {
        assert(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this.strip();
      };
      BN.prototype.iadd = function iadd(num) {
        var r;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r = this.isub(num);
          num.negative = 1;
          return r._normSign();
        }
        var a, b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i = 0; i < b.length; i++) {
          r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
          this.words[i] = r & 67108863;
          carry = r >>> 26;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          this.words[i] = r & 67108863;
          carry = r >>> 26;
        }
        this.length = a.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        return this;
      };
      BN.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length) return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r = this.iadd(num);
          num.negative = 1;
          return r._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a, b;
        if (cmp > 0) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i = 0; i < b.length; i++) {
          r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 67108863;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 67108863;
        }
        if (carry === 0 && i < a.length && a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = Math.max(this.length, i);
        if (a !== this) {
          this.negative = 1;
        }
        return this.strip();
      };
      BN.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len = self2.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a = self2.words[0] | 0;
        var b = num.words[0] | 0;
        var r = a * b;
        var lo = r & 67108863;
        var carry = r / 67108864 | 0;
        out.words[0] = lo;
        for (var k = 1; k < len; k++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i = k - j | 0;
            a = self2.words[i] | 0;
            b = num.words[j] | 0;
            r = a * b + rword;
            ncarry += r / 67108864 | 0;
            rword = r & 67108863;
          }
          out.words[k] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k] = carry | 0;
        } else {
          out.length--;
        }
        return out.strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num, out) {
        var a = self2.words;
        var b = num.words;
        var o = out.words;
        var c = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a2 = a[2] | 0;
        var al2 = a2 & 8191;
        var ah2 = a2 >>> 13;
        var a3 = a[3] | 0;
        var al3 = a3 & 8191;
        var ah3 = a3 >>> 13;
        var a4 = a[4] | 0;
        var al4 = a4 & 8191;
        var ah4 = a4 >>> 13;
        var a5 = a[5] | 0;
        var al5 = a5 & 8191;
        var ah5 = a5 >>> 13;
        var a6 = a[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b0 = b[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b2 = b[2] | 0;
        var bl2 = b2 & 8191;
        var bh2 = b2 >>> 13;
        var b3 = b[3] | 0;
        var bl3 = b3 & 8191;
        var bh3 = b3 >>> 13;
        var b4 = b[4] | 0;
        var bl4 = b4 & 8191;
        var bh4 = b4 >>> 13;
        var b5 = b[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
        w2 &= 67108863;
        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
        w3 &= 67108863;
        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
        w4 &= 67108863;
        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
        w5 &= 67108863;
        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o[0] = w0;
        o[1] = w1;
        o[2] = w2;
        o[3] = w3;
        o[4] = w4;
        o[5] = w5;
        o[6] = w6;
        o[7] = w7;
        o[8] = w8;
        o[9] = w9;
        o[10] = w10;
        o[11] = w11;
        o[12] = w12;
        o[13] = w13;
        o[14] = w14;
        o[15] = w15;
        o[16] = w16;
        o[17] = w17;
        o[18] = w18;
        if (c !== 0) {
          o[19] = c;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k = 0; k < out.length - 1; k++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i = k - j;
            var a = self2.words[i] | 0;
            var b = num.words[j] | 0;
            var r = a * b;
            var lo = r & 67108863;
            ncarry = ncarry + (r / 67108864 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 67108863;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k] = carry;
        } else {
          out.length--;
        }
        return out.strip();
      }
      function jumboMulTo(self2, num, out) {
        var fftm = new FFTM();
        return fftm.mulp(self2, num, out);
      }
      BN.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      function FFTM(x, y) {
        this.x = x;
        this.y = y;
      }
      FFTM.prototype.makeRBT = function makeRBT(N) {
        var t = new Array(N);
        var l = BN.prototype._countBits(N) - 1;
        for (var i = 0; i < N; i++) {
          t[i] = this.revBin(i, l, N);
        }
        return t;
      };
      FFTM.prototype.revBin = function revBin(x, l, N) {
        if (x === 0 || x === N - 1) return x;
        var rb = 0;
        for (var i = 0; i < l; i++) {
          rb |= (x & 1) << l - i - 1;
          x >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
        for (var i = 0; i < N; i++) {
          rtws[i] = rws[rbt[i]];
          itws[i] = iws[rbt[i]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N);
        for (var s = 1; s < N; s <<= 1) {
          var l = s << 1;
          var rtwdf = Math.cos(2 * Math.PI / l);
          var itwdf = Math.sin(2 * Math.PI / l);
          for (var p = 0; p < N; p += l) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j = 0; j < s; j++) {
              var re = rtws[p + j];
              var ie = itws[p + j];
              var ro = rtws[p + j + s];
              var io = itws[p + j + s];
              var rx = rtwdf_ * ro - itwdf_ * io;
              io = rtwdf_ * io + itwdf_ * ro;
              ro = rx;
              rtws[p + j] = re + ro;
              itws[p + j] = ie + io;
              rtws[p + j + s] = re - ro;
              itws[p + j + s] = ie - io;
              if (j !== l) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
        var N = Math.max(m, n) | 1;
        var odd = N & 1;
        var i = 0;
        for (N = N / 2 | 0; N; N = N >>> 1) {
          i++;
        }
        return 1 << i + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
        if (N <= 1) return;
        for (var i = 0; i < N / 2; i++) {
          var t = rws[i];
          rws[i] = rws[N - i - 1];
          rws[N - i - 1] = t;
          t = iws[i];
          iws[i] = -iws[N - i - 1];
          iws[N - i - 1] = -t;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws, N) {
        var carry = 0;
        for (var i = 0; i < N / 2; i++) {
          var w = Math.round(ws[2 * i + 1] / N) * 8192 + Math.round(ws[2 * i] / N) + carry;
          ws[i] = w & 67108863;
          if (w < 67108864) {
            carry = 0;
          } else {
            carry = w / 67108864 | 0;
          }
        }
        return ws;
      };
      FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
        var carry = 0;
        for (var i = 0; i < len; i++) {
          carry = carry + (ws[i] | 0);
          rws[2 * i] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i = 2 * len; i < N; ++i) {
          rws[i] = 0;
        }
        assert(carry === 0);
        assert((carry & ~8191) === 0);
      };
      FFTM.prototype.stub = function stub(N) {
        var ph = new Array(N);
        for (var i = 0; i < N; i++) {
          ph[i] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x, y, out) {
        var N = 2 * this.guessLen13b(x.length, y.length);
        var rbt = this.makeRBT(N);
        var _ = this.stub(N);
        var rws = new Array(N);
        var rwst = new Array(N);
        var iwst = new Array(N);
        var nrws = new Array(N);
        var nrwst = new Array(N);
        var niwst = new Array(N);
        var rmws = out.words;
        rmws.length = N;
        this.convert13b(x.words, x.length, rws, N);
        this.convert13b(y.words, y.length, nrws, N);
        this.transform(rws, _, rwst, iwst, N, rbt);
        this.transform(nrws, _, nrwst, niwst, N, rbt);
        for (var i = 0; i < N; i++) {
          var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
          iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
          rwst[i] = rx;
        }
        this.conjugate(rwst, iwst, N);
        this.transform(rwst, iwst, rmws, _, N, rbt);
        this.conjugate(rmws, _, N);
        this.normalize13b(rmws, N);
        out.negative = x.negative ^ y.negative;
        out.length = x.length + y.length;
        return out.strip();
      };
      BN.prototype.mul = function mul(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN.prototype.mulf = function mulf(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN.prototype.imuln = function imuln(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        var carry = 0;
        for (var i = 0; i < this.length; i++) {
          var w = (this.words[i] | 0) * num;
          var lo = (w & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w / 67108864 | 0;
          carry += lo >>> 26;
          this.words[i] = lo & 67108863;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        this.length = num === 0 ? 1 : this.length;
        return this;
      };
      BN.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN.prototype.pow = function pow(num) {
        var w = toBitArray(num);
        if (w.length === 0) return new BN(1);
        var res = this;
        for (var i = 0; i < w.length; i++, res = res.sqr()) {
          if (w[i] !== 0) break;
        }
        if (++i < w.length) {
          for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
            if (w[i] === 0) continue;
            res = res.mul(q);
          }
        }
        return res;
      };
      BN.prototype.iushln = function iushln(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        var carryMask = 67108863 >>> 26 - r << 26 - r;
        var i;
        if (r !== 0) {
          var carry = 0;
          for (i = 0; i < this.length; i++) {
            var newCarry = this.words[i] & carryMask;
            var c = (this.words[i] | 0) - newCarry << r;
            this.words[i] = c | carry;
            carry = newCarry >>> 26 - r;
          }
          if (carry) {
            this.words[i] = carry;
            this.length++;
          }
        }
        if (s !== 0) {
          for (i = this.length - 1; i >= 0; i--) {
            this.words[i + s] = this.words[i];
          }
          for (i = 0; i < s; i++) {
            this.words[i] = 0;
          }
          this.length += s;
        }
        return this.strip();
      };
      BN.prototype.ishln = function ishln(bits) {
        assert(this.negative === 0);
        return this.iushln(bits);
      };
      BN.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert(typeof bits === "number" && bits >= 0);
        var h;
        if (hint) {
          h = (hint - hint % 26) / 26;
        } else {
          h = 0;
        }
        var r = bits % 26;
        var s = Math.min((bits - r) / 26, this.length);
        var mask = 67108863 ^ 67108863 >>> r << r;
        var maskedWords = extended;
        h -= s;
        h = Math.max(0, h);
        if (maskedWords) {
          for (var i = 0; i < s; i++) {
            maskedWords.words[i] = this.words[i];
          }
          maskedWords.length = s;
        }
        if (s === 0) {
        } else if (this.length > s) {
          this.length -= s;
          for (i = 0; i < this.length; i++) {
            this.words[i] = this.words[i + s];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
          var word = this.words[i] | 0;
          this.words[i] = carry << 26 - r | word >>> r;
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this.strip();
      };
      BN.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN.prototype.testn = function testn(bit) {
        assert(typeof bit === "number" && bit >= 0);
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        if (this.length <= s) return false;
        var w = this.words[s];
        return !!(w & q);
      };
      BN.prototype.imaskn = function imaskn(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        assert(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s) {
          return this;
        }
        if (r !== 0) {
          s++;
        }
        this.length = Math.min(s, this.length);
        if (r !== 0) {
          var mask = 67108863 ^ 67108863 >>> r << r;
          this.words[this.length - 1] &= mask;
        }
        return this.strip();
      };
      BN.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN.prototype.iaddn = function iaddn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0) return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) < num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) {
          this.words[i] -= 67108864;
          if (i === this.length - 1) {
            this.words[i + 1] = 1;
          } else {
            this.words[i + 1]++;
          }
        }
        this.length = Math.max(this.length, i + 1);
        return this;
      };
      BN.prototype.isubn = function isubn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0) return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i = 0; i < this.length && this.words[i] < 0; i++) {
            this.words[i] += 67108864;
            this.words[i + 1] -= 1;
          }
        }
        return this.strip();
      };
      BN.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len = num.length + shift;
        var i;
        this._expand(len);
        var w;
        var carry = 0;
        for (i = 0; i < num.length; i++) {
          w = (this.words[i + shift] | 0) + carry;
          var right = (num.words[i] | 0) * mul;
          w -= right & 67108863;
          carry = (w >> 26) - (right / 67108864 | 0);
          this.words[i + shift] = w & 67108863;
        }
        for (; i < this.length - shift; i++) {
          w = (this.words[i + shift] | 0) + carry;
          carry = w >> 26;
          this.words[i + shift] = w & 67108863;
        }
        if (carry === 0) return this.strip();
        assert(carry === -1);
        carry = 0;
        for (i = 0; i < this.length; i++) {
          w = -(this.words[i] | 0) + carry;
          carry = w >> 26;
          this.words[i] = w & 67108863;
        }
        this.negative = 1;
        return this.strip();
      };
      BN.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a = this.clone();
        var b = num;
        var bhi = b.words[b.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b = b.ushln(shift);
          a.iushln(shift);
          bhi = b.words[b.length - 1] | 0;
        }
        var m = a.length - b.length;
        var q;
        if (mode !== "mod") {
          q = new BN(null);
          q.length = m + 1;
          q.words = new Array(q.length);
          for (var i = 0; i < q.length; i++) {
            q.words[i] = 0;
          }
        }
        var diff = a.clone()._ishlnsubmul(b, 1, m);
        if (diff.negative === 0) {
          a = diff;
          if (q) {
            q.words[m] = 1;
          }
        }
        for (var j = m - 1; j >= 0; j--) {
          var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a._ishlnsubmul(b, qj, j);
          while (a.negative !== 0) {
            qj--;
            a.negative = 0;
            a._ishlnsubmul(b, 1, j);
            if (!a.isZero()) {
              a.negative ^= 1;
            }
          }
          if (q) {
            q.words[j] = qj;
          }
        }
        if (q) {
          q.strip();
        }
        a.strip();
        if (mode !== "div" && shift !== 0) {
          a.iushrn(shift);
        }
        return {
          div: q || null,
          mod: a
        };
      };
      BN.prototype.divmod = function divmod(num, mode, positive) {
        assert(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN(0),
            mod: new BN(0)
          };
        }
        var div, mod, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.iadd(num);
            }
          }
          return {
            div,
            mod
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.isub(num);
            }
          }
          return {
            div: res.div,
            mod
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN(this.modn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN(this.modn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN.prototype.mod = function mod(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero()) return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r2 = num.andln(1);
        var cmp = mod.cmp(half);
        if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN.prototype.modn = function modn(num) {
        assert(num <= 67108863);
        var p = (1 << 26) % num;
        var acc = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          acc = (p * acc + (this.words[i] | 0)) % num;
        }
        return acc;
      };
      BN.prototype.idivn = function idivn(num) {
        assert(num <= 67108863);
        var carry = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var w = (this.words[i] | 0) + carry * 67108864;
          this.words[i] = w / num | 0;
          carry = w % num;
        }
        return this.strip();
      };
      BN.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN.prototype.egcd = function egcd(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var x = this;
        var y = p.clone();
        if (x.negative !== 0) {
          x = x.umod(p);
        } else {
          x = x.clone();
        }
        var A = new BN(1);
        var B = new BN(0);
        var C = new BN(0);
        var D = new BN(1);
        var g = 0;
        while (x.isEven() && y.isEven()) {
          x.iushrn(1);
          y.iushrn(1);
          ++g;
        }
        var yp = y.clone();
        var xp = x.clone();
        while (!x.isZero()) {
          for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1) ;
          if (i > 0) {
            x.iushrn(i);
            while (i-- > 0) {
              if (A.isOdd() || B.isOdd()) {
                A.iadd(yp);
                B.isub(xp);
              }
              A.iushrn(1);
              B.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1) ;
          if (j > 0) {
            y.iushrn(j);
            while (j-- > 0) {
              if (C.isOdd() || D.isOdd()) {
                C.iadd(yp);
                D.isub(xp);
              }
              C.iushrn(1);
              D.iushrn(1);
            }
          }
          if (x.cmp(y) >= 0) {
            x.isub(y);
            A.isub(C);
            B.isub(D);
          } else {
            y.isub(x);
            C.isub(A);
            D.isub(B);
          }
        }
        return {
          a: C,
          b: D,
          gcd: y.iushln(g)
        };
      };
      BN.prototype._invmp = function _invmp(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var a = this;
        var b = p.clone();
        if (a.negative !== 0) {
          a = a.umod(p);
        } else {
          a = a.clone();
        }
        var x1 = new BN(1);
        var x2 = new BN(0);
        var delta = b.clone();
        while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
          for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1) ;
          if (i > 0) {
            a.iushrn(i);
            while (i-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1) ;
          if (j > 0) {
            b.iushrn(j);
            while (j-- > 0) {
              if (x2.isOdd()) {
                x2.iadd(delta);
              }
              x2.iushrn(1);
            }
          }
          if (a.cmp(b) >= 0) {
            a.isub(b);
            x1.isub(x2);
          } else {
            b.isub(a);
            x2.isub(x1);
          }
        }
        var res;
        if (a.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x2;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p);
        }
        return res;
      };
      BN.prototype.gcd = function gcd(num) {
        if (this.isZero()) return num.abs();
        if (num.isZero()) return this.abs();
        var a = this.clone();
        var b = num.clone();
        a.negative = 0;
        b.negative = 0;
        for (var shift = 0; a.isEven() && b.isEven(); shift++) {
          a.iushrn(1);
          b.iushrn(1);
        }
        do {
          while (a.isEven()) {
            a.iushrn(1);
          }
          while (b.isEven()) {
            b.iushrn(1);
          }
          var r = a.cmp(b);
          if (r < 0) {
            var t = a;
            a = b;
            b = t;
          } else if (r === 0 || b.cmpn(1) === 0) {
            break;
          }
          a.isub(b);
        } while (true);
        return b.iushln(shift);
      };
      BN.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN.prototype.bincn = function bincn(bit) {
        assert(typeof bit === "number");
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        if (this.length <= s) {
          this._expand(s + 1);
          this.words[s] |= q;
          return this;
        }
        var carry = q;
        for (var i = s; carry !== 0 && i < this.length; i++) {
          var w = this.words[i] | 0;
          w += carry;
          carry = w >>> 26;
          w &= 67108863;
          this.words[i] = w;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        return this;
      };
      BN.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative) return -1;
        if (this.negative === 0 && negative) return 1;
        this.strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert(num <= 67108863, "Number is too big");
          var w = this.words[0] | 0;
          res = w === num ? 0 : w < num ? -1 : 1;
        }
        if (this.negative !== 0) return -res | 0;
        return res;
      };
      BN.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0) return -1;
        if (this.negative === 0 && num.negative !== 0) return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0) return -res | 0;
        return res;
      };
      BN.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length) return 1;
        if (this.length < num.length) return -1;
        var res = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var a = this.words[i] | 0;
          var b = num.words[i] | 0;
          if (a === b) continue;
          if (a < b) {
            res = -1;
          } else if (a > b) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
      };
      BN.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
      };
      BN.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      };
      BN.red = function red(num) {
        return new Red(num);
      };
      BN.prototype.toRed = function toRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        assert(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN.prototype.fromRed = function fromRed() {
        assert(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN.prototype.forceRed = function forceRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN.prototype.redAdd = function redAdd(num) {
        assert(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN.prototype.redIAdd = function redIAdd(num) {
        assert(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN.prototype.redSub = function redSub(num) {
        assert(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN.prototype.redISub = function redISub(num) {
        assert(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN.prototype.redShl = function redShl(num) {
        assert(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN.prototype.redMul = function redMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN.prototype.redIMul = function redIMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN.prototype.redSqr = function redSqr() {
        assert(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN.prototype.redISqr = function redISqr() {
        assert(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN.prototype.redSqrt = function redSqrt() {
        assert(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN.prototype.redInvm = function redInvm() {
        assert(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN.prototype.redNeg = function redNeg() {
        assert(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN.prototype.redPow = function redPow(num) {
        assert(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name, p) {
        this.name = name;
        this.p = new BN(p, 16);
        this.n = this.p.bitLength();
        this.k = new BN(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r = num;
        var rlen;
        do {
          this.split(r, this.tmp);
          r = this.imulK(r);
          r = r.iadd(this.tmp);
          rlen = r.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
        if (cmp === 0) {
          r.words[0] = 0;
          r.length = 1;
        } else if (cmp > 0) {
          r.isub(this.p);
        } else {
          if (r.strip !== void 0) {
            r.strip();
          } else {
            r._strip();
          }
        }
        return r;
      };
      MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      inherits(K256, MPrime);
      K256.prototype.split = function split(input, output) {
        var mask = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i = 0; i < outLen; i++) {
          output.words[i] = input.words[i];
        }
        output.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for (i = 10; i < input.length; i++) {
          var next = input.words[i] | 0;
          input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo = 0;
        for (var i = 0; i < num.length; i++) {
          var w = num.words[i] | 0;
          lo += w * 977;
          num.words[i] = lo & 67108863;
          lo = w * 64 + (lo / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      inherits(P224, MPrime);
      function P192() {
        MPrime.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      inherits(P192, MPrime);
      function P25519() {
        MPrime.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      inherits(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i = 0; i < num.length; i++) {
          var hi = (num.words[i] | 0) * 19 + carry;
          var lo = hi & 67108863;
          hi >>>= 26;
          num.words[i] = lo;
          carry = hi;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN._prime = function prime(name) {
        if (primes[name]) return primes[name];
        var prime2;
        if (name === "k256") {
          prime2 = new K256();
        } else if (name === "p224") {
          prime2 = new P224();
        } else if (name === "p192") {
          prime2 = new P192();
        } else if (name === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name);
        }
        primes[name] = prime2;
        return prime2;
      };
      function Red(m) {
        if (typeof m === "string") {
          var prime = BN._prime(m);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert(m.gtn(1), "modulus must be greater than 1");
          this.m = m;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a) {
        assert(a.negative === 0, "red works only with positives");
        assert(a.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a, b) {
        assert((a.negative | b.negative) === 0, "red works only with positives");
        assert(
          a.red && a.red === b.red,
          "red works only with red numbers"
        );
      };
      Red.prototype.imod = function imod(a) {
        if (this.prime) return this.prime.ireduce(a)._forceRed(this);
        return a.umod(this.m)._forceRed(this);
      };
      Red.prototype.neg = function neg(a) {
        if (a.isZero()) {
          return a.clone();
        }
        return this.m.sub(a)._forceRed(this);
      };
      Red.prototype.add = function add(a, b) {
        this._verify2(a, b);
        var res = a.add(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a, b) {
        this._verify2(a, b);
        var res = a.iadd(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a, b) {
        this._verify2(a, b);
        var res = a.sub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a, b) {
        this._verify2(a, b);
        var res = a.isub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a, num) {
        this._verify1(a);
        return this.imod(a.ushln(num));
      };
      Red.prototype.imul = function imul(a, b) {
        this._verify2(a, b);
        return this.imod(a.imul(b));
      };
      Red.prototype.mul = function mul(a, b) {
        this._verify2(a, b);
        return this.imod(a.mul(b));
      };
      Red.prototype.isqr = function isqr(a) {
        return this.imul(a, a.clone());
      };
      Red.prototype.sqr = function sqr(a) {
        return this.mul(a, a);
      };
      Red.prototype.sqrt = function sqrt(a) {
        if (a.isZero()) return a.clone();
        var mod3 = this.m.andln(3);
        assert(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow = this.m.add(new BN(1)).iushrn(2);
          return this.pow(a, pow);
        }
        var q = this.m.subn(1);
        var s = 0;
        while (!q.isZero() && q.andln(1) === 0) {
          s++;
          q.iushrn(1);
        }
        assert(!q.isZero());
        var one = new BN(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z = this.m.bitLength();
        z = new BN(2 * z * z).toRed(this);
        while (this.pow(z, lpow).cmp(nOne) !== 0) {
          z.redIAdd(nOne);
        }
        var c = this.pow(z, q);
        var r = this.pow(a, q.addn(1).iushrn(1));
        var t = this.pow(a, q);
        var m = s;
        while (t.cmp(one) !== 0) {
          var tmp = t;
          for (var i = 0; tmp.cmp(one) !== 0; i++) {
            tmp = tmp.redSqr();
          }
          assert(i < m);
          var b = this.pow(c, new BN(1).iushln(m - i - 1));
          r = r.redMul(b);
          c = b.redSqr();
          t = t.redMul(c);
          m = i;
        }
        return r;
      };
      Red.prototype.invm = function invm(a) {
        var inv = a._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow(a, num) {
        if (num.isZero()) return new BN(1).toRed(this);
        if (num.cmpn(1) === 0) return a.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN(1).toRed(this);
        wnd[1] = a;
        for (var i = 2; i < wnd.length; i++) {
          wnd[i] = this.mul(wnd[i - 1], a);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i = num.length - 1; i >= 0; i--) {
          var word = num.words[i];
          for (var j = start - 1; j >= 0; j--) {
            var bit = word >> j & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r = num.umod(this.m);
        return r === num ? r.clone() : r;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m) {
        Red.call(this, m);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r = this.imod(num.mul(this.rinv));
        r.red = null;
        return r;
      };
      Mont.prototype.imul = function imul(a, b) {
        if (a.isZero() || b.isZero()) {
          a.words[0] = 0;
          a.length = 1;
          return a;
        }
        var t = a.imul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul(a, b) {
        if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);
        var t = a.mul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a) {
        var res = this.imod(a._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module2 === "undefined" || module2, exports2);
  }
});

// node_modules/public-encrypt/withPublic.js
var require_withPublic = __commonJS({
  "node_modules/public-encrypt/withPublic.js"(exports2, module2) {
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var BN = require_bn4();
    var Buffer2 = require_safe_buffer().Buffer;
    function withPublic(paddedMsg, key) {
      return Buffer2.from(paddedMsg.toRed(BN.mont(key.modulus)).redPow(new BN(key.publicExponent)).fromRed().toArray());
    }
    module2.exports = withPublic;
  }
});

// node_modules/bn.js/lib/bn.js
var require_bn5 = __commonJS({
  "node_modules/bn.js/lib/bn.js"(exports2, module2) {
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    (function(module3, exports3) {
      "use strict";
      function assert(val, msg) {
        if (!val) throw new Error(msg || "Assertion failed");
      }
      function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN(number, base, endian) {
        if (BN.isBN(number)) {
          return number;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number !== null) {
          if (base === "le" || base === "be") {
            endian = base;
            base = 10;
          }
          this._init(number || 0, base || 10, endian || "be");
        }
      }
      if (typeof module3 === "object") {
        module3.exports = BN;
      } else {
        exports3.BN = BN;
      }
      BN.BN = BN;
      BN.wordSize = 26;
      var Buffer2;
      try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
          Buffer2 = window.Buffer;
        } else {
          Buffer2 = (init_dist(), __toCommonJS(dist_exports)).Buffer;
        }
      } catch (e) {
      }
      BN.isBN = function isBN(num) {
        if (num instanceof BN) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
      };
      BN.max = function max(left, right) {
        if (left.cmp(right) > 0) return left;
        return right;
      };
      BN.min = function min(left, right) {
        if (left.cmp(right) < 0) return left;
        return right;
      };
      BN.prototype._init = function init(number, base, endian) {
        if (typeof number === "number") {
          return this._initNumber(number, base, endian);
        }
        if (typeof number === "object") {
          return this._initArray(number, base, endian);
        }
        if (base === "hex") {
          base = 16;
        }
        assert(base === (base | 0) && base >= 2 && base <= 36);
        number = number.toString().replace(/\s+/g, "");
        var start = 0;
        if (number[0] === "-") {
          start++;
          this.negative = 1;
        }
        if (start < number.length) {
          if (base === 16) {
            this._parseHex(number, start, endian);
          } else {
            this._parseBase(number, base, start);
            if (endian === "le") {
              this._initArray(this.toArray(), base, endian);
            }
          }
        }
      };
      BN.prototype._initNumber = function _initNumber(number, base, endian) {
        if (number < 0) {
          this.negative = 1;
          number = -number;
        }
        if (number < 67108864) {
          this.words = [number & 67108863];
          this.length = 1;
        } else if (number < 4503599627370496) {
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert(number < 9007199254740992);
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le") return;
        this._initArray(this.toArray(), base, endian);
      };
      BN.prototype._initArray = function _initArray(number, base, endian) {
        assert(typeof number.length === "number");
        if (number.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var j, w;
        var off = 0;
        if (endian === "be") {
          for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
            w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        } else if (endian === "le") {
          for (i = 0, j = 0; i < number.length; i += 3) {
            w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        }
        return this._strip();
      };
      function parseHex4Bits(string, index) {
        var c = string.charCodeAt(index);
        if (c >= 48 && c <= 57) {
          return c - 48;
        } else if (c >= 65 && c <= 70) {
          return c - 55;
        } else if (c >= 97 && c <= 102) {
          return c - 87;
        } else {
          assert(false, "Invalid character in " + string);
        }
      }
      function parseHexByte(string, lowerBound, index) {
        var r = parseHex4Bits(string, index);
        if (index - 1 >= lowerBound) {
          r |= parseHex4Bits(string, index - 1) << 4;
        }
        return r;
      }
      BN.prototype._parseHex = function _parseHex(number, start, endian) {
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var off = 0;
        var j = 0;
        var w;
        if (endian === "be") {
          for (i = number.length - 1; i >= start; i -= 2) {
            w = parseHexByte(number, start, i) << off;
            this.words[j] |= w & 67108863;
            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w >>> 26;
            } else {
              off += 8;
            }
          }
        } else {
          var parseLength = number.length - start;
          for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
            w = parseHexByte(number, start, i) << off;
            this.words[j] |= w & 67108863;
            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w >>> 26;
            } else {
              off += 8;
            }
          }
        }
        this._strip();
      };
      function parseBase(str, start, end, mul) {
        var r = 0;
        var b = 0;
        var len = Math.min(str.length, end);
        for (var i = start; i < len; i++) {
          var c = str.charCodeAt(i) - 48;
          r *= mul;
          if (c >= 49) {
            b = c - 49 + 10;
          } else if (c >= 17) {
            b = c - 17 + 10;
          } else {
            b = c;
          }
          assert(c >= 0 && b < mul, "Invalid character");
          r += b;
        }
        return r;
      }
      BN.prototype._parseBase = function _parseBase(number, base, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base | 0;
        var total = number.length - start;
        var mod = total % limbLen;
        var end = Math.min(total, total - mod) + start;
        var word = 0;
        for (var i = start; i < end; i += limbLen) {
          word = parseBase(number, i, i + limbLen, base);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod !== 0) {
          var pow = 1;
          word = parseBase(number, i, number.length, base);
          for (i = 0; i < mod; i++) {
            pow *= base;
          }
          this.imuln(pow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        this._strip();
      };
      BN.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          dest.words[i] = this.words[i];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      function move(dest, src) {
        dest.words = src.words;
        dest.length = src.length;
        dest.negative = src.negative;
        dest.red = src.red;
      }
      BN.prototype._move = function _move(dest) {
        move(dest, this);
      };
      BN.prototype.clone = function clone() {
        var r = new BN(null);
        this.copy(r);
        return r;
      };
      BN.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN.prototype._strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      if (typeof Symbol !== "undefined" && typeof Symbol.for === "function") {
        try {
          BN.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspect;
        } catch (e) {
          BN.prototype.inspect = inspect;
        }
      } else {
        BN.prototype.inspect = inspect;
      }
      function inspect() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      }
      var zeros = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN.prototype.toString = function toString(base, padding) {
        base = base || 10;
        padding = padding | 0 || 1;
        var out;
        if (base === 16 || base === "hex") {
          out = "";
          var off = 0;
          var carry = 0;
          for (var i = 0; i < this.length; i++) {
            var w = this.words[i];
            var word = ((w << off | carry) & 16777215).toString(16);
            carry = w >>> 24 - off & 16777215;
            off += 2;
            if (off >= 26) {
              off -= 26;
              i--;
            }
            if (carry !== 0 || i !== this.length - 1) {
              out = zeros[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base === (base | 0) && base >= 2 && base <= 36) {
          var groupSize = groupSizes[base];
          var groupBase = groupBases[base];
          out = "";
          var c = this.clone();
          c.negative = 0;
          while (!c.isZero()) {
            var r = c.modrn(groupBase).toString(base);
            c = c.idivn(groupBase);
            if (!c.isZero()) {
              out = zeros[groupSize - r.length] + r + out;
            } else {
              out = r + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert(false, "Base should be between 2 and 36");
      };
      BN.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN.prototype.toJSON = function toJSON() {
        return this.toString(16, 2);
      };
      if (Buffer2) {
        BN.prototype.toBuffer = function toBuffer(endian, length) {
          return this.toArrayLike(Buffer2, endian, length);
        };
      }
      BN.prototype.toArray = function toArray(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
      var allocate = function allocate2(ArrayType, size) {
        if (ArrayType.allocUnsafe) {
          return ArrayType.allocUnsafe(size);
        }
        return new ArrayType(size);
      };
      BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        this._strip();
        var byteLength = this.byteLength();
        var reqLength = length || Math.max(1, byteLength);
        assert(byteLength <= reqLength, "byte array longer than desired length");
        assert(reqLength > 0, "Requested array length <= 0");
        var res = allocate(ArrayType, reqLength);
        var postfix = endian === "le" ? "LE" : "BE";
        this["_toArrayLike" + postfix](res, byteLength);
        return res;
      };
      BN.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength) {
        var position = 0;
        var carry = 0;
        for (var i = 0, shift = 0; i < this.length; i++) {
          var word = this.words[i] << shift | carry;
          res[position++] = word & 255;
          if (position < res.length) {
            res[position++] = word >> 8 & 255;
          }
          if (position < res.length) {
            res[position++] = word >> 16 & 255;
          }
          if (shift === 6) {
            if (position < res.length) {
              res[position++] = word >> 24 & 255;
            }
            carry = 0;
            shift = 0;
          } else {
            carry = word >>> 24;
            shift += 2;
          }
        }
        if (position < res.length) {
          res[position++] = carry;
          while (position < res.length) {
            res[position++] = 0;
          }
        }
      };
      BN.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength) {
        var position = res.length - 1;
        var carry = 0;
        for (var i = 0, shift = 0; i < this.length; i++) {
          var word = this.words[i] << shift | carry;
          res[position--] = word & 255;
          if (position >= 0) {
            res[position--] = word >> 8 & 255;
          }
          if (position >= 0) {
            res[position--] = word >> 16 & 255;
          }
          if (shift === 6) {
            if (position >= 0) {
              res[position--] = word >> 24 & 255;
            }
            carry = 0;
            shift = 0;
          } else {
            carry = word >>> 24;
            shift += 2;
          }
        }
        if (position >= 0) {
          res[position--] = carry;
          while (position >= 0) {
            res[position--] = 0;
          }
        }
      };
      if (Math.clz32) {
        BN.prototype._countBits = function _countBits(w) {
          return 32 - Math.clz32(w);
        };
      } else {
        BN.prototype._countBits = function _countBits(w) {
          var t = w;
          var r = 0;
          if (t >= 4096) {
            r += 13;
            t >>>= 13;
          }
          if (t >= 64) {
            r += 7;
            t >>>= 7;
          }
          if (t >= 8) {
            r += 4;
            t >>>= 4;
          }
          if (t >= 2) {
            r += 2;
            t >>>= 2;
          }
          return r + t;
        };
      }
      BN.prototype._zeroBits = function _zeroBits(w) {
        if (w === 0) return 26;
        var t = w;
        var r = 0;
        if ((t & 8191) === 0) {
          r += 13;
          t >>>= 13;
        }
        if ((t & 127) === 0) {
          r += 7;
          t >>>= 7;
        }
        if ((t & 15) === 0) {
          r += 4;
          t >>>= 4;
        }
        if ((t & 3) === 0) {
          r += 2;
          t >>>= 2;
        }
        if ((t & 1) === 0) {
          r++;
        }
        return r;
      };
      BN.prototype.bitLength = function bitLength() {
        var w = this.words[this.length - 1];
        var hi = this._countBits(w);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num) {
        var w = new Array(num.bitLength());
        for (var bit = 0; bit < w.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w[bit] = num.words[off] >>> wbit & 1;
        }
        return w;
      }
      BN.prototype.zeroBits = function zeroBits() {
        if (this.isZero()) return 0;
        var r = 0;
        for (var i = 0; i < this.length; i++) {
          var b = this._zeroBits(this.words[i]);
          r += b;
          if (b !== 26) break;
        }
        return r;
      };
      BN.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN.prototype.neg = function neg() {
        return this.clone().ineg();
      };
      BN.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i = 0; i < num.length; i++) {
          this.words[i] = this.words[i] | num.words[i];
        }
        return this._strip();
      };
      BN.prototype.ior = function ior(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN.prototype.or = function or(num) {
        if (this.length > num.length) return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN.prototype.uor = function uor(num) {
        if (this.length > num.length) return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN.prototype.iuand = function iuand(num) {
        var b;
        if (this.length > num.length) {
          b = num;
        } else {
          b = this;
        }
        for (var i = 0; i < b.length; i++) {
          this.words[i] = this.words[i] & num.words[i];
        }
        this.length = b.length;
        return this._strip();
      };
      BN.prototype.iand = function iand(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN.prototype.and = function and(num) {
        if (this.length > num.length) return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN.prototype.uand = function uand(num) {
        if (this.length > num.length) return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN.prototype.iuxor = function iuxor(num) {
        var a;
        var b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        for (var i = 0; i < b.length; i++) {
          this.words[i] = a.words[i] ^ b.words[i];
        }
        if (this !== a) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = a.length;
        return this._strip();
      };
      BN.prototype.ixor = function ixor(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN.prototype.xor = function xor(num) {
        if (this.length > num.length) return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN.prototype.uxor = function uxor(num) {
        if (this.length > num.length) return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN.prototype.inotn = function inotn(width) {
        assert(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i = 0; i < bytesNeeded; i++) {
          this.words[i] = ~this.words[i] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;
        }
        return this._strip();
      };
      BN.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN.prototype.setn = function setn(bit, val) {
        assert(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this._strip();
      };
      BN.prototype.iadd = function iadd(num) {
        var r;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r = this.isub(num);
          num.negative = 1;
          return r._normSign();
        }
        var a, b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i = 0; i < b.length; i++) {
          r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
          this.words[i] = r & 67108863;
          carry = r >>> 26;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          this.words[i] = r & 67108863;
          carry = r >>> 26;
        }
        this.length = a.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        return this;
      };
      BN.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length) return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r = this.iadd(num);
          num.negative = 1;
          return r._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a, b;
        if (cmp > 0) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i = 0; i < b.length; i++) {
          r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 67108863;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 67108863;
        }
        if (carry === 0 && i < a.length && a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = Math.max(this.length, i);
        if (a !== this) {
          this.negative = 1;
        }
        return this._strip();
      };
      BN.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len = self2.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a = self2.words[0] | 0;
        var b = num.words[0] | 0;
        var r = a * b;
        var lo = r & 67108863;
        var carry = r / 67108864 | 0;
        out.words[0] = lo;
        for (var k = 1; k < len; k++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i = k - j | 0;
            a = self2.words[i] | 0;
            b = num.words[j] | 0;
            r = a * b + rword;
            ncarry += r / 67108864 | 0;
            rword = r & 67108863;
          }
          out.words[k] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k] = carry | 0;
        } else {
          out.length--;
        }
        return out._strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num, out) {
        var a = self2.words;
        var b = num.words;
        var o = out.words;
        var c = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a2 = a[2] | 0;
        var al2 = a2 & 8191;
        var ah2 = a2 >>> 13;
        var a3 = a[3] | 0;
        var al3 = a3 & 8191;
        var ah3 = a3 >>> 13;
        var a4 = a[4] | 0;
        var al4 = a4 & 8191;
        var ah4 = a4 >>> 13;
        var a5 = a[5] | 0;
        var al5 = a5 & 8191;
        var ah5 = a5 >>> 13;
        var a6 = a[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b0 = b[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b2 = b[2] | 0;
        var bl2 = b2 & 8191;
        var bh2 = b2 >>> 13;
        var b3 = b[3] | 0;
        var bl3 = b3 & 8191;
        var bh3 = b3 >>> 13;
        var b4 = b[4] | 0;
        var bl4 = b4 & 8191;
        var bh4 = b4 >>> 13;
        var b5 = b[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
        w2 &= 67108863;
        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
        w3 &= 67108863;
        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
        w4 &= 67108863;
        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
        w5 &= 67108863;
        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o[0] = w0;
        o[1] = w1;
        o[2] = w2;
        o[3] = w3;
        o[4] = w4;
        o[5] = w5;
        o[6] = w6;
        o[7] = w7;
        o[8] = w8;
        o[9] = w9;
        o[10] = w10;
        o[11] = w11;
        o[12] = w12;
        o[13] = w13;
        o[14] = w14;
        o[15] = w15;
        o[16] = w16;
        o[17] = w17;
        o[18] = w18;
        if (c !== 0) {
          o[19] = c;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k = 0; k < out.length - 1; k++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i = k - j;
            var a = self2.words[i] | 0;
            var b = num.words[j] | 0;
            var r = a * b;
            var lo = r & 67108863;
            ncarry = ncarry + (r / 67108864 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 67108863;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k] = carry;
        } else {
          out.length--;
        }
        return out._strip();
      }
      function jumboMulTo(self2, num, out) {
        return bigMulTo(self2, num, out);
      }
      BN.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      function FFTM(x, y) {
        this.x = x;
        this.y = y;
      }
      FFTM.prototype.makeRBT = function makeRBT(N) {
        var t = new Array(N);
        var l = BN.prototype._countBits(N) - 1;
        for (var i = 0; i < N; i++) {
          t[i] = this.revBin(i, l, N);
        }
        return t;
      };
      FFTM.prototype.revBin = function revBin(x, l, N) {
        if (x === 0 || x === N - 1) return x;
        var rb = 0;
        for (var i = 0; i < l; i++) {
          rb |= (x & 1) << l - i - 1;
          x >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
        for (var i = 0; i < N; i++) {
          rtws[i] = rws[rbt[i]];
          itws[i] = iws[rbt[i]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N);
        for (var s = 1; s < N; s <<= 1) {
          var l = s << 1;
          var rtwdf = Math.cos(2 * Math.PI / l);
          var itwdf = Math.sin(2 * Math.PI / l);
          for (var p = 0; p < N; p += l) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j = 0; j < s; j++) {
              var re = rtws[p + j];
              var ie = itws[p + j];
              var ro = rtws[p + j + s];
              var io = itws[p + j + s];
              var rx = rtwdf_ * ro - itwdf_ * io;
              io = rtwdf_ * io + itwdf_ * ro;
              ro = rx;
              rtws[p + j] = re + ro;
              itws[p + j] = ie + io;
              rtws[p + j + s] = re - ro;
              itws[p + j + s] = ie - io;
              if (j !== l) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
        var N = Math.max(m, n) | 1;
        var odd = N & 1;
        var i = 0;
        for (N = N / 2 | 0; N; N = N >>> 1) {
          i++;
        }
        return 1 << i + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
        if (N <= 1) return;
        for (var i = 0; i < N / 2; i++) {
          var t = rws[i];
          rws[i] = rws[N - i - 1];
          rws[N - i - 1] = t;
          t = iws[i];
          iws[i] = -iws[N - i - 1];
          iws[N - i - 1] = -t;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws, N) {
        var carry = 0;
        for (var i = 0; i < N / 2; i++) {
          var w = Math.round(ws[2 * i + 1] / N) * 8192 + Math.round(ws[2 * i] / N) + carry;
          ws[i] = w & 67108863;
          if (w < 67108864) {
            carry = 0;
          } else {
            carry = w / 67108864 | 0;
          }
        }
        return ws;
      };
      FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
        var carry = 0;
        for (var i = 0; i < len; i++) {
          carry = carry + (ws[i] | 0);
          rws[2 * i] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i = 2 * len; i < N; ++i) {
          rws[i] = 0;
        }
        assert(carry === 0);
        assert((carry & ~8191) === 0);
      };
      FFTM.prototype.stub = function stub(N) {
        var ph = new Array(N);
        for (var i = 0; i < N; i++) {
          ph[i] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x, y, out) {
        var N = 2 * this.guessLen13b(x.length, y.length);
        var rbt = this.makeRBT(N);
        var _ = this.stub(N);
        var rws = new Array(N);
        var rwst = new Array(N);
        var iwst = new Array(N);
        var nrws = new Array(N);
        var nrwst = new Array(N);
        var niwst = new Array(N);
        var rmws = out.words;
        rmws.length = N;
        this.convert13b(x.words, x.length, rws, N);
        this.convert13b(y.words, y.length, nrws, N);
        this.transform(rws, _, rwst, iwst, N, rbt);
        this.transform(nrws, _, nrwst, niwst, N, rbt);
        for (var i = 0; i < N; i++) {
          var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
          iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
          rwst[i] = rx;
        }
        this.conjugate(rwst, iwst, N);
        this.transform(rwst, iwst, rmws, _, N, rbt);
        this.conjugate(rmws, _, N);
        this.normalize13b(rmws, N);
        out.negative = x.negative ^ y.negative;
        out.length = x.length + y.length;
        return out._strip();
      };
      BN.prototype.mul = function mul(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN.prototype.mulf = function mulf(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN.prototype.imuln = function imuln(num) {
        var isNegNum = num < 0;
        if (isNegNum) num = -num;
        assert(typeof num === "number");
        assert(num < 67108864);
        var carry = 0;
        for (var i = 0; i < this.length; i++) {
          var w = (this.words[i] | 0) * num;
          var lo = (w & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w / 67108864 | 0;
          carry += lo >>> 26;
          this.words[i] = lo & 67108863;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        this.length = num === 0 ? 1 : this.length;
        return isNegNum ? this.ineg() : this;
      };
      BN.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN.prototype.pow = function pow(num) {
        var w = toBitArray(num);
        if (w.length === 0) return new BN(1);
        var res = this;
        for (var i = 0; i < w.length; i++, res = res.sqr()) {
          if (w[i] !== 0) break;
        }
        if (++i < w.length) {
          for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
            if (w[i] === 0) continue;
            res = res.mul(q);
          }
        }
        return res;
      };
      BN.prototype.iushln = function iushln(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        var carryMask = 67108863 >>> 26 - r << 26 - r;
        var i;
        if (r !== 0) {
          var carry = 0;
          for (i = 0; i < this.length; i++) {
            var newCarry = this.words[i] & carryMask;
            var c = (this.words[i] | 0) - newCarry << r;
            this.words[i] = c | carry;
            carry = newCarry >>> 26 - r;
          }
          if (carry) {
            this.words[i] = carry;
            this.length++;
          }
        }
        if (s !== 0) {
          for (i = this.length - 1; i >= 0; i--) {
            this.words[i + s] = this.words[i];
          }
          for (i = 0; i < s; i++) {
            this.words[i] = 0;
          }
          this.length += s;
        }
        return this._strip();
      };
      BN.prototype.ishln = function ishln(bits) {
        assert(this.negative === 0);
        return this.iushln(bits);
      };
      BN.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert(typeof bits === "number" && bits >= 0);
        var h;
        if (hint) {
          h = (hint - hint % 26) / 26;
        } else {
          h = 0;
        }
        var r = bits % 26;
        var s = Math.min((bits - r) / 26, this.length);
        var mask = 67108863 ^ 67108863 >>> r << r;
        var maskedWords = extended;
        h -= s;
        h = Math.max(0, h);
        if (maskedWords) {
          for (var i = 0; i < s; i++) {
            maskedWords.words[i] = this.words[i];
          }
          maskedWords.length = s;
        }
        if (s === 0) {
        } else if (this.length > s) {
          this.length -= s;
          for (i = 0; i < this.length; i++) {
            this.words[i] = this.words[i + s];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
          var word = this.words[i] | 0;
          this.words[i] = carry << 26 - r | word >>> r;
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this._strip();
      };
      BN.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN.prototype.testn = function testn(bit) {
        assert(typeof bit === "number" && bit >= 0);
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        if (this.length <= s) return false;
        var w = this.words[s];
        return !!(w & q);
      };
      BN.prototype.imaskn = function imaskn(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        assert(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s) {
          return this;
        }
        if (r !== 0) {
          s++;
        }
        this.length = Math.min(s, this.length);
        if (r !== 0) {
          var mask = 67108863 ^ 67108863 >>> r << r;
          this.words[this.length - 1] &= mask;
        }
        return this._strip();
      };
      BN.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN.prototype.iaddn = function iaddn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0) return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) <= num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) {
          this.words[i] -= 67108864;
          if (i === this.length - 1) {
            this.words[i + 1] = 1;
          } else {
            this.words[i + 1]++;
          }
        }
        this.length = Math.max(this.length, i + 1);
        return this;
      };
      BN.prototype.isubn = function isubn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0) return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i = 0; i < this.length && this.words[i] < 0; i++) {
            this.words[i] += 67108864;
            this.words[i + 1] -= 1;
          }
        }
        return this._strip();
      };
      BN.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len = num.length + shift;
        var i;
        this._expand(len);
        var w;
        var carry = 0;
        for (i = 0; i < num.length; i++) {
          w = (this.words[i + shift] | 0) + carry;
          var right = (num.words[i] | 0) * mul;
          w -= right & 67108863;
          carry = (w >> 26) - (right / 67108864 | 0);
          this.words[i + shift] = w & 67108863;
        }
        for (; i < this.length - shift; i++) {
          w = (this.words[i + shift] | 0) + carry;
          carry = w >> 26;
          this.words[i + shift] = w & 67108863;
        }
        if (carry === 0) return this._strip();
        assert(carry === -1);
        carry = 0;
        for (i = 0; i < this.length; i++) {
          w = -(this.words[i] | 0) + carry;
          carry = w >> 26;
          this.words[i] = w & 67108863;
        }
        this.negative = 1;
        return this._strip();
      };
      BN.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a = this.clone();
        var b = num;
        var bhi = b.words[b.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b = b.ushln(shift);
          a.iushln(shift);
          bhi = b.words[b.length - 1] | 0;
        }
        var m = a.length - b.length;
        var q;
        if (mode !== "mod") {
          q = new BN(null);
          q.length = m + 1;
          q.words = new Array(q.length);
          for (var i = 0; i < q.length; i++) {
            q.words[i] = 0;
          }
        }
        var diff = a.clone()._ishlnsubmul(b, 1, m);
        if (diff.negative === 0) {
          a = diff;
          if (q) {
            q.words[m] = 1;
          }
        }
        for (var j = m - 1; j >= 0; j--) {
          var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a._ishlnsubmul(b, qj, j);
          while (a.negative !== 0) {
            qj--;
            a.negative = 0;
            a._ishlnsubmul(b, 1, j);
            if (!a.isZero()) {
              a.negative ^= 1;
            }
          }
          if (q) {
            q.words[j] = qj;
          }
        }
        if (q) {
          q._strip();
        }
        a._strip();
        if (mode !== "div" && shift !== 0) {
          a.iushrn(shift);
        }
        return {
          div: q || null,
          mod: a
        };
      };
      BN.prototype.divmod = function divmod(num, mode, positive) {
        assert(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN(0),
            mod: new BN(0)
          };
        }
        var div, mod, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.iadd(num);
            }
          }
          return {
            div,
            mod
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.isub(num);
            }
          }
          return {
            div: res.div,
            mod
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN(this.modrn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN(this.modrn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN.prototype.mod = function mod(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero()) return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r2 = num.andln(1);
        var cmp = mod.cmp(half);
        if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN.prototype.modrn = function modrn(num) {
        var isNegNum = num < 0;
        if (isNegNum) num = -num;
        assert(num <= 67108863);
        var p = (1 << 26) % num;
        var acc = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          acc = (p * acc + (this.words[i] | 0)) % num;
        }
        return isNegNum ? -acc : acc;
      };
      BN.prototype.modn = function modn(num) {
        return this.modrn(num);
      };
      BN.prototype.idivn = function idivn(num) {
        var isNegNum = num < 0;
        if (isNegNum) num = -num;
        assert(num <= 67108863);
        var carry = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var w = (this.words[i] | 0) + carry * 67108864;
          this.words[i] = w / num | 0;
          carry = w % num;
        }
        this._strip();
        return isNegNum ? this.ineg() : this;
      };
      BN.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN.prototype.egcd = function egcd(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var x = this;
        var y = p.clone();
        if (x.negative !== 0) {
          x = x.umod(p);
        } else {
          x = x.clone();
        }
        var A = new BN(1);
        var B = new BN(0);
        var C = new BN(0);
        var D = new BN(1);
        var g = 0;
        while (x.isEven() && y.isEven()) {
          x.iushrn(1);
          y.iushrn(1);
          ++g;
        }
        var yp = y.clone();
        var xp = x.clone();
        while (!x.isZero()) {
          for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1) ;
          if (i > 0) {
            x.iushrn(i);
            while (i-- > 0) {
              if (A.isOdd() || B.isOdd()) {
                A.iadd(yp);
                B.isub(xp);
              }
              A.iushrn(1);
              B.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1) ;
          if (j > 0) {
            y.iushrn(j);
            while (j-- > 0) {
              if (C.isOdd() || D.isOdd()) {
                C.iadd(yp);
                D.isub(xp);
              }
              C.iushrn(1);
              D.iushrn(1);
            }
          }
          if (x.cmp(y) >= 0) {
            x.isub(y);
            A.isub(C);
            B.isub(D);
          } else {
            y.isub(x);
            C.isub(A);
            D.isub(B);
          }
        }
        return {
          a: C,
          b: D,
          gcd: y.iushln(g)
        };
      };
      BN.prototype._invmp = function _invmp(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var a = this;
        var b = p.clone();
        if (a.negative !== 0) {
          a = a.umod(p);
        } else {
          a = a.clone();
        }
        var x1 = new BN(1);
        var x2 = new BN(0);
        var delta = b.clone();
        while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
          for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1) ;
          if (i > 0) {
            a.iushrn(i);
            while (i-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1) ;
          if (j > 0) {
            b.iushrn(j);
            while (j-- > 0) {
              if (x2.isOdd()) {
                x2.iadd(delta);
              }
              x2.iushrn(1);
            }
          }
          if (a.cmp(b) >= 0) {
            a.isub(b);
            x1.isub(x2);
          } else {
            b.isub(a);
            x2.isub(x1);
          }
        }
        var res;
        if (a.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x2;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p);
        }
        return res;
      };
      BN.prototype.gcd = function gcd(num) {
        if (this.isZero()) return num.abs();
        if (num.isZero()) return this.abs();
        var a = this.clone();
        var b = num.clone();
        a.negative = 0;
        b.negative = 0;
        for (var shift = 0; a.isEven() && b.isEven(); shift++) {
          a.iushrn(1);
          b.iushrn(1);
        }
        do {
          while (a.isEven()) {
            a.iushrn(1);
          }
          while (b.isEven()) {
            b.iushrn(1);
          }
          var r = a.cmp(b);
          if (r < 0) {
            var t = a;
            a = b;
            b = t;
          } else if (r === 0 || b.cmpn(1) === 0) {
            break;
          }
          a.isub(b);
        } while (true);
        return b.iushln(shift);
      };
      BN.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN.prototype.bincn = function bincn(bit) {
        assert(typeof bit === "number");
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        if (this.length <= s) {
          this._expand(s + 1);
          this.words[s] |= q;
          return this;
        }
        var carry = q;
        for (var i = s; carry !== 0 && i < this.length; i++) {
          var w = this.words[i] | 0;
          w += carry;
          carry = w >>> 26;
          w &= 67108863;
          this.words[i] = w;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        return this;
      };
      BN.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative) return -1;
        if (this.negative === 0 && negative) return 1;
        this._strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert(num <= 67108863, "Number is too big");
          var w = this.words[0] | 0;
          res = w === num ? 0 : w < num ? -1 : 1;
        }
        if (this.negative !== 0) return -res | 0;
        return res;
      };
      BN.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0) return -1;
        if (this.negative === 0 && num.negative !== 0) return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0) return -res | 0;
        return res;
      };
      BN.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length) return 1;
        if (this.length < num.length) return -1;
        var res = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var a = this.words[i] | 0;
          var b = num.words[i] | 0;
          if (a === b) continue;
          if (a < b) {
            res = -1;
          } else if (a > b) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
      };
      BN.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
      };
      BN.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      };
      BN.red = function red(num) {
        return new Red(num);
      };
      BN.prototype.toRed = function toRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        assert(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN.prototype.fromRed = function fromRed() {
        assert(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN.prototype.forceRed = function forceRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN.prototype.redAdd = function redAdd(num) {
        assert(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN.prototype.redIAdd = function redIAdd(num) {
        assert(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN.prototype.redSub = function redSub(num) {
        assert(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN.prototype.redISub = function redISub(num) {
        assert(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN.prototype.redShl = function redShl(num) {
        assert(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN.prototype.redMul = function redMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN.prototype.redIMul = function redIMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN.prototype.redSqr = function redSqr() {
        assert(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN.prototype.redISqr = function redISqr() {
        assert(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN.prototype.redSqrt = function redSqrt() {
        assert(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN.prototype.redInvm = function redInvm() {
        assert(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN.prototype.redNeg = function redNeg() {
        assert(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN.prototype.redPow = function redPow(num) {
        assert(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name, p) {
        this.name = name;
        this.p = new BN(p, 16);
        this.n = this.p.bitLength();
        this.k = new BN(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r = num;
        var rlen;
        do {
          this.split(r, this.tmp);
          r = this.imulK(r);
          r = r.iadd(this.tmp);
          rlen = r.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
        if (cmp === 0) {
          r.words[0] = 0;
          r.length = 1;
        } else if (cmp > 0) {
          r.isub(this.p);
        } else {
          if (r.strip !== void 0) {
            r.strip();
          } else {
            r._strip();
          }
        }
        return r;
      };
      MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      inherits(K256, MPrime);
      K256.prototype.split = function split(input, output) {
        var mask = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i = 0; i < outLen; i++) {
          output.words[i] = input.words[i];
        }
        output.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for (i = 10; i < input.length; i++) {
          var next = input.words[i] | 0;
          input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo = 0;
        for (var i = 0; i < num.length; i++) {
          var w = num.words[i] | 0;
          lo += w * 977;
          num.words[i] = lo & 67108863;
          lo = w * 64 + (lo / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      inherits(P224, MPrime);
      function P192() {
        MPrime.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      inherits(P192, MPrime);
      function P25519() {
        MPrime.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      inherits(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i = 0; i < num.length; i++) {
          var hi = (num.words[i] | 0) * 19 + carry;
          var lo = hi & 67108863;
          hi >>>= 26;
          num.words[i] = lo;
          carry = hi;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN._prime = function prime(name) {
        if (primes[name]) return primes[name];
        var prime2;
        if (name === "k256") {
          prime2 = new K256();
        } else if (name === "p224") {
          prime2 = new P224();
        } else if (name === "p192") {
          prime2 = new P192();
        } else if (name === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name);
        }
        primes[name] = prime2;
        return prime2;
      };
      function Red(m) {
        if (typeof m === "string") {
          var prime = BN._prime(m);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert(m.gtn(1), "modulus must be greater than 1");
          this.m = m;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a) {
        assert(a.negative === 0, "red works only with positives");
        assert(a.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a, b) {
        assert((a.negative | b.negative) === 0, "red works only with positives");
        assert(
          a.red && a.red === b.red,
          "red works only with red numbers"
        );
      };
      Red.prototype.imod = function imod(a) {
        if (this.prime) return this.prime.ireduce(a)._forceRed(this);
        move(a, a.umod(this.m)._forceRed(this));
        return a;
      };
      Red.prototype.neg = function neg(a) {
        if (a.isZero()) {
          return a.clone();
        }
        return this.m.sub(a)._forceRed(this);
      };
      Red.prototype.add = function add(a, b) {
        this._verify2(a, b);
        var res = a.add(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a, b) {
        this._verify2(a, b);
        var res = a.iadd(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a, b) {
        this._verify2(a, b);
        var res = a.sub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a, b) {
        this._verify2(a, b);
        var res = a.isub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a, num) {
        this._verify1(a);
        return this.imod(a.ushln(num));
      };
      Red.prototype.imul = function imul(a, b) {
        this._verify2(a, b);
        return this.imod(a.imul(b));
      };
      Red.prototype.mul = function mul(a, b) {
        this._verify2(a, b);
        return this.imod(a.mul(b));
      };
      Red.prototype.isqr = function isqr(a) {
        return this.imul(a, a.clone());
      };
      Red.prototype.sqr = function sqr(a) {
        return this.mul(a, a);
      };
      Red.prototype.sqrt = function sqrt(a) {
        if (a.isZero()) return a.clone();
        var mod3 = this.m.andln(3);
        assert(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow = this.m.add(new BN(1)).iushrn(2);
          return this.pow(a, pow);
        }
        var q = this.m.subn(1);
        var s = 0;
        while (!q.isZero() && q.andln(1) === 0) {
          s++;
          q.iushrn(1);
        }
        assert(!q.isZero());
        var one = new BN(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z = this.m.bitLength();
        z = new BN(2 * z * z).toRed(this);
        while (this.pow(z, lpow).cmp(nOne) !== 0) {
          z.redIAdd(nOne);
        }
        var c = this.pow(z, q);
        var r = this.pow(a, q.addn(1).iushrn(1));
        var t = this.pow(a, q);
        var m = s;
        while (t.cmp(one) !== 0) {
          var tmp = t;
          for (var i = 0; tmp.cmp(one) !== 0; i++) {
            tmp = tmp.redSqr();
          }
          assert(i < m);
          var b = this.pow(c, new BN(1).iushln(m - i - 1));
          r = r.redMul(b);
          c = b.redSqr();
          t = t.redMul(c);
          m = i;
        }
        return r;
      };
      Red.prototype.invm = function invm(a) {
        var inv = a._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow(a, num) {
        if (num.isZero()) return new BN(1).toRed(this);
        if (num.cmpn(1) === 0) return a.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN(1).toRed(this);
        wnd[1] = a;
        for (var i = 2; i < wnd.length; i++) {
          wnd[i] = this.mul(wnd[i - 1], a);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i = num.length - 1; i >= 0; i--) {
          var word = num.words[i];
          for (var j = start - 1; j >= 0; j--) {
            var bit = word >> j & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r = num.umod(this.m);
        return r === num ? r.clone() : r;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m) {
        Red.call(this, m);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r = this.imod(num.mul(this.rinv));
        r.red = null;
        return r;
      };
      Mont.prototype.imul = function imul(a, b) {
        if (a.isZero() || b.isZero()) {
          a.words[0] = 0;
          a.length = 1;
          return a;
        }
        var t = a.imul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul(a, b) {
        if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);
        var t = a.mul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a) {
        var res = this.imod(a._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module2 === "undefined" || module2, exports2);
  }
});

// node_modules/browserify-rsa/index.js
var require_browserify_rsa = __commonJS({
  "node_modules/browserify-rsa/index.js"(exports2, module2) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var BN = require_bn5();
    var randomBytes = require_randombytes();
    var Buffer2 = require_safe_buffer().Buffer;
    function getr(priv) {
      var len = priv.modulus.byteLength();
      var r;
      do {
        r = new BN(randomBytes(len));
      } while (r.cmp(priv.modulus) >= 0 || !r.umod(priv.prime1) || !r.umod(priv.prime2));
      return r;
    }
    function blind(priv) {
      var r = getr(priv);
      var blinder = r.toRed(BN.mont(priv.modulus)).redPow(new BN(priv.publicExponent)).fromRed();
      return { blinder, unblinder: r.invm(priv.modulus) };
    }
    function crt(msg, priv) {
      var blinds = blind(priv);
      var len = priv.modulus.byteLength();
      var blinded = new BN(msg).mul(blinds.blinder).umod(priv.modulus);
      var c1 = blinded.toRed(BN.mont(priv.prime1));
      var c2 = blinded.toRed(BN.mont(priv.prime2));
      var qinv = priv.coefficient;
      var p = priv.prime1;
      var q = priv.prime2;
      var m1 = c1.redPow(priv.exponent1).fromRed();
      var m2 = c2.redPow(priv.exponent2).fromRed();
      var h = m1.isub(m2).imul(qinv).umod(p).imul(q);
      return m2.iadd(h).imul(blinds.unblinder).umod(priv.modulus).toArrayLike(Buffer2, "be", len);
    }
    crt.getr = getr;
    module2.exports = crt;
  }
});

// node_modules/public-encrypt/publicEncrypt.js
var require_publicEncrypt = __commonJS({
  "node_modules/public-encrypt/publicEncrypt.js"(exports2, module2) {
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var parseKeys = require_parse_asn1();
    var randomBytes = require_randombytes();
    var createHash = require_create_hash();
    var mgf = require_mgf();
    var xor = require_xor();
    var BN = require_bn4();
    var withPublic = require_withPublic();
    var crt = require_browserify_rsa();
    var Buffer2 = require_safe_buffer().Buffer;
    module2.exports = function publicEncrypt(publicKey, msg, reverse) {
      var padding;
      if (publicKey.padding) {
        padding = publicKey.padding;
      } else if (reverse) {
        padding = 1;
      } else {
        padding = 4;
      }
      var key = parseKeys(publicKey);
      var paddedMsg;
      if (padding === 4) {
        paddedMsg = oaep(key, msg);
      } else if (padding === 1) {
        paddedMsg = pkcs1(key, msg, reverse);
      } else if (padding === 3) {
        paddedMsg = new BN(msg);
        if (paddedMsg.cmp(key.modulus) >= 0) {
          throw new Error("data too long for modulus");
        }
      } else {
        throw new Error("unknown padding");
      }
      if (reverse) {
        return crt(paddedMsg, key);
      } else {
        return withPublic(paddedMsg, key);
      }
    };
    function oaep(key, msg) {
      var k = key.modulus.byteLength();
      var mLen = msg.length;
      var iHash = createHash("sha1").update(Buffer2.alloc(0)).digest();
      var hLen = iHash.length;
      var hLen2 = 2 * hLen;
      if (mLen > k - hLen2 - 2) {
        throw new Error("message too long");
      }
      var ps = Buffer2.alloc(k - mLen - hLen2 - 2);
      var dblen = k - hLen - 1;
      var seed = randomBytes(hLen);
      var maskedDb = xor(Buffer2.concat([iHash, ps, Buffer2.alloc(1, 1), msg], dblen), mgf(seed, dblen));
      var maskedSeed = xor(seed, mgf(maskedDb, hLen));
      return new BN(Buffer2.concat([Buffer2.alloc(1), maskedSeed, maskedDb], k));
    }
    function pkcs1(key, msg, reverse) {
      var mLen = msg.length;
      var k = key.modulus.byteLength();
      if (mLen > k - 11) {
        throw new Error("message too long");
      }
      var ps;
      if (reverse) {
        ps = Buffer2.alloc(k - mLen - 3, 255);
      } else {
        ps = nonZero(k - mLen - 3);
      }
      return new BN(Buffer2.concat([Buffer2.from([0, reverse ? 1 : 2]), ps, Buffer2.alloc(1), msg], k));
    }
    function nonZero(len) {
      var out = Buffer2.allocUnsafe(len);
      var i = 0;
      var cache = randomBytes(len * 2);
      var cur = 0;
      var num;
      while (i < len) {
        if (cur === cache.length) {
          cache = randomBytes(len * 2);
          cur = 0;
        }
        num = cache[cur++];
        if (num) {
          out[i++] = num;
        }
      }
      return out;
    }
  }
});

// node_modules/public-encrypt/privateDecrypt.js
var require_privateDecrypt = __commonJS({
  "node_modules/public-encrypt/privateDecrypt.js"(exports2, module2) {
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var parseKeys = require_parse_asn1();
    var mgf = require_mgf();
    var xor = require_xor();
    var BN = require_bn4();
    var crt = require_browserify_rsa();
    var createHash = require_create_hash();
    var withPublic = require_withPublic();
    var Buffer2 = require_safe_buffer().Buffer;
    module2.exports = function privateDecrypt(privateKey, enc, reverse) {
      var padding;
      if (privateKey.padding) {
        padding = privateKey.padding;
      } else if (reverse) {
        padding = 1;
      } else {
        padding = 4;
      }
      var key = parseKeys(privateKey);
      var k = key.modulus.byteLength();
      if (enc.length > k || new BN(enc).cmp(key.modulus) >= 0) {
        throw new Error("decryption error");
      }
      var msg;
      if (reverse) {
        msg = withPublic(new BN(enc), key);
      } else {
        msg = crt(enc, key);
      }
      var zBuffer = Buffer2.alloc(k - msg.length);
      msg = Buffer2.concat([zBuffer, msg], k);
      if (padding === 4) {
        return oaep(key, msg);
      } else if (padding === 1) {
        return pkcs1(key, msg, reverse);
      } else if (padding === 3) {
        return msg;
      } else {
        throw new Error("unknown padding");
      }
    };
    function oaep(key, msg) {
      var k = key.modulus.byteLength();
      var iHash = createHash("sha1").update(Buffer2.alloc(0)).digest();
      var hLen = iHash.length;
      if (msg[0] !== 0) {
        throw new Error("decryption error");
      }
      var maskedSeed = msg.slice(1, hLen + 1);
      var maskedDb = msg.slice(hLen + 1);
      var seed = xor(maskedSeed, mgf(maskedDb, hLen));
      var db = xor(maskedDb, mgf(seed, k - hLen - 1));
      if (compare(iHash, db.slice(0, hLen))) {
        throw new Error("decryption error");
      }
      var i = hLen;
      while (db[i] === 0) {
        i++;
      }
      if (db[i++] !== 1) {
        throw new Error("decryption error");
      }
      return db.slice(i);
    }
    function pkcs1(key, msg, reverse) {
      var p1 = msg.slice(0, 2);
      var i = 2;
      var status = 0;
      while (msg[i++] !== 0) {
        if (i >= msg.length) {
          status++;
          break;
        }
      }
      var ps = msg.slice(2, i - 1);
      if (p1.toString("hex") !== "0002" && !reverse || p1.toString("hex") !== "0001" && reverse) {
        status++;
      }
      if (ps.length < 8) {
        status++;
      }
      if (status) {
        throw new Error("decryption error");
      }
      return msg.slice(i);
    }
    function compare(a, b) {
      a = Buffer2.from(a);
      b = Buffer2.from(b);
      var dif = 0;
      var len = a.length;
      if (a.length !== b.length) {
        dif++;
        len = Math.min(a.length, b.length);
      }
      var i = -1;
      while (++i < len) {
        dif += a[i] ^ b[i];
      }
      return dif;
    }
  }
});

// node_modules/public-encrypt/browser.js
var require_browser3 = __commonJS({
  "node_modules/public-encrypt/browser.js"(exports2) {
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    exports2.publicEncrypt = require_publicEncrypt();
    exports2.privateDecrypt = require_privateDecrypt();
    exports2.privateEncrypt = function privateEncrypt(key, buf) {
      return exports2.publicEncrypt(key, buf, true);
    };
    exports2.publicDecrypt = function publicDecrypt(key, buf) {
      return exports2.privateDecrypt(key, buf, true);
    };
  }
});

// node_modules/public-encrypt/index.js
var require_public_encrypt = __commonJS({
  "node_modules/public-encrypt/index.js"(exports2) {
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var crypto2 = require_crypto_browserify();
    if (typeof crypto2.publicEncrypt !== "function") {
      crypto2 = require_browser3();
    }
    exports2.publicEncrypt = crypto2.publicEncrypt;
    exports2.privateDecrypt = crypto2.privateDecrypt;
    if (typeof crypto2.privateEncrypt !== "function") {
      exports2.privateEncrypt = require_browser3().privateEncrypt;
    } else {
      exports2.privateEncrypt = crypto2.privateEncrypt;
    }
    if (typeof crypto2.publicDecrypt !== "function") {
      exports2.publicDecrypt = require_browser3().publicDecrypt;
    } else {
      exports2.publicDecrypt = crypto2.publicDecrypt;
    }
  }
});

// node_modules/randomfill/browser.js
var require_browser4 = __commonJS({
  "node_modules/randomfill/browser.js"(exports2) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    function oldBrowser() {
      throw new Error("secure random number generation not supported by this browser\nuse chrome, FireFox or Internet Explorer 11");
    }
    var safeBuffer = require_safe_buffer();
    var randombytes = require_randombytes();
    var Buffer2 = safeBuffer.Buffer;
    var kBufferMaxLength = safeBuffer.kMaxLength;
    var crypto2 = global.crypto || global.msCrypto;
    var kMaxUint32 = Math.pow(2, 32) - 1;
    function assertOffset(offset, length) {
      if (typeof offset !== "number" || offset !== offset) {
        throw new TypeError("offset must be a number");
      }
      if (offset > kMaxUint32 || offset < 0) {
        throw new TypeError("offset must be a uint32");
      }
      if (offset > kBufferMaxLength || offset > length) {
        throw new RangeError("offset out of range");
      }
    }
    function assertSize(size, offset, length) {
      if (typeof size !== "number" || size !== size) {
        throw new TypeError("size must be a number");
      }
      if (size > kMaxUint32 || size < 0) {
        throw new TypeError("size must be a uint32");
      }
      if (size + offset > length || size > kBufferMaxLength) {
        throw new RangeError("buffer too small");
      }
    }
    if (crypto2 && crypto2.getRandomValues || !process.browser) {
      exports2.randomFill = randomFill;
      exports2.randomFillSync = randomFillSync;
    } else {
      exports2.randomFill = oldBrowser;
      exports2.randomFillSync = oldBrowser;
    }
    function randomFill(buf, offset, size, cb) {
      if (!Buffer2.isBuffer(buf) && !(buf instanceof global.Uint8Array)) {
        throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
      }
      if (typeof offset === "function") {
        cb = offset;
        offset = 0;
        size = buf.length;
      } else if (typeof size === "function") {
        cb = size;
        size = buf.length - offset;
      } else if (typeof cb !== "function") {
        throw new TypeError('"cb" argument must be a function');
      }
      assertOffset(offset, buf.length);
      assertSize(size, offset, buf.length);
      return actualFill(buf, offset, size, cb);
    }
    function actualFill(buf, offset, size, cb) {
      if (process.browser) {
        var ourBuf = buf.buffer;
        var uint = new Uint8Array(ourBuf, offset, size);
        crypto2.getRandomValues(uint);
        if (cb) {
          process.nextTick(function() {
            cb(null, buf);
          });
          return;
        }
        return buf;
      }
      if (cb) {
        randombytes(size, function(err, bytes2) {
          if (err) {
            return cb(err);
          }
          bytes2.copy(buf, offset);
          cb(null, buf);
        });
        return;
      }
      var bytes = randombytes(size);
      bytes.copy(buf, offset);
      return buf;
    }
    function randomFillSync(buf, offset, size) {
      if (typeof offset === "undefined") {
        offset = 0;
      }
      if (!Buffer2.isBuffer(buf) && !(buf instanceof global.Uint8Array)) {
        throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
      }
      assertOffset(offset, buf.length);
      if (size === void 0) size = buf.length - offset;
      assertSize(size, offset, buf.length);
      return actualFill(buf, offset, size);
    }
  }
});

// node_modules/randomfill/index.js
var require_randomfill = __commonJS({
  "node_modules/randomfill/index.js"(exports2, module2) {
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var crypto2 = require_crypto_browserify();
    if (typeof crypto2.randomFill === "function" && typeof crypto2.randomFillSync === "function") {
      exports2.randomFill = crypto2.randomFill;
      exports2.randomFillSync = crypto2.randomFillSync;
    } else {
      module2.exports = require_browser4();
    }
  }
});

// node_modules/crypto-browserify/index.js
var require_crypto_browserify = __commonJS({
  "node_modules/crypto-browserify/index.js"(exports2) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    exports2.randomBytes = exports2.rng = exports2.pseudoRandomBytes = exports2.prng = require_randombytes();
    exports2.createHash = exports2.Hash = require_create_hash();
    exports2.createHmac = exports2.Hmac = require_create_hmac();
    var algos = require_algos();
    var algoKeys = Object.keys(algos);
    var hashes = [
      "sha1",
      "sha224",
      "sha256",
      "sha384",
      "sha512",
      "md5",
      "rmd160"
    ].concat(algoKeys);
    exports2.getHashes = function() {
      return hashes;
    };
    var p = require_pbkdf2();
    exports2.pbkdf2 = p.pbkdf2;
    exports2.pbkdf2Sync = p.pbkdf2Sync;
    var aes = require_browserify_cipher();
    exports2.Cipher = aes.Cipher;
    exports2.createCipher = aes.createCipher;
    exports2.Cipheriv = aes.Cipheriv;
    exports2.createCipheriv = aes.createCipheriv;
    exports2.Decipher = aes.Decipher;
    exports2.createDecipher = aes.createDecipher;
    exports2.Decipheriv = aes.Decipheriv;
    exports2.createDecipheriv = aes.createDecipheriv;
    exports2.getCiphers = aes.getCiphers;
    exports2.listCiphers = aes.listCiphers;
    var dh = require_diffie_hellman();
    exports2.DiffieHellmanGroup = dh.DiffieHellmanGroup;
    exports2.createDiffieHellmanGroup = dh.createDiffieHellmanGroup;
    exports2.getDiffieHellman = dh.getDiffieHellman;
    exports2.createDiffieHellman = dh.createDiffieHellman;
    exports2.DiffieHellman = dh.DiffieHellman;
    var sign = require_browserify_sign();
    exports2.createSign = sign.createSign;
    exports2.Sign = sign.Sign;
    exports2.createVerify = sign.createVerify;
    exports2.Verify = sign.Verify;
    exports2.createECDH = require_create_ecdh();
    var publicEncrypt = require_public_encrypt();
    exports2.publicEncrypt = publicEncrypt.publicEncrypt;
    exports2.privateEncrypt = publicEncrypt.privateEncrypt;
    exports2.publicDecrypt = publicEncrypt.publicDecrypt;
    exports2.privateDecrypt = publicEncrypt.privateDecrypt;
    var rf = require_randomfill();
    exports2.randomFill = rf.randomFill;
    exports2.randomFillSync = rf.randomFillSync;
    exports2.createCredentials = function() {
      throw new Error("sorry, createCredentials is not implemented yet\nwe accept pull requests\nhttps://github.com/browserify/crypto-browserify");
    };
    exports2.constants = {
      DH_CHECK_P_NOT_SAFE_PRIME: 2,
      DH_CHECK_P_NOT_PRIME: 1,
      DH_UNABLE_TO_CHECK_GENERATOR: 4,
      DH_NOT_SUITABLE_GENERATOR: 8,
      NPN_ENABLED: 1,
      ALPN_ENABLED: 1,
      RSA_PKCS1_PADDING: 1,
      RSA_SSLV23_PADDING: 2,
      RSA_NO_PADDING: 3,
      RSA_PKCS1_OAEP_PADDING: 4,
      RSA_X931_PADDING: 5,
      RSA_PKCS1_PSS_PADDING: 6,
      POINT_CONVERSION_COMPRESSED: 2,
      POINT_CONVERSION_UNCOMPRESSED: 4,
      POINT_CONVERSION_HYBRID: 6
    };
  }
});

// node_modules/crypto-js/core.js
var require_core = __commonJS({
  "node_modules/crypto-js/core.js"(exports2, module2) {
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    (function(root, factory) {
      if (typeof exports2 === "object") {
        module2.exports = exports2 = factory();
      } else if (typeof define === "function" && define.amd) {
        define([], factory);
      } else {
        root.CryptoJS = factory();
      }
    })(exports2, function() {
      var CryptoJS = CryptoJS || (function(Math2, undefined2) {
        var crypto2;
        if (typeof window !== "undefined" && window.crypto) {
          crypto2 = window.crypto;
        }
        if (typeof self !== "undefined" && self.crypto) {
          crypto2 = self.crypto;
        }
        if (typeof globalThis !== "undefined" && globalThis.crypto) {
          crypto2 = globalThis.crypto;
        }
        if (!crypto2 && typeof window !== "undefined" && window.msCrypto) {
          crypto2 = window.msCrypto;
        }
        if (!crypto2 && typeof global !== "undefined" && global.crypto) {
          crypto2 = global.crypto;
        }
        if (!crypto2 && typeof __require === "function") {
          try {
            crypto2 = require_crypto_browserify();
          } catch (err) {
          }
        }
        var cryptoSecureRandomInt = function() {
          if (crypto2) {
            if (typeof crypto2.getRandomValues === "function") {
              try {
                return crypto2.getRandomValues(new Uint32Array(1))[0];
              } catch (err) {
              }
            }
            if (typeof crypto2.randomBytes === "function") {
              try {
                return crypto2.randomBytes(4).readInt32LE();
              } catch (err) {
              }
            }
          }
          throw new Error("Native crypto module could not be used to get secure random number.");
        };
        var create = Object.create || /* @__PURE__ */ (function() {
          function F() {
          }
          return function(obj) {
            var subtype;
            F.prototype = obj;
            subtype = new F();
            F.prototype = null;
            return subtype;
          };
        })();
        var C = {};
        var C_lib = C.lib = {};
        var Base = C_lib.Base = /* @__PURE__ */ (function() {
          return {
            /**
             * Creates a new object that inherits from this object.
             *
             * @param {Object} overrides Properties to copy into the new object.
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         field: 'value',
             *
             *         method: function () {
             *         }
             *     });
             */
            extend: function(overrides) {
              var subtype = create(this);
              if (overrides) {
                subtype.mixIn(overrides);
              }
              if (!subtype.hasOwnProperty("init") || this.init === subtype.init) {
                subtype.init = function() {
                  subtype.$super.init.apply(this, arguments);
                };
              }
              subtype.init.prototype = subtype;
              subtype.$super = this;
              return subtype;
            },
            /**
             * Extends this object and runs the init method.
             * Arguments to create() will be passed to init().
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var instance = MyType.create();
             */
            create: function() {
              var instance = this.extend();
              instance.init.apply(instance, arguments);
              return instance;
            },
            /**
             * Initializes a newly created object.
             * Override this method to add some logic when your objects are created.
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         init: function () {
             *             // ...
             *         }
             *     });
             */
            init: function() {
            },
            /**
             * Copies properties into this object.
             *
             * @param {Object} properties The properties to mix in.
             *
             * @example
             *
             *     MyType.mixIn({
             *         field: 'value'
             *     });
             */
            mixIn: function(properties) {
              for (var propertyName in properties) {
                if (properties.hasOwnProperty(propertyName)) {
                  this[propertyName] = properties[propertyName];
                }
              }
              if (properties.hasOwnProperty("toString")) {
                this.toString = properties.toString;
              }
            },
            /**
             * Creates a copy of this object.
             *
             * @return {Object} The clone.
             *
             * @example
             *
             *     var clone = instance.clone();
             */
            clone: function() {
              return this.init.prototype.extend(this);
            }
          };
        })();
        var WordArray = C_lib.WordArray = Base.extend({
          /**
           * Initializes a newly created word array.
           *
           * @param {Array} words (Optional) An array of 32-bit words.
           * @param {number} sigBytes (Optional) The number of significant bytes in the words.
           *
           * @example
           *
           *     var wordArray = CryptoJS.lib.WordArray.create();
           *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
           *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
           */
          init: function(words, sigBytes) {
            words = this.words = words || [];
            if (sigBytes != undefined2) {
              this.sigBytes = sigBytes;
            } else {
              this.sigBytes = words.length * 4;
            }
          },
          /**
           * Converts this word array to a string.
           *
           * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
           *
           * @return {string} The stringified word array.
           *
           * @example
           *
           *     var string = wordArray + '';
           *     var string = wordArray.toString();
           *     var string = wordArray.toString(CryptoJS.enc.Utf8);
           */
          toString: function(encoder) {
            return (encoder || Hex).stringify(this);
          },
          /**
           * Concatenates a word array to this word array.
           *
           * @param {WordArray} wordArray The word array to append.
           *
           * @return {WordArray} This word array.
           *
           * @example
           *
           *     wordArray1.concat(wordArray2);
           */
          concat: function(wordArray) {
            var thisWords = this.words;
            var thatWords = wordArray.words;
            var thisSigBytes = this.sigBytes;
            var thatSigBytes = wordArray.sigBytes;
            this.clamp();
            if (thisSigBytes % 4) {
              for (var i = 0; i < thatSigBytes; i++) {
                var thatByte = thatWords[i >>> 2] >>> 24 - i % 4 * 8 & 255;
                thisWords[thisSigBytes + i >>> 2] |= thatByte << 24 - (thisSigBytes + i) % 4 * 8;
              }
            } else {
              for (var j = 0; j < thatSigBytes; j += 4) {
                thisWords[thisSigBytes + j >>> 2] = thatWords[j >>> 2];
              }
            }
            this.sigBytes += thatSigBytes;
            return this;
          },
          /**
           * Removes insignificant bits.
           *
           * @example
           *
           *     wordArray.clamp();
           */
          clamp: function() {
            var words = this.words;
            var sigBytes = this.sigBytes;
            words[sigBytes >>> 2] &= 4294967295 << 32 - sigBytes % 4 * 8;
            words.length = Math2.ceil(sigBytes / 4);
          },
          /**
           * Creates a copy of this word array.
           *
           * @return {WordArray} The clone.
           *
           * @example
           *
           *     var clone = wordArray.clone();
           */
          clone: function() {
            var clone = Base.clone.call(this);
            clone.words = this.words.slice(0);
            return clone;
          },
          /**
           * Creates a word array filled with random bytes.
           *
           * @param {number} nBytes The number of random bytes to generate.
           *
           * @return {WordArray} The random word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.lib.WordArray.random(16);
           */
          random: function(nBytes) {
            var words = [];
            for (var i = 0; i < nBytes; i += 4) {
              words.push(cryptoSecureRandomInt());
            }
            return new WordArray.init(words, nBytes);
          }
        });
        var C_enc = C.enc = {};
        var Hex = C_enc.Hex = {
          /**
           * Converts a word array to a hex string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The hex string.
           *
           * @static
           *
           * @example
           *
           *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var hexChars = [];
            for (var i = 0; i < sigBytes; i++) {
              var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
              hexChars.push((bite >>> 4).toString(16));
              hexChars.push((bite & 15).toString(16));
            }
            return hexChars.join("");
          },
          /**
           * Converts a hex string to a word array.
           *
           * @param {string} hexStr The hex string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
           */
          parse: function(hexStr) {
            var hexStrLength = hexStr.length;
            var words = [];
            for (var i = 0; i < hexStrLength; i += 2) {
              words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << 24 - i % 8 * 4;
            }
            return new WordArray.init(words, hexStrLength / 2);
          }
        };
        var Latin1 = C_enc.Latin1 = {
          /**
           * Converts a word array to a Latin1 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The Latin1 string.
           *
           * @static
           *
           * @example
           *
           *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var latin1Chars = [];
            for (var i = 0; i < sigBytes; i++) {
              var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
              latin1Chars.push(String.fromCharCode(bite));
            }
            return latin1Chars.join("");
          },
          /**
           * Converts a Latin1 string to a word array.
           *
           * @param {string} latin1Str The Latin1 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
           */
          parse: function(latin1Str) {
            var latin1StrLength = latin1Str.length;
            var words = [];
            for (var i = 0; i < latin1StrLength; i++) {
              words[i >>> 2] |= (latin1Str.charCodeAt(i) & 255) << 24 - i % 4 * 8;
            }
            return new WordArray.init(words, latin1StrLength);
          }
        };
        var Utf8 = C_enc.Utf8 = {
          /**
           * Converts a word array to a UTF-8 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The UTF-8 string.
           *
           * @static
           *
           * @example
           *
           *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
           */
          stringify: function(wordArray) {
            try {
              return decodeURIComponent(escape(Latin1.stringify(wordArray)));
            } catch (e) {
              throw new Error("Malformed UTF-8 data");
            }
          },
          /**
           * Converts a UTF-8 string to a word array.
           *
           * @param {string} utf8Str The UTF-8 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
           */
          parse: function(utf8Str) {
            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
          }
        };
        var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
          /**
           * Resets this block algorithm's data buffer to its initial state.
           *
           * @example
           *
           *     bufferedBlockAlgorithm.reset();
           */
          reset: function() {
            this._data = new WordArray.init();
            this._nDataBytes = 0;
          },
          /**
           * Adds new data to this block algorithm's buffer.
           *
           * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
           *
           * @example
           *
           *     bufferedBlockAlgorithm._append('data');
           *     bufferedBlockAlgorithm._append(wordArray);
           */
          _append: function(data) {
            if (typeof data == "string") {
              data = Utf8.parse(data);
            }
            this._data.concat(data);
            this._nDataBytes += data.sigBytes;
          },
          /**
           * Processes available data blocks.
           *
           * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
           *
           * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
           *
           * @return {WordArray} The processed data.
           *
           * @example
           *
           *     var processedData = bufferedBlockAlgorithm._process();
           *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
           */
          _process: function(doFlush) {
            var processedWords;
            var data = this._data;
            var dataWords = data.words;
            var dataSigBytes = data.sigBytes;
            var blockSize = this.blockSize;
            var blockSizeBytes = blockSize * 4;
            var nBlocksReady = dataSigBytes / blockSizeBytes;
            if (doFlush) {
              nBlocksReady = Math2.ceil(nBlocksReady);
            } else {
              nBlocksReady = Math2.max((nBlocksReady | 0) - this._minBufferSize, 0);
            }
            var nWordsReady = nBlocksReady * blockSize;
            var nBytesReady = Math2.min(nWordsReady * 4, dataSigBytes);
            if (nWordsReady) {
              for (var offset = 0; offset < nWordsReady; offset += blockSize) {
                this._doProcessBlock(dataWords, offset);
              }
              processedWords = dataWords.splice(0, nWordsReady);
              data.sigBytes -= nBytesReady;
            }
            return new WordArray.init(processedWords, nBytesReady);
          },
          /**
           * Creates a copy of this object.
           *
           * @return {Object} The clone.
           *
           * @example
           *
           *     var clone = bufferedBlockAlgorithm.clone();
           */
          clone: function() {
            var clone = Base.clone.call(this);
            clone._data = this._data.clone();
            return clone;
          },
          _minBufferSize: 0
        });
        var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
          /**
           * Configuration options.
           */
          cfg: Base.extend(),
          /**
           * Initializes a newly created hasher.
           *
           * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
           *
           * @example
           *
           *     var hasher = CryptoJS.algo.SHA256.create();
           */
          init: function(cfg) {
            this.cfg = this.cfg.extend(cfg);
            this.reset();
          },
          /**
           * Resets this hasher to its initial state.
           *
           * @example
           *
           *     hasher.reset();
           */
          reset: function() {
            BufferedBlockAlgorithm.reset.call(this);
            this._doReset();
          },
          /**
           * Updates this hasher with a message.
           *
           * @param {WordArray|string} messageUpdate The message to append.
           *
           * @return {Hasher} This hasher.
           *
           * @example
           *
           *     hasher.update('message');
           *     hasher.update(wordArray);
           */
          update: function(messageUpdate) {
            this._append(messageUpdate);
            this._process();
            return this;
          },
          /**
           * Finalizes the hash computation.
           * Note that the finalize operation is effectively a destructive, read-once operation.
           *
           * @param {WordArray|string} messageUpdate (Optional) A final message update.
           *
           * @return {WordArray} The hash.
           *
           * @example
           *
           *     var hash = hasher.finalize();
           *     var hash = hasher.finalize('message');
           *     var hash = hasher.finalize(wordArray);
           */
          finalize: function(messageUpdate) {
            if (messageUpdate) {
              this._append(messageUpdate);
            }
            var hash = this._doFinalize();
            return hash;
          },
          blockSize: 512 / 32,
          /**
           * Creates a shortcut function to a hasher's object interface.
           *
           * @param {Hasher} hasher The hasher to create a helper for.
           *
           * @return {Function} The shortcut function.
           *
           * @static
           *
           * @example
           *
           *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
           */
          _createHelper: function(hasher) {
            return function(message, cfg) {
              return new hasher.init(cfg).finalize(message);
            };
          },
          /**
           * Creates a shortcut function to the HMAC's object interface.
           *
           * @param {Hasher} hasher The hasher to use in this HMAC helper.
           *
           * @return {Function} The shortcut function.
           *
           * @static
           *
           * @example
           *
           *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
           */
          _createHmacHelper: function(hasher) {
            return function(message, key) {
              return new C_algo.HMAC.init(hasher, key).finalize(message);
            };
          }
        });
        var C_algo = C.algo = {};
        return C;
      })(Math);
      return CryptoJS;
    });
  }
});

// node_modules/crypto-js/sha256.js
var require_sha2562 = __commonJS({
  "node_modules/crypto-js/sha256.js"(exports2, module2) {
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    (function(root, factory) {
      if (typeof exports2 === "object") {
        module2.exports = exports2 = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports2, function(CryptoJS) {
      (function(Math2) {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C.algo;
        var H = [];
        var K = [];
        (function() {
          function isPrime(n2) {
            var sqrtN = Math2.sqrt(n2);
            for (var factor = 2; factor <= sqrtN; factor++) {
              if (!(n2 % factor)) {
                return false;
              }
            }
            return true;
          }
          function getFractionalBits(n2) {
            return (n2 - (n2 | 0)) * 4294967296 | 0;
          }
          var n = 2;
          var nPrime = 0;
          while (nPrime < 64) {
            if (isPrime(n)) {
              if (nPrime < 8) {
                H[nPrime] = getFractionalBits(Math2.pow(n, 1 / 2));
              }
              K[nPrime] = getFractionalBits(Math2.pow(n, 1 / 3));
              nPrime++;
            }
            n++;
          }
        })();
        var W = [];
        var SHA256 = C_algo.SHA256 = Hasher.extend({
          _doReset: function() {
            this._hash = new WordArray.init(H.slice(0));
          },
          _doProcessBlock: function(M, offset) {
            var H2 = this._hash.words;
            var a = H2[0];
            var b = H2[1];
            var c = H2[2];
            var d = H2[3];
            var e = H2[4];
            var f = H2[5];
            var g = H2[6];
            var h = H2[7];
            for (var i = 0; i < 64; i++) {
              if (i < 16) {
                W[i] = M[offset + i] | 0;
              } else {
                var gamma0x = W[i - 15];
                var gamma0 = (gamma0x << 25 | gamma0x >>> 7) ^ (gamma0x << 14 | gamma0x >>> 18) ^ gamma0x >>> 3;
                var gamma1x = W[i - 2];
                var gamma1 = (gamma1x << 15 | gamma1x >>> 17) ^ (gamma1x << 13 | gamma1x >>> 19) ^ gamma1x >>> 10;
                W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];
              }
              var ch = e & f ^ ~e & g;
              var maj = a & b ^ a & c ^ b & c;
              var sigma0 = (a << 30 | a >>> 2) ^ (a << 19 | a >>> 13) ^ (a << 10 | a >>> 22);
              var sigma1 = (e << 26 | e >>> 6) ^ (e << 21 | e >>> 11) ^ (e << 7 | e >>> 25);
              var t1 = h + sigma1 + ch + K[i] + W[i];
              var t2 = sigma0 + maj;
              h = g;
              g = f;
              f = e;
              e = d + t1 | 0;
              d = c;
              c = b;
              b = a;
              a = t1 + t2 | 0;
            }
            H2[0] = H2[0] + a | 0;
            H2[1] = H2[1] + b | 0;
            H2[2] = H2[2] + c | 0;
            H2[3] = H2[3] + d | 0;
            H2[4] = H2[4] + e | 0;
            H2[5] = H2[5] + f | 0;
            H2[6] = H2[6] + g | 0;
            H2[7] = H2[7] + h | 0;
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math2.floor(nBitsTotal / 4294967296);
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;
            data.sigBytes = dataWords.length * 4;
            this._process();
            return this._hash;
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          }
        });
        C.SHA256 = Hasher._createHelper(SHA256);
        C.HmacSHA256 = Hasher._createHmacHelper(SHA256);
      })(Math);
      return CryptoJS.SHA256;
    });
  }
});

// node_modules/memoize-one/dist/memoize-one.esm.js
var memoize_one_esm_exports = {};
__export(memoize_one_esm_exports, {
  default: () => memoizeOne
});
function isEqual(first, second) {
  if (first === second) {
    return true;
  }
  if (safeIsNaN(first) && safeIsNaN(second)) {
    return true;
  }
  return false;
}
function areInputsEqual(newInputs, lastInputs) {
  if (newInputs.length !== lastInputs.length) {
    return false;
  }
  for (var i = 0; i < newInputs.length; i++) {
    if (!isEqual(newInputs[i], lastInputs[i])) {
      return false;
    }
  }
  return true;
}
function memoizeOne(resultFn, isEqual2) {
  if (isEqual2 === void 0) {
    isEqual2 = areInputsEqual;
  }
  var cache = null;
  function memoized() {
    var newArgs = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      newArgs[_i] = arguments[_i];
    }
    if (cache && cache.lastThis === this && isEqual2(newArgs, cache.lastArgs)) {
      return cache.lastResult;
    }
    var lastResult = resultFn.apply(this, newArgs);
    cache = {
      lastResult,
      lastArgs: newArgs,
      lastThis: this
    };
    return lastResult;
  }
  memoized.clear = function clear() {
    cache = null;
  };
  return memoized;
}
var import_dist, import_dist2, import_dist3, safeIsNaN;
var init_memoize_one_esm = __esm({
  "node_modules/memoize-one/dist/memoize-one.esm.js"() {
    import_dist = __toESM(require_dist());
    import_dist2 = __toESM(require_dist2());
    import_dist3 = __toESM(require_dist3());
    safeIsNaN = Number.isNaN || function ponyfill(value) {
      return typeof value === "number" && value !== value;
    };
  }
});

// node_modules/@splunk/visualization-schemas/node_modules/@splunk/visualization-color-palettes/index.js
var require_visualization_color_palettes = __commonJS({
  "node_modules/@splunk/visualization-schemas/node_modules/@splunk/visualization-color-palettes/index.js"(exports2, module2) {
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export2(src_exports, {
      CATEGORICAL: () => CATEGORICAL,
      ENTERPRISE_CATEGORICAL: () => ENTERPRISE_CATEGORICAL,
      SCP_CATEGORICAL: () => SCP_CATEGORICAL,
      VIZ_CATEGORICAL: () => VIZ_CATEGORICAL
    });
    module2.exports = __toCommonJS2(src_exports);
    var SCP_CATEGORICAL = [
      "#A9F5E7",
      "#A870EF",
      "#1E6271",
      "#45D4BA",
      "#602CA1",
      "#9AE6F7",
      "#6CD0F0",
      "#2F8AA7",
      "#422879",
      "#F29BAC",
      "#E85B79",
      "#C6335F",
      "#FDAF93",
      "#FB865C",
      "#E9643A",
      "#7EEFDA",
      "#26AA92",
      "#207865",
      "#C093F9",
      "#8747DA",
      "#4EB2D2",
      "#912344",
      "#AD3F20",
      "#D44C20",
      "#FFC34E",
      "#95651D",
      "#C0891E",
      "#ECAE11",
      "#FCD9A4",
      "#78062A"
    ];
    var ENTERPRISE_CATEGORICAL = ["#1E93C6", "#F2B827", "#D6563C", "#6A5C9E", "#31A35F"];
    var CATEGORICAL = [
      "#7B56DB",
      "#0089CF",
      "#00CDAF",
      "#DD9900",
      "#FF677B",
      "#CB2196",
      "#813193",
      "#0051B5",
      "#008C80",
      "#99B100",
      "#FFA476",
      "#FF6ACE",
      "#AE8CFF",
      "#00689D",
      "#00490A",
      "#465D00",
      "#9D6300",
      "#F6540B",
      "#FF969E",
      "#E47BFE"
    ];
    var VIZ_CATEGORICAL = [
      "#7B56DB",
      "#009CEB",
      "#00CDAF",
      "#DD9900",
      "#FF677B",
      "#CB2196",
      "#813193",
      "#0051B5",
      "#008C80",
      "#99B100",
      "#FFA476",
      "#FF6ACE",
      "#AE8CFF",
      "#00689D",
      "#00490A",
      "#465D00",
      "#9D6300",
      "#F6540B",
      "#FF969E",
      "#E47BFE"
    ];
  }
});

// node_modules/@splunk/visualization-schemas/dist/cjs/index.js
var require_cjs = __commonJS({
  "node_modules/@splunk/visualization-schemas/dist/cjs/index.js"(exports2, module2) {
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var __create = Object.create;
    var __defProp = Object.defineProperty;
    var __defProps = Object.defineProperties;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __getOwnPropSymbols = Object.getOwnPropertySymbols;
    var __getProtoOf = Object.getPrototypeOf;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __propIsEnum = Object.prototype.propertyIsEnumerable;
    var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
    var __spreadValues = (a, b) => {
      for (var prop in b || (b = {}))
        if (__hasOwnProp.call(b, prop))
          __defNormalProp(a, prop, b[prop]);
      if (__getOwnPropSymbols)
        for (var prop of __getOwnPropSymbols(b)) {
          if (__propIsEnum.call(b, prop))
            __defNormalProp(a, prop, b[prop]);
        }
      return a;
    };
    var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
    var __objRest = (source, exclude) => {
      var target = {};
      for (var prop in source)
        if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
          target[prop] = source[prop];
      if (source != null && __getOwnPropSymbols)
        for (var prop of __getOwnPropSymbols(source)) {
          if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
            target[prop] = source[prop];
        }
      return target;
    };
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
    var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
      // If the importer is in node compatibility mode or this is not an ESM
      // file that has been converted to a CommonJS file using a Babel-
      // compatible transform (i.e. "__esModule" has not been set), then set
      // "default" to the CommonJS "module.exports" for node compatibility.
      isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
      mod
    ));
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export2(src_exports, {
      COLOR_OR_TOKEN_PATTERN: () => COLOR_OR_TOKEN_PATTERN,
      COLOR_OR_TOKEN_PATTERN_WITH_RGBA: () => COLOR_OR_TOKEN_PATTERN_WITH_RGBA,
      DYNAMIC_OPTIONS_DSL_PATTERN: () => DYNAMIC_OPTIONS_DSL_PATTERN,
      LAYER_TYPE: () => LAYER_TYPE,
      LAYOUT_TYPE: () => LAYOUT_TYPE,
      SchemaUtils: () => schemaUtils_exports,
      TOKEN_PATTERN: () => TOKEN_PATTERN,
      areaOptionsSchema: () => areaOptionsSchema,
      barOptionsSchema: () => barOptionsSchema,
      bubbleOptionsSchema: () => bubbleOptionsSchema,
      choroplethSvgOptionsSchema: () => choroplethSvgOptionsSchema,
      colorPattern: () => colorPattern,
      colorPatternWithRGBA: () => colorPatternWithRGBA,
      columnOptionsSchema: () => columnOptionsSchema,
      createTestSchema: () => createTestSchema,
      ellipseOptionsSchema: () => ellipseOptionsSchema,
      enhanceOptionsSchemaWithDynamicOptions: () => enhanceOptionsSchemaWithDynamicOptions,
      eventsOptionsSchema: () => eventsOptionsSchema,
      fillerGaugeOptionsSchema: () => fillerGaugeOptionsSchema,
      getPattern: () => getPattern,
      imageOptionsSchema: () => imageOptionsSchema,
      lineOptionsSchema: () => lineOptionsSchema,
      linkGraphOptionsSchema: () => linkGraphOptionsSchema,
      mapOptionsSchema: () => mapOptionsSchema,
      markdownOptionsSchema: () => markdownOptionsSchema,
      markerGaugeOptionsSchema: () => markerGaugeOptionsSchema,
      parallelCoordinatesOptionsSchema: () => parallelCoordinatesOptionsSchema,
      pieOptionsSchema: () => pieOptionsSchema,
      punchcardOptionsSchema: () => punchcardOptionsSchema,
      rectangleOptionsSchema: () => rectangleOptionsSchema,
      rgbColorPattern: () => rgbColorPattern,
      rgbaColorPattern: () => rgbaColorPattern,
      sankeyOptionsSchema: () => sankeyOptionsSchema,
      scatterOptionsSchema: () => scatterOptionsSchema,
      schemaDraft07: () => schemaDraft07,
      singleValueIconOptionsSchema: () => singleValueIconOptionsSchema,
      singleValueOptionsSchema: () => singleValueOptionsSchema,
      singleValueRadialOptionsSchema: () => singleValueRadialOptionsSchema,
      tableOptionsSchema: () => tableOptionsSchema,
      timelineOptionsSchema: () => timelineOptionsSchema,
      validAlignments: () => validAlignments,
      validCellRenderers: () => validCellRenderers,
      validColumnAlignments: () => validColumnAlignments,
      validFontSizes: () => validFontSizes,
      validHeaderVisibilities: () => validHeaderVisibilities,
      validSegmentationModes: () => validSegmentationModes,
      validSparklineTypes: () => validSparklineTypes,
      validTextOverflows: () => validTextOverflows
    });
    module2.exports = __toCommonJS2(src_exports);
    var visualization_color_palettes_exports = {};
    __export2(visualization_color_palettes_exports, {
      default: () => visualization_color_palettes_default
    });
    var defaultImport = __toESM2(require_visualization_color_palettes());
    __reExport(visualization_color_palettes_exports, require_visualization_color_palettes());
    var visualization_color_palettes_default = "default" in defaultImport ? defaultImport.default : defaultImport;
    var validSegmentationModes = ["none", "inner"];
    var LAYER_TYPE = ((LAYER_TYPE2) => {
      LAYER_TYPE2["Marker"] = "marker";
      LAYER_TYPE2["Bubble"] = "bubble";
      LAYER_TYPE2["Choropleth"] = "choropleth";
      return LAYER_TYPE2;
    })(LAYER_TYPE || {});
    var LAYOUT_TYPE = ((LAYOUT_TYPE2) => {
      LAYOUT_TYPE2["Off"] = "off";
      LAYOUT_TYPE2["Trellis"] = "trellis";
      return LAYOUT_TYPE2;
    })(LAYOUT_TYPE || {});
    var validCellRenderers = ["TextCell", "ArrayCell", "SparklineCell"];
    var validSparklineTypes = ["line", "area"];
    var validHeaderVisibilities = ["none", "fixed", "inline"];
    var validAlignments = ["left", "center", "right"];
    var validColumnAlignments = ["left", "center", "right", "auto"];
    var validTextOverflows = ["anywhere", "break-word", "ellipsis"];
    var validFontSizes = ["extraSmall", "small", "default", "large"];
    var schemaUtils_exports = {};
    __export2(schemaUtils_exports, {
      COLOR_OR_TOKEN_PATTERN: () => COLOR_OR_TOKEN_PATTERN,
      COLOR_OR_TOKEN_PATTERN_WITH_RGBA: () => COLOR_OR_TOKEN_PATTERN_WITH_RGBA,
      DYNAMIC_OPTIONS_DSL_PATTERN: () => DYNAMIC_OPTIONS_DSL_PATTERN,
      TOKEN_PATTERN: () => TOKEN_PATTERN,
      colorPattern: () => colorPattern,
      colorPatternWithRGBA: () => colorPatternWithRGBA,
      createTestSchema: () => createTestSchema,
      getPattern: () => getPattern,
      rgbColorPattern: () => rgbColorPattern,
      rgbaColorPattern: () => rgbaColorPattern,
      schemaDraft07: () => schemaDraft07
    });
    var schemaDraft07 = {
      $schema: "http://json-schema.org/draft-07/schema#",
      $id: "http://json-schema.org/draft-07/schema#",
      title: "Core schema meta-schema",
      definitions: {
        schemaArray: {
          type: "array",
          minItems: 1,
          items: { $ref: "#" }
        },
        nonNegativeInteger: {
          type: "integer",
          minimum: 0
        },
        nonNegativeIntegerDefault0: {
          allOf: [{ $ref: "#/definitions/nonNegativeInteger" }, { default: 0 }]
        },
        simpleTypes: {
          enum: ["array", "boolean", "integer", "null", "number", "object", "string"]
        },
        stringArray: {
          type: "array",
          items: { type: "string" },
          uniqueItems: true,
          default: []
        }
      },
      type: ["object", "boolean"],
      properties: {
        $id: {
          type: "string",
          format: "uri-reference"
        },
        $schema: {
          type: "string",
          format: "uri"
        },
        $ref: {
          type: "string",
          format: "uri-reference"
        },
        $comment: {
          type: "string"
        },
        title: {
          type: "string"
        },
        description: {
          type: "string"
        },
        default: true,
        readOnly: {
          type: "boolean",
          default: false
        },
        examples: {
          type: "array",
          items: true
        },
        multipleOf: {
          type: "number",
          exclusiveMinimum: 0
        },
        maximum: {
          type: "number"
        },
        exclusiveMaximum: {
          type: "number"
        },
        minimum: {
          type: "number"
        },
        exclusiveMinimum: {
          type: "number"
        },
        maxLength: { $ref: "#/definitions/nonNegativeInteger" },
        minLength: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        pattern: {
          type: "string",
          format: "regex"
        },
        additionalItems: { $ref: "#" },
        items: {
          anyOf: [{ $ref: "#" }, { $ref: "#/definitions/schemaArray" }],
          default: true
        },
        maxItems: { $ref: "#/definitions/nonNegativeInteger" },
        minItems: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        uniqueItems: {
          type: "boolean",
          default: false
        },
        contains: { $ref: "#" },
        maxProperties: { $ref: "#/definitions/nonNegativeInteger" },
        minProperties: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        required: { $ref: "#/definitions/stringArray" },
        additionalProperties: { $ref: "#" },
        definitions: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {}
        },
        properties: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {}
        },
        patternProperties: {
          type: "object",
          additionalProperties: { $ref: "#" },
          propertyNames: { format: "regex" },
          default: {}
        },
        dependencies: {
          type: "object",
          additionalProperties: {
            anyOf: [{ $ref: "#" }, { $ref: "#/definitions/stringArray" }]
          }
        },
        propertyNames: { $ref: "#" },
        const: true,
        enum: {
          type: "array",
          items: true,
          minItems: 1,
          uniqueItems: true
        },
        type: {
          anyOf: [
            { $ref: "#/definitions/simpleTypes" },
            {
              type: "array",
              items: { $ref: "#/definitions/simpleTypes" },
              minItems: 1,
              uniqueItems: true
            }
          ]
        },
        format: { type: "string" },
        contentMediaType: { type: "string" },
        contentEncoding: { type: "string" },
        if: { $ref: "#" },
        then: { $ref: "#" },
        else: { $ref: "#" },
        allOf: { $ref: "#/definitions/schemaArray" },
        anyOf: { $ref: "#/definitions/schemaArray" },
        oneOf: { $ref: "#/definitions/schemaArray" },
        not: { $ref: "#" }
      },
      default: true
    };
    var createTestSchema = (optionsSchema) => ({
      $schema: "http://json-schema.org/draft-07/schema#",
      $id: "http://www.splunk.com/dashboard.schema.json",
      title: "Dashboard Definition",
      description: "Dashboard Definition",
      type: "object",
      properties: optionsSchema
    });
    var TOKEN_NAMESPACE_PREFIX_PATTERN = /(\w+:)?/.source;
    var TOKEN_NAME_CHARS_PATTERN = /([^$|:]+?)(\|[|\w]+)?/.source;
    var TOKEN_PATTERN = /\$/.source + TOKEN_NAMESPACE_PREFIX_PATTERN + TOKEN_NAME_CHARS_PATTERN + /\$/.source;
    var rgbColorPattern = /^rgb\(\s*(\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/;
    var rgbaColorPattern = /^rgba\(\s*(\d{1,3}%?),\s*(\d{1,3}%?),\s*(\d{1,3}%?),\s*(\d*(?:\.\d+)?)\)$/;
    var colorPattern = "^#(?:[0-9a-fA-F]{3,4}|[0-9a-fA-F]{6}|[0-9a-fA-F]{8})$|^transparent$";
    var colorPatternWithRGBA = `${colorPattern}|${rgbColorPattern.source}|${rgbaColorPattern.source}`;
    var COLOR_OR_TOKEN_PATTERN = `${colorPattern}|${TOKEN_PATTERN}`;
    var COLOR_OR_TOKEN_PATTERN_WITH_RGBA = `${colorPatternWithRGBA}|${TOKEN_PATTERN}`;
    var DYNAMIC_OPTIONS_DSL_PATTERN = /^>.*/.source;
    var getPattern = (values) => values.reduce((accumulator, value) => `${accumulator}|^${value}$`, TOKEN_PATTERN);
    var dynamicOptionsDSLType = {
      type: "string",
      pattern: DYNAMIC_OPTIONS_DSL_PATTERN
    };
    var enhanceOptionsSchemaWithDynamicOptions = (optionsSchema) => {
      const enhancedOptionsSchema = {};
      Object.keys(optionsSchema).forEach((key) => {
        const _a = optionsSchema[key], {
          title,
          description,
          readOnly,
          writeOnly,
          examples,
          default: defaultValue,
          type,
          properties,
          patternProperties
        } = _a, remainingSchemaEntry = __objRest(_a, [
          // The next a few are schema annotations, we should leave them as is.
          // Note: in reality we don't use `readOnly`, `writeOnly` or `examples`, but they are listed here for completeness.
          // Ref: https://datatracker.ietf.org/doc/html/draft-handrews-json-schema-validation-01
          "title",
          "description",
          "readOnly",
          "writeOnly",
          "examples",
          "default",
          // The next a few need special care
          "type",
          "properties",
          "patternProperties"
        ]);
        const annotations = __spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({}, title !== void 0 && { title }), description !== void 0 && { description }), readOnly !== void 0 && { readOnly }), writeOnly !== void 0 && { writeOnly }), examples !== void 0 && { examples }), defaultValue !== void 0 && { default: defaultValue });
        if (type === "object") {
          enhancedOptionsSchema[key] = __spreadValues(__spreadProps(__spreadValues(__spreadValues({}, remainingSchemaEntry), annotations), {
            type
          }), properties && {
            properties: enhanceOptionsSchemaWithDynamicOptions(properties)
          });
          if (patternProperties) {
            let enhancedPatternProperties = {};
            Object.keys(patternProperties).forEach((opt) => {
              enhancedPatternProperties = __spreadValues(__spreadValues({}, enhancedPatternProperties), enhanceOptionsSchemaWithDynamicOptions({
                [opt]: patternProperties[opt]
              }));
            });
            enhancedOptionsSchema[key].patternProperties = enhancedPatternProperties;
          }
        } else {
          enhancedOptionsSchema[key] = __spreadProps(__spreadValues({}, annotations), {
            anyOf: [
              // we can't assume `type` is always there because there are `enum` and `const`.
              __spreadValues(__spreadValues({}, type !== void 0 && { type }), remainingSchemaEntry),
              dynamicOptionsDSLType
            ]
          });
        }
      });
      return enhancedOptionsSchema;
    };
    var areaOptionsSchema = enhanceOptionsSchemaWithDynamicOptions({
      x: {
        default: "> primary | seriesByIndex(0)",
        description: "Specify the data source to apply to the x-axis.",
        type: "array",
        items: { type: ["string", "number"] }
      },
      y: {
        default: "> primary | frameBySeriesIndexRange(1)",
        description: "Specify the data source to apply to the y-axis.",
        type: "array",
        items: { type: ["string", "number"] }
      },
      y2: {
        description: "Specify the data source to apply to the second y-axis",
        type: "array",
        items: { type: ["string", "number"] }
      },
      xField: {
        default: "> x | getField()",
        description: "Specify the field to map to the x-axis.",
        type: "string"
      },
      yFields: {
        default: "> y | getField()",
        description: "Specify the field to map to the y-axis.",
        type: "string"
      },
      additionalTooltipFields: {
        default: [],
        description: "Specify the fields to add to the default set of tooltips. Tooltips appear when you hover over events. These fields and their corresponding values are shown in addition to the ones displayed by default.",
        type: "array",
        items: { type: "string" }
      },
      annotationColor: {
        description: `Specify the annotation colors. For example, [“#FF0000”, “#0000FF", “#008000”]. You can use a data source or a hexadecimal code to apply the color.`,
        type: "array",
        items: { type: "string" }
      },
      annotationLabel: {
        description: `Specify a list of labels to use for annotations. For example, [“Sales”, “Revenue”, “Orders”]. You might use a data source to apply the labels.`,
        type: "array",
        items: { type: "string" }
      },
      annotationX: {
        description: "Specify a data source field to apply to the event annotation on the x-axis.",
        type: "array",
        items: { type: ["string", "number"] }
      },
      areaOpacity: {
        description: "Specify the opacity of the area chart. Values can range from 0 (transparent) to 1 (opaque).",
        type: "number",
        default: 0.75
      },
      backgroundColor: {
        default: "> themes.defaultBackgroundColor",
        description: "Specify the color to use for the background. You can use a data source or hexadecimal code to apply the color.",
        pattern: COLOR_OR_TOKEN_PATTERN_WITH_RGBA,
        type: "string"
      },
      dataValuesDisplay: {
        description: 'Specify the labels to display. Enter "all" to show labels for all data points, "off" to show no labels, or "minmax" to show high and low values.',
        type: "string",
        pattern: getPattern(["off", "all", "minmax"]),
        default: "off"
      },
      legendDisplay: {
        description: "Specify the location of the legend on the panel. By default, legendDisplay is off when splitByLayout is trellis, and right otherwise. You must select the Standard legend mode to make this change.",
        pattern: getPattern(["right", "left", "top", "bottom", "off"]),
        type: "string"
      },
      legendLabels: {
        description: `Specify a list of labels to populate the legend in advance. For example, ["percent", "count"].`,
        type: "array",
        items: { type: "string" }
      },
      legendMode: {
        default: "standard",
        description: 'Specify visual and behavioral settings for the tooltip and legend. "seriesCompare" is useful when comparing series.',
        pattern: getPattern(["standard", "seriesCompare"]),
        type: "string"
      },
      legendTruncation: {
        default: "ellipsisEnd",
        description: "Specify how to display legend labels when they overflow the layout boundaries by replacing overflow text with an ellipsis.",
        pattern: getPattern(["ellipsisEnd", "ellipsisMiddle", "ellipsisStart", "ellipsisOff"]),
        type: "string"
      },
      lineDashStyle: {
        default: "solid",
        description: "Specify a dash style for all overlay field lines.",
        pattern: getPattern([
          "solid",
          "shortDash",
          "shortDot",
          "shortDashDot",
          "shortDashDotDot",
          "dot",
          "dash",
          "longDash",
          "dashDot",
          "longDashDot",
          "longDashDotDot"
        ]),
        type: "string"
      },
      lineDashStylesByField: {
        description: `Specify a dash style to use for overlay lines for each field. For example, {"count": "longDashDot", "percent": "longDashDotDot"}.
        Valid values: "solid", "shortDash", "shortDot", "shortDashDot", "shortDashDotDot", "dot", "dash",
        "longDash", "dashDot", "longDashDot", "longDashDotDot".`,
        type: "object"
      },
      lineWidth: {
        default: 2,
        description: "Specify the line width (px) for overlay field lines.",
        type: "number"
      },
      nullValueDisplay: {
        default: "gaps",
        description: "Specify the handling of null values for area and line charts .",
        pattern: getPattern(["gaps", "zero", "connect"]),
        type: "string"
      },
      resultLimit: {
        default: 5e4,
        description: "Specify the number of data points to render in a chart.",
        type: "number"
      },
      seriesColors: {
        default: visualization_color_palettes_exports.VIZ_CATEGORICAL,
        description: `Specify the colors to use in a series. For example, ["#FF0000", "#0000FF", "#008000"].`,
        type: "array",
        items: { type: "string" }
      },
      seriesColorsByField: {
        description: `Specify the colors to use for specific fields in a series. For example, {“count”: “#008000”, “percent”: “#FFA500”}.`,
        type: "object"
      },
      splitByLayout: {
        default: "off",
        description: "Specify the layout method by which to display the visualization, which splits the data into individual visualizations based on a certain category.",
        type: "string",
        pattern: getPattern([
          "off",
          "trellis"
          /* Trellis */
        ]),
        enum: [
          "off",
          "trellis"
          /* Trellis */
        ]
      },
      stackMode: {
        description: "Specify stack mode.",
        type: "string",
        pattern: getPattern(["auto", "stacked", "stacked100"]),
        default: "auto"
      },
      showIndependentYRanges: {
        description: "Specify whether split series charts have independent y-ranges.",
        type: "boolean",
        default: false
      },
      showSplitSeries: {
        description: "Specify whether to split a multi-series chart into separate charts that are stacked from top to bottom; use one chart for each series.",
        type: "boolean",
        default: false
      },
      showLines: {
        description: "Specify whether to show lines in area charts.",
        default: true,
        type: "boolean"
      },
      showXMajorGridLines: {
        description: "Specify whether to show major grid lines on the x-axis.",
        type: "boolean",
        default: false
      },
      showYMajorGridLines: {
        description: "Specify whether to show major grid lines on the y-axis.",
        type: "boolean",
        default: true
      },
      showY2MajorGridLines: {
        description: "Specify whether to show major grid lines on the second y-axis.",
        type: "boolean",
        default: false
      },
      showYMinorGridLines: {
        description: "Specify whether to show minor grid lines on the y-axis.",
        type: "boolean",
        default: false
      },
      showY2MinorGridLines: {
        description: "Specify whether to show minor grid lines on the second y-axis.",
        type: "boolean",
        default: false
      },
      showYAxisExtendedRange: {
        description: "Specify whether to extend the y-axis to include whole major tick marks.",
        type: "boolean",
        default: true
      },
      showYAxisWithZero: {
        description: "Specify whether to include zero in the y-axis range.",
        type: "boolean",
        default: false
      },
      showY2AxisWithZero: {
        description: "Specify whether to include zero in the second y-axis range.",
        type: "boolean",
        default: false
      },
      trellisBackgroundColor: {
        default: "> themes.defaultBackgroundColor",
        description: "Specify the color used for the trellis container background by using a hexadecimal code. For example, #0000FF.",
        pattern: COLOR_OR_TOKEN_PATTERN_WITH_RGBA,
        type: "string"
      },
      trellisColumns: {
        description: "Specify the number of visualizations to display in a given row of the trellis container. The remaining visualizations will wrap accordingly. If nothing is specified, it will be auto-set based on the trellisMinColumnWidth. The minimum value is 1.",
        type: "number",
        minimum: 1,
        default: 3
      },
      trellisMinColumnWidth: {
        default: 250,
        minimum: 1,
        description: "Specify the minimum width, in pixels, of each visualization in the trellis container. If the window or panel is resized, the remaining visualizations may be viewed by scrolling. The minimum value is 1.",
        type: "number"
      },
      trellisPageCount: {
        default: 20,
        minimum: 1,
        description: "Specify the maximum number of visualizations to display in a single page in the trellis container. The remaining visualizations will paginate accordingly. The minimum value is 1.",
        type: "number"
      },
      trellisRowHeight: {
        default: 180,
        minimum: 1,
        description: "Specify the height, in pixels, of each visualization in the trellis container. If the window or panel is resized, the remaining visualizations may be viewed by scrolling. The minimum value is 1.",
        type: "number"
      },
      trellisSharedScale: {
        default: true,
        type: "boolean",
        description: "Specify whether all visualizations will share the same scale in the trellis container."
      },
      trellisSplitBy: {
        description: "Specify the field name of the column with categories used, or “aggregations”, to split the data into individual visualizations for trellis display, if applicable. If a SPL `timechart` command is used, this may default to the SPL `by` clause field. If a SPL `chart` command is used, this may default to the first string field.",
        type: "string"
      },
      xAxisLabelRotation: {
        description: "Specify the rotation of the x-axis label in degrees.",
        enum: [-90, -45, 0, 45, 90],
        type: "number",
        default: 0
      },
      xAxisLabelVisibility: {
        default: "auto",
        description: "Specify whether to show labels on the x-axis.",
        pattern: getPattern(["auto", "show", "hide"]),
        type: "string"
      },
      yAxisLabelVisibility: {
        default: "auto",
        description: "Specify whether to show labels on the y-axis.",
        pattern: getPattern(["auto", "show", "hide"]),
        type: "string"
      },
      y2AxisLabelVisibility: {
        default: "auto",
        description: "Specify whether to show labels on the second y-axis.",
        pattern: getPattern(["auto", "show", "hide"]),
        type: "string"
      },
      xAxisLineVisibility: {
        default: "hide",
        description: "Specify whether to show the x-axis line.",
        enum: ["hide", "show"],
        pattern: getPattern(["show", "hide"]),
        type: "string"
      },
      yAxisLineVisibility: {
        default: "hide",
        description: "Specify whether to show the y-axis line.",
        enum: ["hide", "show"],
        pattern: getPattern(["show", "hide"]),
        type: "string"
      },
      y2AxisLineVisibility: {
        default: "hide",
        description: "Specify whether to show the second y-axis line.",
        enum: ["hide", "show"],
        pattern: getPattern(["show", "hide"]),
        type: "string"
      },
      xAxisMajorTickSize: {
        default: 6,
        description: "Specify the size (px) of major tick marks on the x-axis.",
        type: "number"
      },
      yAxisMajorTickSize: {
        default: 6,
        description: "Specify the size (px) of major tick marks on the y-axis.",
        type: "number"
      },
      y2AxisMajorTickSize: {
        default: 6,
        description: "Specify the size (px) of major tick marks on the second y-axis.",
        type: "number"
      },
      yAxisMinorTickSize: {
        default: 6,
        description: "Specify the size (px) of minor tick marks on the y-axis.",
        type: "number"
      },
      y2AxisMinorTickSize: {
        default: 6,
        description: "Specify the size (px) of minor tick marks on the second y-axis.",
        type: "number"
      },
      xAxisMajorTickVisibility: {
        default: "auto",
        description: "Specify whether to show major tick marks on the x-axis.",
        pattern: getPattern(["auto", "show", "hide"]),
        type: "string"
      },
      yAxisMajorTickVisibility: {
        default: "auto",
        description: "Specify whether to show major tick marks on the y-axis.",
        pattern: getPattern(["auto", "show", "hide"]),
        type: "string"
      },
      y2AxisMajorTickVisibility: {
        default: "auto",
        description: "Specify whether to show major tick marks on the second y-axis.",
        pattern: getPattern(["auto", "show", "hide"]),
        type: "string"
      },
      yAxisMinorTickVisibility: {
        default: "auto",
        description: "Specify whether to show minor tick marks on the y-axis.",
        pattern: getPattern(["auto", "show", "hide"]),
        type: "string"
      },
      y2AxisMinorTickVisibility: {
        default: "auto",
        description: "Specify whether to show minor tick marks on the second y-axis.",
        pattern: getPattern(["auto", "show", "hide"]),
        type: "string"
      },
      xAxisMaxLabelParts: {
        default: 3,
        minimum: 1,
        maximum: 3,
        description: "Specify the maximum number of time-parts for a tick label. The 3 possible parts are year, month, and time. Values can range from 1 to 3.",
        type: "number"
      },
      yAxisScale: {
        type: "string",
        pattern: getPattern(["linear", "log"]),
        description: "Specify the type of scale that applies to a numerical y-axis.",
        default: "linear"
      },
      y2AxisScale: {
        type: "string",
        pattern: getPattern(["linear", "log"]),
        description: "Specify the type of scale that applies to a numerical second y-axis.",
        default: "linear"
      },
      xAxisTitleText: {
        description: "Specify the title of the x-axis.",
        type: "string"
      },
      yAxisTitleText: {
        description: "Specify the title of the y-axis.",
        type: "string"
      },
      y2AxisTitleText: {
        description: "Specify the title of the second y-axis.",
        type: "string"
      },
      xAxisTitleVisibility: {
        default: "show",
        description: "Specify whether to show the title of the x-axis.",
        enum: ["hide", "show"],
        pattern: getPattern(["show", "hide"]),
        type: "string"
      },
      yAxisTitleVisibility: {
        default: "show",
        description: "Specify whether to show the title of the y-axis.",
        enum: ["hide", "show"],
        pattern: getPattern(["show", "hide"]),
        type: "string"
      },
      y2AxisTitleVisibility: {
        default: "show",
        description: "Specify whether to show the title of the second y-axis.",
        enum: ["hide", "show"],
        pattern: getPattern(["show", "hide"]),
        type: "string"
      },
      yAxisAbbreviation: {
        default: "auto",
        description: "Specify whether to abbreviate large y-axis values with the closest International System of Units (SI) prefix.",
        enum: ["auto", "off"],
        pattern: getPattern(["off", "auto"]),
        type: "string"
      },
      y2AxisAbbreviation: {
        default: "auto",
        description: "Specify whether to abbreviate large second y-axis values with the closest International System of Units (SI) prefix.",
        enum: ["auto", "off"],
        pattern: getPattern(["off", "auto"]),
        type: "string"
      },
      yAxisMajorTickInterval: {
        default: "auto",
        description: "Specify the spacing unit between major tick marks along the numeric y-axis.",
        type: ["string", "number"]
      },
      y2AxisMajorTickInterval: {
        default: "auto",
        description: "Specify the spacing unit between major tick marks along the numeric second y-axis.",
        type: ["string", "number"]
      },
      yAxisMax: {
        type: ["string", "number"],
        description: "Specify the largest value for the visible y-axis range.",
        default: "auto"
      },
      y2AxisMax: {
        type: ["string", "number"],
        description: "Specify the largest value for the visible second y-axis range.",
        default: "auto"
      },
      yAxisMin: {
        type: ["string", "number"],
        description: "Specify the smallest value for the visible y-axis range.",
        default: "auto"
      },
      y2AxisMin: {
        type: ["string", "number"],
        description: "Specify the smallest value for the visible second y-axis range.",
        default: "auto"
      },
      overlayFields: {
        description: "Specify one or more fields to differentiate on the chart and display as chart overlays.",
        type: ["array", "string"],
        items: {
          type: "string"
        }
      },
      showOverlayY2Axis: {
        default: false,
        description: "Enable a second y-axis for chart overlays. All overlay fields will map to a second y-axis.",
        type: "boolean"
      },
      showRoundedY2AxisLabels: {
        default: true,
        description: "Specify whether to round second y-axis values to the nearest integer.",
        type: "boolean"
      },
      y2Fields: {
        default: "> y2 | getField()",
        description: "Specify one or more fields to map to the second y-axis.",
        type: ["array", "string"],
        items: { type: "string" }
      }
    });
    var barOptionsSchema = enhanceOptionsSchemaWithDynamicOptions({
      x: {
        default: "> primary | seriesByIndex(0)",
        description: "Specify the data source to apply to the x-axis.",
        type: "array",
        items: { type: ["string", "number"] }
      },
      y: {
        default: "> primary | frameBySeriesIndexRange(1)",
        description: "Specify the data source to apply to the y-axis.",
        type: "array",
        items: { type: ["string", "number"] }
      },
      y2: {
        description: "Specify the data source to apply to the second y-axis",
        type: "array",
        items: { type: ["string", "number"] }
      },
      xField: {
        default: "> x | getField()",
        description: "Specify the field to map to the x-axis.",
        type: "string"
      },
      yFields: {
        default: "> y | getField()",
        description: "Specify the field to map to the y-axis.",
        type: "string"
      },
      y2Fields: {
        default: "> y2 | getField()",
        description: "Specify one or more fields to map to a second y-axis.",
        type: ["array", "string"],
        items: {
          type: "string"
        }
      },
      additionalTooltipFields: {
        default: [],
        description: "Specify the fields to add to the default set of tooltips. Tooltips appear when you hover over events. These fields and their corresponding values are shown in addition to the ones displayed by default.",
        type: "array",
        items: { type: "string" }
      },
      backgroundColor: {
        default: "> themes.defaultBackgroundColor",
        description: "Specify the color used for the background. You can use a data source or hexadecimal code to apply the color.",
        pattern: COLOR_OR_TOKEN_PATTERN_WITH_RGBA,
        type: "string"
      },
      barSpacing: {
        description: "Specify the spacing (px) between columns in a bar chart.",
        type: "number"
      },
      dataValuesDisplay: {
        default: "off",
        description: 'Specify the labels to display. Enter "all" to show lables for all data points, "off" to show no labels, or "minmax to show high and low values".',
        pattern: getPattern(["off", "all", "minmax"]),
        type: "string"
      },
      legendDisplay: {
        description: "Specify the location of the legend on the panel. By default, legendDisplay is off when splitByLayout is trellis, and right otherwise. ",
        pattern: getPattern(["right", "left", "top", "bottom", "off"]),
        type: "string"
      },
      legendLabels: {
        description: 'Specify a list of labels to populate the legend in advance. For example, ["percent", "count"].',
        type: "array",
        items: { type: "string" }
      },
      legendMode: {
        default: "standard",
        description: 'Specify visual and behavioral settings for the tooltip and legend. "seriesCompare" is useful when comparing series.',
        pattern: getPattern(["standard", "seriesCompare"]),
        type: "string"
      },
      legendReversed: {
        default: "false",
        description: "Specify whether to reverse the order of the legend items.",
        type: "boolean"
      },
      legendTruncation: {
        default: "ellipsisEnd",
        description: "Specify how to display legend labels when they overflow the layout boundaries by replacing overflow text with an ellipsis.",
        pattern: getPattern(["ellipsisEnd", "ellipsisMiddle", "ellipsisStart", "ellipsisOff"]),
        type: "string"
      },
      lineDashStyle: {
        default: "solid",
        description: "Specify a dash style for all overlay field lines.",
        pattern: getPattern([
          "solid",
          "shortDash",
          "shortDot",
          "shortDashDot",
          "shortDashDotDot",
          "dot",
          "dash",
          "longDash",
          "dashDot",
          "longDashDot",
          "longDashDotDot"
        ]),
        type: "string"
      },
      lineDashStylesByField: {
        description: `Specify a dash style to use for overlay lines for each field. For example, {"count": "longDashDot", "percent": "longDashDotDot"}.
        Valid values: "solid", "shortDash", "shortDot", "shortDashDot", "shortDashDotDot", "dot", "dash",
        "longDash", "dashDot", "longDashDot", "longDashDotDot".`,
        type: "object"
      },
      lineWidth: {
        default: 2,
        description: "Specify the line width (px) for overlay field lines.",
        type: "number"
      },
      resultLimit: {
        default: 5e4,
        description: "Specify the number of data points to render in a chart.",
        type: "number"
      },
      seriesColors: {
        default: visualization_color_palettes_exports.VIZ_CATEGORICAL,
        description: 'Specify the colors to use in a series. For example, ["#FF0000", "#0000FF", "#008000"].',
        type: "array",
        items: { type: "string" }
      },
      seriesColorsByField: {
        description: "Specify the colors to use for specific fields in a series. For example, {“count”: “#008000”, “percent”: “#FFA500”}.",
        type: "object"
      },
      seriesSpacing: {
        description: "Specify the spacing (px) between clustered series in column and bar charts.",
        type: "number"
      },
      splitByLayout: {
        default: "off",
        description: "Specify the layout method by which to display the visualization, which splits the data into individual visualizations based on a certain category.",
        type: "string",
        pattern: getPattern([
          "off",
          "trellis"
          /* Trellis */
        ]),
        enum: [
          "off",
          "trellis"
          /* Trellis */
        ]
      },
      stackMode: {
        default: "auto",
        description: "Specify stack mode.",
        pattern: getPattern(["auto", "stacked", "stacked100"]),
        type: "string"
      },
      showIndependentYRanges: {
        default: false,
        description: "Specify whether split series charts have independent y-ranges.",
        type: "boolean"
      },
      showSplitSeries: {
        default: false,
        description: "Specify whether to split a multi-series chart into separate charts that are stacked from top to bottom, one for each series.",
        type: "boolean"
      },
      showXMajorGridLines: {
        default: false,
        description: "Specify whether to show major grid lines on the x-axis.",
        type: "boolean"
      },
      showYMajorGridLines: {
        default: true,
        description: "Specify whether to show major grid lines on the y-axis.",
        type: "boolean"
      },
      showY2MajorGridLines: {
        default: false,
        description: "Specify whether to show major grid lines on the second y-axis.",
        type: "boolean"
      },
      showYMinorGridLines: {
        default: false,
        description: "Specify whether to show minor grid lines on the y-axis.",
        type: "boolean"
      },
      showY2MinorGridLines: {
        default: false,
        description: "Specify whether to show minor grid lines on the second y-axis.",
        type: "boolean"
      },
      showYAxisExtendedRange: {
        default: true,
        description: "Specify whether to extend the y-axis to include whole major tick marks.",
        type: "boolean"
      },
      showYAxisWithZero: {
        default: false,
        description: "Specify whether to include zero in the y-axis range.",
        type: "boolean"
      },
      showY2AxisWithZero: {
        default: false,
        description: "Specify whether to include zero the second y-axis range .",
        type: "boolean"
      },
      xAxisLabelVisibility: {
        default: "auto",
        description: "Specify whether to show labels on the x-axis.",
        pattern: getPattern(["auto", "show", "hide"]),
        type: "string"
      },
      trellisBackgroundColor: {
        default: "> themes.defaultBackgroundColor",
        description: "Specify the color used for the trellis container background by using a hexadecimal code. For example, #0000FF.",
        pattern: COLOR_OR_TOKEN_PATTERN_WITH_RGBA,
        type: "string"
      },
      trellisColumns: {
        description: "Specify the number of visualizations to display in a given row of the trellis container. The remaining visualizations will wrap accordingly. If nothing is specified, it will be auto-set based on the trellisMinColumnWidth. The minimum value is 1.",
        type: "number",
        minimum: 1,
        default: 3
      },
      trellisMinColumnWidth: {
        default: 250,
        minimum: 1,
        description: "Specify the minimum width, in pixels, of each visualization in the trellis container. If the window or panel is resized, the remaining visualizations may be viewed by scrolling. The minimum value is 1.",
        type: "number"
      },
      trellisPageCount: {
        default: 20,
        minimum: 1,
        description: "Specify the maximum number of visualizations to display in a single page in the trellis container. The remaining visualizations will paginate accordingly. The minimum value is 1.",
        type: "number"
      },
      trellisRowHeight: {
        default: 180,
        minimum: 1,
        description: "Specify the height, in pixels, of each visualization in the trellis container. If the window or panel is resized, the remaining visualizations may be viewed by scrolling. The minimum value is 1.",
        type: "number"
      },
      trellisSharedScale: {
        default: true,
        type: "boolean",
        description: "Specify whether all visualizations will share the same scale in the trellis container."
      },
      trellisSplitBy: {
        description: "Specify the field name of the column with categories used, or “aggregations”, to split the data into individual visualizations for trellis display, if applicable. If a SPL `timechart` command is used, this may default to the SPL `by` clause field. If a SPL `chart` command is used, this may default to the first string field.",
        type: "string"
      },
      yAxisLabelVisibility: {
        default: "auto",
        description: "Specify whether to show labels on the y-axis.",
        pattern: getPattern(["auto", "show", "hide"]),
        type: "string"
      },
      y2AxisLabelVisibility: {
        default: "auto",
        description: "Specify whether to show labels on the second y-axis.",
        pattern: getPattern(["auto", "show", "hide"]),
        type: "string"
      },
      xAxisLineVisibility: {
        default: "hide",
        description: "Specify whether to show the x-axis line.",
        enum: ["hide", "show"],
        pattern: getPattern(["show", "hide"]),
        type: "string"
      },
      yAxisLineVisibility: {
        default: "hide",
        description: "Specify whether to show the y-axis line.",
        enum: ["hide", "show"],
        pattern: getPattern(["show", "hide"]),
        type: "string"
      },
      y2AxisLineVisibility: {
        default: "hide",
        description: "Specify whether to show the second y-axis line.",
        enum: ["hide", "show"],
        pattern: getPattern(["show", "hide"]),
        type: "string"
      },
      xAxisMajorTickSize: {
        default: 6,
        description: "Specify the size (px) of major tick marks on the x-axis.",
        type: "number"
      },
      yAxisMajorTickSize: {
        default: 6,
        description: "Specify the size (px) of major tick marks on the y-axis.",
        type: "number"
      },
      y2AxisMajorTickSize: {
        default: 6,
        description: "Specify the size (px) of major tick marks on the second y-axis.",
        type: "number"
      },
      yAxisMinorTickSize: {
        default: 6,
        description: "Specify the size (px) of minor tick marks on the y-axis.",
        type: "number"
      },
      y2AxisMinorTickSize: {
        default: 6,
        description: "Specify the size (px) of minor tick marks on the second y-axis.",
        type: "number"
      },
      xAxisMajorTickVisibility: {
        default: "auto",
        description: "Specify whether to show major tick marks on the x-axis.",
        pattern: getPattern(["auto", "show", "hide"]),
        type: "string"
      },
      yAxisMajorTickVisibility: {
        default: "auto",
        description: "Specify whether to show major tick marks on the y-axis.",
        pattern: getPattern(["auto", "show", "hide"]),
        type: "string"
      },
      y2AxisMajorTickVisibility: {
        default: "auto",
        description: "Specify whether to show major tick marks on the second y-axis.",
        pattern: getPattern(["auto", "show", "hide"]),
        type: "string"
      },
      yAxisMinorTickVisibility: {
        default: "auto",
        description: "Specify whether to show  minor tick marks on the y-axis.",
        pattern: getPattern(["auto", "show", "hide"]),
        type: "string"
      },
      y2AxisMinorTickVisibility: {
        default: "auto",
        description: "Specify whether to show minor tick marks on the second y-axis.",
        pattern: getPattern(["auto", "show", "hide"]),
        type: "string"
      },
      xAxisMaxLabelParts: {
        default: 3,
        minimum: 1,
        maximum: 3,
        description: "Specify the maximum number of time-parts for a tick label. The 3 possible parts are year, month, and time. Values can range from 1 to 3.",
        type: "number"
      },
      yAxisScale: {
        default: "linear",
        description: "Specify the type of scale that applies to a numerical y-axis.",
        pattern: getPattern(["linear", "log"]),
        type: "string"
      },
      y2AxisScale: {
        default: "linear",
        description: "Specify the type of scale that applies to a numerical second y-axis.",
        pattern: getPattern(["linear", "log"]),
        type: "string"
      },
      xAxisTitleText: {
        description: "Specify the title of the x-axis.",
        type: "string"
      },
      yAxisTitleText: {
        description: "Specify the title of the y-axis.",
        type: "string"
      },
      y2AxisTitleText: {
        description: "Specify the title of the second y-axis.",
        type: "string"
      },
      xAxisTitleVisibility: {
        default: "show",
        description: "Specify whether to show the title of the x-axis.",
        enum: ["hide", "show"],
        pattern: getPattern(["show", "hide"]),
        type: "string"
      },
      yAxisTitleVisibility: {
        default: "show",
        description: "Specify whether to show the title of the y-axis.",
        enum: ["hide", "show"],
        pattern: getPattern(["show", "hide"]),
        type: "string"
      },
      y2AxisTitleVisibility: {
        default: "show",
        description: "Specify whether to show the title of the second y-axis.",
        enum: ["hide", "show"],
        pattern: getPattern(["show", "hide"]),
        type: "string"
      },
      yAxisAbbreviation: {
        default: "auto",
        description: "Specify whether to abbreviate large y-axis values with the closest International System of Units (SI) prefix.",
        enum: ["auto", "off"],
        pattern: getPattern(["off", "auto"]),
        type: "string"
      },
      y2AxisAbbreviation: {
        default: "auto",
        description: "Specify whether to abbreviate large y2-axis values with the closest International System of Units (SI) prefix.",
        enum: ["auto", "off"],
        pattern: getPattern(["off", "auto"]),
        type: "string"
      },
      yAxisMajorTickInterval: {
        default: "auto",
        description: "Specify the spacing unit between major tick marks along the numeric y-axis.",
        type: ["string", "number"]
      },
      y2AxisMajorTickInterval: {
        default: "auto",
        description: "Specify the spacing unit between major tick marks along the numeric second y-axis.",
        type: ["string", "number"]
      },
      // TODO(SCP-40274): Restrict string value to only 'auto' to achieve precise schema validation
      yAxisMax: {
        default: "auto",
        description: "Specify the largest value to display in the visible y-axis range.",
        type: ["string", "number"]
      },
      // TODO(SCP-40274): Restrict string value to only 'auto' to achieve precise schema validation
      y2AxisMax: {
        default: "auto",
        description: "Specify the largest value to display in the visible second y-axis range.",
        type: ["string", "number"]
      },
      // TODO(SCP-40274): Restrict string value to only 'auto' to achieve precise schema validation
      yAxisMin: {
        default: "auto",
        description: "Specify the smallest value for the visible y-axis range.",
        type: ["string", "number"]
      },
      // TODO(SCP-40274): Restrict string value to only 'auto' to achieve precise schema validation
      y2AxisMin: {
        default: "auto",
        description: "Specify the smallest value for the visible second y-axis range.",
        type: ["string", "number"]
      },
      overlayFields: {
        description: "Specify one or more fields to differentiate on the chart and display as chart overlays.",
        type: ["array", "string"]
      },
      showOverlayY2Axis: {
        default: false,
        description: "Enable a second y-axis for chart overlays. All overlay fields map to a second y-axis.",
        type: "boolean"
      },
      showRoundedY2AxisLabels: {
        default: true,
        description: "Specify whether to round second y-axis values to the nearest integer.",
        type: "boolean"
      }
    });
    var bubbleOptionsSchema = enhanceOptionsSchemaWithDynamicOptions({
      x: {
        default: "> primary | seriesByIndex(0)",
        description: "Specify the dataSource applied to the x-axis.",
        type: "array",
        items: { type: ["string", "number"] }
      },
      y: {
        default: "> primary | seriesByIndex(1)",
        description: "Specify the dataSource applied to the y-axis.",
        type: "array",
        items: { type: ["string", "number"] }
      },
      category: {
        description: "Specify a sequence of dataSource events to be plotted on the chart.",
        type: "array",
        items: { type: ["string", "number"] }
      },
      size: {
        default: "> primary | seriesByIndex(2)",
        description: "Specify the dataSource events that are represented by the bubble size in the chart.",
        type: "array",
        items: { type: "number" }
      },
      xField: {
        default: "> x | getField()",
        description: "Specify the field that should be mapped to the x-axis.",
        type: "string"
      },
      yField: {
        default: "> y | getField()",
        description: "Specify the field that should be mapped to the y-axis.",
        type: "string"
      },
      categoryField: {
        default: "> category | getField()",
        description: "Specify the field that should be mapped to the series categories.",
        type: "string"
      },
      sizeField: {
        default: "> size | getField()",
        description: "Specify the field that should be mapped to the bubble size in the chart.",
        type: "string"
      },
      backgroundColor: {
        default: "> themes.defaultBackgroundColor",
        description: "Specify the color used for the chart background by using a hexadecimal code. For example, #0000FF.",
        pattern: COLOR_OR_TOKEN_PATTERN_WITH_RGBA,
        type: "string"
      },
      bubbleSizeMax: {
        default: 50,
        description: "Specify, in pixels, the maximum size of each bubble.",
        type: "number"
      },
      bubbleSizeMin: {
        default: 10,
        description: "Specify, in pixels, the minimum size of each bubble.",
        type: "number"
      },
      bubbleSizeMethod: {
        default: "area",
        description: "Specify how bubble size is measured.",
        pattern: getPattern(["area", "diameter"]),
        type: "string"
      },
      legendDisplay: {
        default: "right",
        description: "Specify the location of the legend on the panel.",
        pattern: getPattern(["right", "left", "top", "bottom", "off"]),
        type: "string"
      },
      legendTruncation: {
        default: "ellipsisEnd",
        description: "Specify where to use ellipsis to replace legend labels that overflow the layout.",
        pattern: getPattern(["ellipsisEnd", "ellipsisMiddle", "ellipsisStart", "ellipsisOff"]),
        type: "string"
      },
      resultLimit: {
        default: 5e4,
        description: "Specify the number of data points rendered in a chart.",
        type: "number"
      },
      seriesColors: {
        default: visualization_color_palettes_exports.VIZ_CATEGORICAL,
        description: 'Specify the hexadecimal color codes for the bubble order from largest to smallest. For example, ["#FF0000", "#0000FF", "#008000"].',
        type: "array",
        items: { type: "string" }
      },
      seriesColorsByField: {
        description: 'Specify the colors to use for specific categories, or series names, derived from distinct values in the selected category field. For example, {"user1": "#008000", "user2": "#FFA500"}.',
        type: "object"
      },
      showXAxisExtendedRange: {
        default: true,
        description: "Specify whether the x-axis should be extended to snap to whole major tick marks.",
        type: "boolean"
      },
      showYAxisExtendedRange: {
        default: true,
        description: "Specify whether the y-axis should be extended to snap to whole major tick marks.",
        type: "boolean"
      },
      showXAxisWithZero: {
        default: false,
        description: "Specify whether the x-axis range includes zero.",
        type: "boolean"
      },
      showYAxisWithZero: {
        default: false,
        description: "Specify whether the y-axis range includes zero.",
        type: "boolean"
      },
      showRoundedXAxisLabels: {
        default: false,
        description: "Specify whether to round x-axis values to the nearest integer.",
        type: "boolean"
      },
      // TODO: figure out if we want to change splunk-charting behavior for Bubble/Scatter, which hardcodes XMajorGridlines to false
      // showXMajorGridLines: {
      //     default: false,
      //     description: 'Specify whether major grid lines are visible on the x-axis.',
      //     type: 'boolean',
      // },
      showYMajorGridLines: {
        default: true,
        description: "Specify whether major grid lines are visible on the y-axis.",
        type: "boolean"
      },
      showXMinorGridLines: {
        default: false,
        description: "Specify whether minor grid lines are visible on the x-axis.",
        type: "boolean"
      },
      showYMinorGridLines: {
        default: false,
        description: "Specify whether minor grid lines are visible on the y-axis.",
        type: "boolean"
      },
      xAxisLabelRotation: {
        default: 0,
        description: "Specify the rotation of the x-axis labels in degrees.",
        type: "number",
        enum: [-90, -45, 0, 45, 90]
      },
      xAxisAbbreviation: {
        default: "off",
        description: "Specify whether to abbreviate large x-axis values with the closest International System of Units (SI) prefix.",
        enum: ["off", "auto"],
        pattern: getPattern(["auto", "off"]),
        type: "string"
      },
      yAxisAbbreviation: {
        default: "auto",
        description: "Specify whether to abbreviate large y-axis values with the closest International System of Units (SI) prefix.",
        enum: ["off", "auto"],
        pattern: getPattern(["auto", "off"]),
        type: "string"
      },
      xAxisLabelVisibility: {
        default: "auto",
        description: "Specify whether to show or hide labels on the x-axis.",
        pattern: getPattern(["auto", "show", "hide"]),
        type: "string"
      },
      yAxisLabelVisibility: {
        default: "auto",
        description: "Specify whether to show or hide labels on the y-axis.",
        pattern: getPattern(["auto", "show", "hide"]),
        type: "string"
      },
      xAxisLineVisibility: {
        default: "hide",
        description: "Specify whether to show the x-axis line.",
        enum: ["hide", "show"],
        pattern: getPattern(["show", "hide"]),
        type: "string"
      },
      yAxisLineVisibility: {
        default: "hide",
        description: "Specify whether to show the y-axis line.",
        enum: ["hide", "show"],
        pattern: getPattern(["show", "hide"]),
        type: "string"
      },
      xAxisMajorTickInterval: {
        default: "auto",
        description: "Specify the spacing interval between major tick marks along the x-axis. By default, the spacing value is automatically calculated based on the scale of the related axis.",
        type: ["string", "number"]
      },
      yAxisMajorTickInterval: {
        default: "auto",
        description: "Specify the spacing interval between major tick marks along the y-axis. By default, the spacing value is automatically calculated based on the scale of the related axis.",
        type: ["string", "number"]
      },
      xAxisMajorTickSize: {
        default: 6,
        description: "Specify the size, in pixels, of major tick marks on the x-axis.",
        type: "number"
      },
      yAxisMajorTickSize: {
        default: 6,
        description: "Specify the size, in pixels, of major tick marks on the y-axis.",
        type: "number"
      },
      xAxisMinorTickSize: {
        default: 6,
        description: "Specify the size, in pixels, of minor tick marks on the x-axis.",
        type: "number"
      },
      yAxisMinorTickSize: {
        default: 6,
        description: "Specify the size, in pixels, of minor tick marks on the y-axis.",
        type: "number"
      },
      xAxisMajorTickVisibility: {
        default: "auto",
        description: "Specify whether to show or hide major tick marks on the x-axis.",
        pattern: getPattern(["auto", "show", "hide"]),
        type: "string"
      },
      yAxisMajorTickVisibility: {
        default: "auto",
        description: "Specify whether to show or hide major tick marks on the y-axis.",
        pattern: getPattern(["auto", "show", "hide"]),
        type: "string"
      },
      xAxisMinorTickVisibility: {
        default: "auto",
        description: "Specify whether to show or hide minor tick marks on the x-axis .",
        pattern: getPattern(["auto", "show", "hide"]),
        type: "string"
      },
      yAxisMinorTickVisibility: {
        default: "auto",
        description: "Specify whether to show or hide minor tick marks on the y-axis.",
        pattern: getPattern(["auto", "show", "hide"]),
        type: "string"
      },
      xAxisMax: {
        default: "auto",
        description: "Specify the maximum value for the visible x-axis range.",
        type: ["string", "number"]
      },
      yAxisMax: {
        default: "auto",
        description: "Specify the maximum value for the visible y-axis range.",
        type: ["string", "number"]
      },
      xAxisMin: {
        default: "auto",
        description: "Specify the minimum value for the visible x-axis range.",
        type: ["string", "number"]
      },
      yAxisMin: {
        default: "auto",
        description: "Specify the minimum value for the visible y-axis range.",
        type: ["string", "number"]
      },
      xAxisScale: {
        default: "linear",
        description: "Specify the type of scale that applies to a numerical x-axis.",
        pattern: getPattern(["linear", "log"]),
        type: "string"
      },
      yAxisScale: {
        default: "linear",
        description: "Specify the type of scale that applies to a numerical y-axis.",
        pattern: getPattern(["linear", "log"]),
        type: "string"
      },
      xAxisTitleText: {
        description: "Specify the title of the x-axis.",
        type: "string"
      },
      yAxisTitleText: {
        description: "Specify the title of the y-axis.",
        type: "string"
      },
      xAxisTitleVisibility: {
        default: "show",
        description: "Specify whether to hide the title of the x-axis.",
        enum: ["hide", "show"],
        pattern: getPattern(["show", "hide"]),
        type: "string"
      },
      yAxisTitleVisibility: {
        default: "show",
        description: "Specify whether to hide the title of the y-axis.",
        enum: ["hide", "show"],
        pattern: getPattern(["show", "hide"]),
        type: "string"
      }
    });
    var choroplethSvgOptionsSchema = enhanceOptionsSchemaWithDynamicOptions({
      areaColors: {
        default: "> areaValues|rangeValue(areaColorsRangeConfig)",
        description: "Specify the dataSource field that should be used to set the svg fill attribute of identified areas.",
        type: "array",
        items: {
          type: "string",
          pattern: COLOR_OR_TOKEN_PATTERN_WITH_RGBA
        }
      },
      areaIds: {
        default: '> primary|seriesByType("string")',
        description: "Specify the dataSource field that should be used to identify each area in the Choropleth svg, where the area has been tagged with an id field.",
        type: "array",
        items: { type: "string" }
      },
      areaValues: {
        default: '> primary|seriesByType("number")',
        description: "Specify the dataSource field that indicates the values for the areas.",
        type: "array",
        items: { type: "number" }
      },
      backgroundColor: {
        default: "> themes.defaultBackgroundColor",
        description: "the background color behind the SVG, title, and description.",
        type: "string",
        pattern: COLOR_OR_TOKEN_PATTERN_WITH_RGBA
      },
      svg: {
        description: "Literal svg, or svg data URI.",
        type: "string"
      }
    });
    var columnOptionsSchema = enhanceOptionsSchemaWithDynamicOptions({
      x: {
        default: "> primary | seriesByIndex(0)",
        description: "Specify a data source to apply to the x-axis.",
        type: "array",
        items: { type: ["string", "number"] }
      },
      y: {
        default: "> primary | frameBySeriesIndexRange(1)",
        description: "Specify a data source to apply to the y-axis.",
        type: "array",
        items: { type: ["string", "number"] }
      },
      y2: {
        description: "Specify a data source to apply to the second y-axis",
        type: "array",
        items: { type: ["string", "number"] }
      },
      xField: {
        default: "> x | getField()",
        description: "Specify a field to map to the x-axis.",
        type: "string"
      },
      yFields: {
        default: "> y | getField()",
        description: "Specify a field to map to the y-axis.",
        type: "string"
      },
      y2Fields: {
        default: "> y2 | getField()",
        description: "Specify one or more fields to map to a second y-axis.",
        type: ["array", "string"],
        items: {
          type: "string"
        }
      },
      additionalTooltipFields: {
        default: [],
        description: "Specify the fields to add to the default set of tooltips. Tooltips appear when you hover over events. These fields and their corresponding values are shown in addition to the ones displayed by default.",
        type: "array",
        items: { type: "string" }
      },
      annotationColor: {
        description: `Specify the annotation colors. For example, [“#FF0000”, “#0000FF", “#008000”]. You can use a data source or hexadecimal code to apply the color.`,
        type: "array",
        items: { type: "string" }
      },
      annotationLabel: {
        description: `Specify a list of labels to use for annotations. For example, [“Sales”, “Revenue”, “Orders”].You can use a data source to apply the labels. `,
        type: "array",
        items: { type: "string" }
      },
      annotationX: {
        description: "Specify a data source field to apply to the event annotation on the x-axis.",
        type: "array",
        items: { type: ["string", "number"] }
      },
      backgroundColor: {
        default: "> themes.defaultBackgroundColor",
        description: "Specify the color to use for the background. You can use a data source or a hexadecimal code to apply the color.",
        pattern: COLOR_OR_TOKEN_PATTERN_WITH_RGBA,
        type: "string"
      },
      columnGrouping: {
        default: "auto",
        description: "Specify a column grouping mode. If chart.stackMode is defined, it overrides grouping mode settings.",
        pattern: getPattern(["auto", "overlay"]),
        type: "string"
      },
      columnSpacing: {
        description: "Specifies the spacing (px) between columns in a column chart.",
        type: "number"
      },
      dataValuesDisplay: {
        description: 'Specify the labels to display. Enter "all" to show labels for all data points, "off" to show no labels, or "minmax" to show high and low values.',
        type: "string",
        pattern: getPattern(["off", "all", "minmax"]),
        default: "off"
      },
      legendDisplay: {
        description: "Specify the location of the legend on the panel. By default, legendDisplay is off when splitByLayout is trellis, and right otherwise. ",
        pattern: getPattern(["right", "left", "top", "bottom", "off"]),
        type: "string"
      },
      legendLabels: {
        description: `Specify a list of labels to populate the legend in advance. For example, ["percent", "count"].`,
        type: "array",
        items: { type: "string" }
      },
      legendMode: {
        default: "standard",
        description: 'Specify visual and behavioral settings for the tooltip and legend. "seriesCompare" is useful when comparing series.',
        pattern: getPattern(["standard", "seriesCompare"]),
        type: "string"
      },
      legendTruncation: {
        description: "Specify how to display legend labels when they overflow the layout boundaries by replacing overflow text with an ellipsis.",
        pattern: getPattern(["ellipsisEnd", "ellipsisMiddle", "ellipsisStart", "ellipsisOff"]),
        type: "string",
        default: "ellipsisEnd"
      },
      lineDashStyle: {
        default: "solid",
        description: "Specify a dash style for all overlay field lines.",
        pattern: getPattern([
          "solid",
          "shortDash",
          "shortDot",
          "shortDashDot",
          "shortDashDotDot",
          "dot",
          "dash",
          "longDash",
          "dashDot",
          "longDashDot",
          "longDashDotDot"
        ]),
        type: "string"
      },
      lineDashStylesByField: {
        description: `Specify a dash style to use for overlay lines for each field. For example, {"count": "longDashDot", "percent": "longDashDotDot"}.
        Valid values: "solid", "shortDash", "shortDot", "shortDashDot", "shortDashDotDot", "dot", "dash",
        "longDash", "dashDot", "longDashDot", "longDashDotDot".`,
        type: "object"
      },
      lineWidth: {
        default: 2,
        description: "Specify the line width (px) for overlay field lines.",
        type: "number"
      },
      resultLimit: {
        default: 5e4,
        description: "Specify the number of data points to render in a chart.",
        type: "number"
      },
      seriesColors: {
        default: visualization_color_palettes_exports.VIZ_CATEGORICAL,
        description: 'Specify the colors to use in a series. For example, ["#FF0000", "#0000FF", "#008000"].',
        type: "array",
        items: { type: "string" }
      },
      seriesColorsByField: {
        description: "Specify the colors to use for specific fields in a series. For example, {“count”: “#008000”, “percent”: “#FFA500”}.",
        type: "object"
      },
      seriesSpacing: {
        description: "Specify the spacing (px) between clustered series in column and bar charts.",
        type: "number"
      },
      splitByLayout: {
        default: "off",
        description: "Specify the layout method by which to display the visualization, which splits the data into individual visualizations based on a certain category.",
        type: "string",
        pattern: getPattern([
          "off",
          "trellis"
          /* Trellis */
        ]),
        enum: [
          "off",
          "trellis"
          /* Trellis */
        ]
      },
      stackMode: {
        description: "Specify stack mode.",
        type: "string",
        pattern: getPattern(["auto", "stacked", "stacked100"]),
        default: "auto"
      },
      showIndependentYRanges: {
        description: "Specify whether split series charts have independent y-ranges.",
        type: "boolean",
        default: false
      },
      showSplitSeries: {
        description: "Specify whether to split a multi-series chart into separate charts that are stacked from top to bottom; uses one chart for each series.",
        type: "boolean",
        default: false
      },
      showTooltip: {
        description: "Specify whether to make a tooltip visible on hover",
        type: "boolean",
        default: true
      },
      showXMajorGridLines: {
        description: "Specify whether to show major grid lines on the x-axis.",
        type: "boolean",
        default: false
      },
      showYMajorGridLines: {
        description: "Specify whether to show major grid lines on the y-axis.",
        type: "boolean",
        default: true
      },
      showY2MajorGridLines: {
        description: "Specify whether to show major grid lines on the second y-axis.",
        type: "boolean",
        default: false
      },
      showYMinorGridLines: {
        description: "Specify whether to show minor grid lines on the y-axis.",
        type: "boolean",
        default: false
      },
      showY2MinorGridLines: {
        description: "Specify whether to show minor grid lines on the second y-axis.",
        type: "boolean",
        default: false
      },
      showYAxisExtendedRange: {
        description: "Specify whether to extend the y-axis to include whole major tick marks.",
        type: "boolean",
        default: true
      },
      showYAxisWithZero: {
        description: "Specify whether to include zero in the y-axis range.",
        type: "boolean",
        default: false
      },
      showY2AxisWithZero: {
        description: "Specify whether to include zero in the second y-axis range.",
        type: "boolean",
        default: false
      },
      trellisBackgroundColor: {
        default: "> themes.defaultBackgroundColor",
        description: "Specify the color used for the trellis container background by using a hexadecimal code. For example, #0000FF.",
        pattern: COLOR_OR_TOKEN_PATTERN_WITH_RGBA,
        type: "string"
      },
      trellisColumns: {
        description: "Specify the number of visualizations to display in a given row of the trellis container. The remaining visualizations will wrap accordingly. If nothing is specified, it will be auto-set based on the trellisMinColumnWidth. The minimum value is 1.",
        type: "number",
        minimum: 1,
        default: 3
      },
      trellisMinColumnWidth: {
        default: 250,
        minimum: 1,
        description: "Specify the minimum width, in pixels, of each visualization in the trellis container. If the window or panel is resized, the remaining visualizations may be viewed by scrolling. The minimum value is 1.",
        type: "number"
      },
      trellisPageCount: {
        default: 20,
        minimum: 1,
        description: "Specify the maximum number of visualizations to display in a single page in the trellis container. The remaining visualizations will paginate accordingly. The minimum value is 1.",
        type: "number"
      },
      trellisRowHeight: {
        default: 180,
        minimum: 1,
        description: "Specify the height, in pixels, of each visualization in the trellis container. If the window or panel is resized, the remaining visualizations may be viewed by scrolling. The minimum value is 1.",
        type: "number"
      },
      trellisSharedScale: {
        default: true,
        type: "boolean",
        description: "Specify whether all visualizations will share the same scale in the trellis container."
      },
      trellisSplitBy: {
        description: "Specify the field name of the column with categories used, or “aggregations”, to split the data into individual visualizations for trellis display, if applicable. If a SPL `timechart` command is used, this may default to the SPL `by` clause field. If a SPL `chart` command is used, this may default to the first string field.",
        type: "string"
      },
      xAxisLabelRotation: {
        description: "Specify the rotation of the x-axis label in degrees.",
        enum: [-90, -45, 0, 45, 90],
        type: "number",
        default: 0
      },
      xAxisLabelVisibility: {
        description: "Specify whether to show labels on the x-axis.",
        pattern: getPattern(["auto", "show", "hide"]),
        type: "string",
        default: "auto"
      },
      yAxisLabelVisibility: {
        default: "auto",
        description: "Specify whether to show labels on the y-axis.",
        pattern: getPattern(["auto", "show", "hide"]),
        type: "string"
      },
      y2AxisLabelVisibility: {
        default: "auto",
        description: "Specify whether to show labels on the second y-axis.",
        pattern: getPattern(["auto", "show", "hide"]),
        type: "string"
      },
      xAxisLineVisibility: {
        default: "hide",
        description: "Specify whether to show the x-axis line.",
        enum: ["hide", "show"],
        pattern: getPattern(["show", "hide"]),
        type: "string"
      },
      yAxisLineVisibility: {
        default: "hide",
        description: "Specify whether to show the y-axis line.",
        enum: ["hide", "show"],
        pattern: getPattern(["show", "hide"]),
        type: "string"
      },
      y2AxisLineVisibility: {
        default: "hide",
        description: "Specify whether to show the second y-axis line.",
        enum: ["hide", "show"],
        pattern: getPattern(["show", "hide"]),
        type: "string"
      },
      xAxisMajorTickSize: {
        description: "Specify the size (px) of major tick marks on the x-axis.",
        type: "number",
        default: 6
      },
      yAxisMajorTickSize: {
        default: 6,
        description: "Specify the size (px) of major tick marks on the y-axis.",
        type: "number"
      },
      y2AxisMajorTickSize: {
        default: 6,
        description: "Specify the size (px) of major tick marks on the second y-axis.",
        type: "number"
      },
      yAxisMinorTickSize: {
        default: 6,
        description: "Specify the size (px) of minor tick marks on the y-axis.",
        type: "number"
      },
      y2AxisMinorTickSize: {
        default: 6,
        description: "Specify the size (px) of minor tick marks on the second y-axis.",
        type: "number"
      },
      xAxisMajorTickVisibility: {
        default: "auto",
        description: "Specify whether to show major tick marks on the x-axis.",
        pattern: getPattern(["auto", "show", "hide"]),
        type: "string"
      },
      yAxisMajorTickVisibility: {
        default: "auto",
        description: "Specify whether to show major tick marks on the y-axis.",
        pattern: getPattern(["auto", "show", "hide"]),
        type: "string"
      },
      y2AxisMajorTickVisibility: {
        default: "auto",
        description: "Specify whether to show  major tick marks on the second y-axis.",
        pattern: getPattern(["auto", "show", "hide"]),
        type: "string"
      },
      yAxisMinorTickVisibility: {
        default: "auto",
        description: "Specify whether to show minor tick marks on the y-axis.",
        pattern: getPattern(["auto", "show", "hide"]),
        type: "string"
      },
      y2AxisMinorTickVisibility: {
        default: "auto",
        description: "Specify whether to show minor tick marks on the second y-axis.",
        pattern: getPattern(["auto", "show", "hide"]),
        type: "string"
      },
      xAxisMaxLabelParts: {
        description: "Specify the maximum number of time-parts for a tick label. The 3 possible parts are year, month, and time. Values can range from 1 to 3.",
        type: "number",
        default: 3,
        minimum: 1,
        maximum: 3
      },
      yAxisScale: {
        type: "string",
        pattern: getPattern(["linear", "log"]),
        description: "Specify the type of scale that applies to a numerical y-axis.",
        default: "linear"
      },
      y2AxisScale: {
        type: "string",
        pattern: getPattern(["linear", "log"]),
        description: "Specify the type of scale that applies to a numerical second y-axis.",
        default: "linear"
      },
      xAxisTitleText: {
        description: "Specify the title of the x-axis.",
        type: "string"
      },
      yAxisTitleText: {
        description: "Specify the title of the y-axis.",
        type: "string"
      },
      y2AxisTitleText: {
        description: "Specify the title of the second y-axis.",
        type: "string"
      },
      xAxisTitleVisibility: {
        default: "show",
        description: "Specify whether to show the title of the x-axis.",
        enum: ["hide", "show"],
        pattern: getPattern(["show", "hide"]),
        type: "string"
      },
      yAxisTitleVisibility: {
        default: "show",
        description: "Specify whether to show the title of the y-axis.",
        enum: ["hide", "show"],
        pattern: getPattern(["show", "hide"]),
        type: "string"
      },
      y2AxisTitleVisibility: {
        default: "show",
        description: "Specify whether to show the title of the second y-axis.",
        enum: ["hide", "show"],
        pattern: getPattern(["show", "hide"]),
        type: "string"
      },
      yAxisAbbreviation: {
        default: "auto",
        description: "Specify whether to abbreviate large y-axis values with the closest International System of Units (SI) prefix.",
        enum: ["auto", "off"],
        pattern: getPattern(["off", "auto"]),
        type: "string"
      },
      y2AxisAbbreviation: {
        default: "auto",
        description: "Specify whether to abbreviate large second y-axis values with the closest International System of Units (SI) prefix.",
        enum: ["auto", "off"],
        pattern: getPattern(["off", "auto"]),
        type: "string"
      },
      yAxisMajorTickInterval: {
        default: "auto",
        description: "Specify the spacing unit between major tick marks along the numeric y-axis.",
        type: ["string", "number"]
      },
      y2AxisMajorTickInterval: {
        default: "auto",
        description: "Specify the spacing unit between major tick marks along the numeric second y-axis.",
        type: ["string", "number"]
      },
      yAxisMax: {
        type: ["string", "number"],
        description: "Specify the largest value for the visible y-axis range.",
        default: "auto"
      },
      y2AxisMax: {
        type: ["string", "number"],
        description: "Specify the largest value for the visible second y-axis range.",
        default: "auto"
      },
      yAxisMin: {
        type: ["string", "number"],
        description: "Specify the smallest value for the visible y-axis range.",
        default: "auto"
      },
      y2AxisMin: {
        type: ["string", "number"],
        description: "Specify the smallest value for the visible second y-axis range.",
        default: "auto"
      },
      overlayFields: {
        description: "Specify one or more fields to differentiate on the chart and display as chart overlays.",
        type: ["array", "string"],
        items: {
          type: "string"
        }
      },
      showOverlayY2Axis: {
        default: false,
        description: "Enable a second y-axis for chart overlays. All overlay fields will map to a second y-axis.",
        type: "boolean"
      },
      showRoundedY2AxisLabels: {
        default: true,
        description: "Specify whether to round the second y-axis values to the nearest integer.",
        type: "boolean"
      }
    });
    var ellipseOptionsSchema = enhanceOptionsSchemaWithDynamicOptions({
      fillColor: {
        default: "> themes.defaultFillColor",
        description: 'Specify the fill color. You may use a dataSource to apply the color. The hex value format should be "#FFFFFF". The default for enterprise light is "#C3CBD4". The default for enterprise dark is "#31373E". The default for prisma dark is "#0B0C0E".',
        type: "string"
      },
      fillOpacity: {
        default: 1,
        description: 'Specify the opacity of the fill. Choose a number in the range of 0 - 1 (inclusive). You can also express the value as a percentage. For example, "0.80" in source or "80%" in UI.',
        type: "number"
      },
      strokeColor: {
        default: "> themes.defaultStrokeColor",
        description: 'Specify the stroke color. You may use a dataSource to apply the color. The hex value format should be "#FFFFFF". The default for enterprise light is "#3C444D". The default for enterprise dark is "#C3CBD4". The default for prisma dark is "#ACACAD".',
        type: "string"
      },
      strokeDashStyle: {
        default: 0,
        description: "Specify the size, in pixels, of dashes and spaces used to create a custom stitched outline. The value you specify applies to both the dashes and the spaces between them.",
        type: "number"
      },
      strokeOpacity: {
        default: 1,
        description: 'Specify the opacity of the stroke. Choose a number in the range of 0 - 1 (inclusive). You can also express the value as a percentage. For example, "0.80" in source or "80%" in UI.',
        type: "number"
      },
      strokeWidth: {
        default: 1,
        description: "Specify the width of the stroke, in pixels. The minimum value is 0.",
        type: "number"
      }
    });
    var eventsOptionsSchema = enhanceOptionsSchemaWithDynamicOptions({
      backgroundColor: {
        default: "> themes.defaultBackgroundColor",
        description: "Specify the color used for the background by using a hexadecimal code. For example, #0000FF.",
        pattern: COLOR_OR_TOKEN_PATTERN_WITH_RGBA,
        type: "string"
      },
      eventActions: {
        default: [],
        description: 'Specify the available actions to take for an event. For example, `[{ "eventType": "eventAction.buildEventType.click", "label": "Build Event Type" }]`. Event types should end in `.click` if utilizing event handlers. Note that both `eventtypeValues` and `fieldFilters` keys support wildcard values.',
        type: "array",
        items: {
          anyOf: [
            {
              type: "object",
              properties: {
                eventType: {
                  description: "The distinct type for the event emitted upon event action click.",
                  type: "string",
                  pattern: ".click$",
                  default: ""
                },
                label: {
                  description: "The label for the event action.",
                  type: "string",
                  default: ""
                },
                eventtypeValues: {
                  description: "An array of string values that all need to match against the value(s) of the `eventtype` field if it exists in the event in order to be shown.",
                  items: { type: "string" },
                  type: "array",
                  default: []
                },
                fieldFilters: {
                  description: "An array of string values for fields that need to exist in the event in order for the given event action in order to be shown.",
                  items: { type: "string" },
                  type: "array",
                  default: []
                }
              },
              required: ["eventType", "label"]
            }
          ]
        }
      },
      fieldActions: {
        description: 'Specify the available actions for this field. For example, `{ *: [{ "eventType": "fieldAction.sharedAction1.click", "label": "Shared Action 1", "eventtypeValues": ["*"], "fieldFilters": ["*"] }] }`. Event types should end in `.click` if utilizing event handlers. Actions under the `*` key are shared across all field dropdowns. Note that both `eventtypeValues` and `fieldFilters` keys, as well as the field names, support wildcard values.',
        type: "object",
        patternProperties: {
          ".*": {
            description: "Specify the available actions for this field.",
            type: "array",
            items: {
              anyOf: [
                {
                  type: "object",
                  properties: {
                    eventType: {
                      description: "The distinct type for the event emitted upon event action click.",
                      type: "string",
                      pattern: ".click$",
                      default: ""
                    },
                    label: {
                      description: "The label for the event action.",
                      type: "string",
                      default: ""
                    },
                    eventtypeValues: {
                      description: "An array of string values that all need to match against the value(s) of the `eventtype` field if it exists in the event in order to be shown.",
                      items: { type: "string" },
                      type: "array",
                      default: []
                    },
                    fieldFilters: {
                      description: "An array of string values for fields that need to exist in the event in order for the given event action in order to be shown.",
                      items: { type: "string" },
                      type: "array",
                      default: []
                    }
                  },
                  required: ["eventType", "label"]
                }
              ]
            }
          }
        }
      },
      footerFields: {
        description: 'Specify field(s) that should be displayed in the footer component. Specify one or more fields to display in the footer component. For example, specify ["source", "dest"] to display the source and destination fields.',
        type: "array",
        items: {
          type: "string"
        },
        default: []
      },
      highlightValuesByField: {
        description: 'Specify the field and value pairs for manual highlighting. For example, `{"source": "$srcToken$", "dest": "12.21.1.11", "tag": ["tag1", "tag2"]}`.',
        type: "object"
      },
      highlightFromSource: {
        description: 'Specify a segmentation mode to use for search based highlighting. Specifying "none" will turn search based highlighting off. For more about segmentation, search for "event segmentation" in the Getting Data In manual in the Splunk Docs.',
        type: "string",
        pattern: getPattern(validSegmentationModes),
        default: "none"
      },
      showFieldSummary: {
        description: "Specify that a field summary popup appears when a field is selected. To show field summaries for a search, configure an additional datasource called `fieldsummary` using the original search followed by the `... | fieldsummary maxvals=10` SPL command.",
        type: "boolean",
        default: true
      }
    });
    var fillerGaugeOptionsSchema = enhanceOptionsSchemaWithDynamicOptions({
      backgroundColor: {
        default: "> themes.defaultBackgroundColor",
        description: 'Specify the color used for the background. The default for enterprise light is "#ffffff". The default for enterprise dark is "#000000". The default for prisma dark is "#0b0c0e".',
        pattern: COLOR_OR_TOKEN_PATTERN_WITH_RGBA,
        type: "string"
      },
      gaugeColor: {
        default: visualization_color_palettes_exports.CATEGORICAL[0],
        description: 'Specify the color for the gauge color of the filler gauge. You may use a dataSource to apply the color. The hex value format should be "#FFFFFF".',
        type: "string"
      },
      labelDisplay: {
        default: "number",
        description: "Specify whether to display the labels as numbers, percentages, or off. The label right aligns to the value for horizontal orientation, and top aligns for vertical.",
        pattern: getPattern(["number", "percentage", "off"]),
        type: "string"
      },
      majorTickInterval: {
        description: "Specify, in pixels, the spacing between major tick marks.",
        default: "auto",
        type: ["string", "number"]
      },
      orientation: {
        default: "vertical",
        description: "Specify the axis orientation of the gauge.",
        pattern: getPattern(["vertical", "horizontal"]),
        type: "string"
      },
      splitByLayout: {
        default: "off",
        description: "Specify the layout method by which to display the visualization, which splits the data into individual visualizations based on a certain category.",
        type: "string",
        pattern: getPattern([
          "off",
          "trellis"
          /* Trellis */
        ]),
        enum: [
          "off",
          "trellis"
          /* Trellis */
        ]
      },
      trellisBackgroundColor: {
        default: "> themes.defaultBackgroundColor",
        description: "Specify the color used for the trellis container background by using a hexadecimal code. For example, #0000FF.",
        pattern: COLOR_OR_TOKEN_PATTERN_WITH_RGBA,
        type: "string"
      },
      trellisColumns: {
        description: "Specify the number of visualizations to display in a given row of the trellis container. The remaining visualizations will wrap accordingly. If nothing is specified, it will be auto-set based on the trellisMinColumnWidth. The minimum value is 1.",
        type: "number",
        minimum: 1,
        default: 3
      },
      trellisMinColumnWidth: {
        default: 200,
        minimum: 1,
        description: "Specify the minimum width, in pixels, of each visualization in the trellis container. If the window or panel is resized, the remaining visualizations may be viewed by scrolling. The minimum value is 1.",
        type: "number"
      },
      trellisPageCount: {
        default: 20,
        minimum: 1,
        description: "Specify the maximum number of visualizations to display in a single page in the trellis container. The remaining visualizations will paginate accordingly. The minimum value is 1.",
        type: "number"
      },
      trellisRowHeight: {
        default: 200,
        minimum: 1,
        description: "Specify the height, in pixels, of each visualization in the trellis container. If the window or panel is resized, the remaining visualizations may be viewed by scrolling. The minimum value is 1.",
        type: "number"
      },
      trellisSplitBy: {
        description: "Specify the field name of the column with categories used, or “aggregations”, to split the data into individual visualizations for trellis display, if applicable. If a SPL `timechart` command is used, this may default to the SPL `by` clause field. If a SPL `chart` command is used, this may default to the first string field.",
        type: "string"
      },
      value: {
        default: '> primary | seriesByType("number") | lastPoint()',
        description: "Specify the dataSource applied to the value of the filler gauge.",
        type: "number"
      },
      valueDisplay: {
        default: "number",
        description: "Specify whether to display the value as a number, percentage, or off.",
        pattern: getPattern(["number", "percentage", "off"]),
        type: "string"
      }
    });
    var imageOptionsSchema = enhanceOptionsSchemaWithDynamicOptions({
      src: {
        description: "URL of an image file. All browser-supported image formats are acceptable.",
        type: "string"
      },
      preserveAspectRatio: {
        default: false,
        description: "Set to true to maintain the aspect ratio of an image when the screen is resized.",
        type: "boolean"
      }
    });
    var lineOptionsSchema = enhanceOptionsSchemaWithDynamicOptions({
      x: {
        default: "> primary | seriesByIndex(0)",
        description: "Specify the dataSource applied to the x-axis.",
        type: "array",
        items: { type: ["string", "number"] }
      },
      y: {
        default: "> primary | frameBySeriesIndexRange(1)",
        description: "Specify the dataSource applied to the y-axis.",
        type: "array",
        items: { type: ["string", "number"] }
      },
      y2: {
        description: "Specify the dataSource applied to the y2-axis",
        type: "array",
        items: { type: ["string", "number"] }
      },
      xField: {
        default: "> x | getField()",
        description: "Specify the field that should be mapped to the x-axis.",
        type: "string"
      },
      yFields: {
        default: "> y | getField()",
        description: "Specify the field that should be mapped to the y-axis.",
        type: "string"
      },
      additionalTooltipFields: {
        default: [],
        description: "Specify the fields to add to the default set of tooltips. Tooltips appear when you hover over events. These fields and their corresponding values are shown in addition to the ones displayed by default.",
        type: "array",
        items: { type: "string" }
      },
      annotationColor: {
        description: `Specify the annotation colors. You may use a dataSource to apply the color. For example, [“#FF0000”, “#0000FF", “#008000”].`,
        type: "array",
        items: { type: "string" }
      },
      annotationLabel: {
        description: `Specify a list of labels used for the annotations. You may use a dataSource to apply the labels. For example, [“houston, we have a problem”, “just close the jira”, “looking good now”].`,
        type: "array",
        items: { type: "string" }
      },
      annotationX: {
        description: "Specify the dataSource field applied to the event annotation on the x-axis.",
        type: "array",
        items: { type: ["string", "number"] }
      },
      backgroundColor: {
        default: "> themes.defaultBackgroundColor",
        description: 'Specify the color for the background. You may use a dataSource to apply the color. The default for enterprise light is "#ffffff". The default for enterprise dark is "#000000". The default for prisma dark is "#0b0c0e".',
        pattern: COLOR_OR_TOKEN_PATTERN_WITH_RGBA,
        type: "string"
      },
      dataValuesDisplay: {
        default: "off",
        description: "Specify whether chart should display no labels, all labels, or only the min and max labels.",
        pattern: getPattern(["off", "all", "minmax"]),
        type: "string"
      },
      legendDisplay: {
        description: "Specify the location of the legend on the panel. By default, legendDisplay is off when splitByLayout is trellis, and right otherwise. You must select the Standard legend mode to make this change.",
        pattern: getPattern(["right", "left", "top", "bottom", "off"]),
        type: "string"
      },
      legendLabels: {
        description: `Specify a list of labels to pre-populate the legend. For example, ["percent", "count"].`,
        type: "array",
        items: { type: "string" }
      },
      legendMode: {
        default: "standard",
        description: 'Specify visual and behavioral settings for the tooltip and legend. "seriesCompare" is useful when comparing series.',
        pattern: getPattern(["standard", "seriesCompare"]),
        type: "string"
      },
      legendTruncation: {
        default: "ellipsisEnd",
        description: "Specify how to display legend labels when they overflow the layout boundaries by replacing overflow text with an ellipsis.",
        pattern: getPattern(["ellipsisEnd", "ellipsisMiddle", "ellipsisStart", "ellipsisOff"]),
        type: "string"
      },
      lineDashStyle: {
        default: "solid",
        description: "Specify a dash style for all line series in the chart.",
        pattern: getPattern([
          "solid",
          "shortDash",
          "shortDot",
          "shortDashDot",
          "shortDashDotDot",
          "dot",
          "dash",
          "longDash",
          "dashDot",
          "longDashDot",
          "longDashDotDot"
        ]),
        type: "string"
      },
      lineDashStylesByField: {
        description: `Specify a dash style to use for each field. For example, {"count": "longDashDot", "percent": "longDashDotDot"}.
        Valid values: "solid", "shortDash", "shortDot", "shortDashDot", "shortDashDotDot", "dot", "dash",
        "longDash", "dashDot", "longDashDot", "longDashDotDot".`,
        type: "object"
      },
      lineWidth: {
        default: 2,
        description: "Specify the line width (px), for all line series.",
        type: "number"
      },
      markerDisplay: {
        default: "off",
        description: `Specify the marker display style for data points.`,
        pattern: getPattern(["off", "filled", "outlined"]),
        enum: ["off", "filled", "outlined"],
        type: "string"
      },
      nullValueDisplay: {
        default: "gaps",
        description: "Specify how area and line charts handle null values.",
        pattern: getPattern(["gaps", "zero", "connect"]),
        type: "string"
      },
      resultLimit: {
        default: 5e4,
        description: "Specify the number of data points rendered in a chart.",
        type: "number"
      },
      seriesColors: {
        default: visualization_color_palettes_exports.VIZ_CATEGORICAL,
        description: 'Specify the colors used for a series. For example, ["#FF0000", "#0000FF", "#008000"].',
        type: "array",
        items: { type: "string" }
      },
      seriesColorsByField: {
        description: "Specify the colors used for specific fields in a series. For example, {“count”: “#008000”, “percent”: “#FFA500”}.",
        type: "object"
      },
      showLineSmoothing: {
        default: false,
        description: "Specify whether lines are straight or smoothed using curves.",
        type: "boolean"
      },
      showIndependentYRanges: {
        default: false,
        description: "Specify whether split series charts have independent y-ranges.",
        type: "boolean"
      },
      showSplitSeries: {
        default: false,
        description: 'Set to "true" to split a multi-series chart into separate charts that are stacked from top to bottom; one for each series.',
        type: "boolean"
      },
      showXMajorGridLines: {
        default: false,
        description: "Specify whether major grid lines are visible on the x-axis.",
        type: "boolean"
      },
      showYMajorGridLines: {
        default: true,
        description: "Specify whether major grid lines are visible on the y-axis.",
        type: "boolean"
      },
      showY2MajorGridLines: {
        default: false,
        description: "Specify whether major grid lines are visible on the y2-axis.",
        type: "boolean"
      },
      showYMinorGridLines: {
        default: false,
        description: "Specify whether minor grid lines are visible on the y-axis.",
        type: "boolean"
      },
      showY2MinorGridLines: {
        default: false,
        description: "Specify whether minor grid lines are visible on y2-axis.",
        type: "boolean"
      },
      showYAxisExtendedRange: {
        default: true,
        description: "Specify whether the y-axis should be extended to include whole major tick marks.",
        type: "boolean"
      },
      showYAxisWithZero: {
        default: false,
        description: "Specify whether the y-axis range includes zero.",
        type: "boolean"
      },
      showY2AxisWithZero: {
        default: false,
        description: "Specify whether the y2-axis range includes zero.",
        type: "boolean"
      },
      splitByLayout: {
        default: "off",
        description: "Specify the layout method by which to display the visualization, which splits the data into individual visualizations based on a certain category.",
        type: "string",
        pattern: getPattern([
          "off",
          "trellis"
          /* Trellis */
        ]),
        enum: [
          "off",
          "trellis"
          /* Trellis */
        ]
      },
      trellisBackgroundColor: {
        default: "> themes.defaultBackgroundColor",
        description: "Specify the color used for the trellis container background by using a hexadecimal code. For example, #0000FF.",
        pattern: COLOR_OR_TOKEN_PATTERN_WITH_RGBA,
        type: "string"
      },
      trellisColumns: {
        description: "Specify the number of visualizations to display in a given row of the trellis container. The remaining visualizations will wrap accordingly. If nothing is specified, it will be auto-set based on the trellisMinColumnWidth. The minimum value is 1.",
        type: "number",
        minimum: 1,
        default: 3
      },
      trellisMinColumnWidth: {
        default: 250,
        minimum: 1,
        description: "Specify the minimum width, in pixels, of each visualization in the trellis container. If the window or panel is resized, the remaining visualizations may be viewed by scrolling. The minimum value is 1.",
        type: "number"
      },
      trellisPageCount: {
        default: 20,
        minimum: 1,
        description: "Specify the maximum number of visualizations to display in a single page in the trellis container. The remaining visualizations will paginate accordingly. The minimum value is 1.",
        type: "number"
      },
      trellisRowHeight: {
        default: 180,
        minimum: 1,
        description: "Specify the height, in pixels, of each visualization in the trellis container. If the window or panel is resized, the remaining visualizations may be viewed by scrolling. The minimum value is 1.",
        type: "number"
      },
      trellisSharedScale: {
        default: true,
        type: "boolean",
        description: "Specify whether all visualizations will share the same scale in the trellis container."
      },
      trellisSplitBy: {
        description: "Specify the field name of the column with categories used, or “aggregations”, to split the data into individual visualizations for trellis display, if applicable. If a SPL `timechart` command is used, this may default to the SPL `by` clause field. If a SPL `chart` command is used, this may default to the first string field.",
        type: "string"
      },
      xAxisLabelRotation: {
        default: 0,
        description: "Specify the rotation of the x-axis label in degrees.",
        enum: [-90, -45, 0, 45, 90],
        type: "number"
      },
      xAxisLabelVisibility: {
        default: "auto",
        description: "Specify whether to show or hide labels on the x-axis.",
        pattern: getPattern(["auto", "show", "hide"]),
        type: "string"
      },
      yAxisLabelVisibility: {
        default: "auto",
        description: "Specify whether to show or hide labels on the y-axis.",
        pattern: getPattern(["auto", "show", "hide"]),
        type: "string"
      },
      y2AxisLabelVisibility: {
        default: "auto",
        description: "Specify whether to show or hide labels on the y2-axis.",
        pattern: getPattern(["auto", "show", "hide"]),
        type: "string"
      },
      xAxisLineVisibility: {
        default: "hide",
        enum: ["hide", "show"],
        description: "Specify whether to show or hide the x-axis line.",
        pattern: getPattern(["show", "hide"]),
        type: "string"
      },
      yAxisLineVisibility: {
        default: "hide",
        description: "Specify whether to show or hide the y-axis line.",
        enum: ["hide", "show"],
        pattern: getPattern(["show", "hide"]),
        type: "string"
      },
      y2AxisLineVisibility: {
        default: "hide",
        description: "Specify whether to show or hide the y2-axis line.",
        enum: ["hide", "show"],
        pattern: getPattern(["show", "hide"]),
        type: "string"
      },
      xAxisMajorTickSize: {
        default: 6,
        description: "Specify the size, in pixels, of major tick marks on the x-axis.",
        type: "number"
      },
      yAxisMajorTickSize: {
        default: 6,
        description: "Specify the size, in pixels, of major tick marks on the y-axis.",
        type: "number"
      },
      y2AxisMajorTickSize: {
        default: 6,
        description: "Specify the size, in pixels, of major tick marks on the y2-axis.",
        type: "number"
      },
      yAxisMinorTickSize: {
        default: 6,
        description: "Specify the size, in pixels, of minor tick marks on the y-axis.",
        type: "number"
      },
      y2AxisMinorTickSize: {
        default: 6,
        description: "Specify the size, in pixels, of minor tick marks on the y2-axis.",
        type: "number"
      },
      xAxisMajorTickVisibility: {
        default: "auto",
        description: "Specify whether to show or hide major tick marks on the x-axis.",
        pattern: getPattern(["auto", "show", "hide"]),
        type: "string"
      },
      yAxisMajorTickVisibility: {
        default: "auto",
        description: "Specify whether to show or hide major tick marks on the y-axis.",
        pattern: getPattern(["auto", "show", "hide"]),
        type: "string"
      },
      y2AxisMajorTickVisibility: {
        default: "auto",
        description: "Specify whether to show or hide major tick marks on the y2-axis.",
        pattern: getPattern(["auto", "show", "hide"]),
        type: "string"
      },
      yAxisMinorTickVisibility: {
        default: "auto",
        description: "Specify whether to show or hide minor tick marks on the y-axis.",
        pattern: getPattern(["auto", "show", "hide"]),
        type: "string"
      },
      y2AxisMinorTickVisibility: {
        default: "auto",
        description: "Specify whether to show or hide minor tick marks on the y2-axis.",
        pattern: getPattern(["auto", "show", "hide"]),
        type: "string"
      },
      xAxisMaxLabelParts: {
        default: 3,
        minimum: 1,
        maximum: 3,
        description: "Specify the maximum number of time-parts for a tick label. The 3 possible parts are year, month, and time. Values can range from 1 to 3.",
        type: "number"
      },
      xAxisTitleText: {
        description: "Specify the title of the x-axis.",
        type: "string"
      },
      yAxisTitleText: {
        description: "Specify the title of the y-axis.",
        type: "string"
      },
      y2AxisTitleText: {
        description: "Specify the title of the y2-axis.",
        type: "string"
      },
      xAxisTitleVisibility: {
        default: "show",
        description: "Specify whether to show or hide the title of the x-axis.",
        enum: ["hide", "show"],
        pattern: getPattern(["show", "hide"]),
        type: "string"
      },
      yAxisTitleVisibility: {
        default: "show",
        description: "Specify whether to show or hide the title of the y-axis.",
        enum: ["hide", "show"],
        pattern: getPattern(["show", "hide"]),
        type: "string"
      },
      y2AxisTitleVisibility: {
        default: "show",
        description: "Specify whether to show or hide the title of the y2-axis.",
        enum: ["hide", "show"],
        pattern: getPattern(["show", "hide"]),
        type: "string"
      },
      yAxisAbbreviation: {
        default: "auto",
        description: "Specify whether to abbreviate large y-axis values with the closest SI prefix.",
        enum: ["off", "auto"],
        pattern: getPattern(["off", "auto"]),
        type: "string"
      },
      y2AxisAbbreviation: {
        default: "auto",
        description: "Specify whether to abbreviate large y2-axis values with the closest SI prefix.",
        enum: ["off", "auto"],
        pattern: getPattern(["off", "auto"]),
        type: "string"
      },
      yAxisMajorTickInterval: {
        default: "auto",
        description: "Specify the spacing unit between major tick marks along the numeric y-axis.",
        type: ["string", "number"]
      },
      y2AxisMajorTickInterval: {
        default: "auto",
        description: "Specify the spacing unit between major tick marks along the numeric y2-axis.",
        type: ["string", "number"]
      },
      // TODO(SCP-40274): Restrict string value to only 'auto' to achieve precise schema validation
      yAxisMax: {
        default: "auto",
        description: "Specify the maximum number for the visible y-axis range.",
        type: ["string", "number"]
      },
      // TODO(SCP-40274): Restrict string value to only 'auto' to achieve precise schema validation
      y2AxisMax: {
        default: "auto",
        description: "Specify the maximum number for the visible y2-axis range.",
        type: ["string", "number"]
      },
      // TODO(SCP-40274): Restrict string value to only 'auto' to achieve precise schema validation
      yAxisMin: {
        default: "auto",
        description: "Specify the minimum number for the visible y-axis range.",
        type: ["string", "number"]
      },
      // TODO(SCP-40274): Restrict string value to only 'auto' to achieve precise schema validation
      y2AxisMin: {
        default: "auto",
        description: "Specify the minimum number for the visible y2-axis range.",
        type: ["string", "number"]
      },
      yAxisScale: {
        default: "linear",
        description: "Specify the type of scale that applies to a numerical y-axis.",
        pattern: getPattern(["linear", "log"]),
        type: "string"
      },
      y2AxisScale: {
        default: "linear",
        description: "Specify the type of scale that applies to a numerical y2-axis.",
        pattern: getPattern(["linear", "log"]),
        type: "string"
      },
      // TODO: Figure out a way to explicitly support string value in addition to an array of strings
      // as UDF won't allow users to proceed if a string value is entered due to schema validation
      overlayFields: {
        description: "Specify field(s) that should be differentiated on the chart and displayed as chart overlays.",
        type: ["array", "string"],
        items: {
          type: "string"
        }
      },
      showOverlayY2Axis: {
        default: false,
        description: "Enable a y2-axis for chart overlays. All overlay fields will be mapped to a second y-axis.",
        type: "boolean"
      },
      showRoundedY2AxisLabels: {
        default: true,
        description: "Specify whether to round y2-axis values to the nearest integer.",
        type: "boolean"
      },
      y2Fields: {
        default: "> y2 | getField()",
        description: "Specify field(s) that should be mapped to a second y-axis.",
        type: ["array", "string"],
        items: {
          type: "string"
        }
      }
    });
    var linkGraphOptionsSchema = enhanceOptionsSchemaWithDynamicOptions({
      backgroundColor: {
        default: "> themes.defaultBackgroundColor",
        description: 'Specify the color for the background. You may use a dataSource to apply the color. The default for enterprise light is "#ffffff". The default for enterprise dark is "#000000". The default for prisma dark is "#0b0c0e".',
        pattern: COLOR_OR_TOKEN_PATTERN_WITH_RGBA,
        type: "string"
      },
      fieldOrder: {
        default: "> primary | getField()",
        description: "Specify the order of fields to be displayed in the link graph from left to right when loaded. Unspecified fields will be excluded from the graph.",
        type: "array",
        items: {
          type: "string"
        }
      },
      linkColor: {
        default: "#6d6f76",
        description: "Specify the color used for highlighted links. Non-highlighted links will be displayed at 20% opacity.",
        pattern: COLOR_OR_TOKEN_PATTERN_WITH_RGBA,
        type: "string"
      },
      linkWidth: {
        default: 1,
        description: "Specify, in pixels, the stroke width of each link.",
        type: "number"
      },
      nodeColor: {
        default: "> themes.defaultNodeColor",
        description: "Specify the color used for unhighlighted nodes.",
        pattern: COLOR_OR_TOKEN_PATTERN_WITH_RGBA,
        type: "string"
      },
      nodeTextColor: {
        description: "Specify the color used for unhighlighted nodes text.",
        pattern: COLOR_OR_TOKEN_PATTERN_WITH_RGBA,
        type: "string",
        default: "> nodeColor | maxContrast(nodeTextColorMaxContrast)"
      },
      nodeHeight: {
        default: 21,
        description: "Specify, in pixels, the height of each node.",
        type: "number"
      },
      nodeHighlightColor: {
        default: visualization_color_palettes_exports.VIZ_CATEGORICAL[0],
        description: "Specify the color used for highlighted nodes.",
        pattern: COLOR_OR_TOKEN_PATTERN_WITH_RGBA,
        type: "string"
      },
      nodeTextHighlightColor: {
        description: "Specify the color used for highlighted nodes text.",
        pattern: COLOR_OR_TOKEN_PATTERN_WITH_RGBA,
        type: "string",
        default: "> nodeHighlightColor | maxContrast(nodeHighlightTextColorMaxContrast)"
      },
      nodeSpacingX: {
        default: 32,
        description: "Specify, in pixels, the horizontal spacing between each node.",
        type: "number"
      },
      nodeSpacingY: {
        default: 18,
        description: "Specify, in pixels, the vertical spacing between each node.",
        type: "number"
      },
      nodeWidth: {
        default: 180,
        description: "Specify, in pixels, the width of each node.",
        type: "number"
      },
      resultLimit: {
        default: 50,
        description: "Specify the number of nodes rendered in each column.",
        type: "number"
      },
      showNodeCounts: {
        default: true,
        description: "Specify whether a count is shown for the number of nodes displayed in each column. The number of total nodes is also shown if there are hidden nodes.",
        type: "boolean"
      },
      showValueCounts: {
        default: true,
        description: "Specify whether a count is shown for the frequency of occurrence for each distinct node value.",
        type: "boolean"
      }
    });
    var mapOptionsSchema = enhanceOptionsSchemaWithDynamicOptions({
      backgroundColor: {
        default: "> themes.defaultBackgroundColor",
        description: 'Specify a color for the background. You might use a dataSource to apply the color. The default for enterprise light is "#FFFFFF". The default for enterprise dark is "#000000". The default for prisma dark is "#0B0C0E".',
        pattern: COLOR_OR_TOKEN_PATTERN_WITH_RGBA,
        type: "string"
      },
      baseLayerTileServer: {
        type: "string",
        description: "Specify the URL for the set of tiles that make up the base map."
      },
      baseLayerTileServerType: {
        type: "string",
        description: "Specify the type of tile set for the base map.",
        pattern: getPattern(["vector", "raster"])
      },
      center: {
        type: "array",
        description: "Specify the center of the map in coordinates, in the form of [latitude, longitude]. If you don’t provide coordinates, the map automatically centers, based on available location data. If there is no available location data, the center of the map defaults to [37.7749, -122.4194].",
        items: { type: "number" }
      },
      layers: {
        // The option merging of defaults and data binding with editing UI happens with the default defined below.
        // The inner defaults for properties within anyOf objects is used only for code intellisense in UDF to populate options.
        default: [
          {
            type: "bubble",
            latitude: '> primary | seriesByName("latitude")',
            longitude: '> primary | seriesByName("longitude")',
            seriesColors: visualization_color_palettes_exports.VIZ_CATEGORICAL,
            dataValues: '> primary | seriesByType("number")',
            dataColors: "",
            // default to an empty string to prioritize seriesColors
            bubbleSize: '> primary | frameWithoutSeriesNames("geobin", "latitude", "longitude") | frameBySeriesTypes("number")',
            additionalTooltipFields: [],
            resultLimit: 1e3
          },
          {
            type: "marker",
            latitude: '> primary | seriesByName("latitude")',
            longitude: '> primary | seriesByName("longitude")',
            seriesColors: visualization_color_palettes_exports.VIZ_CATEGORICAL,
            dataValues: '> primary | seriesByType("number")',
            dataColors: "",
            // default to an empty string to prioritize seriesColors
            additionalTooltipFields: [],
            resultLimit: 1e3
          },
          {
            type: "choropleth",
            areaIds: '> primary | seriesByType("string")',
            areaValues: '> primary | seriesByType("number")',
            dataColors: "> areaValues | gradient()",
            additionalTooltipFields: [],
            resultLimit: 1e3,
            choroplethEmptyAreaColor: "> themes.defaultChoroplethEmptyAreaColor",
            choroplethStrokeColor: "transparent",
            choroplethOpacity: 0.8
          }
        ],
        type: "array",
        description: "Specify the optional data visualization layers over the base map. If empty, only the base map appears.",
        items: {
          anyOf: [
            {
              type: "object",
              properties: {
                type: {
                  description: 'Specify the type of data layer method to display points on the map. For example, “bubble”, “marker”, or "choropleth".',
                  type: "string",
                  pattern: getPattern([
                    "marker",
                    "bubble",
                    "choropleth"
                    /* Choropleth */
                  ]),
                  default: "marker"
                  /* Marker */
                },
                latitude: {
                  description: 'Specify a dataSource series to apply latitude coordinates for data points displayed on the map. This applies to layers where type: "bubble" or type: "marker".',
                  type: ["string", "array"],
                  items: { type: "number" },
                  default: '> primary | seriesByName("latitude")'
                },
                longitude: {
                  description: 'Specify a dataSource series to apply longitude coordinates for data points displayed on the map. This applies to layers where type: "bubble" or type: "marker".',
                  type: ["string", "array"],
                  items: { type: "number" },
                  default: '> primary | seriesByName("longitude")'
                },
                seriesColors: {
                  description: 'Specify the colors to use for data points. If the dataColors option is specified, the seriesColors option is ignored. The seriesColors option applies to layers where type: "bubble" or type: "marker".',
                  type: "array",
                  items: {
                    type: "string",
                    pattern: COLOR_OR_TOKEN_PATTERN_WITH_RGBA
                  },
                  default: visualization_color_palettes_exports.VIZ_CATEGORICAL
                },
                dataColors: {
                  description: 'Specify the colors to use for data points. You can use an array of colors to be picked from, or you can use a dataSource to apply dynamic coloring. For example, “> primary | seriesByName("status") | matchValue(colorMatchConfig)”. When type: "choropleth", dataColors is defined by default, and the opacities are shown at 80% of maximum to allow textual information to be visible in the map. By default, the dataColors option is empty for "bubble" or "marker" layers to prioritize seriesColors. For "bubble" layers, dataColors requires bubbleSize to have a single series configured. If multiple series are set for bubbleSize, only the first pie slice reflects the colors.',
                  type: ["string", "array"],
                  items: { type: "string" },
                  default: ""
                },
                dataValues: {
                  description: 'Specify the data series used to encode colors for dynamic coloring in layers of type "marker" or "bubble".',
                  type: ["string", "array"],
                  items: { type: "number" },
                  default: '> primary | seriesByType("number")'
                },
                additionalTooltipFields: {
                  description: "Specify the fields to add to the default set of tooltips. Tooltips appear when you hover over data points. These fields and their corresponding values are shown in addition to the ones displayed by default.",
                  type: "array",
                  items: { type: "string" },
                  default: []
                },
                tooltipHeaderField: {
                  description: "Specify the field to add to the tooltip header. Tooltips appear when you hover over data points. Only the value of this field will be displayed as the header.",
                  type: "string"
                },
                resultLimit: {
                  description: "Specify the maximum number of data points to render on the map. Adjust the value to improve performance.",
                  type: "number",
                  default: 1e3
                }
              }
            },
            {
              type: "object",
              properties: {
                type: {
                  description: 'Specify the type of data layer method to display points on the map. For example, “bubble”, “marker”, or "choropleth".',
                  type: "string",
                  pattern: getPattern([
                    "marker",
                    "bubble",
                    "choropleth"
                    /* Choropleth */
                  ]),
                  default: "choropleth"
                  /* Choropleth */
                },
                areaIds: {
                  description: 'Specify a dataSource series to identify each area in the choropleth map layer. This applies to layers where type: "choropleth".',
                  type: "array",
                  items: { type: "string" },
                  default: '> primary | seriesByType("string")'
                },
                areaValues: {
                  description: 'Specify a dataSource series that indicates the values for the choropleth map areas. This applies to layers where type: "choropleth".',
                  type: "array",
                  items: { type: "number" },
                  default: '> primary | seriesByType("number")'
                },
                dataColors: {
                  description: 'Specify the colors to use for data points. You can use an array of colors to be picked from, or you can use a dataSource to apply dynamic coloring. For example, “> primary | seriesByName("status") | matchValue(colorMatchConfig)”. When type: "choropleth", dataColors is defined by default. By default, the dataColors option is not defined for type "bubble" or "marker".',
                  type: ["string", "array"],
                  items: { type: "string" },
                  default: "> areaValues | gradient()"
                },
                additionalTooltipFields: {
                  description: "Specify the fields to add to the default set of tooltips. Tooltips appear when you hover over data points. These fields and their corresponding values are shown in addition to the ones displayed by default.",
                  type: "array",
                  items: { type: "string" },
                  default: []
                },
                tooltipHeaderField: {
                  description: "Specify the field to add to the tooltip header. Tooltips appear when you hover over data points. Only the value of this field will be displayed as the header.",
                  type: "string"
                },
                resultLimit: {
                  description: "Specify the maximum number of data points to render on the map. Adjust the value to improve performance.",
                  type: "number",
                  default: 1e3
                },
                source: {
                  description: 'Source for the geodata for choropleth layer: "us" or "world", and will override data specified in the SPL geom command.',
                  pattern: getPattern(["geo://default/us", "geo://default/world"]),
                  type: "string"
                },
                choroplethEmptyAreaColor: {
                  description: 'Specify the color used for empty choropleth areas when "type": "choropleth", and will only work when "source" option is correctly configured.',
                  pattern: COLOR_OR_TOKEN_PATTERN_WITH_RGBA,
                  type: "string",
                  default: "> themes.defaultChoroplethEmptyAreaColor"
                },
                choroplethStrokeColor: {
                  description: 'Specify the stroke color for choropleth area outlines. The hex value format should be "#FFFFFF".',
                  pattern: COLOR_OR_TOKEN_PATTERN_WITH_RGBA,
                  type: "string",
                  default: "transparent"
                },
                choroplethOpacity: {
                  description: 'Specify the opacity of choropleth areas. Choose a number in the range of 0 - 1 (inclusive). You can also express the value as a percentage. For example, "0.8" in code or "80%" in UI.',
                  type: "number",
                  default: 0.8
                }
              }
            },
            {
              type: "object",
              properties: {
                type: {
                  description: 'Specify the type of data layer method to display points on the map. For example, “bubble”, “marker”, or "choropleth".',
                  type: "string",
                  pattern: getPattern([
                    "marker",
                    "bubble",
                    "choropleth"
                    /* Choropleth */
                  ]),
                  default: "bubble"
                  /* Bubble */
                },
                bubbleSize: {
                  description: 'Specify the data column to encode bubble size. This applies to layers where type: "bubble". If a single data column is specified, each bubble appears as a circle. When multiple columns are provided, bubbles are displayed as pie charts, with each slice representing a different column.',
                  type: ["string", "array"],
                  items: { type: "number" },
                  default: '> primary | frameWithoutSeriesNames("geobin", "latitude", "longitude") | frameBySeriesTypes("number")'
                },
                latitude: {
                  description: 'Specify a dataSource series to apply latitude coordinates for data points displayed on the map. This applies to layers where type: "bubble" or type: "marker".',
                  type: ["string", "array"],
                  items: { type: "number" },
                  default: '> primary | seriesByName("latitude")'
                },
                longitude: {
                  description: 'Specify a dataSource series to apply longitude coordinates for data points displayed on the map. This applies to layers where type: "bubble" or type: "marker".',
                  type: ["string", "array"],
                  items: { type: "number" },
                  default: '> primary | seriesByName("longitude")'
                },
                seriesColors: {
                  description: 'Specify the colors to use for data points. If the dataColors option is specified, the seriesColors option is ignored. The seriesColors option applies to layers where type: "bubble" or type: "marker".',
                  type: "array",
                  items: {
                    type: "string",
                    pattern: COLOR_OR_TOKEN_PATTERN_WITH_RGBA
                  },
                  default: visualization_color_palettes_exports.VIZ_CATEGORICAL
                },
                dataColors: {
                  description: 'Specify the colors to use for data points. You can use an array of colors to be picked from, or you can use a dataSource to apply dynamic coloring. For example, “> primary | seriesByName("status") | matchValue(colorMatchConfig)”. When type: "choropleth", dataColors is defined by default, and the opacities are shown at 80% of maximum to allow textual information to be visible in the map. By default, the dataColors option is empty for "bubble" or "marker" layers to prioritize seriesColors. For "bubble" layers, dataColors requires bubbleSize to have a single series configured. If multiple series are set for bubbleSize, only the first pie slice reflects the colors.',
                  type: ["string", "array"],
                  items: { type: "string" },
                  default: ""
                },
                dataValues: {
                  description: 'Specify the data series used to encode colors for dynamic coloring in layers of type "marker" or "bubble".',
                  type: ["string", "array"],
                  items: { type: "number" },
                  default: '> primary | seriesByType("number")'
                },
                additionalTooltipFields: {
                  description: "Specify the fields to add to the default set of tooltips. Tooltips appear when you hover over data points. These fields and their corresponding values are shown in addition to the ones displayed by default.",
                  type: "array",
                  items: { type: "string" },
                  default: []
                },
                tooltipHeaderField: {
                  description: "Specify the field to add to the tooltip header. Tooltips appear when you hover over data points. Only the value of this field will be displayed as the header.",
                  type: "string"
                },
                resultLimit: {
                  description: "Specify the maximum number of data points to render on the map. Adjust the value to improve performance.",
                  type: "number",
                  default: 1e3
                }
              }
            }
          ]
        }
      },
      scaleUnit: {
        default: "metric",
        type: "string",
        description: "Specify the scale unit to use.",
        pattern: getPattern(["metric", "imperial"])
      },
      showBaseLayer: {
        default: true,
        type: "boolean",
        description: "Specify if showing the base map."
      },
      showScale: {
        default: true,
        type: "boolean",
        description: "Specify whether to display the scale on the bottom left."
      },
      showZoomControls: {
        default: true,
        type: "boolean",
        description: "Specify whether to display the control panel of zoom on the top left."
      },
      zoom: {
        description: "Specify the zoom level of the map.",
        type: "number"
      },
      showCoordinates: {
        default: true,
        type: "boolean",
        description: "Specify whether to display coordinates (latitude and longitude) in the tooltip."
      },
      icon: {
        default: "",
        type: "string",
        description: 'Specify the url for an svg to display an icon inside bubbles for map. This applies to layers where type: "bubble".'
      }
    });
    var markdownOptionsSchema = enhanceOptionsSchemaWithDynamicOptions({
      backgroundColor: {
        description: 'Specify the background color using a Hex code such as "#FF0000".',
        type: "string",
        default: "transparent",
        pattern: COLOR_OR_TOKEN_PATTERN_WITH_RGBA
      },
      customFontSize: {
        description: "Specify the font size (in pixels) you would like to use for unformatted text when `fontSize` is set to `custom`. Header elements are calculated with the following formula: h1 = 2 × `customFontSize`, h2 = 1.5 × `customFontSize`, h3 = 1.25 × `customFontSize`",
        default: 14,
        type: "number"
      },
      fontColor: {
        description: 'Specify the text color using Hex codes or RGBA values, such as "#FF0000" or "rgba(25,12,13,0.1)". The default for enterprise light is "#3c444d". The default for enterprise dark is "#FFFFFF". The default for prisma dark is "rgba(255, 255, 255, 0.7)".',
        type: "string",
        default: "> themes.defaultFontColor",
        pattern: COLOR_OR_TOKEN_PATTERN_WITH_RGBA
      },
      fontFamily: {
        default: "Splunk Platform Sans",
        pattern: getPattern([
          "Splunk Platform Sans",
          "Splunk Data Sans",
          "Splunk Platform Mono",
          "Arial",
          "Helvetica",
          "Times New Roman",
          "Comic Sans MS"
        ]),
        description: 'Specify the font family you would like to use for markdown content, such as "Comic Sans MS". Note: the font needs to be available to your end user.',
        type: "string"
      },
      fontSize: {
        description: "Specify the font size you would like to use for markdown content. Font sizes range from extra small (10px for unformatted text) to extra large (18px for unformatted text) with the default being 14px for unformatted text.",
        type: "string",
        default: "default",
        pattern: getPattern(["extraSmall", "small", "default", "large", "extraLarge", "custom"])
      },
      markdown: {
        description: "Add text using basic markdown syntax.",
        type: "string"
      },
      rotation: {
        description: "Specify the angle of rotation of the markdown content in degrees.",
        type: "number",
        default: 0
      }
    });
    var markerGaugeOptionsSchema = enhanceOptionsSchemaWithDynamicOptions({
      backgroundColor: {
        description: 'Specify the color used for the background. The default for enterprise light is "#ffffff". The default for enterprise dark is "#000000". The default for prisma dark is "#0b0c0e".',
        type: "string",
        pattern: COLOR_OR_TOKEN_PATTERN_WITH_RGBA,
        default: "> themes.defaultBackgroundColor"
      },
      gaugeRanges: {
        description: 'Specify the overall range of the gauge as a series of continuous, color-coded subranges. For example, [{"from": 0, "to": 20, "value": "#4BEBA8"}, {"from": 20, "to": 50, "value": "#F4DF7A"}].',
        default: [
          { from: 0, to: 50, value: "#118832" },
          { from: 50, to: 90, value: "#CBA700" },
          { from: 90, to: 100, value: "#D41F1F" }
        ],
        type: "array",
        items: {
          type: "object",
          properties: {
            from: {
              type: "number",
              description: "Starting value for range."
            },
            to: {
              type: "number",
              description: "Ending value for range."
            },
            value: {
              description: "Color for sub range.",
              type: "string",
              pattern: COLOR_OR_TOKEN_PATTERN_WITH_RGBA
            }
          },
          required: ["from", "to", "value"],
          additionalProperties: false
        }
      },
      labelDisplay: {
        description: "Specify whether to display the labels as numbers, percentages, or off. The label center aligns to the value.",
        default: "number",
        type: "string",
        pattern: getPattern(["number", "percentage", "off"])
      },
      majorTickInterval: {
        description: "Specify, in pixels, the spacing between major tick marks.",
        default: "auto",
        type: ["string", "number"]
      },
      orientation: {
        description: "Specify the axis orientation of the gauge.",
        default: "vertical",
        type: "string",
        pattern: getPattern(["horizontal", "vertical"])
      },
      value: {
        description: "Specify the dataSource applied to the value of the marker gauge.",
        type: "string",
        default: '> primary | seriesByType("number") | lastPoint()'
      },
      valueDisplay: {
        description: "Specify whether to display the value as a number, percentage, or off.",
        default: "number",
        type: "string",
        pattern: getPattern(["number", "percentage", "off"])
      }
    });
    var parallelCoordinatesOptionsSchema = enhanceOptionsSchemaWithDynamicOptions({
      backgroundColor: {
        default: "> themes.defaultBackgroundColor",
        description: 'Specify the color used for the background. The default for enterprise light is "#FFFFFF". The default for enterprise dark is "#000000". The default for prisma dark is "#0b0c0e".',
        pattern: COLOR_OR_TOKEN_PATTERN_WITH_RGBA,
        type: "string"
      },
      lineColor: {
        default: visualization_color_palettes_exports.VIZ_CATEGORICAL[0],
        description: "Specify the dataSource color for the lines. The hex value format should be #FFFFFF.",
        pattern: COLOR_OR_TOKEN_PATTERN_WITH_RGBA,
        type: "string"
      },
      lineOpacity: {
        default: 0.5,
        description: 'Specify the opacity of the lines. Choose a number in the range of 0 - 1 (inclusive). You can also express the value as a percentage. For example, "0.50" in source or "50%" in UI.',
        type: "number"
      },
      showNullAxis: {
        default: true,
        description: "Select whether you would like to show or hide the null value axis.",
        type: "boolean"
      }
    });
    var pieOptionsSchema = enhanceOptionsSchemaWithDynamicOptions({
      backgroundColor: {
        default: "> themes.defaultBackgroundColor",
        description: 'Specify the color for the background. You may use a dataSource to apply the color. The default for enterprise light is "#ffffff". The default for enterprise dark is "#000000". The default for prisma dark is "#0b0c0e".',
        pattern: COLOR_OR_TOKEN_PATTERN_WITH_RGBA,
        type: "string"
      },
      collapseExcludeZero: {
        default: false,
        description: "Specify whether to exclude zeros and non-numeric values in the consolidated slice.",
        type: "boolean"
      },
      collapseLabel: {
        description: "Specify the label for the consolidated slice.",
        type: "string",
        default: "other"
      },
      collapseThreshold: {
        description: "Specify the size threshold as a number between 0 and 1 (inclusive), of the whole pie at which slices collapse into one consolidated slice.",
        type: "number",
        default: 0.01
      },
      label: {
        description: "List of string values to display the pie chart labels.",
        type: "array",
        items: {
          type: "string"
        },
        default: "> primary | seriesByIndex(0)"
      },
      labelField: {
        default: "> label | getField()",
        description: "Specify the field that corresponds to the labels.",
        type: "string"
      },
      labelDisplay: {
        description: "Specify whether to display the labels and/or slice percentages.",
        type: "string",
        pattern: getPattern(["values", "valuesAndPercentage", "off"]),
        default: "values"
      },
      resultLimit: {
        default: 5e4,
        description: "Specify the number of data points rendered in a chart.",
        type: "number"
      },
      seriesColors: {
        default: visualization_color_palettes_exports.VIZ_CATEGORICAL,
        description: 'Specify the colors used for a series. For example, ["#FF0000", "#0000FF", "#008000"].',
        type: "array",
        items: {
          type: "string"
        }
      },
      seriesColorsByField: {
        description: 'Specify the colors used for specific pie slice labels. For example: {"April": "#008000", "May": "#FFA500"}.',
        type: "object"
      },
      showDonutHole: {
        default: false,
        description: "Specify whether the pie should be a donut.",
        type: "boolean"
      },
      splitByLayout: {
        default: "off",
        description: "Specify the layout method by which to display the visualization, which splits the data into individual visualizations based on a certain category.",
        type: "string",
        pattern: getPattern([
          "off",
          "trellis"
          /* Trellis */
        ]),
        enum: [
          "off",
          "trellis"
          /* Trellis */
        ]
      },
      trellisBackgroundColor: {
        default: "> themes.defaultBackgroundColor",
        description: "Specify the color used for the trellis container background by using a hexadecimal code. For example, #0000FF.",
        pattern: COLOR_OR_TOKEN_PATTERN_WITH_RGBA,
        type: "string"
      },
      trellisColumns: {
        description: "Specify the number of visualizations to display in a given row of the trellis container. The remaining visualizations will wrap accordingly. If nothing is specified, it will be auto-set based on the trellisMinColumnWidth. The minimum value is 1.",
        type: "number",
        minimum: 1,
        default: 3
      },
      trellisMinColumnWidth: {
        default: 250,
        minimum: 1,
        description: "Specify the minimum width, in pixels, of each visualization in the trellis container. If the window or panel is resized, the remaining visualizations may be viewed by scrolling. The minimum value is 1.",
        type: "number"
      },
      trellisPageCount: {
        default: 20,
        minimum: 1,
        description: "Specify the maximum number of visualizations to display in a single page in the trellis container. The remaining visualizations will paginate accordingly. The minimum value is 1.",
        type: "number"
      },
      trellisRowHeight: {
        default: 180,
        minimum: 1,
        description: "Specify the height, in pixels, of each visualization in the trellis container. If the window or panel is resized, the remaining visualizations may be viewed by scrolling. The minimum value is 1.",
        type: "number"
      },
      trellisSplitBy: {
        description: "Specify the field name of the column with categories used, or “aggregations”, to split the data into individual visualizations for trellis display, if applicable.",
        type: "string"
      },
      value: {
        description: "List of numerical values to power the pie chart.",
        type: "array",
        items: {
          type: "number"
        },
        default: "> primary | seriesByIndex(1)"
      },
      valueField: {
        default: "> value | getField()",
        description: "Specify the field that corresponds to the data powering values.",
        type: "string"
      }
    });
    var punchcardOptionsSchema = enhanceOptionsSchemaWithDynamicOptions({
      x: {
        default: "> primary | seriesByIndex(0)",
        description: "Specify the dataSource applied to the x-axis.",
        type: "array",
        items: { type: ["string", "number"] }
      },
      y: {
        default: "> primary | seriesByIndex(1)",
        description: "Specify the dataSource applied to the y-axis.",
        type: "array",
        items: { type: ["string", "number"] }
      },
      category: {
        default: "> primary | seriesByIndex(3)",
        description: "Specify the dataSource to apply series categories.",
        type: "array",
        items: { type: ["string", "number"] }
      },
      size: {
        default: "> primary | seriesByIndex(2)",
        description: "Specify the dataSource to apply bubble size in the chart.",
        type: "array",
        items: { type: "number" }
      },
      xField: {
        default: "> x | getField()",
        description: "Specify the field that should be mapped to the x-axis.",
        type: "string"
      },
      yField: {
        default: "> y | getField()",
        description: "Specify the field that should be mapped to the y-axis.",
        type: "string"
      },
      categoryField: {
        default: "> category | getField()",
        description: "Specify the field that should be mapped to the series categories.",
        type: "string"
      },
      sizeField: {
        default: "> size | getField()",
        description: "Specify the field that should be mapped to the bubble size in the chart.",
        type: "string"
      },
      backgroundColor: {
        default: "> themes.defaultBackgroundColor",
        description: 'Specify the color used for the background. The default for enterprise light is "#ffffff". The default for enterprise dark is "#000000". The default for prisma dark is "#0b0c0e".',
        pattern: COLOR_OR_TOKEN_PATTERN_WITH_RGBA,
        type: "string"
      },
      bubbleColor: {
        default: "> size | gradient(bubbleColorConfig)",
        description: 'Specify the coloring method used for the bubbles when the colorMode “dynamic” is specified. For example “> size | gradient(bubbleColorConfig)".',
        type: ["string", "array"]
      },
      bubbleLabelDisplay: {
        default: "all",
        description: "Specify whether all bubble labels, the max value bubble labels, or none of the bubble labels should be displayed.",
        pattern: getPattern(["all", "max", "off"]),
        type: "string"
      },
      bubbleRadiusMax: {
        default: 15,
        description: "Specify the max radius (in pixels) of the bubbles when showDynamicBubbleSize option is false. Greater than 0.",
        type: "number"
      },
      bubbleRadiusMin: {
        default: 1,
        description: "Specify the min radius (in pixels) of the bubbles when showDynamicBubbleSize option is false. Greater than 0.",
        type: "number"
      },
      bubbleRowScale: {
        default: "global",
        description: "Specify how bubbles are scaled relative to other rows.",
        pattern: getPattern(["global", "row"]),
        type: "string"
      },
      bubbleSizeMax: {
        default: 1,
        description: "Specify the max percentage (in decimal format) of space a bubble should take up within a cell when showDynamicBubbleSize option is true. The number specified must be between 0 and 1.",
        type: "number"
      },
      bubbleSizeMin: {
        default: 0.25,
        description: "Specify the min percentage (in decimal format) of space a bubble should take up within a cell when showDynamicBubbleSize option is true. The number specified must be between 0 and 1.",
        type: "number"
      },
      bubbleSizeMethod: {
        default: "area",
        description: "Specify whether bubble area or diameter corresponds to the size value.",
        pattern: getPattern(["radius", "area"]),
        type: "string"
      },
      colorMode: {
        default: "dynamic",
        description: "Specify the coloring method used for the bubbles.",
        pattern: getPattern(["categorical", "dynamic"]),
        type: "string"
      },
      legendDisplay: {
        default: "right",
        description: "Specify the location of the legend on the panel.",
        pattern: getPattern(["right", "off"]),
        type: "string"
      },
      seriesColors: {
        default: visualization_color_palettes_exports.VIZ_CATEGORICAL,
        description: 'Specify the colors used for a series. For example, "#FF0000", "#0000FF", "#008000".',
        type: "array",
        items: {
          type: "string"
        }
      },
      showDefaultSort: {
        default: false,
        description: "Specify whether axes should be sorted based on order of time, digits and strings.",
        type: "boolean"
      },
      showDynamicBubbleSize: {
        default: true,
        description: "Specify whether the bubble size should be dynamic or fixed.",
        type: "boolean"
      },
      showMaxValuePulsation: {
        default: true,
        description: "Specify whether the max value bubble should pulsate.",
        type: "boolean"
      }
    });
    var rectangleOptionsSchema = enhanceOptionsSchemaWithDynamicOptions({
      fillColor: {
        default: "> themes.defaultFillColor",
        description: 'Specify the fill color. You may use a dataSource to apply the color. The hex value format should be "#FFFFFF". The default for enterprise light mode is "#C3CBD4". The default for enterprise dark mode is "#31373E". The default for prisma dark mode is "#0B0C0E".',
        type: "string"
      },
      fillOpacity: {
        description: 'Specify the opacity of the fill. Choose a number in the range of 0 - 1 (inclusive). You can also express the value as a percentage. For example, "0.80" in source or "80%" in UI.',
        type: "number",
        default: 1
      },
      rx: {
        description: "Specify the curvature of the horizontal corner (or border) radius with an integer or a percent greater than or equal to zero.",
        type: "number",
        default: 0
      },
      ry: {
        description: "Specify the curvature of the vertical corner (or border) radius with an integer or a percent greater than or equal to zero.",
        type: "number",
        default: "> rx"
      },
      strokeColor: {
        default: "> themes.defaultStrokeColor",
        description: 'Specify the stroke color. You may use a dataSource to apply the color. The hex value format should be "#FFFFFF". The default for enterprise light mode is "#3C444D". The default for enterprise dark mode is "#C3CBD4". The default for prisma dark mode is "#ACACAD".',
        type: "string"
      },
      strokeDashStyle: {
        description: "Specify the size, in pixels, of dashes and spaces used to create a custom stitched outline. The value you specify applies to both the dashes and the spaces between them.",
        type: "number",
        default: 0
      },
      strokeJoinStyle: {
        description: "Specifies the shape to be used at the corners of paths when they are joined.",
        type: "string",
        default: "miter",
        pattern: getPattern(["arcs", "bevel", "miter", "miter-clip", "round"])
      },
      strokeOpacity: {
        description: 'Specify the opacity of the stroke. Choose a number in the range of 0 - 1 (inclusive). You can also express the value as a percentage. For example, "0.80" in source or "80%" in UI.',
        type: "number",
        default: 1
      },
      strokeWidth: {
        description: "Specify the width of the stroke, in pixels. The minimum value is 0.",
        type: "number",
        default: 1
      }
    });
    var sankeyOptionsSchema = enhanceOptionsSchemaWithDynamicOptions({
      backgroundColor: {
        default: "> themes.defaultBackgroundColor",
        description: 'Specify the color for the background. You may use a dataSource to apply the color. The default for enterprise light is "#ffffff". The default for enterprise dark is "#000000". The default for prisma dark is "#0b0c0e".',
        pattern: COLOR_OR_TOKEN_PATTERN_WITH_RGBA,
        type: "string"
      },
      colorMode: {
        default: "categorical",
        description: 'Specify the coloring method used for the links. When set to "categorical" the nodes and links will be colored based on the "seriesColors". When set to "dynamic" the links will be colored based on the dynamic string assigned to "linkColors".',
        pattern: getPattern(["categorical", "dynamic"]),
        type: "string"
      },
      labelDisplay: {
        default: "off",
        description: "Specify whether to display the values and/or percentages of the nodes. Values are abbreviated to two decimal points, and a magnitude unit will be displayed. Percentages are calculated using the maximum node value as 100%. For very small nodes (with height < 24px) the values/percentage display is automatically turned off. ",
        pattern: getPattern(["values", "valuesAndPercentage", "percentage", "off"]),
        type: "string"
      },
      linkColors: {
        default: `> linkValues | rangeValue(linkColorRangeConfig)`,
        description: "Specify the coloring method used for the links when the colorMode “dynamic” is specified.",
        type: "array",
        items: {
          type: "string",
          pattern: COLOR_OR_TOKEN_PATTERN_WITH_RGBA
        }
      },
      linkOpacity: {
        default: 0.5,
        description: "Specify the opacity of the links. Choose a number in the range of 0 - 1 (inclusive).",
        type: "number"
      },
      linkValues: {
        default: `> primary | seriesByType('number')`,
        description: "Specify the dataSource to apply link width.",
        type: "string"
      },
      resultLimit: {
        default: 1e3,
        description: "Specify the maximum length of link data points rendered.",
        type: "number"
      },
      seriesColors: {
        default: visualization_color_palettes_exports.VIZ_CATEGORICAL,
        description: 'Specify the colors used for a series. For example, ["#FF0000", "#0000FF", "#008000"].',
        type: "array",
        items: {
          type: "string"
        }
      },
      unit: {
        description: 'Specify text to show on the left of the value in the node label when "labelDisplay" is set to either "values" or "valuesAndPercentage"',
        type: "string"
      }
    });
    var scatterOptionsSchema = enhanceOptionsSchemaWithDynamicOptions({
      x: {
        default: "> primary | seriesByIndex(0)",
        description: "Specify the dataSource applied to the x-axis.",
        type: "array",
        items: { type: ["string", "number"] }
      },
      y: {
        default: "> primary | seriesByIndex(1)",
        description: "Specify the dataSource applied to the y-axis.",
        type: "array",
        items: { type: ["string", "number"] }
      },
      category: {
        description: "Specify a sequence of dataSource events to be plotted on the chart.",
        type: "array",
        items: { type: ["string", "number"] },
        default: "> primary | seriesByIndex(2)"
      },
      xField: {
        default: "> x | getField()",
        description: "Specify the field that should be mapped to the x-axis.",
        type: "string"
      },
      yField: {
        default: "> y | getField()",
        description: "Specify the field that should be mapped to the y-axis.",
        type: "string"
      },
      categoryField: {
        default: "> category | getField()",
        description: "Specify the field that should be mapped to the series categories.",
        type: "string"
      },
      backgroundColor: {
        default: "> themes.defaultBackgroundColor",
        description: 'Specify the color used for the background. The default for enterprise light is "#ffffff". The default for enterprise dark is "#000000". The default for prisma dark is "#0b0c0e".',
        pattern: COLOR_OR_TOKEN_PATTERN_WITH_RGBA,
        type: "string"
      },
      legendDisplay: {
        description: "Specify the location of the legend on the panel. By default, legendDisplay is off when splitByLayout is trellis, and right otherwise. ",
        pattern: getPattern(["right", "left", "top", "bottom", "off"]),
        type: "string"
      },
      legendTruncation: {
        default: "ellipsisEnd",
        description: "Specify how to display legend labels when they overflow the layout boundaries by replacing overflow text with an ellipsis.",
        pattern: getPattern(["ellipsisEnd", "ellipsisMiddle", "ellipsisStart", "ellipsisOff"]),
        type: "string"
      },
      markerSize: {
        description: "Specify, in pixels, the size of each scatter marker.",
        type: "number",
        default: 4
      },
      resultLimit: {
        default: 5e4,
        description: "Specify the number of data points rendered in a chart.",
        type: "number"
      },
      seriesColors: {
        default: visualization_color_palettes_exports.VIZ_CATEGORICAL,
        description: 'Specify the colors used for a series. For example, ["#FF0000", "#0000FF", "#008000"].',
        type: "array",
        items: { type: "string" }
      },
      seriesColorsByField: {
        description: 'Specify the colors to use for specific categories, or series names, derived from distinct values in the selected category field. For example, {"user1": "#008000", "user2": "#FFA500"}.',
        type: "object"
      },
      showXAxisExtendedRange: {
        default: true,
        description: "Specify whether the x-axis should be extended to snap to whole major tick marks.",
        type: "boolean"
      },
      showYAxisExtendedRange: {
        default: true,
        description: "Specify whether the y-axis should be extended to snap to whole major tick marks.",
        type: "boolean"
      },
      showXAxisWithZero: {
        default: false,
        description: "Specify whether the x-axis range includes zero.",
        type: "boolean"
      },
      showYAxisWithZero: {
        default: false,
        description: "Specify whether the y-axis range includes zero.",
        type: "boolean"
      },
      showRoundedXAxisLabels: {
        default: false,
        description: "Specify whether to round x-axis values to the nearest integer.",
        type: "boolean"
      },
      // TODO: figure out if we want to change splunk-charting behavior for Bubble/Scatter, which hardcodes XMajorGridlines to false
      // showXMajorGridLines: {
      //     default: false,
      //     description: 'Specify whether major grid lines are visible on the x-axis.',
      //     type: 'boolean',
      // },
      showYMajorGridLines: {
        default: true,
        description: "Specify whether major grid lines are visible on the y-axis.",
        type: "boolean"
      },
      showXMinorGridLines: {
        default: false,
        description: "Specify whether minor grid lines are visible on the x-axis.",
        type: "boolean"
      },
      showYMinorGridLines: {
        default: false,
        description: "Specify whether minor grid lines are visible on the y-axis.",
        type: "boolean"
      },
      splitByLayout: {
        default: "off",
        description: "Specify the layout method by which to display the visualization, which splits the data into individual visualizations based on a certain category.",
        type: "string",
        pattern: getPattern([
          "off",
          "trellis"
          /* Trellis */
        ]),
        enum: [
          "off",
          "trellis"
          /* Trellis */
        ]
      },
      trellisBackgroundColor: {
        default: "> themes.defaultBackgroundColor",
        description: "Specify the color used for the trellis container background by using a hexadecimal code. For example, #0000FF.",
        pattern: COLOR_OR_TOKEN_PATTERN_WITH_RGBA,
        type: "string"
      },
      trellisColumns: {
        description: "Specify the number of visualizations to display in a given row of the trellis container. The remaining visualizations will wrap accordingly. If nothing is specified, it will be auto-set based on the trellisMinColumnWidth. The minimum value is 1.",
        type: "number",
        minimum: 1,
        default: 3
      },
      trellisMinColumnWidth: {
        default: 250,
        minimum: 1,
        description: "Specify the minimum width, in pixels, of each visualization in the trellis container. If the window or panel is resized, the remaining visualizations may be viewed by scrolling. The minimum value is 1.",
        type: "number"
      },
      trellisPageCount: {
        default: 20,
        minimum: 1,
        description: "Specify the maximum number of visualizations to display in a single page in the trellis container. The remaining visualizations will paginate accordingly. The minimum value is 1.",
        type: "number"
      },
      trellisRowHeight: {
        default: 180,
        minimum: 1,
        description: "Specify the height, in pixels, of each visualization in the trellis container. If the window or panel is resized, the remaining visualizations may be viewed by scrolling. The minimum value is 1.",
        type: "number"
      },
      trellisSharedScale: {
        default: true,
        type: "boolean",
        description: "Specify whether all visualizations will share the same scale in the trellis container."
      },
      trellisSplitBy: {
        description: "Specify the field name of the column with categories used, or “aggregations”, to split the data into individual visualizations for trellis display, if applicable. If a SPL `stats` command is used, this may default to the first string field.",
        type: "string"
      },
      xAxisLabelRotation: {
        default: 0,
        description: "Specify the rotation of the x-axis labels in degrees.",
        type: "number",
        enum: [-90, -45, 0, 45, 90]
      },
      xAxisAbbreviation: {
        default: "off",
        description: "Specify whether to abbreviate large x-axis values with the closest SI prefix.",
        enum: ["off", "auto"],
        pattern: getPattern(["auto", "off"]),
        type: "string"
      },
      yAxisAbbreviation: {
        default: "auto",
        description: "Specify whether to abbreviate large y-axis values with the closest SI prefix.",
        enum: ["off", "auto"],
        pattern: getPattern(["auto", "off"]),
        type: "string"
      },
      xAxisLabelVisibility: {
        default: "auto",
        description: "Specify whether to show or hide labels on the x-axis.",
        pattern: getPattern(["auto", "show", "hide"]),
        type: "string"
      },
      yAxisLabelVisibility: {
        default: "auto",
        description: "Specify whether to show or hide labels on the y-axis.",
        pattern: getPattern(["auto", "show", "hide"]),
        type: "string"
      },
      xAxisLineVisibility: {
        default: "hide",
        description: "Specify whether to show or hide the x-axis line.",
        enum: ["hide", "show"],
        pattern: getPattern(["show", "hide"]),
        type: "string"
      },
      yAxisLineVisibility: {
        default: "hide",
        description: "Specify whether to show or hide the y-axis line.",
        enum: ["hide", "show"],
        pattern: getPattern(["show", "hide"]),
        type: "string"
      },
      xAxisMajorTickInterval: {
        default: "auto",
        description: "Specify the spacing interval at which to place major tick marks along the numeric x-axis. By default, this value is automatically calculated based on the scale of the related axis.",
        type: ["string", "number"]
      },
      yAxisMajorTickInterval: {
        default: "auto",
        description: "Specify the spacing interval at which to place major tick marks along the numeric y-axis. By default, this value is automatically calculated based on the scale of the related axis.",
        type: ["string", "number"]
      },
      xAxisMajorTickSize: {
        default: 6,
        description: "Specify the size, in pixels, of major tick marks on the x-axis.",
        type: "number"
      },
      yAxisMajorTickSize: {
        default: 6,
        description: "Specify the size, in pixels, of major tick marks on the y-axis.",
        type: "number"
      },
      xAxisMinorTickSize: {
        default: 6,
        description: "Specify the size, in pixels, of minor tick marks on the x-axis.",
        type: "number"
      },
      yAxisMinorTickSize: {
        default: 6,
        description: "Specify the size, in pixels, of minor tick marks on the y-axis.",
        type: "number"
      },
      xAxisMajorTickVisibility: {
        default: "auto",
        description: "Specify whether to show or hide major tick marks on the x-axis.",
        pattern: getPattern(["auto", "show", "hide"]),
        type: "string"
      },
      yAxisMajorTickVisibility: {
        default: "auto",
        description: "Specify whether to show or hide major tick marks on the y-axis.",
        pattern: getPattern(["auto", "show", "hide"]),
        type: "string"
      },
      xAxisMinorTickVisibility: {
        default: "auto",
        description: "Specify whether to show or hide minor tick marks on the x-axis .",
        pattern: getPattern(["auto", "show", "hide"]),
        type: "string"
      },
      yAxisMinorTickVisibility: {
        default: "auto",
        description: "Specify whether to show or hide minor tick marks on the y-axis.",
        pattern: getPattern(["auto", "show", "hide"]),
        type: "string"
      },
      xAxisMax: {
        default: "auto",
        description: "Specify the maximum number for the range of the visible x-axis.",
        type: ["string", "number"]
      },
      yAxisMax: {
        default: "auto",
        description: "Specify the maximum number for the range of the visible y-axis.",
        type: ["string", "number"]
      },
      xAxisMin: {
        default: "auto",
        description: "Specify the minimum number for the range of the visible x-axis.",
        type: ["string", "number"]
      },
      yAxisMin: {
        default: "auto",
        description: "Specify the minimum number for the range of the visible y-axis.",
        type: ["string", "number"]
      },
      xAxisScale: {
        default: "linear",
        description: "Specify the type of scale that applies to a numerical x-axis.",
        pattern: getPattern(["linear", "log"]),
        type: "string"
      },
      yAxisScale: {
        default: "linear",
        description: "Specify the type of scale that applies to a numerical y-axis.",
        pattern: getPattern(["linear", "log"]),
        type: "string"
      },
      xAxisTitleText: {
        description: "Specify the title of the x-axis.",
        type: "string"
      },
      yAxisTitleText: {
        description: "Specify the title of the y-axis.",
        type: "string"
      },
      xAxisTitleVisibility: {
        default: "show",
        description: "Specify whether to show or hide the title of the x-axis.",
        enum: ["hide", "show"],
        pattern: getPattern(["show", "hide"]),
        type: "string"
      },
      yAxisTitleVisibility: {
        default: "show",
        description: "Specify whether to show or hide the title of the y-axis.",
        enum: ["hide", "show"],
        pattern: getPattern(["show", "hide"]),
        type: "string"
      }
    });
    var singleValueOptionsSchema = enhanceOptionsSchemaWithDynamicOptions({
      align: {
        default: "center",
        description: "Specify how to align the center content.",
        pattern: getPattern(["left", "center", "right"]),
        type: "string"
      },
      backgroundColor: {
        default: "> themes.defaultBackgroundColor",
        description: 'Specify the color for the background. You may use a dataSource to apply the color. The default for enterprise light is "#ffffff". The default for enterprise dark is "#000000". The default for prisma dark is "#0b0c0e".',
        pattern: COLOR_OR_TOKEN_PATTERN_WITH_RGBA,
        type: "string"
      },
      majorColor: {
        default: "> themes.defaultFontColor",
        description: 'Specify the color for the major value.  You may use a dataSource to apply the color. The hex value format should be “#FFFFFF”. The default for enterprise light is "#000000". The default for enterprise dark is "#ffffff". The default for prisma dark is "rgba(255, 255, 255, 0.98)".',
        pattern: COLOR_OR_TOKEN_PATTERN_WITH_RGBA,
        type: "string"
      },
      majorFontSize: {
        description: "Specify the font size (px) for the major value. By default the major value font size is calculated dynamically based on the available space.",
        type: "number"
      },
      majorValue: {
        default: "> sparklineValues|lastPoint()",
        description: "The raw value to display and used to calculate trendValue. It is not displayed if majorValueDisplay is specified.",
        type: ["string", "number"]
      },
      majorValueDisplay: {
        default: "> majorValue",
        description: "The formatted version of majorValue displayed in the visualization.",
        type: ["string", "number"]
      },
      majorValueField: {
        default: "> majorValue | getField()",
        description: "The field name of major value.",
        type: "string"
      },
      numberPrecision: {
        default: 0,
        maximum: 20,
        minimum: 0,
        description: "Specify the number of decimal places to display. For example, to display 3 decimal places, use a value of 3. Values can range from 0 to 20.",
        type: "number"
      },
      shouldAbbreviateTrendValue: {
        default: false,
        description: "Specify whether to abbreviate the trend value to 2 decimal points. A magnitude unit will be displayed.",
        type: "boolean"
      },
      shouldAbbreviateMajorValue: {
        default: false,
        description: "Specify whether to abbreviate the major value to 2 decimal points. A magnitude unit will be displayed.",
        type: "boolean"
      },
      shouldSparklineAcceptNullData: {
        default: true,
        description: "Specify whether to convert null and non-numeric values in the sparkline to 0.",
        type: "boolean"
      },
      shouldUseThousandSeparators: {
        default: true,
        description: "Specify whether numeric values use commas as thousandths separators.",
        type: "boolean"
      },
      showSparklineAreaGraph: {
        default: false,
        description: "Specify whether to show the sparkline as an area graph rather than a line.",
        type: "boolean"
      },
      showSparklineTooltip: {
        default: false,
        description: "Show a tooltip to display values on the sparkline.",
        type: "boolean"
      },
      splitByLayout: {
        default: "off",
        description: "Specify the layout method by which to display the visualization, which splits the data into individual visualizations based on a certain category.",
        type: "string",
        pattern: getPattern([
          "off",
          "trellis"
          /* Trellis */
        ]),
        enum: [
          "off",
          "trellis"
          /* Trellis */
        ]
      },
      sparklineAreaColor: {
        default: "> sparklineStrokeColor",
        description: "Specify the color for the sparkline area fill. You may use a dataSource to apply the color. The hex value format should be “#FFFFFF”. The graph area will have an opacity of 20% and will blend with the background color.",
        pattern: COLOR_OR_TOKEN_PATTERN_WITH_RGBA,
        type: "string"
      },
      sparklineDisplay: {
        default: "below",
        description: "Specify how to display a sparkline.",
        pattern: getPattern(["before", "after", "below", "off"]),
        type: "string"
      },
      sparklineHighlightDots: {
        default: 0,
        description: "Specify the number of markers, or dots, to display at the top of a sparkline area graph.",
        type: "number"
      },
      sparklineHighlightSegments: {
        default: 0,
        description: "Specify the number of segments to be highlighted at the top of a sparkline area graph.",
        type: "number"
      },
      sparklineStrokeColor: {
        default: "> themes.defaultSparklineStrokeColor",
        description: 'Specify the color for the sparkline stroke. You may use a dataSource to apply the color. The hex value format should be “#FFFFFF”. The default for enterprise light is "#000000". The default for enterprise dark is "#ffffff". The default for prisma dark is "rgba(255, 255, 255, 0.98)".',
        pattern: COLOR_OR_TOKEN_PATTERN_WITH_RGBA,
        type: "string"
      },
      sparklineValues: {
        default: '> primary|seriesByPrioritizedTypes("number", "string", "time")',
        description: "List of numerical values to display on a sparkline. If the values are string type, the sparkline will not be shown.",
        type: "array",
        items: { type: ["string", "number"] }
      },
      trendColor: {
        default: "> themes.defaultFontColor",
        description: 'Specify the color for the trend value. You may use a dataSource to apply the color. The hex value format should be “#FFFFFF”. The default for enterprise light is "#000000". The default for enterprise dark is "#ffffff". The default for prisma dark is "rgba(255, 255, 255, 0.98)".',
        pattern: COLOR_OR_TOKEN_PATTERN_WITH_RGBA,
        type: "string"
      },
      trendDisplay: {
        default: "absolute",
        description: "Specify how to display the trend value.",
        pattern: getPattern(["percent", "absolute", "off"]),
        type: "string"
      },
      trendFontSize: {
        description: "Specify the font size (px) for the trend value. By default the trend value font size is calculated dynamically based on the available space.",
        type: "number"
      },
      trendValue: {
        default: "> sparklineValues|delta(-2)",
        // todo: may need update delta method
        description: "The trend value to display in the visualization.",
        type: "number"
      },
      trellisBackgroundColor: {
        default: "> themes.defaultBackgroundColor",
        description: "Specify the color used for the trellis container background by using a hexadecimal code. For example, #0000FF.",
        pattern: COLOR_OR_TOKEN_PATTERN_WITH_RGBA,
        type: "string"
      },
      trellisColumns: {
        description: "Specify the number of visualizations to display in a given row of the trellis container. The remaining visualizations will wrap accordingly. If nothing is specified, it will be auto-set based on the trellisMinColumnWidth. The minimum value is 1.",
        type: "number",
        minimum: 1
      },
      trellisMinColumnWidth: {
        default: 100,
        minimum: 1,
        description: "Specify the minimum width, in pixels, of each visualization in the trellis container. If the window or panel is resized, the remaining visualizations may be viewed by scrolling. The minimum value is 1.",
        type: "number"
      },
      trellisPageCount: {
        default: 20,
        minimum: 1,
        description: "Specify the maximum number of visualizations to display in a single page in the trellis container. The remaining visualizations will paginate accordingly. The minimum value is 1.",
        type: "number"
      },
      trellisRowHeight: {
        default: 70,
        minimum: 1,
        description: "Specify the height, in pixels, of each visualization in the trellis container. If the window or panel is resized, the remaining visualizations may be viewed by scrolling. The minimum value is 1.",
        type: "number"
      },
      trellisSplitBy: {
        description: "Specify the field name of the column with categories used, or “aggregations”, to split the data into individual visualizations for trellis display, if applicable. If a SPL `timechart` command is used, this may default to the SPL `by` clause field. If a SPL `chart` command is used, this may default to the first string field.",
        type: "string"
      },
      underLabel: {
        description: "Specify the text that appears below the major value.",
        type: "string"
      },
      underLabelFontSize: {
        default: 12,
        description: "Specify the font size (px) for the under label text.",
        type: "number"
      },
      unit: {
        description: "Specify text to show next to the major value.",
        type: "string"
      },
      unitPosition: {
        default: "after",
        description: "Specify whether the unit text should appear before or after the major value.",
        pattern: getPattern(["before", "after"]),
        type: "string"
      }
    });
    var singleValueIconOptionsSchema = enhanceOptionsSchemaWithDynamicOptions({
      align: {
        default: "center",
        description: "Specify how to align the center content.",
        pattern: getPattern(["left", "center", "right"]),
        type: "string"
      },
      backgroundColor: {
        default: "transparent",
        description: "Specify the color for the background. You may use a dataSource to apply the color. The hex value format should be “#FFFFFF”.",
        pattern: COLOR_OR_TOKEN_PATTERN_WITH_RGBA,
        type: "string"
      },
      icon: {
        default: "default",
        description: "Specify an icon.",
        type: "string"
      },
      iconColor: {
        default: null,
        description: 'Specify the color for the icon. You may use a dataSource to apply the color. The hex value format should be “#FFFFFF”. The default for enterprise light is "#000000". The default for enterprise dark is "#ffffff". The default for prisma dark is "rgba(255, 255, 255, 0.98)".',
        pattern: COLOR_OR_TOKEN_PATTERN_WITH_RGBA,
        type: "string"
      },
      iconOpacity: {
        default: 1,
        description: "Specify the opacity for the icon using a number between 0 and 1 (inclusive).",
        type: "number"
      },
      iconPosition: {
        default: "before",
        description: "Specify where to display the icon in relation to the major value.",
        type: "string"
      },
      majorColor: {
        default: "> themes.defaultFontColor",
        description: 'Specify the color for the major value.  You may use a dataSource to apply the color. The hex value format should be “#FFFFFF”. The default for enterprise light is "#000000". The default for enterprise dark is "#ffffff". The default for prisma dark is "rgba(255, 255, 255, 0.98)".',
        pattern: COLOR_OR_TOKEN_PATTERN_WITH_RGBA,
        type: "string"
      },
      majorFontSize: {
        description: "Specify the font size (px) for the major value. By default the major value font size is calculated dynamically based on the available space.",
        type: "number"
      },
      majorValue: {
        default: '> primary|seriesByPrioritizedTypes("number", "string", "time")|lastPoint()',
        description: "The raw value to display and used to calculate trendValue. It is not displayed if majorValueDisplay is specified.",
        type: ["string", "number"]
      },
      majorValueDisplay: {
        default: "> majorValue",
        description: "The formatted version of majorValue displayed in the visualization.",
        type: ["string", "number"]
      },
      majorValueField: {
        default: "> majorValue | getField()",
        description: "The field name of major value.",
        type: "string"
      },
      numberPrecision: {
        default: 0,
        maximum: 20,
        minimum: 0,
        description: "Specify the number of decimal places to display. For example, to display 3 decimal places, use a value of 3. Values can range from 0 to 20.",
        type: "number"
      },
      shouldAbbreviateTrendValue: {
        default: false,
        description: "Specify whether to abbreviate the trend value to 2 decimal points. A magnitude unit will be displayed.",
        type: "boolean"
      },
      shouldAbbreviateMajorValue: {
        default: false,
        description: "Specify whether to abbreviate the major value to 2 decimal points. A magnitude unit will be displayed.",
        type: "boolean"
      },
      shouldUseThousandSeparators: {
        default: true,
        description: "Specify whether numeric values use commas as thousandths separators.",
        type: "boolean"
      },
      showValue: {
        default: true,
        description: "Specify whether to enable or disable the value and trend indicator displays.",
        type: "boolean"
      },
      splitByLayout: {
        default: "off",
        description: "Specify the layout method by which to display the visualization, which splits the data into individual visualizations based on a certain category.",
        type: "string",
        pattern: getPattern([
          "off",
          "trellis"
          /* Trellis */
        ]),
        enum: [
          "off",
          "trellis"
          /* Trellis */
        ]
      },
      trendColor: {
        default: "> themes.defaultFontColor",
        description: 'Specify the color for the trend value. You may use a dataSource to apply the color. The hex value format should be “#FFFFFF”. The default for enterprise light is "#000000". The default for enterprise dark is "#ffffff". The default for prisma dark is "rgba(255, 255, 255, 0.98)".',
        pattern: COLOR_OR_TOKEN_PATTERN_WITH_RGBA,
        type: "string"
      },
      trendDisplay: {
        default: "absolute",
        description: "Specify whether the trend value is displayed as a percentage or an absolute count.",
        pattern: getPattern(["off", "percent", "absolute"]),
        type: "string"
      },
      trendFontSize: {
        description: "Specify the font size (px) for the trend value. By default the trend value font size is calculated dynamically based on the available space.",
        type: "number"
      },
      trendValue: {
        default: '> primary|seriesByPrioritizedTypes("number", "string", "time")|delta(-2)',
        // todo: may need update delta method
        description: "The trend value to display in the visualization.",
        type: "number"
      },
      trellisBackgroundColor: {
        default: "> themes.defaultBackgroundColor",
        description: "Specify the color used for the trellis container background by using a hexadecimal code. For example, #0000FF.",
        pattern: COLOR_OR_TOKEN_PATTERN_WITH_RGBA,
        type: "string"
      },
      trellisColumns: {
        description: "Specify the number of visualizations to display in a given row of the trellis container. The remaining visualizations will wrap accordingly. If nothing is specified, it will be auto-set based on the trellisMinColumnWidth. The minimum value is 1.",
        type: "number",
        minimum: 1
      },
      trellisMinColumnWidth: {
        default: 100,
        minimum: 1,
        description: "Specify the minimum width, in pixels, of each visualization in the trellis container. If the window or panel is resized, the remaining visualizations may be viewed by scrolling. The minimum value is 1.",
        type: "number"
      },
      trellisPageCount: {
        default: 20,
        minimum: 1,
        description: "Specify the maximum number of visualizations to display in a single page in the trellis container. The remaining visualizations will paginate accordingly. The minimum value is 1.",
        type: "number"
      },
      trellisRowHeight: {
        default: 70,
        minimum: 1,
        description: "Specify the height, in pixels, of each visualization in the trellis container. If the window or panel is resized, the remaining visualizations may be viewed by scrolling. The minimum value is 1.",
        type: "number"
      },
      trellisSplitBy: {
        description: "Specify the field name of the column with categories used, or “aggregations”, to split the data into individual visualizations for trellis display, if applicable. If a SPL `timechart` command is used, this may default to the SPL `by` clause field. If a SPL `chart` command is used, this may default to the first string field.",
        type: "string"
      },
      underLabel: {
        description: "Specify the text that appears below the major value.",
        type: "string"
      },
      unit: {
        description: "Specify text to show next to the major value.",
        type: "string"
      },
      unitPosition: {
        default: "after",
        description: "Specify whether the unit text should appear before or after the major value.",
        pattern: getPattern(["before", "after"]),
        type: "string"
      }
    });
    var singleValueRadialOptionsSchema = enhanceOptionsSchemaWithDynamicOptions({
      backgroundColor: {
        default: "> themes.defaultBackgroundColor",
        description: 'Specify the color for the background. The hex value format should be “#ffffff”. The default for enterprise light is "#ffffff". The default for enterprise dark is "#000000". The default for prisma dark is "#0b0c0e".',
        pattern: COLOR_OR_TOKEN_PATTERN_WITH_RGBA,
        type: "string"
      },
      gaugeRanges: {
        default: "> majorColorEditorConfig",
        description: 'Specify the overall range of the gauge as a series of continuous, color-coded subranges. For example, [{"to": 20, "value": "#4BEBA8"}, {"from": 20, "to": 50, "value": "#D41F1F"}, {"from": 50, "value": "#F4DF7A"}]. Must be unbounded, open ranges. Ranges are bound by a separate minValue/maxValue option. Only configured if isGaugeOn is true.',
        type: "array",
        items: {
          type: "object",
          properties: {
            from: {
              type: "number"
            },
            to: {
              type: "number"
            },
            value: {
              type: "string",
              pattern: COLOR_OR_TOKEN_PATTERN_WITH_RGBA
            }
          }
        }
      },
      isGaugeOn: {
        default: false,
        description: "Specify if gauge is on.",
        type: "boolean"
      },
      majorColor: {
        default: "> themes.defaultFontColor",
        description: 'Specify the color for the major value. You may use a dataSource to apply the color. The hex value format should be “#ffffff”. The default for enterprise light is "#000000". The default for enterprise dark is "#ffffff". The default for prisma dark is "rgba(255, 255, 255, 0.98)".',
        pattern: COLOR_OR_TOKEN_PATTERN_WITH_RGBA,
        type: "string"
      },
      majorValue: {
        default: '> primary | seriesByPrioritizedTypes("number", "string", "time") | lastPoint()',
        description: "The raw value to display and used to calculate trendValue. It is not displayed if majorValueDisplay is specified.",
        type: ["string", "number"]
      },
      majorValueDisplay: {
        default: "> majorValue",
        description: "The formatted version of majorValue displayed in the visualization.",
        type: ["string", "number"]
      },
      majorValueField: {
        default: "> majorValue | getField()",
        description: "Specify the field that should be mapped to the major value.",
        type: "string"
      },
      minValue: {
        default: 0,
        description: "Specify the min value of the radial.",
        type: "number"
      },
      maxValue: {
        default: 100,
        description: "Specify the value the radial fills up to.",
        type: "number"
      },
      numberPrecision: {
        default: 0,
        maximum: 20,
        minimum: 0,
        description: "Specify the number of decimal places to display. For example, to display 3 decimal places, use a value of 3. Values can range from 0 to 20.",
        type: "number"
      },
      radialBackgroundColor: {
        default: "> themes.defaultRadialBackgroundColor",
        description: 'Specify the color for the radial background. The hex value format should be “#ffffff”. The default for enterprise light is "rgba(0, 0, 0, 0.1)". The default for enterprise dark is "rgba(255, 255, 255, 0.15)". The default for prisma dark is "rgba(255, 255, 255, 0.15)".',
        pattern: COLOR_OR_TOKEN_PATTERN_WITH_RGBA,
        type: "string"
      },
      radialStrokeColor: {
        default: "> majorColor",
        description: 'Specify the color for the radial. You may use a dataSource to apply the color. The hex value format should be “#ffffff”. The default for enterprise light is "#000000". The default for enterprise dark is "#ffffff". The default for prisma dark is "rgba(255, 255, 255, 0.98)".',
        pattern: COLOR_OR_TOKEN_PATTERN_WITH_RGBA,
        type: "string"
      },
      shouldAbbreviateTrendValue: {
        default: false,
        description: "Specify whether to abbreviate the trend value to 2 decimal points. A magnitude unit will be displayed.",
        type: "boolean"
      },
      shouldAbbreviateMajorValue: {
        default: false,
        description: "Specify whether to abbreviate the major value to 2 decimal points. A magnitude unit will be displayed.",
        type: "boolean"
      },
      shouldUseThousandSeparators: {
        default: true,
        description: "Specify whether numeric values use commas as thousandths separators.",
        type: "boolean"
      },
      splitByLayout: {
        default: "off",
        description: "Specify the layout method by which to display the visualization, which splits the data into individual visualizations based on a certain category.",
        type: "string",
        pattern: getPattern([
          "off",
          "trellis"
          /* Trellis */
        ]),
        enum: [
          "off",
          "trellis"
          /* Trellis */
        ]
      },
      trendColor: {
        default: "> themes.defaultFontColor",
        description: 'Specify the color for the trend value. You may use a dataSource to apply the color. The hex value format should be “#FFFFFF”. The default for enterprise light is "#000000". The default for enterprise dark is "#ffffff". The default for prisma dark is "rgba(255, 255, 255, 0.98)".',
        pattern: COLOR_OR_TOKEN_PATTERN_WITH_RGBA,
        type: "string"
      },
      trendDisplay: {
        default: "absolute",
        description: "Specify how to display the trend value.",
        pattern: getPattern(["percent", "absolute", "off"]),
        type: "string"
      },
      trendValue: {
        default: '> primary | seriesByPrioritizedTypes("number", "string", "time") | delta(-2)',
        // todo: may need update delta method
        description: "Specify the dataSource applied to the trend value.",
        type: "number"
      },
      trellisBackgroundColor: {
        default: "> themes.defaultBackgroundColor",
        description: "Specify the color used for the trellis container background by using a hexadecimal code. For example, #0000FF.",
        pattern: COLOR_OR_TOKEN_PATTERN_WITH_RGBA,
        type: "string"
      },
      trellisColumns: {
        description: "Specify the number of visualizations to display in a given row of the trellis container. The remaining visualizations will wrap accordingly. If nothing is specified, it will be auto-set based on the trellisMinColumnWidth. The minimum value is 1.",
        type: "number",
        minimum: 1
      },
      trellisMinColumnWidth: {
        default: 120,
        minimum: 1,
        description: "Specify the minimum width, in pixels, of each visualization in the trellis container. If the window or panel is resized, the remaining visualizations may be viewed by scrolling. The minimum value is 1.",
        type: "number"
      },
      trellisPageCount: {
        default: 20,
        minimum: 1,
        description: "Specify the maximum number of visualizations to display in a single page in the trellis container. The remaining visualizations will paginate accordingly. The minimum value is 1.",
        type: "number"
      },
      trellisRowHeight: {
        default: 100,
        minimum: 1,
        description: "Specify the height, in pixels, of each visualization in the trellis container. If the window or panel is resized, the remaining visualizations may be viewed by scrolling. The minimum value is 1.",
        type: "number"
      },
      trellisSplitBy: {
        description: "Specify the field name of the column with categories used, or “aggregations”, to split the data into individual visualizations for trellis display, if applicable. If a SPL `timechart` command is used, this may default to the SPL `by` clause field. If a SPL `chart` command is used, this may default to the first string field.",
        type: "string"
      },
      underLabel: {
        description: "Specify the text that appears below the major value.",
        type: "string"
      },
      unit: {
        description: "Specify text to show next to the major value.",
        type: "string"
      },
      unitPosition: {
        default: "after",
        description: "Specify whether the unit text should appear before or after the major value.",
        pattern: getPattern(["before", "after"]),
        type: "string"
      }
    });
    var tableOptionsSchema = enhanceOptionsSchemaWithDynamicOptions({
      backgroundColor: {
        default: "> themes.defaultBackgroundColor",
        description: 'Specify the color for the background. You might use a data source to apply the color. The default for enterprise light is "#FFFFFF". The default for enterprise dark is "#000000". The default for prisma dark is "#0B0C0E".',
        pattern: COLOR_OR_TOKEN_PATTERN_WITH_RGBA,
        type: "string"
      },
      columnFormat: {
        description: "Lets you format an individual column in a table. Specify a column in a table as a field, followed by a property. For more information, see the Column Format Align - Left example on the Examples page.",
        type: "object",
        patternProperties: {
          ".*": {
            description: "Customization for column property",
            type: "object",
            properties: {
              align: {
                description: 'Specify the alignment for the whole column. Valid alignments include "left", "center", and "right". You can also pass an array to specify the alignment of each cell. When set to "auto", the column will use the same configuration as tableFormat.align.',
                type: ["string", "array"],
                items: {
                  type: "string",
                  enum: validColumnAlignments.concat()
                },
                default: "auto"
              },
              cellTypes: {
                description: 'Specify how to render data in cells. Valid cell renders include "TextCell", "ArrayCell", "SparklineCell".',
                type: "array",
                items: {
                  type: "string",
                  enum: validCellRenderers.concat()
                }
              },
              data: {
                description: "Specify data points to be displayed in the cells of a column.",
                type: "array",
                items: {
                  oneOf: [
                    { type: "string" },
                    { type: "number" },
                    {
                      type: "array",
                      items: { type: ["string", "number"] }
                    }
                  ]
                }
              },
              headerAlign: {
                description: 'Specify the header alignment for the whole column. Valid alignments include "left", "center", and "right".  When set to "auto", the column will use the same configuration as tableFormat.headerAlign',
                type: "string",
                default: "auto",
                pattern: getPattern(validColumnAlignments)
              },
              rowBackgroundColors: {
                description: 'Specify a list of colors, in hexadecimal code, for the background color of each column of the table. For example, ["#2C333B", "32373D"].',
                type: "array",
                items: {
                  type: "string",
                  pattern: COLOR_OR_TOKEN_PATTERN_WITH_RGBA
                }
              },
              rowColors: {
                description: 'Specify a list of colors, in hexadecimal code, for the text color of the cells of a column. For example, ["#2C333B", "32373D"].',
                type: "array",
                items: {
                  type: "string",
                  pattern: COLOR_OR_TOKEN_PATTERN_WITH_RGBA
                }
              },
              sparklineAreaColors: {
                description: 'Specify a list of colors, in hexadecimal code, for the sparkline area of each column. For example, ["#2C333B", "32373D"].',
                type: "array",
                items: {
                  type: "string",
                  pattern: COLOR_OR_TOKEN_PATTERN_WITH_RGBA
                }
              },
              sparklineColors: {
                description: 'Specify a list of colors, in hexadecimal code, for the sparkline stroke of each column. For example, ["#2C333B", "32373D"].',
                type: "array",
                items: {
                  type: "string",
                  pattern: COLOR_OR_TOKEN_PATTERN_WITH_RGBA
                }
              },
              sparklineTypes: {
                description: 'Choose either area or line formatting for the Sparkline. Valid sparkline types include "line" and "area".',
                type: "array",
                items: {
                  type: "string",
                  enum: validSparklineTypes.concat()
                }
              },
              textOverflow: {
                description: 'Controls how the text should be truncated within a particular column. Valid types include "anywhere", "break-word", "ellipsis".  Columns are "break-word" styled by default when "textOverflow" is not configured.',
                type: "string",
                pattern: getPattern(validTextOverflows)
              },
              width: {
                description: "Specify, in pixels, the width of the column. The default displays a minimum width of at least 90, unless the table needs to filled further. The minimum width is 30px.",
                type: "number",
                minimum: 30
              }
            }
          }
        }
      },
      count: {
        description: "Specify the maximum number of rows to display.",
        type: "number",
        default: 10
      },
      font: {
        default: "proportional",
        description: "Specify the font style to use for table content.",
        type: "string",
        pattern: getPattern(["proportional", "monospace"])
      },
      fontSize: {
        default: "default",
        description: "Specify the font size to use for table content. Font sizes range from extra small (10px) to large (16px) with the default being 14px.",
        type: "string",
        pattern: getPattern(validFontSizes)
      },
      headers: {
        default: "> table | getField()",
        description: "Specify an array of headers to display on the table. Though these can be statically listed, it's best to use the dynamic default, as it will return the fields of your search.",
        type: "array",
        items: {
          type: "string"
        }
      },
      headerVisibility: {
        default: "inline",
        description: "Specify how to display the table header row.",
        pattern: getPattern(validHeaderVisibilities),
        enum: validHeaderVisibilities.concat(),
        type: "string"
      },
      paginateDataSourceKey: {
        default: "primary",
        description: "Specify the data source key for pagination and sorting.",
        type: "string"
      },
      showFooterPercentages: {
        default: false,
        description: "Specify whether to show a row at the bottom of the table that displays percentage values for applicable columns.",
        type: "boolean"
      },
      showFooterTotals: {
        default: false,
        description: "Specify whether to show a row at the bottom of the table that displays total values for applicable columns.",
        type: "boolean"
      },
      showInternalFields: {
        default: true,
        description: "Specify whether to show internal fields that start with an underscore. The _time field will still be shown if false.",
        type: "boolean"
      },
      showRowNumbers: {
        default: false,
        description: "Show row numbers in the first column.",
        type: "boolean"
      },
      table: {
        default: "> primary",
        description: "Two dimensional array of data to be displayed in the table.",
        type: "array",
        items: {
          type: "array",
          items: {
            oneOf: [
              { type: "string" },
              { type: "number" },
              { type: "array", items: { type: ["string", "number"] } }
            ]
          }
        }
      },
      tableFormat: {
        description: "Lets you set global options for a table.",
        type: "object",
        properties: {
          align: {
            default: "> table | type() | matchValue(tableAlignByType)",
            description: 'Specify alignment for the whole table. Valid alignments include "left", "center", and "right". You can also pass a 2 dimensional array to specify the alignment of each cell. By default, the table will be aligned by type.',
            type: ["string", "array"],
            items: {
              type: "array",
              items: {
                type: "string",
                enum: validAlignments.concat()
              }
            }
          },
          cellTypes: {
            default: "> table | type() | matchValue(tableCellTypeByType)",
            description: 'Specify how to render data in cells. Valid cell renders include "TextCell", "ArrayCell", "SparklineCell".',
            type: "array",
            items: {
              type: "array",
              items: {
                type: "string",
                enum: validCellRenderers.concat()
              }
            }
          },
          data: {
            description: "Two dimensional data to be displayed in the table. This is usually formatted data instead of raw data from search.",
            type: "array",
            items: {
              type: "array",
              items: {
                oneOf: [
                  { type: "string" },
                  { type: "number" },
                  {
                    type: "array",
                    items: { type: ["string", "number"] }
                  }
                ]
              }
            }
          },
          headerAlign: {
            description: 'Specify the header alignment for the whole table. Valid alignments include "left", "center", and "right".',
            type: "string",
            default: "left",
            pattern: getPattern(validAlignments)
          },
          headerBackgroundColor: {
            default: "> themes.defaultHeaderBackgroundColor",
            description: 'Specify the table header background color using a hexadecimal code. For example, "#FFFFFF".',
            pattern: COLOR_OR_TOKEN_PATTERN_WITH_RGBA,
            type: "string"
          },
          headerColor: {
            description: 'Specify the table header text color using a hexadecimal code. For example, "#FFFFFF".',
            pattern: COLOR_OR_TOKEN_PATTERN_WITH_RGBA,
            type: "string"
          },
          rowBackgroundColors: {
            default: "> table | seriesByIndex(0) | pick(tableAltRowBackgroundColorsByTheme)",
            description: 'Specify a list of colors, in hexadecimal code, for the background color of each row of the table. For example, ["#2C333B", "32373D"].',
            type: "array",
            items: {
              type: "array",
              items: {
                type: "string",
                pattern: COLOR_OR_TOKEN_PATTERN_WITH_RGBA
              }
            }
          },
          rowColors: {
            description: 'Specify a list of colors, in hexadecimal code, for the text color of each row of the table. For example, ["#2C333B", "32373D"].',
            type: "array",
            items: {
              type: "array",
              items: {
                type: "string",
                pattern: COLOR_OR_TOKEN_PATTERN_WITH_RGBA
              }
            }
          },
          sparklineAreaColors: {
            description: 'Specify a list of colors, in hexadecimal code, for the sparkline area of each row of the table. For example, ["#2C333B", "32373D"].',
            type: "array",
            items: {
              type: "array",
              items: {
                type: "string",
                pattern: COLOR_OR_TOKEN_PATTERN_WITH_RGBA
              }
            }
          },
          sparklineColors: {
            description: 'Specify a list of colors, in hexadecimal code, for the sparkline stroke of each row of the table. For example, ["#2C333B", "32373D"].',
            type: "array",
            items: {
              type: "array",
              items: {
                type: "string",
                pattern: COLOR_OR_TOKEN_PATTERN_WITH_RGBA
              }
            }
          },
          sparklineTypes: {
            description: "Choose either area or line formatting for the Sparkline.",
            type: "array",
            items: {
              type: "array",
              items: {
                type: "string",
                enum: validSparklineTypes.concat()
              }
            }
          },
          textOverflow: {
            description: 'Specify the text overflow for the whole column. Valid overflows include "break-word", "anywhere", and "ellipsis".',
            type: "string",
            default: "break-word",
            pattern: getPattern(validTextOverflows)
          }
        }
      }
    });
    var timelineOptionsSchema = enhanceOptionsSchemaWithDynamicOptions({
      x: {
        default: '> primary | seriesByType("time")',
        description: "Specify the data source applied to the x-axis.",
        type: "array",
        items: { type: ["string", "number"] }
      },
      y: {
        default: '> primary | seriesByPrioritizedTypes("string", "number")',
        description: "Specify the data source applied to the y-axis.",
        type: "array",
        items: { type: ["string", "number"] }
      },
      duration: {
        default: '> primary | seriesByPrioritizedTypes("number", "time")',
        description: "Specify the data source to apply duration to events. This will display events over a length of time as a bar rather than a circle.",
        type: "array",
        items: { type: ["string", "number"] }
      },
      category: {
        default: '> primary| seriesByName("category")',
        description: "Specify the data source to apply series categories. This will color events in distinct categories.",
        type: "array",
        items: { type: ["string", "number"] }
      },
      xField: {
        default: "> x | getField()",
        description: "Specify the field that should be mapped to the x-axis.",
        type: "string"
      },
      yField: {
        default: "> y | getField()",
        description: "Specify the field that should be mapped to the y-axis.",
        type: "string"
      },
      durationField: {
        default: "> duration | getField()",
        description: "Specify the field that should be mapped to the x-axis.",
        type: "string"
      },
      categoryField: {
        default: "> category | getField()",
        description: "Specify the field that should be mapped to the y-axis.",
        type: "string"
      },
      additionalTooltipFields: {
        default: [],
        description: "Specify the fields to add to the default set of tooltips. Tooltips appear when you hover over events. These fields and their corresponding values are shown in addition to the ones displayed by default.",
        type: "array",
        items: { type: "string" }
      },
      backgroundColor: {
        default: "> themes.defaultBackgroundColor",
        description: 'Specify the color for the background. You may use a data source to apply the color. The default for enterprise light is "#ffffff". The default for enterprise dark is "#000000". The default for prisma dark is "#0b0c0e".',
        pattern: COLOR_OR_TOKEN_PATTERN_WITH_RGBA,
        type: "string"
      },
      dataColors: {
        description: 'Specify the colors to use for events. You can use an array of colors to be picked from, or you can use a data source to apply dynamic coloring. For example, “> primary | seriesByName("count") | rangeValue(lowToHigh)”. By default, the dataColors option is not defined and seriesColors is used for categorical coloring.',
        type: ["string", "array"],
        items: { type: "string" }
      },
      legendDisplay: {
        default: "off",
        description: "Specify the location of the legend on the panel.",
        pattern: getPattern(["right", "bottom", "off"]),
        type: "string"
      },
      legendTruncation: {
        default: "ellipsisEnd",
        description: "Specify how to display legend labels when they overflow the layout boundaries by replacing overflow text with an ellipsis.",
        pattern: getPattern(["ellipsisEnd", "ellipsisMiddle", "ellipsisStart", "ellipsisOff"]),
        type: "string"
      },
      resultLimit: {
        default: 1e4,
        description: "Specify the maximum number of events to render on the timeline. Adjust the value to improve performance.",
        type: "number"
      },
      seriesColors: {
        default: visualization_color_palettes_exports.VIZ_CATEGORICAL,
        description: 'Specify the colors used for a series. For example, ["#FF0000", "#0000FF", "#008000"].',
        type: "array",
        items: { type: "string" }
      },
      yAxisLabelWidth: {
        default: 100,
        description: "Specify the width, in pixels, for y-axis labels.",
        type: "number"
      }
    });
  }
});

// node_modules/chroma-js/dist/chroma.cjs
var require_chroma = __commonJS({
  "node_modules/chroma-js/dist/chroma.cjs"(exports2, module2) {
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? module2.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, global2.chroma = factory());
    })(exports2, (function() {
      "use strict";
      function limit(x, low, high) {
        if (low === void 0) low = 0;
        if (high === void 0) high = 1;
        return min$3(max$3(low, x), high);
      }
      function clip_rgb(rgb2) {
        rgb2._clipped = false;
        rgb2._unclipped = rgb2.slice(0);
        for (var i2 = 0; i2 <= 3; i2++) {
          if (i2 < 3) {
            if (rgb2[i2] < 0 || rgb2[i2] > 255) {
              rgb2._clipped = true;
            }
            rgb2[i2] = limit(rgb2[i2], 0, 255);
          } else if (i2 === 3) {
            rgb2[i2] = limit(rgb2[i2], 0, 1);
          }
        }
        return rgb2;
      }
      var classToType = {};
      for (var i$1 = 0, list$1 = [
        "Boolean",
        "Number",
        "String",
        "Function",
        "Array",
        "Date",
        "RegExp",
        "Undefined",
        "Null"
      ]; i$1 < list$1.length; i$1 += 1) {
        var name = list$1[i$1];
        classToType["[object " + name + "]"] = name.toLowerCase();
      }
      function type(obj) {
        return classToType[Object.prototype.toString.call(obj)] || "object";
      }
      function unpack(args, keyOrder) {
        if (keyOrder === void 0) keyOrder = null;
        if (args.length >= 3) {
          return Array.prototype.slice.call(args);
        }
        if (type(args[0]) == "object" && keyOrder) {
          return keyOrder.split("").filter(function(k) {
            return args[0][k] !== void 0;
          }).map(function(k) {
            return args[0][k];
          });
        }
        return args[0];
      }
      function last(args) {
        if (args.length < 2) {
          return null;
        }
        var l = args.length - 1;
        if (type(args[l]) == "string") {
          return args[l].toLowerCase();
        }
        return null;
      }
      var PI$2 = Math.PI;
      var min$3 = Math.min;
      var max$3 = Math.max;
      var TWOPI = PI$2 * 2;
      var PITHIRD = PI$2 / 3;
      var DEG2RAD = PI$2 / 180;
      var RAD2DEG = 180 / PI$2;
      var input = {
        format: {},
        autodetect: []
      };
      var Color = function Color2() {
        var args = [], len = arguments.length;
        while (len--) args[len] = arguments[len];
        var me = this;
        if (type(args[0]) === "object" && args[0].constructor && args[0].constructor === this.constructor) {
          return args[0];
        }
        var mode = last(args);
        var autodetect = false;
        if (!mode) {
          autodetect = true;
          if (!input.sorted) {
            input.autodetect = input.autodetect.sort(function(a, b) {
              return b.p - a.p;
            });
            input.sorted = true;
          }
          for (var i2 = 0, list2 = input.autodetect; i2 < list2.length; i2 += 1) {
            var chk = list2[i2];
            mode = chk.test.apply(chk, args);
            if (mode) {
              break;
            }
          }
        }
        if (input.format[mode]) {
          var rgb2 = input.format[mode].apply(
            null,
            autodetect ? args : args.slice(0, -1)
          );
          me._rgb = clip_rgb(rgb2);
        } else {
          throw new Error("unknown format: " + args);
        }
        if (me._rgb.length === 3) {
          me._rgb.push(1);
        }
      };
      Color.prototype.toString = function toString() {
        if (type(this.hex) == "function") {
          return this.hex();
        }
        return "[" + this._rgb.join(",") + "]";
      };
      var version = "2.6.0";
      var chroma = function() {
        var args = [], len = arguments.length;
        while (len--) args[len] = arguments[len];
        return new (Function.prototype.bind.apply(chroma.Color, [null].concat(args)))();
      };
      chroma.Color = Color;
      chroma.version = version;
      var cmyk2rgb = function() {
        var args = [], len = arguments.length;
        while (len--) args[len] = arguments[len];
        args = unpack(args, "cmyk");
        var c = args[0];
        var m = args[1];
        var y = args[2];
        var k = args[3];
        var alpha = args.length > 4 ? args[4] : 1;
        if (k === 1) {
          return [0, 0, 0, alpha];
        }
        return [
          c >= 1 ? 0 : 255 * (1 - c) * (1 - k),
          // r
          m >= 1 ? 0 : 255 * (1 - m) * (1 - k),
          // g
          y >= 1 ? 0 : 255 * (1 - y) * (1 - k),
          // b
          alpha
        ];
      };
      var max$2 = Math.max;
      var rgb2cmyk = function() {
        var args = [], len = arguments.length;
        while (len--) args[len] = arguments[len];
        var ref = unpack(args, "rgb");
        var r = ref[0];
        var g = ref[1];
        var b = ref[2];
        r = r / 255;
        g = g / 255;
        b = b / 255;
        var k = 1 - max$2(r, max$2(g, b));
        var f = k < 1 ? 1 / (1 - k) : 0;
        var c = (1 - r - k) * f;
        var m = (1 - g - k) * f;
        var y = (1 - b - k) * f;
        return [c, m, y, k];
      };
      Color.prototype.cmyk = function() {
        return rgb2cmyk(this._rgb);
      };
      chroma.cmyk = function() {
        var args = [], len = arguments.length;
        while (len--) args[len] = arguments[len];
        return new (Function.prototype.bind.apply(Color, [null].concat(args, ["cmyk"])))();
      };
      input.format.cmyk = cmyk2rgb;
      input.autodetect.push({
        p: 2,
        test: function() {
          var args = [], len = arguments.length;
          while (len--) args[len] = arguments[len];
          args = unpack(args, "cmyk");
          if (type(args) === "array" && args.length === 4) {
            return "cmyk";
          }
        }
      });
      var rnd = function(a) {
        return Math.round(a * 100) / 100;
      };
      var hsl2css = function() {
        var args = [], len = arguments.length;
        while (len--) args[len] = arguments[len];
        var hsla = unpack(args, "hsla");
        var mode = last(args) || "lsa";
        hsla[0] = rnd(hsla[0] || 0);
        hsla[1] = rnd(hsla[1] * 100) + "%";
        hsla[2] = rnd(hsla[2] * 100) + "%";
        if (mode === "hsla" || hsla.length > 3 && hsla[3] < 1) {
          hsla[3] = hsla.length > 3 ? hsla[3] : 1;
          mode = "hsla";
        } else {
          hsla.length = 3;
        }
        return mode + "(" + hsla.join(",") + ")";
      };
      var rgb2hsl$1 = function() {
        var args = [], len = arguments.length;
        while (len--) args[len] = arguments[len];
        args = unpack(args, "rgba");
        var r = args[0];
        var g = args[1];
        var b = args[2];
        r /= 255;
        g /= 255;
        b /= 255;
        var minRgb = min$3(r, g, b);
        var maxRgb = max$3(r, g, b);
        var l = (maxRgb + minRgb) / 2;
        var s, h;
        if (maxRgb === minRgb) {
          s = 0;
          h = Number.NaN;
        } else {
          s = l < 0.5 ? (maxRgb - minRgb) / (maxRgb + minRgb) : (maxRgb - minRgb) / (2 - maxRgb - minRgb);
        }
        if (r == maxRgb) {
          h = (g - b) / (maxRgb - minRgb);
        } else if (g == maxRgb) {
          h = 2 + (b - r) / (maxRgb - minRgb);
        } else if (b == maxRgb) {
          h = 4 + (r - g) / (maxRgb - minRgb);
        }
        h *= 60;
        if (h < 0) {
          h += 360;
        }
        if (args.length > 3 && args[3] !== void 0) {
          return [h, s, l, args[3]];
        }
        return [h, s, l];
      };
      var round$6 = Math.round;
      var rgb2css = function() {
        var args = [], len = arguments.length;
        while (len--) args[len] = arguments[len];
        var rgba = unpack(args, "rgba");
        var mode = last(args) || "rgb";
        if (mode.substr(0, 3) == "hsl") {
          return hsl2css(rgb2hsl$1(rgba), mode);
        }
        rgba[0] = round$6(rgba[0]);
        rgba[1] = round$6(rgba[1]);
        rgba[2] = round$6(rgba[2]);
        if (mode === "rgba" || rgba.length > 3 && rgba[3] < 1) {
          rgba[3] = rgba.length > 3 ? rgba[3] : 1;
          mode = "rgba";
        }
        return mode + "(" + rgba.slice(0, mode === "rgb" ? 3 : 4).join(",") + ")";
      };
      var round$5 = Math.round;
      var hsl2rgb = function() {
        var assign;
        var args = [], len = arguments.length;
        while (len--) args[len] = arguments[len];
        args = unpack(args, "hsl");
        var h = args[0];
        var s = args[1];
        var l = args[2];
        var r, g, b;
        if (s === 0) {
          r = g = b = l * 255;
        } else {
          var t3 = [0, 0, 0];
          var c = [0, 0, 0];
          var t2 = l < 0.5 ? l * (1 + s) : l + s - l * s;
          var t1 = 2 * l - t2;
          var h_ = h / 360;
          t3[0] = h_ + 1 / 3;
          t3[1] = h_;
          t3[2] = h_ - 1 / 3;
          for (var i2 = 0; i2 < 3; i2++) {
            if (t3[i2] < 0) {
              t3[i2] += 1;
            }
            if (t3[i2] > 1) {
              t3[i2] -= 1;
            }
            if (6 * t3[i2] < 1) {
              c[i2] = t1 + (t2 - t1) * 6 * t3[i2];
            } else if (2 * t3[i2] < 1) {
              c[i2] = t2;
            } else if (3 * t3[i2] < 2) {
              c[i2] = t1 + (t2 - t1) * (2 / 3 - t3[i2]) * 6;
            } else {
              c[i2] = t1;
            }
          }
          assign = [round$5(c[0] * 255), round$5(c[1] * 255), round$5(c[2] * 255)], r = assign[0], g = assign[1], b = assign[2];
        }
        if (args.length > 3) {
          return [r, g, b, args[3]];
        }
        return [r, g, b, 1];
      };
      var RE_RGB = /^rgb\(\s*(-?\d+),\s*(-?\d+)\s*,\s*(-?\d+)\s*\)$/;
      var RE_RGBA = /^rgba\(\s*(-?\d+),\s*(-?\d+)\s*,\s*(-?\d+)\s*,\s*([01]|[01]?\.\d+)\)$/;
      var RE_RGB_PCT = /^rgb\(\s*(-?\d+(?:\.\d+)?)%,\s*(-?\d+(?:\.\d+)?)%\s*,\s*(-?\d+(?:\.\d+)?)%\s*\)$/;
      var RE_RGBA_PCT = /^rgba\(\s*(-?\d+(?:\.\d+)?)%,\s*(-?\d+(?:\.\d+)?)%\s*,\s*(-?\d+(?:\.\d+)?)%\s*,\s*([01]|[01]?\.\d+)\)$/;
      var RE_HSL = /^hsl\(\s*(-?\d+(?:\.\d+)?),\s*(-?\d+(?:\.\d+)?)%\s*,\s*(-?\d+(?:\.\d+)?)%\s*\)$/;
      var RE_HSLA = /^hsla\(\s*(-?\d+(?:\.\d+)?),\s*(-?\d+(?:\.\d+)?)%\s*,\s*(-?\d+(?:\.\d+)?)%\s*,\s*([01]|[01]?\.\d+)\)$/;
      var round$4 = Math.round;
      var css2rgb = function(css) {
        css = css.toLowerCase().trim();
        var m;
        if (input.format.named) {
          try {
            return input.format.named(css);
          } catch (e) {
          }
        }
        if (m = css.match(RE_RGB)) {
          var rgb2 = m.slice(1, 4);
          for (var i2 = 0; i2 < 3; i2++) {
            rgb2[i2] = +rgb2[i2];
          }
          rgb2[3] = 1;
          return rgb2;
        }
        if (m = css.match(RE_RGBA)) {
          var rgb$1 = m.slice(1, 5);
          for (var i$12 = 0; i$12 < 4; i$12++) {
            rgb$1[i$12] = +rgb$1[i$12];
          }
          return rgb$1;
        }
        if (m = css.match(RE_RGB_PCT)) {
          var rgb$2 = m.slice(1, 4);
          for (var i$2 = 0; i$2 < 3; i$2++) {
            rgb$2[i$2] = round$4(rgb$2[i$2] * 2.55);
          }
          rgb$2[3] = 1;
          return rgb$2;
        }
        if (m = css.match(RE_RGBA_PCT)) {
          var rgb$3 = m.slice(1, 5);
          for (var i$3 = 0; i$3 < 3; i$3++) {
            rgb$3[i$3] = round$4(rgb$3[i$3] * 2.55);
          }
          rgb$3[3] = +rgb$3[3];
          return rgb$3;
        }
        if (m = css.match(RE_HSL)) {
          var hsl2 = m.slice(1, 4);
          hsl2[1] *= 0.01;
          hsl2[2] *= 0.01;
          var rgb$4 = hsl2rgb(hsl2);
          rgb$4[3] = 1;
          return rgb$4;
        }
        if (m = css.match(RE_HSLA)) {
          var hsl$1 = m.slice(1, 4);
          hsl$1[1] *= 0.01;
          hsl$1[2] *= 0.01;
          var rgb$5 = hsl2rgb(hsl$1);
          rgb$5[3] = +m[4];
          return rgb$5;
        }
      };
      css2rgb.test = function(s) {
        return RE_RGB.test(s) || RE_RGBA.test(s) || RE_RGB_PCT.test(s) || RE_RGBA_PCT.test(s) || RE_HSL.test(s) || RE_HSLA.test(s);
      };
      Color.prototype.css = function(mode) {
        return rgb2css(this._rgb, mode);
      };
      chroma.css = function() {
        var args = [], len = arguments.length;
        while (len--) args[len] = arguments[len];
        return new (Function.prototype.bind.apply(Color, [null].concat(args, ["css"])))();
      };
      input.format.css = css2rgb;
      input.autodetect.push({
        p: 5,
        test: function(h) {
          var rest = [], len = arguments.length - 1;
          while (len-- > 0) rest[len] = arguments[len + 1];
          if (!rest.length && type(h) === "string" && css2rgb.test(h)) {
            return "css";
          }
        }
      });
      input.format.gl = function() {
        var args = [], len = arguments.length;
        while (len--) args[len] = arguments[len];
        var rgb2 = unpack(args, "rgba");
        rgb2[0] *= 255;
        rgb2[1] *= 255;
        rgb2[2] *= 255;
        return rgb2;
      };
      chroma.gl = function() {
        var args = [], len = arguments.length;
        while (len--) args[len] = arguments[len];
        return new (Function.prototype.bind.apply(Color, [null].concat(args, ["gl"])))();
      };
      Color.prototype.gl = function() {
        var rgb2 = this._rgb;
        return [rgb2[0] / 255, rgb2[1] / 255, rgb2[2] / 255, rgb2[3]];
      };
      var floor$3 = Math.floor;
      var hcg2rgb = function() {
        var assign, assign$1, assign$2, assign$3, assign$4, assign$5;
        var args = [], len = arguments.length;
        while (len--) args[len] = arguments[len];
        args = unpack(args, "hcg");
        var h = args[0];
        var c = args[1];
        var _g = args[2];
        var r, g, b;
        _g = _g * 255;
        var _c = c * 255;
        if (c === 0) {
          r = g = b = _g;
        } else {
          if (h === 360) {
            h = 0;
          }
          if (h > 360) {
            h -= 360;
          }
          if (h < 0) {
            h += 360;
          }
          h /= 60;
          var i2 = floor$3(h);
          var f = h - i2;
          var p = _g * (1 - c);
          var q = p + _c * (1 - f);
          var t = p + _c * f;
          var v = p + _c;
          switch (i2) {
            case 0:
              assign = [v, t, p], r = assign[0], g = assign[1], b = assign[2];
              break;
            case 1:
              assign$1 = [q, v, p], r = assign$1[0], g = assign$1[1], b = assign$1[2];
              break;
            case 2:
              assign$2 = [p, v, t], r = assign$2[0], g = assign$2[1], b = assign$2[2];
              break;
            case 3:
              assign$3 = [p, q, v], r = assign$3[0], g = assign$3[1], b = assign$3[2];
              break;
            case 4:
              assign$4 = [t, p, v], r = assign$4[0], g = assign$4[1], b = assign$4[2];
              break;
            case 5:
              assign$5 = [v, p, q], r = assign$5[0], g = assign$5[1], b = assign$5[2];
              break;
          }
        }
        return [r, g, b, args.length > 3 ? args[3] : 1];
      };
      var rgb2hcg = function() {
        var args = [], len = arguments.length;
        while (len--) args[len] = arguments[len];
        var ref = unpack(args, "rgb");
        var r = ref[0];
        var g = ref[1];
        var b = ref[2];
        var minRgb = min$3(r, g, b);
        var maxRgb = max$3(r, g, b);
        var delta = maxRgb - minRgb;
        var c = delta * 100 / 255;
        var _g = minRgb / (255 - delta) * 100;
        var h;
        if (delta === 0) {
          h = Number.NaN;
        } else {
          if (r === maxRgb) {
            h = (g - b) / delta;
          }
          if (g === maxRgb) {
            h = 2 + (b - r) / delta;
          }
          if (b === maxRgb) {
            h = 4 + (r - g) / delta;
          }
          h *= 60;
          if (h < 0) {
            h += 360;
          }
        }
        return [h, c, _g];
      };
      Color.prototype.hcg = function() {
        return rgb2hcg(this._rgb);
      };
      chroma.hcg = function() {
        var args = [], len = arguments.length;
        while (len--) args[len] = arguments[len];
        return new (Function.prototype.bind.apply(Color, [null].concat(args, ["hcg"])))();
      };
      input.format.hcg = hcg2rgb;
      input.autodetect.push({
        p: 1,
        test: function() {
          var args = [], len = arguments.length;
          while (len--) args[len] = arguments[len];
          args = unpack(args, "hcg");
          if (type(args) === "array" && args.length === 3) {
            return "hcg";
          }
        }
      });
      var RE_HEX = /^#?([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/;
      var RE_HEXA = /^#?([A-Fa-f0-9]{8}|[A-Fa-f0-9]{4})$/;
      var hex2rgb = function(hex) {
        if (hex.match(RE_HEX)) {
          if (hex.length === 4 || hex.length === 7) {
            hex = hex.substr(1);
          }
          if (hex.length === 3) {
            hex = hex.split("");
            hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
          }
          var u = parseInt(hex, 16);
          var r = u >> 16;
          var g = u >> 8 & 255;
          var b = u & 255;
          return [r, g, b, 1];
        }
        if (hex.match(RE_HEXA)) {
          if (hex.length === 5 || hex.length === 9) {
            hex = hex.substr(1);
          }
          if (hex.length === 4) {
            hex = hex.split("");
            hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2] + hex[3] + hex[3];
          }
          var u$1 = parseInt(hex, 16);
          var r$1 = u$1 >> 24 & 255;
          var g$1 = u$1 >> 16 & 255;
          var b$1 = u$1 >> 8 & 255;
          var a = Math.round((u$1 & 255) / 255 * 100) / 100;
          return [r$1, g$1, b$1, a];
        }
        throw new Error("unknown hex color: " + hex);
      };
      var round$3 = Math.round;
      var rgb2hex = function() {
        var args = [], len = arguments.length;
        while (len--) args[len] = arguments[len];
        var ref = unpack(args, "rgba");
        var r = ref[0];
        var g = ref[1];
        var b = ref[2];
        var a = ref[3];
        var mode = last(args) || "auto";
        if (a === void 0) {
          a = 1;
        }
        if (mode === "auto") {
          mode = a < 1 ? "rgba" : "rgb";
        }
        r = round$3(r);
        g = round$3(g);
        b = round$3(b);
        var u = r << 16 | g << 8 | b;
        var str = "000000" + u.toString(16);
        str = str.substr(str.length - 6);
        var hxa = "0" + round$3(a * 255).toString(16);
        hxa = hxa.substr(hxa.length - 2);
        switch (mode.toLowerCase()) {
          case "rgba":
            return "#" + str + hxa;
          case "argb":
            return "#" + hxa + str;
          default:
            return "#" + str;
        }
      };
      Color.prototype.hex = function(mode) {
        return rgb2hex(this._rgb, mode);
      };
      chroma.hex = function() {
        var args = [], len = arguments.length;
        while (len--) args[len] = arguments[len];
        return new (Function.prototype.bind.apply(Color, [null].concat(args, ["hex"])))();
      };
      input.format.hex = hex2rgb;
      input.autodetect.push({
        p: 4,
        test: function(h) {
          var rest = [], len = arguments.length - 1;
          while (len-- > 0) rest[len] = arguments[len + 1];
          if (!rest.length && type(h) === "string" && [3, 4, 5, 6, 7, 8, 9].indexOf(h.length) >= 0) {
            return "hex";
          }
        }
      });
      var cos$4 = Math.cos;
      var hsi2rgb = function() {
        var args = [], len = arguments.length;
        while (len--) args[len] = arguments[len];
        args = unpack(args, "hsi");
        var h = args[0];
        var s = args[1];
        var i2 = args[2];
        var r, g, b;
        if (isNaN(h)) {
          h = 0;
        }
        if (isNaN(s)) {
          s = 0;
        }
        if (h > 360) {
          h -= 360;
        }
        if (h < 0) {
          h += 360;
        }
        h /= 360;
        if (h < 1 / 3) {
          b = (1 - s) / 3;
          r = (1 + s * cos$4(TWOPI * h) / cos$4(PITHIRD - TWOPI * h)) / 3;
          g = 1 - (b + r);
        } else if (h < 2 / 3) {
          h -= 1 / 3;
          r = (1 - s) / 3;
          g = (1 + s * cos$4(TWOPI * h) / cos$4(PITHIRD - TWOPI * h)) / 3;
          b = 1 - (r + g);
        } else {
          h -= 2 / 3;
          g = (1 - s) / 3;
          b = (1 + s * cos$4(TWOPI * h) / cos$4(PITHIRD - TWOPI * h)) / 3;
          r = 1 - (g + b);
        }
        r = limit(i2 * r * 3);
        g = limit(i2 * g * 3);
        b = limit(i2 * b * 3);
        return [r * 255, g * 255, b * 255, args.length > 3 ? args[3] : 1];
      };
      var min$2 = Math.min;
      var sqrt$4 = Math.sqrt;
      var acos = Math.acos;
      var rgb2hsi = function() {
        var args = [], len = arguments.length;
        while (len--) args[len] = arguments[len];
        var ref = unpack(args, "rgb");
        var r = ref[0];
        var g = ref[1];
        var b = ref[2];
        r /= 255;
        g /= 255;
        b /= 255;
        var h;
        var min_ = min$2(r, g, b);
        var i2 = (r + g + b) / 3;
        var s = i2 > 0 ? 1 - min_ / i2 : 0;
        if (s === 0) {
          h = NaN;
        } else {
          h = (r - g + (r - b)) / 2;
          h /= sqrt$4((r - g) * (r - g) + (r - b) * (g - b));
          h = acos(h);
          if (b > g) {
            h = TWOPI - h;
          }
          h /= TWOPI;
        }
        return [h * 360, s, i2];
      };
      Color.prototype.hsi = function() {
        return rgb2hsi(this._rgb);
      };
      chroma.hsi = function() {
        var args = [], len = arguments.length;
        while (len--) args[len] = arguments[len];
        return new (Function.prototype.bind.apply(Color, [null].concat(args, ["hsi"])))();
      };
      input.format.hsi = hsi2rgb;
      input.autodetect.push({
        p: 2,
        test: function() {
          var args = [], len = arguments.length;
          while (len--) args[len] = arguments[len];
          args = unpack(args, "hsi");
          if (type(args) === "array" && args.length === 3) {
            return "hsi";
          }
        }
      });
      Color.prototype.hsl = function() {
        return rgb2hsl$1(this._rgb);
      };
      chroma.hsl = function() {
        var args = [], len = arguments.length;
        while (len--) args[len] = arguments[len];
        return new (Function.prototype.bind.apply(Color, [null].concat(args, ["hsl"])))();
      };
      input.format.hsl = hsl2rgb;
      input.autodetect.push({
        p: 2,
        test: function() {
          var args = [], len = arguments.length;
          while (len--) args[len] = arguments[len];
          args = unpack(args, "hsl");
          if (type(args) === "array" && args.length === 3) {
            return "hsl";
          }
        }
      });
      var floor$2 = Math.floor;
      var hsv2rgb = function() {
        var assign, assign$1, assign$2, assign$3, assign$4, assign$5;
        var args = [], len = arguments.length;
        while (len--) args[len] = arguments[len];
        args = unpack(args, "hsv");
        var h = args[0];
        var s = args[1];
        var v = args[2];
        var r, g, b;
        v *= 255;
        if (s === 0) {
          r = g = b = v;
        } else {
          if (h === 360) {
            h = 0;
          }
          if (h > 360) {
            h -= 360;
          }
          if (h < 0) {
            h += 360;
          }
          h /= 60;
          var i2 = floor$2(h);
          var f = h - i2;
          var p = v * (1 - s);
          var q = v * (1 - s * f);
          var t = v * (1 - s * (1 - f));
          switch (i2) {
            case 0:
              assign = [v, t, p], r = assign[0], g = assign[1], b = assign[2];
              break;
            case 1:
              assign$1 = [q, v, p], r = assign$1[0], g = assign$1[1], b = assign$1[2];
              break;
            case 2:
              assign$2 = [p, v, t], r = assign$2[0], g = assign$2[1], b = assign$2[2];
              break;
            case 3:
              assign$3 = [p, q, v], r = assign$3[0], g = assign$3[1], b = assign$3[2];
              break;
            case 4:
              assign$4 = [t, p, v], r = assign$4[0], g = assign$4[1], b = assign$4[2];
              break;
            case 5:
              assign$5 = [v, p, q], r = assign$5[0], g = assign$5[1], b = assign$5[2];
              break;
          }
        }
        return [r, g, b, args.length > 3 ? args[3] : 1];
      };
      var min$1 = Math.min;
      var max$1 = Math.max;
      var rgb2hsl = function() {
        var args = [], len = arguments.length;
        while (len--) args[len] = arguments[len];
        args = unpack(args, "rgb");
        var r = args[0];
        var g = args[1];
        var b = args[2];
        var min_ = min$1(r, g, b);
        var max_ = max$1(r, g, b);
        var delta = max_ - min_;
        var h, s, v;
        v = max_ / 255;
        if (max_ === 0) {
          h = Number.NaN;
          s = 0;
        } else {
          s = delta / max_;
          if (r === max_) {
            h = (g - b) / delta;
          }
          if (g === max_) {
            h = 2 + (b - r) / delta;
          }
          if (b === max_) {
            h = 4 + (r - g) / delta;
          }
          h *= 60;
          if (h < 0) {
            h += 360;
          }
        }
        return [h, s, v];
      };
      Color.prototype.hsv = function() {
        return rgb2hsl(this._rgb);
      };
      chroma.hsv = function() {
        var args = [], len = arguments.length;
        while (len--) args[len] = arguments[len];
        return new (Function.prototype.bind.apply(Color, [null].concat(args, ["hsv"])))();
      };
      input.format.hsv = hsv2rgb;
      input.autodetect.push({
        p: 2,
        test: function() {
          var args = [], len = arguments.length;
          while (len--) args[len] = arguments[len];
          args = unpack(args, "hsv");
          if (type(args) === "array" && args.length === 3) {
            return "hsv";
          }
        }
      });
      var LAB_CONSTANTS = {
        // Corresponds roughly to RGB brighter/darker
        Kn: 18,
        // D65 standard referent
        Xn: 0.95047,
        Yn: 1,
        Zn: 1.08883,
        t0: 0.137931034,
        // 4 / 29
        t1: 0.206896552,
        // 6 / 29
        t2: 0.12841855,
        // 3 * t1 * t1
        t3: 8856452e-9
        // t1 * t1 * t1
      };
      var pow$a = Math.pow;
      var lab2rgb = function() {
        var args = [], len = arguments.length;
        while (len--) args[len] = arguments[len];
        args = unpack(args, "lab");
        var l = args[0];
        var a = args[1];
        var b = args[2];
        var x, y, z, r, g, b_;
        y = (l + 16) / 116;
        x = isNaN(a) ? y : y + a / 500;
        z = isNaN(b) ? y : y - b / 200;
        y = LAB_CONSTANTS.Yn * lab_xyz(y);
        x = LAB_CONSTANTS.Xn * lab_xyz(x);
        z = LAB_CONSTANTS.Zn * lab_xyz(z);
        r = xyz_rgb(3.2404542 * x - 1.5371385 * y - 0.4985314 * z);
        g = xyz_rgb(-0.969266 * x + 1.8760108 * y + 0.041556 * z);
        b_ = xyz_rgb(0.0556434 * x - 0.2040259 * y + 1.0572252 * z);
        return [r, g, b_, args.length > 3 ? args[3] : 1];
      };
      var xyz_rgb = function(r) {
        return 255 * (r <= 304e-5 ? 12.92 * r : 1.055 * pow$a(r, 1 / 2.4) - 0.055);
      };
      var lab_xyz = function(t) {
        return t > LAB_CONSTANTS.t1 ? t * t * t : LAB_CONSTANTS.t2 * (t - LAB_CONSTANTS.t0);
      };
      var pow$9 = Math.pow;
      var rgb2lab = function() {
        var args = [], len = arguments.length;
        while (len--) args[len] = arguments[len];
        var ref = unpack(args, "rgb");
        var r = ref[0];
        var g = ref[1];
        var b = ref[2];
        var ref$1 = rgb2xyz(r, g, b);
        var x = ref$1[0];
        var y = ref$1[1];
        var z = ref$1[2];
        var l = 116 * y - 16;
        return [l < 0 ? 0 : l, 500 * (x - y), 200 * (y - z)];
      };
      var rgb_xyz = function(r) {
        if ((r /= 255) <= 0.04045) {
          return r / 12.92;
        }
        return pow$9((r + 0.055) / 1.055, 2.4);
      };
      var xyz_lab = function(t) {
        if (t > LAB_CONSTANTS.t3) {
          return pow$9(t, 1 / 3);
        }
        return t / LAB_CONSTANTS.t2 + LAB_CONSTANTS.t0;
      };
      var rgb2xyz = function(r, g, b) {
        r = rgb_xyz(r);
        g = rgb_xyz(g);
        b = rgb_xyz(b);
        var x = xyz_lab(
          (0.4124564 * r + 0.3575761 * g + 0.1804375 * b) / LAB_CONSTANTS.Xn
        );
        var y = xyz_lab(
          (0.2126729 * r + 0.7151522 * g + 0.072175 * b) / LAB_CONSTANTS.Yn
        );
        var z = xyz_lab(
          (0.0193339 * r + 0.119192 * g + 0.9503041 * b) / LAB_CONSTANTS.Zn
        );
        return [x, y, z];
      };
      Color.prototype.lab = function() {
        return rgb2lab(this._rgb);
      };
      chroma.lab = function() {
        var args = [], len = arguments.length;
        while (len--) args[len] = arguments[len];
        return new (Function.prototype.bind.apply(Color, [null].concat(args, ["lab"])))();
      };
      input.format.lab = lab2rgb;
      input.autodetect.push({
        p: 2,
        test: function() {
          var args = [], len = arguments.length;
          while (len--) args[len] = arguments[len];
          args = unpack(args, "lab");
          if (type(args) === "array" && args.length === 3) {
            return "lab";
          }
        }
      });
      var sin$3 = Math.sin;
      var cos$3 = Math.cos;
      var lch2lab = function() {
        var args = [], len = arguments.length;
        while (len--) args[len] = arguments[len];
        var ref = unpack(args, "lch");
        var l = ref[0];
        var c = ref[1];
        var h = ref[2];
        if (isNaN(h)) {
          h = 0;
        }
        h = h * DEG2RAD;
        return [l, cos$3(h) * c, sin$3(h) * c];
      };
      var lch2rgb = function() {
        var args = [], len = arguments.length;
        while (len--) args[len] = arguments[len];
        args = unpack(args, "lch");
        var l = args[0];
        var c = args[1];
        var h = args[2];
        var ref = lch2lab(l, c, h);
        var L = ref[0];
        var a = ref[1];
        var b_ = ref[2];
        var ref$1 = lab2rgb(L, a, b_);
        var r = ref$1[0];
        var g = ref$1[1];
        var b = ref$1[2];
        return [r, g, b, args.length > 3 ? args[3] : 1];
      };
      var hcl2rgb = function() {
        var args = [], len = arguments.length;
        while (len--) args[len] = arguments[len];
        var hcl = unpack(args, "hcl").reverse();
        return lch2rgb.apply(void 0, hcl);
      };
      var sqrt$3 = Math.sqrt;
      var atan2$2 = Math.atan2;
      var round$2 = Math.round;
      var lab2lch = function() {
        var args = [], len = arguments.length;
        while (len--) args[len] = arguments[len];
        var ref = unpack(args, "lab");
        var l = ref[0];
        var a = ref[1];
        var b = ref[2];
        var c = sqrt$3(a * a + b * b);
        var h = (atan2$2(b, a) * RAD2DEG + 360) % 360;
        if (round$2(c * 1e4) === 0) {
          h = Number.NaN;
        }
        return [l, c, h];
      };
      var rgb2lch = function() {
        var args = [], len = arguments.length;
        while (len--) args[len] = arguments[len];
        var ref = unpack(args, "rgb");
        var r = ref[0];
        var g = ref[1];
        var b = ref[2];
        var ref$1 = rgb2lab(r, g, b);
        var l = ref$1[0];
        var a = ref$1[1];
        var b_ = ref$1[2];
        return lab2lch(l, a, b_);
      };
      Color.prototype.lch = function() {
        return rgb2lch(this._rgb);
      };
      Color.prototype.hcl = function() {
        return rgb2lch(this._rgb).reverse();
      };
      chroma.lch = function() {
        var args = [], len = arguments.length;
        while (len--) args[len] = arguments[len];
        return new (Function.prototype.bind.apply(Color, [null].concat(args, ["lch"])))();
      };
      chroma.hcl = function() {
        var args = [], len = arguments.length;
        while (len--) args[len] = arguments[len];
        return new (Function.prototype.bind.apply(Color, [null].concat(args, ["hcl"])))();
      };
      input.format.lch = lch2rgb;
      input.format.hcl = hcl2rgb;
      ["lch", "hcl"].forEach(
        function(m) {
          return input.autodetect.push({
            p: 2,
            test: function() {
              var args = [], len = arguments.length;
              while (len--) args[len] = arguments[len];
              args = unpack(args, m);
              if (type(args) === "array" && args.length === 3) {
                return m;
              }
            }
          });
        }
      );
      var w3cx11 = {
        aliceblue: "#f0f8ff",
        antiquewhite: "#faebd7",
        aqua: "#00ffff",
        aquamarine: "#7fffd4",
        azure: "#f0ffff",
        beige: "#f5f5dc",
        bisque: "#ffe4c4",
        black: "#000000",
        blanchedalmond: "#ffebcd",
        blue: "#0000ff",
        blueviolet: "#8a2be2",
        brown: "#a52a2a",
        burlywood: "#deb887",
        cadetblue: "#5f9ea0",
        chartreuse: "#7fff00",
        chocolate: "#d2691e",
        coral: "#ff7f50",
        cornflowerblue: "#6495ed",
        cornsilk: "#fff8dc",
        crimson: "#dc143c",
        cyan: "#00ffff",
        darkblue: "#00008b",
        darkcyan: "#008b8b",
        darkgoldenrod: "#b8860b",
        darkgray: "#a9a9a9",
        darkgreen: "#006400",
        darkgrey: "#a9a9a9",
        darkkhaki: "#bdb76b",
        darkmagenta: "#8b008b",
        darkolivegreen: "#556b2f",
        darkorange: "#ff8c00",
        darkorchid: "#9932cc",
        darkred: "#8b0000",
        darksalmon: "#e9967a",
        darkseagreen: "#8fbc8f",
        darkslateblue: "#483d8b",
        darkslategray: "#2f4f4f",
        darkslategrey: "#2f4f4f",
        darkturquoise: "#00ced1",
        darkviolet: "#9400d3",
        deeppink: "#ff1493",
        deepskyblue: "#00bfff",
        dimgray: "#696969",
        dimgrey: "#696969",
        dodgerblue: "#1e90ff",
        firebrick: "#b22222",
        floralwhite: "#fffaf0",
        forestgreen: "#228b22",
        fuchsia: "#ff00ff",
        gainsboro: "#dcdcdc",
        ghostwhite: "#f8f8ff",
        gold: "#ffd700",
        goldenrod: "#daa520",
        gray: "#808080",
        green: "#008000",
        greenyellow: "#adff2f",
        grey: "#808080",
        honeydew: "#f0fff0",
        hotpink: "#ff69b4",
        indianred: "#cd5c5c",
        indigo: "#4b0082",
        ivory: "#fffff0",
        khaki: "#f0e68c",
        laserlemon: "#ffff54",
        lavender: "#e6e6fa",
        lavenderblush: "#fff0f5",
        lawngreen: "#7cfc00",
        lemonchiffon: "#fffacd",
        lightblue: "#add8e6",
        lightcoral: "#f08080",
        lightcyan: "#e0ffff",
        lightgoldenrod: "#fafad2",
        lightgoldenrodyellow: "#fafad2",
        lightgray: "#d3d3d3",
        lightgreen: "#90ee90",
        lightgrey: "#d3d3d3",
        lightpink: "#ffb6c1",
        lightsalmon: "#ffa07a",
        lightseagreen: "#20b2aa",
        lightskyblue: "#87cefa",
        lightslategray: "#778899",
        lightslategrey: "#778899",
        lightsteelblue: "#b0c4de",
        lightyellow: "#ffffe0",
        lime: "#00ff00",
        limegreen: "#32cd32",
        linen: "#faf0e6",
        magenta: "#ff00ff",
        maroon: "#800000",
        maroon2: "#7f0000",
        maroon3: "#b03060",
        mediumaquamarine: "#66cdaa",
        mediumblue: "#0000cd",
        mediumorchid: "#ba55d3",
        mediumpurple: "#9370db",
        mediumseagreen: "#3cb371",
        mediumslateblue: "#7b68ee",
        mediumspringgreen: "#00fa9a",
        mediumturquoise: "#48d1cc",
        mediumvioletred: "#c71585",
        midnightblue: "#191970",
        mintcream: "#f5fffa",
        mistyrose: "#ffe4e1",
        moccasin: "#ffe4b5",
        navajowhite: "#ffdead",
        navy: "#000080",
        oldlace: "#fdf5e6",
        olive: "#808000",
        olivedrab: "#6b8e23",
        orange: "#ffa500",
        orangered: "#ff4500",
        orchid: "#da70d6",
        palegoldenrod: "#eee8aa",
        palegreen: "#98fb98",
        paleturquoise: "#afeeee",
        palevioletred: "#db7093",
        papayawhip: "#ffefd5",
        peachpuff: "#ffdab9",
        peru: "#cd853f",
        pink: "#ffc0cb",
        plum: "#dda0dd",
        powderblue: "#b0e0e6",
        purple: "#800080",
        purple2: "#7f007f",
        purple3: "#a020f0",
        rebeccapurple: "#663399",
        red: "#ff0000",
        rosybrown: "#bc8f8f",
        royalblue: "#4169e1",
        saddlebrown: "#8b4513",
        salmon: "#fa8072",
        sandybrown: "#f4a460",
        seagreen: "#2e8b57",
        seashell: "#fff5ee",
        sienna: "#a0522d",
        silver: "#c0c0c0",
        skyblue: "#87ceeb",
        slateblue: "#6a5acd",
        slategray: "#708090",
        slategrey: "#708090",
        snow: "#fffafa",
        springgreen: "#00ff7f",
        steelblue: "#4682b4",
        tan: "#d2b48c",
        teal: "#008080",
        thistle: "#d8bfd8",
        tomato: "#ff6347",
        turquoise: "#40e0d0",
        violet: "#ee82ee",
        wheat: "#f5deb3",
        white: "#ffffff",
        whitesmoke: "#f5f5f5",
        yellow: "#ffff00",
        yellowgreen: "#9acd32"
      };
      Color.prototype.name = function() {
        var hex = rgb2hex(this._rgb, "rgb");
        for (var i2 = 0, list2 = Object.keys(w3cx11); i2 < list2.length; i2 += 1) {
          var n = list2[i2];
          if (w3cx11[n] === hex) {
            return n.toLowerCase();
          }
        }
        return hex;
      };
      input.format.named = function(name2) {
        name2 = name2.toLowerCase();
        if (w3cx11[name2]) {
          return hex2rgb(w3cx11[name2]);
        }
        throw new Error("unknown color name: " + name2);
      };
      input.autodetect.push({
        p: 5,
        test: function(h) {
          var rest = [], len = arguments.length - 1;
          while (len-- > 0) rest[len] = arguments[len + 1];
          if (!rest.length && type(h) === "string" && w3cx11[h.toLowerCase()]) {
            return "named";
          }
        }
      });
      var num2rgb = function(num2) {
        if (type(num2) == "number" && num2 >= 0 && num2 <= 16777215) {
          var r = num2 >> 16;
          var g = num2 >> 8 & 255;
          var b = num2 & 255;
          return [r, g, b, 1];
        }
        throw new Error("unknown num color: " + num2);
      };
      var rgb2num = function() {
        var args = [], len = arguments.length;
        while (len--) args[len] = arguments[len];
        var ref = unpack(args, "rgb");
        var r = ref[0];
        var g = ref[1];
        var b = ref[2];
        return (r << 16) + (g << 8) + b;
      };
      Color.prototype.num = function() {
        return rgb2num(this._rgb);
      };
      chroma.num = function() {
        var args = [], len = arguments.length;
        while (len--) args[len] = arguments[len];
        return new (Function.prototype.bind.apply(Color, [null].concat(args, ["num"])))();
      };
      input.format.num = num2rgb;
      input.autodetect.push({
        p: 5,
        test: function() {
          var args = [], len = arguments.length;
          while (len--) args[len] = arguments[len];
          if (args.length === 1 && type(args[0]) === "number" && args[0] >= 0 && args[0] <= 16777215) {
            return "num";
          }
        }
      });
      var round$1 = Math.round;
      Color.prototype.rgb = function(rnd2) {
        if (rnd2 === void 0) rnd2 = true;
        if (rnd2 === false) {
          return this._rgb.slice(0, 3);
        }
        return this._rgb.slice(0, 3).map(round$1);
      };
      Color.prototype.rgba = function(rnd2) {
        if (rnd2 === void 0) rnd2 = true;
        return this._rgb.slice(0, 4).map(function(v, i2) {
          return i2 < 3 ? rnd2 === false ? v : round$1(v) : v;
        });
      };
      chroma.rgb = function() {
        var args = [], len = arguments.length;
        while (len--) args[len] = arguments[len];
        return new (Function.prototype.bind.apply(Color, [null].concat(args, ["rgb"])))();
      };
      input.format.rgb = function() {
        var args = [], len = arguments.length;
        while (len--) args[len] = arguments[len];
        var rgba = unpack(args, "rgba");
        if (rgba[3] === void 0) {
          rgba[3] = 1;
        }
        return rgba;
      };
      input.autodetect.push({
        p: 3,
        test: function() {
          var args = [], len = arguments.length;
          while (len--) args[len] = arguments[len];
          args = unpack(args, "rgba");
          if (type(args) === "array" && (args.length === 3 || args.length === 4 && type(args[3]) == "number" && args[3] >= 0 && args[3] <= 1)) {
            return "rgb";
          }
        }
      });
      var log$1 = Math.log;
      var temperature2rgb = function(kelvin) {
        var temp = kelvin / 100;
        var r, g, b;
        if (temp < 66) {
          r = 255;
          g = temp < 6 ? 0 : -155.25485562709179 - 0.44596950469579133 * (g = temp - 2) + 104.49216199393888 * log$1(g);
          b = temp < 20 ? 0 : -254.76935184120902 + 0.8274096064007395 * (b = temp - 10) + 115.67994401066147 * log$1(b);
        } else {
          r = 351.97690566805693 + 0.114206453784165 * (r = temp - 55) - 40.25366309332127 * log$1(r);
          g = 325.4494125711974 + 0.07943456536662342 * (g = temp - 50) - 28.0852963507957 * log$1(g);
          b = 255;
        }
        return [r, g, b, 1];
      };
      var round = Math.round;
      var rgb2temperature = function() {
        var args = [], len = arguments.length;
        while (len--) args[len] = arguments[len];
        var rgb2 = unpack(args, "rgb");
        var r = rgb2[0], b = rgb2[2];
        var minTemp = 1e3;
        var maxTemp = 4e4;
        var eps = 0.4;
        var temp;
        while (maxTemp - minTemp > eps) {
          temp = (maxTemp + minTemp) * 0.5;
          var rgb$1 = temperature2rgb(temp);
          if (rgb$1[2] / rgb$1[0] >= b / r) {
            maxTemp = temp;
          } else {
            minTemp = temp;
          }
        }
        return round(temp);
      };
      Color.prototype.temp = Color.prototype.kelvin = Color.prototype.temperature = function() {
        return rgb2temperature(this._rgb);
      };
      chroma.temp = chroma.kelvin = chroma.temperature = function() {
        var args = [], len = arguments.length;
        while (len--) args[len] = arguments[len];
        return new (Function.prototype.bind.apply(Color, [null].concat(args, ["temp"])))();
      };
      input.format.temp = input.format.kelvin = input.format.temperature = temperature2rgb;
      var pow$8 = Math.pow;
      var sign$1 = Math.sign;
      var oklab2rgb = function() {
        var args = [], len = arguments.length;
        while (len--) args[len] = arguments[len];
        args = unpack(args, "lab");
        var L = args[0];
        var a = args[1];
        var b = args[2];
        var l = pow$8(L + 0.3963377774 * a + 0.2158037573 * b, 3);
        var m = pow$8(L - 0.1055613458 * a - 0.0638541728 * b, 3);
        var s = pow$8(L - 0.0894841775 * a - 1.291485548 * b, 3);
        return [
          255 * lrgb2rgb(4.0767416621 * l - 3.3077115913 * m + 0.2309699292 * s),
          255 * lrgb2rgb(-1.2684380046 * l + 2.6097574011 * m - 0.3413193965 * s),
          255 * lrgb2rgb(-0.0041960863 * l - 0.7034186147 * m + 1.707614701 * s),
          args.length > 3 ? args[3] : 1
        ];
      };
      function lrgb2rgb(c) {
        var abs2 = Math.abs(c);
        if (abs2 > 31308e-7) {
          return (sign$1(c) || 1) * (1.055 * pow$8(abs2, 1 / 2.4) - 0.055);
        }
        return c * 12.92;
      }
      var cbrt = Math.cbrt;
      var pow$7 = Math.pow;
      var sign = Math.sign;
      var rgb2oklab = function() {
        var args = [], len = arguments.length;
        while (len--) args[len] = arguments[len];
        var ref = unpack(args, "rgb");
        var r = ref[0];
        var g = ref[1];
        var b = ref[2];
        var ref$1 = [
          rgb2lrgb(r / 255),
          rgb2lrgb(g / 255),
          rgb2lrgb(b / 255)
        ];
        var lr = ref$1[0];
        var lg = ref$1[1];
        var lb = ref$1[2];
        var l = cbrt(0.4122214708 * lr + 0.5363325363 * lg + 0.0514459929 * lb);
        var m = cbrt(0.2119034982 * lr + 0.6806995451 * lg + 0.1073969566 * lb);
        var s = cbrt(0.0883024619 * lr + 0.2817188376 * lg + 0.6299787005 * lb);
        return [
          0.2104542553 * l + 0.793617785 * m - 0.0040720468 * s,
          1.9779984951 * l - 2.428592205 * m + 0.4505937099 * s,
          0.0259040371 * l + 0.7827717662 * m - 0.808675766 * s
        ];
      };
      function rgb2lrgb(c) {
        var abs2 = Math.abs(c);
        if (abs2 < 0.04045) {
          return c / 12.92;
        }
        return (sign(c) || 1) * pow$7((abs2 + 0.055) / 1.055, 2.4);
      }
      Color.prototype.oklab = function() {
        return rgb2oklab(this._rgb);
      };
      chroma.oklab = function() {
        var args = [], len = arguments.length;
        while (len--) args[len] = arguments[len];
        return new (Function.prototype.bind.apply(Color, [null].concat(args, ["oklab"])))();
      };
      input.format.oklab = oklab2rgb;
      input.autodetect.push({
        p: 3,
        test: function() {
          var args = [], len = arguments.length;
          while (len--) args[len] = arguments[len];
          args = unpack(args, "oklab");
          if (type(args) === "array" && args.length === 3) {
            return "oklab";
          }
        }
      });
      var oklch2rgb = function() {
        var args = [], len = arguments.length;
        while (len--) args[len] = arguments[len];
        args = unpack(args, "lch");
        var l = args[0];
        var c = args[1];
        var h = args[2];
        var ref = lch2lab(l, c, h);
        var L = ref[0];
        var a = ref[1];
        var b_ = ref[2];
        var ref$1 = oklab2rgb(L, a, b_);
        var r = ref$1[0];
        var g = ref$1[1];
        var b = ref$1[2];
        return [r, g, b, args.length > 3 ? args[3] : 1];
      };
      var rgb2oklch = function() {
        var args = [], len = arguments.length;
        while (len--) args[len] = arguments[len];
        var ref = unpack(args, "rgb");
        var r = ref[0];
        var g = ref[1];
        var b = ref[2];
        var ref$1 = rgb2oklab(r, g, b);
        var l = ref$1[0];
        var a = ref$1[1];
        var b_ = ref$1[2];
        return lab2lch(l, a, b_);
      };
      Color.prototype.oklch = function() {
        return rgb2oklch(this._rgb);
      };
      chroma.oklch = function() {
        var args = [], len = arguments.length;
        while (len--) args[len] = arguments[len];
        return new (Function.prototype.bind.apply(Color, [null].concat(args, ["oklch"])))();
      };
      input.format.oklch = oklch2rgb;
      input.autodetect.push({
        p: 3,
        test: function() {
          var args = [], len = arguments.length;
          while (len--) args[len] = arguments[len];
          args = unpack(args, "oklch");
          if (type(args) === "array" && args.length === 3) {
            return "oklch";
          }
        }
      });
      Color.prototype.alpha = function(a, mutate) {
        if (mutate === void 0) mutate = false;
        if (a !== void 0 && type(a) === "number") {
          if (mutate) {
            this._rgb[3] = a;
            return this;
          }
          return new Color([this._rgb[0], this._rgb[1], this._rgb[2], a], "rgb");
        }
        return this._rgb[3];
      };
      Color.prototype.clipped = function() {
        return this._rgb._clipped || false;
      };
      Color.prototype.darken = function(amount) {
        if (amount === void 0) amount = 1;
        var me = this;
        var lab2 = me.lab();
        lab2[0] -= LAB_CONSTANTS.Kn * amount;
        return new Color(lab2, "lab").alpha(me.alpha(), true);
      };
      Color.prototype.brighten = function(amount) {
        if (amount === void 0) amount = 1;
        return this.darken(-amount);
      };
      Color.prototype.darker = Color.prototype.darken;
      Color.prototype.brighter = Color.prototype.brighten;
      Color.prototype.get = function(mc) {
        var ref = mc.split(".");
        var mode = ref[0];
        var channel = ref[1];
        var src = this[mode]();
        if (channel) {
          var i2 = mode.indexOf(channel) - (mode.substr(0, 2) === "ok" ? 2 : 0);
          if (i2 > -1) {
            return src[i2];
          }
          throw new Error("unknown channel " + channel + " in mode " + mode);
        } else {
          return src;
        }
      };
      var pow$6 = Math.pow;
      var EPS = 1e-7;
      var MAX_ITER = 20;
      Color.prototype.luminance = function(lum, mode) {
        if (mode === void 0) mode = "rgb";
        if (lum !== void 0 && type(lum) === "number") {
          if (lum === 0) {
            return new Color([0, 0, 0, this._rgb[3]], "rgb");
          }
          if (lum === 1) {
            return new Color([255, 255, 255, this._rgb[3]], "rgb");
          }
          var cur_lum = this.luminance();
          var max_iter = MAX_ITER;
          var test = function(low, high) {
            var mid = low.interpolate(high, 0.5, mode);
            var lm = mid.luminance();
            if (Math.abs(lum - lm) < EPS || !max_iter--) {
              return mid;
            }
            return lm > lum ? test(low, mid) : test(mid, high);
          };
          var rgb2 = (cur_lum > lum ? test(new Color([0, 0, 0]), this) : test(this, new Color([255, 255, 255]))).rgb();
          return new Color(rgb2.concat([this._rgb[3]]));
        }
        return rgb2luminance.apply(void 0, this._rgb.slice(0, 3));
      };
      var rgb2luminance = function(r, g, b) {
        r = luminance_x(r);
        g = luminance_x(g);
        b = luminance_x(b);
        return 0.2126 * r + 0.7152 * g + 0.0722 * b;
      };
      var luminance_x = function(x) {
        x /= 255;
        return x <= 0.03928 ? x / 12.92 : pow$6((x + 0.055) / 1.055, 2.4);
      };
      var index = {};
      function mix(col1, col2, f) {
        if (f === void 0) f = 0.5;
        var rest = [], len = arguments.length - 3;
        while (len-- > 0) rest[len] = arguments[len + 3];
        var mode = rest[0] || "lrgb";
        if (!index[mode] && !rest.length) {
          mode = Object.keys(index)[0];
        }
        if (!index[mode]) {
          throw new Error("interpolation mode " + mode + " is not defined");
        }
        if (type(col1) !== "object") {
          col1 = new Color(col1);
        }
        if (type(col2) !== "object") {
          col2 = new Color(col2);
        }
        return index[mode](col1, col2, f).alpha(
          col1.alpha() + f * (col2.alpha() - col1.alpha())
        );
      }
      Color.prototype.mix = Color.prototype.interpolate = function(col2, f) {
        if (f === void 0) f = 0.5;
        var rest = [], len = arguments.length - 2;
        while (len-- > 0) rest[len] = arguments[len + 2];
        return mix.apply(void 0, [this, col2, f].concat(rest));
      };
      Color.prototype.premultiply = function(mutate) {
        if (mutate === void 0) mutate = false;
        var rgb2 = this._rgb;
        var a = rgb2[3];
        if (mutate) {
          this._rgb = [rgb2[0] * a, rgb2[1] * a, rgb2[2] * a, a];
          return this;
        } else {
          return new Color([rgb2[0] * a, rgb2[1] * a, rgb2[2] * a, a], "rgb");
        }
      };
      Color.prototype.saturate = function(amount) {
        if (amount === void 0) amount = 1;
        var me = this;
        var lch2 = me.lch();
        lch2[1] += LAB_CONSTANTS.Kn * amount;
        if (lch2[1] < 0) {
          lch2[1] = 0;
        }
        return new Color(lch2, "lch").alpha(me.alpha(), true);
      };
      Color.prototype.desaturate = function(amount) {
        if (amount === void 0) amount = 1;
        return this.saturate(-amount);
      };
      Color.prototype.set = function(mc, value, mutate) {
        if (mutate === void 0) mutate = false;
        var ref = mc.split(".");
        var mode = ref[0];
        var channel = ref[1];
        var src = this[mode]();
        if (channel) {
          var i2 = mode.indexOf(channel) - (mode.substr(0, 2) === "ok" ? 2 : 0);
          if (i2 > -1) {
            if (type(value) == "string") {
              switch (value.charAt(0)) {
                case "+":
                  src[i2] += +value;
                  break;
                case "-":
                  src[i2] += +value;
                  break;
                case "*":
                  src[i2] *= +value.substr(1);
                  break;
                case "/":
                  src[i2] /= +value.substr(1);
                  break;
                default:
                  src[i2] = +value;
              }
            } else if (type(value) === "number") {
              src[i2] = value;
            } else {
              throw new Error("unsupported value for Color.set");
            }
            var out = new Color(src, mode);
            if (mutate) {
              this._rgb = out._rgb;
              return this;
            }
            return out;
          }
          throw new Error("unknown channel " + channel + " in mode " + mode);
        } else {
          return src;
        }
      };
      Color.prototype.tint = function(f) {
        if (f === void 0) f = 0.5;
        var rest = [], len = arguments.length - 1;
        while (len-- > 0) rest[len] = arguments[len + 1];
        return mix.apply(void 0, [this, "white", f].concat(rest));
      };
      Color.prototype.shade = function(f) {
        if (f === void 0) f = 0.5;
        var rest = [], len = arguments.length - 1;
        while (len-- > 0) rest[len] = arguments[len + 1];
        return mix.apply(void 0, [this, "black", f].concat(rest));
      };
      var rgb = function(col1, col2, f) {
        var xyz0 = col1._rgb;
        var xyz1 = col2._rgb;
        return new Color(
          xyz0[0] + f * (xyz1[0] - xyz0[0]),
          xyz0[1] + f * (xyz1[1] - xyz0[1]),
          xyz0[2] + f * (xyz1[2] - xyz0[2]),
          "rgb"
        );
      };
      index.rgb = rgb;
      var sqrt$2 = Math.sqrt;
      var pow$5 = Math.pow;
      var lrgb = function(col1, col2, f) {
        var ref = col1._rgb;
        var x1 = ref[0];
        var y1 = ref[1];
        var z1 = ref[2];
        var ref$1 = col2._rgb;
        var x2 = ref$1[0];
        var y2 = ref$1[1];
        var z2 = ref$1[2];
        return new Color(
          sqrt$2(pow$5(x1, 2) * (1 - f) + pow$5(x2, 2) * f),
          sqrt$2(pow$5(y1, 2) * (1 - f) + pow$5(y2, 2) * f),
          sqrt$2(pow$5(z1, 2) * (1 - f) + pow$5(z2, 2) * f),
          "rgb"
        );
      };
      index.lrgb = lrgb;
      var lab = function(col1, col2, f) {
        var xyz0 = col1.lab();
        var xyz1 = col2.lab();
        return new Color(
          xyz0[0] + f * (xyz1[0] - xyz0[0]),
          xyz0[1] + f * (xyz1[1] - xyz0[1]),
          xyz0[2] + f * (xyz1[2] - xyz0[2]),
          "lab"
        );
      };
      index.lab = lab;
      function interpolate_hsx(col1, col2, f, m) {
        var assign, assign$1;
        var xyz0, xyz1;
        if (m === "hsl") {
          xyz0 = col1.hsl();
          xyz1 = col2.hsl();
        } else if (m === "hsv") {
          xyz0 = col1.hsv();
          xyz1 = col2.hsv();
        } else if (m === "hcg") {
          xyz0 = col1.hcg();
          xyz1 = col2.hcg();
        } else if (m === "hsi") {
          xyz0 = col1.hsi();
          xyz1 = col2.hsi();
        } else if (m === "lch" || m === "hcl") {
          m = "hcl";
          xyz0 = col1.hcl();
          xyz1 = col2.hcl();
        } else if (m === "oklch") {
          xyz0 = col1.oklch().reverse();
          xyz1 = col2.oklch().reverse();
        }
        var hue0, hue1, sat0, sat1, lbv0, lbv1;
        if (m.substr(0, 1) === "h" || m === "oklch") {
          assign = xyz0, hue0 = assign[0], sat0 = assign[1], lbv0 = assign[2];
          assign$1 = xyz1, hue1 = assign$1[0], sat1 = assign$1[1], lbv1 = assign$1[2];
        }
        var sat, hue, lbv, dh;
        if (!isNaN(hue0) && !isNaN(hue1)) {
          if (hue1 > hue0 && hue1 - hue0 > 180) {
            dh = hue1 - (hue0 + 360);
          } else if (hue1 < hue0 && hue0 - hue1 > 180) {
            dh = hue1 + 360 - hue0;
          } else {
            dh = hue1 - hue0;
          }
          hue = hue0 + f * dh;
        } else if (!isNaN(hue0)) {
          hue = hue0;
          if ((lbv1 == 1 || lbv1 == 0) && m != "hsv") {
            sat = sat0;
          }
        } else if (!isNaN(hue1)) {
          hue = hue1;
          if ((lbv0 == 1 || lbv0 == 0) && m != "hsv") {
            sat = sat1;
          }
        } else {
          hue = Number.NaN;
        }
        if (sat === void 0) {
          sat = sat0 + f * (sat1 - sat0);
        }
        lbv = lbv0 + f * (lbv1 - lbv0);
        return m === "oklch" ? new Color([lbv, sat, hue], m) : new Color([hue, sat, lbv], m);
      }
      var lch = function(col1, col2, f) {
        return interpolate_hsx(col1, col2, f, "lch");
      };
      index.lch = lch;
      index.hcl = lch;
      var num = function(col1, col2, f) {
        var c1 = col1.num();
        var c2 = col2.num();
        return new Color(c1 + f * (c2 - c1), "num");
      };
      index.num = num;
      var hcg = function(col1, col2, f) {
        return interpolate_hsx(col1, col2, f, "hcg");
      };
      index.hcg = hcg;
      var hsi = function(col1, col2, f) {
        return interpolate_hsx(col1, col2, f, "hsi");
      };
      index.hsi = hsi;
      var hsl = function(col1, col2, f) {
        return interpolate_hsx(col1, col2, f, "hsl");
      };
      index.hsl = hsl;
      var hsv = function(col1, col2, f) {
        return interpolate_hsx(col1, col2, f, "hsv");
      };
      index.hsv = hsv;
      var oklab = function(col1, col2, f) {
        var xyz0 = col1.oklab();
        var xyz1 = col2.oklab();
        return new Color(
          xyz0[0] + f * (xyz1[0] - xyz0[0]),
          xyz0[1] + f * (xyz1[1] - xyz0[1]),
          xyz0[2] + f * (xyz1[2] - xyz0[2]),
          "oklab"
        );
      };
      index.oklab = oklab;
      var oklch = function(col1, col2, f) {
        return interpolate_hsx(col1, col2, f, "oklch");
      };
      index.oklch = oklch;
      var pow$4 = Math.pow;
      var sqrt$1 = Math.sqrt;
      var PI$1 = Math.PI;
      var cos$2 = Math.cos;
      var sin$2 = Math.sin;
      var atan2$1 = Math.atan2;
      function average(colors, mode, weights) {
        if (mode === void 0) mode = "lrgb";
        if (weights === void 0) weights = null;
        var l = colors.length;
        if (!weights) {
          weights = Array.from(new Array(l)).map(function() {
            return 1;
          });
        }
        var k = l / weights.reduce(function(a, b) {
          return a + b;
        });
        weights.forEach(function(w, i3) {
          weights[i3] *= k;
        });
        colors = colors.map(function(c) {
          return new Color(c);
        });
        if (mode === "lrgb") {
          return _average_lrgb(colors, weights);
        }
        var first = colors.shift();
        var xyz = first.get(mode);
        var cnt = [];
        var dx = 0;
        var dy = 0;
        for (var i2 = 0; i2 < xyz.length; i2++) {
          xyz[i2] = (xyz[i2] || 0) * weights[0];
          cnt.push(isNaN(xyz[i2]) ? 0 : weights[0]);
          if (mode.charAt(i2) === "h" && !isNaN(xyz[i2])) {
            var A = xyz[i2] / 180 * PI$1;
            dx += cos$2(A) * weights[0];
            dy += sin$2(A) * weights[0];
          }
        }
        var alpha = first.alpha() * weights[0];
        colors.forEach(function(c, ci) {
          var xyz2 = c.get(mode);
          alpha += c.alpha() * weights[ci + 1];
          for (var i3 = 0; i3 < xyz.length; i3++) {
            if (!isNaN(xyz2[i3])) {
              cnt[i3] += weights[ci + 1];
              if (mode.charAt(i3) === "h") {
                var A2 = xyz2[i3] / 180 * PI$1;
                dx += cos$2(A2) * weights[ci + 1];
                dy += sin$2(A2) * weights[ci + 1];
              } else {
                xyz[i3] += xyz2[i3] * weights[ci + 1];
              }
            }
          }
        });
        for (var i$12 = 0; i$12 < xyz.length; i$12++) {
          if (mode.charAt(i$12) === "h") {
            var A$1 = atan2$1(dy / cnt[i$12], dx / cnt[i$12]) / PI$1 * 180;
            while (A$1 < 0) {
              A$1 += 360;
            }
            while (A$1 >= 360) {
              A$1 -= 360;
            }
            xyz[i$12] = A$1;
          } else {
            xyz[i$12] = xyz[i$12] / cnt[i$12];
          }
        }
        alpha /= l;
        return new Color(xyz, mode).alpha(alpha > 0.99999 ? 1 : alpha, true);
      }
      var _average_lrgb = function(colors, weights) {
        var l = colors.length;
        var xyz = [0, 0, 0, 0];
        for (var i2 = 0; i2 < colors.length; i2++) {
          var col = colors[i2];
          var f = weights[i2] / l;
          var rgb2 = col._rgb;
          xyz[0] += pow$4(rgb2[0], 2) * f;
          xyz[1] += pow$4(rgb2[1], 2) * f;
          xyz[2] += pow$4(rgb2[2], 2) * f;
          xyz[3] += rgb2[3] * f;
        }
        xyz[0] = sqrt$1(xyz[0]);
        xyz[1] = sqrt$1(xyz[1]);
        xyz[2] = sqrt$1(xyz[2]);
        if (xyz[3] > 0.9999999) {
          xyz[3] = 1;
        }
        return new Color(clip_rgb(xyz));
      };
      var pow$3 = Math.pow;
      function scale(colors) {
        var _mode = "rgb";
        var _nacol = chroma("#ccc");
        var _spread = 0;
        var _domain = [0, 1];
        var _pos = [];
        var _padding = [0, 0];
        var _classes = false;
        var _colors = [];
        var _out = false;
        var _min = 0;
        var _max = 1;
        var _correctLightness = false;
        var _colorCache = {};
        var _useCache = true;
        var _gamma = 1;
        var setColors = function(colors2) {
          colors2 = colors2 || ["#fff", "#000"];
          if (colors2 && type(colors2) === "string" && chroma.brewer && chroma.brewer[colors2.toLowerCase()]) {
            colors2 = chroma.brewer[colors2.toLowerCase()];
          }
          if (type(colors2) === "array") {
            if (colors2.length === 1) {
              colors2 = [colors2[0], colors2[0]];
            }
            colors2 = colors2.slice(0);
            for (var c = 0; c < colors2.length; c++) {
              colors2[c] = chroma(colors2[c]);
            }
            _pos.length = 0;
            for (var c$1 = 0; c$1 < colors2.length; c$1++) {
              _pos.push(c$1 / (colors2.length - 1));
            }
          }
          resetCache();
          return _colors = colors2;
        };
        var getClass = function(value) {
          if (_classes != null) {
            var n = _classes.length - 1;
            var i2 = 0;
            while (i2 < n && value >= _classes[i2]) {
              i2++;
            }
            return i2 - 1;
          }
          return 0;
        };
        var tMapLightness = function(t) {
          return t;
        };
        var tMapDomain = function(t) {
          return t;
        };
        var getColor = function(val, bypassMap) {
          var col, t;
          if (bypassMap == null) {
            bypassMap = false;
          }
          if (isNaN(val) || val === null) {
            return _nacol;
          }
          if (!bypassMap) {
            if (_classes && _classes.length > 2) {
              var c = getClass(val);
              t = c / (_classes.length - 2);
            } else if (_max !== _min) {
              t = (val - _min) / (_max - _min);
            } else {
              t = 1;
            }
          } else {
            t = val;
          }
          t = tMapDomain(t);
          if (!bypassMap) {
            t = tMapLightness(t);
          }
          if (_gamma !== 1) {
            t = pow$3(t, _gamma);
          }
          t = _padding[0] + t * (1 - _padding[0] - _padding[1]);
          t = limit(t, 0, 1);
          var k = Math.floor(t * 1e4);
          if (_useCache && _colorCache[k]) {
            col = _colorCache[k];
          } else {
            if (type(_colors) === "array") {
              for (var i2 = 0; i2 < _pos.length; i2++) {
                var p = _pos[i2];
                if (t <= p) {
                  col = _colors[i2];
                  break;
                }
                if (t >= p && i2 === _pos.length - 1) {
                  col = _colors[i2];
                  break;
                }
                if (t > p && t < _pos[i2 + 1]) {
                  t = (t - p) / (_pos[i2 + 1] - p);
                  col = chroma.interpolate(
                    _colors[i2],
                    _colors[i2 + 1],
                    t,
                    _mode
                  );
                  break;
                }
              }
            } else if (type(_colors) === "function") {
              col = _colors(t);
            }
            if (_useCache) {
              _colorCache[k] = col;
            }
          }
          return col;
        };
        var resetCache = function() {
          return _colorCache = {};
        };
        setColors(colors);
        var f = function(v) {
          var c = chroma(getColor(v));
          if (_out && c[_out]) {
            return c[_out]();
          } else {
            return c;
          }
        };
        f.classes = function(classes) {
          if (classes != null) {
            if (type(classes) === "array") {
              _classes = classes;
              _domain = [classes[0], classes[classes.length - 1]];
            } else {
              var d = chroma.analyze(_domain);
              if (classes === 0) {
                _classes = [d.min, d.max];
              } else {
                _classes = chroma.limits(d, "e", classes);
              }
            }
            return f;
          }
          return _classes;
        };
        f.domain = function(domain) {
          if (!arguments.length) {
            return _domain;
          }
          _min = domain[0];
          _max = domain[domain.length - 1];
          _pos = [];
          var k = _colors.length;
          if (domain.length === k && _min !== _max) {
            for (var i2 = 0, list2 = Array.from(domain); i2 < list2.length; i2 += 1) {
              var d = list2[i2];
              _pos.push((d - _min) / (_max - _min));
            }
          } else {
            for (var c = 0; c < k; c++) {
              _pos.push(c / (k - 1));
            }
            if (domain.length > 2) {
              var tOut = domain.map(function(d2, i3) {
                return i3 / (domain.length - 1);
              });
              var tBreaks = domain.map(function(d2) {
                return (d2 - _min) / (_max - _min);
              });
              if (!tBreaks.every(function(val, i3) {
                return tOut[i3] === val;
              })) {
                tMapDomain = function(t) {
                  if (t <= 0 || t >= 1) {
                    return t;
                  }
                  var i3 = 0;
                  while (t >= tBreaks[i3 + 1]) {
                    i3++;
                  }
                  var f2 = (t - tBreaks[i3]) / (tBreaks[i3 + 1] - tBreaks[i3]);
                  var out = tOut[i3] + f2 * (tOut[i3 + 1] - tOut[i3]);
                  return out;
                };
              }
            }
          }
          _domain = [_min, _max];
          return f;
        };
        f.mode = function(_m) {
          if (!arguments.length) {
            return _mode;
          }
          _mode = _m;
          resetCache();
          return f;
        };
        f.range = function(colors2, _pos2) {
          setColors(colors2);
          return f;
        };
        f.out = function(_o) {
          _out = _o;
          return f;
        };
        f.spread = function(val) {
          if (!arguments.length) {
            return _spread;
          }
          _spread = val;
          return f;
        };
        f.correctLightness = function(v) {
          if (v == null) {
            v = true;
          }
          _correctLightness = v;
          resetCache();
          if (_correctLightness) {
            tMapLightness = function(t) {
              var L0 = getColor(0, true).lab()[0];
              var L1 = getColor(1, true).lab()[0];
              var pol = L0 > L1;
              var L_actual = getColor(t, true).lab()[0];
              var L_ideal = L0 + (L1 - L0) * t;
              var L_diff = L_actual - L_ideal;
              var t0 = 0;
              var t1 = 1;
              var max_iter = 20;
              while (Math.abs(L_diff) > 0.01 && max_iter-- > 0) {
                (function() {
                  if (pol) {
                    L_diff *= -1;
                  }
                  if (L_diff < 0) {
                    t0 = t;
                    t += (t1 - t) * 0.5;
                  } else {
                    t1 = t;
                    t += (t0 - t) * 0.5;
                  }
                  L_actual = getColor(t, true).lab()[0];
                  return L_diff = L_actual - L_ideal;
                })();
              }
              return t;
            };
          } else {
            tMapLightness = function(t) {
              return t;
            };
          }
          return f;
        };
        f.padding = function(p) {
          if (p != null) {
            if (type(p) === "number") {
              p = [p, p];
            }
            _padding = p;
            return f;
          } else {
            return _padding;
          }
        };
        f.colors = function(numColors, out) {
          if (arguments.length < 2) {
            out = "hex";
          }
          var result = [];
          if (arguments.length === 0) {
            result = _colors.slice(0);
          } else if (numColors === 1) {
            result = [f(0.5)];
          } else if (numColors > 1) {
            var dm = _domain[0];
            var dd = _domain[1] - dm;
            result = __range__(0, numColors).map(
              function(i3) {
                return f(dm + i3 / (numColors - 1) * dd);
              }
            );
          } else {
            colors = [];
            var samples = [];
            if (_classes && _classes.length > 2) {
              for (var i2 = 1, end = _classes.length, asc = 1 <= end; asc ? i2 < end : i2 > end; asc ? i2++ : i2--) {
                samples.push((_classes[i2 - 1] + _classes[i2]) * 0.5);
              }
            } else {
              samples = _domain;
            }
            result = samples.map(function(v) {
              return f(v);
            });
          }
          if (chroma[out]) {
            result = result.map(function(c) {
              return c[out]();
            });
          }
          return result;
        };
        f.cache = function(c) {
          if (c != null) {
            _useCache = c;
            return f;
          } else {
            return _useCache;
          }
        };
        f.gamma = function(g) {
          if (g != null) {
            _gamma = g;
            return f;
          } else {
            return _gamma;
          }
        };
        f.nodata = function(d) {
          if (d != null) {
            _nacol = chroma(d);
            return f;
          } else {
            return _nacol;
          }
        };
        return f;
      }
      function __range__(left, right, inclusive) {
        var range = [];
        var ascending = left < right;
        var end = right;
        for (var i2 = left; ascending ? i2 < end : i2 > end; ascending ? i2++ : i2--) {
          range.push(i2);
        }
        return range;
      }
      var binom_row = function(n) {
        var row = [1, 1];
        for (var i2 = 1; i2 < n; i2++) {
          var newrow = [1];
          for (var j = 1; j <= row.length; j++) {
            newrow[j] = (row[j] || 0) + row[j - 1];
          }
          row = newrow;
        }
        return row;
      };
      var bezier = function(colors) {
        var assign, assign$1, assign$2;
        var I, lab0, lab1, lab2;
        colors = colors.map(function(c) {
          return new Color(c);
        });
        if (colors.length === 2) {
          assign = colors.map(function(c) {
            return c.lab();
          }), lab0 = assign[0], lab1 = assign[1];
          I = function(t) {
            var lab4 = [0, 1, 2].map(function(i2) {
              return lab0[i2] + t * (lab1[i2] - lab0[i2]);
            });
            return new Color(lab4, "lab");
          };
        } else if (colors.length === 3) {
          assign$1 = colors.map(function(c) {
            return c.lab();
          }), lab0 = assign$1[0], lab1 = assign$1[1], lab2 = assign$1[2];
          I = function(t) {
            var lab4 = [0, 1, 2].map(
              function(i2) {
                return (1 - t) * (1 - t) * lab0[i2] + 2 * (1 - t) * t * lab1[i2] + t * t * lab2[i2];
              }
            );
            return new Color(lab4, "lab");
          };
        } else if (colors.length === 4) {
          var lab3;
          assign$2 = colors.map(function(c) {
            return c.lab();
          }), lab0 = assign$2[0], lab1 = assign$2[1], lab2 = assign$2[2], lab3 = assign$2[3];
          I = function(t) {
            var lab4 = [0, 1, 2].map(
              function(i2) {
                return (1 - t) * (1 - t) * (1 - t) * lab0[i2] + 3 * (1 - t) * (1 - t) * t * lab1[i2] + 3 * (1 - t) * t * t * lab2[i2] + t * t * t * lab3[i2];
              }
            );
            return new Color(lab4, "lab");
          };
        } else if (colors.length >= 5) {
          var labs, row, n;
          labs = colors.map(function(c) {
            return c.lab();
          });
          n = colors.length - 1;
          row = binom_row(n);
          I = function(t) {
            var u = 1 - t;
            var lab4 = [0, 1, 2].map(
              function(i2) {
                return labs.reduce(
                  function(sum, el, j) {
                    return sum + row[j] * Math.pow(u, n - j) * Math.pow(t, j) * el[i2];
                  },
                  0
                );
              }
            );
            return new Color(lab4, "lab");
          };
        } else {
          throw new RangeError("No point in running bezier with only one color.");
        }
        return I;
      };
      function bezier$1(colors) {
        var f = bezier(colors);
        f.scale = function() {
          return scale(f);
        };
        return f;
      }
      var blend = function(bottom, top, mode) {
        if (!blend[mode]) {
          throw new Error("unknown blend mode " + mode);
        }
        return blend[mode](bottom, top);
      };
      var blend_f = function(f) {
        return function(bottom, top) {
          var c0 = chroma(top).rgb();
          var c1 = chroma(bottom).rgb();
          return chroma.rgb(f(c0, c1));
        };
      };
      var each = function(f) {
        return function(c0, c1) {
          var out = [];
          out[0] = f(c0[0], c1[0]);
          out[1] = f(c0[1], c1[1]);
          out[2] = f(c0[2], c1[2]);
          return out;
        };
      };
      var normal = function(a) {
        return a;
      };
      var multiply = function(a, b) {
        return a * b / 255;
      };
      var darken = function(a, b) {
        return a > b ? b : a;
      };
      var lighten = function(a, b) {
        return a > b ? a : b;
      };
      var screen = function(a, b) {
        return 255 * (1 - (1 - a / 255) * (1 - b / 255));
      };
      var overlay = function(a, b) {
        return b < 128 ? 2 * a * b / 255 : 255 * (1 - 2 * (1 - a / 255) * (1 - b / 255));
      };
      var burn = function(a, b) {
        return 255 * (1 - (1 - b / 255) / (a / 255));
      };
      var dodge = function(a, b) {
        if (a === 255) {
          return 255;
        }
        a = 255 * (b / 255) / (1 - a / 255);
        return a > 255 ? 255 : a;
      };
      blend.normal = blend_f(each(normal));
      blend.multiply = blend_f(each(multiply));
      blend.screen = blend_f(each(screen));
      blend.overlay = blend_f(each(overlay));
      blend.darken = blend_f(each(darken));
      blend.lighten = blend_f(each(lighten));
      blend.dodge = blend_f(each(dodge));
      blend.burn = blend_f(each(burn));
      var pow$2 = Math.pow;
      var sin$1 = Math.sin;
      var cos$1 = Math.cos;
      function cubehelix(start, rotations, hue, gamma, lightness) {
        if (start === void 0) start = 300;
        if (rotations === void 0) rotations = -1.5;
        if (hue === void 0) hue = 1;
        if (gamma === void 0) gamma = 1;
        if (lightness === void 0) lightness = [0, 1];
        var dh = 0, dl;
        if (type(lightness) === "array") {
          dl = lightness[1] - lightness[0];
        } else {
          dl = 0;
          lightness = [lightness, lightness];
        }
        var f = function(fract) {
          var a = TWOPI * ((start + 120) / 360 + rotations * fract);
          var l = pow$2(lightness[0] + dl * fract, gamma);
          var h = dh !== 0 ? hue[0] + fract * dh : hue;
          var amp = h * l * (1 - l) / 2;
          var cos_a = cos$1(a);
          var sin_a = sin$1(a);
          var r = l + amp * (-0.14861 * cos_a + 1.78277 * sin_a);
          var g = l + amp * (-0.29227 * cos_a - 0.90649 * sin_a);
          var b = l + amp * (1.97294 * cos_a);
          return chroma(clip_rgb([r * 255, g * 255, b * 255, 1]));
        };
        f.start = function(s) {
          if (s == null) {
            return start;
          }
          start = s;
          return f;
        };
        f.rotations = function(r) {
          if (r == null) {
            return rotations;
          }
          rotations = r;
          return f;
        };
        f.gamma = function(g) {
          if (g == null) {
            return gamma;
          }
          gamma = g;
          return f;
        };
        f.hue = function(h) {
          if (h == null) {
            return hue;
          }
          hue = h;
          if (type(hue) === "array") {
            dh = hue[1] - hue[0];
            if (dh === 0) {
              hue = hue[1];
            }
          } else {
            dh = 0;
          }
          return f;
        };
        f.lightness = function(h) {
          if (h == null) {
            return lightness;
          }
          if (type(h) === "array") {
            lightness = h;
            dl = h[1] - h[0];
          } else {
            lightness = [h, h];
            dl = 0;
          }
          return f;
        };
        f.scale = function() {
          return chroma.scale(f);
        };
        f.hue(hue);
        return f;
      }
      var digits = "0123456789abcdef";
      var floor$1 = Math.floor;
      var random = Math.random;
      function random$1() {
        var code = "#";
        for (var i2 = 0; i2 < 6; i2++) {
          code += digits.charAt(floor$1(random() * 16));
        }
        return new Color(code, "hex");
      }
      var log = Math.log;
      var pow$1 = Math.pow;
      var floor = Math.floor;
      var abs$1 = Math.abs;
      function analyze(data, key2) {
        if (key2 === void 0) key2 = null;
        var r = {
          min: Number.MAX_VALUE,
          max: Number.MAX_VALUE * -1,
          sum: 0,
          values: [],
          count: 0
        };
        if (type(data) === "object") {
          data = Object.values(data);
        }
        data.forEach(function(val) {
          if (key2 && type(val) === "object") {
            val = val[key2];
          }
          if (val !== void 0 && val !== null && !isNaN(val)) {
            r.values.push(val);
            r.sum += val;
            if (val < r.min) {
              r.min = val;
            }
            if (val > r.max) {
              r.max = val;
            }
            r.count += 1;
          }
        });
        r.domain = [r.min, r.max];
        r.limits = function(mode, num2) {
          return limits(r, mode, num2);
        };
        return r;
      }
      function limits(data, mode, num2) {
        if (mode === void 0) mode = "equal";
        if (num2 === void 0) num2 = 7;
        if (type(data) == "array") {
          data = analyze(data);
        }
        var min2 = data.min;
        var max2 = data.max;
        var values = data.values.sort(function(a, b) {
          return a - b;
        });
        if (num2 === 1) {
          return [min2, max2];
        }
        var limits2 = [];
        if (mode.substr(0, 1) === "c") {
          limits2.push(min2);
          limits2.push(max2);
        }
        if (mode.substr(0, 1) === "e") {
          limits2.push(min2);
          for (var i2 = 1; i2 < num2; i2++) {
            limits2.push(min2 + i2 / num2 * (max2 - min2));
          }
          limits2.push(max2);
        } else if (mode.substr(0, 1) === "l") {
          if (min2 <= 0) {
            throw new Error(
              "Logarithmic scales are only possible for values > 0"
            );
          }
          var min_log = Math.LOG10E * log(min2);
          var max_log = Math.LOG10E * log(max2);
          limits2.push(min2);
          for (var i$12 = 1; i$12 < num2; i$12++) {
            limits2.push(pow$1(10, min_log + i$12 / num2 * (max_log - min_log)));
          }
          limits2.push(max2);
        } else if (mode.substr(0, 1) === "q") {
          limits2.push(min2);
          for (var i$2 = 1; i$2 < num2; i$2++) {
            var p = (values.length - 1) * i$2 / num2;
            var pb = floor(p);
            if (pb === p) {
              limits2.push(values[pb]);
            } else {
              var pr = p - pb;
              limits2.push(values[pb] * (1 - pr) + values[pb + 1] * pr);
            }
          }
          limits2.push(max2);
        } else if (mode.substr(0, 1) === "k") {
          var cluster;
          var n = values.length;
          var assignments = new Array(n);
          var clusterSizes = new Array(num2);
          var repeat = true;
          var nb_iters = 0;
          var centroids = null;
          centroids = [];
          centroids.push(min2);
          for (var i$3 = 1; i$3 < num2; i$3++) {
            centroids.push(min2 + i$3 / num2 * (max2 - min2));
          }
          centroids.push(max2);
          while (repeat) {
            for (var j = 0; j < num2; j++) {
              clusterSizes[j] = 0;
            }
            for (var i$4 = 0; i$4 < n; i$4++) {
              var value = values[i$4];
              var mindist = Number.MAX_VALUE;
              var best = void 0;
              for (var j$1 = 0; j$1 < num2; j$1++) {
                var dist = abs$1(centroids[j$1] - value);
                if (dist < mindist) {
                  mindist = dist;
                  best = j$1;
                }
                clusterSizes[best]++;
                assignments[i$4] = best;
              }
            }
            var newCentroids = new Array(num2);
            for (var j$2 = 0; j$2 < num2; j$2++) {
              newCentroids[j$2] = null;
            }
            for (var i$5 = 0; i$5 < n; i$5++) {
              cluster = assignments[i$5];
              if (newCentroids[cluster] === null) {
                newCentroids[cluster] = values[i$5];
              } else {
                newCentroids[cluster] += values[i$5];
              }
            }
            for (var j$3 = 0; j$3 < num2; j$3++) {
              newCentroids[j$3] *= 1 / clusterSizes[j$3];
            }
            repeat = false;
            for (var j$4 = 0; j$4 < num2; j$4++) {
              if (newCentroids[j$4] !== centroids[j$4]) {
                repeat = true;
                break;
              }
            }
            centroids = newCentroids;
            nb_iters++;
            if (nb_iters > 200) {
              repeat = false;
            }
          }
          var kClusters = {};
          for (var j$5 = 0; j$5 < num2; j$5++) {
            kClusters[j$5] = [];
          }
          for (var i$6 = 0; i$6 < n; i$6++) {
            cluster = assignments[i$6];
            kClusters[cluster].push(values[i$6]);
          }
          var tmpKMeansBreaks = [];
          for (var j$6 = 0; j$6 < num2; j$6++) {
            tmpKMeansBreaks.push(kClusters[j$6][0]);
            tmpKMeansBreaks.push(kClusters[j$6][kClusters[j$6].length - 1]);
          }
          tmpKMeansBreaks = tmpKMeansBreaks.sort(function(a, b) {
            return a - b;
          });
          limits2.push(tmpKMeansBreaks[0]);
          for (var i$7 = 1; i$7 < tmpKMeansBreaks.length; i$7 += 2) {
            var v = tmpKMeansBreaks[i$7];
            if (!isNaN(v) && limits2.indexOf(v) === -1) {
              limits2.push(v);
            }
          }
        }
        return limits2;
      }
      function contrast(a, b) {
        a = new Color(a);
        b = new Color(b);
        var l1 = a.luminance();
        var l2 = b.luminance();
        return l1 > l2 ? (l1 + 0.05) / (l2 + 0.05) : (l2 + 0.05) / (l1 + 0.05);
      }
      var sqrt = Math.sqrt;
      var pow = Math.pow;
      var min = Math.min;
      var max = Math.max;
      var atan2 = Math.atan2;
      var abs = Math.abs;
      var cos = Math.cos;
      var sin = Math.sin;
      var exp = Math.exp;
      var PI = Math.PI;
      function deltaE(a, b, Kl, Kc, Kh) {
        if (Kl === void 0) Kl = 1;
        if (Kc === void 0) Kc = 1;
        if (Kh === void 0) Kh = 1;
        var rad2deg = function(rad) {
          return 360 * rad / (2 * PI);
        };
        var deg2rad = function(deg) {
          return 2 * PI * deg / 360;
        };
        a = new Color(a);
        b = new Color(b);
        var ref = Array.from(a.lab());
        var L1 = ref[0];
        var a1 = ref[1];
        var b1 = ref[2];
        var ref$1 = Array.from(b.lab());
        var L2 = ref$1[0];
        var a2 = ref$1[1];
        var b2 = ref$1[2];
        var avgL = (L1 + L2) / 2;
        var C1 = sqrt(pow(a1, 2) + pow(b1, 2));
        var C2 = sqrt(pow(a2, 2) + pow(b2, 2));
        var avgC = (C1 + C2) / 2;
        var G = 0.5 * (1 - sqrt(pow(avgC, 7) / (pow(avgC, 7) + pow(25, 7))));
        var a1p = a1 * (1 + G);
        var a2p = a2 * (1 + G);
        var C1p = sqrt(pow(a1p, 2) + pow(b1, 2));
        var C2p = sqrt(pow(a2p, 2) + pow(b2, 2));
        var avgCp = (C1p + C2p) / 2;
        var arctan1 = rad2deg(atan2(b1, a1p));
        var arctan2 = rad2deg(atan2(b2, a2p));
        var h1p = arctan1 >= 0 ? arctan1 : arctan1 + 360;
        var h2p = arctan2 >= 0 ? arctan2 : arctan2 + 360;
        var avgHp = abs(h1p - h2p) > 180 ? (h1p + h2p + 360) / 2 : (h1p + h2p) / 2;
        var T = 1 - 0.17 * cos(deg2rad(avgHp - 30)) + 0.24 * cos(deg2rad(2 * avgHp)) + 0.32 * cos(deg2rad(3 * avgHp + 6)) - 0.2 * cos(deg2rad(4 * avgHp - 63));
        var deltaHp = h2p - h1p;
        deltaHp = abs(deltaHp) <= 180 ? deltaHp : h2p <= h1p ? deltaHp + 360 : deltaHp - 360;
        deltaHp = 2 * sqrt(C1p * C2p) * sin(deg2rad(deltaHp) / 2);
        var deltaL = L2 - L1;
        var deltaCp = C2p - C1p;
        var sl = 1 + 0.015 * pow(avgL - 50, 2) / sqrt(20 + pow(avgL - 50, 2));
        var sc = 1 + 0.045 * avgCp;
        var sh = 1 + 0.015 * avgCp * T;
        var deltaTheta = 30 * exp(-pow((avgHp - 275) / 25, 2));
        var Rc = 2 * sqrt(pow(avgCp, 7) / (pow(avgCp, 7) + pow(25, 7)));
        var Rt = -Rc * sin(2 * deg2rad(deltaTheta));
        var result = sqrt(
          pow(deltaL / (Kl * sl), 2) + pow(deltaCp / (Kc * sc), 2) + pow(deltaHp / (Kh * sh), 2) + Rt * (deltaCp / (Kc * sc)) * (deltaHp / (Kh * sh))
        );
        return max(0, min(100, result));
      }
      function distance(a, b, mode) {
        if (mode === void 0) mode = "lab";
        a = new Color(a);
        b = new Color(b);
        var l1 = a.get(mode);
        var l2 = b.get(mode);
        var sum_sq = 0;
        for (var i2 in l1) {
          var d = (l1[i2] || 0) - (l2[i2] || 0);
          sum_sq += d * d;
        }
        return Math.sqrt(sum_sq);
      }
      function valid() {
        var args = [], len = arguments.length;
        while (len--) args[len] = arguments[len];
        try {
          new (Function.prototype.bind.apply(Color, [null].concat(args)))();
          return true;
        } catch (e) {
          return false;
        }
      }
      var scales = {
        cool: function cool() {
          return scale([chroma.hsl(180, 1, 0.9), chroma.hsl(250, 0.7, 0.4)]);
        },
        hot: function hot() {
          return scale(["#000", "#f00", "#ff0", "#fff"]).mode(
            "rgb"
          );
        }
      };
      var colorbrewer = {
        // sequential
        OrRd: ["#fff7ec", "#fee8c8", "#fdd49e", "#fdbb84", "#fc8d59", "#ef6548", "#d7301f", "#b30000", "#7f0000"],
        PuBu: ["#fff7fb", "#ece7f2", "#d0d1e6", "#a6bddb", "#74a9cf", "#3690c0", "#0570b0", "#045a8d", "#023858"],
        BuPu: ["#f7fcfd", "#e0ecf4", "#bfd3e6", "#9ebcda", "#8c96c6", "#8c6bb1", "#88419d", "#810f7c", "#4d004b"],
        Oranges: ["#fff5eb", "#fee6ce", "#fdd0a2", "#fdae6b", "#fd8d3c", "#f16913", "#d94801", "#a63603", "#7f2704"],
        BuGn: ["#f7fcfd", "#e5f5f9", "#ccece6", "#99d8c9", "#66c2a4", "#41ae76", "#238b45", "#006d2c", "#00441b"],
        YlOrBr: ["#ffffe5", "#fff7bc", "#fee391", "#fec44f", "#fe9929", "#ec7014", "#cc4c02", "#993404", "#662506"],
        YlGn: ["#ffffe5", "#f7fcb9", "#d9f0a3", "#addd8e", "#78c679", "#41ab5d", "#238443", "#006837", "#004529"],
        Reds: ["#fff5f0", "#fee0d2", "#fcbba1", "#fc9272", "#fb6a4a", "#ef3b2c", "#cb181d", "#a50f15", "#67000d"],
        RdPu: ["#fff7f3", "#fde0dd", "#fcc5c0", "#fa9fb5", "#f768a1", "#dd3497", "#ae017e", "#7a0177", "#49006a"],
        Greens: ["#f7fcf5", "#e5f5e0", "#c7e9c0", "#a1d99b", "#74c476", "#41ab5d", "#238b45", "#006d2c", "#00441b"],
        YlGnBu: ["#ffffd9", "#edf8b1", "#c7e9b4", "#7fcdbb", "#41b6c4", "#1d91c0", "#225ea8", "#253494", "#081d58"],
        Purples: ["#fcfbfd", "#efedf5", "#dadaeb", "#bcbddc", "#9e9ac8", "#807dba", "#6a51a3", "#54278f", "#3f007d"],
        GnBu: ["#f7fcf0", "#e0f3db", "#ccebc5", "#a8ddb5", "#7bccc4", "#4eb3d3", "#2b8cbe", "#0868ac", "#084081"],
        Greys: ["#ffffff", "#f0f0f0", "#d9d9d9", "#bdbdbd", "#969696", "#737373", "#525252", "#252525", "#000000"],
        YlOrRd: ["#ffffcc", "#ffeda0", "#fed976", "#feb24c", "#fd8d3c", "#fc4e2a", "#e31a1c", "#bd0026", "#800026"],
        PuRd: ["#f7f4f9", "#e7e1ef", "#d4b9da", "#c994c7", "#df65b0", "#e7298a", "#ce1256", "#980043", "#67001f"],
        Blues: ["#f7fbff", "#deebf7", "#c6dbef", "#9ecae1", "#6baed6", "#4292c6", "#2171b5", "#08519c", "#08306b"],
        PuBuGn: ["#fff7fb", "#ece2f0", "#d0d1e6", "#a6bddb", "#67a9cf", "#3690c0", "#02818a", "#016c59", "#014636"],
        Viridis: ["#440154", "#482777", "#3f4a8a", "#31678e", "#26838f", "#1f9d8a", "#6cce5a", "#b6de2b", "#fee825"],
        // diverging
        Spectral: ["#9e0142", "#d53e4f", "#f46d43", "#fdae61", "#fee08b", "#ffffbf", "#e6f598", "#abdda4", "#66c2a5", "#3288bd", "#5e4fa2"],
        RdYlGn: ["#a50026", "#d73027", "#f46d43", "#fdae61", "#fee08b", "#ffffbf", "#d9ef8b", "#a6d96a", "#66bd63", "#1a9850", "#006837"],
        RdBu: ["#67001f", "#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#f7f7f7", "#d1e5f0", "#92c5de", "#4393c3", "#2166ac", "#053061"],
        PiYG: ["#8e0152", "#c51b7d", "#de77ae", "#f1b6da", "#fde0ef", "#f7f7f7", "#e6f5d0", "#b8e186", "#7fbc41", "#4d9221", "#276419"],
        PRGn: ["#40004b", "#762a83", "#9970ab", "#c2a5cf", "#e7d4e8", "#f7f7f7", "#d9f0d3", "#a6dba0", "#5aae61", "#1b7837", "#00441b"],
        RdYlBu: ["#a50026", "#d73027", "#f46d43", "#fdae61", "#fee090", "#ffffbf", "#e0f3f8", "#abd9e9", "#74add1", "#4575b4", "#313695"],
        BrBG: ["#543005", "#8c510a", "#bf812d", "#dfc27d", "#f6e8c3", "#f5f5f5", "#c7eae5", "#80cdc1", "#35978f", "#01665e", "#003c30"],
        RdGy: ["#67001f", "#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#ffffff", "#e0e0e0", "#bababa", "#878787", "#4d4d4d", "#1a1a1a"],
        PuOr: ["#7f3b08", "#b35806", "#e08214", "#fdb863", "#fee0b6", "#f7f7f7", "#d8daeb", "#b2abd2", "#8073ac", "#542788", "#2d004b"],
        // qualitative
        Set2: ["#66c2a5", "#fc8d62", "#8da0cb", "#e78ac3", "#a6d854", "#ffd92f", "#e5c494", "#b3b3b3"],
        Accent: ["#7fc97f", "#beaed4", "#fdc086", "#ffff99", "#386cb0", "#f0027f", "#bf5b17", "#666666"],
        Set1: ["#e41a1c", "#377eb8", "#4daf4a", "#984ea3", "#ff7f00", "#ffff33", "#a65628", "#f781bf", "#999999"],
        Set3: ["#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3", "#fdb462", "#b3de69", "#fccde5", "#d9d9d9", "#bc80bd", "#ccebc5", "#ffed6f"],
        Dark2: ["#1b9e77", "#d95f02", "#7570b3", "#e7298a", "#66a61e", "#e6ab02", "#a6761d", "#666666"],
        Paired: ["#a6cee3", "#1f78b4", "#b2df8a", "#33a02c", "#fb9a99", "#e31a1c", "#fdbf6f", "#ff7f00", "#cab2d6", "#6a3d9a", "#ffff99", "#b15928"],
        Pastel2: ["#b3e2cd", "#fdcdac", "#cbd5e8", "#f4cae4", "#e6f5c9", "#fff2ae", "#f1e2cc", "#cccccc"],
        Pastel1: ["#fbb4ae", "#b3cde3", "#ccebc5", "#decbe4", "#fed9a6", "#ffffcc", "#e5d8bd", "#fddaec", "#f2f2f2"]
      };
      for (var i = 0, list = Object.keys(colorbrewer); i < list.length; i += 1) {
        var key = list[i];
        colorbrewer[key.toLowerCase()] = colorbrewer[key];
      }
      Object.assign(chroma, {
        average,
        bezier: bezier$1,
        blend,
        cubehelix,
        mix,
        interpolate: mix,
        random: random$1,
        scale,
        analyze,
        contrast,
        deltaE,
        distance,
        limits,
        valid,
        scales,
        input,
        colors: w3cx11,
        brewer: colorbrewer
      });
      return chroma;
    }));
  }
});

// node_modules/@splunk/visualization-encoding/utils/parserUtils.js
var require_parserUtils = __commonJS({
  "node_modules/@splunk/visualization-encoding/utils/parserUtils.js"(exports2, module2) {
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var __create = Object.create;
    var __defProp = Object.defineProperty;
    var __defProps = Object.defineProperties;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __getOwnPropSymbols = Object.getOwnPropertySymbols;
    var __getProtoOf = Object.getPrototypeOf;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __propIsEnum = Object.prototype.propertyIsEnumerable;
    var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
    var __spreadValues = (a, b) => {
      for (var prop in b || (b = {}))
        if (__hasOwnProp.call(b, prop))
          __defNormalProp(a, prop, b[prop]);
      if (__getOwnPropSymbols)
        for (var prop of __getOwnPropSymbols(b)) {
          if (__propIsEnum.call(b, prop))
            __defNormalProp(a, prop, b[prop]);
        }
      return a;
    };
    var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
    var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
      // If the importer is in node compatibility mode or this is not an ESM
      // file that has been converted to a CommonJS file using a Babel-
      // compatible transform (i.e. "__esModule" has not been set), then set
      // "default" to the CommonJS "module.exports" for node compatibility.
      isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
      mod
    ));
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var parserUtils_exports = {};
    __export2(parserUtils_exports, {
      INVALID_VALUE: () => INVALID_VALUE,
      MAX_LOGGED_FORMATTER_ERRORS: () => MAX_LOGGED_FORMATTER_ERRORS,
      NON_NUMERIC_RANGE_ERROR: () => NON_NUMERIC_RANGE_ERROR,
      VALUES_AND_RANGES_HAVE_DIFFERENT_LENGTH: () => VALUES_AND_RANGES_HAVE_DIFFERENT_LENGTH,
      categoryFormat: () => categoryFormat,
      colorGradientFormat: () => colorGradientFormat,
      drawSample: () => drawSample,
      getDataTypeForPoint: () => getDataTypeForPoint,
      getFormatter: () => getFormatter,
      inferDataTypeFromSample: () => inferDataTypeFromSample,
      matchValueFormat: () => matchValueFormat,
      mergeEncoding: () => mergeEncoding,
      newFormatterErrorHandler: () => newFormatterErrorHandler,
      parse: () => parse,
      parseFieldRangeReference: () => parseFieldRangeReference,
      parseIndexBasedFieldReference: () => parseIndexBasedFieldReference,
      parseNameBasedFieldReference: () => parseNameBasedFieldReference,
      rangeFormat: () => rangeFormat,
      rangeValueFormat: () => rangeValueFormat
    });
    module2.exports = __toCommonJS2(parserUtils_exports);
    var chroma_js_exports = {};
    __export2(chroma_js_exports, {
      default: () => chroma_js_default
    });
    var defaultImport = __toESM2(require_chroma());
    __reExport(chroma_js_exports, require_chroma());
    var chroma_js_default = "default" in defaultImport ? defaultImport.default : defaultImport;
    var lodash_exports = {};
    __export2(lodash_exports, {
      default: () => lodash_default
    });
    var defaultImport2 = __toESM2(require_lodash());
    __reExport(lodash_exports, require_lodash());
    var lodash_default = "default" in defaultImport2 ? defaultImport2.default : defaultImport2;
    var { hasOwnProperty } = Object.prototype;
    var getDataTypeForPoint = (dataPoint) => {
      if ((0, lodash_exports.isFinite)(+dataPoint) && (0, lodash_exports.isNumber)(+dataPoint)) {
        return "number";
      }
      if (!Number.isNaN(Date.parse(dataPoint))) {
        return "time";
      }
      if (typeof dataPoint === "string") {
        return "string";
      }
      return "unknown";
    };
    var inferDataTypeFromSample = (dataSample) => {
      const typeMatches = {
        time: 0,
        number: 0,
        string: 0,
        unknown: 0
      };
      dataSample.forEach((point) => {
        typeMatches[getDataTypeForPoint(point)] += 1;
      });
      let typeCount = -1;
      let returnType = "unknown";
      Object.keys(typeMatches).forEach((key) => {
        if (typeMatches[key] > typeCount) {
          typeCount = typeMatches[key];
          returnType = key;
        }
      });
      return returnType;
    };
    var drawSample = (data) => {
      if (data.length > 2) {
        return [data[0], data[Math.floor(data.length / 2)], data[data.length - 1]];
      }
      if (data.length === 2) {
        return [data[0], data[1]];
      }
      return data;
    };
    var rangeFormat = (value, { ranges, values } = {}) => {
      if (Array.isArray(ranges) && Array.isArray(values) && !Number.isNaN(value)) {
        const floatVal = parseFloat(value);
        for (let i = 0; i < ranges.length; i += 1) {
          if (Number.isNaN(Number(ranges[i]))) {
            return value;
          }
          if (floatVal <= parseFloat(ranges[i])) {
            const valueIndex = Math.min(i, values.length - 1);
            if (values[valueIndex]) {
              return values[valueIndex];
            }
          }
        }
        if (floatVal > parseFloat(ranges[ranges.length - 1])) {
          return values[values.length - 1];
        }
      }
      return value;
    };
    var categoryFormat = (value, { categories, values }) => {
      if (!(Array.isArray(categories) && Array.isArray(values) && categories.length === values.length)) {
        return value;
      }
      const valueIndex = categories.indexOf(value);
      if (valueIndex > -1) {
        return values[valueIndex];
      }
      return value;
    };
    var rangeValueFormat = (value, { ranges = [] }) => {
      const floatValue = parseFloat(value);
      if (Number.isNaN(Number(value))) {
        return value;
      }
      for (let i = 0; i < ranges.length; i += 1) {
        if (
          // open upper bound: value is bigger than or equal to open upper bound start (from)
          i === 0 && hasOwnProperty.call(ranges[i], "from") && floatValue >= ranges[i].from || // inbetween: value falls into from - to range
          floatValue >= ranges[i].from && floatValue < ranges[i].to || // open lower bound: value is smaller than or equal to open lower bound end (to)
          i === ranges.length - 1 && hasOwnProperty.call(ranges[i], "to") && floatValue < ranges[i].to
        ) {
          return ranges[i].value;
        }
      }
      return value;
    };
    var matchValueFormat = (value, { matches = [], defaultValue = void 0 }) => {
      const defaultResult = (0, lodash_exports.isUndefined)(defaultValue) ? value : defaultValue;
      const matchResult = (0, lodash_exports.find)(matches, (match) => match.match && match.match === value);
      return (0, lodash_exports.isUndefined)(matchResult) ? defaultResult : matchResult.value;
    };
    var NON_NUMERIC_RANGE_ERROR = "Could not format value: Ranges are required to be numbers. Falling back to first color";
    var VALUES_AND_RANGES_HAVE_DIFFERENT_LENGTH = "gradient ranges and values must have the same number of elements";
    var INVALID_VALUE = "Could not format value for gradient:";
    var colorGradientFormat = (value, { ranges, values }, data, errorHandler) => {
      let colorValues = values;
      let colorRanges = ranges;
      function errorColor() {
        return colorValues ? chroma_js_default(colorValues[0]).hex().toUpperCase() : "#000";
      }
      if (!Number.isNaN(Number(value))) {
        if (!colorValues) {
          colorValues = ["white", "red"];
        }
        if (colorValues.length === 1) {
          colorValues.unshift("white");
        }
        if (!ranges) {
          if (data && data.length > 0) {
            const min = data.length > 0 ? Math.min.apply(null, data) : void 0;
            const max = data.length > 0 ? Math.max.apply(null, data) : void 0;
            colorRanges = [min];
            for (let i = 1; i < colorValues.length - 1; i += 1) {
              colorRanges.push(min + i * (max - min) / (colorValues.length - 1));
            }
            colorRanges.push(max);
          } else {
            colorRanges = [0, 1];
          }
        }
        if (colorRanges.length === 1) {
          colorRanges.push(colorRanges[0]);
        }
        colorRanges.sort((a, b) => a - b);
        if (colorRanges.length !== colorValues.length) {
          errorHandler(VALUES_AND_RANGES_HAVE_DIFFERENT_LENGTH);
          return errorColor();
        }
        const floatVal = parseFloat(value);
        if (floatVal > parseFloat(colorRanges[colorRanges.length - 1])) {
          return chroma_js_default(colorValues[colorValues.length - 1]).hex().toUpperCase();
        }
        if (floatVal < parseFloat(colorRanges[0])) {
          return chroma_js_default(colorValues[0]).hex().toUpperCase();
        }
        for (let i = 1; i < colorRanges.length; i += 1) {
          if (Number.isNaN(Number(colorRanges[i]))) {
            errorHandler(NON_NUMERIC_RANGE_ERROR);
            return errorColor();
          }
          const upperVal = colorRanges[i];
          if (floatVal <= upperVal) {
            const lowerVal = colorRanges[i - 1];
            let tau = (value - lowerVal) / (upperVal - lowerVal);
            if (upperVal === lowerVal) {
              if (value === 0) {
                tau = 0;
              } else {
                tau = 1;
              }
            }
            const upperColor = colorValues[i];
            const lowerColor = colorValues[i - 1];
            return chroma_js_default.scale([lowerColor, upperColor])(tau).hex().toUpperCase();
          }
        }
      }
      errorHandler(`${INVALID_VALUE} ${value}`);
      return errorColor();
    };
    var formatters = {
      rangevalue: rangeValueFormat,
      matchvalue: matchValueFormat,
      gradient: colorGradientFormat
    };
    var MAX_LOGGED_FORMATTER_ERRORS = 10;
    var newFormatterErrorHandler = (maxErrors, handlerFunc) => {
      let errorCount = 0;
      return (msg) => {
        if (errorCount < maxErrors) {
          handlerFunc(msg);
        }
        errorCount += 1;
      };
    };
    var getFormatter = (data, formatCfg = {}) => {
      if (formatCfg.type) {
        if (formatters[formatCfg.type]) {
          return (value) => formatters[formatCfg.type](
            value,
            formatCfg,
            data,
            // eslint-disable-next-line no-console
            newFormatterErrorHandler(MAX_LOGGED_FORMATTER_ERRORS, (msg) => console.warn(msg))
          );
        }
        return (value) => value;
      }
      const { ranges, values } = formatCfg;
      if (values) {
        if (ranges) {
          return (value) => rangeFormat(value, formatCfg);
        }
        if (formatCfg.categories) {
          return (value) => categoryFormat(value, formatCfg);
        }
      }
      console.warn("Could not find a formatter. Falling back to identity fn");
      return (value) => value;
    };
    var getDataForDataSourceType = (data, dataSourceType) => {
      if (!dataSourceType || !data[dataSourceType] || !data[dataSourceType].data) {
        return {
          fields: [],
          columns: []
        };
      }
      return data[dataSourceType].data;
    };
    var parseFieldRangeReference = (fieldIndexRangeStr) => {
      if (!fieldIndexRangeStr || fieldIndexRangeStr.indexOf(":") === -1) {
        return {
          isFieldIndexRange: false
        };
      }
      const [fromFieldIndexStr, toFieldIndexStr] = fieldIndexRangeStr.split(":");
      return {
        isFieldIndexRange: true,
        fromFieldIndex: Number.isNaN(Number(fromFieldIndexStr)) || !fromFieldIndexStr ? 0 : Number(fromFieldIndexStr),
        toFieldIndex: Number.isNaN(Number(toFieldIndexStr)) || !toFieldIndexStr ? -1 : Number(toFieldIndexStr)
      };
    };
    var parseIndexBasedFieldReference = (fieldReferenceStr) => {
      const indices = fieldReferenceStr.replace(/^[A-Za-z0-9]+/, "").replace(/\[/g, "").replace(/\]/g, ",").split(",");
      const dataSourceName = fieldReferenceStr.match(/^[A-Za-z0-9]+/)[0];
      const fieldRange = parseFieldRangeReference(indices[0]);
      return __spreadValues({
        dataSourceName,
        fieldIndex: Number.isNaN(Number(indices[0])) || !indices[0] ? null : Number(indices[0]),
        columnIndex: Number.isNaN(Number(indices[1])) || !indices[1] ? null : Number(indices[1])
      }, fieldRange);
    };
    var parseNameBasedFieldReference = (fieldReferenceStr) => {
      const dataSourceName = fieldReferenceStr.match(/^[A-Za-z0-9]+/)[0];
      const fieldNameStr = fieldReferenceStr.split(".")[1];
      const splitedStr = fieldNameStr.split("[");
      const fieldName = splitedStr[0];
      const columnIndex = splitedStr[1] ? Number(splitedStr[1].replace("]", "")) : null;
      return { dataSourceName, fieldName, columnIndex };
    };
    var getDataForIndexBasedFieldReference = (data, fieldReferenceStr) => {
      const { fields, columns } = data;
      const { dataSourceName, isFieldIndexRange, fromFieldIndex, toFieldIndex, fieldIndex, columnIndex } = parseIndexBasedFieldReference(fieldReferenceStr);
      if (isFieldIndexRange) {
        const dataForRange = [];
        if (fromFieldIndex > -1) {
          const endIndex = toFieldIndex > -1 ? Math.min(fields.length - 1, toFieldIndex) : fields.length + toFieldIndex;
          for (let i = fromFieldIndex; i <= endIndex; i += 1) {
            dataForRange.push(
              getDataForIndexBasedFieldReference(data, `${dataSourceName}[${i}][${columnIndex}]`)
            );
          }
          return dataForRange;
        }
      }
      if ((0, lodash_exports.isNumber)(fieldIndex)) {
        const isNegative = fieldIndex < 0;
        const absoluteIndex = Math.abs(fieldIndex);
        if (isNegative && absoluteIndex > fields.length || !isNegative && fieldIndex > fields.length - 1) {
          return {};
        }
        const correctedFieldIndex = isNegative ? fields.length - absoluteIndex : fieldIndex;
        const fieldName = typeof fields[correctedFieldIndex] === "object" ? fields[correctedFieldIndex].name : fields[correctedFieldIndex];
        let fieldData;
        if ((0, lodash_exports.isNumber)(columnIndex)) {
          const isNegativeColumnIndex = columnIndex < 0;
          if (isNegativeColumnIndex && columnIndex < -columns[correctedFieldIndex].length || columnIndex >= columns[correctedFieldIndex].length) {
            return {};
          }
          const correctColumnIndex = isNegativeColumnIndex ? columns[correctedFieldIndex].length + columnIndex : columnIndex;
          fieldData = columns[correctedFieldIndex].map(
            () => columns[correctedFieldIndex][correctColumnIndex]
          );
        } else {
          fieldData = columns[correctedFieldIndex];
        }
        return {
          fieldName,
          data: fieldData
        };
      }
      return {};
    };
    var getDataForNameBasedFieldReference = (data, fieldReferenceStr) => {
      const { fields, columns } = data;
      const { fieldName, columnIndex } = parseNameBasedFieldReference(fieldReferenceStr);
      if (fieldName) {
        const fieldIndex = (0, lodash_exports.findIndex)(
          fields,
          (field) => typeof field === "object" ? field.name === fieldName : field === fieldName
        );
        if (fieldIndex > -1) {
          let fieldData;
          if ((0, lodash_exports.isNumber)(columnIndex)) {
            const isNegativeColumnIndex = columnIndex < 0;
            if (isNegativeColumnIndex && columnIndex < -columns[fieldIndex].length || columnIndex >= columns[fieldIndex].length) {
              return {};
            }
            const correctColumnIndex = isNegativeColumnIndex ? columns[fieldIndex].length + columnIndex : columnIndex;
            fieldData = columns[fieldIndex].map(() => columns[fieldIndex][correctColumnIndex]);
          } else {
            fieldData = columns[fieldIndex];
          }
          return {
            fieldName,
            data: fieldData
          };
        }
        console.warn(`field '${fieldName}' not available.`);
        return {};
      }
      return {};
    };
    var getDataForFieldReference = (dataSources, fieldReference) => {
      let fieldReferenceStr = fieldReference;
      let formatValue;
      if (Array.isArray(fieldReference) && !fieldReference.isDefault) {
        return fieldReference.map((ref) => getDataForFieldReference(dataSources, ref));
      }
      if (fieldReference.isDefault && Array.isArray(fieldReference.field)) {
        for (let i = 0; i < fieldReference.field.length; i += 1) {
          fieldReferenceStr = fieldReference.field[i];
          const dataFromDefault = getDataForFieldReference(dataSources, fieldReferenceStr);
          if (Array.isArray(dataFromDefault.data)) {
            const type = inferDataTypeFromSample(drawSample(dataFromDefault.data));
            if (fieldReference.type.indexOf(type) > -1) {
              return dataFromDefault;
            }
          }
        }
      }
      if (typeof fieldReference === "object") {
        const { field } = fieldReference;
        if (field && !Array.isArray(field)) {
          fieldReferenceStr = field;
        }
      }
      const indexBasedRegx = /^[A-Za-z0-9_]+\[.*\].*$/;
      const nameBasedRegx = /^[A-Za-z0-9_]+\..*$/;
      const isIndexBasedReference = indexBasedRegx.test(fieldReferenceStr);
      const isNameBasedReference = nameBasedRegx.test(fieldReferenceStr);
      if (!isIndexBasedReference && !isNameBasedReference) {
        return {};
      }
      const dataSourceType = fieldReferenceStr.match(/^(.*?)(\.|\[)/)[1];
      const data = getDataForDataSourceType(dataSources, dataSourceType);
      let fieldData;
      if (isIndexBasedReference) {
        fieldData = getDataForIndexBasedFieldReference(data, fieldReferenceStr);
      } else {
        fieldData = getDataForNameBasedFieldReference(data, fieldReferenceStr);
      }
      if (typeof fieldReference === "object") {
        const { format } = fieldReference;
        if (format) {
          formatValue = getFormatter(fieldData.data, format);
        }
      }
      if (formatValue && !(0, lodash_exports.isEmpty)(fieldData)) {
        return {
          fieldName: fieldData.fieldName,
          data: fieldData.data.map(formatValue)
        };
      }
      return fieldData;
    };
    var mergeEncoding = (defaultEncoding, userDefinedEncoding = {}) => {
      const mergedEncoding = __spreadValues({}, userDefinedEncoding);
      Object.keys(defaultEncoding).forEach((key) => {
        if ((0, lodash_exports.isEmpty)(userDefinedEncoding[key]) && defaultEncoding[key].isRequired && defaultEncoding[key].default) {
          mergedEncoding[key] = typeof defaultEncoding[key].default === "object" && !Array.isArray(defaultEncoding[key].default) ? __spreadProps(__spreadValues({}, defaultEncoding[key].default), {
            isDefault: true,
            type: defaultEncoding[key].type
          }) : {
            field: defaultEncoding[key].default,
            isDefault: true,
            type: defaultEncoding[key].type
          };
        }
      });
      return mergedEncoding;
    };
    var parse = (dataSources, encoding = {}) => {
      const parsedOutput = {
        _meta: {
          fieldNames: {},
          types: {}
        }
      };
      Object.keys(encoding).forEach((key) => {
        let fieldReference = (0, lodash_exports.clone)(encoding[key]);
        if (typeof fieldReference === "object" && fieldReference.field && fieldReference.field.indexOf("encoding") === 0) {
          const replacedKey = fieldReference.field.split(".")[1];
          if (!encoding[replacedKey]) {
            console.warn(`${key} field cannot refer to 'encoding.${replacedKey}'.`);
          }
          const field = typeof encoding[replacedKey] === "object" ? encoding[replacedKey].field : encoding[replacedKey];
          fieldReference = __spreadProps(__spreadValues({}, fieldReference), {
            field
          });
        }
        const dataForFieldReference = getDataForFieldReference(dataSources, fieldReference);
        if (Array.isArray(dataForFieldReference)) {
          parsedOutput[key] = dataForFieldReference.map((entry) => entry.data);
          parsedOutput._meta.fieldNames[key] = dataForFieldReference.map((entry) => entry.fieldName);
          parsedOutput._meta.types[key] = dataForFieldReference.map(
            (entry) => inferDataTypeFromSample(drawSample(entry.data))
          );
        } else {
          const { fieldName, data } = dataForFieldReference;
          if (fieldName) {
            parsedOutput[key] = data;
            parsedOutput._meta.fieldNames[key] = fieldName;
            parsedOutput._meta.types[key] = inferDataTypeFromSample(drawSample(data));
          }
        }
      });
      return parsedOutput;
    };
  }
});

// node_modules/nearley/lib/nearley.js
var require_nearley = __commonJS({
  "node_modules/nearley/lib/nearley.js"(exports2, module2) {
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    (function(root, factory) {
      if (typeof module2 === "object" && module2.exports) {
        module2.exports = factory();
      } else {
        root.nearley = factory();
      }
    })(exports2, function() {
      function Rule(name, symbols, postprocess) {
        this.id = ++Rule.highestId;
        this.name = name;
        this.symbols = symbols;
        this.postprocess = postprocess;
        return this;
      }
      Rule.highestId = 0;
      Rule.prototype.toString = function(withCursorAt) {
        var symbolSequence = typeof withCursorAt === "undefined" ? this.symbols.map(getSymbolShortDisplay).join(" ") : this.symbols.slice(0, withCursorAt).map(getSymbolShortDisplay).join(" ") + " ● " + this.symbols.slice(withCursorAt).map(getSymbolShortDisplay).join(" ");
        return this.name + " → " + symbolSequence;
      };
      function State(rule, dot, reference, wantedBy) {
        this.rule = rule;
        this.dot = dot;
        this.reference = reference;
        this.data = [];
        this.wantedBy = wantedBy;
        this.isComplete = this.dot === rule.symbols.length;
      }
      State.prototype.toString = function() {
        return "{" + this.rule.toString(this.dot) + "}, from: " + (this.reference || 0);
      };
      State.prototype.nextState = function(child) {
        var state = new State(this.rule, this.dot + 1, this.reference, this.wantedBy);
        state.left = this;
        state.right = child;
        if (state.isComplete) {
          state.data = state.build();
          state.right = void 0;
        }
        return state;
      };
      State.prototype.build = function() {
        var children = [];
        var node = this;
        do {
          children.push(node.right.data);
          node = node.left;
        } while (node.left);
        children.reverse();
        return children;
      };
      State.prototype.finish = function() {
        if (this.rule.postprocess) {
          this.data = this.rule.postprocess(this.data, this.reference, Parser.fail);
        }
      };
      function Column(grammar, index) {
        this.grammar = grammar;
        this.index = index;
        this.states = [];
        this.wants = {};
        this.scannable = [];
        this.completed = {};
      }
      Column.prototype.process = function(nextColumn) {
        var states = this.states;
        var wants = this.wants;
        var completed = this.completed;
        for (var w = 0; w < states.length; w++) {
          var state = states[w];
          if (state.isComplete) {
            state.finish();
            if (state.data !== Parser.fail) {
              var wantedBy = state.wantedBy;
              for (var i = wantedBy.length; i--; ) {
                var left = wantedBy[i];
                this.complete(left, state);
              }
              if (state.reference === this.index) {
                var exp = state.rule.name;
                (this.completed[exp] = this.completed[exp] || []).push(state);
              }
            }
          } else {
            var exp = state.rule.symbols[state.dot];
            if (typeof exp !== "string") {
              this.scannable.push(state);
              continue;
            }
            if (wants[exp]) {
              wants[exp].push(state);
              if (completed.hasOwnProperty(exp)) {
                var nulls = completed[exp];
                for (var i = 0; i < nulls.length; i++) {
                  var right = nulls[i];
                  this.complete(state, right);
                }
              }
            } else {
              wants[exp] = [state];
              this.predict(exp);
            }
          }
        }
      };
      Column.prototype.predict = function(exp) {
        var rules = this.grammar.byName[exp] || [];
        for (var i = 0; i < rules.length; i++) {
          var r = rules[i];
          var wantedBy = this.wants[exp];
          var s = new State(r, 0, this.index, wantedBy);
          this.states.push(s);
        }
      };
      Column.prototype.complete = function(left, right) {
        var copy = left.nextState(right);
        this.states.push(copy);
      };
      function Grammar(rules, start) {
        this.rules = rules;
        this.start = start || this.rules[0].name;
        var byName = this.byName = {};
        this.rules.forEach(function(rule) {
          if (!byName.hasOwnProperty(rule.name)) {
            byName[rule.name] = [];
          }
          byName[rule.name].push(rule);
        });
      }
      Grammar.fromCompiled = function(rules, start) {
        var lexer = rules.Lexer;
        if (rules.ParserStart) {
          start = rules.ParserStart;
          rules = rules.ParserRules;
        }
        var rules = rules.map(function(r) {
          return new Rule(r.name, r.symbols, r.postprocess);
        });
        var g = new Grammar(rules, start);
        g.lexer = lexer;
        return g;
      };
      function StreamLexer() {
        this.reset("");
      }
      StreamLexer.prototype.reset = function(data, state) {
        this.buffer = data;
        this.index = 0;
        this.line = state ? state.line : 1;
        this.lastLineBreak = state ? -state.col : 0;
      };
      StreamLexer.prototype.next = function() {
        if (this.index < this.buffer.length) {
          var ch = this.buffer[this.index++];
          if (ch === "\n") {
            this.line += 1;
            this.lastLineBreak = this.index;
          }
          return { value: ch };
        }
      };
      StreamLexer.prototype.save = function() {
        return {
          line: this.line,
          col: this.index - this.lastLineBreak
        };
      };
      StreamLexer.prototype.formatError = function(token, message) {
        var buffer = this.buffer;
        if (typeof buffer === "string") {
          var lines = buffer.split("\n").slice(
            Math.max(0, this.line - 5),
            this.line
          );
          var nextLineBreak = buffer.indexOf("\n", this.index);
          if (nextLineBreak === -1) nextLineBreak = buffer.length;
          var col = this.index - this.lastLineBreak;
          var lastLineDigits = String(this.line).length;
          message += " at line " + this.line + " col " + col + ":\n\n";
          message += lines.map(function(line, i) {
            return pad(this.line - lines.length + i + 1, lastLineDigits) + " " + line;
          }, this).join("\n");
          message += "\n" + pad("", lastLineDigits + col) + "^\n";
          return message;
        } else {
          return message + " at index " + (this.index - 1);
        }
        function pad(n, length) {
          var s = String(n);
          return Array(length - s.length + 1).join(" ") + s;
        }
      };
      function Parser(rules, start, options) {
        if (rules instanceof Grammar) {
          var grammar = rules;
          var options = start;
        } else {
          var grammar = Grammar.fromCompiled(rules, start);
        }
        this.grammar = grammar;
        this.options = {
          keepHistory: false,
          lexer: grammar.lexer || new StreamLexer()
        };
        for (var key in options || {}) {
          this.options[key] = options[key];
        }
        this.lexer = this.options.lexer;
        this.lexerState = void 0;
        var column = new Column(grammar, 0);
        var table = this.table = [column];
        column.wants[grammar.start] = [];
        column.predict(grammar.start);
        column.process();
        this.current = 0;
      }
      Parser.fail = {};
      Parser.prototype.feed = function(chunk) {
        var lexer = this.lexer;
        lexer.reset(chunk, this.lexerState);
        var token;
        while (true) {
          try {
            token = lexer.next();
            if (!token) {
              break;
            }
          } catch (e) {
            var nextColumn = new Column(this.grammar, this.current + 1);
            this.table.push(nextColumn);
            var err = new Error(this.reportLexerError(e));
            err.offset = this.current;
            err.token = e.token;
            throw err;
          }
          var column = this.table[this.current];
          if (!this.options.keepHistory) {
            delete this.table[this.current - 1];
          }
          var n = this.current + 1;
          var nextColumn = new Column(this.grammar, n);
          this.table.push(nextColumn);
          var literal = token.text !== void 0 ? token.text : token.value;
          var value = lexer.constructor === StreamLexer ? token.value : token;
          var scannable = column.scannable;
          for (var w = scannable.length; w--; ) {
            var state = scannable[w];
            var expect = state.rule.symbols[state.dot];
            if (expect.test ? expect.test(value) : expect.type ? expect.type === token.type : expect.literal === literal) {
              var next = state.nextState({ data: value, token, isToken: true, reference: n - 1 });
              nextColumn.states.push(next);
            }
          }
          nextColumn.process();
          if (nextColumn.states.length === 0) {
            var err = new Error(this.reportError(token));
            err.offset = this.current;
            err.token = token;
            throw err;
          }
          if (this.options.keepHistory) {
            column.lexerState = lexer.save();
          }
          this.current++;
        }
        if (column) {
          this.lexerState = lexer.save();
        }
        this.results = this.finish();
        return this;
      };
      Parser.prototype.reportLexerError = function(lexerError) {
        var tokenDisplay, lexerMessage;
        var token = lexerError.token;
        if (token) {
          tokenDisplay = "input " + JSON.stringify(token.text[0]) + " (lexer error)";
          lexerMessage = this.lexer.formatError(token, "Syntax error");
        } else {
          tokenDisplay = "input (lexer error)";
          lexerMessage = lexerError.message;
        }
        return this.reportErrorCommon(lexerMessage, tokenDisplay);
      };
      Parser.prototype.reportError = function(token) {
        var tokenDisplay = (token.type ? token.type + " token: " : "") + JSON.stringify(token.value !== void 0 ? token.value : token);
        var lexerMessage = this.lexer.formatError(token, "Syntax error");
        return this.reportErrorCommon(lexerMessage, tokenDisplay);
      };
      Parser.prototype.reportErrorCommon = function(lexerMessage, tokenDisplay) {
        var lines = [];
        lines.push(lexerMessage);
        var lastColumnIndex = this.table.length - 2;
        var lastColumn = this.table[lastColumnIndex];
        var expectantStates = lastColumn.states.filter(function(state) {
          var nextSymbol = state.rule.symbols[state.dot];
          return nextSymbol && typeof nextSymbol !== "string";
        });
        if (expectantStates.length === 0) {
          lines.push("Unexpected " + tokenDisplay + ". I did not expect any more input. Here is the state of my parse table:\n");
          this.displayStateStack(lastColumn.states, lines);
        } else {
          lines.push("Unexpected " + tokenDisplay + ". Instead, I was expecting to see one of the following:\n");
          var stateStacks = expectantStates.map(function(state) {
            return this.buildFirstStateStack(state, []) || [state];
          }, this);
          stateStacks.forEach(function(stateStack) {
            var state = stateStack[0];
            var nextSymbol = state.rule.symbols[state.dot];
            var symbolDisplay = this.getSymbolDisplay(nextSymbol);
            lines.push("A " + symbolDisplay + " based on:");
            this.displayStateStack(stateStack, lines);
          }, this);
        }
        lines.push("");
        return lines.join("\n");
      };
      Parser.prototype.displayStateStack = function(stateStack, lines) {
        var lastDisplay;
        var sameDisplayCount = 0;
        for (var j = 0; j < stateStack.length; j++) {
          var state = stateStack[j];
          var display = state.rule.toString(state.dot);
          if (display === lastDisplay) {
            sameDisplayCount++;
          } else {
            if (sameDisplayCount > 0) {
              lines.push("    ^ " + sameDisplayCount + " more lines identical to this");
            }
            sameDisplayCount = 0;
            lines.push("    " + display);
          }
          lastDisplay = display;
        }
      };
      Parser.prototype.getSymbolDisplay = function(symbol) {
        return getSymbolLongDisplay(symbol);
      };
      Parser.prototype.buildFirstStateStack = function(state, visited) {
        if (visited.indexOf(state) !== -1) {
          return null;
        }
        if (state.wantedBy.length === 0) {
          return [state];
        }
        var prevState = state.wantedBy[0];
        var childVisited = [state].concat(visited);
        var childResult = this.buildFirstStateStack(prevState, childVisited);
        if (childResult === null) {
          return null;
        }
        return [state].concat(childResult);
      };
      Parser.prototype.save = function() {
        var column = this.table[this.current];
        column.lexerState = this.lexerState;
        return column;
      };
      Parser.prototype.restore = function(column) {
        var index = column.index;
        this.current = index;
        this.table[index] = column;
        this.table.splice(index + 1);
        this.lexerState = column.lexerState;
        this.results = this.finish();
      };
      Parser.prototype.rewind = function(index) {
        if (!this.options.keepHistory) {
          throw new Error("set option `keepHistory` to enable rewinding");
        }
        this.restore(this.table[index]);
      };
      Parser.prototype.finish = function() {
        var considerations = [];
        var start = this.grammar.start;
        var column = this.table[this.table.length - 1];
        column.states.forEach(function(t) {
          if (t.rule.name === start && t.dot === t.rule.symbols.length && t.reference === 0 && t.data !== Parser.fail) {
            considerations.push(t);
          }
        });
        return considerations.map(function(c) {
          return c.data;
        });
      };
      function getSymbolLongDisplay(symbol) {
        var type = typeof symbol;
        if (type === "string") {
          return symbol;
        } else if (type === "object") {
          if (symbol.literal) {
            return JSON.stringify(symbol.literal);
          } else if (symbol instanceof RegExp) {
            return "character matching " + symbol;
          } else if (symbol.type) {
            return symbol.type + " token";
          } else if (symbol.test) {
            return "token matching " + String(symbol.test);
          } else {
            throw new Error("Unknown symbol type: " + symbol);
          }
        }
      }
      function getSymbolShortDisplay(symbol) {
        var type = typeof symbol;
        if (type === "string") {
          return symbol;
        } else if (type === "object") {
          if (symbol.literal) {
            return JSON.stringify(symbol.literal);
          } else if (symbol instanceof RegExp) {
            return symbol.toString();
          } else if (symbol.type) {
            return "%" + symbol.type;
          } else if (symbol.test) {
            return "<" + String(symbol.test) + ">";
          } else {
            throw new Error("Unknown symbol type: " + symbol);
          }
        }
      }
      return {
        Parser,
        Grammar,
        Rule
      };
    });
  }
});

// node_modules/numbro/dist/numbro.min.js
var require_numbro_min = __commonJS({
  "node_modules/numbro/dist/numbro.min.js"(exports2, module2) {
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    !(function(e, t) {
      "object" == typeof exports2 && "undefined" != typeof module2 ? module2.exports = t() : "function" == typeof define && define.amd ? define(t) : (e = "undefined" != typeof globalThis ? globalThis : e || self).numbro = t();
    })(exports2, (function() {
      "use strict";
      var e, t, r, n, i, a, o = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {};
      function u(e2) {
        return e2 && e2.__esModule && Object.prototype.hasOwnProperty.call(e2, "default") ? e2.default : e2;
      }
      function s() {
        return t ? e : (t = 1, e = { languageTag: "en-US", delimiters: { thousands: ",", decimal: "." }, abbreviations: { thousand: "k", million: "m", billion: "b", trillion: "t" }, spaceSeparated: false, ordinal: function(e2) {
          let t2 = e2 % 10;
          return 1 == ~~(e2 % 100 / 10) ? "th" : 1 === t2 ? "st" : 2 === t2 ? "nd" : 3 === t2 ? "rd" : "th";
        }, bytes: { binarySuffixes: ["B", "KiB", "MiB", "GiB", "TiB", "PiB", "EiB", "ZiB", "YiB"], decimalSuffixes: ["B", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"] }, currency: { symbol: "$", position: "prefix", code: "USD" }, currencyFormat: { thousandSeparated: true, totalLength: 4, spaceSeparated: true, spaceSeparatedCurrency: true }, formats: { fourDigits: { totalLength: 4, spaceSeparated: true }, fullWithTwoDecimals: { output: "currency", thousandSeparated: true, mantissa: 2 }, fullWithTwoDecimalsNoCurrency: { thousandSeparated: true, mantissa: 2 }, fullWithNoDecimals: { output: "currency", thousandSeparated: true, mantissa: 0 } } });
      }
      function l() {
        if (n) return r;
        n = 1;
        const e2 = [{ key: "ZiB", factor: Math.pow(1024, 7) }, { key: "ZB", factor: Math.pow(1e3, 7) }, { key: "YiB", factor: Math.pow(1024, 8) }, { key: "YB", factor: Math.pow(1e3, 8) }, { key: "TiB", factor: Math.pow(1024, 4) }, { key: "TB", factor: Math.pow(1e3, 4) }, { key: "PiB", factor: Math.pow(1024, 5) }, { key: "PB", factor: Math.pow(1e3, 5) }, { key: "MiB", factor: Math.pow(1024, 2) }, { key: "MB", factor: Math.pow(1e3, 2) }, { key: "KiB", factor: Math.pow(1024, 1) }, { key: "KB", factor: Math.pow(1e3, 1) }, { key: "GiB", factor: Math.pow(1024, 3) }, { key: "GB", factor: Math.pow(1e3, 3) }, { key: "EiB", factor: Math.pow(1024, 6) }, { key: "EB", factor: Math.pow(1e3, 6) }, { key: "B", factor: 1 }];
        function t2(e3) {
          return e3.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&");
        }
        function i2(r2, n2, a3, o2, u2, s2, l2) {
          if (!isNaN(+r2)) return +r2;
          let c2 = "", f2 = r2.replace(/(^[^(]*)\((.*)\)([^)]*$)/, "$1$2$3");
          if (f2 !== r2) return -1 * i2(f2, n2, a3, o2, u2, s2);
          for (let t3 = 0; t3 < e2.length; t3++) {
            let l3 = e2[t3];
            if (c2 = r2.replace(RegExp(`([0-9 ])(${l3.key})$`), "$1"), c2 !== r2) return i2(c2, n2, a3, o2, u2, s2) * l3.factor;
          }
          if (c2 = r2.replace("%", ""), c2 !== r2) return i2(c2, n2, a3, o2, u2, s2) / 100;
          let p2 = parseFloat(r2);
          if (isNaN(p2)) return;
          let g2 = o2(p2);
          if (g2 && "." !== g2 && (c2 = r2.replace(new RegExp(`${t2(g2)}$`), ""), c2 !== r2)) return i2(c2, n2, a3, o2, u2, s2);
          let h2 = {};
          Object.keys(s2).forEach(((e3) => {
            h2[s2[e3]] = e3;
          }));
          let d2 = Object.keys(h2).sort().reverse(), m2 = d2.length;
          for (let e3 = 0; e3 < m2; e3++) {
            let t3 = d2[e3], l3 = h2[t3];
            if (c2 = r2.replace(t3, ""), c2 !== r2) {
              let e4;
              switch (l3) {
                case "thousand":
                  e4 = Math.pow(10, 3);
                  break;
                case "million":
                  e4 = Math.pow(10, 6);
                  break;
                case "billion":
                  e4 = Math.pow(10, 9);
                  break;
                case "trillion":
                  e4 = Math.pow(10, 12);
              }
              return i2(c2, n2, a3, o2, u2, s2) * e4;
            }
          }
        }
        function a2(e3, r2, n2 = "", a3, o2, u2, s2) {
          if ("" === e3) return;
          if (e3 === o2) return 0;
          let l2 = (function(e4, r3, n3) {
            let i3 = e4.replace(n3, "");
            return i3 = i3.replace(new RegExp(`([0-9])${t2(r3.thousands)}([0-9])`, "g"), "$1$2"), i3 = i3.replace(r3.decimal, "."), i3;
          })(e3, r2, n2);
          return i2(l2, r2, n2, a3, o2, u2);
        }
        return r = { unformat: function(e3, t3) {
          const r2 = h();
          let n2, i3 = r2.currentDelimiters(), o2 = r2.currentCurrency().symbol, u2 = r2.currentOrdinal(), s2 = r2.getZeroFormat(), l2 = r2.currentAbbreviations();
          if ("string" == typeof e3) n2 = (function(e4, t4) {
            if (!e4.indexOf(":") || ":" === t4.thousands) return false;
            let r3 = e4.split(":");
            if (3 !== r3.length) return false;
            let n3 = +r3[0], i4 = +r3[1], a3 = +r3[2];
            return !isNaN(n3) && !isNaN(i4) && !isNaN(a3);
          })(e3, i3) ? (function(e4) {
            let t4 = e4.split(":"), r3 = +t4[0], n3 = +t4[1];
            return +t4[2] + 60 * n3 + 3600 * r3;
          })(e3) : a2(e3, i3, o2, u2, s2, l2);
          else {
            if ("number" != typeof e3) return;
            n2 = e3;
          }
          if (void 0 !== n2) return n2;
        } }, r;
      }
      function c() {
        if (a) return i;
        a = 1;
        let e2 = l();
        const t2 = /^[a-z]{2,3}(-[a-zA-Z]{4})?(-([A-Z]{2}|[0-9]{3}))?$/, r2 = { output: { type: "string", validValues: ["currency", "percent", "byte", "time", "ordinal", "number"] }, base: { type: "string", validValues: ["decimal", "binary", "general"], restriction: (e3, t3) => "byte" === t3.output, message: "`base` must be provided only when the output is `byte`", mandatory: (e3) => "byte" === e3.output }, characteristic: { type: "number", restriction: (e3) => e3 >= 0, message: "value must be positive" }, prefix: "string", postfix: "string", forceAverage: { type: "string", validValues: ["trillion", "billion", "million", "thousand"] }, average: "boolean", lowPrecision: { type: "boolean", restriction: (e3, t3) => true === t3.average, message: "`lowPrecision` must be provided only when the option `average` is set" }, currencyPosition: { type: "string", validValues: ["prefix", "infix", "postfix"] }, currencySymbol: "string", totalLength: { type: "number", restrictions: [{ restriction: (e3) => e3 >= 0, message: "value must be positive" }, { restriction: (e3, t3) => !t3.exponential, message: "`totalLength` is incompatible with `exponential`" }] }, mantissa: { type: "number", restriction: (e3) => e3 >= 0, message: "value must be positive" }, optionalMantissa: "boolean", trimMantissa: "boolean", roundingFunction: "function", optionalCharacteristic: "boolean", thousandSeparated: "boolean", spaceSeparated: "boolean", spaceSeparatedCurrency: "boolean", spaceSeparatedAbbreviation: "boolean", abbreviations: { type: "object", children: { thousand: "string", million: "string", billion: "string", trillion: "string" } }, negative: { type: "string", validValues: ["sign", "parenthesis"] }, forceSign: "boolean", exponential: { type: "boolean" }, prefixSymbol: { type: "boolean", restriction: (e3, t3) => "percent" === t3.output, message: "`prefixSymbol` can be provided only when the output is `percent`" } }, n2 = { languageTag: { type: "string", mandatory: true, restriction: (e3) => e3.match(t2), message: "the language tag must follow the BCP 47 specification (see https://tools.ieft.org/html/bcp47)" }, delimiters: { type: "object", children: { thousands: "string", decimal: "string", thousandsSize: "number" }, mandatory: true }, abbreviations: { type: "object", children: { thousand: { type: "string", mandatory: true }, million: { type: "string", mandatory: true }, billion: { type: "string", mandatory: true }, trillion: { type: "string", mandatory: true } }, mandatory: true }, spaceSeparated: "boolean", spaceSeparatedCurrency: "boolean", ordinal: { type: "function", mandatory: true }, bytes: { type: "object", children: { binarySuffixes: "object", decimalSuffixes: "object" } }, currency: { type: "object", children: { symbol: "string", position: "string", code: "string" }, mandatory: true }, defaults: "format", ordinalFormat: "format", byteFormat: "format", percentageFormat: "format", currencyFormat: "format", timeDefaults: "format", formats: { type: "object", children: { fourDigits: { type: "format", mandatory: true }, fullWithTwoDecimals: { type: "format", mandatory: true }, fullWithTwoDecimalsNoCurrency: { type: "format", mandatory: true }, fullWithNoDecimals: { type: "format", mandatory: true } } } };
        function o2(t3) {
          return void 0 !== e2.unformat(t3);
        }
        function u2(e3, t3, n3, i2 = false) {
          let a2 = Object.keys(e3).map(((i3) => {
            if (!t3[i3]) return console.error(`${n3} Invalid key: ${i3}`), false;
            let a3 = e3[i3], o3 = t3[i3];
            if ("string" == typeof o3 && (o3 = { type: o3 }), "format" === o3.type) {
              if (!u2(a3, r2, `[Validate ${i3}]`, true)) return false;
            } else if (typeof a3 !== o3.type) return console.error(`${n3} ${i3} type mismatched: "${o3.type}" expected, "${typeof a3}" provided`), false;
            if (o3.restrictions && o3.restrictions.length) {
              let t4 = o3.restrictions.length;
              for (let r3 = 0; r3 < t4; r3++) {
                let { restriction: t5, message: u3 } = o3.restrictions[r3];
                if (!t5(a3, e3)) return console.error(`${n3} ${i3} invalid value: ${u3}`), false;
              }
            }
            if (o3.restriction && !o3.restriction(a3, e3)) return console.error(`${n3} ${i3} invalid value: ${o3.message}`), false;
            if (o3.validValues && -1 === o3.validValues.indexOf(a3)) return console.error(`${n3} ${i3} invalid value: must be among ${JSON.stringify(o3.validValues)}, "${a3}" provided`), false;
            if (o3.children) {
              if (!u2(a3, o3.children, `[Validate ${i3}]`)) return false;
            }
            return true;
          }));
          return i2 || a2.push(...Object.keys(t3).map(((r3) => {
            let i3 = t3[r3];
            if ("string" == typeof i3 && (i3 = { type: i3 }), i3.mandatory) {
              let t4 = i3.mandatory;
              if ("function" == typeof t4 && (t4 = t4(e3)), t4 && void 0 === e3[r3]) return console.error(`${n3} Missing mandatory key "${r3}"`), false;
            }
            return true;
          }))), a2.reduce(((e4, t4) => e4 && t4), true);
        }
        function s2(e3) {
          return u2(e3, r2, "[Validate format]");
        }
        return i = { validate: function(e3, t3) {
          let r3 = o2(e3), n3 = s2(t3);
          return r3 && n3;
        }, validateFormat: s2, validateInput: o2, validateLanguage: function(e3) {
          return u2(e3, n2, "[Validate language]");
        } }, i;
      }
      var f, p, g = { parseFormat: function(e2, t2 = {}) {
        return "string" != typeof e2 ? e2 : ((function(e3, t3) {
          if (-1 === e3.indexOf("$")) {
            if (-1 === e3.indexOf("%")) return -1 !== e3.indexOf("bd") ? (t3.output = "byte", void (t3.base = "general")) : -1 !== e3.indexOf("b") ? (t3.output = "byte", void (t3.base = "binary")) : -1 !== e3.indexOf("d") ? (t3.output = "byte", void (t3.base = "decimal")) : void (-1 === e3.indexOf(":") ? -1 !== e3.indexOf("o") && (t3.output = "ordinal") : t3.output = "time");
            t3.output = "percent";
          } else t3.output = "currency";
        })(e2 = (function(e3, t3) {
          let r2 = e3.match(/{([^}]*)}$/);
          return r2 ? (t3.postfix = r2[1], e3.slice(0, -r2[0].length)) : e3;
        })(e2 = (function(e3, t3) {
          let r2 = e3.match(/^{([^}]*)}/);
          return r2 ? (t3.prefix = r2[1], e3.slice(r2[0].length)) : e3;
        })(e2, t2), t2), t2), (function(e3, t3) {
          let r2 = e3.match(/[1-9]+[0-9]*/);
          r2 && (t3.totalLength = +r2[0]);
        })(e2, t2), (function(e3, t3) {
          let r2 = e3.split(".")[0].match(/0+/);
          r2 && (t3.characteristic = r2[0].length);
        })(e2, t2), (function(e3, t3) {
          if (-1 !== e3.indexOf(".")) {
            let r2 = e3.split(".")[0];
            t3.optionalCharacteristic = -1 === r2.indexOf("0");
          }
        })(e2, t2), (function(e3, t3) {
          -1 !== e3.indexOf("a") && (t3.average = true);
        })(e2, t2), (function(e3, t3) {
          -1 !== e3.indexOf("K") ? t3.forceAverage = "thousand" : -1 !== e3.indexOf("M") ? t3.forceAverage = "million" : -1 !== e3.indexOf("B") ? t3.forceAverage = "billion" : -1 !== e3.indexOf("T") && (t3.forceAverage = "trillion");
        })(e2, t2), (function(e3, t3) {
          let r2 = e3.split(".")[1];
          if (r2) {
            let e4 = r2.match(/0+/);
            e4 && (t3.mantissa = e4[0].length);
          }
        })(e2, t2), (function(e3, t3) {
          e3.match(/\[\.]/) ? t3.optionalMantissa = true : e3.match(/\./) && (t3.optionalMantissa = false);
        })(e2, t2), (function(e3, t3) {
          const r2 = e3.split(".")[1];
          r2 && (t3.trimMantissa = -1 !== r2.indexOf("["));
        })(e2, t2), (function(e3, t3) {
          -1 !== e3.indexOf(",") && (t3.thousandSeparated = true);
        })(e2, t2), (function(e3, t3) {
          -1 !== e3.indexOf(" ") && (t3.spaceSeparated = true, t3.spaceSeparatedCurrency = true, (t3.average || t3.forceAverage) && (t3.spaceSeparatedAbbreviation = true));
        })(e2, t2), (function(e3, t3) {
          e3.match(/^\+?\([^)]*\)$/) && (t3.negative = "parenthesis"), e3.match(/^\+?-/) && (t3.negative = "sign");
        })(e2, t2), (function(e3, t3) {
          e3.match(/^\+/) && (t3.forceSign = true);
        })(e2, t2), t2);
      } };
      function h() {
        if (p) return f;
        p = 1;
        const e2 = s(), t2 = c(), r2 = g;
        let n2, i2 = {}, a2 = {}, o2 = null, u2 = {};
        function l2(e3) {
          n2 = e3;
        }
        function h2() {
          return a2[n2];
        }
        return i2.languages = () => Object.assign({}, a2), i2.currentLanguage = () => n2, i2.currentBytes = () => h2().bytes || {}, i2.currentCurrency = () => h2().currency, i2.currentAbbreviations = () => h2().abbreviations, i2.currentDelimiters = () => h2().delimiters, i2.currentOrdinal = () => h2().ordinal, i2.currentDefaults = () => Object.assign({}, h2().defaults, u2), i2.currentOrdinalDefaultFormat = () => Object.assign({}, i2.currentDefaults(), h2().ordinalFormat), i2.currentByteDefaultFormat = () => Object.assign({}, i2.currentDefaults(), h2().byteFormat), i2.currentPercentageDefaultFormat = () => Object.assign({}, i2.currentDefaults(), h2().percentageFormat), i2.currentCurrencyDefaultFormat = () => Object.assign({}, i2.currentDefaults(), h2().currencyFormat), i2.currentTimeDefaultFormat = () => Object.assign({}, i2.currentDefaults(), h2().timeFormat), i2.setDefaults = (e3) => {
          e3 = r2.parseFormat(e3), t2.validateFormat(e3) && (u2 = e3);
        }, i2.getZeroFormat = () => o2, i2.setZeroFormat = (e3) => o2 = "string" == typeof e3 ? e3 : null, i2.hasZeroFormat = () => null !== o2, i2.languageData = (e3) => {
          if (e3) {
            if (a2[e3]) return a2[e3];
            throw new Error(`Unknown tag "${e3}"`);
          }
          return h2();
        }, i2.registerLanguage = (e3, r3 = false) => {
          if (!t2.validateLanguage(e3)) throw new Error("Invalid language data");
          a2[e3.languageTag] = e3, r3 && l2(e3.languageTag);
        }, i2.setLanguage = (t3, r3 = e2.languageTag) => {
          if (!a2[t3]) {
            let e3 = t3.split("-")[0], n3 = Object.keys(a2).find(((t4) => t4.split("-")[0] === e3));
            return a2[n3] ? void l2(n3) : void l2(r3);
          }
          l2(t3);
        }, i2.registerLanguage(e2), n2 = e2.languageTag, f = i2;
      }
      function d(e2, t2) {
        e2.forEach(((e3) => {
          let r2;
          try {
            r2 = (function(e4) {
              throw new Error('Could not dynamically require "' + e4 + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
            })(`../languages/${e3}`);
          } catch (t3) {
            console.error(`Unable to load "${e3}". No matching language file found.`);
          }
          r2 && t2.registerLanguage(r2);
        }));
      }
      var m = { exports: {} };
      !(function(e2) {
        !(function(t2) {
          var r2, n2 = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, i2 = Math.ceil, a2 = Math.floor, o2 = "[BigNumber Error] ", u2 = o2 + "Number primitive has more than 15 significant digits: ", s2 = 1e14, l2 = 14, c2 = 9007199254740991, f2 = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], p2 = 1e7, g2 = 1e9;
          function h2(e3) {
            var t3 = 0 | e3;
            return e3 > 0 || e3 === t3 ? t3 : t3 - 1;
          }
          function d2(e3) {
            for (var t3, r3, n3 = 1, i3 = e3.length, a3 = e3[0] + ""; n3 < i3; ) {
              for (t3 = e3[n3++] + "", r3 = l2 - t3.length; r3--; t3 = "0" + t3) ;
              a3 += t3;
            }
            for (i3 = a3.length; 48 === a3.charCodeAt(--i3); ) ;
            return a3.slice(0, i3 + 1 || 1);
          }
          function m2(e3, t3) {
            var r3, n3, i3 = e3.c, a3 = t3.c, o3 = e3.s, u3 = t3.s, s3 = e3.e, l3 = t3.e;
            if (!o3 || !u3) return null;
            if (r3 = i3 && !i3[0], n3 = a3 && !a3[0], r3 || n3) return r3 ? n3 ? 0 : -u3 : o3;
            if (o3 != u3) return o3;
            if (r3 = o3 < 0, n3 = s3 == l3, !i3 || !a3) return n3 ? 0 : !i3 ^ r3 ? 1 : -1;
            if (!n3) return s3 > l3 ^ r3 ? 1 : -1;
            for (u3 = (s3 = i3.length) < (l3 = a3.length) ? s3 : l3, o3 = 0; o3 < u3; o3++) if (i3[o3] != a3[o3]) return i3[o3] > a3[o3] ^ r3 ? 1 : -1;
            return s3 == l3 ? 0 : s3 > l3 ^ r3 ? 1 : -1;
          }
          function y2(e3, t3, r3, n3) {
            if (e3 < t3 || e3 > r3 || e3 !== a2(e3)) throw Error(o2 + (n3 || "Argument") + ("number" == typeof e3 ? e3 < t3 || e3 > r3 ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(e3));
          }
          function b2(e3) {
            var t3 = e3.c.length - 1;
            return h2(e3.e / l2) == t3 && e3.c[t3] % 2 != 0;
          }
          function v2(e3, t3) {
            return (e3.length > 1 ? e3.charAt(0) + "." + e3.slice(1) : e3) + (t3 < 0 ? "e" : "e+") + t3;
          }
          function w2(e3, t3, r3) {
            var n3, i3;
            if (t3 < 0) {
              for (i3 = r3 + "."; ++t3; i3 += r3) ;
              e3 = i3 + e3;
            } else if (++t3 > (n3 = e3.length)) {
              for (i3 = r3, t3 -= n3; --t3; i3 += r3) ;
              e3 += i3;
            } else t3 < n3 && (e3 = e3.slice(0, t3) + "." + e3.slice(t3));
            return e3;
          }
          r2 = (function e3(t3) {
            var r3, O2, x2, S2, N2, $2, B2, M2, D2, F2, E2 = q2.prototype = { constructor: q2, toString: null, valueOf: null }, A2 = new q2(1), _2 = 20, k2 = 4, L2 = -7, P2 = 21, T2 = -1e7, C2 = 1e7, j2 = false, U2 = 1, R2 = 0, I2 = { prefix: "", groupSize: 3, secondaryGroupSize: 0, groupSeparator: ",", decimalSeparator: ".", fractionGroupSize: 0, fractionGroupSeparator: " ", suffix: "" }, G2 = "0123456789abcdefghijklmnopqrstuvwxyz", V2 = true;
            function q2(e4, t4) {
              var r4, i3, o3, s3, f3, p3, g3, h3, d3 = this;
              if (!(d3 instanceof q2)) return new q2(e4, t4);
              if (null == t4) {
                if (e4 && true === e4._isBigNumber) return d3.s = e4.s, void (!e4.c || e4.e > C2 ? d3.c = d3.e = null : e4.e < T2 ? d3.c = [d3.e = 0] : (d3.e = e4.e, d3.c = e4.c.slice()));
                if ((p3 = "number" == typeof e4) && 0 * e4 == 0) {
                  if (d3.s = 1 / e4 < 0 ? (e4 = -e4, -1) : 1, e4 === ~~e4) {
                    for (s3 = 0, f3 = e4; f3 >= 10; f3 /= 10, s3++) ;
                    return void (s3 > C2 ? d3.c = d3.e = null : (d3.e = s3, d3.c = [e4]));
                  }
                  h3 = String(e4);
                } else {
                  if (!n2.test(h3 = String(e4))) return x2(d3, h3, p3);
                  d3.s = 45 == h3.charCodeAt(0) ? (h3 = h3.slice(1), -1) : 1;
                }
                (s3 = h3.indexOf(".")) > -1 && (h3 = h3.replace(".", "")), (f3 = h3.search(/e/i)) > 0 ? (s3 < 0 && (s3 = f3), s3 += +h3.slice(f3 + 1), h3 = h3.substring(0, f3)) : s3 < 0 && (s3 = h3.length);
              } else {
                if (y2(t4, 2, G2.length, "Base"), 10 == t4 && V2) return H(d3 = new q2(e4), _2 + d3.e + 1, k2);
                if (h3 = String(e4), p3 = "number" == typeof e4) {
                  if (0 * e4 != 0) return x2(d3, h3, p3, t4);
                  if (d3.s = 1 / e4 < 0 ? (h3 = h3.slice(1), -1) : 1, q2.DEBUG && h3.replace(/^0\.0*|\./, "").length > 15) throw Error(u2 + e4);
                } else d3.s = 45 === h3.charCodeAt(0) ? (h3 = h3.slice(1), -1) : 1;
                for (r4 = G2.slice(0, t4), s3 = f3 = 0, g3 = h3.length; f3 < g3; f3++) if (r4.indexOf(i3 = h3.charAt(f3)) < 0) {
                  if ("." == i3) {
                    if (f3 > s3) {
                      s3 = g3;
                      continue;
                    }
                  } else if (!o3 && (h3 == h3.toUpperCase() && (h3 = h3.toLowerCase()) || h3 == h3.toLowerCase() && (h3 = h3.toUpperCase()))) {
                    o3 = true, f3 = -1, s3 = 0;
                    continue;
                  }
                  return x2(d3, String(e4), p3, t4);
                }
                p3 = false, (s3 = (h3 = O2(h3, t4, 10, d3.s)).indexOf(".")) > -1 ? h3 = h3.replace(".", "") : s3 = h3.length;
              }
              for (f3 = 0; 48 === h3.charCodeAt(f3); f3++) ;
              for (g3 = h3.length; 48 === h3.charCodeAt(--g3); ) ;
              if (h3 = h3.slice(f3, ++g3)) {
                if (g3 -= f3, p3 && q2.DEBUG && g3 > 15 && (e4 > c2 || e4 !== a2(e4))) throw Error(u2 + d3.s * e4);
                if ((s3 = s3 - f3 - 1) > C2) d3.c = d3.e = null;
                else if (s3 < T2) d3.c = [d3.e = 0];
                else {
                  if (d3.e = s3, d3.c = [], f3 = (s3 + 1) % l2, s3 < 0 && (f3 += l2), f3 < g3) {
                    for (f3 && d3.c.push(+h3.slice(0, f3)), g3 -= l2; f3 < g3; ) d3.c.push(+h3.slice(f3, f3 += l2));
                    f3 = l2 - (h3 = h3.slice(f3)).length;
                  } else f3 -= g3;
                  for (; f3--; h3 += "0") ;
                  d3.c.push(+h3);
                }
              } else d3.c = [d3.e = 0];
            }
            function Z(e4, t4, r4, n3) {
              var i3, a3, o3, u3, s3;
              if (null == r4 ? r4 = k2 : y2(r4, 0, 8), !e4.c) return e4.toString();
              if (i3 = e4.c[0], o3 = e4.e, null == t4) s3 = d2(e4.c), s3 = 1 == n3 || 2 == n3 && (o3 <= L2 || o3 >= P2) ? v2(s3, o3) : w2(s3, o3, "0");
              else if (a3 = (e4 = H(new q2(e4), t4, r4)).e, u3 = (s3 = d2(e4.c)).length, 1 == n3 || 2 == n3 && (t4 <= a3 || a3 <= L2)) {
                for (; u3 < t4; s3 += "0", u3++) ;
                s3 = v2(s3, a3);
              } else if (t4 -= o3, s3 = w2(s3, a3, "0"), a3 + 1 > u3) {
                if (--t4 > 0) for (s3 += "."; t4--; s3 += "0") ;
              } else if ((t4 += a3 - u3) > 0) for (a3 + 1 == u3 && (s3 += "."); t4--; s3 += "0") ;
              return e4.s < 0 && i3 ? "-" + s3 : s3;
            }
            function z(e4, t4) {
              for (var r4, n3, i3 = 1, a3 = new q2(e4[0]); i3 < e4.length; i3++) (!(n3 = new q2(e4[i3])).s || (r4 = m2(a3, n3)) === t4 || 0 === r4 && a3.s === t4) && (a3 = n3);
              return a3;
            }
            function W(e4, t4, r4) {
              for (var n3 = 1, i3 = t4.length; !t4[--i3]; t4.pop()) ;
              for (i3 = t4[0]; i3 >= 10; i3 /= 10, n3++) ;
              return (r4 = n3 + r4 * l2 - 1) > C2 ? e4.c = e4.e = null : r4 < T2 ? e4.c = [e4.e = 0] : (e4.e = r4, e4.c = t4), e4;
            }
            function H(e4, t4, r4, n3) {
              var o3, u3, c3, p3, g3, h3, d3, m3 = e4.c, y3 = f2;
              if (m3) {
                e: {
                  for (o3 = 1, p3 = m3[0]; p3 >= 10; p3 /= 10, o3++) ;
                  if ((u3 = t4 - o3) < 0) u3 += l2, c3 = t4, g3 = m3[h3 = 0], d3 = a2(g3 / y3[o3 - c3 - 1] % 10);
                  else if ((h3 = i2((u3 + 1) / l2)) >= m3.length) {
                    if (!n3) break e;
                    for (; m3.length <= h3; m3.push(0)) ;
                    g3 = d3 = 0, o3 = 1, c3 = (u3 %= l2) - l2 + 1;
                  } else {
                    for (g3 = p3 = m3[h3], o3 = 1; p3 >= 10; p3 /= 10, o3++) ;
                    d3 = (c3 = (u3 %= l2) - l2 + o3) < 0 ? 0 : a2(g3 / y3[o3 - c3 - 1] % 10);
                  }
                  if (n3 = n3 || t4 < 0 || null != m3[h3 + 1] || (c3 < 0 ? g3 : g3 % y3[o3 - c3 - 1]), n3 = r4 < 4 ? (d3 || n3) && (0 == r4 || r4 == (e4.s < 0 ? 3 : 2)) : d3 > 5 || 5 == d3 && (4 == r4 || n3 || 6 == r4 && (u3 > 0 ? c3 > 0 ? g3 / y3[o3 - c3] : 0 : m3[h3 - 1]) % 10 & 1 || r4 == (e4.s < 0 ? 8 : 7)), t4 < 1 || !m3[0]) return m3.length = 0, n3 ? (t4 -= e4.e + 1, m3[0] = y3[(l2 - t4 % l2) % l2], e4.e = -t4 || 0) : m3[0] = e4.e = 0, e4;
                  if (0 == u3 ? (m3.length = h3, p3 = 1, h3--) : (m3.length = h3 + 1, p3 = y3[l2 - u3], m3[h3] = c3 > 0 ? a2(g3 / y3[o3 - c3] % y3[c3]) * p3 : 0), n3) for (; ; ) {
                    if (0 == h3) {
                      for (u3 = 1, c3 = m3[0]; c3 >= 10; c3 /= 10, u3++) ;
                      for (c3 = m3[0] += p3, p3 = 1; c3 >= 10; c3 /= 10, p3++) ;
                      u3 != p3 && (e4.e++, m3[0] == s2 && (m3[0] = 1));
                      break;
                    }
                    if (m3[h3] += p3, m3[h3] != s2) break;
                    m3[h3--] = 0, p3 = 1;
                  }
                  for (u3 = m3.length; 0 === m3[--u3]; m3.pop()) ;
                }
                e4.e > C2 ? e4.c = e4.e = null : e4.e < T2 && (e4.c = [e4.e = 0]);
              }
              return e4;
            }
            function Y(e4) {
              var t4, r4 = e4.e;
              return null === r4 ? e4.toString() : (t4 = d2(e4.c), t4 = r4 <= L2 || r4 >= P2 ? v2(t4, r4) : w2(t4, r4, "0"), e4.s < 0 ? "-" + t4 : t4);
            }
            return q2.clone = e3, q2.ROUND_UP = 0, q2.ROUND_DOWN = 1, q2.ROUND_CEIL = 2, q2.ROUND_FLOOR = 3, q2.ROUND_HALF_UP = 4, q2.ROUND_HALF_DOWN = 5, q2.ROUND_HALF_EVEN = 6, q2.ROUND_HALF_CEIL = 7, q2.ROUND_HALF_FLOOR = 8, q2.EUCLID = 9, q2.config = q2.set = function(e4) {
              var t4, r4;
              if (null != e4) {
                if ("object" != typeof e4) throw Error(o2 + "Object expected: " + e4);
                if (e4.hasOwnProperty(t4 = "DECIMAL_PLACES") && (y2(r4 = e4[t4], 0, g2, t4), _2 = r4), e4.hasOwnProperty(t4 = "ROUNDING_MODE") && (y2(r4 = e4[t4], 0, 8, t4), k2 = r4), e4.hasOwnProperty(t4 = "EXPONENTIAL_AT") && ((r4 = e4[t4]) && r4.pop ? (y2(r4[0], -g2, 0, t4), y2(r4[1], 0, g2, t4), L2 = r4[0], P2 = r4[1]) : (y2(r4, -g2, g2, t4), L2 = -(P2 = r4 < 0 ? -r4 : r4))), e4.hasOwnProperty(t4 = "RANGE")) if ((r4 = e4[t4]) && r4.pop) y2(r4[0], -g2, -1, t4), y2(r4[1], 1, g2, t4), T2 = r4[0], C2 = r4[1];
                else {
                  if (y2(r4, -g2, g2, t4), !r4) throw Error(o2 + t4 + " cannot be zero: " + r4);
                  T2 = -(C2 = r4 < 0 ? -r4 : r4);
                }
                if (e4.hasOwnProperty(t4 = "CRYPTO")) {
                  if ((r4 = e4[t4]) !== !!r4) throw Error(o2 + t4 + " not true or false: " + r4);
                  if (r4) {
                    if ("undefined" == typeof crypto || !crypto || !crypto.getRandomValues && !crypto.randomBytes) throw j2 = !r4, Error(o2 + "crypto unavailable");
                    j2 = r4;
                  } else j2 = r4;
                }
                if (e4.hasOwnProperty(t4 = "MODULO_MODE") && (y2(r4 = e4[t4], 0, 9, t4), U2 = r4), e4.hasOwnProperty(t4 = "POW_PRECISION") && (y2(r4 = e4[t4], 0, g2, t4), R2 = r4), e4.hasOwnProperty(t4 = "FORMAT")) {
                  if ("object" != typeof (r4 = e4[t4])) throw Error(o2 + t4 + " not an object: " + r4);
                  I2 = r4;
                }
                if (e4.hasOwnProperty(t4 = "ALPHABET")) {
                  if ("string" != typeof (r4 = e4[t4]) || /^.?$|[+\-.\s]|(.).*\1/.test(r4)) throw Error(o2 + t4 + " invalid: " + r4);
                  V2 = "0123456789" == r4.slice(0, 10), G2 = r4;
                }
              }
              return { DECIMAL_PLACES: _2, ROUNDING_MODE: k2, EXPONENTIAL_AT: [L2, P2], RANGE: [T2, C2], CRYPTO: j2, MODULO_MODE: U2, POW_PRECISION: R2, FORMAT: I2, ALPHABET: G2 };
            }, q2.isBigNumber = function(e4) {
              if (!e4 || true !== e4._isBigNumber) return false;
              if (!q2.DEBUG) return true;
              var t4, r4, n3 = e4.c, i3 = e4.e, u3 = e4.s;
              e: if ("[object Array]" == {}.toString.call(n3)) {
                if ((1 === u3 || -1 === u3) && i3 >= -g2 && i3 <= g2 && i3 === a2(i3)) {
                  if (0 === n3[0]) {
                    if (0 === i3 && 1 === n3.length) return true;
                    break e;
                  }
                  if ((t4 = (i3 + 1) % l2) < 1 && (t4 += l2), String(n3[0]).length == t4) {
                    for (t4 = 0; t4 < n3.length; t4++) if ((r4 = n3[t4]) < 0 || r4 >= s2 || r4 !== a2(r4)) break e;
                    if (0 !== r4) return true;
                  }
                }
              } else if (null === n3 && null === i3 && (null === u3 || 1 === u3 || -1 === u3)) return true;
              throw Error(o2 + "Invalid BigNumber: " + e4);
            }, q2.maximum = q2.max = function() {
              return z(arguments, -1);
            }, q2.minimum = q2.min = function() {
              return z(arguments, 1);
            }, q2.random = (S2 = 9007199254740992, N2 = Math.random() * S2 & 2097151 ? function() {
              return a2(Math.random() * S2);
            } : function() {
              return 8388608 * (1073741824 * Math.random() | 0) + (8388608 * Math.random() | 0);
            }, function(e4) {
              var t4, r4, n3, u3, s3, c3 = 0, p3 = [], h3 = new q2(A2);
              if (null == e4 ? e4 = _2 : y2(e4, 0, g2), u3 = i2(e4 / l2), j2) if (crypto.getRandomValues) {
                for (t4 = crypto.getRandomValues(new Uint32Array(u3 *= 2)); c3 < u3; ) (s3 = 131072 * t4[c3] + (t4[c3 + 1] >>> 11)) >= 9e15 ? (r4 = crypto.getRandomValues(new Uint32Array(2)), t4[c3] = r4[0], t4[c3 + 1] = r4[1]) : (p3.push(s3 % 1e14), c3 += 2);
                c3 = u3 / 2;
              } else {
                if (!crypto.randomBytes) throw j2 = false, Error(o2 + "crypto unavailable");
                for (t4 = crypto.randomBytes(u3 *= 7); c3 < u3; ) (s3 = 281474976710656 * (31 & t4[c3]) + 1099511627776 * t4[c3 + 1] + 4294967296 * t4[c3 + 2] + 16777216 * t4[c3 + 3] + (t4[c3 + 4] << 16) + (t4[c3 + 5] << 8) + t4[c3 + 6]) >= 9e15 ? crypto.randomBytes(7).copy(t4, c3) : (p3.push(s3 % 1e14), c3 += 7);
                c3 = u3 / 7;
              }
              if (!j2) for (; c3 < u3; ) (s3 = N2()) < 9e15 && (p3[c3++] = s3 % 1e14);
              for (u3 = p3[--c3], e4 %= l2, u3 && e4 && (s3 = f2[l2 - e4], p3[c3] = a2(u3 / s3) * s3); 0 === p3[c3]; p3.pop(), c3--) ;
              if (c3 < 0) p3 = [n3 = 0];
              else {
                for (n3 = -1; 0 === p3[0]; p3.splice(0, 1), n3 -= l2) ;
                for (c3 = 1, s3 = p3[0]; s3 >= 10; s3 /= 10, c3++) ;
                c3 < l2 && (n3 -= l2 - c3);
              }
              return h3.e = n3, h3.c = p3, h3;
            }), q2.sum = function() {
              for (var e4 = 1, t4 = arguments, r4 = new q2(t4[0]); e4 < t4.length; ) r4 = r4.plus(t4[e4++]);
              return r4;
            }, O2 = /* @__PURE__ */ (function() {
              var e4 = "0123456789";
              function t4(e5, t5, r4, n3) {
                for (var i3, a3, o3 = [0], u3 = 0, s3 = e5.length; u3 < s3; ) {
                  for (a3 = o3.length; a3--; o3[a3] *= t5) ;
                  for (o3[0] += n3.indexOf(e5.charAt(u3++)), i3 = 0; i3 < o3.length; i3++) o3[i3] > r4 - 1 && (null == o3[i3 + 1] && (o3[i3 + 1] = 0), o3[i3 + 1] += o3[i3] / r4 | 0, o3[i3] %= r4);
                }
                return o3.reverse();
              }
              return function(n3, i3, a3, o3, u3) {
                var s3, l3, c3, f3, p3, g3, h3, m3, y3 = n3.indexOf("."), b3 = _2, v3 = k2;
                for (y3 >= 0 && (f3 = R2, R2 = 0, n3 = n3.replace(".", ""), g3 = (m3 = new q2(i3)).pow(n3.length - y3), R2 = f3, m3.c = t4(w2(d2(g3.c), g3.e, "0"), 10, a3, e4), m3.e = m3.c.length), c3 = f3 = (h3 = t4(n3, i3, a3, u3 ? (s3 = G2, e4) : (s3 = e4, G2))).length; 0 == h3[--f3]; h3.pop()) ;
                if (!h3[0]) return s3.charAt(0);
                if (y3 < 0 ? --c3 : (g3.c = h3, g3.e = c3, g3.s = o3, h3 = (g3 = r3(g3, m3, b3, v3, a3)).c, p3 = g3.r, c3 = g3.e), y3 = h3[l3 = c3 + b3 + 1], f3 = a3 / 2, p3 = p3 || l3 < 0 || null != h3[l3 + 1], p3 = v3 < 4 ? (null != y3 || p3) && (0 == v3 || v3 == (g3.s < 0 ? 3 : 2)) : y3 > f3 || y3 == f3 && (4 == v3 || p3 || 6 == v3 && 1 & h3[l3 - 1] || v3 == (g3.s < 0 ? 8 : 7)), l3 < 1 || !h3[0]) n3 = p3 ? w2(s3.charAt(1), -b3, s3.charAt(0)) : s3.charAt(0);
                else {
                  if (h3.length = l3, p3) for (--a3; ++h3[--l3] > a3; ) h3[l3] = 0, l3 || (++c3, h3 = [1].concat(h3));
                  for (f3 = h3.length; !h3[--f3]; ) ;
                  for (y3 = 0, n3 = ""; y3 <= f3; n3 += s3.charAt(h3[y3++])) ;
                  n3 = w2(n3, c3, s3.charAt(0));
                }
                return n3;
              };
            })(), r3 = /* @__PURE__ */ (function() {
              function e4(e5, t5, r5) {
                var n3, i3, a3, o3, u3 = 0, s3 = e5.length, l3 = t5 % p2, c3 = t5 / p2 | 0;
                for (e5 = e5.slice(); s3--; ) u3 = ((i3 = l3 * (a3 = e5[s3] % p2) + (n3 = c3 * a3 + (o3 = e5[s3] / p2 | 0) * l3) % p2 * p2 + u3) / r5 | 0) + (n3 / p2 | 0) + c3 * o3, e5[s3] = i3 % r5;
                return u3 && (e5 = [u3].concat(e5)), e5;
              }
              function t4(e5, t5, r5, n3) {
                var i3, a3;
                if (r5 != n3) a3 = r5 > n3 ? 1 : -1;
                else for (i3 = a3 = 0; i3 < r5; i3++) if (e5[i3] != t5[i3]) {
                  a3 = e5[i3] > t5[i3] ? 1 : -1;
                  break;
                }
                return a3;
              }
              function r4(e5, t5, r5, n3) {
                for (var i3 = 0; r5--; ) e5[r5] -= i3, i3 = e5[r5] < t5[r5] ? 1 : 0, e5[r5] = i3 * n3 + e5[r5] - t5[r5];
                for (; !e5[0] && e5.length > 1; e5.splice(0, 1)) ;
              }
              return function(n3, i3, o3, u3, c3) {
                var f3, p3, g3, d3, m3, y3, b3, v3, w3, O3, x3, S3, N3, $3, B3, M3, D3, F3 = n3.s == i3.s ? 1 : -1, E3 = n3.c, A3 = i3.c;
                if (!(E3 && E3[0] && A3 && A3[0])) return new q2(n3.s && i3.s && (E3 ? !A3 || E3[0] != A3[0] : A3) ? E3 && 0 == E3[0] || !A3 ? 0 * F3 : F3 / 0 : NaN);
                for (w3 = (v3 = new q2(F3)).c = [], F3 = o3 + (p3 = n3.e - i3.e) + 1, c3 || (c3 = s2, p3 = h2(n3.e / l2) - h2(i3.e / l2), F3 = F3 / l2 | 0), g3 = 0; A3[g3] == (E3[g3] || 0); g3++) ;
                if (A3[g3] > (E3[g3] || 0) && p3--, F3 < 0) w3.push(1), d3 = true;
                else {
                  for ($3 = E3.length, M3 = A3.length, g3 = 0, F3 += 2, (m3 = a2(c3 / (A3[0] + 1))) > 1 && (A3 = e4(A3, m3, c3), E3 = e4(E3, m3, c3), M3 = A3.length, $3 = E3.length), N3 = M3, x3 = (O3 = E3.slice(0, M3)).length; x3 < M3; O3[x3++] = 0) ;
                  D3 = A3.slice(), D3 = [0].concat(D3), B3 = A3[0], A3[1] >= c3 / 2 && B3++;
                  do {
                    if (m3 = 0, (f3 = t4(A3, O3, M3, x3)) < 0) {
                      if (S3 = O3[0], M3 != x3 && (S3 = S3 * c3 + (O3[1] || 0)), (m3 = a2(S3 / B3)) > 1) for (m3 >= c3 && (m3 = c3 - 1), b3 = (y3 = e4(A3, m3, c3)).length, x3 = O3.length; 1 == t4(y3, O3, b3, x3); ) m3--, r4(y3, M3 < b3 ? D3 : A3, b3, c3), b3 = y3.length, f3 = 1;
                      else 0 == m3 && (f3 = m3 = 1), b3 = (y3 = A3.slice()).length;
                      if (b3 < x3 && (y3 = [0].concat(y3)), r4(O3, y3, x3, c3), x3 = O3.length, -1 == f3) for (; t4(A3, O3, M3, x3) < 1; ) m3++, r4(O3, M3 < x3 ? D3 : A3, x3, c3), x3 = O3.length;
                    } else 0 === f3 && (m3++, O3 = [0]);
                    w3[g3++] = m3, O3[0] ? O3[x3++] = E3[N3] || 0 : (O3 = [E3[N3]], x3 = 1);
                  } while ((N3++ < $3 || null != O3[0]) && F3--);
                  d3 = null != O3[0], w3[0] || w3.splice(0, 1);
                }
                if (c3 == s2) {
                  for (g3 = 1, F3 = w3[0]; F3 >= 10; F3 /= 10, g3++) ;
                  H(v3, o3 + (v3.e = g3 + p3 * l2 - 1) + 1, u3, d3);
                } else v3.e = p3, v3.r = +d3;
                return v3;
              };
            })(), $2 = /^(-?)0([xbo])(?=\w[\w.]*$)/i, B2 = /^([^.]+)\.$/, M2 = /^\.([^.]+)$/, D2 = /^-?(Infinity|NaN)$/, F2 = /^\s*\+(?=[\w.])|^\s+|\s+$/g, x2 = function(e4, t4, r4, n3) {
              var i3, a3 = r4 ? t4 : t4.replace(F2, "");
              if (D2.test(a3)) e4.s = isNaN(a3) ? null : a3 < 0 ? -1 : 1;
              else {
                if (!r4 && (a3 = a3.replace($2, (function(e5, t5, r5) {
                  return i3 = "x" == (r5 = r5.toLowerCase()) ? 16 : "b" == r5 ? 2 : 8, n3 && n3 != i3 ? e5 : t5;
                })), n3 && (i3 = n3, a3 = a3.replace(B2, "$1").replace(M2, "0.$1")), t4 != a3)) return new q2(a3, i3);
                if (q2.DEBUG) throw Error(o2 + "Not a" + (n3 ? " base " + n3 : "") + " number: " + t4);
                e4.s = null;
              }
              e4.c = e4.e = null;
            }, E2.absoluteValue = E2.abs = function() {
              var e4 = new q2(this);
              return e4.s < 0 && (e4.s = 1), e4;
            }, E2.comparedTo = function(e4, t4) {
              return m2(this, new q2(e4, t4));
            }, E2.decimalPlaces = E2.dp = function(e4, t4) {
              var r4, n3, i3, a3 = this;
              if (null != e4) return y2(e4, 0, g2), null == t4 ? t4 = k2 : y2(t4, 0, 8), H(new q2(a3), e4 + a3.e + 1, t4);
              if (!(r4 = a3.c)) return null;
              if (n3 = ((i3 = r4.length - 1) - h2(this.e / l2)) * l2, i3 = r4[i3]) for (; i3 % 10 == 0; i3 /= 10, n3--) ;
              return n3 < 0 && (n3 = 0), n3;
            }, E2.dividedBy = E2.div = function(e4, t4) {
              return r3(this, new q2(e4, t4), _2, k2);
            }, E2.dividedToIntegerBy = E2.idiv = function(e4, t4) {
              return r3(this, new q2(e4, t4), 0, 1);
            }, E2.exponentiatedBy = E2.pow = function(e4, t4) {
              var r4, n3, u3, s3, c3, f3, p3, g3, h3 = this;
              if ((e4 = new q2(e4)).c && !e4.isInteger()) throw Error(o2 + "Exponent not an integer: " + Y(e4));
              if (null != t4 && (t4 = new q2(t4)), c3 = e4.e > 14, !h3.c || !h3.c[0] || 1 == h3.c[0] && !h3.e && 1 == h3.c.length || !e4.c || !e4.c[0]) return g3 = new q2(Math.pow(+Y(h3), c3 ? e4.s * (2 - b2(e4)) : +Y(e4))), t4 ? g3.mod(t4) : g3;
              if (f3 = e4.s < 0, t4) {
                if (t4.c ? !t4.c[0] : !t4.s) return new q2(NaN);
                (n3 = !f3 && h3.isInteger() && t4.isInteger()) && (h3 = h3.mod(t4));
              } else {
                if (e4.e > 9 && (h3.e > 0 || h3.e < -1 || (0 == h3.e ? h3.c[0] > 1 || c3 && h3.c[1] >= 24e7 : h3.c[0] < 8e13 || c3 && h3.c[0] <= 9999975e7))) return s3 = h3.s < 0 && b2(e4) ? -0 : 0, h3.e > -1 && (s3 = 1 / s3), new q2(f3 ? 1 / s3 : s3);
                R2 && (s3 = i2(R2 / l2 + 2));
              }
              for (c3 ? (r4 = new q2(0.5), f3 && (e4.s = 1), p3 = b2(e4)) : p3 = (u3 = Math.abs(+Y(e4))) % 2, g3 = new q2(A2); ; ) {
                if (p3) {
                  if (!(g3 = g3.times(h3)).c) break;
                  s3 ? g3.c.length > s3 && (g3.c.length = s3) : n3 && (g3 = g3.mod(t4));
                }
                if (u3) {
                  if (0 === (u3 = a2(u3 / 2))) break;
                  p3 = u3 % 2;
                } else if (H(e4 = e4.times(r4), e4.e + 1, 1), e4.e > 14) p3 = b2(e4);
                else {
                  if (0 === (u3 = +Y(e4))) break;
                  p3 = u3 % 2;
                }
                h3 = h3.times(h3), s3 ? h3.c && h3.c.length > s3 && (h3.c.length = s3) : n3 && (h3 = h3.mod(t4));
              }
              return n3 ? g3 : (f3 && (g3 = A2.div(g3)), t4 ? g3.mod(t4) : s3 ? H(g3, R2, k2, void 0) : g3);
            }, E2.integerValue = function(e4) {
              var t4 = new q2(this);
              return null == e4 ? e4 = k2 : y2(e4, 0, 8), H(t4, t4.e + 1, e4);
            }, E2.isEqualTo = E2.eq = function(e4, t4) {
              return 0 === m2(this, new q2(e4, t4));
            }, E2.isFinite = function() {
              return !!this.c;
            }, E2.isGreaterThan = E2.gt = function(e4, t4) {
              return m2(this, new q2(e4, t4)) > 0;
            }, E2.isGreaterThanOrEqualTo = E2.gte = function(e4, t4) {
              return 1 === (t4 = m2(this, new q2(e4, t4))) || 0 === t4;
            }, E2.isInteger = function() {
              return !!this.c && h2(this.e / l2) > this.c.length - 2;
            }, E2.isLessThan = E2.lt = function(e4, t4) {
              return m2(this, new q2(e4, t4)) < 0;
            }, E2.isLessThanOrEqualTo = E2.lte = function(e4, t4) {
              return -1 === (t4 = m2(this, new q2(e4, t4))) || 0 === t4;
            }, E2.isNaN = function() {
              return !this.s;
            }, E2.isNegative = function() {
              return this.s < 0;
            }, E2.isPositive = function() {
              return this.s > 0;
            }, E2.isZero = function() {
              return !!this.c && 0 == this.c[0];
            }, E2.minus = function(e4, t4) {
              var r4, n3, i3, a3, o3 = this, u3 = o3.s;
              if (t4 = (e4 = new q2(e4, t4)).s, !u3 || !t4) return new q2(NaN);
              if (u3 != t4) return e4.s = -t4, o3.plus(e4);
              var c3 = o3.e / l2, f3 = e4.e / l2, p3 = o3.c, g3 = e4.c;
              if (!c3 || !f3) {
                if (!p3 || !g3) return p3 ? (e4.s = -t4, e4) : new q2(g3 ? o3 : NaN);
                if (!p3[0] || !g3[0]) return g3[0] ? (e4.s = -t4, e4) : new q2(p3[0] ? o3 : 3 == k2 ? -0 : 0);
              }
              if (c3 = h2(c3), f3 = h2(f3), p3 = p3.slice(), u3 = c3 - f3) {
                for ((a3 = u3 < 0) ? (u3 = -u3, i3 = p3) : (f3 = c3, i3 = g3), i3.reverse(), t4 = u3; t4--; i3.push(0)) ;
                i3.reverse();
              } else for (n3 = (a3 = (u3 = p3.length) < (t4 = g3.length)) ? u3 : t4, u3 = t4 = 0; t4 < n3; t4++) if (p3[t4] != g3[t4]) {
                a3 = p3[t4] < g3[t4];
                break;
              }
              if (a3 && (i3 = p3, p3 = g3, g3 = i3, e4.s = -e4.s), (t4 = (n3 = g3.length) - (r4 = p3.length)) > 0) for (; t4--; p3[r4++] = 0) ;
              for (t4 = s2 - 1; n3 > u3; ) {
                if (p3[--n3] < g3[n3]) {
                  for (r4 = n3; r4 && !p3[--r4]; p3[r4] = t4) ;
                  --p3[r4], p3[n3] += s2;
                }
                p3[n3] -= g3[n3];
              }
              for (; 0 == p3[0]; p3.splice(0, 1), --f3) ;
              return p3[0] ? W(e4, p3, f3) : (e4.s = 3 == k2 ? -1 : 1, e4.c = [e4.e = 0], e4);
            }, E2.modulo = E2.mod = function(e4, t4) {
              var n3, i3, a3 = this;
              return e4 = new q2(e4, t4), !a3.c || !e4.s || e4.c && !e4.c[0] ? new q2(NaN) : !e4.c || a3.c && !a3.c[0] ? new q2(a3) : (9 == U2 ? (i3 = e4.s, e4.s = 1, n3 = r3(a3, e4, 0, 3), e4.s = i3, n3.s *= i3) : n3 = r3(a3, e4, 0, U2), (e4 = a3.minus(n3.times(e4))).c[0] || 1 != U2 || (e4.s = a3.s), e4);
            }, E2.multipliedBy = E2.times = function(e4, t4) {
              var r4, n3, i3, a3, o3, u3, c3, f3, g3, d3, m3, y3, b3, v3, w3, O3 = this, x3 = O3.c, S3 = (e4 = new q2(e4, t4)).c;
              if (!(x3 && S3 && x3[0] && S3[0])) return !O3.s || !e4.s || x3 && !x3[0] && !S3 || S3 && !S3[0] && !x3 ? e4.c = e4.e = e4.s = null : (e4.s *= O3.s, x3 && S3 ? (e4.c = [0], e4.e = 0) : e4.c = e4.e = null), e4;
              for (n3 = h2(O3.e / l2) + h2(e4.e / l2), e4.s *= O3.s, (c3 = x3.length) < (d3 = S3.length) && (b3 = x3, x3 = S3, S3 = b3, i3 = c3, c3 = d3, d3 = i3), i3 = c3 + d3, b3 = []; i3--; b3.push(0)) ;
              for (v3 = s2, w3 = p2, i3 = d3; --i3 >= 0; ) {
                for (r4 = 0, m3 = S3[i3] % w3, y3 = S3[i3] / w3 | 0, a3 = i3 + (o3 = c3); a3 > i3; ) r4 = ((f3 = m3 * (f3 = x3[--o3] % w3) + (u3 = y3 * f3 + (g3 = x3[o3] / w3 | 0) * m3) % w3 * w3 + b3[a3] + r4) / v3 | 0) + (u3 / w3 | 0) + y3 * g3, b3[a3--] = f3 % v3;
                b3[a3] = r4;
              }
              return r4 ? ++n3 : b3.splice(0, 1), W(e4, b3, n3);
            }, E2.negated = function() {
              var e4 = new q2(this);
              return e4.s = -e4.s || null, e4;
            }, E2.plus = function(e4, t4) {
              var r4, n3 = this, i3 = n3.s;
              if (t4 = (e4 = new q2(e4, t4)).s, !i3 || !t4) return new q2(NaN);
              if (i3 != t4) return e4.s = -t4, n3.minus(e4);
              var a3 = n3.e / l2, o3 = e4.e / l2, u3 = n3.c, c3 = e4.c;
              if (!a3 || !o3) {
                if (!u3 || !c3) return new q2(i3 / 0);
                if (!u3[0] || !c3[0]) return c3[0] ? e4 : new q2(u3[0] ? n3 : 0 * i3);
              }
              if (a3 = h2(a3), o3 = h2(o3), u3 = u3.slice(), i3 = a3 - o3) {
                for (i3 > 0 ? (o3 = a3, r4 = c3) : (i3 = -i3, r4 = u3), r4.reverse(); i3--; r4.push(0)) ;
                r4.reverse();
              }
              for ((i3 = u3.length) - (t4 = c3.length) < 0 && (r4 = c3, c3 = u3, u3 = r4, t4 = i3), i3 = 0; t4; ) i3 = (u3[--t4] = u3[t4] + c3[t4] + i3) / s2 | 0, u3[t4] = s2 === u3[t4] ? 0 : u3[t4] % s2;
              return i3 && (u3 = [i3].concat(u3), ++o3), W(e4, u3, o3);
            }, E2.precision = E2.sd = function(e4, t4) {
              var r4, n3, i3, a3 = this;
              if (null != e4 && e4 !== !!e4) return y2(e4, 1, g2), null == t4 ? t4 = k2 : y2(t4, 0, 8), H(new q2(a3), e4, t4);
              if (!(r4 = a3.c)) return null;
              if (n3 = (i3 = r4.length - 1) * l2 + 1, i3 = r4[i3]) {
                for (; i3 % 10 == 0; i3 /= 10, n3--) ;
                for (i3 = r4[0]; i3 >= 10; i3 /= 10, n3++) ;
              }
              return e4 && a3.e + 1 > n3 && (n3 = a3.e + 1), n3;
            }, E2.shiftedBy = function(e4) {
              return y2(e4, -9007199254740991, c2), this.times("1e" + e4);
            }, E2.squareRoot = E2.sqrt = function() {
              var e4, t4, n3, i3, a3, o3 = this, u3 = o3.c, s3 = o3.s, l3 = o3.e, c3 = _2 + 4, f3 = new q2("0.5");
              if (1 !== s3 || !u3 || !u3[0]) return new q2(!s3 || s3 < 0 && (!u3 || u3[0]) ? NaN : u3 ? o3 : 1 / 0);
              if (0 == (s3 = Math.sqrt(+Y(o3))) || s3 == 1 / 0 ? (((t4 = d2(u3)).length + l3) % 2 == 0 && (t4 += "0"), s3 = Math.sqrt(+t4), l3 = h2((l3 + 1) / 2) - (l3 < 0 || l3 % 2), n3 = new q2(t4 = s3 == 1 / 0 ? "5e" + l3 : (t4 = s3.toExponential()).slice(0, t4.indexOf("e") + 1) + l3)) : n3 = new q2(s3 + ""), n3.c[0]) {
                for ((s3 = (l3 = n3.e) + c3) < 3 && (s3 = 0); ; ) if (a3 = n3, n3 = f3.times(a3.plus(r3(o3, a3, c3, 1))), d2(a3.c).slice(0, s3) === (t4 = d2(n3.c)).slice(0, s3)) {
                  if (n3.e < l3 && --s3, "9999" != (t4 = t4.slice(s3 - 3, s3 + 1)) && (i3 || "4999" != t4)) {
                    +t4 && (+t4.slice(1) || "5" != t4.charAt(0)) || (H(n3, n3.e + _2 + 2, 1), e4 = !n3.times(n3).eq(o3));
                    break;
                  }
                  if (!i3 && (H(a3, a3.e + _2 + 2, 0), a3.times(a3).eq(o3))) {
                    n3 = a3;
                    break;
                  }
                  c3 += 4, s3 += 4, i3 = 1;
                }
              }
              return H(n3, n3.e + _2 + 1, k2, e4);
            }, E2.toExponential = function(e4, t4) {
              return null != e4 && (y2(e4, 0, g2), e4++), Z(this, e4, t4, 1);
            }, E2.toFixed = function(e4, t4) {
              return null != e4 && (y2(e4, 0, g2), e4 = e4 + this.e + 1), Z(this, e4, t4);
            }, E2.toFormat = function(e4, t4, r4) {
              var n3, i3 = this;
              if (null == r4) null != e4 && t4 && "object" == typeof t4 ? (r4 = t4, t4 = null) : e4 && "object" == typeof e4 ? (r4 = e4, e4 = t4 = null) : r4 = I2;
              else if ("object" != typeof r4) throw Error(o2 + "Argument not an object: " + r4);
              if (n3 = i3.toFixed(e4, t4), i3.c) {
                var a3, u3 = n3.split("."), s3 = +r4.groupSize, l3 = +r4.secondaryGroupSize, c3 = r4.groupSeparator || "", f3 = u3[0], p3 = u3[1], g3 = i3.s < 0, h3 = g3 ? f3.slice(1) : f3, d3 = h3.length;
                if (l3 && (a3 = s3, s3 = l3, l3 = a3, d3 -= a3), s3 > 0 && d3 > 0) {
                  for (a3 = d3 % s3 || s3, f3 = h3.substr(0, a3); a3 < d3; a3 += s3) f3 += c3 + h3.substr(a3, s3);
                  l3 > 0 && (f3 += c3 + h3.slice(a3)), g3 && (f3 = "-" + f3);
                }
                n3 = p3 ? f3 + (r4.decimalSeparator || "") + ((l3 = +r4.fractionGroupSize) ? p3.replace(new RegExp("\\d{" + l3 + "}\\B", "g"), "$&" + (r4.fractionGroupSeparator || "")) : p3) : f3;
              }
              return (r4.prefix || "") + n3 + (r4.suffix || "");
            }, E2.toFraction = function(e4) {
              var t4, n3, i3, a3, u3, s3, c3, p3, g3, h3, m3, y3, b3 = this, v3 = b3.c;
              if (null != e4 && (!(c3 = new q2(e4)).isInteger() && (c3.c || 1 !== c3.s) || c3.lt(A2))) throw Error(o2 + "Argument " + (c3.isInteger() ? "out of range: " : "not an integer: ") + Y(c3));
              if (!v3) return new q2(b3);
              for (t4 = new q2(A2), g3 = n3 = new q2(A2), i3 = p3 = new q2(A2), y3 = d2(v3), u3 = t4.e = y3.length - b3.e - 1, t4.c[0] = f2[(s3 = u3 % l2) < 0 ? l2 + s3 : s3], e4 = !e4 || c3.comparedTo(t4) > 0 ? u3 > 0 ? t4 : g3 : c3, s3 = C2, C2 = 1 / 0, c3 = new q2(y3), p3.c[0] = 0; h3 = r3(c3, t4, 0, 1), 1 != (a3 = n3.plus(h3.times(i3))).comparedTo(e4); ) n3 = i3, i3 = a3, g3 = p3.plus(h3.times(a3 = g3)), p3 = a3, t4 = c3.minus(h3.times(a3 = t4)), c3 = a3;
              return a3 = r3(e4.minus(n3), i3, 0, 1), p3 = p3.plus(a3.times(g3)), n3 = n3.plus(a3.times(i3)), p3.s = g3.s = b3.s, m3 = r3(g3, i3, u3 *= 2, k2).minus(b3).abs().comparedTo(r3(p3, n3, u3, k2).minus(b3).abs()) < 1 ? [g3, i3] : [p3, n3], C2 = s3, m3;
            }, E2.toNumber = function() {
              return +Y(this);
            }, E2.toPrecision = function(e4, t4) {
              return null != e4 && y2(e4, 1, g2), Z(this, e4, t4, 2);
            }, E2.toString = function(e4) {
              var t4, r4 = this, n3 = r4.s, i3 = r4.e;
              return null === i3 ? n3 ? (t4 = "Infinity", n3 < 0 && (t4 = "-" + t4)) : t4 = "NaN" : (null == e4 ? t4 = i3 <= L2 || i3 >= P2 ? v2(d2(r4.c), i3) : w2(d2(r4.c), i3, "0") : 10 === e4 && V2 ? t4 = w2(d2((r4 = H(new q2(r4), _2 + i3 + 1, k2)).c), r4.e, "0") : (y2(e4, 2, G2.length, "Base"), t4 = O2(w2(d2(r4.c), i3, "0"), 10, e4, n3, true)), n3 < 0 && r4.c[0] && (t4 = "-" + t4)), t4;
            }, E2.valueOf = E2.toJSON = function() {
              return Y(this);
            }, E2._isBigNumber = true, null != t3 && q2.set(t3), q2;
          })(), r2.default = r2.BigNumber = r2, e2.exports ? e2.exports = r2 : (t2 || (t2 = "undefined" != typeof self && self ? self : window), t2.BigNumber = r2);
        })(o);
      })(m);
      var y = m.exports;
      const b = h(), v = c(), w = g, O = y, x = { trillion: Math.pow(10, 12), billion: Math.pow(10, 9), million: Math.pow(10, 6), thousand: Math.pow(10, 3) }, S = { totalLength: 0, characteristic: 0, forceAverage: false, average: false, mantissa: -1, optionalMantissa: true, thousandSeparated: false, spaceSeparated: false, negative: "sign", forceSign: false, roundingFunction: Math.round, spaceSeparatedAbbreviation: false }, { binarySuffixes: N, decimalSuffixes: $ } = b.currentBytes(), B = { general: { scale: 1024, suffixes: $, marker: "bd" }, binary: { scale: 1024, suffixes: N, marker: "b" }, decimal: { scale: 1e3, suffixes: $, marker: "d" } };
      function M(e2, t2 = {}, r2) {
        if ("string" == typeof t2 && (t2 = w.parseFormat(t2)), !v.validateFormat(t2)) return "ERROR: invalid format";
        let n2 = t2.prefix || "", i2 = t2.postfix || "", a2 = (function(e3, t3, r3) {
          switch (t3.output) {
            case "currency":
              return (function(e4, t4, r4) {
                const n3 = r4.currentCurrency();
                let i3, a3 = Object.assign({}, t4), o2 = Object.assign({}, S, a3), u2 = "", s2 = !!o2.totalLength || !!o2.forceAverage || o2.average, l2 = a3.currencyPosition || n3.position, c2 = a3.currencySymbol || n3.symbol;
                const f2 = void 0 !== o2.spaceSeparatedCurrency ? o2.spaceSeparatedCurrency : o2.spaceSeparated;
                void 0 === a3.lowPrecision && (a3.lowPrecision = false);
                f2 && (u2 = " ");
                "infix" === l2 && (i3 = u2 + c2 + u2);
                let p2 = A({ instance: e4, providedFormat: a3, state: r4, decimalSeparator: i3 });
                "prefix" === l2 && (p2 = e4._value < 0 && "sign" === o2.negative ? `-${u2}${c2}${p2.slice(1)}` : e4._value > 0 && o2.forceSign ? `+${u2}${c2}${p2.slice(1)}` : c2 + u2 + p2);
                l2 && "postfix" !== l2 || (u2 = !o2.spaceSeparatedAbbreviation && s2 ? "" : u2, p2 = p2 + u2 + c2);
                return p2;
              })(e3, t3 = _(t3, b.currentCurrencyDefaultFormat()), b);
            case "percent":
              return (function(e4, t4, r4, n3) {
                let i3 = t4.prefixSymbol, a3 = A({ instance: n3(100 * e4._value), providedFormat: t4, state: r4 }), o2 = Object.assign({}, S, t4);
                if (i3) return `%${o2.spaceSeparated ? " " : ""}${a3}`;
                return `${a3}${o2.spaceSeparated ? " " : ""}%`;
              })(e3, t3 = _(t3, b.currentPercentageDefaultFormat()), b, r3);
            case "byte":
              return (function(e4, t4, r4, n3) {
                let i3 = t4.base || "binary", a3 = Object.assign({}, S, t4);
                const { binarySuffixes: o2, decimalSuffixes: u2 } = r4.currentBytes();
                let s2 = { general: { scale: 1024, suffixes: u2 || $, marker: "bd" }, binary: { scale: 1024, suffixes: o2 || N, marker: "b" }, decimal: { scale: 1e3, suffixes: u2 || $, marker: "d" } }[i3], { value: l2, suffix: c2 } = D(e4._value, s2.suffixes, s2.scale), f2 = A({ instance: n3(l2), providedFormat: t4, state: r4, defaults: r4.currentByteDefaultFormat() });
                return `${f2}${a3.spaceSeparated ? " " : ""}${c2}`;
              })(e3, t3 = _(t3, b.currentByteDefaultFormat()), b, r3);
            case "time":
              return t3 = _(t3, b.currentTimeDefaultFormat()), (function(e4) {
                let t4 = Math.floor(e4._value / 60 / 60), r4 = Math.floor((e4._value - 60 * t4 * 60) / 60), n3 = Math.round(e4._value - 60 * t4 * 60 - 60 * r4);
                return `${t4}:${r4 < 10 ? "0" : ""}${r4}:${n3 < 10 ? "0" : ""}${n3}`;
              })(e3);
            case "ordinal":
              return (function(e4, t4, r4) {
                let n3 = r4.currentOrdinal(), i3 = Object.assign({}, S, t4), a3 = A({ instance: e4, providedFormat: t4, state: r4 }), o2 = n3(e4._value);
                return `${a3}${i3.spaceSeparated ? " " : ""}${o2}`;
              })(e3, t3 = _(t3, b.currentOrdinalDefaultFormat()), b);
            default:
              return A({ instance: e3, providedFormat: t3, numbro: r3 });
          }
        })(e2, t2, r2);
        return a2 = (function(e3, t3) {
          return t3 + e3;
        })(a2, n2), a2 = (function(e3, t3) {
          return e3 + t3;
        })(a2, i2), a2;
      }
      function D(e2, t2, r2) {
        let n2 = t2[0], i2 = Math.abs(e2);
        if (i2 >= r2) {
          for (let a2 = 1; a2 < t2.length; ++a2) {
            let o2 = Math.pow(r2, a2), u2 = Math.pow(r2, a2 + 1);
            if (i2 >= o2 && i2 < u2) {
              n2 = t2[a2], e2 /= o2;
              break;
            }
          }
          n2 === t2[0] && (e2 /= Math.pow(r2, t2.length - 1), n2 = t2[t2.length - 1]);
        }
        return { value: e2, suffix: n2 };
      }
      function F(e2) {
        let t2 = "";
        for (let r2 = 0; r2 < e2; r2++) t2 += "0";
        return t2;
      }
      function E(e2, t2, r2 = Math.round) {
        if (-1 !== e2.toString().indexOf("e")) return (function(e3, t3) {
          let r3 = e3.toString(), [n2, i2] = r3.split("e"), [a2, o2 = ""] = n2.split(".");
          if (+i2 > 0) r3 = a2 + o2 + F(i2 - o2.length);
          else {
            let e4 = ".";
            e4 = +a2 < 0 ? `-0${e4}` : `0${e4}`;
            let n3 = (F(-i2 - 1) + Math.abs(a2) + o2).substr(0, t3);
            n3.length < t3 && (n3 += F(t3 - n3.length)), r3 = e4 + n3;
          }
          return +i2 > 0 && t3 > 0 && (r3 += `.${F(t3)}`), r3;
        })(e2, t2);
        return new O(r2(+`${e2}e+${t2}`) / Math.pow(10, t2)).toFixed(t2);
      }
      function A({ instance: e2, providedFormat: t2, state: r2 = b, decimalSeparator: n2, defaults: i2 = r2.currentDefaults() }) {
        let a2 = e2._value;
        if (0 === a2 && r2.hasZeroFormat()) return r2.getZeroFormat();
        if (!isFinite(a2)) return a2.toString();
        let o2 = Object.assign({}, S, i2, t2), u2 = o2.totalLength, s2 = u2 ? 0 : o2.characteristic, l2 = o2.optionalCharacteristic, c2 = o2.forceAverage, f2 = o2.lowPrecision, p2 = !!u2 || !!c2 || o2.average, g2 = u2 ? -1 : p2 && void 0 === t2.mantissa ? 0 : o2.mantissa, h2 = !u2 && (void 0 === t2.optionalMantissa ? -1 === g2 : o2.optionalMantissa), d2 = o2.trimMantissa, m2 = o2.thousandSeparated, y2 = o2.spaceSeparated, v2 = o2.negative, w2 = o2.forceSign, O2 = o2.exponential, N2 = o2.roundingFunction, $2 = "";
        if (p2) {
          let e3 = (function({ value: e4, forceAverage: t3, lowPrecision: r3 = true, abbreviations: n3, spaceSeparated: i3 = false, totalLength: a3 = 0, roundingFunction: o3 = Math.round }) {
            let u3 = "", s3 = Math.abs(e4), l3 = -1;
            if (t3 && n3[t3] && x[t3] ? (u3 = n3[t3], e4 /= x[t3]) : s3 >= x.trillion || r3 && 1 === o3(s3 / x.trillion) ? (u3 = n3.trillion, e4 /= x.trillion) : s3 < x.trillion && s3 >= x.billion || r3 && 1 === o3(s3 / x.billion) ? (u3 = n3.billion, e4 /= x.billion) : s3 < x.billion && s3 >= x.million || r3 && 1 === o3(s3 / x.million) ? (u3 = n3.million, e4 /= x.million) : (s3 < x.million && s3 >= x.thousand || r3 && 1 === o3(s3 / x.thousand)) && (u3 = n3.thousand, e4 /= x.thousand), u3 && (u3 = (i3 ? " " : "") + u3), a3) {
              let t4 = e4 < 0, r4 = e4.toString().split(".")[0], n4 = t4 ? r4.length - 1 : r4.length;
              l3 = Math.max(a3 - n4, 0);
            }
            return { value: e4, abbreviation: u3, mantissaPrecision: l3 };
          })({ value: a2, forceAverage: c2, lowPrecision: f2, abbreviations: r2.currentAbbreviations(), spaceSeparated: y2, roundingFunction: N2, totalLength: u2 });
          a2 = e3.value, $2 += e3.abbreviation, u2 && (g2 = e3.mantissaPrecision);
        }
        if (O2) {
          let e3 = (function({ value: e4, characteristicPrecision: t3 }) {
            let [r3, n3] = e4.toExponential().split("e"), i3 = +r3;
            return t3 ? (1 < t3 && (i3 *= Math.pow(10, t3 - 1), n3 = +n3 - (t3 - 1), n3 = n3 >= 0 ? `+${n3}` : n3), { value: i3, abbreviation: `e${n3}` }) : { value: i3, abbreviation: `e${n3}` };
          })({ value: a2, characteristicPrecision: s2 });
          a2 = e3.value, $2 = e3.abbreviation + $2;
        }
        let B2 = (function(e3, t3, r3, n3, i3, a3) {
          if (-1 === n3) return e3;
          let o3 = E(t3, n3, a3), [u3, s3 = ""] = o3.toString().split(".");
          if (s3.match(/^0+$/) && (r3 || i3)) return u3;
          let l3 = s3.match(/0+$/);
          return i3 && l3 ? `${u3}.${s3.toString().slice(0, l3.index)}` : o3.toString();
        })(a2.toString(), a2, h2, g2, d2, N2);
        return B2 = (function(e3, t3, r3, n3) {
          let i3 = e3, [a3, o3] = i3.toString().split(".");
          if (a3.match(/^-?0$/) && r3) return o3 ? `${a3.replace("0", "")}.${o3}` : a3.replace("0", "");
          const u3 = t3 < 0 && 0 === a3.indexOf("-");
          if (u3 && (a3 = a3.slice(1), i3 = i3.slice(1)), a3.length < n3) {
            let e4 = n3 - a3.length;
            for (let t4 = 0; t4 < e4; t4++) i3 = `0${i3}`;
          }
          return u3 && (i3 = `-${i3}`), i3.toString();
        })(B2, a2, l2, s2), B2 = (function(e3, t3, r3, n3, i3) {
          let a3 = n3.currentDelimiters(), o3 = a3.thousands;
          i3 = i3 || a3.decimal;
          let u3 = a3.thousandsSize || 3, s3 = e3.toString(), l3 = s3.split(".")[0], c3 = s3.split(".")[1];
          const f3 = t3 < 0 && 0 === l3.indexOf("-");
          if (r3) {
            f3 && (l3 = l3.slice(1));
            let e4 = (function(e5, t4) {
              let r4 = [], n4 = 0;
              for (let i4 = e5; i4 > 0; i4--) n4 === t4 && (r4.unshift(i4), n4 = 0), n4++;
              return r4;
            })(l3.length, u3);
            e4.forEach(((e5, t4) => {
              l3 = l3.slice(0, e5 + t4) + o3 + l3.slice(e5 + t4);
            })), f3 && (l3 = `-${l3}`);
          }
          return s3 = c3 ? l3 + i3 + c3 : l3, s3;
        })(B2, a2, m2, r2, n2), (p2 || O2) && (B2 = (function(e3, t3) {
          return e3 + t3;
        })(B2, $2)), (w2 || a2 < 0) && (B2 = (function(e3, t3, r3) {
          return 0 === t3 ? e3 : 0 == +e3 ? e3.replace("-", "") : t3 > 0 ? `+${e3}` : "sign" === r3 ? e3 : `(${e3.replace("-", "")})`;
        })(B2, a2, v2)), B2;
      }
      function _(e2, t2) {
        if (!e2) return t2;
        let r2 = Object.keys(e2);
        return 1 === r2.length && "output" === r2[0] ? t2 : e2;
      }
      const k = y;
      function L(e2, t2, r2) {
        let n2 = new k(e2._value), i2 = t2;
        return r2.isNumbro(t2) && (i2 = t2._value), i2 = new k(i2), e2._value = n2.minus(i2).toNumber(), e2;
      }
      const P = h(), T = c(), C = /* @__PURE__ */ ((e2) => ({ loadLanguagesInNode: (t2) => d(t2, e2) }))(q), j = l();
      let U = /* @__PURE__ */ ((e2) => ({ format: (...t2) => M(...t2, e2), getByteUnit: (...t2) => (function(e3) {
        let t3 = B.general;
        return D(e3._value, t3.suffixes, t3.scale).suffix;
      })(...t2, e2), getBinaryByteUnit: (...t2) => (function(e3) {
        let t3 = B.binary;
        return D(e3._value, t3.suffixes, t3.scale).suffix;
      })(...t2, e2), getDecimalByteUnit: (...t2) => (function(e3) {
        let t3 = B.decimal;
        return D(e3._value, t3.suffixes, t3.scale).suffix;
      })(...t2, e2), formatOrDefault: _ }))(q), R = /* @__PURE__ */ ((e2) => ({ add: (t2, r2) => (function(e3, t3, r3) {
        let n2 = new k(e3._value), i2 = t3;
        return r3.isNumbro(t3) && (i2 = t3._value), i2 = new k(i2), e3._value = n2.plus(i2).toNumber(), e3;
      })(t2, r2, e2), subtract: (t2, r2) => L(t2, r2, e2), multiply: (t2, r2) => (function(e3, t3, r3) {
        let n2 = new k(e3._value), i2 = t3;
        return r3.isNumbro(t3) && (i2 = t3._value), i2 = new k(i2), e3._value = n2.times(i2).toNumber(), e3;
      })(t2, r2, e2), divide: (t2, r2) => (function(e3, t3, r3) {
        let n2 = new k(e3._value), i2 = t3;
        return r3.isNumbro(t3) && (i2 = t3._value), i2 = new k(i2), e3._value = n2.dividedBy(i2).toNumber(), e3;
      })(t2, r2, e2), set: (t2, r2) => (function(e3, t3, r3) {
        let n2 = t3;
        return r3.isNumbro(t3) && (n2 = t3._value), e3._value = n2, e3;
      })(t2, r2, e2), difference: (t2, r2) => (function(e3, t3, r3) {
        let n2 = r3(e3._value);
        return L(n2, t3, r3), Math.abs(n2._value);
      })(t2, r2, e2), BigNumber: k }))(q);
      const I = g;
      class G {
        constructor(e2) {
          this._value = e2;
        }
        clone() {
          return q(this._value);
        }
        format(e2 = {}) {
          return U.format(this, e2);
        }
        formatCurrency(e2) {
          return "string" == typeof e2 && (e2 = I.parseFormat(e2)), (e2 = U.formatOrDefault(e2, P.currentCurrencyDefaultFormat())).output = "currency", U.format(this, e2);
        }
        formatTime(e2 = {}) {
          return e2.output = "time", U.format(this, e2);
        }
        binaryByteUnits() {
          return U.getBinaryByteUnit(this);
        }
        decimalByteUnits() {
          return U.getDecimalByteUnit(this);
        }
        byteUnits() {
          return U.getByteUnit(this);
        }
        difference(e2) {
          return R.difference(this, e2);
        }
        add(e2) {
          return R.add(this, e2);
        }
        subtract(e2) {
          return R.subtract(this, e2);
        }
        multiply(e2) {
          return R.multiply(this, e2);
        }
        divide(e2) {
          return R.divide(this, e2);
        }
        set(e2) {
          return R.set(this, V(e2));
        }
        value() {
          return this._value;
        }
        valueOf() {
          return this._value;
        }
      }
      function V(e2) {
        let t2 = e2;
        return q.isNumbro(e2) ? t2 = e2._value : "string" == typeof e2 ? t2 = q.unformat(e2) : isNaN(e2) && (t2 = NaN), t2;
      }
      function q(e2) {
        return new G(V(e2));
      }
      return q.version = "2.5.0", q.isNumbro = function(e2) {
        return e2 instanceof G;
      }, q.language = P.currentLanguage, q.registerLanguage = P.registerLanguage, q.setLanguage = P.setLanguage, q.languages = P.languages, q.languageData = P.languageData, q.zeroFormat = P.setZeroFormat, q.defaultFormat = P.currentDefaults, q.setDefaults = P.setDefaults, q.defaultCurrencyFormat = P.currentCurrencyDefaultFormat, q.validate = T.validate, q.loadLanguagesInNode = C.loadLanguagesInNode, q.unformat = j.unformat, q.BigNumber = R.BigNumber, u(q);
    }));
  }
});

// node_modules/@splunk/visualization-encoding/utils/dsl.js
var require_dsl = __commonJS({
  "node_modules/@splunk/visualization-encoding/utils/dsl.js"(exports2, module2) {
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var __create = Object.create;
    var __defProp = Object.defineProperty;
    var __defProps = Object.defineProperties;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __getOwnPropSymbols = Object.getOwnPropertySymbols;
    var __getProtoOf = Object.getPrototypeOf;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __propIsEnum = Object.prototype.propertyIsEnumerable;
    var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
    var __spreadValues = (a, b) => {
      for (var prop in b || (b = {}))
        if (__hasOwnProp.call(b, prop))
          __defNormalProp(a, prop, b[prop]);
      if (__getOwnPropSymbols)
        for (var prop of __getOwnPropSymbols(b)) {
          if (__propIsEnum.call(b, prop))
            __defNormalProp(a, prop, b[prop]);
        }
      return a;
    };
    var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
    var __esm2 = (fn, res) => function __init() {
      return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
    };
    var __commonJS2 = (cb, mod) => function __require2() {
      return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
    };
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
    var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
      // If the importer is in node compatibility mode or this is not an ESM
      // file that has been converted to a CommonJS file using a Babel-
      // compatible transform (i.e. "__esModule" has not been set), then set
      // "default" to the CommonJS "module.exports" for node compatibility.
      isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
      mod
    ));
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var init_define_global = __esm2({
      "<define:global>"() {
      }
    });
    var require_vizparser = __commonJS2({
      "src/nearley/generated/vizparser.js"(exports3, module22) {
        init_define_global();
        (function() {
          function arrpush(d) {
            return d[0].concat([d[1]]);
          }
          function id(x) {
            return x[0];
          }
          function parseNull() {
            return null;
          }
          function parseString(d) {
            return { type: "string", v: d[0] };
          }
          function parseJoin(d) {
            return d[1].join("");
          }
          var grammar2 = {
            Lexer: void 0,
            ParserRules: [
              { name: "_$ebnf$1", symbols: [] },
              {
                name: "_$ebnf$1",
                symbols: ["_$ebnf$1", "wschar"],
                postprocess: arrpush
              },
              {
                name: "_",
                symbols: ["_$ebnf$1"],
                postprocess: parseNull
              },
              { name: "__$ebnf$1", symbols: ["wschar"] },
              {
                name: "__$ebnf$1",
                symbols: ["__$ebnf$1", "wschar"],
                postprocess: arrpush
              },
              {
                name: "__",
                symbols: ["__$ebnf$1"],
                postprocess: parseNull
              },
              { name: "wschar", symbols: [/[ \t\n\v\f]/], postprocess: id },
              { name: "dqstring$ebnf$1", symbols: [] },
              {
                name: "dqstring$ebnf$1",
                symbols: ["dqstring$ebnf$1", "dstrchar"],
                postprocess: arrpush
              },
              {
                name: "dqstring",
                symbols: [{ literal: '"' }, "dqstring$ebnf$1", { literal: '"' }],
                postprocess: parseJoin
              },
              { name: "sqstring$ebnf$1", symbols: [] },
              {
                name: "sqstring$ebnf$1",
                symbols: ["sqstring$ebnf$1", "sstrchar"],
                postprocess: arrpush
              },
              {
                name: "sqstring",
                symbols: [{ literal: "'" }, "sqstring$ebnf$1", { literal: "'" }],
                postprocess: parseJoin
              },
              { name: "btstring$ebnf$1", symbols: [] },
              {
                name: "btstring$ebnf$1",
                symbols: ["btstring$ebnf$1", /[^`]/],
                postprocess: arrpush
              },
              {
                name: "btstring",
                symbols: [{ literal: "`" }, "btstring$ebnf$1", { literal: "`" }],
                postprocess: parseJoin
              },
              { name: "dstrchar", symbols: [/[^\\"\n]/], postprocess: id },
              {
                name: "dstrchar",
                symbols: [{ literal: "\\" }, "strescape"],
                postprocess: function(d) {
                  return JSON.parse('"' + d.join("") + '"');
                }
              },
              { name: "sstrchar", symbols: [/[^\\'\n]/], postprocess: id },
              {
                name: "sstrchar",
                symbols: [{ literal: "\\" }, "strescape"],
                postprocess: function(d) {
                  return JSON.parse('"' + d.join("") + '"');
                }
              },
              {
                name: "sstrchar$string$1",
                symbols: [{ literal: "\\" }, { literal: "'" }],
                postprocess: function joiner(d) {
                  return d.join("");
                }
              },
              {
                name: "sstrchar",
                symbols: ["sstrchar$string$1"],
                postprocess: function(d) {
                  return "'";
                }
              },
              { name: "strescape", symbols: [/["\\/bfnrt]/], postprocess: id },
              {
                name: "strescape",
                symbols: [{ literal: "u" }, /[a-fA-F0-9]/, /[a-fA-F0-9]/, /[a-fA-F0-9]/, /[a-fA-F0-9]/],
                postprocess: function(d) {
                  return d.join("");
                }
              },
              { name: "unsigned_int$ebnf$1", symbols: [/[0-9]/] },
              {
                name: "unsigned_int$ebnf$1",
                symbols: ["unsigned_int$ebnf$1", /[0-9]/],
                postprocess: arrpush
              },
              {
                name: "unsigned_int",
                symbols: ["unsigned_int$ebnf$1"],
                postprocess: function(d) {
                  return parseInt(d[0].join(""));
                }
              },
              { name: "int$ebnf$1$subexpression$1", symbols: [{ literal: "-" }] },
              { name: "int$ebnf$1$subexpression$1", symbols: [{ literal: "+" }] },
              { name: "int$ebnf$1", symbols: ["int$ebnf$1$subexpression$1"], postprocess: id },
              {
                name: "int$ebnf$1",
                symbols: [],
                postprocess: parseNull
              },
              { name: "int$ebnf$2", symbols: [/[0-9]/] },
              {
                name: "int$ebnf$2",
                symbols: ["int$ebnf$2", /[0-9]/],
                postprocess: arrpush
              },
              {
                name: "int",
                symbols: ["int$ebnf$1", "int$ebnf$2"],
                postprocess: function(d) {
                  if (d[0]) {
                    return parseInt(d[0][0] + d[1].join(""));
                  } else {
                    return parseInt(d[1].join(""));
                  }
                }
              },
              { name: "unsigned_decimal$ebnf$1", symbols: [/[0-9]/] },
              {
                name: "unsigned_decimal$ebnf$1",
                symbols: ["unsigned_decimal$ebnf$1", /[0-9]/],
                postprocess: arrpush
              },
              { name: "unsigned_decimal$ebnf$2$subexpression$1$ebnf$1", symbols: [/[0-9]/] },
              {
                name: "unsigned_decimal$ebnf$2$subexpression$1$ebnf$1",
                symbols: ["unsigned_decimal$ebnf$2$subexpression$1$ebnf$1", /[0-9]/],
                postprocess: arrpush
              },
              {
                name: "unsigned_decimal$ebnf$2$subexpression$1",
                symbols: [{ literal: "." }, "unsigned_decimal$ebnf$2$subexpression$1$ebnf$1"]
              },
              {
                name: "unsigned_decimal$ebnf$2",
                symbols: ["unsigned_decimal$ebnf$2$subexpression$1"],
                postprocess: id
              },
              {
                name: "unsigned_decimal$ebnf$2",
                symbols: [],
                postprocess: parseNull
              },
              {
                name: "unsigned_decimal",
                symbols: ["unsigned_decimal$ebnf$1", "unsigned_decimal$ebnf$2"],
                postprocess: function(d) {
                  return parseFloat(d[0].join("") + (d[1] ? "." + d[1][1].join("") : ""));
                }
              },
              { name: "decimal$ebnf$1", symbols: [{ literal: "-" }], postprocess: id },
              {
                name: "decimal$ebnf$1",
                symbols: [],
                postprocess: parseNull
              },
              { name: "decimal$ebnf$2", symbols: [/[0-9]/] },
              {
                name: "decimal$ebnf$2",
                symbols: ["decimal$ebnf$2", /[0-9]/],
                postprocess: arrpush
              },
              { name: "decimal$ebnf$3$subexpression$1$ebnf$1", symbols: [/[0-9]/] },
              {
                name: "decimal$ebnf$3$subexpression$1$ebnf$1",
                symbols: ["decimal$ebnf$3$subexpression$1$ebnf$1", /[0-9]/],
                postprocess: arrpush
              },
              {
                name: "decimal$ebnf$3$subexpression$1",
                symbols: [{ literal: "." }, "decimal$ebnf$3$subexpression$1$ebnf$1"]
              },
              { name: "decimal$ebnf$3", symbols: ["decimal$ebnf$3$subexpression$1"], postprocess: id },
              {
                name: "decimal$ebnf$3",
                symbols: [],
                postprocess: parseNull
              },
              {
                name: "decimal",
                symbols: ["decimal$ebnf$1", "decimal$ebnf$2", "decimal$ebnf$3"],
                postprocess: function(d) {
                  return parseFloat((d[0] || "") + d[1].join("") + (d[2] ? "." + d[2][1].join("") : ""));
                }
              },
              {
                name: "percentage",
                symbols: ["decimal", { literal: "%" }],
                postprocess: function(d) {
                  return d[0] / 100;
                }
              },
              { name: "jsonfloat$ebnf$1", symbols: [{ literal: "-" }], postprocess: id },
              {
                name: "jsonfloat$ebnf$1",
                symbols: [],
                postprocess: parseNull
              },
              { name: "jsonfloat$ebnf$2", symbols: [/[0-9]/] },
              {
                name: "jsonfloat$ebnf$2",
                symbols: ["jsonfloat$ebnf$2", /[0-9]/],
                postprocess: arrpush
              },
              { name: "jsonfloat$ebnf$3$subexpression$1$ebnf$1", symbols: [/[0-9]/] },
              {
                name: "jsonfloat$ebnf$3$subexpression$1$ebnf$1",
                symbols: ["jsonfloat$ebnf$3$subexpression$1$ebnf$1", /[0-9]/],
                postprocess: arrpush
              },
              {
                name: "jsonfloat$ebnf$3$subexpression$1",
                symbols: [{ literal: "." }, "jsonfloat$ebnf$3$subexpression$1$ebnf$1"]
              },
              { name: "jsonfloat$ebnf$3", symbols: ["jsonfloat$ebnf$3$subexpression$1"], postprocess: id },
              {
                name: "jsonfloat$ebnf$3",
                symbols: [],
                postprocess: parseNull
              },
              { name: "jsonfloat$ebnf$4$subexpression$1$ebnf$1", symbols: [/[+-]/], postprocess: id },
              {
                name: "jsonfloat$ebnf$4$subexpression$1$ebnf$1",
                symbols: [],
                postprocess: parseNull
              },
              { name: "jsonfloat$ebnf$4$subexpression$1$ebnf$2", symbols: [/[0-9]/] },
              {
                name: "jsonfloat$ebnf$4$subexpression$1$ebnf$2",
                symbols: ["jsonfloat$ebnf$4$subexpression$1$ebnf$2", /[0-9]/],
                postprocess: arrpush
              },
              {
                name: "jsonfloat$ebnf$4$subexpression$1",
                symbols: [
                  /[eE]/,
                  "jsonfloat$ebnf$4$subexpression$1$ebnf$1",
                  "jsonfloat$ebnf$4$subexpression$1$ebnf$2"
                ]
              },
              { name: "jsonfloat$ebnf$4", symbols: ["jsonfloat$ebnf$4$subexpression$1"], postprocess: id },
              {
                name: "jsonfloat$ebnf$4",
                symbols: [],
                postprocess: parseNull
              },
              {
                name: "jsonfloat",
                symbols: ["jsonfloat$ebnf$1", "jsonfloat$ebnf$2", "jsonfloat$ebnf$3", "jsonfloat$ebnf$4"],
                postprocess: function(d) {
                  return parseFloat(
                    (d[0] || "") + d[1].join("") + (d[2] ? "." + d[2][1].join("") : "") + (d[3] ? "e" + (d[3][1] || "+") + d[3][2].join("") : "")
                  );
                }
              },
              { name: "Pipeline$ebnf$1", symbols: [] },
              { name: "Pipeline$ebnf$1$subexpression$1", symbols: [{ literal: "|" }, "Expr"] },
              {
                name: "Pipeline$ebnf$1",
                symbols: ["Pipeline$ebnf$1", "Pipeline$ebnf$1$subexpression$1"],
                postprocess: arrpush
              },
              {
                name: "Pipeline",
                symbols: ["Expr", "Pipeline$ebnf$1"],
                postprocess: (d) => {
                  return [d[0], ...d[1].map((e) => e[1])];
                }
              },
              { name: "Expr", symbols: ["_", "Identifier", "_"], postprocess: (d) => d[1] },
              { name: "Expr", symbols: ["_", "Method", "_"], postprocess: (d) => d[1] },
              { name: "Expr", symbols: ["_", "Literal", "_"], postprocess: (d) => d[1] },
              { name: "Method$ebnf$1", symbols: ["Arg"], postprocess: id },
              {
                name: "Method$ebnf$1",
                symbols: [],
                postprocess: parseNull
              },
              { name: "Method$ebnf$2", symbols: [] },
              { name: "Method$ebnf$2$subexpression$1", symbols: ["_", { literal: "," }, "_", "Arg"] },
              {
                name: "Method$ebnf$2",
                symbols: ["Method$ebnf$2", "Method$ebnf$2$subexpression$1"],
                postprocess: arrpush
              },
              {
                name: "Method",
                symbols: [
                  "Identifier",
                  { literal: "(" },
                  "_",
                  "Method$ebnf$1",
                  "Method$ebnf$2",
                  "_",
                  { literal: ")" }
                ],
                postprocess: (d) => {
                  let arg0 = d[3];
                  let otherArgs = d[4];
                  let args = [];
                  arg0 && args.push(arg0);
                  if (otherArgs) {
                    args = args.concat(otherArgs.map((e) => e[3]));
                  }
                  let r = { type: "method", name: d[0].v, args };
                  return r;
                }
              },
              { name: "Arg", symbols: ["Identifier"], postprocess: (d) => d[0] },
              { name: "Arg", symbols: ["Literal"], postprocess: (d) => d[0] },
              { name: "Identifier$subexpression$1", symbols: ["Letter"] },
              { name: "Identifier$subexpression$1", symbols: ["Star"] },
              { name: "Identifier$ebnf$1", symbols: [] },
              { name: "Identifier$ebnf$1$subexpression$1", symbols: ["Letter"] },
              { name: "Identifier$ebnf$1$subexpression$1", symbols: ["Digit"] },
              { name: "Identifier$ebnf$1$subexpression$1", symbols: ["Star"] },
              {
                name: "Identifier$ebnf$1",
                symbols: ["Identifier$ebnf$1", "Identifier$ebnf$1$subexpression$1"],
                postprocess: arrpush
              },
              {
                name: "Identifier",
                symbols: ["Identifier$subexpression$1", "Identifier$ebnf$1"],
                postprocess: (d) => {
                  return { type: "identifier", v: d[0] + d[1].join("") };
                }
              },
              { name: "Identifier$subexpression$2", symbols: ["Letter"] },
              { name: "Identifier$subexpression$2", symbols: ["Star"] },
              { name: "Identifier$ebnf$2", symbols: [] },
              { name: "Identifier$ebnf$2$subexpression$1", symbols: ["Letter"] },
              { name: "Identifier$ebnf$2$subexpression$1", symbols: ["Digit"] },
              { name: "Identifier$ebnf$2$subexpression$1", symbols: ["Star"] },
              {
                name: "Identifier$ebnf$2",
                symbols: ["Identifier$ebnf$2", "Identifier$ebnf$2$subexpression$1"],
                postprocess: arrpush
              },
              { name: "Identifier$ebnf$3$subexpression$1$subexpression$1", symbols: ["Letter"] },
              { name: "Identifier$ebnf$3$subexpression$1$subexpression$1", symbols: ["Star"] },
              { name: "Identifier$ebnf$3$subexpression$1$ebnf$1", symbols: [] },
              { name: "Identifier$ebnf$3$subexpression$1$ebnf$1$subexpression$1", symbols: ["Letter"] },
              { name: "Identifier$ebnf$3$subexpression$1$ebnf$1$subexpression$1", symbols: ["Digit"] },
              { name: "Identifier$ebnf$3$subexpression$1$ebnf$1$subexpression$1", symbols: ["Star"] },
              {
                name: "Identifier$ebnf$3$subexpression$1$ebnf$1",
                symbols: [
                  "Identifier$ebnf$3$subexpression$1$ebnf$1",
                  "Identifier$ebnf$3$subexpression$1$ebnf$1$subexpression$1"
                ],
                postprocess: arrpush
              },
              {
                name: "Identifier$ebnf$3$subexpression$1",
                symbols: [
                  "Dot",
                  "Identifier$ebnf$3$subexpression$1$subexpression$1",
                  "Identifier$ebnf$3$subexpression$1$ebnf$1"
                ]
              },
              { name: "Identifier$ebnf$3", symbols: ["Identifier$ebnf$3$subexpression$1"] },
              { name: "Identifier$ebnf$3$subexpression$2$subexpression$1", symbols: ["Letter"] },
              { name: "Identifier$ebnf$3$subexpression$2$subexpression$1", symbols: ["Star"] },
              { name: "Identifier$ebnf$3$subexpression$2$ebnf$1", symbols: [] },
              { name: "Identifier$ebnf$3$subexpression$2$ebnf$1$subexpression$1", symbols: ["Letter"] },
              { name: "Identifier$ebnf$3$subexpression$2$ebnf$1$subexpression$1", symbols: ["Digit"] },
              { name: "Identifier$ebnf$3$subexpression$2$ebnf$1$subexpression$1", symbols: ["Star"] },
              {
                name: "Identifier$ebnf$3$subexpression$2$ebnf$1",
                symbols: [
                  "Identifier$ebnf$3$subexpression$2$ebnf$1",
                  "Identifier$ebnf$3$subexpression$2$ebnf$1$subexpression$1"
                ],
                postprocess: arrpush
              },
              {
                name: "Identifier$ebnf$3$subexpression$2",
                symbols: [
                  "Dot",
                  "Identifier$ebnf$3$subexpression$2$subexpression$1",
                  "Identifier$ebnf$3$subexpression$2$ebnf$1"
                ]
              },
              {
                name: "Identifier$ebnf$3",
                symbols: ["Identifier$ebnf$3", "Identifier$ebnf$3$subexpression$2"],
                postprocess: arrpush
              },
              {
                name: "Identifier",
                symbols: ["Identifier$subexpression$2", "Identifier$ebnf$2", "Identifier$ebnf$3"],
                postprocess: (d) => {
                  function flat(input, depth = 1, stack = []) {
                    for (let item of input) {
                      if (item instanceof Array && depth > 0) {
                        flat(item, depth - 1, stack);
                      } else {
                        stack.push(item);
                      }
                    }
                    return stack;
                  }
                  const r = flat(d, Infinity);
                  return { type: "identifier", v: r.join("") };
                }
              },
              {
                name: "Literal",
                symbols: ["jsonfloat"],
                postprocess: (d) => {
                  return { type: "number", v: d[0] };
                }
              },
              {
                name: "Literal",
                symbols: ["dqstring"],
                postprocess: parseString
              },
              {
                name: "Literal",
                symbols: ["sqstring"],
                postprocess: parseString
              },
              {
                name: "Literal",
                symbols: ["btstring"],
                postprocess: parseString
              },
              { name: "Letter", symbols: [/[a-zA-Z_]/], postprocess: (d) => d[0] },
              { name: "Digit", symbols: [/[0-9]/], postprocess: (d) => d[0] },
              { name: "Dot", symbols: [/[\.]/], postprocess: (d) => d[0] },
              { name: "Star", symbols: [{ literal: "*" }] }
            ],
            ParserStart: "Pipeline"
          };
          if (typeof module22 !== "undefined" && typeof module22.exports !== "undefined") {
            module22.exports = grammar2;
          } else {
            window.grammar = grammar2;
          }
        })();
      }
    });
    var dsl_exports = {};
    __export2(dsl_exports, {
      buildDSLFromDataSelectorAndFormatter: () => buildDSLFromDataSelectorAndFormatter,
      getDataSelectorsFromDSL: () => getDataSelectorsFromDSL,
      getDataTypesFromDSL: () => getDataTypesFromDSL,
      getFieldsFromDSL: () => getFieldsFromDSL,
      getFormattersFromDSL: () => getFormattersFromDSL,
      getLastFormatterFromDSL: () => getLastFormatterFromDSL
    });
    module2.exports = __toCommonJS2(dsl_exports);
    init_define_global();
    var lodash_exports = {};
    __export2(lodash_exports, {
      default: () => lodash_default
    });
    init_define_global();
    var defaultImport = __toESM2(require_lodash());
    __reExport(lodash_exports, require_lodash());
    var lodash_default = "default" in defaultImport ? defaultImport.default : defaultImport;
    init_define_global();
    init_define_global();
    var chroma_js_exports = {};
    __export2(chroma_js_exports, {
      default: () => chroma_js_default
    });
    init_define_global();
    var defaultImport2 = __toESM2(require_chroma());
    __reExport(chroma_js_exports, require_chroma());
    var chroma_js_default = "default" in defaultImport2 ? defaultImport2.default : defaultImport2;
    init_define_global();
    init_define_global();
    init_define_global();
    init_define_global();
    init_define_global();
    var moment_exports = {};
    __export2(moment_exports, {
      default: () => moment_default
    });
    init_define_global();
    var defaultImport3 = __toESM2(require_moment());
    __reExport(moment_exports, require_moment());
    var moment_default = "default" in defaultImport3 ? defaultImport3.default : defaultImport3;
    init_define_global();
    var visualization_schemas_exports = {};
    __export2(visualization_schemas_exports, {
      default: () => visualization_schemas_default
    });
    init_define_global();
    var defaultImport4 = __toESM2(require_cjs());
    __reExport(visualization_schemas_exports, require_cjs());
    var visualization_schemas_default = "default" in defaultImport4 ? defaultImport4.default : defaultImport4;
    init_define_global();
    var namedColors_default = [
      "transparent",
      "aliceblue",
      "antiquewhite",
      "aqua",
      "aquamarine",
      "azure",
      "beige",
      "bisque",
      "black",
      "blanchedalmond",
      "blue",
      "blueviolet",
      "brown",
      "burlywood",
      "cadetblue",
      "chartreuse",
      "chocolate",
      "coral",
      "cornflowerblue",
      "cornsilk",
      "crimson",
      "cyan",
      "darkblue",
      "darkcyan",
      "darkgoldenrod",
      "darkgray",
      "darkgreen",
      "darkgrey",
      "darkkhaki",
      "darkmagenta",
      "darkolivegreen",
      "darkorange",
      "darkorchid",
      "darkred",
      "darksalmon",
      "darkseagreen",
      "darkslateblue",
      "darkslategray",
      "darkslategrey",
      "darkturquoise",
      "darkviolet",
      "deeppink",
      "deepskyblue",
      "dimgray",
      "dimgrey",
      "dodgerblue",
      "firebrick",
      "floralwhite",
      "forestgreen",
      "fuchsia",
      "gainsboro",
      "ghostwhite",
      "gold",
      "goldenrod",
      "gray",
      "green",
      "greenyellow",
      "grey",
      "honeydew",
      "hotpink",
      "indianred",
      "indigo",
      "ivory",
      "khaki",
      "lavender",
      "lavenderblush",
      "lawngreen",
      "lemonchiffon",
      "lightblue",
      "lightcoral",
      "lightcyan",
      "lightgoldenrodyellow",
      "lightgray",
      "lightgreen",
      "lightgrey",
      "lightpink",
      "lightsalmon",
      "lightseagreen",
      "lightskyblue",
      "lightslategray",
      "lightslategrey",
      "lightsteelblue",
      "lightyellow",
      "lime",
      "limegreen",
      "linen",
      "magenta",
      "maroon",
      "mediumaquamarine",
      "mediumblue",
      "mediumorchid",
      "mediumpurple",
      "mediumseagreen",
      "mediumslateblue",
      "mediumspringgreen",
      "mediumturquoise",
      "mediumvioletred",
      "midnightblue",
      "mintcream",
      "mistyrose",
      "moccasin",
      "navajowhite",
      "navy",
      "oldlace",
      "olive",
      "olivedrab",
      "orange",
      "orangered",
      "orchid",
      "palegoldenrod",
      "palegreen",
      "paleturquoise",
      "palevioletred",
      "papayawhip",
      "peachpuff",
      "peru",
      "pink",
      "plum",
      "powderblue",
      "purple",
      "rebeccapurple",
      "red",
      "rosybrown",
      "royalblue",
      "saddlebrown",
      "salmon",
      "sandybrown",
      "seagreen",
      "seashell",
      "sienna",
      "silver",
      "skyblue",
      "slateblue",
      "slategray",
      "slategrey",
      "snow",
      "springgreen",
      "steelblue",
      "tan",
      "teal",
      "thistle",
      "tomato",
      "turquoise",
      "violet",
      "wheat",
      "white",
      "whitesmoke",
      "yellow",
      "yellowgreen"
    ];
    function isColor(color = "") {
      if (typeof color !== "string") {
        return false;
      }
      if (color.startsWith("#")) {
        color = color.substring(1);
        return [3, 4, 6, 8].indexOf(color.length) > -1 && !Number.isNaN(parseInt(color, 16));
      }
      const trimmedColor = color.trim();
      if (visualization_schemas_exports.rgbColorPattern.test(trimmedColor) || visualization_schemas_exports.rgbaColorPattern.test(trimmedColor)) {
        return true;
      }
      return namedColors_default.includes(color.toLowerCase());
    }
    var supportedDateFormats = [
      "YYYY-MM-DD",
      // HTML5 date
      moment_default.ISO_8601,
      "YYYY-MM-DDTHH:mm",
      // HTML5 date local
      "YYYY-MM-DDTHH:mm:ss.SSS",
      // HTML5 date local milliseconds
      "YYYY-MM-DDTHH:mm:ss",
      // HTML5 date local seconds
      "YYYY-MM-DD HH:MM",
      "YYYY-MM-DD HH:MM:SS",
      "YYYY-MM-DD HH:MM:SS.SSS"
    ];
    var typeOrder = [
      "geojson",
      "sparkline",
      "array",
      "string",
      "color",
      "number",
      "time",
      "null",
      "unknown"
    ];
    function isNumber(dataPoint) {
      return dataPoint !== null && !(0, lodash_exports.isBoolean)(dataPoint) && dataPoint !== "" && (0, lodash_exports.isFinite)(+dataPoint) && (0, lodash_exports.isNumber)(+dataPoint);
    }
    function isGeoJsonObject(dataPoint) {
      if (!dataPoint) return false;
      let parsedDataPoint;
      try {
        parsedDataPoint = (0, lodash_exports.isObject)(dataPoint) ? dataPoint : JSON.parse(dataPoint);
      } catch (e) {
        return false;
      }
      if (parsedDataPoint == null) {
        return false;
      }
      return Object.prototype.hasOwnProperty.call(parsedDataPoint, "coordinates") && parsedDataPoint.coordinates != null && Array.isArray(parsedDataPoint.coordinates) && Object.prototype.hasOwnProperty.call(parsedDataPoint, "type") && parsedDataPoint.type === "MultiPolygon";
    }
    function isTime(dataPoint) {
      if (!dataPoint) {
        return false;
      }
      return typeof dataPoint === "string" ? moment_default(dataPoint, supportedDateFormats, true).isValid() : moment_default(dataPoint).isValid();
    }
    function isString(dataPoint) {
      return typeof dataPoint === "string" && dataPoint.length > 0;
    }
    var getDataTypeForPoint = (dataPoint, metaData) => {
      if (canInferTypeFromMeta(metaData)) {
        return getDataTypeForMeta(metaData);
      }
      return memoizedGetDataTypeForValue(dataPoint);
    };
    var getDataTypeForValue = (dataPoint) => {
      if (Array.isArray(dataPoint)) {
        if (dataPoint.length > 1 && dataPoint[0] === "##__SPARKLINE__##") {
          return "sparkline";
        }
        return "array";
      }
      if (isGeoJsonObject(dataPoint)) {
        return "geojson";
      }
      if ((0, lodash_exports.isObject)(dataPoint)) {
        return "unknown";
      }
      if (isNumber(dataPoint)) {
        return "number";
      }
      if (isString(dataPoint) && isColor(dataPoint)) {
        return "color";
      }
      if (isTime(dataPoint)) {
        return "time";
      }
      if (isString(dataPoint)) {
        return "string";
      }
      if (dataPoint === null) {
        return "null";
      }
      return "unknown";
    };
    var memoizedGetDataTypeForValue = (0, lodash_exports.memoize)(getDataTypeForValue);
    var splTypesToDSLDataTypes = {
      str: "string",
      num: "number"
    };
    var canInferTypeFromMeta = (metaData = {}) => {
      const { name, type = "" } = metaData;
      return splTypesToDSLDataTypes[type] !== void 0 || name === "_time";
    };
    var getDataTypeForMeta = (metaData = {}) => {
      const { name, type } = metaData;
      if (name === "_time") {
        return "time";
      }
      const typeMatch = splTypesToDSLDataTypes[type];
      if (typeMatch !== void 0) {
        return typeMatch;
      }
      return "unknown";
    };
    var applyTypePrioritization = (typeMatches) => {
      const typesWithCount = Object.keys(typeMatches).filter(
        (key) => typeMatches[key] > 0
      );
      if (typesWithCount.length === 0) {
        return "unknown";
      }
      if (typesWithCount.length === 1) {
        return typesWithCount[0];
      }
      for (let i = 0; i < typeOrder.length; i += 1) {
        const key = typeOrder[i];
        if (typesWithCount.find((k) => k === key)) {
          return key;
        }
      }
      return "unknown";
    };
    var inferDataTypeFromDataPoints = (dataPoints) => {
      if (!dataPoints) {
        return "unknown";
      }
      const typeMatches = {
        time: 0,
        number: 0,
        string: 0,
        color: 0,
        unknown: 0,
        array: 0,
        sparkline: 0,
        null: 0,
        geojson: 0
      };
      dataPoints.forEach((point) => {
        typeMatches[point.getType()] += 1;
      });
      return applyTypePrioritization(typeMatches);
    };
    init_define_global();
    var setDefaultValue = (defaultValue) => {
      if (isNumber(defaultValue)) {
        return defaultValue;
      }
      return defaultValue || "";
    };
    var timeToSplunkMoment = (time) => {
      if (moment_default.getDefaultSplunkTimezone()) {
        return moment_default.newSplunkTime({ time });
      }
      return moment_default(time);
    };
    var formatTimeWithTimezoneCorrection = (time, format = moment_default.defaultFormat) => {
      const utcOffset = moment_default.parseZone(time).utcOffset();
      const momentTime = timeToSplunkMoment(time).utcOffset(utcOffset);
      return momentTime.format(format);
    };
    var TypeSafeValue = class _TypeSafeValue {
      // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
      constructor(type, value, coercedValue) {
        this.isTypeSafe = true;
        this.type = type;
        this.value = value;
        this.coercedValue = coercedValue;
      }
      /**
       * returns a TypeSafeValue, either by converting the non TypeSafeValue to
       * a TypeSafeValue, or by simply returning the passed-in TypeSafeValue
       * @param {TypedValue<T>} typedValue
       * @returns {TypeSafeValue<T>}
       */
      static from(typedValue) {
        if (typedValue.isTypeSafe) {
          return typedValue;
        }
        const { value, type } = typedValue;
        const [coercedValue] = _TypeSafeValue.coerceValue(typedValue);
        return new _TypeSafeValue(type, value, coercedValue);
      }
      /**
       * Creates a TypeSafeValue from a raw value
       * @param value
       * @returns {TypeSafeValue<DataType>}
       */
      static fromRaw(value) {
        const type = getDataTypeForPoint(value);
        return new _TypeSafeValue(type, value, value);
      }
      /**
       * attempts to coerce the provided value to the provided type. Returns tuple
       * of the coerced value and a boolean telling if the coercion was clean (true)
       * or if the coercion was likely produced an unusable result, such as NaN for
       * a number, or '' for a color.
       * @param {TypedValue<T>} typedValue
       * @returns {[any]}
       */
      static coerceValue(typedValue) {
        const { type, value } = typedValue;
        let coercedValue = null;
        try {
          switch (type) {
            case "number": {
              coercedValue = Number(value);
              break;
            }
            case "time": {
              const isOk = isTime(value);
              if (value instanceof Date) {
                coercedValue = value;
              } else if (!isOk) {
                coercedValue = "Invalid Date";
              } else {
                const timeString = formatTimeWithTimezoneCorrection(value);
                coercedValue = timeString;
              }
              break;
            }
            case "string": {
              coercedValue = value.toString();
              break;
            }
            case "color": {
              coercedValue = value;
              break;
            }
            case "sparkline": {
              coercedValue = value;
              break;
            }
            case "array": {
              coercedValue = value;
              break;
            }
            case "null": {
              coercedValue = value;
              break;
            }
            case "geojson": {
              coercedValue = value;
              break;
            }
            default: {
              coercedValue = "";
            }
          }
        } catch (e) {
        }
        return [coercedValue];
      }
      toRawCoercedValue() {
        switch (this.type) {
          case "time":
          case "sparkline":
          case "array":
          case "number":
          case "string":
          case "color":
          case "geojson":
          default:
            return this.coercedValue;
        }
      }
      toRawValue() {
        switch (this.type) {
          case "time":
          case "sparkline":
          case "array":
          case "number":
          case "string":
          case "color":
          case "geojson":
          default:
            return this.value;
        }
      }
    };
    var _DataPoint = class _DataPoint2 {
      static isDataPoint(o) {
        return o instanceof _DataPoint2;
      }
      static fromRaw(value) {
        return new _DataPoint2("", TypeSafeValue.fromRaw(value));
      }
      /**
       *
       * @param {string} field data field
       * @param {object} value data value + it's type (number, string, time, color, geojson)
       */
      constructor(field, value) {
        this.field = field;
        this.setValue(value);
        _DataPoint2.count += 1;
      }
      getValue() {
        return this.value;
      }
      /**
       * Sets the data point's value to a static TypedValue.
       * @param {TypedValue} v
       */
      setValue(v) {
        this.value = TypeSafeValue.from(v);
      }
      /**
       * Get only value of the data point.
       * @returns {string|number|GeoJsonDataType|null}
       */
      getRawValue() {
        return this.value.toRawValue();
      }
      /**
       * Get only the coerced value of the data point.
       * @returns {string|number|null}
       */
      getCoercedValue() {
        return this.value.toRawCoercedValue();
      }
      /**
       * Returns the data field of the point.
       * @public
       * @returns {DataPoint<'string'>}
       */
      getField() {
        return _DataPoint2.fromRaw(this.field);
      }
      /**
       * Returns the data type of the point.
       * @public
       * @returns {string}
       */
      getType() {
        return this.value.type;
      }
    };
    _DataPoint.count = 0;
    var DataPoint = _DataPoint;
    init_define_global();
    var DataSeries = class _DataSeries {
      /**
       *
       * @param {array} points list of data points
       * @param {string} type user explicitly sets the data type
       */
      // eslint-disable-next-line
      constructor(points = [], type, field) {
        this.internalPoints = [];
        this.internalPoints = points;
        if (points.length > 0) {
          this.field = points[0].field;
        }
        if (field) {
          this.field = field;
        }
        this.type = type;
      }
      get points() {
        return this.internalPoints;
      }
      static isDataSeries(o) {
        return o instanceof _DataSeries;
      }
      static fromRaw(pts) {
        return new _DataSeries(pts.map((p) => DataPoint.fromRaw(p)));
      }
      /**
       * Return first dataPoint in series.
       * @public
       * @returns {DataPoint}
       */
      firstPoint() {
        return this.points[0];
      }
      /**
       * Return last dataPoint in series.
       * @public
       * @returns {DataPoint}
       */
      lastPoint() {
        return this.points.slice(-1)[0];
      }
      /**
       * Finds dataPoint(s) in DataSeries by index(es).
       * @public
       * @param {...number} indexes
       * @returns {DataSeries}
       */
      pointsByIndexes(...indexes) {
        const indexedPoints = [];
        indexes.forEach((index) => {
          const dp = this.points[index];
          if (dp != null) {
            indexedPoints.push(dp);
          }
        });
        return new _DataSeries(indexedPoints);
      }
      /**
       * Finds and returns the individual dataPoint at the given index.
       * @public
       * @param {number} index
       * @returns {DataPoint}
       */
      pointByIndex(indexIn) {
        let index = indexIn;
        if (index < 0) {
          index = this.points.length + index;
        }
        if (index < 0 || index >= this.points.length) {
          return null;
        }
        const dp = this.points[index];
        const { field } = dp;
        const { type, value } = dp.getValue();
        return new DataPoint(field, { type, value });
      }
      /**
       * Finds the delta between the last point and point at the given index.
       * A negative index can be used, indicating an offset from the end of the sequence.
       * @public
       * @param {number} index
       * @returns {DataPoint}
       */
      delta(index) {
        const dp1 = this.lastPoint();
        if (dp1 === void 0) {
          return void 0;
        }
        const { field } = dp1;
        const { type, value: val1 } = dp1.getValue();
        if (type !== "number") {
          console.warn(`DSL delta cannot be computed for non-numerical data series of type ${type}`);
        }
        let dp2 = null;
        let delta;
        if (index >= 0) {
          dp2 = this.points[index];
        } else {
          dp2 = this.points.slice().reverse()[Math.abs(index) - 1];
        }
        if (dp2 == null) {
          console.warn("DSL delta cannot be computed, no data - invalid index");
        } else {
          const { value: val2 } = dp2.getValue();
          delta = val1 - val2;
        }
        return new DataPoint(field, { type, value: delta });
      }
      /**
       * Sets all the values in the Data Series to a static TypedValue.
       * @param {TypedValue} v
       */
      setValue(v) {
        this.points.forEach((p) => {
          p.setValue(v);
        });
        this.type = this.points[0].getType();
      }
      /**
       * Gets all the values + their type in the Data Series.
       * @returns {TypedValue[]}
       */
      getValue() {
        const values = [];
        this.points.forEach((p) => {
          values.push(p.getValue());
        });
        return values;
      }
      /**
       * Gets all the values (only) in the Data Series.
       * @returns {array}
       */
      getRawValue() {
        const values = [];
        this.points.forEach((p) => {
          values.push(p.getRawValue());
        });
        return values;
      }
      /**
       * Returns the data source field which the series belongs to.
       * @public
       * @returns {DataPoint<'string'>}
       */
      getField() {
        const dp1 = this.lastPoint();
        return dp1.getField();
      }
      /**
       * Returns the inferred data type of the series.
       * @public
       * @returns {string}
       */
      getType() {
        if (this.type === void 0) {
          this.type = inferDataTypeFromDataPoints(this.points);
        }
        return this.type;
      }
      /**
       * Returns the minimum DataPoint in the series or undefined if no numbers in series.
       * @public
       * @returns {DataPoint<T>}
       */
      min() {
        return this.reduce((v1, v2) => v1 < v2);
      }
      /**
       * Returns the maximum DataPoint in the series.
       * @public
       * @returns {DataPoint<T>}
       */
      max() {
        return this.reduce((v1, v2) => v1 > v2);
      }
      reduce(comparator) {
        return this.points.reduce((agg, cur) => {
          return !agg || comparator(cur.getValue().coercedValue, agg.getValue().coercedValue) ? cur : agg;
        }, void 0);
      }
    };
    var DataFrame = class _DataFrame {
      /**
       * @param {any} o
       * @returns {boolean}
       */
      static isDataFrame(o) {
        return o instanceof _DataFrame;
      }
      /**
       * @param {array} series list of data series
       */
      constructor(series) {
        this.series = Array.isArray(series) ? series : [series];
      }
      /**
       * Loads ColumnarData into a DataFrame
       * @param {ColumnarData} columnarData
       * @returns {DataFrame<T>}
       */
      static fromJsonCols(columnarData) {
        if (!(columnarData == null ? void 0 : columnarData.data)) {
          return new _DataFrame([]);
        }
        const {
          data: { fields = [], columns = [] }
        } = columnarData;
        if (columns.length !== fields.length) {
          throw new Error(
            `number of columns (${columns.length}) does not match number of fields (${fields.length})`
          );
        }
        const dataSeries = [];
        columns.forEach((data, idx) => {
          const dataPoints = [];
          const fieldInfo = fields[idx];
          const name = fieldInfo.name || fieldInfo;
          const type = fieldInfo == null ? void 0 : fieldInfo.type;
          data.forEach((value) => {
            const dataType = getDataTypeForPoint(value, {
              name,
              type
            });
            dataPoints.push(new DataPoint(name, { value, type: dataType }));
          });
          dataSeries.push(new DataSeries(dataPoints));
        });
        return new _DataFrame(dataSeries);
      }
      static fromRaw(f) {
        const series = [];
        f.forEach((s) => {
          series.push(DataSeries.fromRaw(s));
        });
        return new _DataFrame(series);
      }
      // eslint-disable-next-line consistent-return
      static fromDataPrimitive(dp) {
        if (_DataFrame.isDataFrame(dp)) {
          return dp;
        }
        if (DataSeries.isDataSeries(dp)) {
          return new _DataFrame([dp]);
        }
        if (DataPoint.isDataPoint(dp)) {
          return new _DataFrame([new DataSeries([dp])]);
        }
      }
      /**
       * Filter a DataFrame by specifying the indexes of the DataSeries you would like to return.
       * For example, `frameBySeriesIndexes(first_index, second_index, ...)`, where at least one index is required.
       * @public
       * @param {number[]} indexes
       * @returns {DataFrame.<DataType>}
       *
       * The following code sample shows how to use frameBySeriesIndexes to render a table that includes the first, second, and fourth DataSeries from the data source.
       *
       * ```
       * <Table
       *   options={{
       *     table: '> primary | frameBySeriesIndexes(0,1,3)'
       *   }},
       *   dataSources={{
       *     primary: {
       *       data: {
       *         fields: [
       *           {
       *             name: 'Name'
       *           },
       *           {
       *             name: 'UserID'
       *           },
       *           {
       *             name: 'Money Spent'
       *           },
       *           {
       *             name: 'Most Recent Game'
       *           }
       *         ],
       *         columns: [
       *           [
       *             'Ms. Herman Beer',
       *             'Crystal Ziemann',
       *             'Phil Bartoletti',
       *             'Janis Kiehn V',
       *             'Angel Krajcik',
       *             'Patti Hodkiewicz IV',
       *             'Joanne Emmerich',
       *             'Jay Renner',
       *             'Ora Borer',
       *             'Dr. Bradford Gulgowski'
       *           ],
       *           [
       *             'Enrico98',
       *             'Taylor_Parker83',
       *             'Candice_Carroll',
       *             'Yolanda_McLaughlin95',
       *             'Modesto84',
       *             'Elwin52',
       *             'Francis8',
       *             'Charley.Feeney85',
       *             'Jensen_Jacobson74',
       *             'Dora_Volkman'
       *           ],
       *           [
       *             9740890.83,
       *             2107983.52,
       *             5467223.67,
       *             9529184.93,
       *             9692275.78,
       *             5692737.43,
       *             1001734.82,
       *             3848531.8,
       *             3848531.8
       *           ],
       *           [
       *             '2020-04-12T06:32:08-07:00',
       *             '2020-06-06T16:14:04-07:00',
       *             '2020-02-12T09:43:25-08:00',
       *             '2020-07-25T13:19:49-07:00',
       *             '2020-03-16T21:46:40-07:00',
       *             '2020-08-21T08:38:55-07:00',
       *             '2020-09-26T16:06:03-07:00',
       *             '2020-08-10T14:54:16-07:00',
       *             '2020-08-11T16:49:24-07:00',
       *             '2020-09-29T03:52:51-07:00'
       *           ]
       *         ]
       *       },
       *       meta: {
       *         totalCount: 100
       *       },
       *       requestParams: {
       *         count: 10,
       *         offset: 0
       *       }
       *     }
       *   }}
       * />
       */
      frameBySeriesIndexes(...indexes) {
        const indexedSeries = [];
        indexes.forEach((index) => {
          const ds = this.series[index];
          if (ds != null) {
            indexedSeries.push(ds);
          }
        });
        return new _DataFrame(indexedSeries);
      }
      /**
       * Select a DataSeries by specifying the index of the series you want to return.
       * @public
       * @param {number} index
       * @returns {DataSeries<DataType>}
       *
       * The following code sample shows how to use seriesByIndex to display the second series in a data source as a single value.
       *
       * ```
       * <SingleValue
       *     options={{
       *         sparklineValues: '> primary | seriesByIndex(1)'
       *     }}
       *     dataSources={{
       *         primary: {
       *             data: {
       *                 fields: [
       *                     {
       *                         name: '_time',
       *                     },
       *                     {
       *                         name: 'count',
       *                     },
       *                 ],
       *                 columns: [
       *                     [
       *                         '2018-08-19T00:00:00.000+00:00',
       *                         '2018-08-20T00:00:00.000+00:00',
       *                         '2018-08-21T00:00:00.000+00:00',
       *                         '2018-08-22T00:00:00.000+00:00',
       *                         '2018-08-23T00:00:00.000+00:00',
       *                         '2018-08-24T00:00:00.000+00:00',
       *                         '2018-08-25T00:00:00.000+00:00',
       *                         '2018-08-26T00:00:00.000+00:00',
       *                     ],
       *                     ['1', '62', '103', '308', '587', '876', '930', '1320'],
       *                 ],
       *             },
       *             meta: {},
       *         },
       *     }}
       * />
       *
       */
      // SCP-60632: added a second parameter - empty array as default fallback, hidden from user
      seriesByIndex(index, defaultSeries = []) {
        return this.series[index] || defaultSeries;
      }
      /**
       * Filter a DataFrame by specifying the index range [start, end) of the DataSeries you would like to return.
       * For example, `frameBySeriesIndexRange(start_index)` or `frameBySeriesIndexRange(start_index, end_index)`, where at least the starting index is required.
       * @public
       * @param {int} start (inclusive)
       * @param {int=} end (optional, exclusive)
       * @returns {DataFrame<DataType>}
       *
       * The following code sample shows how to use frameBySeriesIndexRange to render a table that includes the first, second, and third series from the data source.
       *
       * ```
       * <Table
       *   options={{
       *     table: '> primary | frameBySeriesIndexRange(0,2)'
       *   }},
       *   dataSources={{
       *     primary: {
       *       data: {
       *         fields: [
       *           {
       *             name: 'Name'
       *           },
       *           {
       *             name: 'UserID'
       *           },
       *           {
       *             name: 'Money Spent'
       *           },
       *           {
       *             name: 'Most Recent Game'
       *           },
       *         ],
       *         columns: [
       *           [
       *             'Ms. Herman Beer',
       *             'Crystal Ziemann',
       *             'Phil Bartoletti',
       *             'Janis Kiehn V',
       *             'Angel Krajcik',
       *             'Patti Hodkiewicz IV',
       *             'Joanne Emmerich',
       *             'Jay Renner',
       *             'Ora Borer',
       *             'Dr. Bradford Gulgowski'
       *           ],
       *           [
       *             'Enrico98',
       *             'Taylor_Parker83',
       *             'Candice_Carroll',
       *             'Yolanda_McLaughlin95',
       *             'Modesto84',
       *             'Elwin52',
       *             'Francis8',
       *             'Charley.Feeney85',
       *             'Jensen_Jacobson74',
       *             'Dora_Volkman'
       *           ],
       *           [
       *             9740890.83,
       *             2107983.52,
       *             5467223.67,
       *             9529184.93,
       *             9692275.78,
       *             9395814.7,
       *             5692737.43,
       *             1001734.82,
       *             3848531.8,
       *             1691776.38
       *           ],
       *           [
       *             '2020-04-12T06:32:08-07:00',
       *             '2020-06-06T16:14:04-07:00',
       *             '2020-02-12T09:43:25-08:00',
       *             '2020-07-25T13:19:49-07:00',
       *             '2020-03-16T21:46:40-07:00',
       *             '2020-08-21T08:38:55-07:00',
       *             '2020-09-26T16:06:03-07:00',
       *             '2020-08-10T14:54:16-07:00',
       *             '2020-08-11T16:49:24-07:00',
       *             '2020-09-29T03:52:51-07:00'
       *           ]
       *         ]
       *       },
       *       meta: {
       *         totalCount: 100
       *       },
       *       requestParams: {
       *         count: 10,
       *         offset: 0
       *       }
       *     }
       *   }}
       * />
       */
      frameBySeriesIndexRange(start, end) {
        return new _DataFrame(this.series.slice(start, end));
      }
      /**
       * Filter a DataFrame by specifying the names of the DataSeries you would like to return.
       * For example, `frameBySeriesNames(first_name, second_name, ...)`, where at least one series name is required.
       * @public
       * @param {string[]} names
       * @returns {DataFrame<DataType>}
       *
       * The following code sample shows how to use frameBySeriesNames to render a table with the Name and Money Spent columns in the data source.
       *
       * ```
       * <Table
       *     options={{
       *         table: '> primary | frameBySeriesNames("Name", "Money Spent")'
       *     }},
       *     dataSources={{
       *         primary: {
       *             data: {
       *                 fields: [
       *                     {
       *                         name: 'Name'
       *                     },
       *                     {
       *                         name: 'UserID'
       *                     },
       *                     {
       *                         name: 'Money Spent'
       *                     },
       *                     {
       *                         name: 'Most Recent Game'
       *                     },
       *                 ],
       *                 columns: [
       *                     [
       *                         'Ms. Herman Beer',
       *                         'Crystal Ziemann',
       *                         'Phil Bartoletti',
       *                         'Janis Kiehn V',
       *                         'Angel Krajcik',
       *                         'Patti Hodkiewicz IV',
       *                         'Joanne Emmerich',
       *                         'Jay Renner',
       *                         'Ora Borer',
       *                         'Dr. Bradford Gulgowski'
       *                     ],
       *                     [
       *                         'Enrico98',
       *                         'Taylor_Parker83',
       *                         'Candice_Carroll',
       *                         'Yolanda_McLaughlin95',
       *                         'Modesto84',
       *                         'Elwin52',
       *                         'Francis8',
       *                         'Charley.Feeney85',
       *                         'Jensen_Jacobson74',
       *                         'Dora_Volkman'
       *                     ],
       *                     [
       *                         9740890.83,
       *                         2107983.52,
       *                         5467223.67,
       *                         9529184.93,
       *                         9692275.78,
       *                         9395814.7,
       *                         5692737.43,
       *                         1001734.82,
       *                         3848531.8,
       *                         1691776.38
       *                     ],
       *                     [
       *                         '2020-04-12T06:32:08-07:00',
       *                         '2020-06-06T16:14:04-07:00',
       *                         '2020-02-12T09:43:25-08:00',
       *                         '2020-07-25T13:19:49-07:00',
       *                         '2020-03-16T21:46:40-07:00',
       *                         '2020-08-21T08:38:55-07:00',
       *                         '2020-09-26T16:06:03-07:00',
       *                         '2020-08-10T14:54:16-07:00',
       *                         '2020-08-11T16:49:24-07:00',
       *                         '2020-09-29T03:52:51-07:00'
       *                     ]
       *                 ]
       *             },
       *             meta: {
       *                 totalCount: 100
       *             },
       *             requestParams {
       *                 count: 10,
       *                 offset: 0
       *             }
       *         }
       *     }}
       * />
       */
      frameBySeriesNames(...names) {
        const namedSeries = [];
        names.forEach((name) => {
          const series = this.seriesByName(name);
          const found = series && DataSeries.isDataSeries(series);
          if (found) {
            namedSeries.push(series);
          }
        });
        return new _DataFrame(namedSeries);
      }
      /**
       * Filter a DataFrame by specifying the names of the DataSeries you would like to omit.
       *  e.g. `frameWithoutSeriesNames(first_name, second_name, ...)`, where at least one series name is required.
       * Note: the data columns of internal fields are automatically excluded from the result.
       * @public
       * @param {string[]} names
       * @returns {DataFrame<DataType>}
       */
      frameWithoutSeriesNames(...names) {
        if (names == null) {
          return new _DataFrame(this.series);
        }
        return new _DataFrame(
          this.series.filter(
            (s) => !names.includes(s.field) && !s.field.startsWith("_")
          )
        );
      }
      /**
       * Filter a DataFrame by removing all internal fields starting with underscore `_`.
       * For example, if you have a primary data source with the following fields: `_time, _span, date, count, cost, _raw`,
       * then DSL `> primary | frameWithoutInternalFields()` removes all the internal fields and returns the DataFrame with fields `date, count, cost`.
       * @public
       * @returns {DataFrame<DataType>}
       *
       * The following code sample shows how to use `frameWithoutInternalFields()` to remove the internal fields from the data source.
       *
       * ```
       * <Table
       *     options={{
       *         table: '> primary | frameWithoutInternalFields()'
       *     }},
       *     dataSources={{
       *         primary: {
       *             data: {
       *                 fields: [
       *                     {
       *                         name: 'Name'
       *                     },
       *                     {
       *                         name: 'UserID'
       *                     },
       *                     {
       *                         name: '_time'
       *                     },
       *                     {
       *                         name: '_span'
       *                     },
       *                 ],
       *                 columns: [
       *                     [
       *                         'Ms. Herman Beer',
       *                         'Crystal Ziemann',
       *                         'Jay Renner',
       *                         'Ora Borer',
       *                         'Dr. Bradford Gulgowski'
       *                     ],
       *                     [
       *                         'Enrico98',
       *                         'Taylor_Parker83',
       *                         'Charley.Feeney85',
       *                         'Jensen_Jacobson74',
       *                         'Dora_Volkman'
       *                     ],
       *                     [
       *                         '2020-04-12T06:32:08-07:00',
       *                         '2020-06-06T16:14:04-07:00',
       *                         '2020-08-10T14:54:16-07:00',
       *                         '2020-08-11T16:49:24-07:00',
       *                         '2020-09-29T03:52:51-07:00'
       *                     ],
       *                     [
       *                         '1800',
       *                         '1800',
       *                         '1800',
       *                         '1800',
       *                         '1800'
       *                     ]
       *                 ]
       *             },
       *             meta: {
       *                 totalCount: 100
       *             },
       *             requestParams {
       *                 count: 10,
       *                 offset: 0
       *             }
       *         }
       *     }}
       * />
       * ```
       * This code sample will visualize a table with the `Name` and `UserID` columns,
       * and the columns of `_time` and `_span` (internal fields) will not be displayed.
       *
       * Another example of using `frameWithoutInternalFields()` in a chained DSL:
       *
       * ```
       * <SingleValue
       *     options={{
       *         "majorValue": "> primary | frameWithoutInternalFields() | seriesByIndex(0) | lastPoint()"
       *     }},
       *     dataSources={{
       *         primary: {
       *             data: {
       *                 fields: [
       *                     {
       *                         name: '_time'
       *                     },
       *                     {
       *                         name: '_span'
       *                     },
       *                     {
       *                         name: 'Name'
       *                     },
       *                     {
       *                         name: 'UserID'
       *                     }
       *                 ],
       *                 columns: [
       *                     [
       *                         '2020-04-12T06:32:08-07:00',
       *                         '2020-06-06T16:14:04-07:00',
       *                         '2020-08-10T14:54:16-07:00',
       *                         '2020-08-11T16:49:24-07:00',
       *                         '2020-09-29T03:52:51-07:00'
       *                     ],
       *                     [
       *                         '1800',
       *                         '1800',
       *                         '1800',
       *                         '1800',
       *                         '1800'
       *                     ],
       *                     [
       *                         'Patti Hodkiewicz IV',
       *                         'Joanne Emmerich',
       *                         'Jay Renner',
       *                         'Ora Borer',
       *                         'Dr. Bradford Gulgowski'
       *                     ],
       *                     [
       *                         'Elwin52',
       *                         'Francis8',
       *                         'Charley.Feeney85',
       *                         'Jensen_Jacobson74',
       *                         'Dora_Volkman'
       *                     ]
       *                 ]
       *             },
       *             meta: {
       *                 totalCount: 100
       *             },
       *             requestParams {
       *                 count: 10,
       *                 offset: 0
       *             }
       *         }
       *     }}
       * />
       * ```
       * This code sample will visualize `Dr. Bradford Gulgowski` as the major value,
       * because both internal fields (`_time` and `_span`) are removed and index `0` of the rest of the data frame corresponds to the `Name` column.
       */
      frameWithoutInternalFields() {
        return new _DataFrame(
          this.series.filter((s) => !s.field.startsWith("_"))
        );
      }
      /**
       * Filter a DataFrame by removing all internal fields starting with underscore `_`, except for the fields listed in `names`.
       * For example, if you have a primary data source with the following fields: `_time, _span, date, count, cost, _raw`,
       * then DSL `> primary | frameWithoutInternalFields('_time')` removes all the internal fields except `_time` and returns the DataFrame with fields `_time, date, count, cost`.
       * If you want to remove all the internal fields, use `frameWithoutInternalFields()` instead.
       * If you pass any non-internal fields as parameters, they will be ignored.
       *
       * @public
       * @param {string[]} names
       * @returns {DataFrame<DataType>}
       *
       * The following code sample shows how to use `frameWithoutInternalFieldsExcept(...names)` to remove some internal fields from the data source, but leaving specified internal fields by their field names.
       *
       * ```
       * <Table
       *     options={{
       *         table: '> primary | frameWithoutInternalFieldsExcept('_time', '_span')'
       *     }},
       *     dataSources={{
       *         primary: {
       *             data: {
       *                 fields: [
       *                     {
       *                         name: 'Name'
       *                     },
       *                     {
       *                         name: 'UserID'
       *                     },
       *                     {
       *                         name: '_time'
       *                     },
       *                     {
       *                         name: '_span'
       *                     },
       *                     {
       *                         name: '_raw'
       *                     },
       *                 ],
       *                 columns: [
       *                     [
       *                         'Ms. Herman Beer',
       *                         'Joanne Emmerich',
       *                         'Jay Renner',
       *                         'Ora Borer',
       *                         'Dr. Bradford Gulgowski'
       *                     ],
       *                     [
       *                         'Enrico98',
       *                         'Francis8',
       *                         'Charley.Feeney85',
       *                         'Jensen_Jacobson74',
       *                         'Dora_Volkman'
       *                     ],
       *                     [
       *                         '2020-04-12T06:32:08-07:00',
       *                         '2020-09-26T16:06:03-07:00',
       *                         '2020-08-10T14:54:16-07:00',
       *                         '2020-08-11T16:49:24-07:00',
       *                         '2020-09-29T03:52:51-07:00'
       *                     ],
       *                     [
       *                         '1800',
       *                         '1800',
       *                         '1800',
       *                         '1800',
       *                         '1800'
       *                     ],
       *                     [
       *                         '2020-04-12T06:32:08-07:00',
       *                         '2020-09-26T16:06:03-07:00',
       *                         '2020-08-10T14:54:16-07:00',
       *                         '2020-08-11T16:49:24-07:00',
       *                         '2020-09-29T03:52:51-07:00'
       *                     ]
       *                 ]
       *             },
       *             meta: {
       *                 totalCount: 100
       *             },
       *             requestParams {
       *                 count: 10,
       *                 offset: 0
       *             }
       *         }
       *     }}
       * />
       * ```
       *
       * This code sample will visualize the table with the `Name`, `UserID`, `_time` and `_span` columns,
       * and the `_raw` columns will not be displayed.
       *
       * Another example of using `frameWithoutInternalFieldsExcept(...names)` in a chained DSL:
       *
       * ```
       * <SingleValue
       *     options={{
       *         "majorValue": "> primary | frameWithoutInternalFieldsExcept('_time') | seriesByIndex(1) | lastPoint()"
       *     }},
       *     dataSources={{
       *         primary: {
       *             data: {
       *                 fields: [
       *                     {
       *                         name: '_time'
       *                     },
       *                     {
       *                         name: '_span'
       *                     },
       *                     {
       *                         name: '_raw'
       *                     },
       *                     {
       *                         name: 'Name'
       *                     },
       *                     {
       *                         name: 'UserID'
       *                     }
       *                 ],
       *                 columns: [
       *                     [
       *                         '2020-04-12T06:32:08-07:00',
       *                         '2020-09-26T16:06:03-07:00',
       *                         '2020-08-10T14:54:16-07:00',
       *                         '2020-08-11T16:49:24-07:00',
       *                         '2020-09-29T03:52:51-07:00'
       *                     ],
       *                     [
       *                         '1800',
       *                         '1800',
       *                         '1800',
       *                         '1800',
       *                         '1800'
       *                     ],
       *                     [
       *                         '2020-04-12T06:32:08-07:00',
       *                         '2020-06-06T16:14:04-07:00',
       *                         '2020-08-10T14:54:16-07:00',
       *                         '2020-08-11T16:49:24-07:00',
       *                         '2020-09-29T03:52:51-07:00'
       *                     ],
       *                     [
       *                         'Ms. Herman Beer',
       *                         'Crystal Ziemann',
       *                         'Angel Krajcik',
       *                         'Jay Renner',
       *                         'Dr. Bradford Gulgowski'
       *                     ],
       *                     [
       *                         'Candice_Carroll',
       *                         'Elwin52',
       *                         'Francis8',
       *                         'Charley.Feeney85',
       *                         'Dora_Volkman'
       *                     ]
       *                 ]
       *             },
       *             meta: {
       *                 totalCount: 100
       *             },
       *             requestParams {
       *                 count: 10,
       *                 offset: 0
       *             }
       *         }
       *     }}
       * />
       * ```
       *
       * This code sample will visualize `Dr. Bradford Gulgowski` as the major value, because the internal fields other than `_time` are excluded,
       * and index `1` of the rest of the data frame (`_time`, `Name`, `UserID`) corresponds to the `Name` column.
       */
      frameWithoutInternalFieldsExcept(...names) {
        if (!names || names.length === 0) {
          return this.frameWithoutInternalFields();
        }
        const fields = this.series.map((s) => s.field);
        const validNames = names.filter((name) => fields.includes(name));
        return new _DataFrame(
          this.series.filter(
            (s) => validNames.includes(s.field) || !s.field.startsWith("_")
          )
        );
      }
      /**
       * Filter a DataFrame by specifying one or more names or indexes of DataSeries you would like to return.
       * For example,`frameBySeriesNames(first_name_or_index, second_name_or_index, ...)`, where at least one name or index is required.
       * @public
       * @param {...(string|number)} namesOrIndexes
       * @returns {DataFrame<DataType>}
       *
       * The following code sample shows how to use frameBySeriesNamesOrIndexes to render a table with the Name DataSeries and the fourth DataSeries in the data source.
       *
       * ```
       * <Table
       *     options={{
       *         table: '> primary | frameBySeriesNamesOrIndexes("Name", 3)'
       *     }},
       *     dataSources={{
       *         primary: {
       *             data: {
       *                 fields: [
       *                     {
       *                         name: 'Name'
       *                     },
       *                     {
       *                         name: 'UserID'
       *                     },
       *                     {
       *                         name: 'Money Spent'
       *                     },
       *                     {
       *                         name: 'Most Recent Game'
       *                     },
       *                 ],
       *                 columns: [
       *                     [
       *                         'Ms. Herman Beer',
       *                         'Crystal Ziemann',
       *                         'Phil Bartoletti',
       *                         'Janis Kiehn V',
       *                         'Angel Krajcik',
       *                         'Patti Hodkiewicz IV',
       *                         'Joanne Emmerich',
       *                         'Jay Renner',
       *                         'Ora Borer',
       *                         'Dr. Bradford Gulgowski'
       *                     ],
       *                     [
       *                         'Enrico98',
       *                         'Taylor_Parker83',
       *                         'Candice_Carroll',
       *                         'Yolanda_McLaughlin95',
       *                         'Modesto84',
       *                         'Elwin52',
       *                         'Francis8',
       *                         'Charley.Feeney85',
       *                         'Jensen_Jacobson74',
       *                         'Dora_Volkman'
       *                     ],
       *                     [
       *                         9740890.83,
       *                         2107983.52,
       *                         5467223.67,
       *                         9529184.93,
       *                         9692275.78,
       *                         9395814.7,
       *                         5692737.43,
       *                         1001734.82,
       *                         3848531.8,
       *                         1691776.38
       *                     ],
       *                     [
       *                         '2020-04-12T06:32:08-07:00',
       *                         '2020-06-06T16:14:04-07:00',
       *                         '2020-02-12T09:43:25-08:00',
       *                         '2020-07-25T13:19:49-07:00',
       *                         '2020-03-16T21:46:40-07:00',
       *                         '2020-08-21T08:38:55-07:00',
       *                         '2020-09-26T16:06:03-07:00',
       *                         '2020-08-10T14:54:16-07:00',
       *                         '2020-08-11T16:49:24-07:00',
       *                         '2020-09-29T03:52:51-07:00',
       *                     ]
       *                 ]
       *             },
       *             meta: {
       *                 totalCount: 100
       *             },
       *             requestParams: {
       *                 count: 10,
       *                 offset: 0
       *             }
       *         }
       *     }}
       * />
       */
      frameBySeriesNamesOrIndexes(...mixed) {
        const mixedSeries = [];
        mixed.forEach((nameOrIndex) => {
          const asNumber = Number(nameOrIndex);
          if (Number.isNaN(asNumber)) {
            const found = this.seriesByName(nameOrIndex);
            if (found) {
              mixedSeries.push(found);
            }
          } else {
            const found = this.series[asNumber];
            if (found) {
              mixedSeries.push(found);
            }
          }
        });
        return new _DataFrame(mixedSeries);
      }
      /**
       * Filter a DataFrame by specifying one or more types of DataSeries you would like to return.
       * For example, `frameBySeriesNames(first_type, second_type, ...)`, where at least one type is required.
       * @public
       * @param {DataType[]} types
       * @returns {DataFrame<DataType>}
       *
       * The following code sample shows how to use frameBySeriesTypes to render a table that contains only the string columns in the data source.
       *
       * ```
       * <Table
       *     options={{
       *         table: '> primary | frameBySeriesTypes("string")'
       *     }},
       *     dataSources={{
       *         primary: {
       *             data: {
       *                 fields: [
       *                     {
       *                         name: 'Name'
       *                     },
       *                     {
       *                         name: 'UserID'
       *                     },
       *                     {
       *                         name: 'Money Spent'
       *                     },
       *                     {
       *                         name: 'Most Recent Game'
       *                     },
       *                 ],
       *                 columns: [
       *                     [
       *                         'Ms. Herman Beer',
       *                         'Crystal Ziemann',
       *                         'Phil Bartoletti',
       *                         'Janis Kiehn V',
       *                         'Angel Krajcik',
       *                         'Patti Hodkiewicz IV',
       *                         'Joanne Emmerich',
       *                         'Jay Renner',
       *                         'Ora Borer',
       *                         'Dr. Bradford Gulgowski'
       *                     ],
       *                     [
       *                         'Enrico98',
       *                         'Taylor_Parker83',
       *                         'Candice_Carroll',
       *                         'Yolanda_McLaughlin95',
       *                         'Modesto84',
       *                         'Elwin52',
       *                         'Francis8',
       *                         'Charley.Feeney85',
       *                         'Jensen_Jacobson74',
       *                         'Dora_Volkman'
       *                     ],
       *                     [
       *                         9740890.83,
       *                         2107983.52,
       *                         5467223.67,
       *                         9529184.93,
       *                         9692275.78,
       *                         9395814.7,
       *                         5692737.43,
       *                         1001734.82,
       *                         3848531.8,
       *                         1691776.38
       *                     ],
       *                     [
       *                         '2020-04-12T06:32:08-07:00',
       *                         '2020-06-06T16:14:04-07:00',
       *                         '2020-02-12T09:43:25-08:00',
       *                         '2020-07-25T13:19:49-07:00',
       *                         '2020-03-16T21:46:40-07:00',
       *                         '2020-08-21T08:38:55-07:00',
       *                         '2020-09-26T16:06:03-07:00',
       *                         '2020-08-10T14:54:16-07:00',
       *                         '2020-08-11T16:49:24-07:00',
       *                         '2020-09-29T03:52:51-07:00'
       *                     ]
       *                 ]
       *             },
       *             meta: {
       *                 totalCount: 100
       *             },
       *             requestParams: {
       *                 count: 10,
       *                 offset: 0
       *             }
       *         }
       *     }}
       * />
       */
      frameBySeriesTypes(...types) {
        return new _DataFrame(
          this.series.filter((s) => types.includes(s.getType()))
        );
      }
      /**
       * Select a DataSeries by specifying the name of the DataSeries you would like to return.
       * @public
       * @param {string} field
       * @returns {DataSeries<DataType>}
       *
       * The following code sample shows how to use seriesByName to display the count series in a data source as a single value.
       *
       * ```
       * <SingleValue
       *     options={{
       *         sparklineValues: '> primary | seriesByName("count")',
       *     }}
       *     dataSources={{
       *         primary: {
       *             data: {
       *                 fields: [
       *                     {
       *                         name: '_time',
       *                     },
       *                     {
       *                         name: 'count',
       *                     },
       *                 ],
       *                 columns: [
       *                     [
       *                         '2018-08-19T00:00:00.000+00:00',
       *                         '2018-08-20T00:00:00.000+00:00',
       *                         '2018-08-21T00:00:00.000+00:00',
       *                         '2018-08-22T00:00:00.000+00:00',
       *                         '2018-08-23T00:00:00.000+00:00',
       *                         '2018-08-24T00:00:00.000+00:00',
       *                         '2018-08-25T00:00:00.000+00:00',
       *                         '2018-08-26T00:00:00.000+00:00',
       *                     ],
       *                     ['1', '62', '103', '308', '587', '876', '930', '1320'],
       *                 ],
       *             },
       *             meta: {},
       *         },
       *     }}
       * />
       */
      // SCP-60632: added a second parameter - empty array as default fallback, hidden from user
      seriesByName(field, defaultSeries = []) {
        var _a;
        return (_a = this.series.find((dataSeries) => field === dataSeries.field)) != null ? _a : defaultSeries;
      }
      /**
       * Select a DataSeries by specifying the type of the DataSeries you would like to return. The first DataSeries that matches the first type specified will be returned. If no DataSeries matches the first type specified, no DataSeries will be returned.
       * @public
       * @param {DataType} type
       * @returns {DataSeries<DataType>}
       *
       * The following code sample shows how to use seriesByType to display the first numeric series in a data source as a single value.
       *
       * If no numeric series are found, return nothing and display N/A.
       *
       * ```
       * <SingleValue
       *     options={{
       *         sparklineValues: '> primary | seriesByType("number")',
       *     }}
       *     dataSources: {{
       *         primary: {
       *             data: {
       *                 fields: [
       *                     {
       *                         name: '_time",
       *                     },
       *                     {
       *                         name: 'count',
       *                     },
       *                 ],
       *                 columns: [
       *                     [
       *                         '2018-08-19T00:00:00.000+00:00',
       *                         '2018-08-20T00:00:00.000+00:00',
       *                         '2018-08-21T00:00:00.000+00:00',
       *                         '2018-08-22T00:00:00.000+00:00',
       *                         '2018-08-23T00:00:00.000+00:00',
       *                         '2018-08-24T00:00:00.000+00:00',
       *                         '2018-08-25T00:00:00.000+00:00',
       *                         '2018-08-26T00:00:00.000+00:00',
       *                     ],
       *                     [ '1', '62', '103', '308', '587', '876', '930', '1320'],
       *                 ],
       *             },
       *             meta: {},
       *         },
       *     }}
       * />
       */
      seriesByType(type) {
        return this.series.find((dataSeries) => {
          const dataType = dataSeries.getType();
          return dataType === type;
        });
      }
      /**
       * Select a DataSeries by specifying any acceptable types of the DataSeries you would like to return. The first DataSeries that matches any of the types specified will be returned. If no DataSeries matches the type options specified, no DataSeries will be returned.
       * @public
       * @param {DataType[]} types
       * @returns {DataSeries<DataType>}
       */
      seriesByTypes(...types) {
        return this.series.find(
          (dataSeries) => types.some((type) => dataSeries.getType() === type)
        );
      }
      /**
       * Select a DataSeries by specifying the prioritized types of the DataSeries you would like to return. The first DataSeries that matches the first type specified will be returned. If no DataSeries matches the first type specified, the first DataSeries that matches the second type will be returned, and so on.
       * @public
       * @param {DataType[]} types
       * @returns {DataSeries<DataType>}
       *
       * The following code sample shows how to use seriesByPrioritizedTypes to display the first numeric series in a data source as a single value.
       *
       * If no numeric series are found in the data, the first series of type string is displayed. If no string series are found, the first series of type time is displayed.
       *
       * ```
       * <SingleValue
       *     options={{
       *         sparklineValues: '> primary | seriesByPrioritizedTypes'("number", "string", "time"),
       *     }}
       *     dataSources={{
       *         primary: {
       *             data: {
       *                 columns: [
       *                     [
       *                         '2018-08-19T00:00:00.000+00:00',
       *                         '2018-08-20T00:00:00.000+00:00',
       *                         '2018-08-21T00:00:00.000+00:00',
       *                         '2018-08-22T00:00:00.000+00:00',
       *                         '2018-08-23T00:00:00.000+00:00',
       *                         '2018-08-24T00:00:00.000+00:00',
       *                         '2018-08-25T00:00:00.000+00:00',
       *                         '2018-08-26T00:00:00.000+00:00',
       *                     ],
       *                     [ 'INFO', 'ERROR', 'WARN', 'INFO', 'ERROR', 'WARN', 'INFO', 'WARN'],
       *                 ],
       *                 fields: [
       *                     {
       *                         name: '_time',
       *                     },
       *                     {
       *                         name: 'status',
       *                     },
       *                 ],
       *             },
       *             meta: {},
       *         },
       *     }}
       * />
       */
      seriesByPrioritizedTypes(...types) {
        var _a;
        for (const type of types) {
          const matchedSeries = this.seriesByType(type);
          if (Array.isArray(matchedSeries == null ? void 0 : matchedSeries.points) && ((_a = matchedSeries == null ? void 0 : matchedSeries.points) == null ? void 0 : _a.length)) {
            return matchedSeries;
          }
        }
        return this.series[0];
      }
      /**
       * Set all values in the DataFrame to a static TypedValue.
       * @public
       * @param {TypedValue} v
       */
      setValue(v) {
        this.series.forEach((s) => s.setValue(v));
      }
      /**
       * Get all values in the DataFrame. This excludes field names.
       * @public
       * @returns {array}
       */
      getRawValue() {
        const values = [];
        this.series.forEach((s) => {
          values.push(s.getRawValue());
        });
        return values;
      }
      /**
       * Get all values and their types in the DataFrame. This excludes field names.
       * @public
       * @returns {TypedValue[][]}
       */
      getValue() {
        const values = [];
        this.series.forEach((s) => {
          values.push(s.getValue());
        });
        return values;
      }
      /**
       * Get the names of each DataSeries in the DataFrame.
       * @public
       * @returns {DataSeries<string>}
       *
       * ```
       * <Table
       *   options={{
       *       headers: '> table | getField()'
       *   }},
       *   dataSources={{
       *     primary: {
       *       data: {
       *         fields: [
       *           {
       *              name: 'Name'
       *           },
       *           {
       *              name: 'UserID'
       *           },
       *           {
       *              name: 'Money Spent'
       *           },
       *           {
       *              name: 'Most Recent Game'
       *           },
       *         ],
       *         columns: [
       *           [
       *              'Ms. Herman Beer',
       *              'Crystal Ziemann',
       *              'Phil Bartoletti',
       *              'Janis Kiehn V',
       *              'Angel Krajcik',
       *              'Patti Hodkiewicz IV',
       *              'Joanne Emmerich',
       *              'Jay Renner',
       *              'Ora Borer',
       *              'Dr. Bradford Gulgowski'
       *           ],
       *           [
       *              'Enrico98',
       *              'Taylor_Parker83',
       *              'Candice_Carroll',
       *              'Yolanda_McLaughlin95',
       *              'Modesto84',
       *              'Elwin52',
       *              'Francis8',
       *              'Charley.Feeney85',
       *              'Jensen_Jacobson74',
       *              'Dore_Volkman'
       *           ],
       *           [
       *              9740890.83,
       *              2107983.52,
       *              5467223.67,
       *              9529184.93,
       *              9692275.78,
       *              9395814.7,
       *              5692737.43,
       *              1001734.82,
       *              3848531.8,
       *              1691776.38
       *           ],
       *           [
       *              '2020-04-12T06:32:08-07:00',
       *              '2020-06-06T16:14:04-07:00',
       *              '2020-02-12T09:43:25-08:00',
       *              '2020-07-25T13:19:49-07:00',
       *              '2020-03-16T21:46:40-07:00',
       *              '2020-08-21T08:38:55-07:00',
       *              '2020-09-26T16:06:03-07:00',
       *              '2020-08-10T14:54:16-07:00',
       *              '2020-08-11T16:49:24-07:00',
       *              '2020-09-29T03:52:51-07:00'
       *           ]
       *         ]
       *      },
       *      meta: {
       *        totalCount: 100
       *      },
       *      requestParams: {
       *        count: 10,
       *        offset: 0
       *      }
       *     }
       *   }}
       * />
       *
       * Display the third and fourth DataSeries in a column chart as overlay fields.
       *
       * <Column
       *   options={{
       *     overlayFields: '> primary | frameBySeriesIndex(2,3) | getField()'
       *   }},
       *   dataSources={{
       *     primary: {
       *       requestParams: { offset: 0, count: 20},
       *       data: {
       *         fields: [
       *             { name: '_time' },
       *             { name: 'splunkd' },
       *             { name: 'splunkd_web_access' },
       *             { name: 'mongod' },
       *         ],
       *         columns: [
       *             [
       *                 '2018-05-02T18:15:46.000-07:00',
       *                 '2018-05-02T18:15:47.000-07:00',
       *                 '2018-05-02T18:15:48.000-07:00',
       *                 '2018-05-02T18:15:49.000-07:00',
       *                 '2018-05-02T18:15:50.000-07:00',
       *             ],
       *             ['67228', '83195', '3145', '19332', '29763'],
       *             ['67228', '83195', '3145', '19332', '29763'],
       *             ['14881', '17341', '18081', '19774', '10467'],
       *         ]
       *       },
       *       meta: {
       *         totalCount: 100,
       *       }
       *     }
       *   }}
       * />
       */
      getField() {
        const points = this.series.map((s) => s.getField());
        return new DataSeries(points);
      }
      /**
       * Get the data type of each DataSeries in the DataFrame.
       * @public
       * @returns {string[]}
       */
      getType() {
        return this.series.map((s) => s.getType());
      }
      /**
       * Get the global minimum value from all numeric DataSeries in the DataFrame.
       * @public
       * @returns {number}
       *
       * The following code sample shows how to use min to display the smallest data point in a data source as a single value.
       *
       * ```
       * <SingleValue
       *     options={{
       *         majorValue: '> primary | min()',
       *         trendDisplay: 'off',
       *         sparklineDisplay: 'off'
       *     }}
       *     dataSources={{
       *         primary: {
       *             data: {
       *                 fields: [
       *                     {
       *                         name: '_time',
       *                     },
       *                     {
       *                         name: 'count',
       *                     },
       *                 ],
       *                 columns: [
       *                     [
       *                         '2018-08-19T00:00:00.000+00:00',
       *                         '2018-08-20T00:00:00.000+00:00',
       *                         '2018-08-21T00:00:00.000+00:00',
       *                         '2018-08-22T00:00:00.000+00:00',
       *                         '2018-08-23T00:00:00.000+00:00',
       *                         '2018-08-24T00:00:00.000+00:00',
       *                         '2018-08-25T00:00:00.000+00:00',
       *                         '2018-08-26T00:00:00.000+00:00',
       *                     ],
       *                     ['1', '62', '103', '308', '587', '876', '930', '1320'],
       *                 ],
       *             },
       *             meta: {},
       *         },
       *     }}
       * />
       */
      min() {
        return this.minOrMax("min");
      }
      /**
       * Get the global maximum value from all numeric DataSeries in the DataFrame.
       * @public
       * @returns {number}
       *
       * The following code sample shows how to use max to display the largest data point in a data source as a single value.
       *
       * ```
       * <SingleValue
       *     options={{
       *         majorValue: '> primary | max()',
       *         trendDisplay: 'off',
       *         sparklineDisplay: 'off',
       *     }}
       *     dataSources={{
       *         primary: {
       *             data: {
       *                 fields: [
       *                     {
       *                         name: '_time',
       *                     },
       *                     {
       *                         name: 'count',
       *                     },
       *                 ],
       *                 columns: [
       *                     [
       *                         '2018-08-19T00:00:00.000+00:00',
       *                         '2018-08-20T00:00:00.000+00:00',
       *                         '2018-08-21T00:00:00.000+00:00',
       *                         '2018-08-22T00:00:00.000+00:00',
       *                         '2018-08-23T00:00:00.000+00:00',
       *                         '2018-08-24T00:00:00.000+00:00',
       *                         '2018-08-25T00:00:00.000+00:00',
       *                         '2018-08-26T00:00:00.000+00:00',
       *                     ],
       *                     [ '1', '62', '103', '308', '587', '876', '930', '1320' ],
       *                 ],
       *             },
       *             meta: {},
       *         },
       *     }}
       * />
       */
      max() {
        return this.minOrMax("max");
      }
      /**
       * runs result of min or max function over all the series and returns the data point
       * points
       * @param {string} aggName
       * @returns {DataPoint<T>}
       */
      minOrMax(funcName) {
        const overallSeries = new DataSeries();
        this.series.forEach((s) => {
          const m = s[funcName]();
          if (m) {
            overallSeries.points.push(m);
          }
        });
        return overallSeries[funcName]();
      }
    };
    init_define_global();
    var DataSeriesLite = class extends DataSeries {
      /**
       *
       * @param {string} type user explicitly sets the data type
       * @param {string} field or column name
       * @param {ColumnVal} the raw values
       */
      constructor(values, type, field) {
        super([], type, field);
        this.internalPoints = [];
        this.values = values;
        const dataTypeForMeta = getDataTypeForMeta({ name: field, type });
        if (dataTypeForMeta !== "unknown") {
          this.type = dataTypeForMeta;
        }
      }
      get points() {
        this.values.forEach((rawValue, index) => {
          if (!this.internalPoints[index]) {
            this.createDataPointFromValueAtIndex(index);
          }
        });
        return this.internalPoints;
      }
      /**
       * Return first dataPoint in series.
       * @public
       * @returns {DataPoint}
       */
      firstPoint() {
        if (!this.internalPoints[0]) {
          this.createDataPointFromValueAtIndex(0);
        }
        return this.internalPoints[0];
      }
      /**
       * Return last dataPoint in series.
       * @public
       * @returns {DataPoint}
       */
      lastPoint() {
        if (!this.internalPoints[this.values.length - 1]) {
          this.createDataPointFromValueAtIndex(this.values.length - 1);
        }
        return this.internalPoints[this.internalPoints.length - 1];
      }
      /**
       * Finds dataPoint(s) in DataSeries by index(es).
       * @public
       * @param {...number} indexes
       * @returns {DataSeries}
       */
      pointsByIndexes(...indexes) {
        const indexedPoints = [];
        indexes.forEach((index) => {
          let dp = this.internalPoints[index];
          if (!dp) {
            dp = this.createDataPointFromValueAtIndex(index);
          }
          if (dp != null) {
            indexedPoints.push(dp);
          }
        });
        return new DataSeries(indexedPoints);
      }
      /**
       * Finds and returns the individual dataPoint at the given index.
       * @public
       * @param {number} index
       * @returns {DataPoint}
       */
      pointByIndex(indexIn) {
        let index = indexIn;
        if (index < 0) {
          index = this.values.length + index;
        }
        if (index < 0 || index >= this.values.length) {
          return null;
        }
        let dp = this.internalPoints[index];
        if (!dp) {
          dp = this.createDataPointFromValueAtIndex(index);
        }
        return dp;
      }
      /**
       * Finds the delta between the last point and point at the given index.
       * A negative index can be used, indicating an offset from the end of the sequence.
       * @public
       * @param {number} index
       * @returns {DataPoint}
       */
      delta(index) {
        const dp1 = this.lastPoint();
        if (dp1 === void 0) {
          return void 0;
        }
        const { field } = dp1;
        const { type, value: val1 } = dp1.getValue();
        if (type !== "number") {
          console.warn(`DSL delta cannot be computed for non-numerical data series of type ${type}`);
        }
        let dp2 = null;
        let delta;
        if (index >= 0) {
          dp2 = this.internalPoints[index];
          if (!dp2) {
            dp2 = this.createDataPointFromValueAtIndex(index);
          }
        } else {
          const newIndex = this.values.length + index;
          dp2 = this.internalPoints[newIndex];
          if (!dp2) {
            dp2 = this.createDataPointFromValueAtIndex(newIndex);
          }
        }
        if (dp2 == null) {
          console.warn("DSL delta cannot be computed, no data - invalid index");
        } else {
          const { value: val2 } = dp2.getValue();
          delta = val1 - val2;
        }
        if (Number.isNaN(delta)) {
          delta = void 0;
        }
        return new DataPoint(field, { type, value: delta });
      }
      /**
       * Sets all the values in the Data Series to a static TypedValue.
       * @param {TypedValue} v
       */
      setValue(v) {
        this.internalPoints.forEach((p) => {
          p.setValue(v);
        });
        this.values.fill(v.value);
        this.type = inferDataTypeFromDataPoints(this.points);
      }
      /**
       * Gets all the values + their type in the Data Series.
       * @returns {TypedValue[]}
       */
      getValue() {
        const values = [];
        this.points.forEach((p) => {
          values.push(p.getValue());
        });
        return values;
      }
      /**
       * Gets all the values (only) in the Data Series.
       * @returns {array}
       */
      getRawValue() {
        return this.values;
      }
      createDataPointFromValueAtIndex(index) {
        const dataType = getDataTypeForPoint(this.values[index], {
          name: this.field,
          type: this.type
        });
        this.internalPoints[index] = new DataPoint(String(this.field), {
          type: dataType,
          value: this.values[index]
        });
        return this.internalPoints[index];
      }
    };
    var AbstractFormatter = class {
      format(dataPrimitive) {
        if (dataPrimitive instanceof DataFrame) {
          const newSeries = [];
          dataPrimitive.series.forEach((dataSeries, i) => {
            newSeries.push(this.formatSeries(dataSeries, i));
          });
          return new DataFrame(newSeries);
        }
        if (dataPrimitive instanceof DataSeries || dataPrimitive instanceof DataSeriesLite) {
          return this.formatSeries(dataPrimitive);
        }
        return this.formatPoint(dataPrimitive);
      }
      formatSeries(s, i = 0) {
        const newPoints = [];
        s.points.forEach((dataPoint, j) => {
          newPoints.push(this.formatPoint(dataPoint, s, i, j));
        });
        return new DataSeries(newPoints);
      }
      formatPoint(p, s, i = 0, j = 0) {
        const { field } = p;
        const dp = new DataPoint(field, {
          type: p.getValue().type,
          value: p.getValue().coercedValue
        });
        const tmp = this.formatTypedValue(dp, s, i, j);
        return new DataPoint(field, tmp);
      }
      makeArrays2D(a) {
        if (Array.isArray(a)) {
          if (Array.isArray(a[0])) {
            return a;
          }
          return [a];
        }
        throw new Error("argument wasn't array");
      }
    };
    init_define_global();
    init_define_global();
    var LITERAL_TYPES = ["number", "string"];
    init_define_global();
    function isDataPrimitive(o) {
      return DataFrame.isDataFrame(o) || DataSeries.isDataSeries(o) || DataPoint.isDataPoint(o);
    }
    init_define_global();
    var _OptionScopes = class _OptionScopes2 {
      constructor(optionsStanza, frames, themeFunc, bypassCloneDeepOptionScope) {
        this.local = [];
        this.visitedPaths = /* @__PURE__ */ new Set();
        this.context = optionsStanza.context;
        this.executedOptions = optionsStanza.options;
        this.frames = frames;
        this.themeFunc = themeFunc;
        this.bypassCloneDeepOptionScope = bypassCloneDeepOptionScope;
        this.local.push(this.executedOptions);
      }
      resolve(identifier) {
        const scopeParts = identifier.split(".");
        let scopedValue = null;
        if (_OptionScopes2.isQualified(scopeParts)) {
          scopedValue = this.resolveQualifiedIdentifier(scopeParts);
        } else {
          scopedValue = this.resolveUnqualifiedIdentifier(scopeParts);
        }
        if (this.bypassCloneDeepOptionScope) {
          return scopedValue;
        }
        return (0, lodash_exports.cloneDeep)(scopedValue);
      }
      static isQualified(scopeParts) {
        const firstPart = scopeParts[0];
        return _OptionScopes2.SCOPES.includes(firstPart);
      }
      resolveUnqualifiedIdentifier(scopeParts) {
        const qualifiers = _OptionScopes2.SCOPES;
        let scopedValue;
        for (let i = 0; i < qualifiers.length; i += 1) {
          const qualifiedIdentifier = [qualifiers[i], ...scopeParts];
          scopedValue = this.resolveQualifiedIdentifier(qualifiedIdentifier);
          if (scopedValue.val) {
            break;
          }
        }
        return scopedValue;
      }
      resolveQualifiedIdentifier(scopeParts) {
        const qualifiedTargets = {
          context: this.context,
          options: this.executedOptions,
          datasources: this.frames,
          local: this.local[this.local.length - 1]
        };
        let val = null;
        const location = scopeParts[0];
        if (location === "themes" && this.themeFunc) {
          const themeKey = scopeParts[1];
          val = this.themeFunc(themeKey);
        } else {
          val = (0, lodash_exports.get)(qualifiedTargets, scopeParts);
          if (val) {
            val = new EncodingExecutor().eval(val, this, scopeParts);
          }
        }
        return { location, val };
      }
      pushLocalScope(o) {
        this.local.push(o);
      }
      popLocalScope() {
        this.local.pop();
      }
      addToVisitedList(path) {
        const pathStr = path.join(".");
        if (this.visitedPaths.has(pathStr)) {
          throw new Error(
            `Circular reference ${pathStr}, path history: ${new Array(...this.visitedPaths).toString()}`
          );
        }
        this.visitedPaths.add(pathStr);
      }
      removeFromVisitedList(path) {
        this.visitedPaths.delete(path.join("."));
      }
    };
    _OptionScopes.SCOPES = ["local", "context", "datasources", "options", "themes"];
    var OptionScopes = _OptionScopes;
    init_define_global();
    var nearley_exports = {};
    __export2(nearley_exports, {
      default: () => nearley_default
    });
    init_define_global();
    var defaultImport5 = __toESM2(require_nearley());
    __reExport(nearley_exports, require_nearley());
    var nearley_default = "default" in defaultImport5 ? defaultImport5.default : defaultImport5;
    var grammar = require_vizparser();
    var _DslParser = class _DslParser2 {
      static parse(dsl) {
        if (_DslParser2.cache[dsl]) {
          return [..._DslParser2.cache[dsl]];
        }
        const parser = new nearley_exports.Parser(grammar);
        parser.feed(dsl);
        if (parser.results.length > 1) {
          console.warn(`Ambiguous parse of '${dsl}'`);
        }
        if (parser.results.length === 0) {
          console.warn(`No parsed results for '${dsl}'`);
        }
        _DslParser2.cache[dsl] = [...parser.results[0]];
        return parser.results[0];
      }
    };
    _DslParser.cache = {};
    var DslParser = _DslParser;
    init_define_global();
    var EncodingParser = class _EncodingParser {
      static parseOptions(optionsStanza) {
        const optionsAST = {
          simpleOptions: {},
          expressions: {},
          context: optionsStanza.context
        };
        const { options } = optionsStanza;
        Object.keys(options).forEach((k) => {
          const v = options[k];
          if (_EncodingParser.isDslString(v)) {
            optionsAST.expressions[k] = DslParser.parse(_EncodingParser.withoutArrow(v));
          } else {
            optionsAST.simpleOptions[k] = v;
          }
        });
        return optionsAST;
      }
      static isDslString(s) {
        return s ? s.toString().trim().startsWith(">") : false;
      }
      static withoutArrow(s) {
        return s.toString().match(/\s*>\s*(.+$)/)[1].trim();
      }
      static parse(encoding) {
        const { dimensions: dslFields, context } = encoding;
        const ast = { dimensions: {}, context };
        Object.keys(dslFields).forEach((f) => {
          const astDimension = { value: [] };
          let value = null;
          if (typeof dslFields[f] === "string") {
            value = dslFields[f];
          } else {
            const dim = dslFields[f];
            value = dim.value;
          }
          astDimension.value = DslParser.parse(value);
          ast.dimensions[f] = astDimension;
        });
        return ast;
      }
    };
    init_define_global();
    var Helper = class _Helper {
      static isRawDataFrame(d) {
        return Array.isArray(d) && _Helper.isRawDataSeries(d[0]);
      }
      static isRawDataSeries(d) {
        return Array.isArray(d) && !EncodingExecutor.isObject(d[0]);
      }
      static isRawDataPoint(d) {
        return !EncodingExecutor.isObject(d);
      }
      static dataPrimitiveFromRaw(d) {
        if (_Helper.isRawDataFrame(d)) {
          return DataFrame.fromRaw(d);
        }
        if (_Helper.isRawDataSeries(d)) {
          return DataSeries.fromRaw(d);
        }
        if (_Helper.isRawDataPoint(d)) {
          return DataPoint.fromRaw(d);
        }
        throw new Error(`raw value does not resemble DataFrame, DataSeries, or DataPoint`);
      }
    };
    var EncodingExecutor = class _EncodingExecutor {
      executeOptions(optionsStanza, frames, themeFunc, bypassCloneDeepOptionScope) {
        const ret = (0, lodash_exports.cloneDeep)(optionsStanza);
        const scopes = new OptionScopes(ret, frames, themeFunc, bypassCloneDeepOptionScope);
        this.eval(ret, scopes);
        const returnValue = _EncodingExecutor.rawTree(ret.options);
        return returnValue;
      }
      /**
       * o is what we are evaluating. If it is an array or an object that its parts are recursively
       * evaluated. Any DSL expressions encountered are evaluated. The scopes object is uses by the
       * DSL expression to resolve any identifiers. The scope object's 'local' scope is updated by
       * pushLocalScope as the eval method moves through the tree. The path array for a path "context.a.b.c"
       * will be ['context', 'a', 'b','c']. As eval moves through the tree, the scopes add the current
       * path its visited list. If the current path is found in the visited list, then a circular reference
       * error is thrown.
       * current 'path' in the
       * @param o
       * @param {OptionScopes} scopes
       * @param {string[]} path
       * @returns {any}
       */
      eval(o, scopes, path = []) {
        scopes.pushLocalScope(o);
        scopes.addToVisitedList(path);
        if (Array.isArray(o)) {
          o.forEach((v, i) => {
            path.push(i.toString());
            o[i] = this.eval(o[i], scopes, path);
            path.pop();
          });
        } else if ((0, lodash_exports.isPlainObject)(o)) {
          Object.keys(o).forEach((k) => {
            path.push(k);
            o[k] = this.eval(o[k], scopes, path);
            path.pop();
          });
        } else if (EncodingParser.isDslString(o)) {
          scopes.popLocalScope();
          const tmp = this.evalDsl(o, scopes);
          scopes.removeFromVisitedList(path);
          return tmp;
        }
        scopes.popLocalScope();
        scopes.removeFromVisitedList(path);
        return o;
      }
      evalDsl(dsl, scopes) {
        try {
          const parsedDsl = DslParser.parse(EncodingParser.withoutArrow(dsl));
          const execOptionsPipelineValue = this.execOptionsPipeline(
            parsedDsl,
            scopes,
            scopes.frames.primary
          );
          return execOptionsPipelineValue;
        } catch (e) {
          return void 0;
        }
      }
      /**
       * Takes anything that can have DSL embedded in it, such as tree or array, and insures
       * that all DataPrimitive have been converted to their 'raw' equivalents
       * @param {object} o
       * @returns {any}
       */
      static rawTree(o) {
        if (Array.isArray(o)) {
          o.forEach((v, i) => {
            o[i] = _EncodingExecutor.rawTree(o[i]);
          });
          return o;
        }
        if ((0, lodash_exports.isPlainObject)(o)) {
          Object.keys(o).forEach((k) => {
            o[k] = _EncodingExecutor.rawTree(o[k]);
          });
          return o;
        }
        const tmp = isDataPrimitive(o) ? o.getRawValue() : o;
        return tmp;
      }
      /**
       * Executes sequence of pipe delimited expressions that constitute a DSL
       * @param {Expr[]} pipeline
       * @param {OptionScopes} scopes
       * @param {DataPrimitive<DataType>} origin
       * @param {ExecutedOptions} executedOptions
       * @returns {{location: string; val: Option | DataPrimitive}}
       */
      execOptionsPipeline(pipeline, scopes, origin) {
        let subject = origin;
        pipeline.forEach((expr, i) => {
          if (expr.type === "method") {
            if (subject) {
              subject = this.executeMethod(expr, subject, scopes.context);
            }
          } else if (expr.type === "identifier") {
            subject = scopes.resolve(expr.v.toString()).val;
          } else if (LITERAL_TYPES.includes(expr.type)) {
            const tsv = TypeSafeValue.from({
              type: expr.type,
              value: expr.v
            });
            subject = new DataPoint("", tsv);
          }
          const isLastInPipeline = i === pipeline.length - 1;
          if (!isLastInPipeline && subject && !isDataPrimitive(subject)) {
            try {
              subject = Helper.dataPrimitiveFromRaw(subject);
            } catch (e) {
              const exprStr = expr.v ? expr.v : expr.name;
              throw new Error(
                `Output of '${exprStr}' cannot be piped because it is not a DataFrame, DataPoint, or DataSeries`
              );
            }
          }
        });
        return subject;
      }
      /**
       * Methods are either selector methods that built-ins such as
       * 'selectSeriesByPosition(...)",or they are formatter calls like 'rangeValue(...)'
       * @param {Method} expr
       * @param {DataPrimitive} subject
       * @param {Scopes} scopes
       * @param {string} metaName
       * @returns {DataPrimitive}
       */
      executeMethod(expr, subject, context) {
        const m = expr;
        const args = this.args(m.args, context);
        const method = subject[m.name];
        if (method) {
          subject = method.apply(subject, args);
        } else {
          subject = this.applyFormatter(subject, m.name, args);
        }
        return subject;
      }
      /**
       * Applies the Formatter to either metaData or value
       * @param {DataPrimitive} subject
       * @param {string} funcName
       * @param {ResolvedValue[]} args
       * @param {string} metaName
       */
      applyFormatter(subject, funcName, args) {
        const FormatterClass = formatterClasses[funcName];
        if (FormatterClass) {
          return new FormatterClass(...args).format(subject);
        }
        throw Error(`No such method or formatter function: '${funcName}'`);
      }
      /**
       * Sometimes when invoking a pipeline we may find degenerate pipelines like
       * '42' that simply set the metadata to a literal. Or, we may perhaps in
       * a value pipeline, we set the value to 'hello' after w perform selection
       * like "selectByPosition(0)|'hello'"
       * @param {DataPrimitive} subject
       * @param {LiteralSymbol} symbol
       */
      applyLiteral(subject, symbol) {
        const { type, v: value } = symbol;
        subject.setValue({ type, value });
      }
      /**
       * reduces method call arguments (ParserSymbols) to actual values
       * @param {ParserSymbol[]} args
       * @param {Scopes} scopes
       * @returns {any[]}
       */
      args(args, context) {
        return args.reduce((acc, cur) => {
          const v = this.getArg(cur, context);
          acc.push(v);
          return acc;
        }, []);
      }
      /**
       * Returns either the literal value from the symbol, or a value from context.
       * Throws error if identifier not found in context.
       * @param {ParserSymbol} s
       * @param {object} context
       * @returns {any}
       */
      getArg(s, context) {
        if (s.type === "identifier") {
          const val = context[s.v];
          if (!val) {
            throw Error(
              `Could not resolve ${s.v} in context. Did you mean one of '[${Object.keys(
                context
              ).toString()}]'`
            );
          }
          return val;
        }
        return s.v;
      }
      /**
       * Simple method to tell if the argument is an object or primitive.
       * @param opt
       * @returns {boolean}
       */
      static isObject(opt) {
        return Object(opt) === opt;
      }
    };
    var SetColorChannel = class extends AbstractFormatter {
      constructor(config) {
        super();
        this.config = EncodingExecutor.rawTree(config);
      }
      formatTypedValue(p) {
        const { value, type } = p.getValue();
        if (type !== "color") {
          return { type, value };
        }
        const channel = (0, lodash_exports.get)(this, "config.channel");
        const v = (0, lodash_exports.get)(this, "config.value");
        if (!channel || value == null) {
          console.warn(
            "SetColorChannel requires channel (ex: hsv.v, rgb.r) and value configuration to be set. It will return the same color when missing."
          );
        }
        try {
          return {
            type: "color",
            value: chroma_js_default(value.toString()).set(channel, v).hex()
          };
        } catch (error) {
          console.warn(error);
          return { type: "color", value };
        }
      }
    };
    init_define_global();
    var Prefix = class extends AbstractFormatter {
      constructor(prefix) {
        super();
        this.prefix = EncodingExecutor.rawTree(prefix);
      }
      formatTypedValue(p) {
        const { value } = p.getValue();
        const prefixedValue = this.prefix + value.toString();
        return { value: prefixedValue, type: "string" };
      }
    };
    init_define_global();
    var MatchValue = class extends AbstractFormatter {
      constructor(matches, defaultValue = void 0) {
        super();
        this.matches = EncodingExecutor.rawTree(matches);
        this.defaultValue = defaultValue === void 0 ? void 0 : setDefaultValue(defaultValue);
      }
      formatTypedValue(input) {
        const { value } = input.getValue();
        const defaultMatchValue = (0, lodash_exports.isUndefined)(this.defaultValue) ? value || "" : this.defaultValue;
        const matchWildcard = (pattern, val) => {
          if (pattern === "*") return true;
          const parts = pattern.split(/\*+/);
          const firstPart = parts[0];
          const lastPart = parts[parts.length - 1];
          if (firstPart && !val.startsWith(firstPart)) return false;
          if (parts.length > 1 && lastPart && !val.endsWith(lastPart)) return false;
          let currentIndex = firstPart.length;
          for (let i = 1; i < parts.length - 1; i += 1) {
            const part = parts[i];
            currentIndex = val.indexOf(part, currentIndex);
            if (currentIndex === -1) return false;
            currentIndex += part.length;
          }
          return true;
        };
        const matchNumber = (m) => isNumber(value) && isNumber(m.match) && parseFloat(m.match) === parseFloat(value);
        const matchFunc = (m) => {
          if (m.match === 0 && (value === 0 || Number(value) === 0)) return true;
          if (m.match === null && value === null) return true;
          if (!m || !m.match) return false;
          if (typeof m.match === "string") {
            if (value === null && m.match !== "*") return false;
            if (m.match.includes("*")) {
              return matchWildcard(m.match, value == null ? void 0 : value.toString());
            }
            return m.match === value;
          }
          return matchNumber(m);
        };
        const calculateSpecificity = (pattern) => {
          const collapsedPattern = pattern.replace(/\*+/g, "*");
          const wildcardCount = (collapsedPattern.match(/\*/g) || []).length;
          if (collapsedPattern === "*") {
            return -100;
          }
          return collapsedPattern.length - wildcardCount * 2;
        };
        let bestMatch = null;
        let bestSpecificity = -Infinity;
        let foundExactMatch = false;
        this.matches.forEach((m) => {
          if (foundExactMatch || !matchFunc(m)) return;
          if (m.match === value) {
            bestMatch = m;
            foundExactMatch = true;
            return;
          }
          const specificity = calculateSpecificity(m.match);
          if (specificity > bestSpecificity) {
            bestMatch = m;
            bestSpecificity = specificity;
          }
        });
        const updatedValue = bestMatch !== null ? bestMatch.value : defaultMatchValue;
        const updatedType = getDataTypeForPoint(updatedValue);
        return { value: updatedValue, type: updatedType };
      }
    };
    init_define_global();
    var { hasOwnProperty } = Object.prototype;
    var RangeValue = class extends AbstractFormatter {
      constructor(ranges, defaultValue) {
        super();
        this.ranges = EncodingExecutor.rawTree(ranges);
        this.defaultValue = setDefaultValue(defaultValue);
      }
      formatTypedValue(p) {
        const { type, value } = p.getValue();
        if (type !== "number") {
          console.warn(`type '${type}' with value '${value}' is not a valid input to rangeValue`);
        }
        let rangeValueResult;
        const defaultRangeValue = (0, lodash_exports.isUndefined)(this.defaultValue) && !isNumber(value) ? value : this.defaultValue;
        if (isNumber(value)) {
          const floatValue = parseFloat(value);
          for (let i = 0; i < this.ranges.length; i += 1) {
            if (
              // open upper bound: value is bigger than or equal to open upper bound start (from)
              // if there are several 'from'-only ranges, we look at the first one that satisfies the mapping criteria
              // if there is overlap between a 'from'-only range and an inbetween range, this means that the ranges config is semantically invalid
              // TODO: figure out if we want to enforce a semantically valid config by sorting,
              // or by throwing an error if there are multiple 'from'/'to'-only ranges
              hasOwnProperty.call(this.ranges[i], "from") && !hasOwnProperty.call(this.ranges[i], "to") && floatValue >= this.ranges[i].from || // inbetween: value falls into from (inclusive) - to (exclusive) range
              floatValue >= this.ranges[i].from && floatValue < this.ranges[i].to || hasOwnProperty.call(this.ranges[i], "to") && !hasOwnProperty.call(this.ranges[i], "from") && floatValue < this.ranges[i].to
            ) {
              rangeValueResult = this.ranges[i].value;
              break;
            }
          }
        }
        const updatedValue = (0, lodash_exports.isUndefined)(rangeValueResult) ? defaultRangeValue : rangeValueResult;
        const updatedType = getDataTypeForPoint(updatedValue);
        return { type: updatedType, value: updatedValue };
      }
    };
    init_define_global();
    var DEFAULT_MIN_COLOR = "rgba(123,86,219,0.4)";
    var DEFAULT_MAX_COLOR = "rgba(123,86,219,1)";
    var _Gradient = class _Gradient2 extends AbstractFormatter {
      constructor(config) {
        super();
        this.config = EncodingExecutor.rawTree(config) || {};
        this.colors = this.config.colors || [];
        this.stops = this.config.stops || [];
        if (!Array.isArray(this.colors) || !Array.isArray(this.stops)) {
          throw new Error("Gradient config: both 'colors' and 'stops' in should be 1D array.");
        }
        this.colors.forEach((c) => {
          if (!isColor(c)) {
            throw new Error("Gradient config: every element in 'colors' should be a color.");
          }
        });
        _Gradient2.sortArray(this.stops);
      }
      prepareColorsAndStopsSeries(series) {
        const colorsLength = this.colors.length;
        const stopsLength = this.stops.length;
        const min = Number(series.min().getRawValue());
        const max = Number(series.max().getRawValue());
        let newColors = [DEFAULT_MIN_COLOR, DEFAULT_MAX_COLOR];
        if (stopsLength === 0) {
          if (colorsLength > 2) {
            const newStops2 = [];
            for (let i = 0; i < colorsLength; i += 1) {
              newStops2.push(min + (max - min) * i / (colorsLength - 1));
            }
            return { newStops: newStops2, newColors: this.colors };
          }
          this.colors.forEach((c, i) => {
            newColors[i] = c;
          });
          return {
            newStops: [min, max],
            newColors
          };
        }
        const newStops = [...this.stops];
        newStops.unshift(min);
        newStops.push(max);
        if (colorsLength === 0) {
          if (stopsLength === 1) {
            newColors = [DEFAULT_MIN_COLOR, DEFAULT_MAX_COLOR, DEFAULT_MAX_COLOR];
          } else if (stopsLength === 2) {
            newColors = [DEFAULT_MIN_COLOR, DEFAULT_MIN_COLOR, DEFAULT_MAX_COLOR, DEFAULT_MAX_COLOR];
          } else {
            throw new Error("Gradient config: provide at most two stops when colors is empty.");
          }
          _Gradient2.ignoreMinMaxWhenNeeded(min, max, this.stops, newStops, newColors);
          return {
            newStops,
            newColors
          };
        }
        if (stopsLength + 2 >= colorsLength) {
          newColors = [...this.colors];
          if (stopsLength >= colorsLength) {
            newColors.unshift(DEFAULT_MIN_COLOR);
          }
          _Gradient2.addDefaultEndingColors(newColors, stopsLength + 2 - newColors.length);
          _Gradient2.ignoreMinMaxWhenNeeded(min, max, this.stops, newStops, newColors);
          if (newStops.length !== newColors.length) {
            throw new Error("Gradient config: not equal length of stops and colors.");
          }
          return {
            newStops,
            newColors
          };
        }
        throw new Error("Gradient config: too many colors set for the given stops.");
      }
      prepareColorsAndStopsPoint(value) {
        let newStops = this.stops;
        let newColors = this.colors;
        if (this.stops.length === 0) {
          newStops = [0, 1];
        }
        if (this.colors.length === 0) {
          newColors = [DEFAULT_MIN_COLOR, DEFAULT_MAX_COLOR];
        }
        if (this.stops.length === this.colors.length && this.stops.length === 1 && value < this.stops[0]) {
          newColors = [DEFAULT_MIN_COLOR, ...this.colors];
        }
        return { newStops, newColors };
      }
      formatTypedValue(p, series) {
        const input = p.getValue();
        const { type, value } = input;
        if (type !== "number") {
          throw new Error(`Type '${type}' with value '${value}' is not a valid input to gradient`);
        }
        const isDataSeries = series && series.points && series.points.length;
        const { newStops, newColors } = isDataSeries ? this.prepareColorsAndStopsSeries(series) : this.prepareColorsAndStopsPoint(value);
        let interpolateColor;
        const isBeyondUpperBound = value > newStops[newStops.length - 1];
        const isBeyondLowerBound = value < newStops[0];
        if (isBeyondUpperBound || isBeyondLowerBound) {
          const index = isBeyondUpperBound ? newColors.length - 1 : 0;
          interpolateColor = chroma_js_default(newColors[index]).hex().toUpperCase();
          return { type: "color", value: interpolateColor };
        }
        for (let i = 1; i < newStops.length; i += 1) {
          if (Number.isNaN(Number(newStops[i]))) {
            console.warn(
              "Could not format gradient color: stops are required to be numbers. Falling back to first color."
            );
            interpolateColor = chroma_js_default(newColors[0]).hex().toUpperCase() || "#000";
            return { type: "color", value: interpolateColor };
          }
          const upperVal = newStops[i];
          if (value <= upperVal) {
            const lowerVal = newStops[i - 1];
            let tau = 0;
            if (upperVal === lowerVal) {
              tau = value === 0 ? 0 : 1;
            } else {
              tau = (value - lowerVal) / (upperVal - lowerVal);
            }
            interpolateColor = chroma_js_default.scale([newColors[i - 1], newColors[i]])(tau).hex().toUpperCase();
            return { type: "color", value: interpolateColor };
          }
        }
        console.warn(`Could not format value for gradient: ${value}`);
        interpolateColor = chroma_js_default(newColors[0]).hex().toUpperCase() || "#000";
        return { type: "color", value: interpolateColor };
      }
    };
    _Gradient.sortArray = (array) => {
      array.sort((a, b) => a - b);
    };
    _Gradient.addDefaultEndingColors = (colors, n) => {
      for (let i = 0; i < n; i += 1) {
        colors.push(DEFAULT_MAX_COLOR);
      }
    };
    _Gradient.ignoreMinMaxWhenNeeded = (min, max, stops, newStops, newColors) => {
      if (min >= stops[0]) {
        newStops.shift();
        newColors.shift();
      }
      if (max <= stops[stops.length - 1]) {
        newStops.pop();
        newColors.pop();
      }
    };
    var Gradient = _Gradient;
    init_define_global();
    var Pick = class extends AbstractFormatter {
      constructor(formatConfig) {
        super();
        this.config = EncodingExecutor.rawTree(formatConfig);
      }
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      formatTypedValue(p, s, i = 0, j = 0) {
        let val;
        if (Array.isArray(this.config)) {
          val = this.config[j % this.config.length];
        } else {
          val = this.config[s.field];
        }
        return TypeSafeValue.fromRaw(val);
      }
    };
    init_define_global();
    var Type = class extends AbstractFormatter {
      formatTypedValue(p) {
        if (p && p.getRawValue() === null) {
          return TypeSafeValue.from({ type: "string", value: "null" });
        }
        return TypeSafeValue.fromRaw(p.getType());
      }
    };
    init_define_global();
    var numbro_exports = {};
    __export2(numbro_exports, {
      default: () => numbro_default
    });
    init_define_global();
    var defaultImport6 = __toESM2(require_numbro_min());
    __reExport(numbro_exports, require_numbro_min());
    var numbro_default = "default" in defaultImport6 ? defaultImport6.default : defaultImport6;
    var formatNumber = (number, config) => {
      const mappedConfig = {
        prefix: !(0, lodash_exports.isEmpty)(config.unit) && config.unitPosition === "before" ? `${config.unit} ` : void 0,
        postfix: !(0, lodash_exports.isEmpty)(config.unit) && config.unitPosition !== "before" ? ` ${config.unit}` : void 0,
        mantissa: typeof config.precision === "number" ? config.precision : void 0
      };
      const c = (0, lodash_exports.defaultsDeep)(
        {},
        (0, lodash_exports.omitBy)(mappedConfig, lodash_exports.isUndefined),
        (0, lodash_exports.omit)(config, ["unit", "unitPosition", "precision"])
      );
      return numbro_default(number).format(c);
    };
    var formatString = (string, config) => {
      if (!(0, lodash_exports.isEmpty)(config.unit)) {
        return config.unitPosition === "before" ? `${config.unit} ${string}` : `${string} ${config.unit}`;
      }
      return `${string}`;
    };
    var formatTime = (dateString, defaultValue, config) => {
      if (typeof config.format === "string" && !(0, lodash_exports.isEmpty)(config.format)) {
        return formatTimeWithTimezoneCorrection(dateString, config.format);
      }
      return defaultValue.toString();
    };
    var FormatByType = class extends AbstractFormatter {
      constructor(config) {
        super();
        this.config = {
          number: {},
          string: {},
          time: { format: "" }
        };
        this.config = (0, lodash_exports.defaultsDeep)({}, config, this.config);
      }
      formatTypedValue(p) {
        const { number: numberConfig, string: stringConfig, time: timeConfig } = this.config;
        const value = p.getValue();
        switch (value.type) {
          case "number":
            return new TypeSafeValue(
              "string",
              formatNumber(p.getRawValue(), numberConfig),
              value.value
            );
          case "string":
            return new TypeSafeValue("string", formatString(value.value, stringConfig), value.value);
          case "time":
            return new TypeSafeValue(
              "string",
              formatTime(value.coercedValue, value.value, timeConfig),
              value.value
            );
          default:
            return p.getValue();
        }
      }
    };
    init_define_global();
    var Frame = class {
      constructor(...args) {
        this.args = [];
        this.args = args.map(
          (a) => isDataPrimitive(a) ? a : Helper.dataPrimitiveFromRaw(EncodingExecutor.rawTree(a))
        );
      }
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      format(ignored) {
        let series = [];
        this.args.forEach((dataPrim) => {
          if (DataSeries.isDataSeries(dataPrim)) {
            series.push(dataPrim);
          } else if (DataFrame.isDataFrame(dataPrim)) {
            series = series.concat(dataPrim.series);
          } else if (DataPoint.isDataPoint(dataPrim)) {
            series.push(new DataSeries([dataPrim]));
          } else {
            throw new Error(`frame formatter args incorrect`);
          }
        });
        return new DataFrame(series);
      }
    };
    init_define_global();
    var Prepend = class {
      constructor(d) {
        this.prependMe = isDataPrimitive(d) ? d : Helper.dataPrimitiveFromRaw(EncodingExecutor.rawTree(d));
      }
      format(subject) {
        if (DataFrame.isDataFrame(subject)) {
          return this.prependToFrame(subject);
        }
        if (DataSeries.isDataSeries(subject)) {
          return this.prependToSeries(subject);
        }
        throw new Error(`Can only prepend to DataFrame or DataSeries`);
      }
      prependToFrame(subject) {
        if (DataFrame.isDataFrame(this.prependMe)) {
          return this.prependFrameToFrame(subject);
        }
        if (DataSeries.isDataSeries(this.prependMe)) {
          return this.prependASeriesToEachSeriesOfFrame(subject);
        }
        if (DataPoint.isDataPoint(this.prependMe)) {
          return this.prependAPointToEachSeriesOfFrame(subject);
        }
        throw new Error(`'prepend' formatter only accepts DataFrame, DataSeries, or DataPoint as argument`);
      }
      prependToSeries(subject) {
        if (DataFrame.isDataFrame(this.prependMe)) {
          throw new Error("cannot prepend a DataFrame to a DataSeries");
        } else if (DataSeries.isDataSeries(this.prependMe)) {
          return this.prependSeriesToSeries(subject, this.prependMe);
        } else if (DataPoint.isDataPoint(this.prependMe)) {
          return this.prependPointToSeries(subject);
        }
        throw new Error(`'prepend' to series formatter only DataSeries, or DataPoint as argument`);
      }
      prependAPointToEachSeriesOfFrame(dp) {
        return new DataFrame(dp.series.map((s) => this.prependPointToSeries(s)));
      }
      prependASeriesToEachSeriesOfFrame(frame) {
        return new DataFrame(
          frame.series.map((s) => this.prependSeriesToSeries(s, this.prependMe))
        );
      }
      prependFrameToFrame(frame) {
        const numSeries1 = this.prependMe.series.length;
        const numSeries2 = frame.series.length;
        if (numSeries1 !== numSeries2) {
          throw new Error(
            `can't prepend a frame with ${numSeries1} columns to a field with ${numSeries2} columns`
          );
        }
        return new DataFrame(
          frame.series.map(
            (s, i) => this.prependSeriesToSeries(s, this.prependMe.seriesByIndex(i))
          )
        );
      }
      prependSeriesToSeries(series, prependMe) {
        const { field } = series;
        const type1 = series.points.length > 0 ? series.points[0].getValue().type : void 0;
        const type2 = prependMe.points.length > 0 ? prependMe.points[0].getValue().type : void 0;
        if (type1 && type2 && type1 !== type2) {
          throw new Error(`cannot prepend ${type2} to ${type1}`);
        }
        return new DataSeries(
          prependMe.points.map((p) => new DataPoint(field, p.getValue())).concat(series.points)
        );
      }
      prependPointToSeries(s) {
        const { field } = s;
        const typedValue = s.firstPoint().getValue();
        const type1 = typedValue.type;
        const typedValue2 = this.prependMe.getValue();
        const type2 = typedValue2.type;
        if (type1 !== type2) {
          throw new Error(`cannot prepend point of type ${type2} to series of type ${type1}`);
        }
        const newPoint = new DataPoint(field, typedValue2);
        return new DataSeries([newPoint, ...s.points]);
      }
    };
    init_define_global();
    var Objects = class {
      constructor(objectConfig) {
        this.config = EncodingExecutor.rawTree(objectConfig);
      }
      format(dp) {
        if (DataFrame.isDataFrame(dp)) {
          const mergedObjectSeries = this.seriesToObjects(dp.series[0]);
          for (let i = 1; i < dp.series.length; i += 1) {
            const mergeMeIn = this.seriesToObjects(dp.series[i]);
            for (let j = 0; j < mergedObjectSeries.length; j += 1) {
              mergedObjectSeries[j] = (0, lodash_exports.merge)(mergedObjectSeries[j], mergeMeIn[j]);
            }
          }
          return mergedObjectSeries;
        }
        if (DataSeries.isDataSeries(dp)) {
          return this.seriesToObjects(dp);
        }
        if (DataPoint.isDataPoint(dp)) {
          return [{ [dp.field]: dp.getRawValue() }];
        }
        throw new Error(`'objects' formatter only allowed on DataFrame, DataPoint, or DataSeries`);
      }
      seriesToObjects(s) {
        return s.points.reduce((acc, pt) => {
          let key = pt.field;
          if (this.config && this.config.rename) {
            key = this.config.rename[key] || key;
          }
          acc.push({ [key]: pt.getRawValue() });
          return acc;
        }, []);
      }
    };
    init_define_global();
    var MultiFormat = class {
      constructor(formatConfig) {
        this.config = EncodingExecutor.rawTree(formatConfig);
      }
      format(f) {
        const namesDataSeries = f.seriesByName(this.config.nameField);
        const valuesDataSeries = f.seriesByName(this.config.valueField);
        return namesDataSeries.points.map((name, i) => {
          const { type, config } = this.config.formatters[name.getRawValue()];
          const FormatterClass = formatterClasses[type];
          const value = valuesDataSeries.pointByIndex(i);
          if (!FormatterClass) {
            throw new Error(`unknown formatter type "${type}" was specified`);
          }
          return new FormatterClass(config).format(value, valuesDataSeries);
        });
      }
    };
    init_define_global();
    var MaxContrast = class extends AbstractFormatter {
      constructor(config) {
        super();
        this.config = EncodingExecutor.rawTree(config);
      }
      formatTypedValue(p) {
        const { value, type } = p.getValue();
        if (type !== "color" || !isColor(value)) {
          return { type, value };
        }
        const colorConfig = (0, lodash_exports.get)(this, "config.colors");
        const defaultColor = (0, lodash_exports.get)(this, "config.default");
        if (!Array.isArray(colorConfig) || colorConfig.length === 0) {
          return isColor(defaultColor) ? { type: "color", value: defaultColor } : { type, value };
        }
        if (value === "transparent" && isColor(defaultColor)) {
          return { type: "color", value: defaultColor };
        }
        try {
          return {
            type: "color",
            value: (0, lodash_exports.chain)(colorConfig).map((c) => ({
              color: c,
              contrast: chroma_js_default.contrast(value, c)
            })).maxBy("contrast").value().color
          };
        } catch (error) {
          console.warn(error);
          return { type: "color", value: defaultColor || value };
        }
      }
    };
    init_define_global();
    init_define_global();
    var Default = class extends AbstractFormatter {
      constructor(val) {
        super();
        this.defaultVal = EncodingExecutor.rawTree(val);
      }
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      formatTypedValue(p, s, i = 0, j = 0) {
        if (p.getRawValue() === void 0) {
          return TypeSafeValue.fromRaw(this.defaultVal);
        }
        return p.getValue();
      }
    };
    var RenameSeries = class extends Default {
      constructor(name) {
        super(name);
        this.newFieldName = name;
      }
      formatPoint(p, s, i = 0, j = 0) {
        return i === 0 && typeof this.newFieldName === "string" && this.newFieldName.length > 0 ? new DataPoint(this.newFieldName, this.formatTypedValue(p, s, i, j)) : super.formatPoint(p, s, i, j);
      }
    };
    init_define_global();
    var DivideBy = class extends AbstractFormatter {
      constructor(divisor) {
        super();
        this.divisor = EncodingExecutor.rawTree(divisor);
      }
      formatTypedValue(p) {
        const { value } = p.getValue();
        const dividedValue = this.divisor !== 0 && value / this.divisor;
        return { value: dividedValue, type: "number" };
      }
    };
    init_define_global();
    var Subtract = class extends AbstractFormatter {
      constructor(valToSubtract) {
        super();
        this.valToSubtract = EncodingExecutor.rawTree(valToSubtract);
      }
      formatTypedValue(p) {
        const { value } = p.getValue();
        const difference = this.valToSubtract !== 0 && value - this.valToSubtract;
        return { value: difference, type: "number" };
      }
    };
    var formatterClasses = {
      gradient: Gradient,
      matchValue: MatchValue,
      prefix: Prefix,
      rangeValue: RangeValue,
      pick: Pick,
      multiFormat: MultiFormat,
      type: Type,
      formatByType: FormatByType,
      frame: Frame,
      prepend: Prepend,
      objects: Objects,
      setColorChannel: SetColorChannel,
      maxContrast: MaxContrast,
      renameSeries: RenameSeries,
      divideBy: DivideBy,
      subtract: Subtract
    };
    init_define_global();
    init_define_global();
    var DataFrameLite = class extends DataFrame {
      /**
       * Loads ColumnarData into a DataFrame
       * DataFrame contains DataSeries but without DataPoints
       * @param {ColumnarData} columnarData
       * @returns {DataFrame<T>}
       */
      static fromJsonCols(columnarData) {
        if (!(columnarData == null ? void 0 : columnarData.data)) {
          return new DataFrame([]);
        }
        const {
          data: { fields = [], columns = [] }
        } = columnarData;
        if (columns.length !== fields.length) {
          throw new Error(
            `number of columns (${columns.length}) does not match number of fields (${fields.length})`
          );
        }
        const dataSeries = [];
        columns.forEach((data, idx) => {
          const fieldInfo = fields[idx];
          const field = fieldInfo.name || fieldInfo;
          const type = fieldInfo == null ? void 0 : fieldInfo.type;
          dataSeries.push(new DataSeriesLite(data, type, field));
        });
        return new DataFrame(dataSeries);
      }
    };
    var Options = class _Options {
      /**
       * Takes the options stanza and the dataSources, and returns a simple properties object. Any options
       * that were expressions are evaluated. The resulting object is suitable to pass to a pure viz as props.
       * @param {OptionsStanza} options
       * @param dataSources
       * @param themeFunc
       * @returns {object}
       */
      static evaluate(options, dataSources, themeFunc, dataFramesIn, bypassCloneDeepOptionScope, lazyLoadingDataFrame) {
        let dataFrames;
        if (dataFramesIn) {
          dataFrames = dataFramesIn;
        } else {
          dataFrames = _Options.dataFrameFromDataSource(dataSources, lazyLoadingDataFrame);
        }
        return new EncodingExecutor().executeOptions(
          options,
          dataFrames,
          themeFunc,
          bypassCloneDeepOptionScope
        );
      }
      static dataFrameFromDataSource(dataSources, lazyLoadingDataFrame) {
        if (lazyLoadingDataFrame) {
          return (0, lodash_exports.mapValues)(dataSources, (ds) => DataFrameLite.fromJsonCols(ds));
        }
        return (0, lodash_exports.mapValues)(dataSources, (ds) => DataFrame.fromJsonCols(ds));
      }
    };
    var supportedFormatters = Object.keys(formatterClasses);
    var isFormatter = (str) => supportedFormatters.indexOf(str) !== -1;
    var getDataSelectorsFromDSL = (dslString) => {
      const ast = EncodingParser.parseOptions({
        options: {
          value: dslString
        },
        context: {}
      });
      return (0, lodash_exports.get)(ast, ["expressions", "value"], []).filter((expression) => !(expression.type === "method" && isFormatter(expression.name))).map((expression) => {
        if (expression.type !== "method") {
          return `${expression.v}`;
        }
        return `${expression.name}(${(0, lodash_exports.get)(expression, "args", []).map((arg) => arg.v).join(",")})`;
      });
    };
    var getFormattersFromDSL = (dslString) => {
      const ast = EncodingParser.parseOptions({
        options: {
          value: dslString
        },
        context: {}
      });
      return (0, lodash_exports.get)(ast, ["expressions", "value"], []).filter((expression) => expression.type === "method" && isFormatter(expression.name)).map(
        (expression) => ({
          type: expression.name,
          paramKey: (0, lodash_exports.get)(expression, ["args", "0", "v"], "")
        })
      );
    };
    var getLastFormatterFromDSL = (dslString) => {
      return (0, lodash_exports.last)(getFormattersFromDSL(dslString));
    };
    var buildDSLFromDataSelectorAndFormatter = (dataSelector, formatter, formatterParamKey = "") => {
      const extractedFormatterKey = formatterParamKey.replace(/^\w+\[\d+\]\.(.+)$/, "$1");
      return `> ${dataSelector} | ${formatter}(${extractedFormatterKey})`;
    };
    var getFieldsFromDSL = (dsl, dataSources, vizOptions = {}, vizContext = {}) => {
      try {
        const { evalFields } = Options.evaluate(
          {
            context: vizContext,
            options: __spreadProps(__spreadValues({}, vizOptions), {
              evalFields: `${dsl} | getField()`
            })
          },
          dataSources,
          () => {
          }
        );
        if (Array.isArray(evalFields)) {
          return evalFields.filter((field) => field.length > 0);
        }
        if (evalFields.length !== 0) {
          return [evalFields];
        }
      } catch (e) {
      }
      return [];
    };
    var getDataTypesFromDSL = (dsl, dataSources, vizOptions = {}, vizContext = {}) => {
      try {
        const { dataTypes } = Options.evaluate(
          {
            context: vizContext,
            options: __spreadProps(__spreadValues({}, vizOptions), {
              dataTypes: `${dsl} | getType()`
            })
          },
          dataSources,
          () => {
          }
        );
        if (Array.isArray(dataTypes)) {
          return [...new Set(dataTypes)];
        }
        if (dataTypes.length !== 0) {
          return [dataTypes];
        }
      } catch (e) {
      }
      return [];
    };
  }
});

// node_modules/@splunk/visualization-encoding/utils/deepMergeWithArrayPrimitiveOverrides.js
var require_deepMergeWithArrayPrimitiveOverrides = __commonJS({
  "node_modules/@splunk/visualization-encoding/utils/deepMergeWithArrayPrimitiveOverrides.js"(exports2, module2) {
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var __create = Object.create;
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __getProtoOf = Object.getPrototypeOf;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
    var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
      // If the importer is in node compatibility mode or this is not an ESM
      // file that has been converted to a CommonJS file using a Babel-
      // compatible transform (i.e. "__esModule" has not been set), then set
      // "default" to the CommonJS "module.exports" for node compatibility.
      isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
      mod
    ));
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var deepMergeWithArrayPrimitiveOverrides_exports = {};
    __export2(deepMergeWithArrayPrimitiveOverrides_exports, {
      deepMergeWithArrayPrimitiveOverrides: () => deepMergeWithArrayPrimitiveOverrides
    });
    module2.exports = __toCommonJS2(deepMergeWithArrayPrimitiveOverrides_exports);
    var lodash_exports = {};
    __export2(lodash_exports, {
      default: () => lodash_default
    });
    var defaultImport = __toESM2(require_lodash());
    __reExport(lodash_exports, require_lodash());
    var lodash_default = "default" in defaultImport ? defaultImport.default : defaultImport;
    var findClosestMatchFromDefaultList = (searchList, inputObj) => {
      if (!Array.isArray(searchList) || searchList.length === 0) {
        return -1;
      }
      const keys = Object.keys(inputObj);
      let maxMatchCnt = 0;
      let maxMatchIdx = 0;
      searchList.forEach((item, idx) => {
        let matchCnt = 0;
        keys.forEach((key) => {
          if (item[key] === inputObj[key]) {
            matchCnt += 1;
          }
        });
        if (Math.max(maxMatchCnt, matchCnt) > maxMatchCnt) {
          maxMatchCnt = matchCnt;
          maxMatchIdx = idx;
        }
      });
      return maxMatchIdx;
    };
    var deepMergeWithArrayPrimitiveOverrides = (initial, ...sources) => {
      const clone = (0, lodash_exports.cloneDeep)(initial);
      sources.forEach((sourceToApply) => {
        Object.keys(sourceToApply).forEach((sourceKey) => {
          if (!Object.prototype.hasOwnProperty.call(clone, sourceKey)) {
            clone[sourceKey] = (0, lodash_exports.cloneDeep)(sourceToApply[sourceKey]);
          }
          if (clone[sourceKey] && typeof clone[sourceKey] === "object" && !Array.isArray(clone[sourceKey]) && typeof sourceToApply[sourceKey] === "object") {
            clone[sourceKey] = deepMergeWithArrayPrimitiveOverrides(
              clone[sourceKey],
              sourceToApply[sourceKey]
            );
          } else if (Array.isArray(clone[sourceKey]) && typeof clone[sourceKey][0] === "object" && !Array.isArray(clone[sourceKey][0])) {
            for (let i = 0; i < clone[sourceKey].length; i += 1) {
              if (typeof clone[sourceKey][i] === "object") {
                const closestMatchIdx = findClosestMatchFromDefaultList(
                  sourceToApply[sourceKey],
                  clone[sourceKey][i]
                );
                if (closestMatchIdx > -1) {
                  clone[sourceKey][i] = deepMergeWithArrayPrimitiveOverrides(
                    clone[sourceKey][i],
                    sourceToApply[sourceKey][closestMatchIdx]
                  );
                }
              }
            }
          }
        });
      });
      return clone;
    };
  }
});

// node_modules/@splunk/visualization-migrations/index.js
var require_visualization_migrations = __commonJS({
  "node_modules/@splunk/visualization-migrations/index.js"(exports2, module2) {
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var __create = Object.create;
    var __defProp = Object.defineProperty;
    var __defProps = Object.defineProperties;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __getOwnPropSymbols = Object.getOwnPropertySymbols;
    var __getProtoOf = Object.getPrototypeOf;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __propIsEnum = Object.prototype.propertyIsEnumerable;
    var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
    var __spreadValues = (a, b) => {
      for (var prop in b || (b = {}))
        if (__hasOwnProp.call(b, prop))
          __defNormalProp(a, prop, b[prop]);
      if (__getOwnPropSymbols)
        for (var prop of __getOwnPropSymbols(b)) {
          if (__propIsEnum.call(b, prop))
            __defNormalProp(a, prop, b[prop]);
        }
      return a;
    };
    var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
    var __objRest = (source, exclude) => {
      var target = {};
      for (var prop in source)
        if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
          target[prop] = source[prop];
      if (source != null && __getOwnPropSymbols)
        for (var prop of __getOwnPropSymbols(source)) {
          if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
            target[prop] = source[prop];
        }
      return target;
    };
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
    var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
      // If the importer is in node compatibility mode or this is not an ESM
      // file that has been converted to a CommonJS file using a Babel-
      // compatible transform (i.e. "__esModule" has not been set), then set
      // "default" to the CommonJS "module.exports" for node compatibility.
      isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
      mod
    ));
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export2(src_exports, {
      canMigrate: () => canMigrate,
      encodingToDynamicOptionsDSL: () => encodingToDynamicOptionsDSL,
      inferToType: () => inferToType,
      migrate: () => migrate
    });
    module2.exports = __toCommonJS2(src_exports);
    var visualization_schemas_exports = {};
    __export2(visualization_schemas_exports, {
      default: () => visualization_schemas_default
    });
    var defaultImport = __toESM2(require_cjs());
    __reExport(visualization_schemas_exports, require_cjs());
    var visualization_schemas_default = "default" in defaultImport ? defaultImport.default : defaultImport;
    var parserUtils_exports = {};
    __export2(parserUtils_exports, {
      default: () => parserUtils_default
    });
    var defaultImport2 = __toESM2(require_parserUtils());
    __reExport(parserUtils_exports, require_parserUtils());
    var parserUtils_default = "default" in defaultImport2 ? defaultImport2.default : defaultImport2;
    var indexBasedRegx = /^[A-Za-z0-9_]+\[.*\].*$/;
    var nameBasedRegx = /^[A-Za-z0-9_]+\..*$/;
    var isIndexBasedReference = (ref) => indexBasedRegx.test(ref);
    var isNameBasedReference = (ref) => nameBasedRegx.test(ref);
    var convertFormatterToDSL = (fieldReference, key, translatedValue) => {
      var _a, _b, _c, _d, _e, _f;
      switch ((_a = fieldReference == null ? void 0 : fieldReference.format) == null ? void 0 : _a.type) {
        case "gradient":
          return {
            contextConfig: __spreadValues(__spreadValues({}, Array.isArray((_b = fieldReference.format) == null ? void 0 : _b.ranges) && {
              stops: [...fieldReference.format.ranges]
            }), Array.isArray((_c = fieldReference.format) == null ? void 0 : _c.values) && {
              colors: [...fieldReference.format.values]
            }),
            contextKey: `${key}GradientContext`,
            dsl: `${translatedValue} | gradient(${key}GradientContext)`
          };
        case "rangevalue": {
          const contextKey = `${key}RangeValueContext`;
          return {
            contextConfig: ((_d = fieldReference.format) == null ? void 0 : _d.ranges) || [],
            contextKey,
            dsl: `${translatedValue} | rangeValue(${contextKey})`
          };
        }
        case "matchvalue": {
          const defaultValue = (_e = fieldReference.format) == null ? void 0 : _e.defaultValue;
          const matchValueContextKey = `${key}MatchValueContext`;
          return {
            contextConfig: ((_f = fieldReference.format) == null ? void 0 : _f.matches) || [],
            contextKey: matchValueContextKey,
            dsl: `${translatedValue} | matchValue(${matchValueContextKey}${defaultValue !== null && defaultValue !== void 0 ? `, ${typeof defaultValue === "string" ? `"${defaultValue}"` : defaultValue}` : ""})`
          };
        }
        default:
          break;
      }
      return null;
    };
    var translateArrayFormatDataReference = (encodingDataReference) => {
      if (encodingDataReference.length === 0) {
        return null;
      }
      const allIndexBased = encodingDataReference.every(isIndexBasedReference);
      const allNameBased = encodingDataReference.every(isNameBasedReference);
      if (allIndexBased) {
        const { dataSourceName: dataSourceName2 } = (0, parserUtils_exports.parseIndexBasedFieldReference)(encodingDataReference[0]);
        const indexesStr = encodingDataReference.map((ref) => {
          var _a;
          return (_a = (0, parserUtils_exports.parseIndexBasedFieldReference)(ref)) == null ? void 0 : _a.fieldIndex;
        }).join(",");
        return `> ${dataSourceName2} | frameBySeriesIndexes(${indexesStr})`;
      }
      if (allNameBased) {
        const { dataSourceName: dataSourceName2 } = (0, parserUtils_exports.parseNameBasedFieldReference)(encodingDataReference[0]);
        const namesStr = encodingDataReference.map((ref) => {
          var _a;
          return `"${(_a = (0, parserUtils_exports.parseNameBasedFieldReference)(ref)) == null ? void 0 : _a.fieldName}"`;
        }).join(",");
        return `> ${dataSourceName2} | frameBySeriesNames(${namesStr})`;
      }
      const firstEntry = encodingDataReference[0];
      const { dataSourceName } = isIndexBasedReference(firstEntry) ? (0, parserUtils_exports.parseIndexBasedFieldReference)(firstEntry) : (0, parserUtils_exports.parseNameBasedFieldReference)(firstEntry);
      const paramStr = encodingDataReference.map((ref) => {
        var _a, _b;
        return isIndexBasedReference(ref) ? (_a = (0, parserUtils_exports.parseIndexBasedFieldReference)(ref)) == null ? void 0 : _a.fieldIndex : `"${(_b = (0, parserUtils_exports.parseNameBasedFieldReference)(ref)) == null ? void 0 : _b.fieldName}"`;
      }).join(",");
      return `> ${dataSourceName} | frameBySeriesNamesOrIndexes(${paramStr})`;
    };
    var translateDataReference = (encodingDataReference) => {
      if (encodingDataReference.indexOf("encoding.") === 0) {
        return `> ${encodingDataReference.replace("encoding.", "")}`;
      }
      const isIndexBasedRef = isIndexBasedReference(encodingDataReference);
      const isNameBasedRef = isNameBasedReference(encodingDataReference);
      if (!isIndexBasedRef && !isNameBasedRef) {
        console.warn("Unable to parse the encoding. Please verify the encoding format is correct");
        return null;
      }
      if (isNameBasedRef) {
        const { dataSourceName, fieldName, columnIndex } = (0, parserUtils_exports.parseNameBasedFieldReference)(encodingDataReference);
        let returnString = `> ${dataSourceName} | seriesByName("${fieldName}")`;
        if (columnIndex) {
          returnString += ` | pointByIndex(${columnIndex})`;
        }
        return returnString;
      }
      if (isIndexBasedRef) {
        const { dataSourceName, fieldIndex, columnIndex, isFieldIndexRange, fromFieldIndex, toFieldIndex } = (0, parserUtils_exports.parseIndexBasedFieldReference)(encodingDataReference);
        if (isFieldIndexRange) {
          let dslToIndexString;
          if (toFieldIndex === -1) {
            dslToIndexString = "";
          } else {
            dslToIndexString = `,${toFieldIndex + 1}`;
          }
          return `> ${dataSourceName} | frameBySeriesIndexRange(${fromFieldIndex}${dslToIndexString})`;
        }
        let returnString = `> ${dataSourceName} | seriesByIndex(${fieldIndex})`;
        if (columnIndex) {
          returnString += ` | pointByIndex(${columnIndex})`;
        }
        return returnString;
      }
      return null;
    };
    var encodingToDynamicOptionsDSL = (encoding) => {
      const dynamicOptions = {
        options: {},
        context: {}
      };
      const translatedOptions = {};
      const encodingObj = encoding != null ? encoding : {};
      Object.keys(encodingObj).forEach((key) => {
        const fieldReference = encoding[key];
        let fieldReferenceStr = fieldReference;
        if (typeof fieldReference === "object" && !Array.isArray(fieldReference)) {
          const { field } = fieldReference;
          if (field && !Array.isArray(field)) {
            fieldReferenceStr = field;
          }
        }
        let translatedValue;
        if (Array.isArray(fieldReference)) {
          translatedValue = translateArrayFormatDataReference(fieldReference);
        } else {
          translatedValue = translateDataReference(fieldReferenceStr);
        }
        if (translatedValue) {
          translatedOptions[key] = translatedValue;
          const convertedFormatterObject = convertFormatterToDSL(
            fieldReference,
            key,
            translatedValue
          );
          if (convertedFormatterObject) {
            translatedOptions[key] = convertedFormatterObject.dsl;
            dynamicOptions.context[convertedFormatterObject.contextKey] = convertedFormatterObject.contextConfig;
          }
        }
      });
      dynamicOptions.options = translatedOptions;
      return dynamicOptions;
    };
    var optionRenames = {
      "axisTitleX.text": "xAxisTitleText",
      "axisTitleY.text": "yAxisTitleText",
      "axisTitleY2.text": "y2AxisTitleText",
      "axisTitleX.visibility": "xAxisTitleVisibility",
      "axisTitleY.visibility": "yAxisTitleVisibility",
      "axisTitleY2.visibility": "y2AxisTitleVisibility",
      "axisLabelsX.majorLabelStyle.rotation": "xAxisLabelRotation",
      "axisLabelsX.majorLabelVisibility": "xAxisLabelVisibility",
      "axisLabelsY.majorLabelVisibility": "yAxisLabelVisibility",
      "axisLabelsY2.majorLabelVisibility": "y2AxisLabelVisibility",
      "axisLabelsX.majorTickVisibility": "xAxisMajorTickVisibility",
      "axisLabelsY.majorTickVisibility": "yAxisMajorTickVisibility",
      "axisLabelsY2.majorTickVisibility": "y2AxisMajorTickVisibility",
      "axisLabelsX.minorTickVisibility": "xAxisMinorTickVisibility",
      "axisLabelsY.minorTickVisibility": "yAxisMinorTickVisibility",
      "axisLabelsY2.minorTickVisibility": "y2AxisMinorTickVisibility",
      "axisLabelsX.majorTickSize": "xAxisMajorTickSize",
      "axisLabelsY.majorTickSize": "yAxisMajorTickSize",
      "axisLabelsY2.majorTickSize": "y2AxisMajorTickSize",
      "axisLabelsX.minorTickSize": "xAxisMinorTickSize",
      "axisLabelsY.minorTickSize": "yAxisMinorTickSize",
      "axisLabelsY2.minorTickSize": "y2AxisMinorTickSize",
      "axisLabelsX.majorUnit": "xAxisMajorTickInterval",
      "axisLabelsY.majorUnit": "yAxisMajorTickInterval",
      "axisLabelsY2.majorUnit": "y2AxisMajorTickInterval",
      "axisX.abbreviation": "xAxisAbbreviation",
      "axisY.abbreviation": "yAxisAbbreviation",
      "axisY2.abbreviation": "y2AxisAbbreviation",
      "axisLabelsX.integerUnits": "showRoundedXAxisLabels",
      "axisLabelsY2.integerUnits": "showRoundedY2AxisLabels",
      "axisLabelsX.maxLabelParts": "xAxisMaxLabelParts",
      "axisLabelsX.axisVisibility": "xAxisLineVisibility",
      "axisLabelsY.axisVisibility": "yAxisLineVisibility",
      "axisLabelsY2.axisVisibility": "y2AxisLineVisibility",
      "gridLinesX.showMajorLines": "showXMajorGridLines",
      "gridLinesY.showMajorLines": "showYMajorGridLines",
      "gridLinesX.showMinorLines": "showXMinorGridLines",
      "gridLinesY.showMinorLines": "showYMinorGridLines",
      "gridLinesY2.showMajorLines": "showY2MajorGridLines",
      "gridLinesY2.showMinorLines": "showY2MinorGridLines",
      "axisX.scale": "xAxisScale",
      "axisY.scale": "yAxisScale",
      "axisY2.scale": "y2AxisScale",
      "axisX.maximumNumber": "xAxisMax",
      "axisY.maximumNumber": "yAxisMax",
      "axisY2.maximumNumber": "y2AxisMax",
      "axisX.minimumNumber": "xAxisMin",
      "axisY.minimumNumber": "yAxisMin",
      "axisY2.minimumNumber": "y2AxisMin",
      "axisX.includeZero": "showXAxisWithZero",
      "axisY.includeZero": "showYAxisWithZero",
      "axisY2.includeZero": "showY2AxisWithZero",
      "axisLabelsX.extendsAxisRange": "showXAxisExtendedRange",
      "axisLabelsY.extendsAxisRange": "showYAxisExtendedRange",
      "layout.splitSeries": "showSplitSeries",
      "layout.splitSeries.allowIndependentYRanges": "showIndependentYRanges",
      "axisY2.enabled": "showOverlayY2Axis",
      "axisY2.fields": "y2Fields",
      "chart.overlayFields": "overlayFields",
      "legend.labels": "legendLabels",
      "legend.labelStyle.overflowMode": "legendTruncation",
      "legend.mode": "legendMode",
      "legend.placement": "legendDisplay",
      "chart.nullValueMode": "nullValueDisplay",
      "chart.showDataLabels": "dataValuesDisplay",
      fieldColors: "seriesColorsByField",
      "chart.resultTruncationLimit": "resultLimit",
      "chart.stackMode": "stackMode",
      "chart.barSpacing": "barSpacing",
      "chart.columnSpacing": "columnSpacing",
      "chart.seriesSpacing": "seriesSpacing",
      "chart.sliceCollapsingLabel": "collapseLabel",
      "chart.sliceCollapsingThreshold": "collapseThreshold",
      hasDonutHole: "showDonutHole",
      // area specific mapped options
      areaFillOpacity: "areaOpacity",
      "chart.showLines": "showLines",
      // bubble specific mapped options
      "chart.bubbleMinimumSize": "bubbleSizeMin",
      "chart.bubbleMaximumSize": "bubbleSizeMax",
      "chart.bubbleSizeBy": "bubbleSizeMethod",
      // line specific mapped options
      fieldDashStyles: "lineDashStylesByField",
      "chart.showMarkers": "markerDisplay",
      // scatter-specific options
      "chart.markerSize": "markerSize"
    };
    var visibilityEnumReplacements = {
      visible: "show",
      collapsed: "hide"
    };
    var modeEnumReplacements = {
      none: "off"
    };
    var abbreviationEnumReplacements = {
      none: "auto"
    };
    var enumReplacements = {
      xAxisTitleVisibility: visibilityEnumReplacements,
      yAxisTitleVisibility: visibilityEnumReplacements,
      y2AxisTitleVisibility: visibilityEnumReplacements,
      xAxisAbbreviation: modeEnumReplacements,
      yAxisAbbreviation: abbreviationEnumReplacements,
      y2AxisAbbreviation: abbreviationEnumReplacements,
      dataValuesDisplay: modeEnumReplacements,
      legendDisplay: modeEnumReplacements,
      legendTruncation: {
        ellipsisNone: "ellipsisOff"
      },
      stackMode: {
        default: "auto"
      }
    };
    var splitValue = (oldValue) => Array.isArray(oldValue) ? oldValue : oldValue.split(",");
    var parseObjects = (oldValue) => {
      if (typeof oldValue === "object" && !Array.isArray(oldValue)) {
        return oldValue;
      }
      let nuValue = {};
      try {
        nuValue = JSON.parse(oldValue);
      } catch (e) {
      }
      return nuValue;
    };
    var otherValueReplacements = {
      y2Fields: splitValue,
      overlayFields: splitValue,
      legendLabels: splitValue,
      seriesColorsByField: parseObjects,
      lineDashStylesByField: parseObjects,
      /**
       * the original markerDisplay was only exposed as `chart.showMarkers`
       * setting chart.showMarkers to true is the equivalent of `markerDisplay: 'outlined'`
       */
      markerDisplay: (oldValue) => {
        if (oldValue === false) return "off";
        if (oldValue === true) return "outlined";
        return oldValue;
      }
    };
    var migrateChartingOptions = (options) => {
      const migratedOptions = {};
      Object.keys(options).forEach((key) => {
        var _a, _b, _c;
        const value = options[key];
        const updatedKey = (_a = optionRenames[key]) != null ? _a : key;
        let updatedValue = (_c = (_b = enumReplacements == null ? void 0 : enumReplacements[updatedKey]) == null ? void 0 : _b[value]) != null ? _c : value;
        if (otherValueReplacements[updatedKey]) {
          updatedValue = otherValueReplacements[updatedKey](updatedValue);
        }
        migratedOptions[updatedKey] = updatedValue;
      });
      return migratedOptions;
    };
    var migrateBaseChartingVizDefinition = ({
      defaultChanges: defaultChanges10,
      validOptions: validOptions22,
      vizDefinition,
      vizType
    }) => {
      const _a = vizDefinition, { encoding = {}, options = {} } = _a, otherDefinitionParts = __objRest(_a, ["encoding", "options"]);
      const migratedDefinition = __spreadProps(__spreadValues({}, otherDefinitionParts), {
        type: vizType,
        options: {},
        context: {}
      });
      const { options: dataOptions, context: dataContext } = encodingToDynamicOptionsDSL(
        encoding
      );
      const migratedOptions = __spreadValues(__spreadValues(__spreadValues({}, defaultChanges10), migrateChartingOptions(options)), dataOptions);
      Object.keys(migratedOptions).forEach((key) => {
        if (!validOptions22[key]) {
          delete migratedOptions[key];
        }
      });
      migratedDefinition.options = migratedOptions;
      migratedDefinition.context = dataContext;
      return migratedDefinition;
    };
    var defaultChanges = {
      yAxisAbbreviation: "off",
      y2AxisAbbreviation: "off",
      showRoundedY2AxisLabels: false,
      legendTruncation: "ellipsisMiddle",
      showY2MajorGridLines: true
    };
    var migrateVizToSplunkArea = (vizDefinition) => migrateBaseChartingVizDefinition({
      defaultChanges,
      validOptions: visualization_schemas_exports.areaOptionsSchema,
      vizDefinition,
      vizType: "splunk.area"
    });
    var defaultChanges2 = {
      yAxisAbbreviation: "off",
      y2AxisAbbreviation: "off",
      showRoundedY2AxisLabels: false,
      legendTruncation: "ellipsisMiddle",
      showY2MajorGridLines: true
    };
    var migrateVizToSplunkBar = (vizDefinition) => migrateBaseChartingVizDefinition({
      defaultChanges: defaultChanges2,
      validOptions: visualization_schemas_exports.barOptionsSchema,
      vizDefinition,
      vizType: "splunk.bar"
    });
    var defaultChanges3 = {
      yAxisAbbreviation: "off",
      legendTruncation: "ellipsisMiddle"
    };
    var migrateVizToSplunkBubble = (vizDefinition) => migrateBaseChartingVizDefinition({
      defaultChanges: defaultChanges3,
      validOptions: visualization_schemas_exports.bubbleOptionsSchema,
      vizDefinition,
      vizType: "splunk.bubble"
    });
    var dsl_exports = {};
    __export2(dsl_exports, {
      default: () => dsl_default
    });
    var defaultImport3 = __toESM2(require_dsl());
    __reExport(dsl_exports, require_dsl());
    var dsl_default = "default" in defaultImport3 ? defaultImport3.default : defaultImport3;
    var removeInvalidOptions = (currentOptions, validOptions22) => {
      if (!currentOptions || !validOptions22) {
        return;
      }
      const copiedCurrOptions = currentOptions;
      Object.keys(copiedCurrOptions).forEach((key) => {
        if (!(key in validOptions22)) {
          delete copiedCurrOptions[key];
        }
      });
    };
    var renameVizOptions = (oldOptions, optionRenames9) => {
      const updatedOptions = {};
      if (!oldOptions) return {};
      if (!optionRenames9) return oldOptions;
      Object.entries(oldOptions).forEach(([oldOptName, val]) => {
        var _a;
        const optionName = (_a = optionRenames9[oldOptName]) != null ? _a : oldOptName;
        updatedOptions[optionName] = val;
      });
      return updatedOptions;
    };
    var preserveDataSelectionForValueOption = (valueOption, selector) => {
      if (valueOption) {
        const dataSelectors = typeof valueOption === "string" ? (0, dsl_exports.getDataSelectorsFromDSL)(valueOption) : [];
        const lastDataSelector = dataSelectors[dataSelectors.length - 1];
        if (lastDataSelector.includes("seriesByIndex") || lastDataSelector.includes("seriesByName")) {
          return `${valueOption} | ${selector}`;
        }
      }
      return null;
    };
    var addsDataSelectorToOptions = (dataOptions, selector) => {
      const updatedDataOptions = {};
      Object.keys(dataOptions).forEach((key) => {
        const statement = dataOptions[key];
        const updatedDSL = preserveDataSelectionForValueOption(statement, selector);
        if (updatedDSL) {
          updatedDataOptions[key] = updatedDSL;
        } else {
          updatedDataOptions[key] = statement;
        }
      });
      return updatedDataOptions;
    };
    var optionRenames2 = {
      featureId: "areaIds",
      value: "areaValues",
      fill: "areaColors"
    };
    var defaultOptionChanges = {
      areaIds: "> primary | seriesByIndex(0)",
      areaValues: "> primary | seriesByIndex(1)",
      areaColors: "> primary | seriesByIndex(1) | gradient(fillGradientContext)"
    };
    var defaultContextChanges = {
      fillGradientContext: {
        colors: ["#7EEFDA", "#6484F6", "#C093F9", "#293873"]
      }
    };
    var migrateVizToSplunkChoroplethSvg = (vizDefinition) => {
      const _a = vizDefinition, { encoding = {}, options = {} } = _a, otherDefinitionParts = __objRest(_a, ["encoding", "options"]);
      const { options: dataOptions, context: dataContext } = encodingToDynamicOptionsDSL(
        encoding
      );
      const migratedDefinition = __spreadProps(__spreadValues({}, otherDefinitionParts), {
        type: "splunk.choropleth.svg",
        options: {},
        context: {}
      });
      const migratedOptions = __spreadValues({}, options);
      Object.keys(dataOptions).forEach((key) => {
        var _a2;
        const updatedKey = (_a2 = optionRenames2[key]) != null ? _a2 : key;
        migratedOptions[updatedKey] = dataOptions[key];
      });
      migratedDefinition.options = __spreadValues(__spreadValues({}, defaultOptionChanges), migratedOptions);
      migratedDefinition.context = encoding.fill ? dataContext : defaultContextChanges;
      removeInvalidOptions(migratedDefinition.options, visualization_schemas_exports.choroplethSvgOptionsSchema);
      return migratedDefinition;
    };
    var defaultChanges4 = {
      yAxisAbbreviation: "off",
      y2AxisAbbreviation: "off",
      showRoundedY2AxisLabels: false,
      legendTruncation: "ellipsisMiddle",
      showY2MajorGridLines: true
    };
    var migrateVizToSplunkColumn = (vizDefinition) => migrateBaseChartingVizDefinition({
      defaultChanges: defaultChanges4,
      validOptions: visualization_schemas_exports.columnOptionsSchema,
      vizDefinition,
      vizType: "splunk.column"
    });
    var optionsToRename = {
      fill: "fillColor",
      stroke: "strokeColor",
      strokeDasharray: "strokeDashStyle"
    };
    var migrateVizToSplunkEllipse = (vizDefinition) => {
      const _a = vizDefinition, { encoding = {}, options = {} } = _a, otherDefinitionParts = __objRest(_a, ["encoding", "options"]);
      const migratedDefinition = __spreadProps(__spreadValues({}, otherDefinitionParts), {
        type: "splunk.ellipse",
        options,
        context: {}
      });
      const { options: dataOptions, context: dataContext } = encodingToDynamicOptionsDSL(
        encoding
      );
      const updatedDataOptions = addsDataSelectorToOptions(dataOptions, "lastPoint()");
      migratedDefinition.options = __spreadValues(__spreadValues({}, options), updatedDataOptions);
      migratedDefinition.options = renameVizOptions(migratedDefinition.options, optionsToRename);
      removeInvalidOptions(migratedDefinition.options, visualization_schemas_exports.ellipseOptionsSchema);
      migratedDefinition.context = dataContext;
      return migratedDefinition;
    };
    var consolidateDisplayOption = (showOption, percentageOption) => {
      if (showOption === false) {
        return "off";
      }
      if (percentageOption === true) {
        return "percentage";
      }
      if (showOption === true) {
        return "number";
      }
      return null;
    };
    var optionRenames3 = {
      majorUnit: "majorTickInterval"
    };
    var previousRangeValueConfig = [
      { to: 10, value: "#5fbcff" },
      { from: 10, to: 30, value: "#4beba8" },
      { from: 30, to: 50, value: "#f4df7a" },
      { from: 50, to: 70, value: "#fc9850" },
      { from: 70, to: 100, value: "#ff7152" }
    ];
    var defaultChanges5 = {
      gaugeColor: "> value | rangeValue(gaugeColorRangeValueContext)",
      value: "> primary | seriesByIndex(0) | lastPoint()"
    };
    var migrateVizToSplunkFillerGauge = (vizDefinition) => {
      var _b;
      const _a = vizDefinition, { options = {}, encoding = {} } = _a, otherDefinitionParts = __objRest(_a, ["options", "encoding"]);
      const migratedVisualization = __spreadProps(__spreadValues({
        options
      }, otherDefinitionParts), {
        type: "splunk.fillergauge",
        context: {}
      });
      const renamedOptions = renameVizOptions(options, optionRenames3);
      const { options: encodingOptions, context: gaugeColorContext } = encodingToDynamicOptionsDSL(
        encoding
      );
      const originalGaugeValue = encodingOptions.value;
      if (typeof originalGaugeValue === "string") {
        encodingOptions.value = (_b = preserveDataSelectionForValueOption(originalGaugeValue, "lastPoint()")) != null ? _b : originalGaugeValue;
      }
      if (encodingOptions == null ? void 0 : encodingOptions.gaugeColor) {
        migratedVisualization.context = gaugeColorContext;
      } else {
        migratedVisualization.context = {
          gaugeColorRangeValueContext: previousRangeValueConfig
        };
      }
      const { showLabels, usePercentageRange, showValue, usePercentageValue } = options;
      const labelDisplay = consolidateDisplayOption(showLabels, usePercentageRange);
      const valueDisplay = consolidateDisplayOption(showValue, usePercentageValue);
      migratedVisualization.options = __spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({}, defaultChanges5), renamedOptions), encodingOptions), typeof labelDisplay === "string" && { labelDisplay }), typeof valueDisplay === "string" && { valueDisplay });
      removeInvalidOptions(migratedVisualization.options, visualization_schemas_exports.fillerGaugeOptionsSchema);
      return migratedVisualization;
    };
    var defaultChanges6 = {
      yAxisAbbreviation: "off",
      y2AxisAbbreviation: "off",
      showRoundedY2AxisLabels: false,
      legendTruncation: "ellipsisMiddle",
      showY2MajorGridLines: true
    };
    var migrateVizToSplunkLine = (vizDefinition) => migrateBaseChartingVizDefinition({
      defaultChanges: defaultChanges6,
      validOptions: visualization_schemas_exports.lineOptionsSchema,
      vizDefinition,
      vizType: "splunk.line"
    });
    var migrateVizToSplunkImage = (vizDefinition) => {
      const _a = vizDefinition, { options = {} } = _a, otherDefinitionParts = __objRest(_a, ["options"]);
      const migratedVisualization = __spreadProps(__spreadValues({
        options
      }, otherDefinitionParts), {
        type: "splunk.image",
        context: {}
      });
      removeInvalidOptions(migratedVisualization.options, visualization_schemas_exports.imageOptionsSchema);
      return migratedVisualization;
    };
    var migrateVizToSplunkMarkdown = (vizDefinition) => {
      const _a = vizDefinition, { options = {} } = _a, otherDefinitionParts = __objRest(_a, ["options"]);
      const migratedVisualization = __spreadProps(__spreadValues({
        options
      }, otherDefinitionParts), {
        type: "splunk.markdown",
        context: {}
      });
      removeInvalidOptions(migratedVisualization.options, visualization_schemas_exports.markdownOptionsSchema);
      return migratedVisualization;
    };
    var defaultChanges7 = {
      gaugeRanges: [
        { from: 90, to: 100, value: "#CB3B43" },
        { from: 50, to: 90, value: "#F4DF7A" },
        { from: 0, to: 50, value: "#4BEBA8" }
      ],
      value: "> primary | seriesByIndex(0) | lastPoint()"
    };
    var optionRenames4 = {
      majorUnit: "majorTickInterval",
      ranges: "gaugeRanges"
    };
    var migrateVizToSplunkMarkerGauge = (vizDefinition) => {
      var _b;
      const _a = vizDefinition, { options = {}, encoding = {} } = _a, otherDefinitionParts = __objRest(_a, ["options", "encoding"]);
      const migratedVisualization = __spreadProps(__spreadValues({
        options
      }, otherDefinitionParts), {
        type: "splunk.markergauge",
        context: {}
      });
      const renamedOptions = renameVizOptions(options, optionRenames4);
      const { options: dataOptions } = encodingToDynamicOptionsDSL(encoding);
      const originalGaugeValue = dataOptions.value;
      if (typeof originalGaugeValue === "string") {
        dataOptions.value = (_b = preserveDataSelectionForValueOption(originalGaugeValue, "firstPoint()")) != null ? _b : originalGaugeValue;
      }
      const { showLabels, usePercentageRange, showValue, usePercentageValue } = renamedOptions;
      const labelDisplay = consolidateDisplayOption(showLabels, usePercentageRange);
      const valueDisplay = consolidateDisplayOption(showValue, usePercentageValue);
      migratedVisualization.options = __spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({}, defaultChanges7), renamedOptions), dataOptions), typeof labelDisplay === "string" && { labelDisplay }), typeof valueDisplay === "string" && { valueDisplay });
      removeInvalidOptions(migratedVisualization.options, visualization_schemas_exports.markerGaugeOptionsSchema);
      return migratedVisualization;
    };
    var migratePieChartLabelAndPercent = (options) => {
      if (!("chart.showLabels" in options) && !("chart.showPercent" in options)) {
        return {};
      }
      if (!("chart.showLabels" in options) && "chart.showPercent" in options) {
        return {
          labelDisplay: options["chart.showPercent"] ? "valuesAndPercentage" : "values"
        };
      }
      if ("chart.showLabels" in options && !("chart.showPercent" in options)) {
        return { labelDisplay: options["chart.showLabels"] ? "values" : "off" };
      }
      const labelOption = {
        labelDisplay: "values"
      };
      if (options["chart.showLabels"] && options["chart.showPercent"]) {
        labelOption.labelDisplay = "valuesAndPercentage";
      }
      if (!options["chart.showLabels"]) {
        labelOption.labelDisplay = "off";
      }
      return labelOption;
    };
    var migrateDonutChart = (options) => {
      if (options.hasDonutHole) {
        if (options["legend.placement"] === "none") {
          return { labelDisplay: "off" };
        }
        return { labelDisplay: "values" };
      }
      return {};
    };
    var migrateFieldColors = (options) => {
      if ("fieldColors" in options) {
        return {
          seriesColorsByField: otherValueReplacements.seriesColorsByField(options.fieldColors)
        };
      }
      return {};
    };
    var migrateVizToSplunkPie = (vizDefinition) => {
      const _a = vizDefinition, { encoding = {}, options = {} } = _a, otherDefinitionParts = __objRest(_a, ["encoding", "options"]);
      const migratedDefinition = __spreadProps(__spreadValues({}, otherDefinitionParts), {
        type: "splunk.pie",
        options: {},
        context: {}
      });
      const { options: dataOptions, context: dataContext } = encodingToDynamicOptionsDSL(
        encoding
      );
      const migratedOptions = __spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({}, migratePieChartLabelAndPercent(options)), migrateChartingOptions(options)), migrateFieldColors(options)), migrateDonutChart(options)), dataOptions);
      Object.keys(migratedOptions).forEach((key) => {
        if (!visualization_schemas_exports.pieOptionsSchema[key]) {
          delete migratedOptions[key];
        }
      });
      migratedDefinition.options = migratedOptions;
      migratedDefinition.context = dataContext;
      return migratedDefinition;
    };
    var defaultChanges8 = {
      yAxisAbbreviation: "off",
      legendTruncation: "ellipsisMiddle"
    };
    var migrateVizToSplunkScatter = (vizDefinition) => migrateBaseChartingVizDefinition({
      defaultChanges: defaultChanges8,
      validOptions: visualization_schemas_exports.scatterOptionsSchema,
      vizDefinition,
      vizType: "splunk.scatter"
    });
    var optionsToRename2 = {
      fill: "fillColor",
      stroke: "strokeColor",
      strokeDasharray: "strokeDashStyle",
      strokeLinejoin: "strokeJoinStyle"
    };
    var migrateVizToSplunkRectangle = (vizDefinition) => {
      const _a = vizDefinition, { encoding = {}, options } = _a, otherDefinitionParts = __objRest(_a, ["encoding", "options"]);
      const migratedDefinition = __spreadProps(__spreadValues({}, otherDefinitionParts), {
        type: "splunk.rectangle",
        options: {},
        context: {}
      });
      const { options: dataOptions, context: dataContext } = encodingToDynamicOptionsDSL(
        encoding
      );
      const updatedDataOptions = addsDataSelectorToOptions(dataOptions, "lastPoint()");
      migratedDefinition.options = __spreadValues(__spreadValues({}, options), updatedDataOptions);
      migratedDefinition.options = renameVizOptions(migratedDefinition.options, optionsToRename2);
      removeInvalidOptions(migratedDefinition.options, visualization_schemas_exports.rectangleOptionsSchema);
      migratedDefinition.context = dataContext;
      return migratedDefinition;
    };
    var consolidateTrendDisplay = (trendDisplayMode, showTrendIndicator) => {
      if (showTrendIndicator === false) {
        return "off";
      }
      if (["absolute", "percent"].includes(trendDisplayMode)) {
        return trendDisplayMode;
      }
      if (showTrendIndicator === true) {
        return "absolute";
      }
      return null;
    };
    var defaultsToRetain = {
      showSparklineAreaGraph: false,
      sparklineValues: '> primary | seriesByTypes("number", "string")'
    };
    var optionRenames5 = {
      useTrendUnits: "shouldAbbreviateTrendValue",
      useThousandSeparators: "shouldUseThousandSeparators",
      sparklineAreaGraph: "showSparklineAreaGraph",
      sparklineFillColor: "sparklineAreaColor",
      sparklineAcceptNullData: "shouldSparklineAcceptNullData",
      deltaFontSize: "trendFontSize"
    };
    var consolidateSparklineDisplay = (sparklinePosition, showSparkline) => {
      if (showSparkline === false) {
        return "off";
      }
      if (["before", "after", "below"].includes(sparklinePosition)) {
        return sparklinePosition;
      }
      if (showSparkline === true) {
        return "below";
      }
      return null;
    };
    var migrateVizToSplunkSingleValue = (vizDefinition) => {
      var _b, _c, _d;
      const _a = vizDefinition, { options = {}, encoding = {} } = _a, otherDefinitionParts = __objRest(_a, ["options", "encoding"]);
      const migratedVisualization = __spreadProps(__spreadValues({}, otherDefinitionParts), {
        type: "splunk.singlevalue",
        context: {},
        options: {}
      });
      const { options: dataOptions, context: dataContext } = encodingToDynamicOptionsDSL(
        encoding
      );
      const migratedDataOptions = __spreadValues(__spreadValues(__spreadValues(__spreadValues({}, (dataOptions == null ? void 0 : dataOptions.trend) && { sparklineValues: dataOptions.trend }), (dataOptions == null ? void 0 : dataOptions.majorColor) && {
        majorColor: (_b = preserveDataSelectionForValueOption(dataOptions.majorColor, "lastPoint()")) != null ? _b : dataOptions.majorColor
      }), (dataOptions == null ? void 0 : dataOptions.deltaColor) && {
        trendColor: (_c = preserveDataSelectionForValueOption(dataOptions.deltaColor, "lastPoint()")) != null ? _c : dataOptions.deltaColor
      }), (dataOptions == null ? void 0 : dataOptions.fill) && {
        backgroundColor: (_d = preserveDataSelectionForValueOption(dataOptions.fill, "lastPoint()")) != null ? _d : dataOptions.fill
      });
      const renamedOptions = renameVizOptions(options, optionRenames5);
      const { trendDisplayMode, showTrendIndicator, showSparkline, sparklinePosition } = renamedOptions;
      const trendDisplay = consolidateTrendDisplay(trendDisplayMode, showTrendIndicator);
      const sparklineDisplay = consolidateSparklineDisplay(
        sparklinePosition,
        showSparkline
      );
      migratedVisualization.options = __spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({}, defaultsToRetain), renamedOptions), migratedDataOptions), typeof trendDisplay === "string" && { trendDisplay }), typeof sparklineDisplay === "string" && { sparklineDisplay });
      migratedVisualization.context = dataContext;
      removeInvalidOptions(migratedVisualization.options, visualization_schemas_exports.singleValueOptionsSchema);
      return migratedVisualization;
    };
    var defaultsToRetain2 = {
      majorValue: "> primary | seriesByIndex(0) | lastPoint()",
      trendValue: "> primary | seriesByIndex(0) | delta(-2)"
    };
    var optionsToRename3 = {
      useTrendUnits: "shouldAbbreviateTrendValue",
      useThousandSeparators: "shouldUseThousandSeparators",
      deltaColor: "trendColor",
      color: "iconColor"
    };
    var migrateVizToSplunkSingleValueIcon = (vizDefinition) => {
      var _b, _c, _d;
      const _a = vizDefinition, { options = {}, encoding = {} } = _a, otherDefinitionParts = __objRest(_a, ["options", "encoding"]);
      const migratedVisualization = __spreadProps(__spreadValues({}, otherDefinitionParts), {
        type: "splunk.singlevalueicon",
        context: {},
        options: {}
      });
      const { options: dataOptions, context: dataContext } = encodingToDynamicOptionsDSL(
        encoding
      );
      const migratedDataOptions = __spreadValues(__spreadValues({}, (dataOptions == null ? void 0 : dataOptions.trend) && {
        majorValue: (_b = preserveDataSelectionForValueOption(dataOptions.trend, "lastPoint()")) != null ? _b : dataOptions.trend,
        trendValue: (_c = preserveDataSelectionForValueOption(dataOptions.trend, "delta(-2)")) != null ? _c : dataOptions.trend
      }), (dataOptions == null ? void 0 : dataOptions.fill) && {
        backgroundColor: (_d = preserveDataSelectionForValueOption(dataOptions.fill, "lastPoint()")) != null ? _d : dataOptions.fill
      });
      const renamedOptions = renameVizOptions(options, optionsToRename3);
      const { trendDisplayMode, showTrendIndicator } = renamedOptions;
      const trendDisplay = consolidateTrendDisplay(trendDisplayMode, showTrendIndicator);
      migratedVisualization.options = __spreadValues(__spreadValues(__spreadValues(__spreadValues({}, defaultsToRetain2), renamedOptions), migratedDataOptions), typeof trendDisplay === "string" && { trendDisplay });
      migratedVisualization.context = dataContext;
      removeInvalidOptions(migratedVisualization.options, visualization_schemas_exports.singleValueIconOptionsSchema);
      return migratedVisualization;
    };
    var defaultsToRetain3 = {
      majorValue: "> primary | seriesByIndex(0) | lastPoint()",
      trendValue: "> primary | seriesByIndex(0) | delta(-2)"
    };
    var optionRenames6 = {
      useTrendUnits: "shouldAbbreviateTrendValue",
      useThousandSeparators: "shouldUseThousandSeparators"
    };
    var migrateVizToSplunkSingleValueRadial = (vizDefinition) => {
      var _b, _c, _d;
      const _a = vizDefinition, { options = {}, encoding = {} } = _a, otherDefinitionParts = __objRest(_a, ["options", "encoding"]);
      const migratedVisualization = __spreadProps(__spreadValues({}, otherDefinitionParts), {
        type: "splunk.singlevalueradial",
        context: {},
        options: {}
      });
      const { options: dataOptions, context: dataContext } = encodingToDynamicOptionsDSL(
        encoding
      );
      const { trend: originalTrend, fill: originalFill } = dataOptions;
      const migratedDataOptions = __spreadValues(__spreadValues({}, originalTrend && {
        majorValue: (_b = preserveDataSelectionForValueOption(originalTrend, "lastPoint()")) != null ? _b : originalTrend,
        trendValue: (_c = preserveDataSelectionForValueOption(originalTrend, "delta(-2)")) != null ? _c : originalTrend
      }), originalFill && {
        backgroundColor: (_d = preserveDataSelectionForValueOption(originalFill, "lastPoint()")) != null ? _d : originalFill
      });
      const renamedOptions = renameVizOptions(options, optionRenames6);
      const { trendDisplayMode, showTrendIndicator } = renamedOptions;
      const trendDisplay = consolidateTrendDisplay(trendDisplayMode, showTrendIndicator);
      migratedVisualization.options = __spreadValues(__spreadValues(__spreadValues(__spreadValues({}, defaultsToRetain3), renamedOptions), migratedDataOptions), typeof trendDisplay === "string" && { trendDisplay });
      migratedVisualization.context = dataContext;
      removeInvalidOptions(migratedVisualization.options, visualization_schemas_exports.singleValueRadialOptionsSchema);
      return migratedVisualization;
    };
    var lodash_exports = {};
    __export2(lodash_exports, {
      default: () => lodash_default
    });
    var defaultImport4 = __toESM2(require_lodash());
    __reExport(lodash_exports, require_lodash());
    var lodash_default = "default" in defaultImport4 ? defaultImport4.default : defaultImport4;
    var deepMergeWithArrayPrimitiveOverrides_exports = {};
    __export2(deepMergeWithArrayPrimitiveOverrides_exports, {
      default: () => deepMergeWithArrayPrimitiveOverrides_default
    });
    var defaultImport5 = __toESM2(require_deepMergeWithArrayPrimitiveOverrides());
    __reExport(deepMergeWithArrayPrimitiveOverrides_exports, require_deepMergeWithArrayPrimitiveOverrides());
    var deepMergeWithArrayPrimitiveOverrides_default = "default" in defaultImport5 ? defaultImport5.default : defaultImport5;
    var defaultChanges9 = {
      count: 20
    };
    var optionRenames7 = {
      rowNumbers: "showRowNumbers"
    };
    var migrateHeaderVisibility = (oldHeaderVisibility) => {
      if (oldHeaderVisibility === void 0) {
        return void 0;
      }
      return oldHeaderVisibility ? "inline" : "none";
    };
    var migrateAlternatingColors = (colors, optionToConvert, contextConfigName) => {
      const themedAlternatingColors = {
        rowBackgroundColors: {
          even: "> themes.rowBackgroundColorEven",
          odd: "> themes.rowBackgroundColorOdd"
        },
        rowColors: {
          even: "> themes.inverseTextColor",
          odd: "> themes.textColor"
        }
      };
      const colorsContext = [];
      const { oddColor, evenColor } = colors;
      if (oddColor && evenColor) {
        colorsContext.push(...[oddColor, evenColor]);
      } else if (oddColor) {
        colorsContext.push(...[oddColor, themedAlternatingColors[optionToConvert].even]);
      } else if (evenColor) {
        colorsContext.push(...[themedAlternatingColors[optionToConvert].odd, evenColor]);
      }
      if (colorsContext.length) {
        return {
          contextConfigName,
          context: colorsContext,
          dsl: `> table | pick(${contextConfigName})`
        };
      }
      return {};
    };
    var migrateToColumnFormat = (fieldsOption) => {
      const columnFormat = {};
      const columnFormatContext = {};
      if (!fieldsOption) {
        return {
          columnFormat,
          columnFormatContext
        };
      }
      Object.entries(fieldsOption).forEach(([column, formatting]) => {
        const contextEntry = `formatted${column}Config`;
        columnFormatContext[contextEntry] = {};
        columnFormat[column] = {
          data: `> table | seriesByName("${column}") | formatByType(${contextEntry})`
        };
        const { unit, unitPosition, numberPrecision, useThousandSeparators } = formatting;
        if (typeof unitPosition === "string") {
          (0, lodash_exports.set)(columnFormatContext, [contextEntry, "number", "unitPosition"], unitPosition);
          (0, lodash_exports.set)(columnFormatContext, [contextEntry, "string", "unitPosition"], unitPosition);
        }
        if (typeof unit === "string" || typeof unit === "number") {
          (0, lodash_exports.set)(columnFormatContext, [contextEntry, "number", "unit"], unit);
          (0, lodash_exports.set)(columnFormatContext, [contextEntry, "string", "unit"], unit);
        }
        if (numberPrecision != null) {
          (0, lodash_exports.set)(columnFormatContext, [contextEntry, "number", "precision"], numberPrecision);
        }
        if (useThousandSeparators != null) {
          (0, lodash_exports.set)(columnFormatContext, [contextEntry, "number", "thousandSeparated"], useThousandSeparators);
        }
      });
      return {
        columnFormat,
        columnFormatContext
      };
    };
    var migrateToTableFormat = (oldOptions = {}) => {
      const tableFormat = {};
      const tableFormatContext = {
        formattedConfig: {}
      };
      const {
        unit,
        unitPosition: oldUnitPosition,
        numberPrecision: oldNumberPrecision,
        useThousandSeparators: oldUseThousandSeparators
      } = oldOptions;
      const unitPosition = typeof oldUnitPosition === "string" ? oldUnitPosition : "after";
      const numberPrecision = typeof oldNumberPrecision === "number" ? oldNumberPrecision : 0;
      const useThousandSeparators = typeof oldUseThousandSeparators === "boolean" ? oldUseThousandSeparators : false;
      (0, lodash_exports.set)(tableFormatContext, ["formattedConfig", "number", "precision"], numberPrecision);
      (0, lodash_exports.set)(tableFormatContext, ["formattedConfig", "number", "thousandSeparated"], useThousandSeparators);
      (0, lodash_exports.set)(tableFormatContext, ["formattedConfig", "number", "unitPosition"], unitPosition);
      (0, lodash_exports.set)(tableFormatContext, ["formattedConfig", "string", "unitPosition"], unitPosition);
      if (typeof unit === "string" || typeof unit === "number") {
        (0, lodash_exports.set)(tableFormatContext, ["formattedConfig", "number", "unit"], unit);
        (0, lodash_exports.set)(tableFormatContext, ["formattedConfig", "string", "unit"], unit);
      }
      tableFormat.data = `> table | formatByType(formattedConfig)`;
      const {
        rowBackgroundColorEven,
        rowBackgroundColorOdd,
        rowTextColorOdd,
        rowTextColorEven,
        headerTextColor,
        headerBackgroundColor
      } = oldOptions;
      const { context: rowColorsContext, dsl: rowColorsDSL } = migrateAlternatingColors(
        { oddColor: rowTextColorOdd, evenColor: rowTextColorEven },
        "rowColors",
        "rowColorsConfig"
      );
      if (rowColorsContext && rowColorsDSL) {
        tableFormatContext.rowColorsConfig = rowColorsContext;
        tableFormat.rowColors = rowColorsDSL;
      }
      const { context: rowBackgroundColorsContext, dsl: rowBackgroundColorsDSL } = migrateAlternatingColors(
        {
          oddColor: rowBackgroundColorOdd,
          evenColor: rowBackgroundColorEven
        },
        "rowBackgroundColors",
        "rowBackgroundColorsConfig"
      );
      if (rowBackgroundColorsContext && rowBackgroundColorsDSL) {
        tableFormat.rowBackgroundColors = rowBackgroundColorsDSL;
        tableFormatContext.rowBackgroundColorsConfig = rowBackgroundColorsContext;
      }
      if (headerTextColor) {
        tableFormat.headerColor = headerTextColor;
      }
      if (headerBackgroundColor) {
        tableFormat.headerBackgroundColor = headerBackgroundColor;
      }
      return {
        tableFormat,
        tableFormatContext
      };
    };
    var migrateVizToSplunkTable = (vizDefinition) => {
      const _a = vizDefinition, { encoding = {}, options = {} } = _a, otherDefinitionParts = __objRest(_a, ["encoding", "options"]);
      const migratedDefinition = __spreadProps(__spreadValues({}, otherDefinitionParts), {
        type: "splunk.table",
        options: {},
        context: {}
      });
      const { options: dataOptions, context: dataContext } = encodingToDynamicOptionsDSL(
        encoding
      );
      const renamedOptions = renameVizOptions(options, optionRenames7);
      const headerVisibility = migrateHeaderVisibility(renamedOptions.showHeader);
      const { tableFormat, tableFormatContext } = migrateToTableFormat(renamedOptions);
      const { columnFormat, columnFormatContext } = migrateToColumnFormat(
        renamedOptions.fields
      );
      const migratedDataOptions = __spreadValues({}, (dataOptions == null ? void 0 : dataOptions.columns) && { table: dataOptions.columns });
      const formattingOptions = __spreadProps(__spreadValues(__spreadValues({}, !(0, lodash_exports.isEmpty)(columnFormat) && { columnFormat }), typeof headerVisibility === "string" && { headerVisibility }), {
        tableFormat
      });
      const migratedOptions = (0, deepMergeWithArrayPrimitiveOverrides_exports.deepMergeWithArrayPrimitiveOverrides)(
        {},
        defaultChanges9,
        formattingOptions,
        migratedDataOptions,
        renamedOptions
      );
      Object.keys(migratedOptions).forEach((key) => {
        if (!visualization_schemas_exports.tableOptionsSchema[key]) {
          delete migratedOptions[key];
        }
      });
      migratedDefinition.context = __spreadValues(__spreadValues(__spreadValues({}, dataContext), !(0, lodash_exports.isEmpty)(columnFormatContext) && __spreadValues({}, columnFormatContext)), tableFormatContext);
      migratedDefinition.options = migratedOptions;
      return migratedDefinition;
    };
    var optionsToRename4 = {
      textColor: "fontColor",
      content: "markdown"
    };
    var convertTextContentToMarkDown = (fontWeight, fontSize, textContent = "") => {
      if (!lodash_exports.isNumber(fontSize)) {
        return textContent;
      }
      if (textContent.trim().length === 0) {
        return textContent;
      }
      let markdownContent = textContent.replace(/\n*$/, "");
      const regex = /\n/g;
      if (fontWeight === "bold") {
        const contentStrings = markdownContent.split("\n");
        const stringsTrimmed = contentStrings.map(
          (str) => str && str.trim().length ? `**${str.trim()}**` : ""
        );
        let idx = stringsTrimmed.length - 1;
        while (idx >= 0 && stringsTrimmed[idx].length === 0) {
          stringsTrimmed.pop();
          idx -= 1;
        }
        return stringsTrimmed.join("\\\n");
      }
      markdownContent = markdownContent.replace(regex, "\\\n");
      return markdownContent;
    };
    var convertFontSize = (fontSize) => {
      if (!lodash_exports.isNumber(fontSize)) {
        return { fontSize: "default" };
      }
      return { fontSize: "custom", customFontSize: fontSize };
    };
    var migrateVizTextToSplunkMarkdown = (vizDefinition) => {
      const _a = vizDefinition, { options = {} } = _a, otherDefinitionParts = __objRest(_a, ["options"]);
      const {
        fontSize = 24,
        fontWeight = "normal",
        fontFamily = "Splunk Platform Sans",
        rotation = 0
      } = options;
      const migratedVisualization = __spreadProps(__spreadValues({
        options
      }, otherDefinitionParts), {
        type: "splunk.markdown",
        context: {}
      });
      migratedVisualization.options = renameVizOptions(migratedVisualization.options, optionsToRename4);
      const migratedVizOptions = migratedVisualization.options;
      migratedVizOptions.markdown = convertTextContentToMarkDown(
        fontWeight,
        fontSize,
        migratedVizOptions.markdown
      );
      const { fontSize: fontSizeValue, customFontSize } = convertFontSize(fontSize);
      migratedVizOptions.fontSize = fontSizeValue;
      migratedVizOptions.customFontSize = customFontSize;
      migratedVizOptions.fontFamily = fontFamily;
      migratedVizOptions.rotation = rotation;
      removeInvalidOptions(migratedVizOptions, visualization_schemas_exports.markdownOptionsSchema);
      return migratedVisualization;
    };
    var defaultContext = {
      bubbleColorConfig: {
        colors: ["rgba(123,86,219,0.4)", "rgba(123,86,219,1)"]
      }
    };
    var optionsToRename5 = {
      showBubbleLabels: "bubbleLabelDisplay",
      bubbleScale: "bubbleSizeMethod",
      isBubbleSizeDynamic: "showDynamicBubbleSize",
      maxBubbleRadius: "bubbleRadiusMax",
      minBubbleRadius: "bubbleRadiusMin",
      maxBubbleSize: "bubbleSizeMax",
      minBubbleSize: "bubbleSizeMin",
      showLegend: "legendDisplay",
      useDefaultSort: "showDefaultSort"
    };
    var consolidateLegendDisplay = (vizOptions) => {
      if (!vizOptions) {
        return;
      }
      const options = vizOptions;
      if (options.legendDisplay) {
        options.legendDisplay = "right";
      } else if (options.legendDisplay === false) {
        options.legendDisplay = "off";
      }
    };
    var consolidateBubbleLabelDisplay = (vizOptions) => {
      if (!vizOptions) {
        return;
      }
      const options = vizOptions;
      if (options.bubbleLabelDisplay === "none") {
        options.bubbleLabelDisplay = "off";
      }
    };
    var convertGradientConfig = (minBubbleColorIntensity, defaultBubbleColorConfig) => {
      if (!defaultBubbleColorConfig || !defaultBubbleColorConfig.colors || !defaultBubbleColorConfig.colors[0] || typeof minBubbleColorIntensity !== "number") {
        return null;
      }
      const firstColor = defaultBubbleColorConfig.colors[0];
      const firstColorUpdated = `${firstColor.substring(
        0,
        firstColor.lastIndexOf(",")
      )},${minBubbleColorIntensity})`;
      const colors = [...defaultBubbleColorConfig.colors];
      colors[0] = firstColorUpdated;
      const bubbleColorConfigUpdated = __spreadProps(__spreadValues({}, defaultBubbleColorConfig), { colors });
      return bubbleColorConfigUpdated;
    };
    var convertColorModeOption = (visualizationDefinition) => {
      const visualizationDef = visualizationDefinition;
      if (!visualizationDef || !visualizationDef.options) {
        return;
      }
      if (visualizationDef.options.colorMode === "sequential") {
        visualizationDef.options.colorMode = "dynamic";
      }
      if (!visualizationDef.options.colorMode) {
        visualizationDef.options.colorMode = "categorical";
      }
      const { minBubbleColorIntensity } = visualizationDef.options;
      if ((!visualizationDef.options.category || visualizationDef.options.colorMode !== "categorical") && minBubbleColorIntensity && typeof minBubbleColorIntensity === "number") {
        const bubbleColorConfig = convertGradientConfig(
          minBubbleColorIntensity,
          defaultContext.bubbleColorConfig
        );
        if (bubbleColorConfig) {
          visualizationDef.context = __spreadProps(__spreadValues({}, visualizationDef.context), {
            bubbleColorConfig
          });
        }
      }
    };
    var migrateVizToSplunkPunchcard = (vizDefinition) => {
      const _a = vizDefinition, { options = {}, encoding = {} } = _a, otherDefinitionParts = __objRest(_a, ["options", "encoding"]);
      const migratedVisualization = __spreadProps(__spreadValues({
        options
      }, otherDefinitionParts), {
        type: "splunk.punchcard",
        context: {}
      });
      const { options: dataOptions, context: dataContext } = encodingToDynamicOptionsDSL(
        encoding
      );
      const renamedOptions = renameVizOptions(migratedVisualization.options, optionsToRename5);
      consolidateLegendDisplay(renamedOptions);
      consolidateBubbleLabelDisplay(renamedOptions);
      migratedVisualization.options = __spreadValues(__spreadValues({}, renamedOptions), dataOptions);
      migratedVisualization.context = dataContext;
      convertColorModeOption(migratedVisualization);
      removeInvalidOptions(migratedVisualization.options, visualization_schemas_exports.punchcardOptionsSchema);
      return migratedVisualization;
    };
    var optionRenames8 = {
      fillColor: "choroplethEmptyAreaColor",
      strokeColor: "choroplethStrokeColor",
      featureId: "areaIds",
      fill: "dataColors",
      value: "areaValues"
    };
    var defaultContextChanges2 = {
      fillGradientContext: {
        colors: "> themes.defaultGradientMigrationConfig"
      }
    };
    var defaultStrokeColor = "#689C8D";
    var defaultEmptyAreaColor = "#EAEFF2";
    var migrateVizToSplunkMapChoropleth = (vizDefinition) => {
      const _a = vizDefinition, { encoding = {}, options = {} } = _a, otherDefinitionParts = __objRest(_a, ["encoding", "options"]);
      const migratedDefinition = __spreadProps(__spreadValues({}, otherDefinitionParts), {
        type: "splunk.map",
        options: {},
        context: {}
      });
      const { options: dataOptions, context: dataContext } = encodingToDynamicOptionsDSL(
        encoding
      );
      const dynamicOptions = renameVizOptions(dataOptions, optionRenames8);
      const renamedOptions = renameVizOptions(options, optionRenames8);
      if (!("dataColors" in dynamicOptions)) {
        Object.assign(dynamicOptions, {
          dataColors: "> areaValues | gradient(fillGradientContext)"
        });
      }
      let { choroplethEmptyAreaColor, choroplethStrokeColor } = renamedOptions;
      const { source } = renamedOptions;
      const layerOptions = ["choroplethEmptyAreaColor", "choroplethStrokeColor", "source"];
      const renamedOptionsFiltered = Object.keys(renamedOptions).filter((key) => !layerOptions.includes(key)).reduce((obj, key) => {
        obj[key] = renamedOptions[key];
        return obj;
      }, {});
      if (choroplethStrokeColor === defaultStrokeColor && choroplethEmptyAreaColor !== "transparent") {
        if ("backgroundColor" in renamedOptionsFiltered) {
          if (renamedOptionsFiltered["backgroundColor"] !== "transparent") {
            choroplethStrokeColor = renamedOptionsFiltered.backgroundColor;
          } else {
            choroplethStrokeColor = "> themes.defaultBackgroundColor";
          }
        } else {
          choroplethStrokeColor = "> themes.defaultBackgroundColor";
        }
      }
      if (choroplethEmptyAreaColor === defaultEmptyAreaColor) {
        choroplethEmptyAreaColor = "> themes.defaultChoroplethEmptyAreaColor";
      }
      migratedDefinition.options = __spreadProps(__spreadValues({}, renamedOptionsFiltered), {
        layers: [
          __spreadProps(__spreadValues({
            type: "choropleth",
            source
          }, dynamicOptions), {
            choroplethEmptyAreaColor,
            choroplethStrokeColor,
            choroplethOpacity: 1
          })
        ],
        showScale: false,
        showBaseLayer: false,
        showZoomControls: false
      });
      if (vizDefinition.type === "viz.geojson.us") {
        migratedDefinition.options.center = [39.83, -97];
        migratedDefinition.options.zoom = 3;
      } else {
        migratedDefinition.options.center = [46.56, 10.35];
        migratedDefinition.options.zoom = 0;
      }
      migratedDefinition.context = encoding.fill ? dataContext : defaultContextChanges2;
      if (JSON.stringify(dataContext) === JSON.stringify({
        fillGradientContext: {}
      })) {
        Object.assign(migratedDefinition, {
          context: defaultContextChanges2
        });
      }
      removeInvalidOptions(migratedDefinition.options, visualization_schemas_exports.mapOptionsSchema);
      return migratedDefinition;
    };
    var supportedMigrations = {
      "viz.area": {
        "splunk.area": migrateVizToSplunkArea
      },
      "viz.bar": {
        "splunk.bar": migrateVizToSplunkBar
      },
      "viz.bubble": {
        "splunk.bubble": migrateVizToSplunkBubble
      },
      "viz.column": {
        "splunk.column": migrateVizToSplunkColumn
      },
      "viz.choropleth.svg": {
        "splunk.choropleth.svg": migrateVizToSplunkChoroplethSvg
      },
      "viz.geojson.us": {
        "splunk.map": migrateVizToSplunkMapChoropleth
      },
      "viz.geojson.world": {
        "splunk.map": migrateVizToSplunkMapChoropleth
      },
      "viz.ellipse": {
        "splunk.ellipse": migrateVizToSplunkEllipse
      },
      "viz.fillergauge": {
        "splunk.fillergauge": migrateVizToSplunkFillerGauge
      },
      "viz.line": {
        "splunk.line": migrateVizToSplunkLine
      },
      "viz.img": {
        "splunk.image": migrateVizToSplunkImage
      },
      "viz.markdown": {
        "splunk.markdown": migrateVizToSplunkMarkdown
      },
      "viz.markergauge": {
        "splunk.markergauge": migrateVizToSplunkMarkerGauge
      },
      "viz.pie": {
        "splunk.pie": migrateVizToSplunkPie
      },
      "viz.rectangle": {
        "splunk.rectangle": migrateVizToSplunkRectangle
      },
      "viz.singlevalue": {
        "splunk.singlevalue": migrateVizToSplunkSingleValue
      },
      "viz.singlevalueicon": {
        "splunk.singlevalueicon": migrateVizToSplunkSingleValueIcon
      },
      "viz.singlevalueradial": {
        "splunk.singlevalueradial": migrateVizToSplunkSingleValueRadial
      },
      "viz.scatter": {
        "splunk.scatter": migrateVizToSplunkScatter
      },
      "viz.table": {
        "splunk.table": migrateVizToSplunkTable
      },
      "viz.text": {
        "splunk.markdown": migrateVizTextToSplunkMarkdown
      },
      "viz.punchcard": {
        "splunk.punchcard": migrateVizToSplunkPunchcard
      }
    };
    var inferToType = (typeFromDefinition) => {
      if (typeFromDefinition === "viz.img") {
        return "splunk.image";
      }
      if (typeFromDefinition === "viz.text") {
        return "splunk.markdown";
      }
      if (typeFromDefinition === "viz.geojson.us" || typeFromDefinition === "viz.geojson.world") {
        return "splunk.map";
      }
      return typeFromDefinition.replace(/^viz\./, "splunk.");
    };
    var migrate = ({ definition, toType: toTypeFromParams }) => {
      var _a;
      const toType = toTypeFromParams != null ? toTypeFromParams : inferToType(definition.type);
      if (!((_a = supportedMigrations == null ? void 0 : supportedMigrations[definition == null ? void 0 : definition.type]) == null ? void 0 : _a[toType])) {
        throw new Error("Migration currently not supported");
      }
      return supportedMigrations[definition.type][toType](definition);
    };
    var canMigrate = ({ fromType, toType }) => {
      var _a;
      if ((_a = supportedMigrations == null ? void 0 : supportedMigrations[fromType]) == null ? void 0 : _a[toType]) {
        return true;
      }
      return false;
    };
  }
});

// node_modules/lodash/_baseDifference.js
var require_baseDifference = __commonJS({
  "node_modules/lodash/_baseDifference.js"(exports2, module2) {
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var SetCache = require_SetCache();
    var arrayIncludes = require_arrayIncludes();
    var arrayIncludesWith = require_arrayIncludesWith();
    var arrayMap = require_arrayMap();
    var baseUnary = require_baseUnary();
    var cacheHas = require_cacheHas();
    var LARGE_ARRAY_SIZE = 200;
    function baseDifference(array, values, iteratee, comparator) {
      var index = -1, includes = arrayIncludes, isCommon = true, length = array.length, result = [], valuesLength = values.length;
      if (!length) {
        return result;
      }
      if (iteratee) {
        values = arrayMap(values, baseUnary(iteratee));
      }
      if (comparator) {
        includes = arrayIncludesWith;
        isCommon = false;
      } else if (values.length >= LARGE_ARRAY_SIZE) {
        includes = cacheHas;
        isCommon = false;
        values = new SetCache(values);
      }
      outer:
        while (++index < length) {
          var value = array[index], computed = iteratee == null ? value : iteratee(value);
          value = comparator || value !== 0 ? value : 0;
          if (isCommon && computed === computed) {
            var valuesIndex = valuesLength;
            while (valuesIndex--) {
              if (values[valuesIndex] === computed) {
                continue outer;
              }
            }
            result.push(value);
          } else if (!includes(values, computed, comparator)) {
            result.push(value);
          }
        }
      return result;
    }
    module2.exports = baseDifference;
  }
});

// node_modules/lodash/difference.js
var require_difference = __commonJS({
  "node_modules/lodash/difference.js"(exports2, module2) {
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var baseDifference = require_baseDifference();
    var baseFlatten = require_baseFlatten();
    var baseRest = require_baseRest();
    var isArrayLikeObject = require_isArrayLikeObject();
    var difference = baseRest(function(array, values) {
      return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true)) : [];
    });
    module2.exports = difference;
  }
});

// node_modules/lodash/_createFind.js
var require_createFind = __commonJS({
  "node_modules/lodash/_createFind.js"(exports2, module2) {
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var baseIteratee = require_baseIteratee();
    var isArrayLike = require_isArrayLike();
    var keys = require_keys();
    function createFind(findIndexFunc) {
      return function(collection, predicate, fromIndex) {
        var iterable = Object(collection);
        if (!isArrayLike(collection)) {
          var iteratee = baseIteratee(predicate, 3);
          collection = keys(collection);
          predicate = function(key) {
            return iteratee(iterable[key], key, iterable);
          };
        }
        var index = findIndexFunc(collection, predicate, fromIndex);
        return index > -1 ? iterable[iteratee ? collection[index] : index] : void 0;
      };
    }
    module2.exports = createFind;
  }
});

// node_modules/lodash/findIndex.js
var require_findIndex = __commonJS({
  "node_modules/lodash/findIndex.js"(exports2, module2) {
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var baseFindIndex = require_baseFindIndex();
    var baseIteratee = require_baseIteratee();
    var toInteger = require_toInteger();
    var nativeMax = Math.max;
    function findIndex(array, predicate, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = fromIndex == null ? 0 : toInteger(fromIndex);
      if (index < 0) {
        index = nativeMax(length + index, 0);
      }
      return baseFindIndex(array, baseIteratee(predicate, 3), index);
    }
    module2.exports = findIndex;
  }
});

// node_modules/lodash/find.js
var require_find = __commonJS({
  "node_modules/lodash/find.js"(exports2, module2) {
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var createFind = require_createFind();
    var findIndex = require_findIndex();
    var find = createFind(findIndex);
    module2.exports = find;
  }
});

// node_modules/@splunk/dashboard-utils/index.js
var require_dashboard_utils = __commonJS({
  "node_modules/@splunk/dashboard-utils/index.js"(exports2, module2) {
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var __create = Object.create;
    var __defProp = Object.defineProperty;
    var __defProps = Object.defineProperties;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __getOwnPropSymbols = Object.getOwnPropertySymbols;
    var __getProtoOf = Object.getPrototypeOf;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __propIsEnum = Object.prototype.propertyIsEnumerable;
    var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
    var __spreadValues = (a, b) => {
      for (var prop in b || (b = {}))
        if (__hasOwnProp.call(b, prop))
          __defNormalProp(a, prop, b[prop]);
      if (__getOwnPropSymbols)
        for (var prop of __getOwnPropSymbols(b)) {
          if (__propIsEnum.call(b, prop))
            __defNormalProp(a, prop, b[prop]);
        }
      return a;
    };
    var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
    var __objRest = (source, exclude) => {
      var target = {};
      for (var prop in source)
        if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
          target[prop] = source[prop];
      if (source != null && __getOwnPropSymbols)
        for (var prop of __getOwnPropSymbols(source)) {
          if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
            target[prop] = source[prop];
        }
      return target;
    };
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
    var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
      // If the importer is in node compatibility mode or this is not an ESM
      // file that has been converted to a CommonJS file using a Babel-
      // compatible transform (i.e. "__esModule" has not been set), then set
      // "default" to the CommonJS "module.exports" for node compatibility.
      isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
      mod
    ));
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var __async = (__this, __arguments, generator) => {
      return new Promise((resolve, reject) => {
        var fulfilled = (value) => {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        };
        var rejected = (value) => {
          try {
            step(generator.throw(value));
          } catch (e) {
            reject(e);
          }
        };
        var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
        step((generator = generator.apply(__this, __arguments)).next());
      });
    };
    var src_exports = {};
    __export2(src_exports, {
      ACTIVE_TAB_SEARCH_PARAM: () => ACTIVE_TAB_SEARCH_PARAM,
      CANNOT_CONTAIN_TOKEN_MSG: () => CANNOT_CONTAIN_TOKEN_MSG,
      COMPLETED_SEARCH_STATUSES: () => COMPLETED_SEARCH_STATUSES,
      CONDITION_TOKEN_NAMESPACE: () => CONDITION_TOKEN_NAMESPACE,
      DEFAULT_CANVAS_HEIGHT: () => DEFAULT_CANVAS_HEIGHT,
      DEFAULT_CANVAS_WIDTH: () => DEFAULT_CANVAS_WIDTH,
      DEFAULT_FILTERS: () => DEFAULT_FILTERS,
      DEFAULT_INPUT_ON_CANVAS_HEIGHT: () => DEFAULT_INPUT_ON_CANVAS_HEIGHT,
      DEFAULT_INPUT_ON_CANVAS_WIDTH: () => DEFAULT_INPUT_ON_CANVAS_WIDTH,
      DEFAULT_SCALE_FACTOR: () => DEFAULT_SCALE_FACTOR,
      DEFAULT_TOKEN_NAMESPACE: () => DEFAULT_TOKEN_NAMESPACE,
      DS_STATUS: () => DS_STATUS,
      DYNAMIC_STRING_SUBSTITUTE: () => DYNAMIC_STRING_SUBSTITUTE,
      EVAL_TOKEN_NAMESPACE: () => EVAL_TOKEN_NAMESPACE,
      INVALID_CHAR_MSG: () => INVALID_CHAR_MSG,
      INVALID_FIRST_LAST_CHAR_MSG: () => INVALID_FIRST_LAST_CHAR_MSG,
      MAX_CHAIN_LENGTH: () => MAX_CHAIN_LENGTH,
      RUNNING_SEARCH_STATUSES: () => RUNNING_SEARCH_STATUSES,
      TOKEN_NAMESPACE_PREFIX_PATTERN: () => TOKEN_NAMESPACE_PREFIX_PATTERN,
      TOKEN_NAME_CHARS_PATTERN: () => TOKEN_NAME_CHARS_PATTERN,
      TOKEN_NO_DELIMITERS_PATTERN: () => TOKEN_NO_DELIMITERS_PATTERN,
      TOKEN_OR_DOLLAR_RE: () => TOKEN_OR_DOLLAR_RE,
      TokenNameRegExp: () => TokenNameRegExp,
      TokenRegExp: () => TokenRegExp,
      VIZ_DEFAULT_HEIGHT_PX: () => VIZ_DEFAULT_HEIGHT_PX,
      adjacentTokenRegex: () => adjacentTokenRegex,
      allowKeyboardShortcut: () => allowKeyboardShortcut,
      arrayToCSSProp: () => arrayToCSSProp,
      asyncJsonataEvaluation: () => asyncJsonataEvaluation,
      b64DecodeUnicode: () => b64DecodeUnicode,
      b64EncodeUnicode: () => b64EncodeUnicode,
      collides: () => collides,
      computeLocationPort: () => computeLocationPort,
      computeMaxHeight: () => computeMaxHeight,
      computeNewAbsoluteStructureItem: () => computeNewAbsoluteStructureItem,
      computeNewBlockItemPosition: () => computeNewBlockItemPosition,
      computeNewGridStructureItem: () => computeNewGridStructureItem,
      computeNewInputPosition: () => computeNewInputPosition,
      computeNewLinePosition: () => computeNewLinePosition,
      computeNextAvailablePosition: () => computeNextAvailablePosition,
      console: () => console_default,
      convertLineToBlockItem: () => convertLineToBlockItem,
      convertToBlockItem: () => convertToBlockItem,
      convertToBlockItems: () => convertToBlockItems,
      createRangeLabel: () => createRangeLabel,
      deepFreeze: () => deepFreeze_default,
      deepMergeWithDefaults: () => deepMergeWithDefaults_default,
      defaultRealTimePreset: () => defaultRealTimePreset,
      defaultSPLSyntax: () => defaultSPLSyntax_json_default,
      defaultTimePreset: () => defaultTimePreset,
      deprecated: () => deprecated_default,
      doubleDollarOrTokenRegex: () => doubleDollarOrTokenRegex,
      downloadFile: () => downloadFile,
      epochToISO: () => epochToISO,
      epochToMoment: () => epochToMoment,
      evaluateConditions: () => evaluateConditions,
      evaluateTokenExpressions: () => evaluateTokenExpressions,
      exportDashboardToFile: () => exportDashboardToFile,
      exportDataUrisToPdf: () => exportDataUrisToPdf,
      exportDataUrisToPdfDataUri: () => exportDataUrisToPdfDataUri,
      exportLayoutToDataUri: () => exportLayoutToDataUri,
      exportSearchDataAsCsv: () => exportSearchDataAsCsv,
      exportToZip: () => exportToZip,
      exportVizAsPng: () => exportVizAsPng,
      extractTokenMatches: () => extractTokenMatches,
      extractTokens: () => extractTokens,
      extractTokensFromNamespaceNameArray: () => extractTokensFromNamespaceNameArray,
      extractTokensFromObject: () => extractTokensFromObject,
      findDeprecatedVisualizations: () => findDeprecatedVisualizations,
      findHorizontalNeighbors: () => findHorizontalNeighbors,
      findPresetLabel: () => findPresetLabel,
      findVerticalNeighbors: () => findVerticalNeighbors,
      formatDuration: () => formatDuration,
      formatJSONataErrorMessage: () => formatJSONataErrorMessage,
      formatRiskyCommandErrorMessage: () => formatRiskyCommandErrorMessage,
      genJsonataAst: () => genJsonataAst,
      generateCopiedDataSourceName: () => generateCopiedDataSourceName,
      generateId: () => generateId,
      getDefaultDataSourceName: () => getDefaultDataSourceName,
      getDefaultPosition: () => getDefaultPosition,
      getDeprecatedVisualizations: () => getDeprecatedVisualizations,
      getFirstCollision: () => getFirstCollision,
      getFocus: () => getFocus,
      getItemsWithUpdatedPositions: () => getItemsWithUpdatedPositions,
      getPositionByType: () => getPositionByType,
      getProtectedNameError: () => getProtectedNameError,
      getRiskyCommands: () => getRiskyCommands,
      getScrollbarWidth: () => getScrollbarWidth,
      getTokenNameError: () => getTokenNameError,
      getUnitLabel: () => getUnitLabel,
      getWindowLocationSearch: () => getWindowLocationSearch,
      hasFocus: () => hasFocus,
      hasTokens: () => hasTokens,
      hasTokensInObject: () => hasTokensInObject,
      hasWhiteSpace: () => hasWhiteSpace,
      hashString: () => hashString_default,
      invokeAfterPaint: () => invokeAfterPaint,
      isAbsolute: () => isAbsolute,
      isAbsoluteURL: () => isAbsoluteURL,
      isAllTime: () => isAllTime,
      isBlockItem: () => isBlockItem,
      isBottomNeighbor: () => isBottomNeighbor,
      isDefined: () => isDefined,
      isDynamicOption: () => isDynamicOption,
      isEarliestEmpty: () => isEarliestEmpty,
      isEmpty: () => isEmpty2,
      isEmptyArray: () => isEmptyArray,
      isEmptyObject: () => isEmptyObject,
      isEmptyOrUndefined: () => isEmptyOrUndefined,
      isEpoch: () => isEpoch,
      isISO: () => isISO,
      isJsonataError: () => isJsonataError,
      isLatestNow: () => isLatestNow,
      isLayoutItem: () => isLayoutItem,
      isLayoutStructure: () => isLayoutStructure,
      isLeftNeighbor: () => isLeftNeighbor,
      isMac: () => isMac,
      isPlainObject: () => isPlainObject5,
      isPrimitive: () => isPrimitive,
      isPrimitiveArray: () => isPrimitiveArray,
      isRealTime: () => isRealTime,
      isRelativeURL: () => isRelativeURL,
      isRightNeighbor: () => isRightNeighbor,
      isRiskyCommandError: () => isRiskyCommandError,
      isTopNeighbor: () => isTopNeighbor,
      isValidTime: () => isValidTime,
      isValidTokenNamespace: () => isValidTokenNamespace,
      isValidTokenValue: () => isValidTokenValue,
      isValidUrl: () => isValidUrl,
      isVizFocused: () => isVizFocused,
      isWholeDay: () => isWholeDay,
      isoToEpoch: () => isoToEpoch,
      logfmt: () => logfmt,
      mapActiveTabToURL: () => mapActiveTabToURL,
      mapTokensToURL: () => mapTokensToURL,
      mapURLToActiveTab: () => mapURLToActiveTab,
      mapURLToTokens: () => mapURLToTokens,
      mergeDashboardDefinitions: () => mergeDashboardDefinitions,
      migrateDashboardDefinition: () => migrateDashboardDefinition,
      migrateInputDefaultValueToTokenDefaults: () => migrateInputDefaultValueToTokenDefaults,
      migrateLegacyVisualizationsToPlatformVisualizations: () => migrateLegacyVisualizationsToPlatformVisualizations,
      migrateToTabsLayout: () => migrateToTabsLayout,
      migrateVisualizationDefaults: () => migrateVisualizationDefaults,
      navigateToUrl: () => navigateToUrl,
      noop: () => noop2,
      normalizeSnapUnit: () => normalizeSnapUnit,
      normalizeUnit: () => normalizeUnit,
      parse: () => parse,
      parseTimeString: () => parseTimeString,
      processPreset: () => processPreset,
      r: () => r,
      removeISOTimezone: () => removeISOTimezone,
      removeRealTime: () => removeRealTime,
      replaceTokens: () => replaceTokens,
      replaceTokensForObject: () => replaceTokensForObject,
      replaceTokensForObjectWithMetadata: () => replaceTokensForObjectWithMetadata,
      replaceTokensWithHash: () => replaceTokensWithHash,
      replaceTokensWithMetadata: () => replaceTokensWithMetadata,
      replaceTokensWithRegexp: () => replaceTokensWithRegexp,
      safeReplaceTokensForObject: () => safeReplaceTokensForObject,
      shallowEqual: () => shallowEqual_default,
      shouldHideItem: () => shouldHideItem,
      snapUnits: () => snapUnits,
      sortLayoutItems: () => sortLayoutItems,
      splitToken: () => splitToken,
      startsWithToken: () => startsWithToken,
      timeRangesAreEquivalent: () => timeRangesAreEquivalent,
      timeUnits: () => timeUnits,
      toCoordinate: () => toCoordinate,
      toDimension: () => toDimension,
      toMargin: () => toMargin,
      toPadding: () => toPadding,
      toPx: () => toPx,
      tokenWithTrailingDollarRegex: () => tokenWithTrailingDollarRegex,
      tokenWithTrailingDoubleDollarRegex: () => tokenWithTrailingDoubleDollarRegex,
      uniqueId: () => uniqueId,
      updateRemovedVizNeighbors: () => updateRemovedVizNeighbors,
      wait: () => wait
    });
    module2.exports = __toCommonJS2(src_exports);
    var ACTIVE_TAB_SEARCH_PARAM = "tab";
    var mapURLToActiveTab = ({
      search,
      tabIds
    }) => {
      const urlSearchParams = new URLSearchParams(search);
      const activeTab = urlSearchParams.get(ACTIVE_TAB_SEARCH_PARAM);
      if (activeTab && tabIds.includes(activeTab)) {
        return activeTab;
      }
      return void 0;
    };
    var mapActiveTabToURL = ({
      search = "?",
      activeTab
    }) => {
      const searchParams = new URLSearchParams(search);
      if (activeTab) {
        searchParams.set(ACTIVE_TAB_SEARCH_PARAM, activeTab);
      }
      return searchParams.toString();
    };
    var hasWindowConsole = typeof window !== "undefined" && "console" in window;
    var hasConsoleMethod = (method) => hasWindowConsole && typeof window.console[method] === "function";
    var noop = () => void 0;
    var console2 = {
      log: hasConsoleMethod("log") ? (...args) => window.console.log(...args) : noop,
      debug: hasConsoleMethod("debug") ? (...args) => window.console.debug(...args) : noop,
      info: hasConsoleMethod("info") ? (...args) => window.console.info(...args) : noop,
      warn: hasConsoleMethod("warn") ? (...args) => window.console.warn(...args) : noop,
      error: hasConsoleMethod("error") ? (...args) => window.console.error(...args) : noop,
      group: hasConsoleMethod("group") ? (...args) => window.console.group(...args) : noop,
      groupCollapsed: hasConsoleMethod("groupCollapsed") ? (...args) => window.console.groupCollapsed(...args) : noop,
      groupEnd: hasConsoleMethod("groupEnd") ? () => window.console.groupEnd() : noop,
      logWithDetails(message, lines) {
        console2.groupCollapsed(message);
        lines.forEach(
          (line) => Array.isArray(line) ? console2.log(...line) : console2.log(line)
        );
        console2.groupEnd();
      }
    };
    var console_default = console2;
    function logfmt(strings, ...values2) {
      return [strings.join("%o"), ...values2 || []];
    }
    var i18n_exports = {};
    __export2(i18n_exports, {
      default: () => i18n_default
    });
    var defaultImport = __toESM2(require_i18n());
    __reExport(i18n_exports, require_i18n());
    var i18n_default = "default" in defaultImport ? defaultImport.default : defaultImport;
    var lodash_exports = {};
    __export2(lodash_exports, {
      default: () => lodash_default
    });
    var defaultImport2 = __toESM2(require_lodash());
    __reExport(lodash_exports, require_lodash());
    var lodash_default = "default" in defaultImport2 ? defaultImport2.default : defaultImport2;
    var formatValueForCsv = (value) => {
      let formattedValue = value;
      if (Array.isArray(formattedValue)) {
        formattedValue = formattedValue.join(",");
      }
      if (typeof formattedValue === "string" && (formattedValue.search(/["\r\n]/g) >= 0 || formattedValue.includes(","))) {
        return `"${formattedValue.replace(/"/g, '""')}"`;
      }
      return formattedValue;
    };
    var downloadFile = (url, name) => {
      const evt = new MouseEvent("click", {
        view: window,
        bubbles: false,
        cancelable: true
      });
      const link = document.createElement("a");
      link.setAttribute("download", `${name}`);
      link.setAttribute("href", url);
      link.dispatchEvent(evt);
    };
    var moment_exports = {};
    __export2(moment_exports, {
      default: () => moment_default
    });
    var defaultImport3 = __toESM2(require_moment());
    __reExport(moment_exports, require_moment());
    var moment_default = "default" in defaultImport3 ? defaultImport3.default : defaultImport3;
    var createExportFileName = (name) => {
      const formattedDateTime = moment_default().format("YYYY-MM-DD [at] hh.mm.ssZZ");
      return `${name}_${formattedDateTime}_Splunk`;
    };
    var exportSearchDataAsCsv = (_0) => __async(void 0, [_0], function* ({
      searchData,
      filename,
      itemType
    }) {
      var _a, _b;
      if (!((_a = searchData == null ? void 0 : searchData.data) == null ? void 0 : _a.fields) || !((_b = searchData == null ? void 0 : searchData.data) == null ? void 0 : _b.columns)) {
        throw new Error((0, i18n_exports._)("Unable to export CSV due to invalid search data"));
      }
      const fieldNames = searchData.data.fields.map(
        (field) => formatValueForCsv(field.name)
      );
      const columnData = (0, lodash_exports.zipWith)(
        ...searchData.data.columns,
        (...values2) => values2.map(formatValueForCsv)
      );
      const csvData = [fieldNames, ...columnData].join("\n");
      const encodedUri = URL.createObjectURL(
        new Blob([csvData], { type: "text/csv;charset=utf-8" })
      );
      downloadFile(
        encodedUri,
        `${createExportFileName(filename || itemType)}.csv`
      );
    });
    var cloneNodeStyles = (clonedDomNode, originalDomNode) => {
      if (!(clonedDomNode instanceof HTMLElement)) {
        return;
      }
      const sourceStyles = window.getComputedStyle(originalDomNode);
      const targetStyles = clonedDomNode.style;
      if (sourceStyles.cssText) {
        targetStyles.cssText = sourceStyles.cssText;
      } else {
        Array.from(sourceStyles).forEach((name) => {
          targetStyles.setProperty(
            name,
            sourceStyles.getPropertyValue(name),
            sourceStyles.getPropertyPriority(name)
          );
        });
      }
    };
    var TEMP_CANVAS_IMG_ATTRIBUTE = "temp-canvas-image";
    var addTempCanvasImage = (domNode) => {
      Array.from(domNode.getElementsByTagName("canvas")).forEach((canvas) => {
        var _a;
        const image = document.createElement("img");
        image.src = canvas.toDataURL("image/png");
        cloneNodeStyles(image, canvas);
        image.setAttribute("data-test", TEMP_CANVAS_IMG_ATTRIBUTE);
        (_a = canvas.parentNode) == null ? void 0 : _a.insertBefore(image, canvas.nextElementSibling);
      });
    };
    var removeTempCanvasImage = (domNode) => {
      domNode.querySelectorAll(`[data-test=${TEMP_CANVAS_IMG_ATTRIBUTE}]`).forEach((image) => {
        var _a;
        return (_a = image.parentElement) == null ? void 0 : _a.removeChild(image);
      });
    };
    var cloneNodeChildren = (clonedParentDomNode, originalParentDomNode) => {
      const { childNodes } = originalParentDomNode;
      childNodes.forEach((childNode) => {
        const clonedChildNode = childNode.cloneNode();
        cloneNodeStyles(clonedChildNode, childNode);
        clonedParentDomNode.appendChild(clonedChildNode);
        cloneNodeChildren(clonedChildNode, childNode);
      });
    };
    var cloneNodeWithStyles = (vizDomNode) => {
      addTempCanvasImage(vizDomNode);
      const clonedDomNode = vizDomNode.cloneNode();
      cloneNodeStyles(clonedDomNode, vizDomNode);
      cloneNodeChildren(clonedDomNode, vizDomNode);
      removeTempCanvasImage(vizDomNode);
      return clonedDomNode;
    };
    var scaleWidthAndHeight = (scaledDomNode, scale, width, height) => {
      let scaledWidth = width;
      let scaledHeight = height;
      if (scale && scale !== 1) {
        scaledDomNode.style.cssText = `transform: scale(${scale}); transform-origin: 0 0;`;
        scaledWidth = width * scale;
        scaledHeight = height * scale;
      }
      return { scaledWidth, scaledHeight };
    };
    var applyCanvasBackgroundColor = (domNode) => {
      const canvasNode = document.querySelector('[data-test="canvas"]');
      if (canvasNode) {
        domNode.style.backgroundColor = window.getComputedStyle(canvasNode).backgroundColor;
      }
    };
    var applyTableScroll = (vizNode, clonedNode, type) => {
      var _a, _b;
      if (type !== "viz.table" && type !== "splunk.table" || !vizNode.getElementsByTagName("tbody").length) {
        return;
      }
      const table = (_a = vizNode.querySelector("[data-test=main-table]")) == null ? void 0 : _a.parentNode;
      const { scrollLeft = 0, scrollTop = 0 } = table;
      const translateX = 0 - scrollLeft;
      const translateY = 0 - scrollTop;
      clonedNode.getElementsByTagName(
        "tbody"
      )[0].style.transform = `translate(${translateX}px, ${translateY}px)`;
      const clonedTableBody = (_b = clonedNode.querySelector("[data-test=main-table]")) == null ? void 0 : _b.parentNode;
      const clonedTable = clonedNode.querySelector(
        "[data-test=table]"
      );
      clonedTableBody.style.overflow = "hidden";
      clonedTable.style.width = "100%";
      clonedTable.style.height = "100%";
    };
    var applyTableScrolls = (canvasDomNode, clonedCanvasNode) => {
      const tables = canvasDomNode.querySelectorAll(
        'div[data-viz-type="viz.table"], div[data-viz-type="splunk.table"]'
      );
      const clonedTables = clonedCanvasNode.querySelectorAll(
        'div[data-viz-type="viz.table"], div[data-viz-type="splunk.table"]'
      );
      tables.forEach((table, index) => {
        applyTableScroll(table, clonedTables[index], "viz.table");
      });
    };
    var b64EncodeUnicode = (str) => {
      return btoa(
        encodeURIComponent(str).replace(
          /%([0-9A-F]{2})/g,
          function toSolidBytes(match, p1) {
            return String.fromCharCode(parseInt(`0x${p1}`, 16));
          }
        )
      );
    };
    var b64DecodeUnicode = (data) => new TextDecoder().decode(
      Uint8Array.from(atob(data), (m) => m.codePointAt(0))
    );
    var isDataUri = (uri) => /^(data:)/.test(uri);
    var blobToDataUri = (blob) => new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onloadend = () => {
        resolve(reader.result);
      };
      reader.onerror = reject;
      reader.readAsDataURL(blob);
    });
    var fetchExternalResources = (url) => __async(void 0, null, function* () {
      const response = yield fetch(url);
      if (!response.ok) {
        throw new Error(`Unable to fetch resources at: ${url}`);
      }
      const responseBodyBlob = yield response.blob();
      return blobToDataUri(responseBodyBlob);
    });
    var extractSvgFromIframe = (iframeNode) => __async(void 0, null, function* () {
      const { src } = iframeNode;
      if (!src) {
        return void 0;
      }
      const b64Regex = /data:[^;]+;base64,(.*)$/;
      let regexResult = null;
      if (isDataUri(src)) {
        regexResult = b64Regex.exec(src);
      } else {
        const blobAsDataUrl = yield fetchExternalResources(src);
        regexResult = b64Regex.exec(blobAsDataUrl);
      }
      if (regexResult == null ? void 0 : regexResult[1]) {
        const b64EncodedHtmlContents = regexResult[1];
        const htmlContentsString = b64DecodeUnicode(b64EncodedHtmlContents);
        const parser = new DOMParser();
        const htmlNode = parser.parseFromString(
          htmlContentsString,
          "application/xml"
        );
        return htmlNode.getElementsByTagName("svg")[0];
      }
      return void 0;
    });
    var replaceSvgChoroIframe = (clonedNode, type) => __async(void 0, null, function* () {
      if (!type.includes("choropleth") || !clonedNode.getElementsByTagName("iframe").length) {
        return;
      }
      const serializer = new XMLSerializer();
      const iframeNode = clonedNode.getElementsByTagName("iframe")[0];
      const { parentNode } = iframeNode;
      const svgNode = yield extractSvgFromIframe(iframeNode);
      if (svgNode) {
        const svg = serializer.serializeToString(svgNode);
        const imageNode = new Image();
        imageNode.src = `data:image/svg+xml;base64,${b64EncodeUnicode(svg)}`;
        parentNode == null ? void 0 : parentNode.replaceChild(imageNode, iframeNode);
      }
    });
    var replacePngCustomVizIframe = (vizNode, clonedNode) => __async(void 0, null, function* () {
      if (!clonedNode.querySelectorAll("iframe[data-exportable]")) {
        return;
      }
      const clonedIframeNode = clonedNode.querySelector(
        "iframe[data-exportable]"
      );
      const vizIframeNode = vizNode.querySelector(`iframe[data-exportable]`);
      if (!clonedIframeNode || !vizIframeNode) {
        return;
      }
      const { parentNode } = clonedIframeNode;
      if (typeof vizIframeNode.toDataURL !== "function") {
        return;
      }
      const pngDataUri = yield vizIframeNode.toDataURL().catch(() => null);
      if (pngDataUri) {
        const imageNode = new Image();
        imageNode.src = pngDataUri;
        Array.from(clonedIframeNode.attributes).forEach((attribute) => {
          imageNode.setAttribute(attribute.name, attribute.value);
        });
        parentNode == null ? void 0 : parentNode.replaceChild(imageNode, clonedIframeNode);
      }
    });
    var applyVizEffect = (vizNode, clonedNode, type) => __async(void 0, null, function* () {
      applyTableScroll(vizNode, clonedNode, type);
      applyCanvasBackgroundColor(clonedNode);
      yield Promise.allSettled([
        replaceSvgChoroIframe(clonedNode, type),
        replacePngCustomVizIframe(vizNode, clonedNode)
      ]);
    });
    var processImageNode = (imageNode) => __async(void 0, null, function* () {
      const { src } = imageNode;
      let dataUri = "";
      if (!isDataUri(src)) {
        dataUri = yield fetchExternalResources(src);
        imageNode.src = dataUri;
      }
    });
    var processImages = (domNode, vizType) => __async(void 0, null, function* () {
      const imageNodes = domNode.getElementsByTagName("img");
      let imageErrors = 0;
      if (imageNodes.length > 0) {
        yield Promise.all(
          Array.from(imageNodes).map((imageNode) => __async(void 0, null, function* () {
            try {
              yield processImageNode(imageNode);
            } catch (error) {
              imageErrors += 1;
              if (vizType === "viz.img") {
                throw error;
              }
            }
          }))
        );
      }
      if (imageErrors > 0) {
        throw new Error((0, i18n_exports._)("Some external images can not be downloaded."));
      }
    });
    var getCssStyles = (scaledDomNode) => __async(void 0, null, function* () {
      const FONTS_URL_REGEX = /url\(['"]?([^'"]+?)['"]?\)/g;
      const sheets = Array.from(scaledDomNode.ownerDocument.styleSheets);
      const cssStylesList = [];
      yield Promise.all(
        sheets.map((sheet) => __async(void 0, null, function* () {
          if (!sheet) {
            return;
          }
          let cssRules;
          try {
            cssRules = sheet.cssRules;
          } catch (e) {
            console_default.error(e);
            cssRules = [];
          }
          yield Promise.all(
            Array.from(cssRules).map((cssRule) => __async(void 0, null, function* () {
              if (cssRule.constructor.name !== "CSSFontFaceRule") {
                cssStylesList.push(cssRule.cssText);
                return;
              }
              const { style, cssText } = cssRule;
              const fontFaces = style.getPropertyValue("src");
              const fontFaceUrls = [];
              let match = FONTS_URL_REGEX.exec(fontFaces);
              while (match !== null) {
                fontFaceUrls.push(match[1]);
                match = FONTS_URL_REGEX.exec(fontFaces);
              }
              const filter = (url) => !isDataUri(url);
              const map3 = (url) => __async(void 0, null, function* () {
                try {
                  const fontData = yield fetchExternalResources(url);
                  cssStylesList.push(cssText.replace(url, fontData));
                } catch (e) {
                  if (e instanceof Error) {
                    console_default.error(e.message);
                  } else {
                    console_default.error("An unknown error occurred");
                  }
                }
              });
              yield Promise.all(fontFaceUrls.filter(filter).map(map3));
            }))
          );
        }))
      );
      return cssStylesList.map((rule) => `${rule}
`).join("");
    });
    var copyStyles = (scaledDomNode) => __async(void 0, null, function* () {
      const style = document.createElementNS(
        "http://www.w3.org/2000/svg",
        "style"
      );
      const cssStyles = yield getCssStyles(scaledDomNode);
      style.appendChild(document.createTextNode(cssStyles));
      return style;
    });
    var domNodeToSvg = (vizDomString, width, height) => `<svg xmlns='http://www.w3.org/2000/svg' width='${width}' height='${height}'><foreignObject width='100%' height='100%' externalResourcesRequired ='true'> ${vizDomString} </foreignObject></svg>`;
    var domNodeToSvgDataUri = (scaledDomNode, scaledWidth, scaledHeight) => __async(void 0, null, function* () {
      const styleNode = yield copyStyles(scaledDomNode);
      scaledDomNode.insertBefore(styleNode, scaledDomNode.firstChild);
      const svg = new XMLSerializer().serializeToString(scaledDomNode);
      return `data:image/svg+xml;charset=utf-8,${encodeURIComponent(
        domNodeToSvg(svg, scaledWidth, scaledHeight)
      )}`;
    });
    var drawImageOnCanvas = (img, canvas) => {
      const context = canvas.getContext("2d");
      context.drawImage(
        img,
        0,
        0,
        img.width,
        img.height,
        0,
        0,
        canvas.width,
        canvas.height
      );
      context.imageSmoothingQuality = "high";
      return canvas.toDataURL("image/png");
    };
    var wait = (time) => new Promise((resolve) => {
      setTimeout(resolve, time);
    });
    var drawImage = (imageUrl, width, height) => new Promise((resolve, reject) => {
      const canvas = document.createElement("canvas");
      if (!canvas.getContext) {
        reject(new Error((0, i18n_exports._)("Canvas is not supported")));
      }
      const img = new Image();
      img.crossOrigin = "anonymous";
      canvas.width = width;
      canvas.height = height;
      img.addEventListener("load", () => {
        wait(0).then(() => {
          resolve(drawImageOnCanvas(img, canvas));
        }).catch(reject);
      });
      img.addEventListener("error", reject);
      img.src = imageUrl;
    });
    var exportVizAsPng = (_0) => __async(void 0, [_0], function* ({
      vizDomNode,
      vizId,
      vizType,
      scale = 1,
      filename
    }) {
      if (!vizDomNode) {
        throw new Error((0, i18n_exports._)(`Visualization ${vizType} not found.`));
      }
      const clonedDomNode = cloneNodeWithStyles(vizDomNode);
      const { clientWidth, clientHeight } = vizDomNode;
      const { scaledWidth, scaledHeight } = scaleWidthAndHeight(
        clonedDomNode,
        scale,
        clientWidth,
        clientHeight
      );
      yield applyVizEffect(vizDomNode, clonedDomNode, vizType);
      try {
        yield processImages(clonedDomNode);
      } catch (e) {
        throw new Error((0, i18n_exports._)("Images from external URLs can not be downloaded."));
      }
      try {
        const imageUri = yield domNodeToSvgDataUri(
          clonedDomNode,
          scaledWidth,
          scaledHeight
        );
        const downloadUri = yield drawImage(
          imageUri,
          scaledWidth || clientWidth,
          scaledHeight || clientHeight
        );
        downloadFile(
          downloadUri,
          `${createExportFileName(filename || vizType)}.png`
        );
      } catch (e) {
        throw new Error(
          (0, i18n_exports._)(`Unable to export the visualization with id of ${vizId} as PNG.`)
        );
      }
    });
    var format_exports = {};
    __export2(format_exports, {
      default: () => format_default
    });
    var defaultImport4 = __toESM2(require_format());
    __reExport(format_exports, require_format());
    var format_default = "default" in defaultImport4 ? defaultImport4.default : defaultImport4;
    var appendClonedChild = (source, child) => {
      if (!child) {
        return 0;
      }
      source.appendChild(cloneNodeWithStyles(child));
      return child.clientHeight;
    };
    var processCanvasBackgroundImage = (clonedCanvasNode) => __async(void 0, null, function* () {
      var _a;
      const canvasNode = clonedCanvasNode.querySelector(
        "div[data-test=background-image]"
      );
      const canvasBackgroundImage = (_a = canvasNode == null ? void 0 : canvasNode.style) == null ? void 0 : _a.backgroundImage;
      const urlRegex = /url\(['"]?([^'"]+?)['"]?\)/g;
      const url = urlRegex.exec(canvasBackgroundImage);
      if (url) {
        try {
          const dataUri = yield fetchExternalResources(url[1]);
          canvasNode.style.backgroundImage = `url(${dataUri})`;
        } catch (e) {
          if (e instanceof Error) {
            console_default.error(e.message);
          } else {
            console_default.error("An unknown error occurred");
          }
        }
      }
    });
    var replacePngCustomVizIframes = (canvasNode, clonedCanvasNode) => __async(void 0, null, function* () {
      const customVizNodes = canvasNode.querySelectorAll(
        "div[data-viz-type]:has(iframe[data-exportable])"
      );
      yield Promise.allSettled(
        Array.from(customVizNodes).map((customVizNode) => {
          const dataId = customVizNode.getAttribute("data-id");
          const clonedCustomVizNode = clonedCanvasNode.querySelector(
            `div[data-viz-type][data-id="${dataId}"]`
          );
          if (!clonedCustomVizNode) {
            return Promise.resolve();
          }
          return replacePngCustomVizIframe(
            customVizNode,
            clonedCustomVizNode
          );
        })
      );
    });
    var replaceSvgChoroIframes = (clonedCanvasNode) => __async(void 0, null, function* () {
      const vizSvgChoros = clonedCanvasNode.querySelectorAll(
        'div[data-viz-type="viz.choropleth.svg"]'
      );
      const replaceVizChoroSvgPromises = Array.from(vizSvgChoros).map(
        (svgChoro) => replaceSvgChoroIframe(svgChoro, "viz.choropleth.svg")
      );
      const splunkSvgChoros = clonedCanvasNode.querySelectorAll(
        'div[data-viz-type="splunk.choropleth.svg"]'
      );
      const replaceSplunkChoroSvgPromises = Array.from(splunkSvgChoros).map(
        (svgChoro) => replaceSvgChoroIframe(svgChoro, "splunk.choropleth.svg")
      );
      yield Promise.all([
        ...replaceVizChoroSvgPromises,
        ...replaceSplunkChoroSvgPromises
      ]);
    });
    var applyCanvasEffects = (canvasNode, clonedCanvasNode) => __async(void 0, null, function* () {
      yield processCanvasBackgroundImage(clonedCanvasNode);
      applyTableScrolls(canvasNode, clonedCanvasNode);
      yield replacePngCustomVizIframes(canvasNode, clonedCanvasNode);
      yield replaceSvgChoroIframes(clonedCanvasNode);
    });
    var exportLayoutToDataUri = (_0) => __async(void 0, [_0], function* ({
      layoutId,
      dashboardHeaderDomNode,
      dashboardInputsDomNode,
      dashboardTabBarDomNode,
      dashboardCanvasDomNode,
      scale = 1,
      showToast
    }) {
      const clonedCanvasNode = cloneNodeWithStyles(dashboardCanvasDomNode);
      let { clientHeight } = dashboardCanvasDomNode;
      const { clientWidth } = dashboardCanvasDomNode;
      const nodeToExport = document.createElement("div");
      clientHeight += appendClonedChild(nodeToExport, dashboardHeaderDomNode);
      clientHeight += appendClonedChild(nodeToExport, dashboardInputsDomNode);
      clientHeight += appendClonedChild(nodeToExport, dashboardTabBarDomNode);
      nodeToExport.appendChild(clonedCanvasNode);
      const { scaledWidth, scaledHeight } = scaleWidthAndHeight(
        nodeToExport,
        scale,
        clientWidth,
        clientHeight
      );
      if (dashboardHeaderDomNode || dashboardInputsDomNode) {
        nodeToExport.style.backgroundColor = window.getComputedStyle(
          dashboardHeaderDomNode || dashboardInputsDomNode
        ).backgroundColor;
      }
      yield applyCanvasEffects(dashboardCanvasDomNode, clonedCanvasNode);
      try {
        yield processImages(nodeToExport);
      } catch (e) {
        showToast == null ? void 0 : showToast((0, i18n_exports._)("Images from external URLs cannot be downloaded."));
      }
      try {
        const imageUri = yield domNodeToSvgDataUri(
          nodeToExport,
          scaledWidth,
          scaledHeight
        );
        const downloadUri = yield drawImage(
          imageUri,
          scaledWidth || clientWidth,
          scaledHeight || clientHeight
        );
        return { downloadUri, clientWidth, clientHeight };
      } catch (e) {
        if (layoutId) {
          throw new Error(
            (0, format_exports.sprintf)(
              (0, i18n_exports._)('Unable to generate data URI for layout "%(layoutId)s"'),
              { layoutId }
            )
          );
        }
        throw new Error((0, i18n_exports._)(`Unable to generate data URI for active layout`));
      }
    });
    var jspdf_es_min_exports2 = {};
    __export2(jspdf_es_min_exports2, {
      default: () => jspdf_es_min_default
    });
    var defaultImport5 = __toESM2((init_jspdf_es_min(), __toCommonJS(jspdf_es_min_exports)));
    __reExport(jspdf_es_min_exports2, (init_jspdf_es_min(), __toCommonJS(jspdf_es_min_exports)));
    var jspdf_es_min_default = "default" in defaultImport5 ? defaultImport5.default : defaultImport5;
    var exportPdf = (clientWidth, clientHeight, imageUri, fileName) => {
      const orientation = clientWidth > clientHeight ? "landscape" : "portrait";
      const pdf = new jspdf_es_min_default({
        orientation,
        unit: "px",
        format: [clientWidth, clientHeight],
        // https://github.com/parallax/jsPDF/blob/master/HOTFIX_README.md#px_scaling
        // When using px units, jsPDF recommends adding this px_scaling hotfix
        hotfixes: ["px_scaling"]
      });
      pdf.addImage(
        imageUri,
        "PNG",
        0,
        0,
        pdf.internal.pageSize.getWidth(),
        pdf.internal.pageSize.getHeight(),
        "",
        "FAST"
      );
      pdf.save(`${fileName}.pdf`);
    };
    var exportDashboardToFile = (_0) => __async(void 0, [_0], function* ({
      fileType,
      dashboardTitle,
      dashboardHeaderDomNode,
      dashboardInputsDomNode,
      dashboardTabBarDomNode,
      dashboardCanvasDomNode,
      scale = 1,
      showToast
    }) {
      try {
        const { downloadUri, clientWidth, clientHeight } = yield exportLayoutToDataUri({
          dashboardHeaderDomNode,
          dashboardInputsDomNode,
          dashboardTabBarDomNode,
          dashboardCanvasDomNode,
          scale,
          showToast
        });
        const fileName = createExportFileName(
          dashboardTitle || (0, i18n_exports._)("My Dashboard")
        );
        if ((fileType == null ? void 0 : fileType.toLowerCase()) === "png") {
          downloadFile(downloadUri, `${fileName}.png`);
        } else {
          exportPdf(clientWidth, clientHeight, downloadUri, fileName);
        }
      } catch (e) {
        throw new Error((0, i18n_exports._)(`Unable to export the dashboard as ${fileType}`));
      }
    });
    var combineDataUris = ({ pages }) => {
      const pdf = new jspdf_es_min_exports2.jsPDF({
        unit: "px",
        // https://github.com/parallax/jsPDF/blob/master/HOTFIX_README.md#px_scaling
        // When using px units, jsPDF recommends adding this px_scaling hotfix
        hotfixes: ["px_scaling"]
      });
      pdf.deletePage(1);
      pages.forEach((page, idx) => {
        const { clientWidth, clientHeight, dataUri: imageData } = page;
        const orientation = clientWidth > clientHeight ? "landscape" : "portrait";
        pdf.addPage([clientWidth, clientHeight], orientation);
        pdf.addImage(
          imageData,
          "PNG",
          0,
          0,
          pdf.internal.pageSize.getWidth(),
          pdf.internal.pageSize.getHeight(),
          `page-${idx}`,
          "FAST"
        );
      });
      return pdf;
    };
    var exportDataUrisToPdf = ({
      pages,
      fileName = "export"
    }) => {
      const pdf = combineDataUris({ pages });
      pdf.save(`${fileName}.pdf`);
      return null;
    };
    var exportDataUrisToPdfDataUri = ({
      pages
    }) => {
      const pdf = combineDataUris({ pages });
      return pdf.output("datauristring");
    };
    var fflate_exports = {};
    __export2(fflate_exports, {
      default: () => fflate_default
    });
    var defaultImport6 = __toESM2(require_browser());
    __reExport(fflate_exports, require_browser());
    var fflate_default = "default" in defaultImport6 ? defaultImport6.default : defaultImport6;
    var generateFileName = (fileName, fileType) => `${fileName}.${fileType}`;
    var exportToZip = ({
      dataUriMappings,
      fileName: zipFileName,
      outputType = "save"
    }) => {
      const zipObject = dataUriMappings.reduce(
        (obj, { fileName, fileType, dataUri }) => {
          var _a;
          const decodedString = window.atob((_a = dataUri.split(",")[1]) != null ? _a : dataUri);
          const bytes = Uint8Array.from(
            decodedString,
            (char) => char.charCodeAt(0)
          );
          let uniqueFileName = fileName;
          let uniqueCounter = 1;
          while (generateFileName(uniqueFileName, fileType) in obj) {
            uniqueFileName = `${fileName} (${uniqueCounter})`;
            uniqueCounter += 1;
          }
          return __spreadProps(__spreadValues({}, obj), {
            [generateFileName(uniqueFileName, fileType)]: bytes
          });
        },
        {}
      );
      const data = (0, fflate_exports.zipSync)(zipObject, { level: 0 });
      if (outputType === "save") {
        const blob = new Blob([data], { type: "application/zip" });
        const url = URL.createObjectURL(blob);
        downloadFile(url, `${zipFileName}.zip`);
        return null;
      }
      const base64String = window.btoa((0, fflate_exports.strFromU8)(data, true));
      return `data:application/zip;base64,${base64String}`;
    };
    var getDefaultDataSourceName = ({
      dataSource
    }) => (dataSource == null ? void 0 : dataSource.name) || "";
    var isObjectLike = (value) => !!value && typeof value === "object";
    var deepFreeze = (obj) => {
      if (!isObjectLike(obj)) {
        return obj;
      }
      Object.values(obj).forEach((val) => {
        deepFreeze(val);
      });
      return Object.freeze(obj);
    };
    var deepFreeze_default = deepFreeze;
    var isPlainObject_exports = {};
    __export2(isPlainObject_exports, {
      default: () => isPlainObject_default
    });
    var defaultImport7 = __toESM2(require_isPlainObject());
    __reExport(isPlainObject_exports, require_isPlainObject());
    var isPlainObject_default = "default" in defaultImport7 ? defaultImport7.default : defaultImport7;
    var mergeWithDefaultRecursive = (val, defaultVal) => {
      if (val === void 0) {
        return defaultVal;
      }
      if (!isPlainObject_default(val) || !isPlainObject_default(defaultVal)) {
        return val;
      }
      const obj = val;
      const defaultObj = defaultVal;
      const newObj = {};
      const keys = /* @__PURE__ */ new Set([...Object.keys(obj), ...Object.keys(defaultObj)]);
      let didObjChange = false;
      keys.forEach((k) => {
        newObj[k] = mergeWithDefaultRecursive(obj[k], defaultObj[k]);
        if (obj[k] !== newObj[k]) {
          didObjChange = true;
        }
      });
      return didObjChange ? newObj : obj;
    };
    var deepMergeWithDefaults = (obj, ...defaultsToApply) => defaultsToApply.reduce(
      (objWithDefaults, defaultToApply) => mergeWithDefaultRecursive(objWithDefaults, defaultToApply),
      obj
    );
    var deepMergeWithDefaults_default = deepMergeWithDefaults;
    var defaultSPLSyntax_json_default = {
      "excerpt-command": {
        isList: false,
        args: [
          {
            key: "maxterms",
            valueType: "int"
          },
          {
            key: "maxlines",
            valueType: "int"
          }
        ],
        functions: [],
        keywords: [],
        other: [],
        list: []
      },
      "abstract-command": {
        isList: false,
        args: [
          {
            key: "maxterms",
            valueType: "int"
          },
          {
            key: "maxlines",
            valueType: "int"
          }
        ],
        functions: [],
        keywords: [],
        other: [],
        list: []
      },
      "accum-command": {
        isList: false,
        args: [],
        functions: [],
        keywords: ["AS"],
        other: ["field", "field"],
        list: []
      },
      "addcoltotals-command": {
        isList: false,
        args: [
          {
            key: "labelfield",
            valueType: "field"
          },
          {
            key: "label",
            valueType: "string"
          }
        ],
        functions: [],
        keywords: [],
        other: ["field-list"],
        list: []
      },
      "addinfo-command": {
        isList: false,
        args: [],
        functions: [],
        keywords: [],
        other: [],
        list: []
      },
      "addtotals-command": {
        isList: false,
        args: [
          {
            key: "row",
            valueType: "bool"
          },
          {
            key: "col",
            valueType: "bool"
          },
          {
            key: "labelfield",
            valueType: "field"
          },
          {
            key: "label",
            valueType: "string"
          },
          {
            key: "fieldname",
            valueType: "field"
          }
        ],
        functions: [],
        keywords: [],
        other: ["field-list"],
        list: []
      },
      "af-command": {
        isList: false,
        args: [
          {
            key: "classfield",
            valueType: "field"
          }
        ],
        functions: [],
        keywords: [],
        other: [],
        list: []
      },
      "analyzefields-command": {
        isList: false,
        args: [
          {
            key: "classfield",
            valueType: "field"
          }
        ],
        functions: [],
        keywords: [],
        other: [],
        list: []
      },
      "anomalies-command": {
        isList: false,
        args: [
          {
            key: "threshold",
            valueType: "num"
          },
          {
            key: "labelonly",
            valueType: "bool"
          },
          {
            key: "normalize",
            valueType: "bool"
          },
          {
            key: "maxvalues",
            valueType: "int"
          },
          {
            key: "field",
            valueType: "field"
          },
          {
            key: "denylist",
            valueType: "filename"
          },
          {
            key: "denylistthreshold",
            valueType: "num"
          }
        ],
        functions: [],
        keywords: ["by"],
        other: ["field-list"],
        list: []
      },
      "anomalousvalue-command": {
        isList: false,
        args: [
          {
            key: "minsupcount",
            valueType: "int"
          },
          {
            key: "maxanofreq",
            valueType: "num"
          },
          {
            key: "minsupfreq",
            valueType: "num"
          },
          {
            key: "minnormfreq",
            valueType: "num"
          },
          {
            key: "action",
            valueType: ""
          },
          {
            key: "pthresh",
            valueType: "num"
          }
        ],
        functions: [],
        keywords: [],
        other: ["field-list"],
        list: []
      },
      "anomalydetection-command": {
        isList: false,
        args: [
          {
            key: "method",
            valueType: ""
          },
          {
            key: "action",
            valueType: ""
          },
          {
            key: "action",
            valueType: ""
          },
          {
            key: "pthresh",
            valueType: "num"
          },
          {
            key: "cutoff",
            valueType: "bool"
          }
        ],
        functions: [],
        keywords: [],
        other: ["field-list"],
        list: []
      },
      "append-command": {
        isList: false,
        args: [
          {
            key: "extendtimerange",
            valueType: "bool"
          },
          {
            key: "maxtime",
            valueType: "int"
          },
          {
            key: "maxout",
            valueType: "int"
          },
          {
            key: "timeout",
            valueType: "int"
          }
        ],
        functions: [],
        keywords: [],
        other: ["string"],
        list: []
      },
      "appendcols-command": {
        isList: false,
        args: [
          {
            key: "override",
            valueType: "bool"
          },
          {
            key: "extendtimerange",
            valueType: "bool"
          },
          {
            key: "maxtime",
            valueType: "int"
          },
          {
            key: "maxout",
            valueType: "int"
          },
          {
            key: "timeout",
            valueType: "int"
          }
        ],
        functions: [],
        keywords: [],
        other: ["string"],
        list: []
      },
      "appendpipe-command": {
        isList: false,
        args: [
          {
            key: "run_in_preview",
            valueType: "bool"
          }
        ],
        functions: [],
        keywords: [],
        other: ["subpipeline"],
        list: []
      },
      "archivebuckets-command": {
        isList: false,
        args: [
          {
            key: "forcerun",
            valueType: ""
          },
          {
            key: "retries",
            valueType: ""
          }
        ],
        functions: [],
        keywords: [],
        other: [],
        list: []
      },
      "arules-command": {
        isList: false,
        args: [
          {
            key: "sup",
            valueType: "int"
          },
          {
            key: "conf",
            valueType: "num"
          }
        ],
        functions: [],
        keywords: [],
        other: ["fields"],
        list: []
      },
      "associate-command": {
        isList: false,
        args: [
          {
            key: "supcnt",
            valueType: "int"
          },
          {
            key: "supfreq",
            valueType: "num"
          },
          {
            key: "improv",
            valueType: "num"
          }
        ],
        functions: [],
        keywords: [],
        other: ["field-list"],
        list: []
      },
      "audit-command": {
        isList: false,
        args: [],
        functions: [],
        keywords: [],
        other: [],
        list: []
      },
      "ar-command": {
        isList: false,
        args: [
          {
            key: "p",
            valueType: ""
          }
        ],
        functions: [],
        keywords: ["AS"],
        other: ["field", "field:newfield"],
        list: []
      },
      "autoregress-command": {
        isList: false,
        args: [
          {
            key: "p",
            valueType: ""
          }
        ],
        functions: [],
        keywords: ["AS"],
        other: ["field", "field:newfield"],
        list: []
      },
      "bucket-command": {
        isList: false,
        args: [
          {
            key: "bins",
            valueType: "int"
          },
          {
            key: "minspan",
            valueType: ""
          },
          {
            key: "span",
            valueType: ""
          },
          {
            key: "start",
            valueType: "num"
          },
          {
            key: "end",
            valueType: "num"
          },
          {
            key: "aligntime",
            valueType: ""
          }
        ],
        functions: [],
        keywords: ["as"],
        other: ["field", "field"],
        list: []
      },
      "discretize-command": {
        isList: false,
        args: [
          {
            key: "bins",
            valueType: "int"
          },
          {
            key: "minspan",
            valueType: ""
          },
          {
            key: "span",
            valueType: ""
          },
          {
            key: "start",
            valueType: "num"
          },
          {
            key: "end",
            valueType: "num"
          },
          {
            key: "aligntime",
            valueType: ""
          }
        ],
        functions: [],
        keywords: ["as"],
        other: ["field", "field"],
        list: []
      },
      "bin-command": {
        isList: false,
        args: [
          {
            key: "bins",
            valueType: "int"
          },
          {
            key: "minspan",
            valueType: ""
          },
          {
            key: "span",
            valueType: ""
          },
          {
            key: "start",
            valueType: "num"
          },
          {
            key: "end",
            valueType: "num"
          },
          {
            key: "aligntime",
            valueType: ""
          }
        ],
        functions: [],
        keywords: ["as"],
        other: ["field", "field"],
        list: []
      },
      "bucketdir-command": {
        isList: false,
        args: [
          {
            key: "pathfield",
            valueType: "field"
          },
          {
            key: "sizefield",
            valueType: "field"
          },
          {
            key: "maxcount",
            valueType: "int"
          },
          {
            key: "countfield",
            valueType: "field"
          },
          {
            key: "sep",
            valueType: "char"
          }
        ],
        functions: [],
        keywords: [],
        other: [],
        list: []
      },
      "chart-command": {
        isList: false,
        args: [
          {
            key: "sep",
            valueType: "string"
          },
          {
            key: "format",
            valueType: "string"
          },
          {
            key: "cont",
            valueType: "bool"
          },
          {
            key: "limit",
            valueType: "chart-limit-opt"
          },
          {
            key: "agg",
            valueType: "stats-agg-term"
          },
          {
            key: "bins",
            valueType: "int"
          },
          {
            key: "minspan",
            valueType: ""
          },
          {
            key: "span",
            valueType: ""
          },
          {
            key: "start",
            valueType: "num"
          },
          {
            key: "end",
            valueType: "num"
          },
          {
            key: "aligntime",
            valueType: ""
          },
          {
            key: "usenull",
            valueType: "bool"
          },
          {
            key: "useother",
            valueType: "bool"
          },
          {
            key: "nullstr",
            valueType: "string"
          },
          {
            key: "otherstr",
            valueType: "string"
          },
          {
            key: "dedup_splitvals",
            valueType: "bool"
          }
        ],
        functions: [
          {
            name: "c",
            parenOptional: true
          },
          {
            name: "count",
            parenOptional: true
          },
          {
            name: "dc",
            parenOptional: true
          },
          {
            name: "distinct_count",
            parenOptional: true
          },
          {
            name: "mean",
            parenOptional: true
          },
          {
            name: "avg",
            parenOptional: true
          },
          {
            name: "stdev",
            parenOptional: true
          },
          {
            name: "stdevp",
            parenOptional: true
          },
          {
            name: "var",
            parenOptional: true
          },
          {
            name: "varp",
            parenOptional: true
          },
          {
            name: "sum",
            parenOptional: true
          },
          {
            name: "sumsq",
            parenOptional: true
          },
          {
            name: "min",
            parenOptional: true
          },
          {
            name: "max",
            parenOptional: true
          },
          {
            name: "mode",
            parenOptional: true
          },
          {
            name: "median",
            parenOptional: true
          },
          {
            name: "earliest",
            parenOptional: true
          },
          {
            name: "first",
            parenOptional: true
          },
          {
            name: "last",
            parenOptional: true
          },
          {
            name: "latest",
            parenOptional: true
          },
          {
            name: "list",
            parenOptional: true
          },
          {
            name: "values",
            parenOptional: true
          },
          {
            name: "range",
            parenOptional: true
          },
          {
            name: "estdc",
            parenOptional: true
          },
          {
            name: "estdc_error",
            parenOptional: true
          },
          {
            name: "earliest_time",
            parenOptional: true
          },
          {
            name: "latest_time",
            parenOptional: true
          },
          {
            name: "rate",
            parenOptional: true
          },
          {
            name: "eval",
            parenOptional: false
          },
          {
            name: "abs",
            parenOptional: false
          },
          {
            name: "avg",
            parenOptional: false
          },
          {
            name: "case",
            parenOptional: false
          },
          {
            name: "ceiling",
            parenOptional: false
          },
          {
            name: "ceil",
            parenOptional: false
          },
          {
            name: "cidrmatch",
            parenOptional: false
          },
          {
            name: "coalesce",
            parenOptional: false
          },
          {
            name: "commands",
            parenOptional: false
          },
          {
            name: "exact",
            parenOptional: false
          },
          {
            name: "exp",
            parenOptional: false
          },
          {
            name: "false",
            parenOptional: false
          },
          {
            name: "floor",
            parenOptional: false
          },
          {
            name: "if",
            parenOptional: false
          },
          {
            name: "ifnull",
            parenOptional: false
          },
          {
            name: "isbool",
            parenOptional: false
          },
          {
            name: "isint",
            parenOptional: false
          },
          {
            name: "isnotnull",
            parenOptional: false
          },
          {
            name: "isnull",
            parenOptional: false
          },
          {
            name: "isnum",
            parenOptional: false
          },
          {
            name: "isstr",
            parenOptional: false
          },
          {
            name: "len",
            parenOptional: false
          },
          {
            name: "like",
            parenOptional: false
          },
          {
            name: "ln",
            parenOptional: false
          },
          {
            name: "log",
            parenOptional: false
          },
          {
            name: "lookup",
            parenOptional: false
          },
          {
            name: "lower",
            parenOptional: false
          },
          {
            name: "match",
            parenOptional: false
          },
          {
            name: "max",
            parenOptional: false
          },
          {
            name: "md5",
            parenOptional: false
          },
          {
            name: "min",
            parenOptional: false
          },
          {
            name: "mvappend",
            parenOptional: false
          },
          {
            name: "mvcount",
            parenOptional: false
          },
          {
            name: "mvdedup",
            parenOptional: false
          },
          {
            name: "mvindex",
            parenOptional: false
          },
          {
            name: "mvfilter",
            parenOptional: false
          },
          {
            name: "mvfind",
            parenOptional: false
          },
          {
            name: "mvjoin",
            parenOptional: false
          },
          {
            name: "mvmap",
            parenOptional: false
          },
          {
            name: "mvrange",
            parenOptional: false
          },
          {
            name: "mvsort",
            parenOptional: false
          },
          {
            name: "mvzip",
            parenOptional: false
          },
          {
            name: "now",
            parenOptional: false
          },
          {
            name: "null",
            parenOptional: false
          },
          {
            name: "nullif",
            parenOptional: false
          },
          {
            name: "pi",
            parenOptional: false
          },
          {
            name: "pow",
            parenOptional: false
          },
          {
            name: "random",
            parenOptional: false
          },
          {
            name: "relative_time",
            parenOptional: false
          },
          {
            name: "replace",
            parenOptional: false
          },
          {
            name: "round",
            parenOptional: false
          },
          {
            name: "searchmatch",
            parenOptional: false
          },
          {
            name: "sha1",
            parenOptional: false
          },
          {
            name: "sha256",
            parenOptional: false
          },
          {
            name: "sha512",
            parenOptional: false
          },
          {
            name: "sigfig",
            parenOptional: false
          },
          {
            name: "spath",
            parenOptional: false
          },
          {
            name: "split",
            parenOptional: false
          },
          {
            name: "sqrt",
            parenOptional: false
          },
          {
            name: "strftime",
            parenOptional: false
          },
          {
            name: "strptime",
            parenOptional: false
          },
          {
            name: "substr",
            parenOptional: false
          },
          {
            name: "sum",
            parenOptional: false
          },
          {
            name: "time",
            parenOptional: false
          },
          {
            name: "tostring",
            parenOptional: false
          },
          {
            name: "trim",
            parenOptional: false
          },
          {
            name: "ltrim",
            parenOptional: false
          },
          {
            name: "rtrim",
            parenOptional: false
          },
          {
            name: "true",
            parenOptional: false
          },
          {
            name: "typeof",
            parenOptional: false
          },
          {
            name: "upper",
            parenOptional: false
          },
          {
            name: "urldecode",
            parenOptional: false
          },
          {
            name: "validate",
            parenOptional: false
          },
          {
            name: "tonumber",
            parenOptional: false
          },
          {
            name: "acos",
            parenOptional: false
          },
          {
            name: "acosh",
            parenOptional: false
          },
          {
            name: "asin",
            parenOptional: false
          },
          {
            name: "asinh",
            parenOptional: false
          },
          {
            name: "atan",
            parenOptional: false
          },
          {
            name: "atan2",
            parenOptional: false
          },
          {
            name: "atanh",
            parenOptional: false
          },
          {
            name: "cos",
            parenOptional: false
          },
          {
            name: "cosh",
            parenOptional: false
          },
          {
            name: "hypot",
            parenOptional: false
          },
          {
            name: "sin",
            parenOptional: false
          },
          {
            name: "sinh",
            parenOptional: false
          },
          {
            name: "tan",
            parenOptional: false
          },
          {
            name: "tanh",
            parenOptional: false
          },
          {
            name: "json_array_to_mv",
            parenOptional: false
          },
          {
            name: "mv_to_json_array",
            parenOptional: false
          },
          {
            name: "json_append",
            parenOptional: false
          },
          {
            name: "json_extend",
            parenOptional: false
          },
          {
            name: "json_extract_exact",
            parenOptional: false
          },
          {
            name: "json_set_exact",
            parenOptional: false
          },
          {
            name: "sparkline",
            parenOptional: false
          },
          {
            name: "c",
            parenOptional: false
          },
          {
            name: "count",
            parenOptional: false
          },
          {
            name: "dc",
            parenOptional: false
          },
          {
            name: "mean",
            parenOptional: false
          },
          {
            name: "avg",
            parenOptional: false
          },
          {
            name: "stdev",
            parenOptional: false
          },
          {
            name: "stdevp",
            parenOptional: false
          },
          {
            name: "var",
            parenOptional: false
          },
          {
            name: "varp",
            parenOptional: false
          },
          {
            name: "sum",
            parenOptional: false
          },
          {
            name: "sumsq",
            parenOptional: false
          },
          {
            name: "min",
            parenOptional: false
          },
          {
            name: "max",
            parenOptional: false
          },
          {
            name: "range",
            parenOptional: false
          },
          {
            name: "c",
            parenOptional: false
          },
          {
            name: "count",
            parenOptional: false
          },
          {
            name: "dc",
            parenOptional: false
          },
          {
            name: "distinct_count",
            parenOptional: false
          },
          {
            name: "mean",
            parenOptional: false
          },
          {
            name: "avg",
            parenOptional: false
          },
          {
            name: "stdev",
            parenOptional: false
          },
          {
            name: "stdevp",
            parenOptional: false
          },
          {
            name: "var",
            parenOptional: false
          },
          {
            name: "varp",
            parenOptional: false
          },
          {
            name: "sum",
            parenOptional: false
          },
          {
            name: "sumsq",
            parenOptional: false
          },
          {
            name: "min",
            parenOptional: false
          },
          {
            name: "max",
            parenOptional: false
          },
          {
            name: "mode",
            parenOptional: false
          },
          {
            name: "median",
            parenOptional: false
          },
          {
            name: "earliest",
            parenOptional: false
          },
          {
            name: "first",
            parenOptional: false
          },
          {
            name: "last",
            parenOptional: false
          },
          {
            name: "latest",
            parenOptional: false
          },
          {
            name: "list",
            parenOptional: false
          },
          {
            name: "values",
            parenOptional: false
          },
          {
            name: "range",
            parenOptional: false
          },
          {
            name: "estdc",
            parenOptional: false
          },
          {
            name: "estdc_error",
            parenOptional: false
          },
          {
            name: "earliest_time",
            parenOptional: false
          },
          {
            name: "latest_time",
            parenOptional: false
          },
          {
            name: "rate",
            parenOptional: false
          }
        ],
        keywords: ["LIKE", "AND|OR|XOR", "as", "BY", "where", "OVER"],
        other: ["field", "num", "string", "wc-field", "int", "|"],
        list: []
      },
      "slc-command": {
        isList: false,
        args: [
          {
            key: "t",
            valueType: "num"
          },
          {
            key: "delims",
            valueType: "string"
          },
          {
            key: "showcount",
            valueType: "bool"
          },
          {
            key: "countfield",
            valueType: "field"
          },
          {
            key: "labelfield",
            valueType: "field"
          },
          {
            key: "field",
            valueType: "field"
          },
          {
            key: "labelonly",
            valueType: "bool"
          },
          {
            key: "match",
            valueType: ""
          }
        ],
        functions: [],
        keywords: [],
        other: [],
        list: []
      },
      "cluster-command": {
        isList: false,
        args: [
          {
            key: "t",
            valueType: "num"
          },
          {
            key: "delims",
            valueType: "string"
          },
          {
            key: "showcount",
            valueType: "bool"
          },
          {
            key: "countfield",
            valueType: "field"
          },
          {
            key: "labelfield",
            valueType: "field"
          },
          {
            key: "field",
            valueType: "field"
          },
          {
            key: "labelonly",
            valueType: "bool"
          },
          {
            key: "match",
            valueType: ""
          }
        ],
        functions: [],
        keywords: [],
        other: [],
        list: []
      },
      "cofilter-command": {
        isList: false,
        args: [],
        functions: [],
        keywords: [],
        other: [],
        list: []
      },
      "collapse-command": {
        isList: false,
        args: [
          {
            key: "chunksize",
            valueType: "num"
          },
          {
            key: "force",
            valueType: "bool"
          }
        ],
        functions: [],
        keywords: [],
        other: [],
        list: []
      },
      "stash-command": {
        isList: false,
        args: [
          {
            key: "index",
            valueType: "string"
          },
          {
            key: "addtime",
            valueType: "bool"
          },
          {
            key: "file",
            valueType: "string"
          },
          {
            key: "spool",
            valueType: "bool"
          },
          {
            key: "marker",
            valueType: "string"
          },
          {
            key: "testmode",
            valueType: "bool"
          },
          {
            key: "run_in_preview",
            valueType: "bool"
          },
          {
            key: "host",
            valueType: "string"
          },
          {
            key: "source",
            valueType: "string"
          },
          {
            key: "sourcetype",
            valueType: "string"
          },
          {
            key: "uselb",
            valueType: "bool"
          },
          {
            key: "output_format",
            valueType: ""
          }
        ],
        functions: [],
        keywords: [],
        other: [],
        list: []
      },
      "summaryindex-command": {
        isList: false,
        args: [
          {
            key: "index",
            valueType: "string"
          },
          {
            key: "addtime",
            valueType: "bool"
          },
          {
            key: "file",
            valueType: "string"
          },
          {
            key: "spool",
            valueType: "bool"
          },
          {
            key: "marker",
            valueType: "string"
          },
          {
            key: "testmode",
            valueType: "bool"
          },
          {
            key: "run_in_preview",
            valueType: "bool"
          },
          {
            key: "host",
            valueType: "string"
          },
          {
            key: "source",
            valueType: "string"
          },
          {
            key: "sourcetype",
            valueType: "string"
          },
          {
            key: "uselb",
            valueType: "bool"
          },
          {
            key: "output_format",
            valueType: ""
          }
        ],
        functions: [],
        keywords: [],
        other: [],
        list: []
      },
      "sumindex-command": {
        isList: false,
        args: [
          {
            key: "index",
            valueType: "string"
          },
          {
            key: "addtime",
            valueType: "bool"
          },
          {
            key: "file",
            valueType: "string"
          },
          {
            key: "spool",
            valueType: "bool"
          },
          {
            key: "marker",
            valueType: "string"
          },
          {
            key: "testmode",
            valueType: "bool"
          },
          {
            key: "run_in_preview",
            valueType: "bool"
          },
          {
            key: "host",
            valueType: "string"
          },
          {
            key: "source",
            valueType: "string"
          },
          {
            key: "sourcetype",
            valueType: "string"
          },
          {
            key: "uselb",
            valueType: "bool"
          },
          {
            key: "output_format",
            valueType: ""
          }
        ],
        functions: [],
        keywords: [],
        other: [],
        list: []
      },
      "collect-command": {
        isList: false,
        args: [
          {
            key: "index",
            valueType: "string"
          },
          {
            key: "addtime",
            valueType: "bool"
          },
          {
            key: "file",
            valueType: "string"
          },
          {
            key: "spool",
            valueType: "bool"
          },
          {
            key: "marker",
            valueType: "string"
          },
          {
            key: "testmode",
            valueType: "bool"
          },
          {
            key: "run_in_preview",
            valueType: "bool"
          },
          {
            key: "host",
            valueType: "string"
          },
          {
            key: "source",
            valueType: "string"
          },
          {
            key: "sourcetype",
            valueType: "string"
          },
          {
            key: "uselb",
            valueType: "bool"
          },
          {
            key: "output_format",
            valueType: ""
          }
        ],
        functions: [],
        keywords: [],
        other: [],
        list: []
      },
      "concurrency-command": {
        isList: false,
        args: [
          {
            key: "duration",
            valueType: "field"
          },
          {
            key: "start",
            valueType: "field"
          },
          {
            key: "output",
            valueType: "field"
          }
        ],
        functions: [],
        keywords: [],
        other: [],
        list: []
      },
      "counttable-command": {
        isList: false,
        args: [
          {
            key: "maxrows",
            valueType: "int"
          },
          {
            key: "maxcols",
            valueType: "int"
          },
          {
            key: "mincolcover",
            valueType: "num"
          },
          {
            key: "minrowcover",
            valueType: "num"
          },
          {
            key: "usetotal",
            valueType: "bool"
          },
          {
            key: "totalstr",
            valueType: "field"
          }
        ],
        functions: [],
        keywords: [],
        other: ["field", "field"],
        list: []
      },
      "ctable-command": {
        isList: false,
        args: [
          {
            key: "maxrows",
            valueType: "int"
          },
          {
            key: "maxcols",
            valueType: "int"
          },
          {
            key: "mincolcover",
            valueType: "num"
          },
          {
            key: "minrowcover",
            valueType: "num"
          },
          {
            key: "usetotal",
            valueType: "bool"
          },
          {
            key: "totalstr",
            valueType: "field"
          }
        ],
        functions: [],
        keywords: [],
        other: ["field", "field"],
        list: []
      },
      "contingency-command": {
        isList: false,
        args: [
          {
            key: "maxrows",
            valueType: "int"
          },
          {
            key: "maxcols",
            valueType: "int"
          },
          {
            key: "mincolcover",
            valueType: "num"
          },
          {
            key: "minrowcover",
            valueType: "num"
          },
          {
            key: "usetotal",
            valueType: "bool"
          },
          {
            key: "totalstr",
            valueType: "field"
          }
        ],
        functions: [],
        keywords: [],
        other: ["field", "field"],
        list: []
      },
      "convert-command": {
        isList: false,
        args: [
          {
            key: "timeformat",
            valueType: "string"
          }
        ],
        functions: [
          {
            name: "auto",
            parenOptional: true
          },
          {
            name: "dur2sec",
            parenOptional: false
          },
          {
            name: "mstime",
            parenOptional: false
          },
          {
            name: "memk",
            parenOptional: false
          },
          {
            name: "none",
            parenOptional: false
          },
          {
            name: "num",
            parenOptional: false
          },
          {
            name: "rmunit",
            parenOptional: false
          },
          {
            name: "rmcomma",
            parenOptional: false
          },
          {
            name: "ctime",
            parenOptional: false
          },
          {
            name: "mktime",
            parenOptional: false
          }
        ],
        keywords: ["as"],
        other: ["wc-field", "wc-field"],
        list: []
      },
      "copyresults-command": {
        isList: false,
        args: [
          {
            key: "dest",
            valueType: "string"
          },
          {
            key: "sid",
            valueType: "string"
          }
        ],
        functions: [],
        keywords: [],
        other: [],
        list: []
      },
      "correlate-command": {
        isList: false,
        args: [],
        functions: [],
        keywords: [],
        other: [],
        list: []
      },
      "createrss-command": {
        isList: false,
        args: [
          {
            key: "path",
            valueType: "string"
          },
          {
            key: "name",
            valueType: "string"
          },
          {
            key: "link",
            valueType: "string"
          },
          {
            key: "descr",
            valueType: "string"
          },
          {
            key: "count",
            valueType: "int"
          },
          {
            key: "graceful",
            valueType: "bool"
          }
        ],
        functions: [],
        keywords: [],
        other: [],
        list: []
      },
      "datamodel-command": {
        isList: false,
        args: [
          {
            key: "allow_old_summaries",
            valueType: "bool"
          },
          {
            key: "summariesonly",
            valueType: "bool"
          },
          {
            key: "strict_fields",
            valueType: "bool"
          }
        ],
        functions: [],
        keywords: [],
        other: ["string"],
        list: []
      },
      "dbinspect-command": {
        isList: false,
        args: [
          {
            key: "index",
            valueType: "string"
          },
          {
            key: "span",
            valueType: ""
          },
          {
            key: "timeformat",
            valueType: "string"
          },
          {
            key: "corruptonly",
            valueType: "bool"
          },
          {
            key: "bucketstate",
            valueType: "bucketstate-type"
          }
        ],
        functions: [],
        keywords: [],
        other: [],
        list: []
      },
      "debug-command": {
        isList: false,
        args: [
          {
            key: "cmd",
            valueType: "debug-method"
          },
          {
            key: "param1",
            valueType: "string"
          },
          {
            key: "param2",
            valueType: "string"
          }
        ],
        functions: [],
        keywords: [],
        other: ["string"],
        list: []
      },
      "dedup-command": {
        isList: false,
        args: [
          {
            key: "keepevents",
            valueType: "bool"
          },
          {
            key: "keepempty",
            valueType: "bool"
          },
          {
            key: "consecutive",
            valueType: "bool"
          }
        ],
        functions: [],
        keywords: ["sortby"],
        other: ["int", "field-list", "field"],
        list: []
      },
      "delete-command": {
        isList: false,
        args: [],
        functions: [],
        keywords: [],
        other: [],
        list: []
      },
      "delta-command": {
        isList: false,
        args: [
          {
            key: "p",
            valueType: "int"
          }
        ],
        functions: [],
        keywords: ["as"],
        other: ["field", "field:newfield"],
        list: []
      },
      "dfsjob-command": {
        isList: false,
        args: [],
        functions: [],
        keywords: [],
        other: ["string"],
        list: []
      },
      "diff-command": {
        isList: false,
        args: [
          {
            key: "position1",
            valueType: "int"
          },
          {
            key: "position2",
            valueType: "int"
          },
          {
            key: "attribute",
            valueType: "string"
          },
          {
            key: "diffheader",
            valueType: "bool"
          },
          {
            key: "context",
            valueType: "bool"
          },
          {
            key: "maxlen",
            valueType: "int"
          }
        ],
        functions: [],
        keywords: [],
        other: [],
        list: []
      },
      "dispatch-command": {
        isList: false,
        args: [
          {
            key: "ttl",
            valueType: "num"
          },
          {
            key: "maxresults",
            valueType: "num"
          },
          {
            key: "maxtime",
            valueType: "num"
          },
          {
            key: "id",
            valueType: "string"
          },
          {
            key: "spawn_process",
            valueType: "bool"
          },
          {
            key: "label",
            valueType: "string"
          },
          {
            key: "start_time",
            valueType: "num"
          },
          {
            key: "end_time",
            valueType: "num"
          }
        ],
        functions: [],
        keywords: [],
        other: ["string", "search-pipeline"],
        list: []
      },
      "dump-command": {
        isList: false,
        args: [
          {
            key: "basefilename",
            valueType: "string"
          },
          {
            key: "rollsize",
            valueType: "num"
          },
          {
            key: "compress",
            valueType: "int"
          },
          {
            key: "format",
            valueType: "string"
          },
          {
            key: "fields",
            valueType: "comma-delimited-string"
          }
        ],
        functions: [],
        keywords: [],
        other: [],
        list: []
      },
      "editinfo-command": {
        isList: false,
        args: [
          {
            key: "keyset",
            valueType: ""
          },
          {
            key: "starttime",
            valueType: ""
          },
          {
            key: "endtime",
            valueType: ""
          },
          {
            key: "msg_error",
            valueType: ""
          },
          {
            key: "msg_warn",
            valueType: ""
          },
          {
            key: "msg_info",
            valueType: ""
          },
          {
            key: "msg_debug",
            valueType: ""
          }
        ],
        functions: [],
        keywords: [],
        other: [],
        list: []
      },
      "erex-command": {
        isList: false,
        args: [
          {
            key: "examples",
            valueType: "erex-examples"
          },
          {
            key: "counterexamples",
            valueType: "erex-examples"
          },
          {
            key: "fromfield",
            valueType: "field"
          },
          {
            key: "maxtrainers",
            valueType: "int"
          }
        ],
        functions: [],
        keywords: [],
        other: ["field"],
        list: []
      },
      "eval-command": {
        isList: false,
        args: [],
        functions: [
          {
            name: "abs",
            parenOptional: false
          },
          {
            name: "avg",
            parenOptional: false
          },
          {
            name: "case",
            parenOptional: false
          },
          {
            name: "ceiling",
            parenOptional: false
          },
          {
            name: "ceil",
            parenOptional: false
          },
          {
            name: "cidrmatch",
            parenOptional: false
          },
          {
            name: "coalesce",
            parenOptional: false
          },
          {
            name: "commands",
            parenOptional: false
          },
          {
            name: "exact",
            parenOptional: false
          },
          {
            name: "exp",
            parenOptional: false
          },
          {
            name: "false",
            parenOptional: false
          },
          {
            name: "floor",
            parenOptional: false
          },
          {
            name: "if",
            parenOptional: false
          },
          {
            name: "ifnull",
            parenOptional: false
          },
          {
            name: "isbool",
            parenOptional: false
          },
          {
            name: "isint",
            parenOptional: false
          },
          {
            name: "isnotnull",
            parenOptional: false
          },
          {
            name: "isnull",
            parenOptional: false
          },
          {
            name: "isnum",
            parenOptional: false
          },
          {
            name: "isstr",
            parenOptional: false
          },
          {
            name: "len",
            parenOptional: false
          },
          {
            name: "like",
            parenOptional: false
          },
          {
            name: "ln",
            parenOptional: false
          },
          {
            name: "log",
            parenOptional: false
          },
          {
            name: "lookup",
            parenOptional: false
          },
          {
            name: "lower",
            parenOptional: false
          },
          {
            name: "match",
            parenOptional: false
          },
          {
            name: "max",
            parenOptional: false
          },
          {
            name: "md5",
            parenOptional: false
          },
          {
            name: "min",
            parenOptional: false
          },
          {
            name: "mvappend",
            parenOptional: false
          },
          {
            name: "mvcount",
            parenOptional: false
          },
          {
            name: "mvdedup",
            parenOptional: false
          },
          {
            name: "mvindex",
            parenOptional: false
          },
          {
            name: "mvfilter",
            parenOptional: false
          },
          {
            name: "mvfind",
            parenOptional: false
          },
          {
            name: "mvjoin",
            parenOptional: false
          },
          {
            name: "mvmap",
            parenOptional: false
          },
          {
            name: "mvrange",
            parenOptional: false
          },
          {
            name: "mvsort",
            parenOptional: false
          },
          {
            name: "mvzip",
            parenOptional: false
          },
          {
            name: "now",
            parenOptional: false
          },
          {
            name: "null",
            parenOptional: false
          },
          {
            name: "nullif",
            parenOptional: false
          },
          {
            name: "pi",
            parenOptional: false
          },
          {
            name: "pow",
            parenOptional: false
          },
          {
            name: "random",
            parenOptional: false
          },
          {
            name: "relative_time",
            parenOptional: false
          },
          {
            name: "replace",
            parenOptional: false
          },
          {
            name: "round",
            parenOptional: false
          },
          {
            name: "searchmatch",
            parenOptional: false
          },
          {
            name: "sha1",
            parenOptional: false
          },
          {
            name: "sha256",
            parenOptional: false
          },
          {
            name: "sha512",
            parenOptional: false
          },
          {
            name: "sigfig",
            parenOptional: false
          },
          {
            name: "spath",
            parenOptional: false
          },
          {
            name: "split",
            parenOptional: false
          },
          {
            name: "sqrt",
            parenOptional: false
          },
          {
            name: "strftime",
            parenOptional: false
          },
          {
            name: "strptime",
            parenOptional: false
          },
          {
            name: "substr",
            parenOptional: false
          },
          {
            name: "sum",
            parenOptional: false
          },
          {
            name: "time",
            parenOptional: false
          },
          {
            name: "tostring",
            parenOptional: false
          },
          {
            name: "trim",
            parenOptional: false
          },
          {
            name: "ltrim",
            parenOptional: false
          },
          {
            name: "rtrim",
            parenOptional: false
          },
          {
            name: "true",
            parenOptional: false
          },
          {
            name: "typeof",
            parenOptional: false
          },
          {
            name: "upper",
            parenOptional: false
          },
          {
            name: "urldecode",
            parenOptional: false
          },
          {
            name: "validate",
            parenOptional: false
          },
          {
            name: "tonumber",
            parenOptional: false
          },
          {
            name: "acos",
            parenOptional: false
          },
          {
            name: "acosh",
            parenOptional: false
          },
          {
            name: "asin",
            parenOptional: false
          },
          {
            name: "asinh",
            parenOptional: false
          },
          {
            name: "atan",
            parenOptional: false
          },
          {
            name: "atan2",
            parenOptional: false
          },
          {
            name: "atanh",
            parenOptional: false
          },
          {
            name: "cos",
            parenOptional: false
          },
          {
            name: "cosh",
            parenOptional: false
          },
          {
            name: "hypot",
            parenOptional: false
          },
          {
            name: "sin",
            parenOptional: false
          },
          {
            name: "sinh",
            parenOptional: false
          },
          {
            name: "tan",
            parenOptional: false
          },
          {
            name: "tanh",
            parenOptional: false
          },
          {
            name: "json_array_to_mv",
            parenOptional: false
          },
          {
            name: "mv_to_json_array",
            parenOptional: false
          },
          {
            name: "json_append",
            parenOptional: false
          },
          {
            name: "json_extend",
            parenOptional: false
          },
          {
            name: "json_extract_exact",
            parenOptional: false
          },
          {
            name: "json_set_exact",
            parenOptional: false
          }
        ],
        keywords: ["LIKE", "AND|OR|XOR"],
        other: ["field", "num", "string"],
        list: []
      },
      "eventcount-command": {
        isList: false,
        args: [
          {
            key: "index",
            valueType: "string"
          },
          {
            key: "summarize",
            valueType: "bool"
          },
          {
            key: "report_size",
            valueType: "bool"
          },
          {
            key: "list_vix",
            valueType: "bool"
          }
        ],
        functions: [],
        keywords: [],
        other: [],
        list: []
      },
      "eventstats-command": {
        isList: false,
        args: [
          {
            key: "allnum",
            valueType: "bool"
          }
        ],
        functions: [
          {
            name: "c",
            parenOptional: true
          },
          {
            name: "count",
            parenOptional: true
          },
          {
            name: "dc",
            parenOptional: true
          },
          {
            name: "distinct_count",
            parenOptional: true
          },
          {
            name: "mean",
            parenOptional: true
          },
          {
            name: "avg",
            parenOptional: true
          },
          {
            name: "stdev",
            parenOptional: true
          },
          {
            name: "stdevp",
            parenOptional: true
          },
          {
            name: "var",
            parenOptional: true
          },
          {
            name: "varp",
            parenOptional: true
          },
          {
            name: "sum",
            parenOptional: true
          },
          {
            name: "sumsq",
            parenOptional: true
          },
          {
            name: "min",
            parenOptional: true
          },
          {
            name: "max",
            parenOptional: true
          },
          {
            name: "mode",
            parenOptional: true
          },
          {
            name: "median",
            parenOptional: true
          },
          {
            name: "earliest",
            parenOptional: true
          },
          {
            name: "first",
            parenOptional: true
          },
          {
            name: "last",
            parenOptional: true
          },
          {
            name: "latest",
            parenOptional: true
          },
          {
            name: "list",
            parenOptional: true
          },
          {
            name: "values",
            parenOptional: true
          },
          {
            name: "range",
            parenOptional: true
          },
          {
            name: "estdc",
            parenOptional: true
          },
          {
            name: "estdc_error",
            parenOptional: true
          },
          {
            name: "earliest_time",
            parenOptional: true
          },
          {
            name: "latest_time",
            parenOptional: true
          },
          {
            name: "rate",
            parenOptional: true
          },
          {
            name: "eval",
            parenOptional: false
          },
          {
            name: "abs",
            parenOptional: false
          },
          {
            name: "avg",
            parenOptional: false
          },
          {
            name: "case",
            parenOptional: false
          },
          {
            name: "ceiling",
            parenOptional: false
          },
          {
            name: "ceil",
            parenOptional: false
          },
          {
            name: "cidrmatch",
            parenOptional: false
          },
          {
            name: "coalesce",
            parenOptional: false
          },
          {
            name: "commands",
            parenOptional: false
          },
          {
            name: "exact",
            parenOptional: false
          },
          {
            name: "exp",
            parenOptional: false
          },
          {
            name: "false",
            parenOptional: false
          },
          {
            name: "floor",
            parenOptional: false
          },
          {
            name: "if",
            parenOptional: false
          },
          {
            name: "ifnull",
            parenOptional: false
          },
          {
            name: "isbool",
            parenOptional: false
          },
          {
            name: "isint",
            parenOptional: false
          },
          {
            name: "isnotnull",
            parenOptional: false
          },
          {
            name: "isnull",
            parenOptional: false
          },
          {
            name: "isnum",
            parenOptional: false
          },
          {
            name: "isstr",
            parenOptional: false
          },
          {
            name: "len",
            parenOptional: false
          },
          {
            name: "like",
            parenOptional: false
          },
          {
            name: "ln",
            parenOptional: false
          },
          {
            name: "log",
            parenOptional: false
          },
          {
            name: "lookup",
            parenOptional: false
          },
          {
            name: "lower",
            parenOptional: false
          },
          {
            name: "match",
            parenOptional: false
          },
          {
            name: "max",
            parenOptional: false
          },
          {
            name: "md5",
            parenOptional: false
          },
          {
            name: "min",
            parenOptional: false
          },
          {
            name: "mvappend",
            parenOptional: false
          },
          {
            name: "mvcount",
            parenOptional: false
          },
          {
            name: "mvdedup",
            parenOptional: false
          },
          {
            name: "mvindex",
            parenOptional: false
          },
          {
            name: "mvfilter",
            parenOptional: false
          },
          {
            name: "mvfind",
            parenOptional: false
          },
          {
            name: "mvjoin",
            parenOptional: false
          },
          {
            name: "mvmap",
            parenOptional: false
          },
          {
            name: "mvrange",
            parenOptional: false
          },
          {
            name: "mvsort",
            parenOptional: false
          },
          {
            name: "mvzip",
            parenOptional: false
          },
          {
            name: "now",
            parenOptional: false
          },
          {
            name: "null",
            parenOptional: false
          },
          {
            name: "nullif",
            parenOptional: false
          },
          {
            name: "pi",
            parenOptional: false
          },
          {
            name: "pow",
            parenOptional: false
          },
          {
            name: "random",
            parenOptional: false
          },
          {
            name: "relative_time",
            parenOptional: false
          },
          {
            name: "replace",
            parenOptional: false
          },
          {
            name: "round",
            parenOptional: false
          },
          {
            name: "searchmatch",
            parenOptional: false
          },
          {
            name: "sha1",
            parenOptional: false
          },
          {
            name: "sha256",
            parenOptional: false
          },
          {
            name: "sha512",
            parenOptional: false
          },
          {
            name: "sigfig",
            parenOptional: false
          },
          {
            name: "spath",
            parenOptional: false
          },
          {
            name: "split",
            parenOptional: false
          },
          {
            name: "sqrt",
            parenOptional: false
          },
          {
            name: "strftime",
            parenOptional: false
          },
          {
            name: "strptime",
            parenOptional: false
          },
          {
            name: "substr",
            parenOptional: false
          },
          {
            name: "sum",
            parenOptional: false
          },
          {
            name: "time",
            parenOptional: false
          },
          {
            name: "tostring",
            parenOptional: false
          },
          {
            name: "trim",
            parenOptional: false
          },
          {
            name: "ltrim",
            parenOptional: false
          },
          {
            name: "rtrim",
            parenOptional: false
          },
          {
            name: "true",
            parenOptional: false
          },
          {
            name: "typeof",
            parenOptional: false
          },
          {
            name: "upper",
            parenOptional: false
          },
          {
            name: "urldecode",
            parenOptional: false
          },
          {
            name: "validate",
            parenOptional: false
          },
          {
            name: "tonumber",
            parenOptional: false
          },
          {
            name: "acos",
            parenOptional: false
          },
          {
            name: "acosh",
            parenOptional: false
          },
          {
            name: "asin",
            parenOptional: false
          },
          {
            name: "asinh",
            parenOptional: false
          },
          {
            name: "atan",
            parenOptional: false
          },
          {
            name: "atan2",
            parenOptional: false
          },
          {
            name: "atanh",
            parenOptional: false
          },
          {
            name: "cos",
            parenOptional: false
          },
          {
            name: "cosh",
            parenOptional: false
          },
          {
            name: "hypot",
            parenOptional: false
          },
          {
            name: "sin",
            parenOptional: false
          },
          {
            name: "sinh",
            parenOptional: false
          },
          {
            name: "tan",
            parenOptional: false
          },
          {
            name: "tanh",
            parenOptional: false
          },
          {
            name: "json_array_to_mv",
            parenOptional: false
          },
          {
            name: "mv_to_json_array",
            parenOptional: false
          },
          {
            name: "json_append",
            parenOptional: false
          },
          {
            name: "json_extend",
            parenOptional: false
          },
          {
            name: "json_extract_exact",
            parenOptional: false
          },
          {
            name: "json_set_exact",
            parenOptional: false
          }
        ],
        keywords: ["LIKE", "AND|OR|XOR", "as", "by"],
        other: ["field", "num", "string", "wc-field", "field-list"],
        list: []
      },
      "kv-command": {
        isList: false,
        args: [
          {
            key: "segment",
            valueType: "bool"
          },
          {
            key: "reload",
            valueType: "bool"
          },
          {
            key: "kvdelim",
            valueType: "string"
          },
          {
            key: "pairdelim",
            valueType: "string"
          },
          {
            key: "limit",
            valueType: "int"
          },
          {
            key: "maxchars",
            valueType: "int"
          },
          {
            key: "mv_add",
            valueType: "bool"
          },
          {
            key: "clean_keys",
            valueType: "bool"
          }
        ],
        functions: [],
        keywords: [],
        other: ["string"],
        list: []
      },
      "extract-command": {
        isList: false,
        args: [
          {
            key: "segment",
            valueType: "bool"
          },
          {
            key: "reload",
            valueType: "bool"
          },
          {
            key: "kvdelim",
            valueType: "string"
          },
          {
            key: "pairdelim",
            valueType: "string"
          },
          {
            key: "limit",
            valueType: "int"
          },
          {
            key: "maxchars",
            valueType: "int"
          },
          {
            key: "mv_add",
            valueType: "bool"
          },
          {
            key: "clean_keys",
            valueType: "bool"
          }
        ],
        functions: [],
        keywords: [],
        other: ["string"],
        list: []
      },
      "fieldformat-command": {
        isList: false,
        args: [],
        functions: [
          {
            name: "abs",
            parenOptional: false
          },
          {
            name: "avg",
            parenOptional: false
          },
          {
            name: "case",
            parenOptional: false
          },
          {
            name: "ceiling",
            parenOptional: false
          },
          {
            name: "ceil",
            parenOptional: false
          },
          {
            name: "cidrmatch",
            parenOptional: false
          },
          {
            name: "coalesce",
            parenOptional: false
          },
          {
            name: "commands",
            parenOptional: false
          },
          {
            name: "exact",
            parenOptional: false
          },
          {
            name: "exp",
            parenOptional: false
          },
          {
            name: "false",
            parenOptional: false
          },
          {
            name: "floor",
            parenOptional: false
          },
          {
            name: "if",
            parenOptional: false
          },
          {
            name: "ifnull",
            parenOptional: false
          },
          {
            name: "isbool",
            parenOptional: false
          },
          {
            name: "isint",
            parenOptional: false
          },
          {
            name: "isnotnull",
            parenOptional: false
          },
          {
            name: "isnull",
            parenOptional: false
          },
          {
            name: "isnum",
            parenOptional: false
          },
          {
            name: "isstr",
            parenOptional: false
          },
          {
            name: "len",
            parenOptional: false
          },
          {
            name: "like",
            parenOptional: false
          },
          {
            name: "ln",
            parenOptional: false
          },
          {
            name: "log",
            parenOptional: false
          },
          {
            name: "lookup",
            parenOptional: false
          },
          {
            name: "lower",
            parenOptional: false
          },
          {
            name: "match",
            parenOptional: false
          },
          {
            name: "max",
            parenOptional: false
          },
          {
            name: "md5",
            parenOptional: false
          },
          {
            name: "min",
            parenOptional: false
          },
          {
            name: "mvappend",
            parenOptional: false
          },
          {
            name: "mvcount",
            parenOptional: false
          },
          {
            name: "mvdedup",
            parenOptional: false
          },
          {
            name: "mvindex",
            parenOptional: false
          },
          {
            name: "mvfilter",
            parenOptional: false
          },
          {
            name: "mvfind",
            parenOptional: false
          },
          {
            name: "mvjoin",
            parenOptional: false
          },
          {
            name: "mvmap",
            parenOptional: false
          },
          {
            name: "mvrange",
            parenOptional: false
          },
          {
            name: "mvsort",
            parenOptional: false
          },
          {
            name: "mvzip",
            parenOptional: false
          },
          {
            name: "now",
            parenOptional: false
          },
          {
            name: "null",
            parenOptional: false
          },
          {
            name: "nullif",
            parenOptional: false
          },
          {
            name: "pi",
            parenOptional: false
          },
          {
            name: "pow",
            parenOptional: false
          },
          {
            name: "random",
            parenOptional: false
          },
          {
            name: "relative_time",
            parenOptional: false
          },
          {
            name: "replace",
            parenOptional: false
          },
          {
            name: "round",
            parenOptional: false
          },
          {
            name: "searchmatch",
            parenOptional: false
          },
          {
            name: "sha1",
            parenOptional: false
          },
          {
            name: "sha256",
            parenOptional: false
          },
          {
            name: "sha512",
            parenOptional: false
          },
          {
            name: "sigfig",
            parenOptional: false
          },
          {
            name: "spath",
            parenOptional: false
          },
          {
            name: "split",
            parenOptional: false
          },
          {
            name: "sqrt",
            parenOptional: false
          },
          {
            name: "strftime",
            parenOptional: false
          },
          {
            name: "strptime",
            parenOptional: false
          },
          {
            name: "substr",
            parenOptional: false
          },
          {
            name: "sum",
            parenOptional: false
          },
          {
            name: "time",
            parenOptional: false
          },
          {
            name: "tostring",
            parenOptional: false
          },
          {
            name: "trim",
            parenOptional: false
          },
          {
            name: "ltrim",
            parenOptional: false
          },
          {
            name: "rtrim",
            parenOptional: false
          },
          {
            name: "true",
            parenOptional: false
          },
          {
            name: "typeof",
            parenOptional: false
          },
          {
            name: "upper",
            parenOptional: false
          },
          {
            name: "urldecode",
            parenOptional: false
          },
          {
            name: "validate",
            parenOptional: false
          },
          {
            name: "tonumber",
            parenOptional: false
          },
          {
            name: "acos",
            parenOptional: false
          },
          {
            name: "acosh",
            parenOptional: false
          },
          {
            name: "asin",
            parenOptional: false
          },
          {
            name: "asinh",
            parenOptional: false
          },
          {
            name: "atan",
            parenOptional: false
          },
          {
            name: "atan2",
            parenOptional: false
          },
          {
            name: "atanh",
            parenOptional: false
          },
          {
            name: "cos",
            parenOptional: false
          },
          {
            name: "cosh",
            parenOptional: false
          },
          {
            name: "hypot",
            parenOptional: false
          },
          {
            name: "sin",
            parenOptional: false
          },
          {
            name: "sinh",
            parenOptional: false
          },
          {
            name: "tan",
            parenOptional: false
          },
          {
            name: "tanh",
            parenOptional: false
          },
          {
            name: "json_array_to_mv",
            parenOptional: false
          },
          {
            name: "mv_to_json_array",
            parenOptional: false
          },
          {
            name: "json_append",
            parenOptional: false
          },
          {
            name: "json_extend",
            parenOptional: false
          },
          {
            name: "json_extract_exact",
            parenOptional: false
          },
          {
            name: "json_set_exact",
            parenOptional: false
          }
        ],
        keywords: ["LIKE", "AND|OR|XOR"],
        other: ["field", "num", "string"],
        list: []
      },
      "fields-command": {
        isList: false,
        args: [],
        functions: [],
        keywords: [],
        other: ["wc-field-list"],
        list: []
      },
      "fieldsummary-command": {
        isList: false,
        args: [
          {
            key: "maxvals",
            valueType: "num"
          }
        ],
        functions: [],
        keywords: [],
        other: ["wc-field-list"],
        list: []
      },
      "test-command": {
        isList: false,
        args: [],
        functions: [],
        keywords: [],
        other: ["filename"],
        list: []
      },
      "file-command": {
        isList: false,
        args: [],
        functions: [],
        keywords: [],
        other: ["filename"],
        list: []
      },
      "filldown-command": {
        isList: false,
        args: [],
        functions: [],
        keywords: [],
        other: ["wc-field-list"],
        list: []
      },
      "fillnull-command": {
        isList: false,
        args: [
          {
            key: "value",
            valueType: "string"
          }
        ],
        functions: [],
        keywords: [],
        other: ["field-list"],
        list: []
      },
      "findkeywords-command": {
        isList: false,
        args: [
          {
            key: "labelfield",
            valueType: "field"
          },
          {
            key: "dedup",
            valueType: "bool"
          }
        ],
        functions: [],
        keywords: [],
        other: [],
        list: []
      },
      "findtypes-command": {
        isList: false,
        args: [
          {
            key: "max",
            valueType: "int"
          }
        ],
        functions: [],
        keywords: [],
        other: [],
        list: []
      },
      "folderize-command": {
        isList: false,
        args: [
          {
            key: "attr",
            valueType: "string"
          },
          {
            key: "sep",
            valueType: "string"
          },
          {
            key: "size",
            valueType: "string"
          },
          {
            key: "minfolders",
            valueType: "int"
          },
          {
            key: "maxfolders",
            valueType: "int"
          }
        ],
        functions: [],
        keywords: [],
        other: [],
        list: []
      },
      "foreach-command": {
        isList: false,
        args: [
          {
            key: "fieldstr",
            valueType: "string"
          },
          {
            key: "matchstr",
            valueType: "string"
          },
          {
            key: "matchseg1",
            valueType: "string"
          },
          {
            key: "matchseg2",
            valueType: "string"
          },
          {
            key: "matchseg3",
            valueType: "string"
          }
        ],
        functions: [],
        keywords: [],
        other: ["wc-field", "string"],
        list: []
      },
      "format-command": {
        isList: false,
        args: [
          {
            key: "quote",
            valueType: "bool"
          },
          {
            key: "mvsep",
            valueType: ""
          },
          {
            key: "maxresults",
            valueType: "int"
          }
        ],
        functions: [],
        keywords: [],
        other: ["double-quoted-string", "row end"],
        list: []
      },
      "from-command": {
        isList: true,
        args: [],
        functions: [],
        keywords: [],
        other: ["ws", "string"],
        list: ["datamodel", "savedsearch", "inputlookup", "federated"]
      },
      "gauge-command": {
        isList: false,
        args: [],
        functions: [],
        keywords: [],
        other: ["num", "field", "num", "field"],
        list: []
      },
      "gentimes-command": {
        isList: false,
        args: [
          {
            key: "start",
            valueType: "timestamp"
          },
          {
            key: "end",
            valueType: "timestamp"
          },
          {
            key: "increment",
            valueType: "increment"
          }
        ],
        functions: [],
        keywords: [],
        other: [],
        list: []
      },
      "geom-command": {
        isList: false,
        args: [
          {
            key: "allFeatures",
            valueType: "bool"
          },
          {
            key: "featureIdField",
            valueType: "string"
          },
          {
            key: "gen",
            valueType: "num"
          },
          {
            key: "min_x",
            valueType: "num"
          },
          {
            key: "min_y",
            valueType: "num"
          },
          {
            key: "max_x",
            valueType: "num"
          },
          {
            key: "max_y",
            valueType: "num"
          }
        ],
        functions: [],
        keywords: [],
        other: ["string"],
        list: []
      },
      "geomfilter-command": {
        isList: false,
        args: [
          {
            key: "min_x",
            valueType: "num"
          },
          {
            key: "min_y",
            valueType: "num"
          },
          {
            key: "max_x",
            valueType: "num"
          },
          {
            key: "max_y",
            valueType: "num"
          }
        ],
        functions: [],
        keywords: [],
        other: [],
        list: []
      },
      "geostats-command": {
        isList: false,
        args: [
          {
            key: "translatetoxy",
            valueType: "bool"
          },
          {
            key: "latfield",
            valueType: "string"
          },
          {
            key: "longfield",
            valueType: "string"
          },
          {
            key: "outputlatfield",
            valueType: "string"
          },
          {
            key: "outputlongfield",
            valueType: "string"
          },
          {
            key: "globallimit",
            valueType: "int"
          },
          {
            key: "locallimit",
            valueType: "int"
          },
          {
            key: "binspanlat",
            valueType: "float"
          },
          {
            key: "binspanlong",
            valueType: ""
          },
          {
            key: "maxzoomlevel",
            valueType: "int"
          }
        ],
        functions: [
          {
            name: "c",
            parenOptional: true
          },
          {
            name: "count",
            parenOptional: true
          },
          {
            name: "dc",
            parenOptional: true
          },
          {
            name: "distinct_count",
            parenOptional: true
          },
          {
            name: "mean",
            parenOptional: true
          },
          {
            name: "avg",
            parenOptional: true
          },
          {
            name: "stdev",
            parenOptional: true
          },
          {
            name: "stdevp",
            parenOptional: true
          },
          {
            name: "var",
            parenOptional: true
          },
          {
            name: "varp",
            parenOptional: true
          },
          {
            name: "sum",
            parenOptional: true
          },
          {
            name: "sumsq",
            parenOptional: true
          },
          {
            name: "min",
            parenOptional: true
          },
          {
            name: "max",
            parenOptional: true
          },
          {
            name: "mode",
            parenOptional: true
          },
          {
            name: "median",
            parenOptional: true
          },
          {
            name: "earliest",
            parenOptional: true
          },
          {
            name: "first",
            parenOptional: true
          },
          {
            name: "last",
            parenOptional: true
          },
          {
            name: "latest",
            parenOptional: true
          },
          {
            name: "list",
            parenOptional: true
          },
          {
            name: "values",
            parenOptional: true
          },
          {
            name: "range",
            parenOptional: true
          },
          {
            name: "estdc",
            parenOptional: true
          },
          {
            name: "estdc_error",
            parenOptional: true
          },
          {
            name: "earliest_time",
            parenOptional: true
          },
          {
            name: "latest_time",
            parenOptional: true
          },
          {
            name: "rate",
            parenOptional: true
          },
          {
            name: "eval",
            parenOptional: false
          },
          {
            name: "abs",
            parenOptional: false
          },
          {
            name: "avg",
            parenOptional: false
          },
          {
            name: "case",
            parenOptional: false
          },
          {
            name: "ceiling",
            parenOptional: false
          },
          {
            name: "ceil",
            parenOptional: false
          },
          {
            name: "cidrmatch",
            parenOptional: false
          },
          {
            name: "coalesce",
            parenOptional: false
          },
          {
            name: "commands",
            parenOptional: false
          },
          {
            name: "exact",
            parenOptional: false
          },
          {
            name: "exp",
            parenOptional: false
          },
          {
            name: "false",
            parenOptional: false
          },
          {
            name: "floor",
            parenOptional: false
          },
          {
            name: "if",
            parenOptional: false
          },
          {
            name: "ifnull",
            parenOptional: false
          },
          {
            name: "isbool",
            parenOptional: false
          },
          {
            name: "isint",
            parenOptional: false
          },
          {
            name: "isnotnull",
            parenOptional: false
          },
          {
            name: "isnull",
            parenOptional: false
          },
          {
            name: "isnum",
            parenOptional: false
          },
          {
            name: "isstr",
            parenOptional: false
          },
          {
            name: "len",
            parenOptional: false
          },
          {
            name: "like",
            parenOptional: false
          },
          {
            name: "ln",
            parenOptional: false
          },
          {
            name: "log",
            parenOptional: false
          },
          {
            name: "lookup",
            parenOptional: false
          },
          {
            name: "lower",
            parenOptional: false
          },
          {
            name: "match",
            parenOptional: false
          },
          {
            name: "max",
            parenOptional: false
          },
          {
            name: "md5",
            parenOptional: false
          },
          {
            name: "min",
            parenOptional: false
          },
          {
            name: "mvappend",
            parenOptional: false
          },
          {
            name: "mvcount",
            parenOptional: false
          },
          {
            name: "mvdedup",
            parenOptional: false
          },
          {
            name: "mvindex",
            parenOptional: false
          },
          {
            name: "mvfilter",
            parenOptional: false
          },
          {
            name: "mvfind",
            parenOptional: false
          },
          {
            name: "mvjoin",
            parenOptional: false
          },
          {
            name: "mvmap",
            parenOptional: false
          },
          {
            name: "mvrange",
            parenOptional: false
          },
          {
            name: "mvsort",
            parenOptional: false
          },
          {
            name: "mvzip",
            parenOptional: false
          },
          {
            name: "now",
            parenOptional: false
          },
          {
            name: "null",
            parenOptional: false
          },
          {
            name: "nullif",
            parenOptional: false
          },
          {
            name: "pi",
            parenOptional: false
          },
          {
            name: "pow",
            parenOptional: false
          },
          {
            name: "random",
            parenOptional: false
          },
          {
            name: "relative_time",
            parenOptional: false
          },
          {
            name: "replace",
            parenOptional: false
          },
          {
            name: "round",
            parenOptional: false
          },
          {
            name: "searchmatch",
            parenOptional: false
          },
          {
            name: "sha1",
            parenOptional: false
          },
          {
            name: "sha256",
            parenOptional: false
          },
          {
            name: "sha512",
            parenOptional: false
          },
          {
            name: "sigfig",
            parenOptional: false
          },
          {
            name: "spath",
            parenOptional: false
          },
          {
            name: "split",
            parenOptional: false
          },
          {
            name: "sqrt",
            parenOptional: false
          },
          {
            name: "strftime",
            parenOptional: false
          },
          {
            name: "strptime",
            parenOptional: false
          },
          {
            name: "substr",
            parenOptional: false
          },
          {
            name: "sum",
            parenOptional: false
          },
          {
            name: "time",
            parenOptional: false
          },
          {
            name: "tostring",
            parenOptional: false
          },
          {
            name: "trim",
            parenOptional: false
          },
          {
            name: "ltrim",
            parenOptional: false
          },
          {
            name: "rtrim",
            parenOptional: false
          },
          {
            name: "true",
            parenOptional: false
          },
          {
            name: "typeof",
            parenOptional: false
          },
          {
            name: "upper",
            parenOptional: false
          },
          {
            name: "urldecode",
            parenOptional: false
          },
          {
            name: "validate",
            parenOptional: false
          },
          {
            name: "tonumber",
            parenOptional: false
          },
          {
            name: "acos",
            parenOptional: false
          },
          {
            name: "acosh",
            parenOptional: false
          },
          {
            name: "asin",
            parenOptional: false
          },
          {
            name: "asinh",
            parenOptional: false
          },
          {
            name: "atan",
            parenOptional: false
          },
          {
            name: "atan2",
            parenOptional: false
          },
          {
            name: "atanh",
            parenOptional: false
          },
          {
            name: "cos",
            parenOptional: false
          },
          {
            name: "cosh",
            parenOptional: false
          },
          {
            name: "hypot",
            parenOptional: false
          },
          {
            name: "sin",
            parenOptional: false
          },
          {
            name: "sinh",
            parenOptional: false
          },
          {
            name: "tan",
            parenOptional: false
          },
          {
            name: "tanh",
            parenOptional: false
          },
          {
            name: "json_array_to_mv",
            parenOptional: false
          },
          {
            name: "mv_to_json_array",
            parenOptional: false
          },
          {
            name: "json_append",
            parenOptional: false
          },
          {
            name: "json_extend",
            parenOptional: false
          },
          {
            name: "json_extract_exact",
            parenOptional: false
          },
          {
            name: "json_set_exact",
            parenOptional: false
          }
        ],
        keywords: ["LIKE", "AND|OR|XOR", "as", "by"],
        other: ["field", "num", "string", "wc-field", "field-list"],
        list: []
      },
      "head-command": {
        isList: false,
        args: [
          {
            key: "limit",
            valueType: "int"
          },
          {
            key: "null",
            valueType: "bool"
          },
          {
            key: "keeplast",
            valueType: "bool"
          }
        ],
        functions: [
          {
            name: "abs",
            parenOptional: false
          },
          {
            name: "avg",
            parenOptional: false
          },
          {
            name: "case",
            parenOptional: false
          },
          {
            name: "ceiling",
            parenOptional: false
          },
          {
            name: "ceil",
            parenOptional: false
          },
          {
            name: "cidrmatch",
            parenOptional: false
          },
          {
            name: "coalesce",
            parenOptional: false
          },
          {
            name: "commands",
            parenOptional: false
          },
          {
            name: "exact",
            parenOptional: false
          },
          {
            name: "exp",
            parenOptional: false
          },
          {
            name: "false",
            parenOptional: false
          },
          {
            name: "floor",
            parenOptional: false
          },
          {
            name: "if",
            parenOptional: false
          },
          {
            name: "ifnull",
            parenOptional: false
          },
          {
            name: "isbool",
            parenOptional: false
          },
          {
            name: "isint",
            parenOptional: false
          },
          {
            name: "isnotnull",
            parenOptional: false
          },
          {
            name: "isnull",
            parenOptional: false
          },
          {
            name: "isnum",
            parenOptional: false
          },
          {
            name: "isstr",
            parenOptional: false
          },
          {
            name: "len",
            parenOptional: false
          },
          {
            name: "like",
            parenOptional: false
          },
          {
            name: "ln",
            parenOptional: false
          },
          {
            name: "log",
            parenOptional: false
          },
          {
            name: "lookup",
            parenOptional: false
          },
          {
            name: "lower",
            parenOptional: false
          },
          {
            name: "match",
            parenOptional: false
          },
          {
            name: "max",
            parenOptional: false
          },
          {
            name: "md5",
            parenOptional: false
          },
          {
            name: "min",
            parenOptional: false
          },
          {
            name: "mvappend",
            parenOptional: false
          },
          {
            name: "mvcount",
            parenOptional: false
          },
          {
            name: "mvdedup",
            parenOptional: false
          },
          {
            name: "mvindex",
            parenOptional: false
          },
          {
            name: "mvfilter",
            parenOptional: false
          },
          {
            name: "mvfind",
            parenOptional: false
          },
          {
            name: "mvjoin",
            parenOptional: false
          },
          {
            name: "mvmap",
            parenOptional: false
          },
          {
            name: "mvrange",
            parenOptional: false
          },
          {
            name: "mvsort",
            parenOptional: false
          },
          {
            name: "mvzip",
            parenOptional: false
          },
          {
            name: "now",
            parenOptional: false
          },
          {
            name: "null",
            parenOptional: false
          },
          {
            name: "nullif",
            parenOptional: false
          },
          {
            name: "pi",
            parenOptional: false
          },
          {
            name: "pow",
            parenOptional: false
          },
          {
            name: "random",
            parenOptional: false
          },
          {
            name: "relative_time",
            parenOptional: false
          },
          {
            name: "replace",
            parenOptional: false
          },
          {
            name: "round",
            parenOptional: false
          },
          {
            name: "searchmatch",
            parenOptional: false
          },
          {
            name: "sha1",
            parenOptional: false
          },
          {
            name: "sha256",
            parenOptional: false
          },
          {
            name: "sha512",
            parenOptional: false
          },
          {
            name: "sigfig",
            parenOptional: false
          },
          {
            name: "spath",
            parenOptional: false
          },
          {
            name: "split",
            parenOptional: false
          },
          {
            name: "sqrt",
            parenOptional: false
          },
          {
            name: "strftime",
            parenOptional: false
          },
          {
            name: "strptime",
            parenOptional: false
          },
          {
            name: "substr",
            parenOptional: false
          },
          {
            name: "sum",
            parenOptional: false
          },
          {
            name: "time",
            parenOptional: false
          },
          {
            name: "tostring",
            parenOptional: false
          },
          {
            name: "trim",
            parenOptional: false
          },
          {
            name: "ltrim",
            parenOptional: false
          },
          {
            name: "rtrim",
            parenOptional: false
          },
          {
            name: "true",
            parenOptional: false
          },
          {
            name: "typeof",
            parenOptional: false
          },
          {
            name: "upper",
            parenOptional: false
          },
          {
            name: "urldecode",
            parenOptional: false
          },
          {
            name: "validate",
            parenOptional: false
          },
          {
            name: "tonumber",
            parenOptional: false
          },
          {
            name: "acos",
            parenOptional: false
          },
          {
            name: "acosh",
            parenOptional: false
          },
          {
            name: "asin",
            parenOptional: false
          },
          {
            name: "asinh",
            parenOptional: false
          },
          {
            name: "atan",
            parenOptional: false
          },
          {
            name: "atan2",
            parenOptional: false
          },
          {
            name: "atanh",
            parenOptional: false
          },
          {
            name: "cos",
            parenOptional: false
          },
          {
            name: "cosh",
            parenOptional: false
          },
          {
            name: "hypot",
            parenOptional: false
          },
          {
            name: "sin",
            parenOptional: false
          },
          {
            name: "sinh",
            parenOptional: false
          },
          {
            name: "tan",
            parenOptional: false
          },
          {
            name: "tanh",
            parenOptional: false
          },
          {
            name: "json_array_to_mv",
            parenOptional: false
          },
          {
            name: "mv_to_json_array",
            parenOptional: false
          },
          {
            name: "json_append",
            parenOptional: false
          },
          {
            name: "json_extend",
            parenOptional: false
          },
          {
            name: "json_extract_exact",
            parenOptional: false
          },
          {
            name: "json_set_exact",
            parenOptional: false
          }
        ],
        keywords: ["LIKE", "AND|OR|XOR"],
        other: ["int", "field", "num", "string"],
        list: []
      },
      "hilite-command": {
        isList: false,
        args: [],
        functions: [],
        keywords: [],
        other: ["string"],
        list: []
      },
      "highlight-command": {
        isList: false,
        args: [],
        functions: [],
        keywords: [],
        other: ["string"],
        list: []
      },
      "history-command": {
        isList: false,
        args: [
          {
            key: "events",
            valueType: "bool"
          }
        ],
        functions: [],
        keywords: [],
        other: [],
        list: []
      },
      "iconify-command": {
        isList: false,
        args: [],
        functions: [],
        keywords: [],
        other: ["field-list"],
        list: []
      },
      "ingestpreview-command": {
        isList: false,
        args: [
          {
            key: "meta_mode",
            valueType: "string"
          },
          {
            key: "ingest_processor",
            valueType: "string"
          },
          {
            key: "emit_copy_pastable",
            valueType: "bool"
          }
        ],
        functions: [],
        keywords: [],
        other: [],
        list: []
      },
      "inputcsv-command": {
        isList: false,
        args: [
          {
            key: "dispatch",
            valueType: "bool"
          },
          {
            key: "append",
            valueType: "bool"
          },
          {
            key: "strict",
            valueType: "bool"
          },
          {
            key: "start",
            valueType: "int"
          },
          {
            key: "max",
            valueType: "int"
          },
          {
            key: "events",
            valueType: "bool"
          }
        ],
        functions: [],
        keywords: ["WHERE"],
        other: ["filename", "string:search-query"],
        list: []
      },
      "inputlookup-command": {
        isList: false,
        args: [
          {
            key: "append",
            valueType: "bool"
          },
          {
            key: "start",
            valueType: "int"
          },
          {
            key: "max",
            valueType: "int"
          }
        ],
        functions: [],
        keywords: ["where"],
        other: ["filename", "string:tablename", "string:search-query"],
        list: []
      },
      "internalinputcsv-command": {
        isList: false,
        args: [],
        functions: [],
        keywords: [],
        other: ["filename"],
        list: []
      },
      "iplocation-command": {
        isList: false,
        args: [
          {
            key: "prefix",
            valueType: "string"
          },
          {
            key: "allfields",
            valueType: "bool"
          },
          {
            key: "lang",
            valueType: "string"
          }
        ],
        functions: [],
        keywords: [],
        other: ["field"],
        list: []
      },
      "join-command": {
        isList: false,
        args: [
          {
            key: "type",
            valueType: ""
          },
          {
            key: "usetime",
            valueType: "bool"
          },
          {
            key: "earlier",
            valueType: "bool"
          },
          {
            key: "overwrite",
            valueType: "bool"
          },
          {
            key: "max",
            valueType: "int"
          },
          {
            key: "return_multivalue",
            valueType: "bool"
          },
          {
            key: "left",
            valueType: "leftalias"
          },
          {
            key: "right",
            valueType: "rightalias"
          }
        ],
        functions: [],
        keywords: ["WHERE"],
        other: ["field-list", "string", "field"],
        list: []
      },
      "jsontxn-command": {
        isList: false,
        args: [],
        functions: [],
        keywords: [],
        other: [],
        list: []
      },
      "kmeans-command": {
        isList: false,
        args: [
          {
            key: "reps",
            valueType: "int"
          },
          {
            key: "maxiters",
            valueType: "int"
          },
          {
            key: "t",
            valueType: "num"
          },
          {
            key: "k",
            valueType: ""
          },
          {
            key: "cfield",
            valueType: "field"
          },
          {
            key: "dt",
            valueType: ""
          },
          {
            key: "showcentroid",
            valueType: "bool"
          }
        ],
        functions: [],
        keywords: [],
        other: ["field-list"],
        list: []
      },
      "kvform-command": {
        isList: false,
        args: [
          {
            key: "form",
            valueType: "string"
          },
          {
            key: "field",
            valueType: "field"
          }
        ],
        functions: [],
        keywords: [],
        other: [],
        list: []
      },
      "loadjob-command": {
        isList: false,
        args: [
          {
            key: "savedsearch",
            valueType: ""
          },
          {
            key: "events",
            valueType: "bool"
          },
          {
            key: "job_delegate",
            valueType: "string"
          },
          {
            key: "artifact_offset",
            valueType: "int"
          },
          {
            key: "ignore_running",
            valueType: "bool"
          },
          {
            key: "wait_until_finished",
            valueType: "bool"
          },
          {
            key: "wait_timeout",
            valueType: "int"
          }
        ],
        functions: [],
        keywords: [],
        other: ["string"],
        list: []
      },
      "localize-command": {
        isList: false,
        args: [
          {
            key: "maxpause",
            valueType: ""
          },
          {
            key: "timeafter",
            valueType: ""
          },
          {
            key: "timebefore",
            valueType: ""
          }
        ],
        functions: [],
        keywords: [],
        other: [],
        list: []
      },
      "localop-command": {
        isList: false,
        args: [],
        functions: [],
        keywords: [],
        other: [],
        list: []
      },
      "lookup-command": {
        isList: false,
        args: [
          {
            key: "local",
            valueType: "bool"
          },
          {
            key: "update",
            valueType: "bool"
          },
          {
            key: "event_time_field",
            valueType: "string"
          }
        ],
        functions: [],
        keywords: ["as", "OUTPUT|OUTPUTNEW", "as"],
        other: [
          "string:lookup-table-name",
          "field:lookup",
          "field:local",
          "field:dest",
          "field:local-dest"
        ],
        list: []
      },
      "makecontinuous-command": {
        isList: false,
        args: [
          {
            key: "bins",
            valueType: "int"
          },
          {
            key: "minspan",
            valueType: ""
          },
          {
            key: "span",
            valueType: ""
          },
          {
            key: "start",
            valueType: "num"
          },
          {
            key: "end",
            valueType: "num"
          },
          {
            key: "aligntime",
            valueType: ""
          }
        ],
        functions: [],
        keywords: [],
        other: ["field"],
        list: []
      },
      "makejson-command": {
        isList: false,
        args: [
          {
            key: "output",
            valueType: "string"
          }
        ],
        functions: [],
        keywords: [],
        other: ["wc-field-list"],
        list: []
      },
      "makemv-command": {
        isList: false,
        args: [
          {
            key: "delim",
            valueType: "string"
          },
          {
            key: "tokenizer",
            valueType: ""
          },
          {
            key: "allowempty",
            valueType: "bool"
          },
          {
            key: "setsv",
            valueType: "bool"
          }
        ],
        functions: [],
        keywords: [],
        other: ["field"],
        list: []
      },
      "makeresults-command": {
        isList: false,
        args: [
          {
            key: "count",
            valueType: "int"
          },
          {
            key: "annotate",
            valueType: "bool"
          },
          {
            key: "splunk_server",
            valueType: "string"
          },
          {
            key: "splunk_server_group",
            valueType: "string"
          }
        ],
        functions: [],
        keywords: [],
        other: [],
        list: []
      },
      "map-command": {
        isList: false,
        args: [
          {
            key: "search",
            valueType: ""
          },
          {
            key: "maxsearches",
            valueType: "int"
          }
        ],
        functions: [],
        keywords: [],
        other: ["string"],
        list: []
      },
      "mcatalog-command": {
        isList: false,
        args: [
          {
            key: "prestats",
            valueType: "bool"
          },
          {
            key: "append",
            valueType: "bool"
          },
          {
            key: "timeformat",
            valueType: "string"
          },
          {
            key: "earliest",
            valueType: "time_modifier"
          },
          {
            key: "_index_earliest",
            valueType: "time_modifier"
          },
          {
            key: "starttime",
            valueType: "string"
          },
          {
            key: "startdaysago",
            valueType: "int"
          },
          {
            key: "startminutesago",
            valueType: "int"
          },
          {
            key: "starthoursago",
            valueType: "int"
          },
          {
            key: "startmonthsago",
            valueType: "int"
          },
          {
            key: "starttimeu",
            valueType: "num"
          },
          {
            key: "latest",
            valueType: "time_modifier"
          },
          {
            key: "_index_latest",
            valueType: "time_modifier"
          },
          {
            key: "endtime",
            valueType: "string"
          },
          {
            key: "enddaysago",
            valueType: "int"
          },
          {
            key: "endminutesago",
            valueType: "int"
          },
          {
            key: "endhoursago",
            valueType: "int"
          },
          {
            key: "endmonthsago",
            valueType: "int"
          },
          {
            key: "endtimeu",
            valueType: "num"
          },
          {
            key: "searchtimespanhours",
            valueType: "int"
          },
          {
            key: "searchtimespanminutes",
            valueType: "int"
          },
          {
            key: "searchtimespandays",
            valueType: "int"
          },
          {
            key: "searchtimespanmonths",
            valueType: "int"
          },
          {
            key: "daysago",
            valueType: "int"
          },
          {
            key: "minutesago",
            valueType: "int"
          },
          {
            key: "hoursago",
            valueType: "int"
          },
          {
            key: "monthsago",
            valueType: "int"
          },
          {
            key: "savedsearch",
            valueType: "string"
          },
          {
            key: "savedsplunk",
            valueType: "string"
          }
        ],
        functions: [],
        keywords: ["as", "WHERE", "IN", "BY|GROUPBY"],
        other: [
          "field",
          "string",
          "boolean-operator-not",
          "term",
          "num",
          "boolean-operator-or",
          "boolean-operator-and",
          "field-list"
        ],
        list: []
      },
      "mcollect-command": {
        isList: false,
        args: [
          {
            key: "index",
            valueType: "string"
          },
          {
            key: "file",
            valueType: "string"
          },
          {
            key: "split",
            valueType: "true|false|allnums"
          },
          {
            key: "spool",
            valueType: "bool"
          },
          {
            key: "prefix_field",
            valueType: "string"
          },
          {
            key: "host",
            valueType: "string"
          },
          {
            key: "source",
            valueType: "string"
          },
          {
            key: "sourcetype",
            valueType: "string"
          },
          {
            key: "marker",
            valueType: "string"
          }
        ],
        functions: [],
        keywords: [],
        other: ["field-list"],
        list: []
      },
      "metadata-command": {
        isList: false,
        args: [
          {
            key: "type",
            valueType: "metadata-type"
          },
          {
            key: "index",
            valueType: "string"
          },
          {
            key: "splunk_server",
            valueType: "wc-string"
          },
          {
            key: "splunk_server_group",
            valueType: "wc-string"
          },
          {
            key: "datatype",
            valueType: "metric|event"
          }
        ],
        functions: [],
        keywords: [],
        other: [],
        list: []
      },
      "metasearch-command": {
        isList: false,
        args: [
          {
            key: "timeformat",
            valueType: "string"
          },
          {
            key: "earliest",
            valueType: "time_modifier"
          },
          {
            key: "_index_earliest",
            valueType: "time_modifier"
          },
          {
            key: "starttime",
            valueType: "string"
          },
          {
            key: "startdaysago",
            valueType: "int"
          },
          {
            key: "startminutesago",
            valueType: "int"
          },
          {
            key: "starthoursago",
            valueType: "int"
          },
          {
            key: "startmonthsago",
            valueType: "int"
          },
          {
            key: "starttimeu",
            valueType: "num"
          },
          {
            key: "latest",
            valueType: "time_modifier"
          },
          {
            key: "_index_latest",
            valueType: "time_modifier"
          },
          {
            key: "endtime",
            valueType: "string"
          },
          {
            key: "enddaysago",
            valueType: "int"
          },
          {
            key: "endminutesago",
            valueType: "int"
          },
          {
            key: "endhoursago",
            valueType: "int"
          },
          {
            key: "endmonthsago",
            valueType: "int"
          },
          {
            key: "endtimeu",
            valueType: "num"
          },
          {
            key: "searchtimespanhours",
            valueType: "int"
          },
          {
            key: "searchtimespanminutes",
            valueType: "int"
          },
          {
            key: "searchtimespandays",
            valueType: "int"
          },
          {
            key: "searchtimespanmonths",
            valueType: "int"
          },
          {
            key: "daysago",
            valueType: "int"
          },
          {
            key: "minutesago",
            valueType: "int"
          },
          {
            key: "hoursago",
            valueType: "int"
          },
          {
            key: "monthsago",
            valueType: "int"
          },
          {
            key: "savedsearch",
            valueType: "string"
          },
          {
            key: "savedsplunk",
            valueType: "string"
          }
        ],
        functions: [],
        keywords: ["IN"],
        other: [
          "string",
          "field",
          "boolean-operator-not",
          "term",
          "num",
          "boolean-operator-or",
          "boolean-operator-and"
        ],
        list: []
      },
      "meventcollect-command": {
        isList: false,
        args: [
          {
            key: "index",
            valueType: "string"
          },
          {
            key: "split",
            valueType: "bool"
          },
          {
            key: "spool",
            valueType: "bool"
          },
          {
            key: "prefix_field",
            valueType: "string"
          },
          {
            key: "host",
            valueType: "string"
          },
          {
            key: "source",
            valueType: "string"
          },
          {
            key: "sourcetype",
            valueType: "string"
          }
        ],
        functions: [],
        keywords: [],
        other: ["field-list"],
        list: []
      },
      "msearch-command": {
        isList: false,
        args: [
          {
            key: "filter",
            valueType: "string"
          },
          {
            key: "index",
            valueType: "string"
          },
          {
            key: "splunk_server",
            valueType: "wc-string"
          },
          {
            key: "splunk_server_group",
            valueType: "wc-string"
          },
          {
            key: "earliest",
            valueType: "mpreview-time-specifier"
          },
          {
            key: "latest",
            valueType: "mpreview-time-specifier"
          },
          {
            key: "chunk_size",
            valueType: "int"
          },
          {
            key: "target_per_timeseries",
            valueType: "int"
          }
        ],
        functions: [],
        keywords: [],
        other: [],
        list: []
      },
      "mpreview-command": {
        isList: false,
        args: [
          {
            key: "filter",
            valueType: "string"
          },
          {
            key: "index",
            valueType: "string"
          },
          {
            key: "splunk_server",
            valueType: "wc-string"
          },
          {
            key: "splunk_server_group",
            valueType: "wc-string"
          },
          {
            key: "earliest",
            valueType: "mpreview-time-specifier"
          },
          {
            key: "latest",
            valueType: "mpreview-time-specifier"
          },
          {
            key: "chunk_size",
            valueType: "int"
          },
          {
            key: "target_per_timeseries",
            valueType: "int"
          }
        ],
        functions: [],
        keywords: [],
        other: [],
        list: []
      },
      "mrollup-command": {
        isList: false,
        args: [
          {
            key: "source",
            valueType: "string"
          },
          {
            key: "target",
            valueType: "string"
          },
          {
            key: "file",
            valueType: "string"
          },
          {
            key: "span",
            valueType: "string:timespan"
          },
          {
            key: "aggregate",
            valueType: ""
          },
          {
            key: "dimension-list",
            valueType: ""
          },
          {
            key: "dimension-list-type",
            valueType: ""
          },
          {
            key: "metric-list",
            valueType: ""
          },
          {
            key: "metric-list-type",
            valueType: ""
          },
          {
            key: "metric-overrides",
            valueType: ""
          },
          {
            key: "app",
            valueType: "string"
          }
        ],
        functions: [],
        keywords: [],
        other: [],
        list: []
      },
      "mstats-command": {
        isList: false,
        args: [
          {
            key: "chart",
            valueType: "bool"
          },
          {
            key: "chart.limit",
            valueType: "chart-limit-opt"
          },
          {
            key: "chart.agg",
            valueType: "stats-agg-term"
          },
          {
            key: "chart.usenull",
            valueType: "bool"
          },
          {
            key: "chart.useother",
            valueType: "bool"
          },
          {
            key: "chart.nullstr",
            valueType: "string"
          },
          {
            key: "chart.otherstr",
            valueType: "string"
          },
          {
            key: "prestats",
            valueType: "bool"
          },
          {
            key: "append",
            valueType: "bool"
          },
          {
            key: "backfill",
            valueType: "bool"
          },
          {
            key: "update_period",
            valueType: "int"
          },
          {
            key: "fillnull_value",
            valueType: "string"
          },
          {
            key: "chunk_size",
            valueType: "int"
          },
          {
            key: "timeformat",
            valueType: "string"
          },
          {
            key: "earliest",
            valueType: "time_modifier"
          },
          {
            key: "_index_earliest",
            valueType: "time_modifier"
          },
          {
            key: "starttime",
            valueType: "string"
          },
          {
            key: "startdaysago",
            valueType: "int"
          },
          {
            key: "startminutesago",
            valueType: "int"
          },
          {
            key: "starthoursago",
            valueType: "int"
          },
          {
            key: "startmonthsago",
            valueType: "int"
          },
          {
            key: "starttimeu",
            valueType: "num"
          },
          {
            key: "latest",
            valueType: "time_modifier"
          },
          {
            key: "_index_latest",
            valueType: "time_modifier"
          },
          {
            key: "endtime",
            valueType: "string"
          },
          {
            key: "enddaysago",
            valueType: "int"
          },
          {
            key: "endminutesago",
            valueType: "int"
          },
          {
            key: "endhoursago",
            valueType: "int"
          },
          {
            key: "endmonthsago",
            valueType: "int"
          },
          {
            key: "endtimeu",
            valueType: "num"
          },
          {
            key: "searchtimespanhours",
            valueType: "int"
          },
          {
            key: "searchtimespanminutes",
            valueType: "int"
          },
          {
            key: "searchtimespandays",
            valueType: "int"
          },
          {
            key: "searchtimespanmonths",
            valueType: "int"
          },
          {
            key: "daysago",
            valueType: "int"
          },
          {
            key: "minutesago",
            valueType: "int"
          },
          {
            key: "hoursago",
            valueType: "int"
          },
          {
            key: "monthsago",
            valueType: "int"
          },
          {
            key: "savedsearch",
            valueType: "string"
          },
          {
            key: "savedsplunk",
            valueType: "string"
          },
          {
            key: "span",
            valueType: "string:timespan"
          },
          {
            key: "every",
            valueType: "string:timespan"
          }
        ],
        functions: [
          {
            name: "rate_avg",
            parenOptional: false
          },
          {
            name: "rate_sum",
            parenOptional: false
          }
        ],
        keywords: ["as", "WHERE", "IN", "BY|GROUPBY"],
        other: [
          "metric_name",
          "string",
          "stats-func-value",
          "field",
          "boolean-operator-not",
          "term",
          "num",
          "boolean-operator-or",
          "boolean-operator-and",
          "field-list"
        ],
        list: []
      },
      "multikv-command": {
        isList: false,
        args: [
          {
            key: "conf",
            valueType: "stanza_name"
          },
          {
            key: "copyattrs",
            valueType: "bool"
          },
          {
            key: "forceheader",
            valueType: "int"
          },
          {
            key: "multitable",
            valueType: "bool"
          },
          {
            key: "noheader",
            valueType: "bool"
          },
          {
            key: "rmorig",
            valueType: "bool"
          }
        ],
        functions: [],
        keywords: ["fields", "filter"],
        other: ["field-list"],
        list: []
      },
      "multisearch-command": {
        isList: false,
        args: [],
        functions: [],
        keywords: [],
        other: ["string"],
        list: []
      },
      "mvcombine-command": {
        isList: false,
        args: [
          {
            key: "delim",
            valueType: "string"
          }
        ],
        functions: [],
        keywords: [],
        other: ["field"],
        list: []
      },
      "mvexpand-command": {
        isList: false,
        args: [
          {
            key: "limit",
            valueType: "int"
          }
        ],
        functions: [],
        keywords: [],
        other: ["field"],
        list: []
      },
      "newseriesfilter-command": {
        isList: false,
        args: [],
        functions: [],
        keywords: [],
        other: ["string"],
        list: []
      },
      "nokv-command": {
        isList: false,
        args: [],
        functions: [],
        keywords: [],
        other: [],
        list: []
      },
      "nomv-command": {
        isList: false,
        args: [],
        functions: [],
        keywords: [],
        other: ["field"],
        list: []
      },
      "outlierfilter-command": {
        isList: false,
        args: [
          {
            key: "action",
            valueType: ""
          },
          {
            key: "param",
            valueType: "num"
          },
          {
            key: "uselower",
            valueType: "bool"
          },
          {
            key: "mark",
            valueType: "bool"
          }
        ],
        functions: [],
        keywords: [],
        other: ["field-list"],
        list: []
      },
      "outlier-command": {
        isList: false,
        args: [
          {
            key: "action",
            valueType: ""
          },
          {
            key: "param",
            valueType: "num"
          },
          {
            key: "uselower",
            valueType: "bool"
          },
          {
            key: "mark",
            valueType: "bool"
          }
        ],
        functions: [],
        keywords: [],
        other: ["field-list"],
        list: []
      },
      "outputcsv-command": {
        isList: false,
        args: [
          {
            key: "append",
            valueType: "bool"
          },
          {
            key: "create_empty",
            valueType: "bool"
          },
          {
            key: "override_if_empty",
            valueType: ""
          },
          {
            key: "dispatch",
            valueType: "bool"
          },
          {
            key: "usexml",
            valueType: "bool"
          },
          {
            key: "singlefile",
            valueType: "bool"
          }
        ],
        functions: [],
        keywords: [],
        other: ["filename"],
        list: []
      },
      "outputlookup-command": {
        isList: false,
        args: [
          {
            key: "append",
            valueType: "bool"
          },
          {
            key: "create_empty",
            valueType: "bool"
          },
          {
            key: "override_if_empty",
            valueType: ""
          },
          {
            key: "max",
            valueType: "int"
          },
          {
            key: "key_field",
            valueType: "field"
          },
          {
            key: "createinapp",
            valueType: "bool"
          },
          {
            key: "create_context",
            valueType: "string"
          },
          {
            key: "output_format",
            valueType: "string"
          }
        ],
        functions: [],
        keywords: [],
        other: ["filename", "string:tablename"],
        list: []
      },
      "outputraw-command": {
        isList: false,
        args: [],
        functions: [],
        keywords: [],
        other: [],
        list: []
      },
      "outputrawr-command": {
        isList: false,
        args: [],
        functions: [],
        keywords: [],
        other: [],
        list: []
      },
      "outputtelemetry-command": {
        isList: false,
        args: [
          {
            key: "input",
            valueType: "string"
          },
          {
            key: "type",
            valueType: "string"
          },
          {
            key: "component",
            valueType: "string"
          },
          {
            key: "support",
            valueType: "bool"
          },
          {
            key: "anonymous",
            valueType: "bool"
          },
          {
            key: "license",
            valueType: "bool"
          },
          {
            key: "optinrequired",
            valueType: "int"
          }
        ],
        functions: [],
        keywords: [],
        other: [],
        list: []
      },
      "outputtext-command": {
        isList: false,
        args: [
          {
            key: "usexml",
            valueType: "bool"
          }
        ],
        functions: [],
        keywords: [],
        other: [],
        list: []
      },
      "overlap-command": {
        isList: false,
        args: [],
        functions: [],
        keywords: [],
        other: [],
        list: []
      },
      "pivot-command": {
        isList: false,
        args: [],
        functions: [],
        keywords: [],
        other: ["datamodel-name", "object-name", "pivot-element"],
        list: []
      },
      "predict-command": {
        isList: false,
        args: [
          {
            key: "algorithm",
            valueType: ""
          },
          {
            key: "correlate",
            valueType: "field"
          },
          {
            key: "future_timespan",
            valueType: "num"
          },
          {
            key: "holdback",
            valueType: "num"
          },
          {
            key: "period",
            valueType: "num"
          },
          {
            key: "upper\\d+",
            valueType: "field"
          },
          {
            key: "lower\\d+",
            valueType: "field"
          },
          {
            key: "suppress",
            valueType: "field"
          }
        ],
        functions: [],
        keywords: ["as"],
        other: ["field-list", "field"],
        list: []
      },
      "preview-command": {
        isList: false,
        args: [],
        functions: [],
        keywords: [],
        other: [],
        list: []
      },
      "prjob-command": {
        isList: false,
        args: [],
        functions: [],
        keywords: [],
        other: ["string"],
        list: []
      },
      "rangemap-command": {
        isList: false,
        args: [
          {
            key: "field",
            valueType: "field"
          },
          {
            key: "default",
            valueType: "string"
          }
        ],
        functions: [],
        keywords: [],
        other: ["string", "num"],
        list: []
      },
      "rare-command": {
        isList: false,
        args: [
          {
            key: "showcount",
            valueType: "bool"
          },
          {
            key: "showperc",
            valueType: "bool"
          },
          {
            key: "limit",
            valueType: "int"
          },
          {
            key: "countfield",
            valueType: "string"
          },
          {
            key: "percentfield",
            valueType: "string"
          },
          {
            key: "useother",
            valueType: "bool"
          },
          {
            key: "otherstr",
            valueType: "string"
          }
        ],
        functions: [],
        keywords: ["by"],
        other: ["field-list"],
        list: []
      },
      "rawstats-command": {
        isList: false,
        args: [],
        functions: [],
        keywords: [],
        other: [],
        list: []
      },
      "redistribute-command": {
        isList: false,
        args: [
          {
            key: "dfs",
            valueType: ""
          },
          {
            key: "num_of_reducers",
            valueType: "int"
          }
        ],
        functions: [],
        keywords: ["by"],
        other: ["field-list"],
        list: []
      },
      "regex-command": {
        isList: false,
        args: [],
        functions: [],
        keywords: [],
        other: ["field", "string"],
        list: []
      },
      "relevancy-command": {
        isList: false,
        args: [],
        functions: [],
        keywords: [],
        other: [],
        list: []
      },
      "reltime-command": {
        isList: false,
        args: [
          {
            key: "timefield",
            valueType: "field-list"
          },
          {
            key: "prefix",
            valueType: "string"
          }
        ],
        functions: [],
        keywords: [],
        other: [],
        list: []
      },
      "rename-command": {
        isList: false,
        args: [],
        functions: [],
        keywords: ["as"],
        other: ["wc-field", "wc-field"],
        list: []
      },
      "replace-command": {
        isList: false,
        args: [],
        functions: [],
        keywords: ["with", "in"],
        other: ["wc-str", "wc-str", "field-list"],
        list: []
      },
      "require-command": {
        isList: false,
        args: [],
        functions: [],
        keywords: [],
        other: [],
        list: []
      },
      "rest-command": {
        isList: false,
        args: [
          {
            key: "count",
            valueType: "int"
          },
          {
            key: "strict",
            valueType: "bool"
          },
          {
            key: "splunk_server",
            valueType: "string"
          },
          {
            key: "splunk_server_group",
            valueType: "string"
          },
          {
            key: "timeout",
            valueType: "int"
          }
        ],
        functions: [],
        keywords: [],
        other: ["string"],
        list: []
      },
      "return-command": {
        isList: false,
        args: [],
        functions: [],
        keywords: [],
        other: ["int:count", "field:alias", "field", "field", "field"],
        list: []
      },
      "reverse-command": {
        isList: false,
        args: [],
        functions: [],
        keywords: [],
        other: [],
        list: []
      },
      "rex-command": {
        isList: false,
        args: [
          {
            key: "field",
            valueType: "field"
          },
          {
            key: "max_match",
            valueType: "int"
          },
          {
            key: "offset_field",
            valueType: "string"
          },
          {
            key: "mode",
            valueType: ""
          }
        ],
        functions: [],
        keywords: [],
        other: ["string", "sed-expression"],
        list: []
      },
      "rtorder-command": {
        isList: false,
        args: [
          {
            key: "discard",
            valueType: "bool"
          },
          {
            key: "buffer_span",
            valueType: "span-length"
          },
          {
            key: "max_buffer_size",
            valueType: "int"
          }
        ],
        functions: [],
        keywords: [],
        other: [],
        list: []
      },
      "runshellscript-command": {
        isList: false,
        args: [],
        functions: [],
        keywords: [],
        other: [
          "script-filename",
          "result-count",
          "search-terms",
          "search-string",
          "savedsearch-name",
          "description",
          "results-url",
          "deprecated-arg",
          "search-id"
        ],
        list: []
      },
      "macro-command": {
        isList: false,
        args: [
          {
            key: "nosubstitution",
            valueType: "bool"
          }
        ],
        functions: [],
        keywords: [],
        other: ["string"],
        list: []
      },
      "savedsplunk-command": {
        isList: false,
        args: [
          {
            key: "nosubstitution",
            valueType: "bool"
          }
        ],
        functions: [],
        keywords: [],
        other: ["string"],
        list: []
      },
      "savedsearch-command": {
        isList: false,
        args: [
          {
            key: "nosubstitution",
            valueType: "bool"
          }
        ],
        functions: [],
        keywords: [],
        other: ["string"],
        list: []
      },
      "run-command": {
        isList: false,
        args: [
          {
            key: "maxinputs",
            valueType: "int"
          }
        ],
        functions: [],
        keywords: [],
        other: ["string"],
        list: []
      },
      "script-command": {
        isList: false,
        args: [
          {
            key: "maxinputs",
            valueType: "int"
          }
        ],
        functions: [],
        keywords: [],
        other: ["string"],
        list: []
      },
      "scrub-command": {
        isList: false,
        args: [
          {
            key: "public-terms",
            valueType: "filename"
          },
          {
            key: "private-terms",
            valueType: "filename"
          },
          {
            key: "name-terms",
            valueType: "filename"
          },
          {
            key: "dictionary",
            valueType: "filename"
          },
          {
            key: "timeconfig",
            valueType: "filename"
          },
          {
            key: "namespace",
            valueType: "string"
          }
        ],
        functions: [],
        keywords: [],
        other: [],
        list: []
      },
      "search-command": {
        isList: false,
        args: [
          {
            key: "timeformat",
            valueType: "string"
          },
          {
            key: "earliest",
            valueType: "time_modifier"
          },
          {
            key: "_index_earliest",
            valueType: "time_modifier"
          },
          {
            key: "starttime",
            valueType: "string"
          },
          {
            key: "startdaysago",
            valueType: "int"
          },
          {
            key: "startminutesago",
            valueType: "int"
          },
          {
            key: "starthoursago",
            valueType: "int"
          },
          {
            key: "startmonthsago",
            valueType: "int"
          },
          {
            key: "starttimeu",
            valueType: "num"
          },
          {
            key: "latest",
            valueType: "time_modifier"
          },
          {
            key: "_index_latest",
            valueType: "time_modifier"
          },
          {
            key: "endtime",
            valueType: "string"
          },
          {
            key: "enddaysago",
            valueType: "int"
          },
          {
            key: "endminutesago",
            valueType: "int"
          },
          {
            key: "endhoursago",
            valueType: "int"
          },
          {
            key: "endmonthsago",
            valueType: "int"
          },
          {
            key: "endtimeu",
            valueType: "num"
          },
          {
            key: "searchtimespanhours",
            valueType: "int"
          },
          {
            key: "searchtimespanminutes",
            valueType: "int"
          },
          {
            key: "searchtimespandays",
            valueType: "int"
          },
          {
            key: "searchtimespanmonths",
            valueType: "int"
          },
          {
            key: "daysago",
            valueType: "int"
          },
          {
            key: "minutesago",
            valueType: "int"
          },
          {
            key: "hoursago",
            valueType: "int"
          },
          {
            key: "monthsago",
            valueType: "int"
          },
          {
            key: "savedsearch",
            valueType: "string"
          },
          {
            key: "savedsplunk",
            valueType: "string"
          }
        ],
        functions: [],
        keywords: ["IN"],
        other: [
          "string",
          "field",
          "boolean-operator-not",
          "term",
          "num",
          "boolean-operator-or",
          "boolean-operator-and"
        ],
        list: []
      },
      "searchtxn-command": {
        isList: false,
        args: [
          {
            key: "max_terms",
            valueType: "int"
          },
          {
            key: "use_disjunct",
            valueType: "bool"
          },
          {
            key: "eventsonly",
            valueType: "bool"
          }
        ],
        functions: [],
        keywords: [],
        other: ["string", "search-string"],
        list: []
      },
      "report-command": {
        isList: false,
        args: [],
        functions: [],
        keywords: [],
        other: ["string"],
        list: []
      },
      "select-command": {
        isList: false,
        args: [],
        functions: [],
        keywords: [],
        other: ["string"],
        list: []
      },
      "selfjoin-command": {
        isList: false,
        args: [
          {
            key: "overwrite",
            valueType: "bool"
          },
          {
            key: "max",
            valueType: "int"
          },
          {
            key: "keepsingle",
            valueType: "int"
          }
        ],
        functions: [],
        keywords: [],
        other: ["field-list"],
        list: []
      },
      "sendalert-command": {
        isList: false,
        args: [
          {
            key: "results_link",
            valueType: "url"
          },
          {
            key: "results_path",
            valueType: "path"
          },
          {
            key: "param.<param-name>",
            valueType: "value"
          }
        ],
        functions: [],
        keywords: [],
        other: ["string"],
        list: []
      },
      "sendemail-command": {
        isList: false,
        args: [
          {
            key: "to",
            valueType: "email_list"
          },
          {
            key: "from",
            valueType: "email_list"
          },
          {
            key: "cc",
            valueType: "email_list"
          },
          {
            key: "bcc",
            valueType: "email_list"
          },
          {
            key: "subject",
            valueType: "string"
          },
          {
            key: "message",
            valueType: "string"
          },
          {
            key: "footer",
            valueType: "string"
          },
          {
            key: "sendresults",
            valueType: "bool"
          },
          {
            key: "inline",
            valueType: "bool"
          },
          {
            key: "format",
            valueType: ""
          },
          {
            key: "sendcsv",
            valueType: "bool"
          },
          {
            key: "sendpdf",
            valueType: "bool"
          },
          {
            key: "pdfview",
            valueType: "string"
          },
          {
            key: "paperorientation",
            valueType: ""
          },
          {
            key: "papersize",
            valueType: ""
          },
          {
            key: "priority",
            valueType: ""
          },
          {
            key: "server",
            valueType: "string"
          },
          {
            key: "graceful",
            valueType: "bool"
          },
          {
            key: "content_type",
            valueType: ""
          },
          {
            key: "width_sort_columns",
            valueType: "bool"
          },
          {
            key: "use_ssl",
            valueType: "bool"
          },
          {
            key: "use_tls",
            valueType: "bool"
          },
          {
            key: "maxinputs",
            valueType: "int"
          },
          {
            key: "maxtime",
            valueType: ""
          }
        ],
        functions: [],
        keywords: [],
        other: [],
        list: []
      },
      "set-command": {
        isList: false,
        args: [],
        functions: [],
        keywords: ["union|diff|intersect"],
        other: ["string"],
        list: []
      },
      "setfields-command": {
        isList: false,
        args: [],
        functions: [],
        keywords: [],
        other: ["string"],
        list: []
      },
      "shape-command": {
        isList: false,
        args: [
          {
            key: "maxvalues",
            valueType: "int"
          },
          {
            key: "maxresolution",
            valueType: "int"
          }
        ],
        functions: [],
        keywords: [],
        other: ["field"],
        list: []
      },
      "showargs-command": {
        isList: false,
        args: [],
        functions: [],
        keywords: [],
        other: ["string"],
        list: []
      },
      "sichart-command": {
        isList: false,
        args: [
          {
            key: "sep",
            valueType: "string"
          },
          {
            key: "format",
            valueType: "string"
          },
          {
            key: "cont",
            valueType: "bool"
          },
          {
            key: "limit",
            valueType: "chart-limit-opt"
          },
          {
            key: "agg",
            valueType: "stats-agg-term"
          },
          {
            key: "bins",
            valueType: "int"
          },
          {
            key: "minspan",
            valueType: ""
          },
          {
            key: "span",
            valueType: ""
          },
          {
            key: "start",
            valueType: "num"
          },
          {
            key: "end",
            valueType: "num"
          },
          {
            key: "aligntime",
            valueType: ""
          },
          {
            key: "usenull",
            valueType: "bool"
          },
          {
            key: "useother",
            valueType: "bool"
          },
          {
            key: "nullstr",
            valueType: "string"
          },
          {
            key: "otherstr",
            valueType: "string"
          },
          {
            key: "dedup_splitvals",
            valueType: "bool"
          }
        ],
        functions: [
          {
            name: "c",
            parenOptional: true
          },
          {
            name: "count",
            parenOptional: true
          },
          {
            name: "dc",
            parenOptional: true
          },
          {
            name: "distinct_count",
            parenOptional: true
          },
          {
            name: "mean",
            parenOptional: true
          },
          {
            name: "avg",
            parenOptional: true
          },
          {
            name: "stdev",
            parenOptional: true
          },
          {
            name: "stdevp",
            parenOptional: true
          },
          {
            name: "var",
            parenOptional: true
          },
          {
            name: "varp",
            parenOptional: true
          },
          {
            name: "sum",
            parenOptional: true
          },
          {
            name: "sumsq",
            parenOptional: true
          },
          {
            name: "min",
            parenOptional: true
          },
          {
            name: "max",
            parenOptional: true
          },
          {
            name: "mode",
            parenOptional: true
          },
          {
            name: "median",
            parenOptional: true
          },
          {
            name: "earliest",
            parenOptional: true
          },
          {
            name: "first",
            parenOptional: true
          },
          {
            name: "last",
            parenOptional: true
          },
          {
            name: "latest",
            parenOptional: true
          },
          {
            name: "list",
            parenOptional: true
          },
          {
            name: "values",
            parenOptional: true
          },
          {
            name: "range",
            parenOptional: true
          },
          {
            name: "estdc",
            parenOptional: true
          },
          {
            name: "estdc_error",
            parenOptional: true
          },
          {
            name: "earliest_time",
            parenOptional: true
          },
          {
            name: "latest_time",
            parenOptional: true
          },
          {
            name: "rate",
            parenOptional: true
          },
          {
            name: "eval",
            parenOptional: false
          },
          {
            name: "abs",
            parenOptional: false
          },
          {
            name: "avg",
            parenOptional: false
          },
          {
            name: "case",
            parenOptional: false
          },
          {
            name: "ceiling",
            parenOptional: false
          },
          {
            name: "ceil",
            parenOptional: false
          },
          {
            name: "cidrmatch",
            parenOptional: false
          },
          {
            name: "coalesce",
            parenOptional: false
          },
          {
            name: "commands",
            parenOptional: false
          },
          {
            name: "exact",
            parenOptional: false
          },
          {
            name: "exp",
            parenOptional: false
          },
          {
            name: "false",
            parenOptional: false
          },
          {
            name: "floor",
            parenOptional: false
          },
          {
            name: "if",
            parenOptional: false
          },
          {
            name: "ifnull",
            parenOptional: false
          },
          {
            name: "isbool",
            parenOptional: false
          },
          {
            name: "isint",
            parenOptional: false
          },
          {
            name: "isnotnull",
            parenOptional: false
          },
          {
            name: "isnull",
            parenOptional: false
          },
          {
            name: "isnum",
            parenOptional: false
          },
          {
            name: "isstr",
            parenOptional: false
          },
          {
            name: "len",
            parenOptional: false
          },
          {
            name: "like",
            parenOptional: false
          },
          {
            name: "ln",
            parenOptional: false
          },
          {
            name: "log",
            parenOptional: false
          },
          {
            name: "lookup",
            parenOptional: false
          },
          {
            name: "lower",
            parenOptional: false
          },
          {
            name: "match",
            parenOptional: false
          },
          {
            name: "max",
            parenOptional: false
          },
          {
            name: "md5",
            parenOptional: false
          },
          {
            name: "min",
            parenOptional: false
          },
          {
            name: "mvappend",
            parenOptional: false
          },
          {
            name: "mvcount",
            parenOptional: false
          },
          {
            name: "mvdedup",
            parenOptional: false
          },
          {
            name: "mvindex",
            parenOptional: false
          },
          {
            name: "mvfilter",
            parenOptional: false
          },
          {
            name: "mvfind",
            parenOptional: false
          },
          {
            name: "mvjoin",
            parenOptional: false
          },
          {
            name: "mvmap",
            parenOptional: false
          },
          {
            name: "mvrange",
            parenOptional: false
          },
          {
            name: "mvsort",
            parenOptional: false
          },
          {
            name: "mvzip",
            parenOptional: false
          },
          {
            name: "now",
            parenOptional: false
          },
          {
            name: "null",
            parenOptional: false
          },
          {
            name: "nullif",
            parenOptional: false
          },
          {
            name: "pi",
            parenOptional: false
          },
          {
            name: "pow",
            parenOptional: false
          },
          {
            name: "random",
            parenOptional: false
          },
          {
            name: "relative_time",
            parenOptional: false
          },
          {
            name: "replace",
            parenOptional: false
          },
          {
            name: "round",
            parenOptional: false
          },
          {
            name: "searchmatch",
            parenOptional: false
          },
          {
            name: "sha1",
            parenOptional: false
          },
          {
            name: "sha256",
            parenOptional: false
          },
          {
            name: "sha512",
            parenOptional: false
          },
          {
            name: "sigfig",
            parenOptional: false
          },
          {
            name: "spath",
            parenOptional: false
          },
          {
            name: "split",
            parenOptional: false
          },
          {
            name: "sqrt",
            parenOptional: false
          },
          {
            name: "strftime",
            parenOptional: false
          },
          {
            name: "strptime",
            parenOptional: false
          },
          {
            name: "substr",
            parenOptional: false
          },
          {
            name: "sum",
            parenOptional: false
          },
          {
            name: "time",
            parenOptional: false
          },
          {
            name: "tostring",
            parenOptional: false
          },
          {
            name: "trim",
            parenOptional: false
          },
          {
            name: "ltrim",
            parenOptional: false
          },
          {
            name: "rtrim",
            parenOptional: false
          },
          {
            name: "true",
            parenOptional: false
          },
          {
            name: "typeof",
            parenOptional: false
          },
          {
            name: "upper",
            parenOptional: false
          },
          {
            name: "urldecode",
            parenOptional: false
          },
          {
            name: "validate",
            parenOptional: false
          },
          {
            name: "tonumber",
            parenOptional: false
          },
          {
            name: "acos",
            parenOptional: false
          },
          {
            name: "acosh",
            parenOptional: false
          },
          {
            name: "asin",
            parenOptional: false
          },
          {
            name: "asinh",
            parenOptional: false
          },
          {
            name: "atan",
            parenOptional: false
          },
          {
            name: "atan2",
            parenOptional: false
          },
          {
            name: "atanh",
            parenOptional: false
          },
          {
            name: "cos",
            parenOptional: false
          },
          {
            name: "cosh",
            parenOptional: false
          },
          {
            name: "hypot",
            parenOptional: false
          },
          {
            name: "sin",
            parenOptional: false
          },
          {
            name: "sinh",
            parenOptional: false
          },
          {
            name: "tan",
            parenOptional: false
          },
          {
            name: "tanh",
            parenOptional: false
          },
          {
            name: "json_array_to_mv",
            parenOptional: false
          },
          {
            name: "mv_to_json_array",
            parenOptional: false
          },
          {
            name: "json_append",
            parenOptional: false
          },
          {
            name: "json_extend",
            parenOptional: false
          },
          {
            name: "json_extract_exact",
            parenOptional: false
          },
          {
            name: "json_set_exact",
            parenOptional: false
          },
          {
            name: "sparkline",
            parenOptional: false
          },
          {
            name: "c",
            parenOptional: false
          },
          {
            name: "count",
            parenOptional: false
          },
          {
            name: "dc",
            parenOptional: false
          },
          {
            name: "mean",
            parenOptional: false
          },
          {
            name: "avg",
            parenOptional: false
          },
          {
            name: "stdev",
            parenOptional: false
          },
          {
            name: "stdevp",
            parenOptional: false
          },
          {
            name: "var",
            parenOptional: false
          },
          {
            name: "varp",
            parenOptional: false
          },
          {
            name: "sum",
            parenOptional: false
          },
          {
            name: "sumsq",
            parenOptional: false
          },
          {
            name: "min",
            parenOptional: false
          },
          {
            name: "max",
            parenOptional: false
          },
          {
            name: "range",
            parenOptional: false
          },
          {
            name: "c",
            parenOptional: false
          },
          {
            name: "count",
            parenOptional: false
          },
          {
            name: "dc",
            parenOptional: false
          },
          {
            name: "distinct_count",
            parenOptional: false
          },
          {
            name: "mean",
            parenOptional: false
          },
          {
            name: "avg",
            parenOptional: false
          },
          {
            name: "stdev",
            parenOptional: false
          },
          {
            name: "stdevp",
            parenOptional: false
          },
          {
            name: "var",
            parenOptional: false
          },
          {
            name: "varp",
            parenOptional: false
          },
          {
            name: "sum",
            parenOptional: false
          },
          {
            name: "sumsq",
            parenOptional: false
          },
          {
            name: "min",
            parenOptional: false
          },
          {
            name: "max",
            parenOptional: false
          },
          {
            name: "mode",
            parenOptional: false
          },
          {
            name: "median",
            parenOptional: false
          },
          {
            name: "earliest",
            parenOptional: false
          },
          {
            name: "first",
            parenOptional: false
          },
          {
            name: "last",
            parenOptional: false
          },
          {
            name: "latest",
            parenOptional: false
          },
          {
            name: "list",
            parenOptional: false
          },
          {
            name: "values",
            parenOptional: false
          },
          {
            name: "range",
            parenOptional: false
          },
          {
            name: "estdc",
            parenOptional: false
          },
          {
            name: "estdc_error",
            parenOptional: false
          },
          {
            name: "earliest_time",
            parenOptional: false
          },
          {
            name: "latest_time",
            parenOptional: false
          },
          {
            name: "rate",
            parenOptional: false
          }
        ],
        keywords: ["LIKE", "AND|OR|XOR", "as", "BY", "where", "OVER"],
        other: ["field", "num", "string", "wc-field", "int", "|"],
        list: []
      },
      "sirare-command": {
        isList: false,
        args: [
          {
            key: "showcount",
            valueType: "bool"
          },
          {
            key: "showperc",
            valueType: "bool"
          },
          {
            key: "limit",
            valueType: "int"
          },
          {
            key: "countfield",
            valueType: "string"
          },
          {
            key: "percentfield",
            valueType: "string"
          },
          {
            key: "useother",
            valueType: "bool"
          },
          {
            key: "otherstr",
            valueType: "string"
          }
        ],
        functions: [],
        keywords: ["by"],
        other: ["field-list"],
        list: []
      },
      "sistats-command": {
        isList: false,
        args: [
          {
            key: "partitions",
            valueType: "num"
          },
          {
            key: "allnum",
            valueType: "bool"
          },
          {
            key: "delim",
            valueType: "string"
          },
          {
            key: "dedup_splitvals",
            valueType: "bool"
          }
        ],
        functions: [
          {
            name: "c",
            parenOptional: true
          },
          {
            name: "count",
            parenOptional: true
          },
          {
            name: "dc",
            parenOptional: true
          },
          {
            name: "distinct_count",
            parenOptional: true
          },
          {
            name: "mean",
            parenOptional: true
          },
          {
            name: "avg",
            parenOptional: true
          },
          {
            name: "stdev",
            parenOptional: true
          },
          {
            name: "stdevp",
            parenOptional: true
          },
          {
            name: "var",
            parenOptional: true
          },
          {
            name: "varp",
            parenOptional: true
          },
          {
            name: "sum",
            parenOptional: true
          },
          {
            name: "sumsq",
            parenOptional: true
          },
          {
            name: "min",
            parenOptional: true
          },
          {
            name: "max",
            parenOptional: true
          },
          {
            name: "mode",
            parenOptional: true
          },
          {
            name: "median",
            parenOptional: true
          },
          {
            name: "earliest",
            parenOptional: true
          },
          {
            name: "first",
            parenOptional: true
          },
          {
            name: "last",
            parenOptional: true
          },
          {
            name: "latest",
            parenOptional: true
          },
          {
            name: "list",
            parenOptional: true
          },
          {
            name: "values",
            parenOptional: true
          },
          {
            name: "range",
            parenOptional: true
          },
          {
            name: "estdc",
            parenOptional: true
          },
          {
            name: "estdc_error",
            parenOptional: true
          },
          {
            name: "earliest_time",
            parenOptional: true
          },
          {
            name: "latest_time",
            parenOptional: true
          },
          {
            name: "rate",
            parenOptional: true
          },
          {
            name: "eval",
            parenOptional: false
          },
          {
            name: "abs",
            parenOptional: false
          },
          {
            name: "avg",
            parenOptional: false
          },
          {
            name: "case",
            parenOptional: false
          },
          {
            name: "ceiling",
            parenOptional: false
          },
          {
            name: "ceil",
            parenOptional: false
          },
          {
            name: "cidrmatch",
            parenOptional: false
          },
          {
            name: "coalesce",
            parenOptional: false
          },
          {
            name: "commands",
            parenOptional: false
          },
          {
            name: "exact",
            parenOptional: false
          },
          {
            name: "exp",
            parenOptional: false
          },
          {
            name: "false",
            parenOptional: false
          },
          {
            name: "floor",
            parenOptional: false
          },
          {
            name: "if",
            parenOptional: false
          },
          {
            name: "ifnull",
            parenOptional: false
          },
          {
            name: "isbool",
            parenOptional: false
          },
          {
            name: "isint",
            parenOptional: false
          },
          {
            name: "isnotnull",
            parenOptional: false
          },
          {
            name: "isnull",
            parenOptional: false
          },
          {
            name: "isnum",
            parenOptional: false
          },
          {
            name: "isstr",
            parenOptional: false
          },
          {
            name: "len",
            parenOptional: false
          },
          {
            name: "like",
            parenOptional: false
          },
          {
            name: "ln",
            parenOptional: false
          },
          {
            name: "log",
            parenOptional: false
          },
          {
            name: "lookup",
            parenOptional: false
          },
          {
            name: "lower",
            parenOptional: false
          },
          {
            name: "match",
            parenOptional: false
          },
          {
            name: "max",
            parenOptional: false
          },
          {
            name: "md5",
            parenOptional: false
          },
          {
            name: "min",
            parenOptional: false
          },
          {
            name: "mvappend",
            parenOptional: false
          },
          {
            name: "mvcount",
            parenOptional: false
          },
          {
            name: "mvdedup",
            parenOptional: false
          },
          {
            name: "mvindex",
            parenOptional: false
          },
          {
            name: "mvfilter",
            parenOptional: false
          },
          {
            name: "mvfind",
            parenOptional: false
          },
          {
            name: "mvjoin",
            parenOptional: false
          },
          {
            name: "mvmap",
            parenOptional: false
          },
          {
            name: "mvrange",
            parenOptional: false
          },
          {
            name: "mvsort",
            parenOptional: false
          },
          {
            name: "mvzip",
            parenOptional: false
          },
          {
            name: "now",
            parenOptional: false
          },
          {
            name: "null",
            parenOptional: false
          },
          {
            name: "nullif",
            parenOptional: false
          },
          {
            name: "pi",
            parenOptional: false
          },
          {
            name: "pow",
            parenOptional: false
          },
          {
            name: "random",
            parenOptional: false
          },
          {
            name: "relative_time",
            parenOptional: false
          },
          {
            name: "replace",
            parenOptional: false
          },
          {
            name: "round",
            parenOptional: false
          },
          {
            name: "searchmatch",
            parenOptional: false
          },
          {
            name: "sha1",
            parenOptional: false
          },
          {
            name: "sha256",
            parenOptional: false
          },
          {
            name: "sha512",
            parenOptional: false
          },
          {
            name: "sigfig",
            parenOptional: false
          },
          {
            name: "spath",
            parenOptional: false
          },
          {
            name: "split",
            parenOptional: false
          },
          {
            name: "sqrt",
            parenOptional: false
          },
          {
            name: "strftime",
            parenOptional: false
          },
          {
            name: "strptime",
            parenOptional: false
          },
          {
            name: "substr",
            parenOptional: false
          },
          {
            name: "sum",
            parenOptional: false
          },
          {
            name: "time",
            parenOptional: false
          },
          {
            name: "tostring",
            parenOptional: false
          },
          {
            name: "trim",
            parenOptional: false
          },
          {
            name: "ltrim",
            parenOptional: false
          },
          {
            name: "rtrim",
            parenOptional: false
          },
          {
            name: "true",
            parenOptional: false
          },
          {
            name: "typeof",
            parenOptional: false
          },
          {
            name: "upper",
            parenOptional: false
          },
          {
            name: "urldecode",
            parenOptional: false
          },
          {
            name: "validate",
            parenOptional: false
          },
          {
            name: "tonumber",
            parenOptional: false
          },
          {
            name: "acos",
            parenOptional: false
          },
          {
            name: "acosh",
            parenOptional: false
          },
          {
            name: "asin",
            parenOptional: false
          },
          {
            name: "asinh",
            parenOptional: false
          },
          {
            name: "atan",
            parenOptional: false
          },
          {
            name: "atan2",
            parenOptional: false
          },
          {
            name: "atanh",
            parenOptional: false
          },
          {
            name: "cos",
            parenOptional: false
          },
          {
            name: "cosh",
            parenOptional: false
          },
          {
            name: "hypot",
            parenOptional: false
          },
          {
            name: "sin",
            parenOptional: false
          },
          {
            name: "sinh",
            parenOptional: false
          },
          {
            name: "tan",
            parenOptional: false
          },
          {
            name: "tanh",
            parenOptional: false
          },
          {
            name: "json_array_to_mv",
            parenOptional: false
          },
          {
            name: "mv_to_json_array",
            parenOptional: false
          },
          {
            name: "json_append",
            parenOptional: false
          },
          {
            name: "json_extend",
            parenOptional: false
          },
          {
            name: "json_extract_exact",
            parenOptional: false
          },
          {
            name: "json_set_exact",
            parenOptional: false
          },
          {
            name: "sparkline",
            parenOptional: false
          },
          {
            name: "c",
            parenOptional: false
          },
          {
            name: "count",
            parenOptional: false
          },
          {
            name: "dc",
            parenOptional: false
          },
          {
            name: "mean",
            parenOptional: false
          },
          {
            name: "avg",
            parenOptional: false
          },
          {
            name: "stdev",
            parenOptional: false
          },
          {
            name: "stdevp",
            parenOptional: false
          },
          {
            name: "var",
            parenOptional: false
          },
          {
            name: "varp",
            parenOptional: false
          },
          {
            name: "sum",
            parenOptional: false
          },
          {
            name: "sumsq",
            parenOptional: false
          },
          {
            name: "min",
            parenOptional: false
          },
          {
            name: "max",
            parenOptional: false
          },
          {
            name: "range",
            parenOptional: false
          }
        ],
        keywords: ["LIKE", "AND|OR|XOR", "as", "by"],
        other: ["field", "num", "string", "wc-field", "int", "field-list"],
        list: []
      },
      "sitimechart-command": {
        isList: false,
        args: [
          {
            key: "sep",
            valueType: "string"
          },
          {
            key: "format",
            valueType: "string"
          },
          {
            key: "fixedrange",
            valueType: "bool"
          },
          {
            key: "partial",
            valueType: "bool"
          },
          {
            key: "cont",
            valueType: "bool"
          },
          {
            key: "limit",
            valueType: "chart-limit-opt"
          },
          {
            key: "bins",
            valueType: "int"
          },
          {
            key: "minspan",
            valueType: ""
          },
          {
            key: "span",
            valueType: ""
          },
          {
            key: "start",
            valueType: "num"
          },
          {
            key: "end",
            valueType: "num"
          },
          {
            key: "aligntime",
            valueType: ""
          },
          {
            key: "usenull",
            valueType: "bool"
          },
          {
            key: "useother",
            valueType: "bool"
          },
          {
            key: "nullstr",
            valueType: "string"
          },
          {
            key: "otherstr",
            valueType: "string"
          },
          {
            key: "dedup_splitvals",
            valueType: "bool"
          }
        ],
        functions: [
          {
            name: "c",
            parenOptional: true
          },
          {
            name: "count",
            parenOptional: true
          },
          {
            name: "dc",
            parenOptional: true
          },
          {
            name: "distinct_count",
            parenOptional: true
          },
          {
            name: "mean",
            parenOptional: true
          },
          {
            name: "avg",
            parenOptional: true
          },
          {
            name: "stdev",
            parenOptional: true
          },
          {
            name: "stdevp",
            parenOptional: true
          },
          {
            name: "var",
            parenOptional: true
          },
          {
            name: "varp",
            parenOptional: true
          },
          {
            name: "sum",
            parenOptional: true
          },
          {
            name: "sumsq",
            parenOptional: true
          },
          {
            name: "min",
            parenOptional: true
          },
          {
            name: "max",
            parenOptional: true
          },
          {
            name: "mode",
            parenOptional: true
          },
          {
            name: "median",
            parenOptional: true
          },
          {
            name: "earliest",
            parenOptional: true
          },
          {
            name: "first",
            parenOptional: true
          },
          {
            name: "last",
            parenOptional: true
          },
          {
            name: "latest",
            parenOptional: true
          },
          {
            name: "list",
            parenOptional: true
          },
          {
            name: "values",
            parenOptional: true
          },
          {
            name: "range",
            parenOptional: true
          },
          {
            name: "estdc",
            parenOptional: true
          },
          {
            name: "estdc_error",
            parenOptional: true
          },
          {
            name: "earliest_time",
            parenOptional: true
          },
          {
            name: "latest_time",
            parenOptional: true
          },
          {
            name: "rate",
            parenOptional: true
          },
          {
            name: "eval",
            parenOptional: false
          },
          {
            name: "abs",
            parenOptional: false
          },
          {
            name: "avg",
            parenOptional: false
          },
          {
            name: "case",
            parenOptional: false
          },
          {
            name: "ceiling",
            parenOptional: false
          },
          {
            name: "ceil",
            parenOptional: false
          },
          {
            name: "cidrmatch",
            parenOptional: false
          },
          {
            name: "coalesce",
            parenOptional: false
          },
          {
            name: "commands",
            parenOptional: false
          },
          {
            name: "exact",
            parenOptional: false
          },
          {
            name: "exp",
            parenOptional: false
          },
          {
            name: "false",
            parenOptional: false
          },
          {
            name: "floor",
            parenOptional: false
          },
          {
            name: "if",
            parenOptional: false
          },
          {
            name: "ifnull",
            parenOptional: false
          },
          {
            name: "isbool",
            parenOptional: false
          },
          {
            name: "isint",
            parenOptional: false
          },
          {
            name: "isnotnull",
            parenOptional: false
          },
          {
            name: "isnull",
            parenOptional: false
          },
          {
            name: "isnum",
            parenOptional: false
          },
          {
            name: "isstr",
            parenOptional: false
          },
          {
            name: "len",
            parenOptional: false
          },
          {
            name: "like",
            parenOptional: false
          },
          {
            name: "ln",
            parenOptional: false
          },
          {
            name: "log",
            parenOptional: false
          },
          {
            name: "lookup",
            parenOptional: false
          },
          {
            name: "lower",
            parenOptional: false
          },
          {
            name: "match",
            parenOptional: false
          },
          {
            name: "max",
            parenOptional: false
          },
          {
            name: "md5",
            parenOptional: false
          },
          {
            name: "min",
            parenOptional: false
          },
          {
            name: "mvappend",
            parenOptional: false
          },
          {
            name: "mvcount",
            parenOptional: false
          },
          {
            name: "mvdedup",
            parenOptional: false
          },
          {
            name: "mvindex",
            parenOptional: false
          },
          {
            name: "mvfilter",
            parenOptional: false
          },
          {
            name: "mvfind",
            parenOptional: false
          },
          {
            name: "mvjoin",
            parenOptional: false
          },
          {
            name: "mvmap",
            parenOptional: false
          },
          {
            name: "mvrange",
            parenOptional: false
          },
          {
            name: "mvsort",
            parenOptional: false
          },
          {
            name: "mvzip",
            parenOptional: false
          },
          {
            name: "now",
            parenOptional: false
          },
          {
            name: "null",
            parenOptional: false
          },
          {
            name: "nullif",
            parenOptional: false
          },
          {
            name: "pi",
            parenOptional: false
          },
          {
            name: "pow",
            parenOptional: false
          },
          {
            name: "random",
            parenOptional: false
          },
          {
            name: "relative_time",
            parenOptional: false
          },
          {
            name: "replace",
            parenOptional: false
          },
          {
            name: "round",
            parenOptional: false
          },
          {
            name: "searchmatch",
            parenOptional: false
          },
          {
            name: "sha1",
            parenOptional: false
          },
          {
            name: "sha256",
            parenOptional: false
          },
          {
            name: "sha512",
            parenOptional: false
          },
          {
            name: "sigfig",
            parenOptional: false
          },
          {
            name: "spath",
            parenOptional: false
          },
          {
            name: "split",
            parenOptional: false
          },
          {
            name: "sqrt",
            parenOptional: false
          },
          {
            name: "strftime",
            parenOptional: false
          },
          {
            name: "strptime",
            parenOptional: false
          },
          {
            name: "substr",
            parenOptional: false
          },
          {
            name: "sum",
            parenOptional: false
          },
          {
            name: "time",
            parenOptional: false
          },
          {
            name: "tostring",
            parenOptional: false
          },
          {
            name: "trim",
            parenOptional: false
          },
          {
            name: "ltrim",
            parenOptional: false
          },
          {
            name: "rtrim",
            parenOptional: false
          },
          {
            name: "true",
            parenOptional: false
          },
          {
            name: "typeof",
            parenOptional: false
          },
          {
            name: "upper",
            parenOptional: false
          },
          {
            name: "urldecode",
            parenOptional: false
          },
          {
            name: "validate",
            parenOptional: false
          },
          {
            name: "tonumber",
            parenOptional: false
          },
          {
            name: "acos",
            parenOptional: false
          },
          {
            name: "acosh",
            parenOptional: false
          },
          {
            name: "asin",
            parenOptional: false
          },
          {
            name: "asinh",
            parenOptional: false
          },
          {
            name: "atan",
            parenOptional: false
          },
          {
            name: "atan2",
            parenOptional: false
          },
          {
            name: "atanh",
            parenOptional: false
          },
          {
            name: "cos",
            parenOptional: false
          },
          {
            name: "cosh",
            parenOptional: false
          },
          {
            name: "hypot",
            parenOptional: false
          },
          {
            name: "sin",
            parenOptional: false
          },
          {
            name: "sinh",
            parenOptional: false
          },
          {
            name: "tan",
            parenOptional: false
          },
          {
            name: "tanh",
            parenOptional: false
          },
          {
            name: "json_array_to_mv",
            parenOptional: false
          },
          {
            name: "mv_to_json_array",
            parenOptional: false
          },
          {
            name: "json_append",
            parenOptional: false
          },
          {
            name: "json_extend",
            parenOptional: false
          },
          {
            name: "json_extract_exact",
            parenOptional: false
          },
          {
            name: "json_set_exact",
            parenOptional: false
          },
          {
            name: "c",
            parenOptional: false
          },
          {
            name: "count",
            parenOptional: false
          },
          {
            name: "dc",
            parenOptional: false
          },
          {
            name: "distinct_count",
            parenOptional: false
          },
          {
            name: "mean",
            parenOptional: false
          },
          {
            name: "avg",
            parenOptional: false
          },
          {
            name: "stdev",
            parenOptional: false
          },
          {
            name: "stdevp",
            parenOptional: false
          },
          {
            name: "var",
            parenOptional: false
          },
          {
            name: "varp",
            parenOptional: false
          },
          {
            name: "sum",
            parenOptional: false
          },
          {
            name: "sumsq",
            parenOptional: false
          },
          {
            name: "min",
            parenOptional: false
          },
          {
            name: "max",
            parenOptional: false
          },
          {
            name: "mode",
            parenOptional: false
          },
          {
            name: "median",
            parenOptional: false
          },
          {
            name: "earliest",
            parenOptional: false
          },
          {
            name: "first",
            parenOptional: false
          },
          {
            name: "last",
            parenOptional: false
          },
          {
            name: "latest",
            parenOptional: false
          },
          {
            name: "list",
            parenOptional: false
          },
          {
            name: "values",
            parenOptional: false
          },
          {
            name: "range",
            parenOptional: false
          },
          {
            name: "estdc",
            parenOptional: false
          },
          {
            name: "estdc_error",
            parenOptional: false
          },
          {
            name: "earliest_time",
            parenOptional: false
          },
          {
            name: "latest_time",
            parenOptional: false
          },
          {
            name: "rate",
            parenOptional: false
          },
          {
            name: "per_second",
            parenOptional: false
          },
          {
            name: "per_minute",
            parenOptional: false
          },
          {
            name: "per_hour",
            parenOptional: false
          },
          {
            name: "per_day",
            parenOptional: false
          }
        ],
        keywords: ["LIKE", "AND|OR|XOR", "as", "by", "where"],
        other: ["field", "num", "string", "wc-field", "int", "|"],
        list: []
      },
      "sitop-command": {
        isList: false,
        args: [
          {
            key: "showcount",
            valueType: "bool"
          },
          {
            key: "showperc",
            valueType: "bool"
          },
          {
            key: "limit",
            valueType: "int"
          },
          {
            key: "countfield",
            valueType: "string"
          },
          {
            key: "percentfield",
            valueType: "string"
          },
          {
            key: "useother",
            valueType: "bool"
          },
          {
            key: "otherstr",
            valueType: "string"
          }
        ],
        functions: [],
        keywords: ["by"],
        other: ["int", "field-list"],
        list: []
      },
      "sort-command": {
        isList: false,
        args: [],
        functions: [],
        keywords: [],
        other: ["int", "field"],
        list: []
      },
      "spath-command": {
        isList: false,
        args: [
          {
            key: "output",
            valueType: "field"
          },
          {
            key: "path",
            valueType: "datapath"
          },
          {
            key: "input",
            valueType: "field"
          }
        ],
        functions: [],
        keywords: [],
        other: ["datapath"],
        list: []
      },
      "stats-command": {
        isList: false,
        args: [
          {
            key: "partitions",
            valueType: "num"
          },
          {
            key: "allnum",
            valueType: "bool"
          },
          {
            key: "delim",
            valueType: "string"
          },
          {
            key: "dedup_splitvals",
            valueType: "bool"
          }
        ],
        functions: [
          {
            name: "c",
            parenOptional: true
          },
          {
            name: "count",
            parenOptional: true
          },
          {
            name: "dc",
            parenOptional: true
          },
          {
            name: "distinct_count",
            parenOptional: true
          },
          {
            name: "mean",
            parenOptional: true
          },
          {
            name: "avg",
            parenOptional: true
          },
          {
            name: "stdev",
            parenOptional: true
          },
          {
            name: "stdevp",
            parenOptional: true
          },
          {
            name: "var",
            parenOptional: true
          },
          {
            name: "varp",
            parenOptional: true
          },
          {
            name: "sum",
            parenOptional: true
          },
          {
            name: "sumsq",
            parenOptional: true
          },
          {
            name: "min",
            parenOptional: true
          },
          {
            name: "max",
            parenOptional: true
          },
          {
            name: "mode",
            parenOptional: true
          },
          {
            name: "median",
            parenOptional: true
          },
          {
            name: "earliest",
            parenOptional: true
          },
          {
            name: "first",
            parenOptional: true
          },
          {
            name: "last",
            parenOptional: true
          },
          {
            name: "latest",
            parenOptional: true
          },
          {
            name: "list",
            parenOptional: true
          },
          {
            name: "values",
            parenOptional: true
          },
          {
            name: "range",
            parenOptional: true
          },
          {
            name: "estdc",
            parenOptional: true
          },
          {
            name: "estdc_error",
            parenOptional: true
          },
          {
            name: "earliest_time",
            parenOptional: true
          },
          {
            name: "latest_time",
            parenOptional: true
          },
          {
            name: "rate",
            parenOptional: true
          },
          {
            name: "eval",
            parenOptional: false
          },
          {
            name: "abs",
            parenOptional: false
          },
          {
            name: "avg",
            parenOptional: false
          },
          {
            name: "case",
            parenOptional: false
          },
          {
            name: "ceiling",
            parenOptional: false
          },
          {
            name: "ceil",
            parenOptional: false
          },
          {
            name: "cidrmatch",
            parenOptional: false
          },
          {
            name: "coalesce",
            parenOptional: false
          },
          {
            name: "commands",
            parenOptional: false
          },
          {
            name: "exact",
            parenOptional: false
          },
          {
            name: "exp",
            parenOptional: false
          },
          {
            name: "false",
            parenOptional: false
          },
          {
            name: "floor",
            parenOptional: false
          },
          {
            name: "if",
            parenOptional: false
          },
          {
            name: "ifnull",
            parenOptional: false
          },
          {
            name: "isbool",
            parenOptional: false
          },
          {
            name: "isint",
            parenOptional: false
          },
          {
            name: "isnotnull",
            parenOptional: false
          },
          {
            name: "isnull",
            parenOptional: false
          },
          {
            name: "isnum",
            parenOptional: false
          },
          {
            name: "isstr",
            parenOptional: false
          },
          {
            name: "len",
            parenOptional: false
          },
          {
            name: "like",
            parenOptional: false
          },
          {
            name: "ln",
            parenOptional: false
          },
          {
            name: "log",
            parenOptional: false
          },
          {
            name: "lookup",
            parenOptional: false
          },
          {
            name: "lower",
            parenOptional: false
          },
          {
            name: "match",
            parenOptional: false
          },
          {
            name: "max",
            parenOptional: false
          },
          {
            name: "md5",
            parenOptional: false
          },
          {
            name: "min",
            parenOptional: false
          },
          {
            name: "mvappend",
            parenOptional: false
          },
          {
            name: "mvcount",
            parenOptional: false
          },
          {
            name: "mvdedup",
            parenOptional: false
          },
          {
            name: "mvindex",
            parenOptional: false
          },
          {
            name: "mvfilter",
            parenOptional: false
          },
          {
            name: "mvfind",
            parenOptional: false
          },
          {
            name: "mvjoin",
            parenOptional: false
          },
          {
            name: "mvmap",
            parenOptional: false
          },
          {
            name: "mvrange",
            parenOptional: false
          },
          {
            name: "mvsort",
            parenOptional: false
          },
          {
            name: "mvzip",
            parenOptional: false
          },
          {
            name: "now",
            parenOptional: false
          },
          {
            name: "null",
            parenOptional: false
          },
          {
            name: "nullif",
            parenOptional: false
          },
          {
            name: "pi",
            parenOptional: false
          },
          {
            name: "pow",
            parenOptional: false
          },
          {
            name: "random",
            parenOptional: false
          },
          {
            name: "relative_time",
            parenOptional: false
          },
          {
            name: "replace",
            parenOptional: false
          },
          {
            name: "round",
            parenOptional: false
          },
          {
            name: "searchmatch",
            parenOptional: false
          },
          {
            name: "sha1",
            parenOptional: false
          },
          {
            name: "sha256",
            parenOptional: false
          },
          {
            name: "sha512",
            parenOptional: false
          },
          {
            name: "sigfig",
            parenOptional: false
          },
          {
            name: "spath",
            parenOptional: false
          },
          {
            name: "split",
            parenOptional: false
          },
          {
            name: "sqrt",
            parenOptional: false
          },
          {
            name: "strftime",
            parenOptional: false
          },
          {
            name: "strptime",
            parenOptional: false
          },
          {
            name: "substr",
            parenOptional: false
          },
          {
            name: "sum",
            parenOptional: false
          },
          {
            name: "time",
            parenOptional: false
          },
          {
            name: "tostring",
            parenOptional: false
          },
          {
            name: "trim",
            parenOptional: false
          },
          {
            name: "ltrim",
            parenOptional: false
          },
          {
            name: "rtrim",
            parenOptional: false
          },
          {
            name: "true",
            parenOptional: false
          },
          {
            name: "typeof",
            parenOptional: false
          },
          {
            name: "upper",
            parenOptional: false
          },
          {
            name: "urldecode",
            parenOptional: false
          },
          {
            name: "validate",
            parenOptional: false
          },
          {
            name: "tonumber",
            parenOptional: false
          },
          {
            name: "acos",
            parenOptional: false
          },
          {
            name: "acosh",
            parenOptional: false
          },
          {
            name: "asin",
            parenOptional: false
          },
          {
            name: "asinh",
            parenOptional: false
          },
          {
            name: "atan",
            parenOptional: false
          },
          {
            name: "atan2",
            parenOptional: false
          },
          {
            name: "atanh",
            parenOptional: false
          },
          {
            name: "cos",
            parenOptional: false
          },
          {
            name: "cosh",
            parenOptional: false
          },
          {
            name: "hypot",
            parenOptional: false
          },
          {
            name: "sin",
            parenOptional: false
          },
          {
            name: "sinh",
            parenOptional: false
          },
          {
            name: "tan",
            parenOptional: false
          },
          {
            name: "tanh",
            parenOptional: false
          },
          {
            name: "json_array_to_mv",
            parenOptional: false
          },
          {
            name: "mv_to_json_array",
            parenOptional: false
          },
          {
            name: "json_append",
            parenOptional: false
          },
          {
            name: "json_extend",
            parenOptional: false
          },
          {
            name: "json_extract_exact",
            parenOptional: false
          },
          {
            name: "json_set_exact",
            parenOptional: false
          },
          {
            name: "sparkline",
            parenOptional: false
          },
          {
            name: "c",
            parenOptional: false
          },
          {
            name: "count",
            parenOptional: false
          },
          {
            name: "dc",
            parenOptional: false
          },
          {
            name: "mean",
            parenOptional: false
          },
          {
            name: "avg",
            parenOptional: false
          },
          {
            name: "stdev",
            parenOptional: false
          },
          {
            name: "stdevp",
            parenOptional: false
          },
          {
            name: "var",
            parenOptional: false
          },
          {
            name: "varp",
            parenOptional: false
          },
          {
            name: "sum",
            parenOptional: false
          },
          {
            name: "sumsq",
            parenOptional: false
          },
          {
            name: "min",
            parenOptional: false
          },
          {
            name: "max",
            parenOptional: false
          },
          {
            name: "range",
            parenOptional: false
          }
        ],
        keywords: ["LIKE", "AND|OR|XOR", "as", "by"],
        other: ["field", "num", "string", "wc-field", "int", "field-list"],
        list: []
      },
      "strcat-command": {
        isList: false,
        args: [
          {
            key: "allrequired",
            valueType: "bool"
          }
        ],
        functions: [],
        keywords: [],
        other: ["field", "double-quoted-string", "field"],
        list: []
      },
      "streamedcsv-command": {
        isList: false,
        args: [
          {
            key: "chunk",
            valueType: "int"
          }
        ],
        functions: [],
        keywords: [],
        other: ["string"],
        list: []
      },
      "streamstats-command": {
        isList: false,
        args: [
          {
            key: "reset_on_change",
            valueType: "bool"
          },
          {
            key: "reset_before",
            valueType: ""
          },
          {
            key: "reset_after",
            valueType: ""
          },
          {
            key: "current",
            valueType: "bool"
          },
          {
            key: "window",
            valueType: "int"
          },
          {
            key: "time_window",
            valueType: "span-length"
          },
          {
            key: "global",
            valueType: "bool"
          },
          {
            key: "allnum",
            valueType: "bool"
          }
        ],
        functions: [
          {
            name: "c",
            parenOptional: true
          },
          {
            name: "count",
            parenOptional: true
          },
          {
            name: "dc",
            parenOptional: true
          },
          {
            name: "distinct_count",
            parenOptional: true
          },
          {
            name: "mean",
            parenOptional: true
          },
          {
            name: "avg",
            parenOptional: true
          },
          {
            name: "stdev",
            parenOptional: true
          },
          {
            name: "stdevp",
            parenOptional: true
          },
          {
            name: "var",
            parenOptional: true
          },
          {
            name: "varp",
            parenOptional: true
          },
          {
            name: "sum",
            parenOptional: true
          },
          {
            name: "sumsq",
            parenOptional: true
          },
          {
            name: "min",
            parenOptional: true
          },
          {
            name: "max",
            parenOptional: true
          },
          {
            name: "mode",
            parenOptional: true
          },
          {
            name: "median",
            parenOptional: true
          },
          {
            name: "earliest",
            parenOptional: true
          },
          {
            name: "first",
            parenOptional: true
          },
          {
            name: "last",
            parenOptional: true
          },
          {
            name: "latest",
            parenOptional: true
          },
          {
            name: "list",
            parenOptional: true
          },
          {
            name: "values",
            parenOptional: true
          },
          {
            name: "range",
            parenOptional: true
          },
          {
            name: "estdc",
            parenOptional: true
          },
          {
            name: "estdc_error",
            parenOptional: true
          },
          {
            name: "earliest_time",
            parenOptional: true
          },
          {
            name: "latest_time",
            parenOptional: true
          },
          {
            name: "rate",
            parenOptional: true
          },
          {
            name: "eval",
            parenOptional: false
          },
          {
            name: "abs",
            parenOptional: false
          },
          {
            name: "avg",
            parenOptional: false
          },
          {
            name: "case",
            parenOptional: false
          },
          {
            name: "ceiling",
            parenOptional: false
          },
          {
            name: "ceil",
            parenOptional: false
          },
          {
            name: "cidrmatch",
            parenOptional: false
          },
          {
            name: "coalesce",
            parenOptional: false
          },
          {
            name: "commands",
            parenOptional: false
          },
          {
            name: "exact",
            parenOptional: false
          },
          {
            name: "exp",
            parenOptional: false
          },
          {
            name: "false",
            parenOptional: false
          },
          {
            name: "floor",
            parenOptional: false
          },
          {
            name: "if",
            parenOptional: false
          },
          {
            name: "ifnull",
            parenOptional: false
          },
          {
            name: "isbool",
            parenOptional: false
          },
          {
            name: "isint",
            parenOptional: false
          },
          {
            name: "isnotnull",
            parenOptional: false
          },
          {
            name: "isnull",
            parenOptional: false
          },
          {
            name: "isnum",
            parenOptional: false
          },
          {
            name: "isstr",
            parenOptional: false
          },
          {
            name: "len",
            parenOptional: false
          },
          {
            name: "like",
            parenOptional: false
          },
          {
            name: "ln",
            parenOptional: false
          },
          {
            name: "log",
            parenOptional: false
          },
          {
            name: "lookup",
            parenOptional: false
          },
          {
            name: "lower",
            parenOptional: false
          },
          {
            name: "match",
            parenOptional: false
          },
          {
            name: "max",
            parenOptional: false
          },
          {
            name: "md5",
            parenOptional: false
          },
          {
            name: "min",
            parenOptional: false
          },
          {
            name: "mvappend",
            parenOptional: false
          },
          {
            name: "mvcount",
            parenOptional: false
          },
          {
            name: "mvdedup",
            parenOptional: false
          },
          {
            name: "mvindex",
            parenOptional: false
          },
          {
            name: "mvfilter",
            parenOptional: false
          },
          {
            name: "mvfind",
            parenOptional: false
          },
          {
            name: "mvjoin",
            parenOptional: false
          },
          {
            name: "mvmap",
            parenOptional: false
          },
          {
            name: "mvrange",
            parenOptional: false
          },
          {
            name: "mvsort",
            parenOptional: false
          },
          {
            name: "mvzip",
            parenOptional: false
          },
          {
            name: "now",
            parenOptional: false
          },
          {
            name: "null",
            parenOptional: false
          },
          {
            name: "nullif",
            parenOptional: false
          },
          {
            name: "pi",
            parenOptional: false
          },
          {
            name: "pow",
            parenOptional: false
          },
          {
            name: "random",
            parenOptional: false
          },
          {
            name: "relative_time",
            parenOptional: false
          },
          {
            name: "replace",
            parenOptional: false
          },
          {
            name: "round",
            parenOptional: false
          },
          {
            name: "searchmatch",
            parenOptional: false
          },
          {
            name: "sha1",
            parenOptional: false
          },
          {
            name: "sha256",
            parenOptional: false
          },
          {
            name: "sha512",
            parenOptional: false
          },
          {
            name: "sigfig",
            parenOptional: false
          },
          {
            name: "spath",
            parenOptional: false
          },
          {
            name: "split",
            parenOptional: false
          },
          {
            name: "sqrt",
            parenOptional: false
          },
          {
            name: "strftime",
            parenOptional: false
          },
          {
            name: "strptime",
            parenOptional: false
          },
          {
            name: "substr",
            parenOptional: false
          },
          {
            name: "sum",
            parenOptional: false
          },
          {
            name: "time",
            parenOptional: false
          },
          {
            name: "tostring",
            parenOptional: false
          },
          {
            name: "trim",
            parenOptional: false
          },
          {
            name: "ltrim",
            parenOptional: false
          },
          {
            name: "rtrim",
            parenOptional: false
          },
          {
            name: "true",
            parenOptional: false
          },
          {
            name: "typeof",
            parenOptional: false
          },
          {
            name: "upper",
            parenOptional: false
          },
          {
            name: "urldecode",
            parenOptional: false
          },
          {
            name: "validate",
            parenOptional: false
          },
          {
            name: "tonumber",
            parenOptional: false
          },
          {
            name: "acos",
            parenOptional: false
          },
          {
            name: "acosh",
            parenOptional: false
          },
          {
            name: "asin",
            parenOptional: false
          },
          {
            name: "asinh",
            parenOptional: false
          },
          {
            name: "atan",
            parenOptional: false
          },
          {
            name: "atan2",
            parenOptional: false
          },
          {
            name: "atanh",
            parenOptional: false
          },
          {
            name: "cos",
            parenOptional: false
          },
          {
            name: "cosh",
            parenOptional: false
          },
          {
            name: "hypot",
            parenOptional: false
          },
          {
            name: "sin",
            parenOptional: false
          },
          {
            name: "sinh",
            parenOptional: false
          },
          {
            name: "tan",
            parenOptional: false
          },
          {
            name: "tanh",
            parenOptional: false
          },
          {
            name: "json_array_to_mv",
            parenOptional: false
          },
          {
            name: "mv_to_json_array",
            parenOptional: false
          },
          {
            name: "json_append",
            parenOptional: false
          },
          {
            name: "json_extend",
            parenOptional: false
          },
          {
            name: "json_extract_exact",
            parenOptional: false
          },
          {
            name: "json_set_exact",
            parenOptional: false
          }
        ],
        keywords: ["LIKE", "AND|OR|XOR", "as", "by"],
        other: ["field", "num", "string", "wc-field", "field-list"],
        list: []
      },
      "surrounding-command": {
        isList: false,
        args: [
          {
            key: "id",
            valueType: "event-id"
          },
          {
            key: "timebefore",
            valueType: "int"
          },
          {
            key: "timeafter",
            valueType: "int"
          },
          {
            key: "searchkeys",
            valueType: "key-list"
          },
          {
            key: "readlevel",
            valueType: "readlevel-int"
          }
        ],
        functions: [],
        keywords: [],
        other: ["int:maxresults", "string"],
        list: []
      },
      "table-command": {
        isList: false,
        args: [],
        functions: [],
        keywords: [],
        other: ["wc-field-list"],
        list: []
      },
      "tagcreate-command": {
        isList: false,
        args: [],
        functions: [],
        keywords: [],
        other: ["tag", "field-and-value-list"],
        list: []
      },
      "tagdelete-command": {
        isList: false,
        args: [],
        functions: [],
        keywords: [],
        other: ["tag", "field-and-value-list"],
        list: []
      },
      "tags-command": {
        isList: false,
        args: [
          {
            key: "outputfield",
            valueType: "field"
          },
          {
            key: "inclname",
            valueType: "bool"
          },
          {
            key: "inclvalue",
            valueType: "bool"
          },
          {
            key: "allowed_tags",
            valueType: "string"
          }
        ],
        functions: [],
        keywords: [],
        other: ["field"],
        list: []
      },
      "tagset-command": {
        isList: false,
        args: [],
        functions: [],
        keywords: [],
        other: ["field-and-value", "tag-list"],
        list: []
      },
      "tail-command": {
        isList: false,
        args: [],
        functions: [],
        keywords: [],
        other: ["int"],
        list: []
      },
      "timechart-command": {
        isList: false,
        args: [
          {
            key: "sep",
            valueType: "string"
          },
          {
            key: "format",
            valueType: "string"
          },
          {
            key: "fixedrange",
            valueType: "bool"
          },
          {
            key: "partial",
            valueType: "bool"
          },
          {
            key: "cont",
            valueType: "bool"
          },
          {
            key: "limit",
            valueType: "chart-limit-opt"
          },
          {
            key: "bins",
            valueType: "int"
          },
          {
            key: "minspan",
            valueType: ""
          },
          {
            key: "span",
            valueType: ""
          },
          {
            key: "start",
            valueType: "num"
          },
          {
            key: "end",
            valueType: "num"
          },
          {
            key: "aligntime",
            valueType: ""
          },
          {
            key: "usenull",
            valueType: "bool"
          },
          {
            key: "useother",
            valueType: "bool"
          },
          {
            key: "nullstr",
            valueType: "string"
          },
          {
            key: "otherstr",
            valueType: "string"
          },
          {
            key: "dedup_splitvals",
            valueType: "bool"
          }
        ],
        functions: [
          {
            name: "c",
            parenOptional: true
          },
          {
            name: "count",
            parenOptional: true
          },
          {
            name: "dc",
            parenOptional: true
          },
          {
            name: "distinct_count",
            parenOptional: true
          },
          {
            name: "mean",
            parenOptional: true
          },
          {
            name: "avg",
            parenOptional: true
          },
          {
            name: "stdev",
            parenOptional: true
          },
          {
            name: "stdevp",
            parenOptional: true
          },
          {
            name: "var",
            parenOptional: true
          },
          {
            name: "varp",
            parenOptional: true
          },
          {
            name: "sum",
            parenOptional: true
          },
          {
            name: "sumsq",
            parenOptional: true
          },
          {
            name: "min",
            parenOptional: true
          },
          {
            name: "max",
            parenOptional: true
          },
          {
            name: "mode",
            parenOptional: true
          },
          {
            name: "median",
            parenOptional: true
          },
          {
            name: "earliest",
            parenOptional: true
          },
          {
            name: "first",
            parenOptional: true
          },
          {
            name: "last",
            parenOptional: true
          },
          {
            name: "latest",
            parenOptional: true
          },
          {
            name: "list",
            parenOptional: true
          },
          {
            name: "values",
            parenOptional: true
          },
          {
            name: "range",
            parenOptional: true
          },
          {
            name: "estdc",
            parenOptional: true
          },
          {
            name: "estdc_error",
            parenOptional: true
          },
          {
            name: "earliest_time",
            parenOptional: true
          },
          {
            name: "latest_time",
            parenOptional: true
          },
          {
            name: "rate",
            parenOptional: true
          },
          {
            name: "eval",
            parenOptional: false
          },
          {
            name: "abs",
            parenOptional: false
          },
          {
            name: "avg",
            parenOptional: false
          },
          {
            name: "case",
            parenOptional: false
          },
          {
            name: "ceiling",
            parenOptional: false
          },
          {
            name: "ceil",
            parenOptional: false
          },
          {
            name: "cidrmatch",
            parenOptional: false
          },
          {
            name: "coalesce",
            parenOptional: false
          },
          {
            name: "commands",
            parenOptional: false
          },
          {
            name: "exact",
            parenOptional: false
          },
          {
            name: "exp",
            parenOptional: false
          },
          {
            name: "false",
            parenOptional: false
          },
          {
            name: "floor",
            parenOptional: false
          },
          {
            name: "if",
            parenOptional: false
          },
          {
            name: "ifnull",
            parenOptional: false
          },
          {
            name: "isbool",
            parenOptional: false
          },
          {
            name: "isint",
            parenOptional: false
          },
          {
            name: "isnotnull",
            parenOptional: false
          },
          {
            name: "isnull",
            parenOptional: false
          },
          {
            name: "isnum",
            parenOptional: false
          },
          {
            name: "isstr",
            parenOptional: false
          },
          {
            name: "len",
            parenOptional: false
          },
          {
            name: "like",
            parenOptional: false
          },
          {
            name: "ln",
            parenOptional: false
          },
          {
            name: "log",
            parenOptional: false
          },
          {
            name: "lookup",
            parenOptional: false
          },
          {
            name: "lower",
            parenOptional: false
          },
          {
            name: "match",
            parenOptional: false
          },
          {
            name: "max",
            parenOptional: false
          },
          {
            name: "md5",
            parenOptional: false
          },
          {
            name: "min",
            parenOptional: false
          },
          {
            name: "mvappend",
            parenOptional: false
          },
          {
            name: "mvcount",
            parenOptional: false
          },
          {
            name: "mvdedup",
            parenOptional: false
          },
          {
            name: "mvindex",
            parenOptional: false
          },
          {
            name: "mvfilter",
            parenOptional: false
          },
          {
            name: "mvfind",
            parenOptional: false
          },
          {
            name: "mvjoin",
            parenOptional: false
          },
          {
            name: "mvmap",
            parenOptional: false
          },
          {
            name: "mvrange",
            parenOptional: false
          },
          {
            name: "mvsort",
            parenOptional: false
          },
          {
            name: "mvzip",
            parenOptional: false
          },
          {
            name: "now",
            parenOptional: false
          },
          {
            name: "null",
            parenOptional: false
          },
          {
            name: "nullif",
            parenOptional: false
          },
          {
            name: "pi",
            parenOptional: false
          },
          {
            name: "pow",
            parenOptional: false
          },
          {
            name: "random",
            parenOptional: false
          },
          {
            name: "relative_time",
            parenOptional: false
          },
          {
            name: "replace",
            parenOptional: false
          },
          {
            name: "round",
            parenOptional: false
          },
          {
            name: "searchmatch",
            parenOptional: false
          },
          {
            name: "sha1",
            parenOptional: false
          },
          {
            name: "sha256",
            parenOptional: false
          },
          {
            name: "sha512",
            parenOptional: false
          },
          {
            name: "sigfig",
            parenOptional: false
          },
          {
            name: "spath",
            parenOptional: false
          },
          {
            name: "split",
            parenOptional: false
          },
          {
            name: "sqrt",
            parenOptional: false
          },
          {
            name: "strftime",
            parenOptional: false
          },
          {
            name: "strptime",
            parenOptional: false
          },
          {
            name: "substr",
            parenOptional: false
          },
          {
            name: "sum",
            parenOptional: false
          },
          {
            name: "time",
            parenOptional: false
          },
          {
            name: "tostring",
            parenOptional: false
          },
          {
            name: "trim",
            parenOptional: false
          },
          {
            name: "ltrim",
            parenOptional: false
          },
          {
            name: "rtrim",
            parenOptional: false
          },
          {
            name: "true",
            parenOptional: false
          },
          {
            name: "typeof",
            parenOptional: false
          },
          {
            name: "upper",
            parenOptional: false
          },
          {
            name: "urldecode",
            parenOptional: false
          },
          {
            name: "validate",
            parenOptional: false
          },
          {
            name: "tonumber",
            parenOptional: false
          },
          {
            name: "acos",
            parenOptional: false
          },
          {
            name: "acosh",
            parenOptional: false
          },
          {
            name: "asin",
            parenOptional: false
          },
          {
            name: "asinh",
            parenOptional: false
          },
          {
            name: "atan",
            parenOptional: false
          },
          {
            name: "atan2",
            parenOptional: false
          },
          {
            name: "atanh",
            parenOptional: false
          },
          {
            name: "cos",
            parenOptional: false
          },
          {
            name: "cosh",
            parenOptional: false
          },
          {
            name: "hypot",
            parenOptional: false
          },
          {
            name: "sin",
            parenOptional: false
          },
          {
            name: "sinh",
            parenOptional: false
          },
          {
            name: "tan",
            parenOptional: false
          },
          {
            name: "tanh",
            parenOptional: false
          },
          {
            name: "json_array_to_mv",
            parenOptional: false
          },
          {
            name: "mv_to_json_array",
            parenOptional: false
          },
          {
            name: "json_append",
            parenOptional: false
          },
          {
            name: "json_extend",
            parenOptional: false
          },
          {
            name: "json_extract_exact",
            parenOptional: false
          },
          {
            name: "json_set_exact",
            parenOptional: false
          },
          {
            name: "c",
            parenOptional: false
          },
          {
            name: "count",
            parenOptional: false
          },
          {
            name: "dc",
            parenOptional: false
          },
          {
            name: "distinct_count",
            parenOptional: false
          },
          {
            name: "mean",
            parenOptional: false
          },
          {
            name: "avg",
            parenOptional: false
          },
          {
            name: "stdev",
            parenOptional: false
          },
          {
            name: "stdevp",
            parenOptional: false
          },
          {
            name: "var",
            parenOptional: false
          },
          {
            name: "varp",
            parenOptional: false
          },
          {
            name: "sum",
            parenOptional: false
          },
          {
            name: "sumsq",
            parenOptional: false
          },
          {
            name: "min",
            parenOptional: false
          },
          {
            name: "max",
            parenOptional: false
          },
          {
            name: "mode",
            parenOptional: false
          },
          {
            name: "median",
            parenOptional: false
          },
          {
            name: "earliest",
            parenOptional: false
          },
          {
            name: "first",
            parenOptional: false
          },
          {
            name: "last",
            parenOptional: false
          },
          {
            name: "latest",
            parenOptional: false
          },
          {
            name: "list",
            parenOptional: false
          },
          {
            name: "values",
            parenOptional: false
          },
          {
            name: "range",
            parenOptional: false
          },
          {
            name: "estdc",
            parenOptional: false
          },
          {
            name: "estdc_error",
            parenOptional: false
          },
          {
            name: "earliest_time",
            parenOptional: false
          },
          {
            name: "latest_time",
            parenOptional: false
          },
          {
            name: "rate",
            parenOptional: false
          },
          {
            name: "per_second",
            parenOptional: false
          },
          {
            name: "per_minute",
            parenOptional: false
          },
          {
            name: "per_hour",
            parenOptional: false
          },
          {
            name: "per_day",
            parenOptional: false
          }
        ],
        keywords: ["LIKE", "AND|OR|XOR", "as", "by", "where"],
        other: ["field", "num", "string", "wc-field", "int", "|"],
        list: []
      },
      "timewrap-command": {
        isList: false,
        args: [
          {
            key: "align",
            valueType: ""
          },
          {
            key: "series",
            valueType: ""
          },
          {
            key: "time_format",
            valueType: "str"
          }
        ],
        functions: [],
        keywords: [],
        other: ["int"],
        list: []
      },
      "tojson-command": {
        isList: false,
        args: [
          {
            key: "fill_null",
            valueType: "bool"
          },
          {
            key: "include_internal",
            valueType: "bool"
          }
        ],
        functions: [
          {
            name: "auto",
            parenOptional: true
          },
          {
            name: "num",
            parenOptional: true
          },
          {
            name: "str",
            parenOptional: true
          },
          {
            name: "bool",
            parenOptional: true
          },
          {
            name: "json",
            parenOptional: true
          },
          {
            name: "none",
            parenOptional: true
          }
        ],
        keywords: [],
        other: ["wc-field", "output_field", "default_type"],
        list: []
      },
      "common-command": {
        isList: false,
        args: [
          {
            key: "showcount",
            valueType: "bool"
          },
          {
            key: "showperc",
            valueType: "bool"
          },
          {
            key: "limit",
            valueType: "int"
          },
          {
            key: "countfield",
            valueType: "string"
          },
          {
            key: "percentfield",
            valueType: "string"
          },
          {
            key: "useother",
            valueType: "bool"
          },
          {
            key: "otherstr",
            valueType: "string"
          }
        ],
        functions: [],
        keywords: ["by"],
        other: ["int", "field-list"],
        list: []
      },
      "top-command": {
        isList: false,
        args: [
          {
            key: "showcount",
            valueType: "bool"
          },
          {
            key: "showperc",
            valueType: "bool"
          },
          {
            key: "limit",
            valueType: "int"
          },
          {
            key: "countfield",
            valueType: "string"
          },
          {
            key: "percentfield",
            valueType: "string"
          },
          {
            key: "useother",
            valueType: "bool"
          },
          {
            key: "otherstr",
            valueType: "string"
          }
        ],
        functions: [],
        keywords: ["by"],
        other: ["int", "field-list"],
        list: []
      },
      "transam-command": {
        isList: false,
        args: [
          {
            key: "name",
            valueType: "transaction-name"
          },
          {
            key: "maxspan",
            valueType: ""
          },
          {
            key: "maxpause",
            valueType: ""
          },
          {
            key: "maxevents",
            valueType: "int"
          },
          {
            key: "startswith",
            valueType: "transam-filter-string"
          },
          {
            key: "endswith",
            valueType: "transam-filter-string"
          },
          {
            key: "connected",
            valueType: "bool"
          },
          {
            key: "unifyends",
            valueType: "bool"
          },
          {
            key: "keeporphans",
            valueType: "bool"
          },
          {
            key: "maxopentxn",
            valueType: "int"
          },
          {
            key: "maxopenevents",
            valueType: "int"
          },
          {
            key: "keepevicted",
            valueType: "bool"
          },
          {
            key: "delim",
            valueType: "string"
          },
          {
            key: "mvlist",
            valueType: ""
          },
          {
            key: "nullstr",
            valueType: "string"
          },
          {
            key: "mvraw",
            valueType: "bool"
          }
        ],
        functions: [],
        keywords: [],
        other: ["field-list"],
        list: []
      },
      "transaction-command": {
        isList: false,
        args: [
          {
            key: "name",
            valueType: "transaction-name"
          },
          {
            key: "maxspan",
            valueType: ""
          },
          {
            key: "maxpause",
            valueType: ""
          },
          {
            key: "maxevents",
            valueType: "int"
          },
          {
            key: "startswith",
            valueType: "transam-filter-string"
          },
          {
            key: "endswith",
            valueType: "transam-filter-string"
          },
          {
            key: "connected",
            valueType: "bool"
          },
          {
            key: "unifyends",
            valueType: "bool"
          },
          {
            key: "keeporphans",
            valueType: "bool"
          },
          {
            key: "maxopentxn",
            valueType: "int"
          },
          {
            key: "maxopenevents",
            valueType: "int"
          },
          {
            key: "keepevicted",
            valueType: "bool"
          },
          {
            key: "delim",
            valueType: "string"
          },
          {
            key: "mvlist",
            valueType: ""
          },
          {
            key: "nullstr",
            valueType: "string"
          },
          {
            key: "mvraw",
            valueType: "bool"
          }
        ],
        functions: [],
        keywords: [],
        other: ["field-list"],
        list: []
      },
      "transpose-command": {
        isList: false,
        args: [
          {
            key: "column_name",
            valueType: "string"
          },
          {
            key: "header_field",
            valueType: "field"
          },
          {
            key: "include_empty",
            valueType: "bool"
          }
        ],
        functions: [],
        keywords: [],
        other: ["int"],
        list: []
      },
      "trendline-command": {
        isList: false,
        args: [],
        functions: [
          {
            name: "sma\\d+",
            parenOptional: false
          },
          {
            name: "ema\\d+",
            parenOptional: false
          },
          {
            name: "wma\\d+",
            parenOptional: false
          }
        ],
        keywords: ["as"],
        other: ["field", "field"],
        list: []
      },
      "tscollect-command": {
        isList: false,
        args: [
          {
            key: "namespace",
            valueType: "string"
          },
          {
            key: "squashcase",
            valueType: "bool"
          },
          {
            key: "keepresults",
            valueType: "bool"
          }
        ],
        functions: [],
        keywords: [],
        other: [],
        list: []
      },
      "tstats-command": {
        isList: false,
        args: [
          {
            key: "prestats",
            valueType: "bool"
          },
          {
            key: "local",
            valueType: "bool"
          },
          {
            key: "append",
            valueType: "bool"
          },
          {
            key: "summariesonly",
            valueType: "bool"
          },
          {
            key: "include_reduced_buckets",
            valueType: "bool"
          },
          {
            key: "allow_old_summaries",
            valueType: "bool"
          },
          {
            key: "chunk_size",
            valueType: "int"
          },
          {
            key: "fillnull_value",
            valueType: "string"
          },
          {
            key: "sid",
            valueType: "string:tscollect-job-id"
          },
          {
            key: "datamodel",
            valueType: ""
          },
          {
            key: "timeformat",
            valueType: "string"
          },
          {
            key: "earliest",
            valueType: "time_modifier"
          },
          {
            key: "_index_earliest",
            valueType: "time_modifier"
          },
          {
            key: "starttime",
            valueType: "string"
          },
          {
            key: "startdaysago",
            valueType: "int"
          },
          {
            key: "startminutesago",
            valueType: "int"
          },
          {
            key: "starthoursago",
            valueType: "int"
          },
          {
            key: "startmonthsago",
            valueType: "int"
          },
          {
            key: "starttimeu",
            valueType: "num"
          },
          {
            key: "latest",
            valueType: "time_modifier"
          },
          {
            key: "_index_latest",
            valueType: "time_modifier"
          },
          {
            key: "endtime",
            valueType: "string"
          },
          {
            key: "enddaysago",
            valueType: "int"
          },
          {
            key: "endminutesago",
            valueType: "int"
          },
          {
            key: "endhoursago",
            valueType: "int"
          },
          {
            key: "endmonthsago",
            valueType: "int"
          },
          {
            key: "endtimeu",
            valueType: "num"
          },
          {
            key: "searchtimespanhours",
            valueType: "int"
          },
          {
            key: "searchtimespanminutes",
            valueType: "int"
          },
          {
            key: "searchtimespandays",
            valueType: "int"
          },
          {
            key: "searchtimespanmonths",
            valueType: "int"
          },
          {
            key: "daysago",
            valueType: "int"
          },
          {
            key: "minutesago",
            valueType: "int"
          },
          {
            key: "hoursago",
            valueType: "int"
          },
          {
            key: "monthsago",
            valueType: "int"
          },
          {
            key: "savedsearch",
            valueType: "string"
          },
          {
            key: "savedsplunk",
            valueType: "string"
          },
          {
            key: "span",
            valueType: "string:timespan"
          }
        ],
        functions: [
          {
            name: "c",
            parenOptional: false
          },
          {
            name: "count",
            parenOptional: false
          },
          {
            name: "dc",
            parenOptional: false
          },
          {
            name: "distinct_count",
            parenOptional: false
          },
          {
            name: "mean",
            parenOptional: false
          },
          {
            name: "avg",
            parenOptional: false
          },
          {
            name: "stdev",
            parenOptional: false
          },
          {
            name: "stdevp",
            parenOptional: false
          },
          {
            name: "var",
            parenOptional: false
          },
          {
            name: "varp",
            parenOptional: false
          },
          {
            name: "sum",
            parenOptional: false
          },
          {
            name: "sumsq",
            parenOptional: false
          },
          {
            name: "min",
            parenOptional: false
          },
          {
            name: "max",
            parenOptional: false
          },
          {
            name: "mode",
            parenOptional: false
          },
          {
            name: "median",
            parenOptional: false
          },
          {
            name: "earliest",
            parenOptional: false
          },
          {
            name: "first",
            parenOptional: false
          },
          {
            name: "last",
            parenOptional: false
          },
          {
            name: "latest",
            parenOptional: false
          },
          {
            name: "list",
            parenOptional: false
          },
          {
            name: "values",
            parenOptional: false
          },
          {
            name: "range",
            parenOptional: false
          },
          {
            name: "estdc",
            parenOptional: false
          },
          {
            name: "estdc_error",
            parenOptional: false
          },
          {
            name: "earliest_time",
            parenOptional: false
          },
          {
            name: "latest_time",
            parenOptional: false
          },
          {
            name: "rate",
            parenOptional: false
          }
        ],
        keywords: ["as", "FROM", "WHERE", "IN", "by|GROUPBY"],
        other: [
          "field",
          "string",
          "string:namespace",
          "boolean-operator-not",
          "term",
          "num",
          "boolean-operator-or",
          "boolean-operator-and",
          "field",
          "field"
        ],
        list: []
      },
      "typeahead-command": {
        isList: false,
        args: [
          {
            key: "prefix",
            valueType: "string"
          },
          {
            key: "count",
            valueType: "int"
          },
          {
            key: "max_time",
            valueType: "int"
          },
          {
            key: "index",
            valueType: "string"
          },
          {
            key: "starttimeu",
            valueType: "num"
          },
          {
            key: "endtimeu",
            valueType: "num"
          },
          {
            key: "collapse",
            valueType: "bool"
          }
        ],
        functions: [],
        keywords: [],
        other: [],
        list: []
      },
      "typelearner-command": {
        isList: false,
        args: [
          {
            key: "maxlen",
            valueType: "int"
          }
        ],
        functions: [],
        keywords: [],
        other: ["field"],
        list: []
      },
      "typer-command": {
        isList: false,
        args: [
          {
            key: "eventtypes",
            valueType: "string"
          },
          {
            key: "maxlen",
            valueType: "int"
          }
        ],
        functions: [],
        keywords: [],
        other: [],
        list: []
      },
      "union-command": {
        isList: false,
        args: [
          {
            key: "extendtimerange",
            valueType: "bool"
          },
          {
            key: "maxtime",
            valueType: "int"
          },
          {
            key: "maxout",
            valueType: "int"
          },
          {
            key: "timeout",
            valueType: "int"
          }
        ],
        functions: [],
        keywords: [],
        other: [],
        list: []
      },
      "uniq-command": {
        isList: false,
        args: [],
        functions: [],
        keywords: [],
        other: [],
        list: []
      },
      "untable-command": {
        isList: false,
        args: [],
        functions: [],
        keywords: [],
        other: ["field"],
        list: []
      },
      "walklex-command": {
        isList: false,
        args: [
          {
            key: "type",
            valueType: "walklex-type"
          },
          {
            key: "prefix",
            valueType: ""
          },
          {
            key: "index",
            valueType: "string"
          },
          {
            key: "splunk_server",
            valueType: "wc-string"
          },
          {
            key: "splunk_server_group",
            valueType: "wc-string"
          }
        ],
        functions: [],
        keywords: [],
        other: [],
        list: []
      },
      "where-command": {
        isList: false,
        args: [],
        functions: [
          {
            name: "abs",
            parenOptional: false
          },
          {
            name: "avg",
            parenOptional: false
          },
          {
            name: "case",
            parenOptional: false
          },
          {
            name: "ceiling",
            parenOptional: false
          },
          {
            name: "ceil",
            parenOptional: false
          },
          {
            name: "cidrmatch",
            parenOptional: false
          },
          {
            name: "coalesce",
            parenOptional: false
          },
          {
            name: "commands",
            parenOptional: false
          },
          {
            name: "exact",
            parenOptional: false
          },
          {
            name: "exp",
            parenOptional: false
          },
          {
            name: "false",
            parenOptional: false
          },
          {
            name: "floor",
            parenOptional: false
          },
          {
            name: "if",
            parenOptional: false
          },
          {
            name: "ifnull",
            parenOptional: false
          },
          {
            name: "isbool",
            parenOptional: false
          },
          {
            name: "isint",
            parenOptional: false
          },
          {
            name: "isnotnull",
            parenOptional: false
          },
          {
            name: "isnull",
            parenOptional: false
          },
          {
            name: "isnum",
            parenOptional: false
          },
          {
            name: "isstr",
            parenOptional: false
          },
          {
            name: "len",
            parenOptional: false
          },
          {
            name: "like",
            parenOptional: false
          },
          {
            name: "ln",
            parenOptional: false
          },
          {
            name: "log",
            parenOptional: false
          },
          {
            name: "lookup",
            parenOptional: false
          },
          {
            name: "lower",
            parenOptional: false
          },
          {
            name: "match",
            parenOptional: false
          },
          {
            name: "max",
            parenOptional: false
          },
          {
            name: "md5",
            parenOptional: false
          },
          {
            name: "min",
            parenOptional: false
          },
          {
            name: "mvappend",
            parenOptional: false
          },
          {
            name: "mvcount",
            parenOptional: false
          },
          {
            name: "mvdedup",
            parenOptional: false
          },
          {
            name: "mvindex",
            parenOptional: false
          },
          {
            name: "mvfilter",
            parenOptional: false
          },
          {
            name: "mvfind",
            parenOptional: false
          },
          {
            name: "mvjoin",
            parenOptional: false
          },
          {
            name: "mvmap",
            parenOptional: false
          },
          {
            name: "mvrange",
            parenOptional: false
          },
          {
            name: "mvsort",
            parenOptional: false
          },
          {
            name: "mvzip",
            parenOptional: false
          },
          {
            name: "now",
            parenOptional: false
          },
          {
            name: "null",
            parenOptional: false
          },
          {
            name: "nullif",
            parenOptional: false
          },
          {
            name: "pi",
            parenOptional: false
          },
          {
            name: "pow",
            parenOptional: false
          },
          {
            name: "random",
            parenOptional: false
          },
          {
            name: "relative_time",
            parenOptional: false
          },
          {
            name: "replace",
            parenOptional: false
          },
          {
            name: "round",
            parenOptional: false
          },
          {
            name: "searchmatch",
            parenOptional: false
          },
          {
            name: "sha1",
            parenOptional: false
          },
          {
            name: "sha256",
            parenOptional: false
          },
          {
            name: "sha512",
            parenOptional: false
          },
          {
            name: "sigfig",
            parenOptional: false
          },
          {
            name: "spath",
            parenOptional: false
          },
          {
            name: "split",
            parenOptional: false
          },
          {
            name: "sqrt",
            parenOptional: false
          },
          {
            name: "strftime",
            parenOptional: false
          },
          {
            name: "strptime",
            parenOptional: false
          },
          {
            name: "substr",
            parenOptional: false
          },
          {
            name: "sum",
            parenOptional: false
          },
          {
            name: "time",
            parenOptional: false
          },
          {
            name: "tostring",
            parenOptional: false
          },
          {
            name: "trim",
            parenOptional: false
          },
          {
            name: "ltrim",
            parenOptional: false
          },
          {
            name: "rtrim",
            parenOptional: false
          },
          {
            name: "true",
            parenOptional: false
          },
          {
            name: "typeof",
            parenOptional: false
          },
          {
            name: "upper",
            parenOptional: false
          },
          {
            name: "urldecode",
            parenOptional: false
          },
          {
            name: "validate",
            parenOptional: false
          },
          {
            name: "tonumber",
            parenOptional: false
          },
          {
            name: "acos",
            parenOptional: false
          },
          {
            name: "acosh",
            parenOptional: false
          },
          {
            name: "asin",
            parenOptional: false
          },
          {
            name: "asinh",
            parenOptional: false
          },
          {
            name: "atan",
            parenOptional: false
          },
          {
            name: "atan2",
            parenOptional: false
          },
          {
            name: "atanh",
            parenOptional: false
          },
          {
            name: "cos",
            parenOptional: false
          },
          {
            name: "cosh",
            parenOptional: false
          },
          {
            name: "hypot",
            parenOptional: false
          },
          {
            name: "sin",
            parenOptional: false
          },
          {
            name: "sinh",
            parenOptional: false
          },
          {
            name: "tan",
            parenOptional: false
          },
          {
            name: "tanh",
            parenOptional: false
          },
          {
            name: "json_array_to_mv",
            parenOptional: false
          },
          {
            name: "mv_to_json_array",
            parenOptional: false
          },
          {
            name: "json_append",
            parenOptional: false
          },
          {
            name: "json_extend",
            parenOptional: false
          },
          {
            name: "json_extract_exact",
            parenOptional: false
          },
          {
            name: "json_set_exact",
            parenOptional: false
          }
        ],
        keywords: ["LIKE", "AND|OR|XOR"],
        other: ["field", "num", "string"],
        list: []
      },
      "x11-command": {
        isList: false,
        args: [],
        functions: [
          {
            name: "mult",
            parenOptional: false
          },
          {
            name: "add",
            parenOptional: false
          }
        ],
        keywords: ["as"],
        other: ["field", "field"],
        list: []
      },
      "xmlkv-command": {
        isList: false,
        args: [
          {
            key: "maxinputs",
            valueType: "int"
          }
        ],
        functions: [],
        keywords: [],
        other: [],
        list: []
      },
      "xmlunescape-command": {
        isList: false,
        args: [
          {
            key: "maxinputs",
            valueType: "int"
          }
        ],
        functions: [],
        keywords: [],
        other: [],
        list: []
      },
      "xpath-command": {
        isList: false,
        args: [
          {
            key: "field",
            valueType: "field"
          },
          {
            key: "outfield",
            valueType: "field"
          },
          {
            key: "default",
            valueType: "string"
          }
        ],
        functions: [],
        keywords: [],
        other: ["string:xpath"],
        list: []
      },
      "maketable-command": {
        isList: false,
        args: [
          {
            key: "grouped",
            valueType: "bool"
          },
          {
            key: "sep",
            valueType: "string"
          },
          {
            key: "format",
            valueType: "string"
          }
        ],
        functions: [],
        keywords: [],
        other: ["field"],
        list: []
      },
      "xyseries-command": {
        isList: false,
        args: [
          {
            key: "grouped",
            valueType: "bool"
          },
          {
            key: "sep",
            valueType: "string"
          },
          {
            key: "format",
            valueType: "string"
          }
        ],
        functions: [],
        keywords: [],
        other: ["field"],
        list: []
      }
    };
    var memoize_exports = {};
    __export2(memoize_exports, {
      default: () => memoize_default
    });
    var defaultImport8 = __toESM2(require_memoize());
    __reExport(memoize_exports, require_memoize());
    var memoize_default = "default" in defaultImport8 ? defaultImport8.default : defaultImport8;
    var deprecated = memoize_default((message) => {
      if (message == null) {
        throw new Error("deprecation message is required");
      }
      console_default.warn(message);
    });
    var deprecated_default = deprecated;
    var DYNAMIC_STRING_SUBSTITUTE = "--dynamicValue--";
    var isDynamicOption = (optionValue) => typeof optionValue === "string" && optionValue.trim().startsWith(">");
    var jsonata_exports = {};
    __export2(jsonata_exports, {
      default: () => jsonata_default
    });
    var defaultImport9 = __toESM2(require_jsonata());
    __reExport(jsonata_exports, require_jsonata());
    var jsonata_default = "default" in defaultImport9 ? defaultImport9.default : defaultImport9;
    var DEFAULT_TOKEN_NAMESPACE = "default";
    var MAX_RECURSION_LEVEL = 10;
    var isNumberLike = (v) => typeof v === "number" && Number.isFinite(v) || typeof v === "string" && !!v && Number.isFinite(Number(v));
    var VALUE_ESCAPERS = {
      search(v) {
        if (Array.isArray(v)) {
          return v.map((val) => JSON.stringify(String(val)));
        }
        return JSON.stringify(String(v));
      },
      url(v) {
        if (Array.isArray(v)) {
          return v.map((val) => encodeURIComponent(String(val)));
        }
        return encodeURIComponent(String(v));
      },
      html(v) {
        if (Array.isArray(v)) {
          return v.map((val) => (0, lodash_exports.escape)(String(val)));
        }
        return (0, lodash_exports.escape)(String(v));
      },
      value(v) {
        if (Array.isArray(v)) {
          return v.map(VALUE_ESCAPERS.value);
        }
        if (isNumberLike(v)) {
          return Number(v);
        }
        return VALUE_ESCAPERS.search(v);
      },
      noEscape(v) {
        return v;
      }
    };
    var DEFAULT_FILTERS = {
      h: VALUE_ESCAPERS.html,
      u: VALUE_ESCAPERS.url,
      s: VALUE_ESCAPERS.search,
      v: VALUE_ESCAPERS.value,
      n: VALUE_ESCAPERS.noEscape
    };
    var DEFAULT_ALLOWABLE_NAME_PATTERN = " \\w.-";
    var TOKEN_NAMESPACE_PREFIX_PATTERN = `([${DEFAULT_ALLOWABLE_NAME_PATTERN}]+:)?`;
    var TOKEN_NAME_CHARS_PATTERN = /((?=[\w.-])[\w .-]*[\w.-])/.source;
    var FLAGS_PATTERN = /((?:\|[a-zA-Z]+)*)?/.source;
    var TOKEN_NAME_CHARS_PATTERN_WITH_FLAGS = TOKEN_NAME_CHARS_PATTERN + FLAGS_PATTERN;
    var TokenNameRegExp = new RegExp(`^${TOKEN_NAME_CHARS_PATTERN}$`);
    var TOKEN_NO_DELIMITERS_PATTERN = TOKEN_NAMESPACE_PREFIX_PATTERN + TOKEN_NAME_CHARS_PATTERN_WITH_FLAGS;
    var TOKEN_PATTERN = /\$/.source + TOKEN_NO_DELIMITERS_PATTERN + /\$/.source;
    var TOKEN_OR_DOLLAR_RE = new RegExp(
      `${TOKEN_PATTERN}|${/\$\$/.source}`,
      "g"
    );
    var TokenRegExp = new RegExp(TOKEN_PATTERN);
    var SINGLE_DOLLAR_REGEX_STR = String.raw`\$`;
    var DOUBLE_DOLLAR_REGEX_STR = String.raw`\$\$`;
    var doubleDollarOrTokenRegex = () => new RegExp(`(${DOUBLE_DOLLAR_REGEX_STR}|${TOKEN_PATTERN})`, "g");
    var adjacentTokenRegex = () => new RegExp(`^${TOKEN_PATTERN}${TOKEN_PATTERN}`, "g");
    var tokenWithTrailingDoubleDollarRegex = () => new RegExp(`^${TOKEN_PATTERN}${DOUBLE_DOLLAR_REGEX_STR}`, "g");
    var tokenWithTrailingDollarRegex = () => new RegExp(`^${TOKEN_PATTERN}${SINGLE_DOLLAR_REGEX_STR}`, "g");
    var getTrimmedTokenNamespace = (tokenNamespace) => tokenNamespace ? tokenNamespace.substring(0, tokenNamespace.length - 1) : DEFAULT_TOKEN_NAMESPACE;
    var replaceTokensWithRegexp = ({
      value,
      tokens,
      tokenFilters = DEFAULT_FILTERS,
      defaultAppliedTokenFilters = [],
      skipDefaultFiltersForFilteredTokens = false
    }) => {
      var _a, _b;
      const match = TokenRegExp.exec(value);
      if (!match) {
        return null;
      }
      const [, tokenNamespace, tokenName, filterChain] = match;
      const ns = getTrimmedTokenNamespace(tokenNamespace);
      const tokenValue = (_b = (_a = tokens[ns]) == null ? void 0 : _a[tokenName]) != null ? _b : null;
      if (tokenValue == null || Array.isArray(tokenValue) && tokenValue.length === 0) {
        return null;
      }
      const filters = filterChain ? new Set(filterChain.substring(1).split("|")) : /* @__PURE__ */ new Set();
      const skipDefaultFilters = filters.has("n") || filters.size && skipDefaultFiltersForFilteredTokens;
      if (!skipDefaultFilters) {
        defaultAppliedTokenFilters.forEach((tokenFilter) => {
          filters.add(tokenFilter);
        });
      }
      const resolvedToken = Array.from(filters).reduce((acc, f) => {
        const filter = tokenFilters[f];
        return typeof filter === "function" ? filter(acc) : acc;
      }, tokenValue);
      return Array.isArray(resolvedToken) ? resolvedToken.join(",") : resolvedToken;
    };
    var replaceBetween = (original, start, end, insertion) => `${original.substring(0, start)}${insertion}${original.substring(end)}`;
    var extractTokenMatches = (value) => {
      const doubleDollarOrTokenRE = doubleDollarOrTokenRegex();
      const matches = [];
      let currentMatch = doubleDollarOrTokenRE.exec(value);
      while (currentMatch !== null) {
        const fullMatch = currentMatch[0];
        const start = currentMatch.index;
        const end = start + fullMatch.length;
        const match = { match: fullMatch, start, end };
        if (fullMatch === "$$") {
          matches.push(match);
        } else {
          const tail = value.slice(start);
          if (adjacentTokenRegex().exec(tail) !== null || tokenWithTrailingDoubleDollarRegex().exec(tail) !== null) {
            matches.push(match);
          } else if (tokenWithTrailingDollarRegex().exec(tail) !== null) {
            doubleDollarOrTokenRE.lastIndex = start + 1;
          } else {
            matches.push(match);
          }
        }
        currentMatch = doubleDollarOrTokenRE.exec(value);
      }
      return matches;
    };
    var replaceTokensWithMetadata = ({
      value,
      tokens = {},
      tokenFilters = DEFAULT_FILTERS,
      defaultAppliedTokenFilters = [],
      skipDefaultFiltersForFilteredTokens = false
    }) => {
      const matches = extractTokenMatches(value);
      const resolvedTokens = /* @__PURE__ */ new Set();
      const missedTokens = /* @__PURE__ */ new Set();
      let updatedValue = value;
      for (let i = matches.length - 1; i >= 0; i -= 1) {
        const { match, start, end } = matches[i];
        if (match === "$$") {
          updatedValue = replaceBetween(updatedValue, start, end, "$");
        } else {
          const resolvedToken = replaceTokensWithRegexp({
            value: match,
            tokens,
            tokenFilters,
            defaultAppliedTokenFilters,
            skipDefaultFiltersForFilteredTokens
          });
          if (resolvedToken == null) {
            missedTokens.add(match);
          } else {
            updatedValue = replaceBetween(
              updatedValue,
              start,
              end,
              resolvedToken
            );
            resolvedTokens.add(match);
          }
        }
      }
      return {
        value: updatedValue,
        resolvedTokens: Array.from(resolvedTokens).reverse(),
        missedTokens: Array.from(missedTokens).reverse(),
        matches: matches.filter((m) => m.match !== "$$")
      };
    };
    var isObjectArgument = (args) => {
      return args.length === 1 && typeof args[0] === "object" && !!args[0];
    };
    var parseReplaceTokensArgs = (args) => {
      if (isObjectArgument(args)) {
        return args[0];
      }
      deprecated_default(
        "Legacy arguments for function replaceTokens has been deprecated, use a single object argument."
      );
      return {
        value: args[0],
        tokens: args[1],
        tokenFilters: args[2],
        defaultAppliedTokenFilters: args[3]
      };
    };
    function replaceTokens(...args) {
      const {
        value,
        tokens,
        tokenFilters = DEFAULT_FILTERS,
        defaultAppliedTokenFilters = [],
        skipDefaultFiltersForFilteredTokens = false
      } = parseReplaceTokensArgs(args);
      if (!value) {
        return value;
      }
      return replaceTokensWithMetadata({
        value,
        tokens,
        tokenFilters,
        defaultAppliedTokenFilters,
        skipDefaultFiltersForFilteredTokens
      }).value;
    }
    var isObjectArgument2 = (args) => {
      return args.length === 1 && typeof args[0] === "object" && !!args[0];
    };
    var parseReplaceTokensForObjectArgs = (args) => {
      if (isObjectArgument2(args)) {
        return args[0];
      }
      deprecated_default(
        "Legacy arguments for function replaceTokensForObject has been deprecated, use a single object argument."
      );
      return {
        value: args[0],
        tokens: args[1],
        tokenFilters: args[2],
        recursionLevel: args[3],
        defaultAppliedTokenFilters: args[4]
      };
    };
    function replaceTokensForObject(...args) {
      const {
        value,
        tokens,
        tokenFilters = DEFAULT_FILTERS,
        recursionLevel = 0,
        defaultAppliedTokenFilters = [],
        skipDefaultFiltersForFilteredTokens = false
      } = parseReplaceTokensForObjectArgs(args);
      if (value == null) {
        return value;
      }
      if (typeof value === "string") {
        return replaceTokens({
          value,
          tokens,
          tokenFilters,
          defaultAppliedTokenFilters,
          skipDefaultFiltersForFilteredTokens
        });
      }
      if ((0, lodash_exports.isPlainObject)(value) && recursionLevel <= MAX_RECURSION_LEVEL) {
        return (0, lodash_exports.mapValues)(
          value,
          (v) => replaceTokensForObject({
            value: v,
            tokens,
            tokenFilters,
            recursionLevel: recursionLevel + 1,
            defaultAppliedTokenFilters,
            skipDefaultFiltersForFilteredTokens
          })
        );
      }
      if (Array.isArray(value) && recursionLevel <= MAX_RECURSION_LEVEL) {
        return value.map(
          (v) => replaceTokensForObject({
            value: v,
            tokens,
            tokenFilters,
            recursionLevel: recursionLevel + 1,
            defaultAppliedTokenFilters,
            skipDefaultFiltersForFilteredTokens
          })
        );
      }
      return value;
    }
    var isObjectArgument3 = (args) => {
      return args.length === 1 && typeof args[0] === "object" && !!args[0];
    };
    var parseReplaceTokensForObjectWithMetadataArgs = (args) => {
      if (isObjectArgument3(args)) {
        return args[0];
      }
      deprecated_default(
        "Legacy arguments for function replaceTokensForObjectWithMetadata has been deprecated, use a single object argument."
      );
      return {
        value: args[0],
        tokens: args[1],
        tokenFilters: args[2],
        defaultAppliedTokenFilters: args[3]
      };
    };
    function replaceTokensForObjectWithMetadata(...args) {
      const {
        value,
        tokens,
        tokenFilters = DEFAULT_FILTERS,
        defaultAppliedTokenFilters = [],
        skipDefaultFiltersForFilteredTokens = false
      } = parseReplaceTokensForObjectWithMetadataArgs(args);
      const missedTokens = /* @__PURE__ */ new Set();
      const resolvedTokens = /* @__PURE__ */ new Set();
      const tokenObjectRecurser = (val, recursionLevel = 0) => {
        if (val === null || typeof val === "undefined") {
          return val;
        }
        if (typeof val === "string") {
          const result = replaceTokensWithMetadata({
            value: val,
            tokens,
            tokenFilters,
            defaultAppliedTokenFilters,
            skipDefaultFiltersForFilteredTokens
          });
          result.missedTokens.forEach((token) => {
            missedTokens.add(token);
          });
          result.resolvedTokens.forEach((token) => {
            resolvedTokens.add(token);
          });
          return result.value;
        }
        if ((0, lodash_exports.isPlainObject)(val) && recursionLevel <= MAX_RECURSION_LEVEL) {
          return (0, lodash_exports.mapValues)(
            val,
            (v) => tokenObjectRecurser(v, recursionLevel + 1)
          );
        }
        if (Array.isArray(val) && recursionLevel <= MAX_RECURSION_LEVEL) {
          return (0, lodash_exports.map)(
            val,
            (v) => tokenObjectRecurser(v, recursionLevel + 1)
          );
        }
        return val;
      };
      const replacedObj = tokenObjectRecurser(value);
      return {
        value: replacedObj,
        missedTokens: Array.from(missedTokens),
        resolvedTokens: Array.from(resolvedTokens)
      };
    }
    var sha256_exports = {};
    __export2(sha256_exports, {
      default: () => sha256_default
    });
    var defaultImport10 = __toESM2(require_sha2562());
    __reExport(sha256_exports, require_sha2562());
    var sha256_default = "default" in defaultImport10 ? defaultImport10.default : defaultImport10;
    var hashString = (str, prefix = "") => `${prefix}${sha256_default(str)}`;
    var hashString_default = hashString;
    var hasTokens = (value) => {
      if (typeof value !== "string") {
        throw new TypeError("hasTokens requires a string");
      }
      return replaceTokensWithMetadata({ value }).missedTokens.length > 0;
    };
    var hasTokensInObject = (obj, recursionLevel = 0) => {
      if (obj == null) {
        return false;
      }
      if (typeof obj === "string") {
        return hasTokens(obj);
      }
      if ((Array.isArray(obj) || (0, lodash_exports.isPlainObject)(obj)) && recursionLevel <= MAX_RECURSION_LEVEL) {
        return (0, lodash_exports.some)(
          obj,
          (v) => hasTokensInObject(v, recursionLevel + 1)
        );
      }
      return false;
    };
    var isValidTokenNamespace = (tokenNamespace) => {
      if (typeof tokenNamespace !== "string") {
        return false;
      }
      const namespaceWithColon = `${tokenNamespace}:`;
      const matches = new RegExp(TOKEN_NAMESPACE_PREFIX_PATTERN).exec(
        namespaceWithColon
      );
      if (!matches) {
        return false;
      }
      return matches[0] === namespaceWithColon;
    };
    var isValidTokenValue = (tokenValue) => typeof tokenValue === "string" && !!tokenValue || Array.isArray(tokenValue) && tokenValue.length > 0;
    var r = (regexp) => {
      const { source, global: global2, multiline, ignoreCase } = regexp;
      return new RegExp(
        source,
        `${global2 ? "g" : ""}${multiline ? "m" : ""}${ignoreCase ? "i" : ""}`
      );
    };
    var startsWithToken = (str) => typeof str === "string" && new RegExp(`^(?:${TOKEN_OR_DOLLAR_RE.source})`).test(str);
    var replaceTokensWithHash = (value) => {
      if (value == null) {
        return value;
      }
      return value.replace(
        r(TOKEN_OR_DOLLAR_RE),
        (match, tokenNamespace, tokenName, filterChain) => {
          let namespace;
          if (tokenNamespace) {
            namespace = tokenNamespace.substring(
              0,
              tokenNamespace.length - 1
            );
          }
          let v = match;
          if (namespace) {
            v = v.replace(namespace, hashString_default(namespace, "namespace_"));
          }
          if (tokenName) {
            v = v.replace(tokenName, hashString_default(tokenName, "token_"));
          }
          if (filterChain) {
            v = v.replace(filterChain, hashString_default(filterChain, "|filter_"));
          }
          return v;
        }
      );
    };
    var safeReplaceTokensForObject = (obj, tokens, denyList) => {
      const rawObject = {};
      denyList.forEach((key) => {
        rawObject[key] = (0, lodash_exports.get)(obj, key);
      });
      const tokenizedObj = replaceTokensForObject({ value: obj, tokens });
      denyList.forEach((key) => {
        if (rawObject[key]) {
          (0, lodash_exports.set)(tokenizedObj, key, rawObject[key]);
        }
      });
      return tokenizedObj;
    };
    var splitToken = (token) => {
      var _a, _b, _c, _d;
      const [, namespace, name, filters] = (_a = TokenRegExp.exec(token)) != null ? _a : [];
      return {
        namespace: (_b = namespace == null ? void 0 : namespace.slice(0, -1)) != null ? _b : DEFAULT_TOKEN_NAMESPACE,
        name: name != null ? name : "",
        filters: (_d = (_c = filters == null ? void 0 : filters.slice(1)) == null ? void 0 : _c.split("|")) != null ? _d : []
      };
    };
    var extractTokens = (value) => {
      if (!value) {
        return [];
      }
      return replaceTokensWithMetadata({
        value
      }).missedTokens.map((token) => splitToken(token));
    };
    var extractTokensFromNamespaceNameArray = (value) => {
      return value.map((token) => extractTokens(`$${token}$`)[0]);
    };
    var extractTokensFromObject = (value, recursionLevel = 0) => {
      if ((0, lodash_exports.isEmpty)(value)) {
        return [];
      }
      if (typeof value === "string") {
        return extractTokens(value);
      }
      if ((0, lodash_exports.isPlainObject)(value) && recursionLevel <= MAX_RECURSION_LEVEL) {
        return (0, lodash_exports.uniqWith)(
          (0, lodash_exports.flattenDeep)(
            (0, lodash_exports.map)(
              (0, lodash_exports.values)(value),
              (v) => extractTokensFromObject(v, recursionLevel + 1)
            )
          ),
          lodash_exports.isEqual
        );
      }
      if (Array.isArray(value) && recursionLevel <= MAX_RECURSION_LEVEL) {
        return (0, lodash_exports.uniqWith)(
          (0, lodash_exports.flattenDeep)(
            (0, lodash_exports.map)(
              value,
              (v) => extractTokensFromObject(v, recursionLevel + 1)
            )
          ),
          lodash_exports.isEqual
        );
      }
      return [];
    };
    var mapTokensToURL = ({
      search: initSearch = "?",
      tokens
    }) => {
      const initSearchParams = new URLSearchParams(initSearch);
      const updatedSearchParams = new URLSearchParams(initSearch);
      const updateParam = (tokenName) => {
        const tokenValue = tokens[DEFAULT_TOKEN_NAMESPACE][tokenName];
        const key = `form.${tokenName}`;
        if (Array.isArray(tokenValue)) {
          tokenValue.forEach((tokenArrayValue) => {
            if (isValidTokenValue(tokenArrayValue)) {
              updatedSearchParams.append(key, `${tokenArrayValue}`);
            }
          });
        } else if (isValidTokenValue(tokenValue)) {
          updatedSearchParams.set(key, tokenValue);
        }
      };
      initSearchParams.forEach((_value, key) => {
        if (key.startsWith("form.")) {
          const tokenName = key.substring(5);
          updatedSearchParams.delete(key);
          if (tokenName in tokens.default) {
            updateParam(tokenName);
          }
        }
      });
      Object.keys(tokens.default).forEach((key) => {
        if (!updatedSearchParams.has(`form.${key}`)) {
          updateParam(key);
        }
      });
      return updatedSearchParams.toString();
    };
    var mapURLToTokens = ({
      search
    }) => {
      const urlSearchParams = new URLSearchParams(search);
      const tokens = {};
      urlSearchParams.forEach((value, key) => {
        if (!key.startsWith("form.") || !isValidTokenValue(value)) {
          return;
        }
        const tokenName = key.slice(5);
        if (tokens[tokenName]) {
          if (typeof tokens[tokenName] === "string") {
            tokens[tokenName] = [tokens[tokenName]];
          }
          tokens[tokenName].push(value);
        } else {
          tokens[tokenName] = value;
        }
      });
      return { default: tokens };
    };
    var getProtectedNameError = ({
      name,
      errorMessages
    }) => {
      if (TokenRegExp.test(name)) {
        return errorMessages.containsToken;
      }
      const matches = new RegExp(TOKEN_NAME_CHARS_PATTERN).exec(name);
      const nameLength = name.length;
      if (!matches || nameLength === 0) {
        return errorMessages.invalidFirstLastChar;
      }
      const [matchString] = matches;
      if (matchString === name) {
        return void 0;
      }
      const matchLength = matchString.length;
      if (matchLength >= 1 && // if the match is just 1 char off
      matchLength === nameLength - 1 && // and that 1 character is just the beginning or ending
      // it's likely the regex match failed due to this reason
      (!matchString.startsWith(name.charAt(0)) || !matchString.endsWith(name.charAt(nameLength - 1)))) {
        return errorMessages.invalidFirstLastChar;
      }
      return errorMessages.invalidChars;
    };
    var CANNOT_CONTAIN_TOKEN_MSG = (0, i18n_exports._)("Token names cannot contain tokens.");
    var INVALID_FIRST_LAST_CHAR_MSG = (0, i18n_exports._)(
      "Token names must start and end with an alphanumeric character, dash, underscore, or period."
    );
    var INVALID_CHAR_MSG = (0, i18n_exports._)(
      "Token names can only include letters, numbers, spaces, dashes, underscores, and periods."
    );
    var getTokenNameError = (tokenName) => {
      const err = getProtectedNameError({
        name: tokenName,
        errorMessages: {
          containsToken: CANNOT_CONTAIN_TOKEN_MSG,
          invalidChars: INVALID_CHAR_MSG,
          invalidFirstLastChar: INVALID_FIRST_LAST_CHAR_MSG
        }
      });
      return err != null ? err : null;
    };
    var RejectedEvalExpression = (0, i18n_exports._)(
      "Potentially unsafe code detected; the expression was not evaluated."
    );
    var UnknownErrorMessage = (0, i18n_exports._)("An unknown error has occurred.");
    var CONDITION_TOKEN_NAMESPACE = "condition";
    var EVAL_TOKEN_NAMESPACE = "eval";
    var nestedNodeProps = [
      "arguments",
      "condition",
      "then",
      "else",
      "lhs",
      "rhs",
      "expressions",
      "body"
    ];
    var unsafeNodeNames = ["eval"];
    var isUnsafeVar = (tree) => {
      if (!tree) {
        return false;
      }
      if (Array.isArray(tree)) {
        return tree.some(
          (t) => t.type === "variable" && typeof t.value === "string" && unsafeNodeNames.includes(t.value)
        );
      }
      return tree.type === "variable" && typeof tree.value === "string" && unsafeNodeNames.includes(tree.value);
    };
    var hasUnsafeNode = (tree) => {
      var _a;
      if (!tree) {
        return false;
      }
      if (tree.type === "function" && typeof ((_a = tree.procedure) == null ? void 0 : _a.value) === "string" && unsafeNodeNames.includes(tree.procedure.value)) {
        return true;
      }
      if (tree.type === "bind" && isUnsafeVar(tree.rhs)) {
        return true;
      }
      if (tree.type === "apply" && (isUnsafeVar(tree.lhs) || isUnsafeVar(tree.rhs))) {
        return true;
      }
      if (tree.type === "function" && isUnsafeVar(tree.arguments)) {
        return true;
      }
      return nestedNodeProps.some((prop) => {
        if (Array.isArray(tree[prop])) {
          return tree[prop].some(hasUnsafeNode);
        }
        return !!tree[prop] && hasUnsafeNode(tree[prop]);
      });
    };
    var createIsSetMethod = (tokens) => (input) => {
      const extractedTokens = extractTokens(`$${input}$`);
      if (extractedTokens.length !== 1) {
        const err = {
          name: "isSetError",
          message: (0, i18n_exports._)("isSet() needs to take as argument exactly 1 token."),
          position: 0,
          code: "",
          token: ""
        };
        throw err;
      }
      const token = extractedTokens[0];
      const isTokenSet = token.namespace in tokens && token.name in tokens[token.namespace];
      if (!isTokenSet) {
        return false;
      }
      const tokenValue = tokens[token.namespace][token.name];
      return typeof tokenValue !== "undefined" && tokenValue !== null;
    };
    var isSetFnRegexSource = `\\$?isSet\\(\\$(${TOKEN_NO_DELIMITERS_PATTERN})\\$\\)`;
    var isJsonataError = (obj) => {
      const error = obj;
      return typeof error === "object" && error !== null && typeof error.message === "string" && typeof error.code === "string" && typeof error.position === "number" && typeof error.token === "string";
    };
    var formatIsSetCall = (0, lodash_exports.memoize)(
      (expression) => expression.replace(new RegExp(isSetFnRegexSource, "g"), '$$isSet("$1")').replace(new RegExp('(?<!\\$)(isSet\\("[^"]+"\\))'), "$$$1").replace(/!\$isSet\(([^)]+\))/g, "$$not($$isSet($1)")
    );
    var alphabet = "useandom26T198340PX75pxJACKVERYMINDBUSHWOLFGQZbfghjklqvwyzrict";
    var uniqueId = (size = 8) => {
      let id = "";
      let i = size;
      while (i--) {
        id += alphabet[Math.random() * 62 | 0];
      }
      return id;
    };
    var generateUniqueId = (prefix) => `${prefix}_${uniqueId()}`;
    var generateId = (prefix, searchFn = () => false) => {
      let nextId = generateUniqueId(prefix);
      while (searchFn(nextId)) {
        nextId = generateUniqueId(prefix);
      }
      return nextId;
    };
    var generateCompliantVariable = (expr) => {
      const searchFn = (nextId) => expr.includes(`$${nextId}`);
      const compliantVariableName = generateId("var", searchFn);
      return `$${compliantVariableName}`;
    };
    var sanitizeMissedTokens = ({
      expression,
      missedTokens
    }) => {
      if (!missedTokens.length) {
        return expression;
      }
      let sanitizedExpression = expression;
      const tokenNameReplacements = /* @__PURE__ */ new Map();
      missedTokens.forEach((missedToken) => {
        var _a;
        const { namespace, name } = splitToken(missedToken);
        const normalizedMissedToken = `${namespace}:${name}`;
        const replacementTokenName = (_a = tokenNameReplacements.get(normalizedMissedToken)) != null ? _a : generateCompliantVariable(sanitizedExpression);
        tokenNameReplacements.set(normalizedMissedToken, replacementTokenName);
        sanitizedExpression = sanitizedExpression.replaceAll(
          missedToken,
          replacementTokenName
        );
      });
      return sanitizedExpression;
    };
    var EmptyEvalContext = /* @__PURE__ */ Object.create(null);
    var noopJsonataEval = () => null;
    var asyncJsonataEvaluation = (_0) => __async(void 0, [_0], function* ({
      expression,
      tokens,
      context = EmptyEvalContext
    }) {
      try {
        const { value: formattedExpression, missedTokens } = replaceTokensForObjectWithMetadata({
          value: formatIsSetCall(expression),
          tokens,
          defaultAppliedTokenFilters: ["v"],
          skipDefaultFiltersForFilteredTokens: true
        });
        const sanitizedExpression = sanitizeMissedTokens({
          expression: formattedExpression,
          missedTokens
        });
        const jsonataEval = jsonata_default(sanitizedExpression);
        jsonataEval.registerFunction("isSet", createIsSetMethod(tokens));
        jsonataEval.registerFunction("eval", noopJsonataEval);
        const ast = jsonataEval.ast();
        if (hasUnsafeNode(ast)) {
          return { success: false, reason: RejectedEvalExpression };
        }
        const value = yield jsonataEval.evaluate(context);
        return { success: true, value };
      } catch (error) {
        if (isJsonataError(error)) {
          return {
            success: false,
            reason: error.message,
            code: error.code,
            position: error.position
          };
        }
        return { success: false, reason: UnknownErrorMessage };
      }
    });
    var AbortedPromiseErrorMessage = (0, i18n_exports._)("Expression evaluations canceled.");
    var AbortedPromiseError = () => new Error(AbortedPromiseErrorMessage);
    var config_exports = {};
    __export2(config_exports, {
      default: () => config_default
    });
    var defaultImport11 = __toESM2(require_config());
    __reExport(config_exports, require_config());
    var config_default = "default" in defaultImport11 ? defaultImport11.default : defaultImport11;
    var DAGCycleErrorMessage = (0, i18n_exports._)(
      "Cycle in evaluation order for %(expressionType)s comprised of node(s) [%(nodeList)s]. Cyclic expressions cannot be evaluated and are ignored."
    );
    var DAGCycleError = ({
      expressionType,
      nodesInCycle
    }) => {
      const listFormatter = new Intl.ListFormat(config_exports.locale, { type: "unit" });
      const nodeList = listFormatter.format(nodesInCycle);
      return new Error(
        (0, format_exports.sprintf)(DAGCycleErrorMessage, { expressionType, nodeList })
      );
    };
    var EvaluationChainError = class extends Error {
      constructor(message, {
        expressionId,
        partialResults
      }) {
        super(message);
        this.expressionId = expressionId;
        this.partialResults = deepFreeze_default(partialResults);
      }
    };
    var ExpressionDoesNotExistErrorMessage = (0, i18n_exports._)(
      'The %(expressionType)s "%(expressionId)s" does not exist in this dashboard.'
    );
    var ExpressionDoesNotExistError = (expressionId, expressionType, partialResults) => new EvaluationChainError(
      (0, format_exports.sprintf)(ExpressionDoesNotExistErrorMessage, {
        expressionId,
        expressionType
      }),
      {
        expressionId,
        partialResults
      }
    );
    var ErrorWithCodeAndPosition = (0, i18n_exports._)(
      "[%(errorCode)s] %(errorReason)s at position %(errorPosition)d"
    );
    var ErrorWithCode = (0, i18n_exports._)("[%(errorCode)s] %(errorReason)s");
    var ErrorWithPosition = (0, i18n_exports._)("%(errorReason)s at position %(errorPosition)d");
    var formatJSONataErrorMessage = ({
      errorCode,
      errorPosition,
      errorReason
    }) => {
      if (errorCode && errorPosition) {
        return (0, format_exports.sprintf)(ErrorWithCodeAndPosition, {
          errorCode,
          errorReason,
          errorPosition
        });
      }
      if (errorCode) {
        return (0, format_exports.sprintf)(ErrorWithCode, {
          errorCode,
          errorReason
        });
      }
      if (errorPosition) {
        return (0, format_exports.sprintf)(ErrorWithPosition, {
          errorReason,
          errorPosition
        });
      }
      return errorReason;
    };
    var FormattedJSONataError = ({
      errorCode,
      errorPosition,
      errorReason,
      expressionId,
      partialResults
    }) => {
      return new EvaluationChainError(
        formatJSONataErrorMessage({ errorCode, errorPosition, errorReason }),
        { expressionId, partialResults }
      );
    };
    var createExpressionDependencyGraph = ({
      expressions,
      targetNamespace
    }) => {
      const entries = Object.entries(expressions);
      const graph = {};
      const nameMap = Object.fromEntries(
        entries.map(([id, { name }]) => [name, id])
      );
      entries.forEach(([id, { value }]) => {
        var _a;
        (_a = graph[id]) != null ? _a : graph[id] = [];
        const tokens = extractTokens(formatIsSetCall(value));
        tokens.forEach(({ namespace, name }) => {
          if (namespace !== targetNamespace) {
            return;
          }
          const depId = nameMap[name];
          if (!depId) {
            return;
          }
          graph[id].push(depId);
        });
      });
      return graph;
    };
    var createConditionsDependencyGraph = ({ expressions }) => createExpressionDependencyGraph({
      expressions,
      targetNamespace: CONDITION_TOKEN_NAMESPACE
    });
    var createTokenEvalDependencyGraph = ({ expressions }) => createExpressionDependencyGraph({
      expressions,
      targetNamespace: EVAL_TOKEN_NAMESPACE
    });
    var createUndirectedAdjacencyList = ({
      graph
    }) => {
      const undirectedGraph = {};
      const visitedNeighbors = {};
      Object.entries(graph).forEach(([node, neighbors]) => {
        var _a, _b;
        (_a = undirectedGraph[node]) != null ? _a : undirectedGraph[node] = [];
        (_b = visitedNeighbors[node]) != null ? _b : visitedNeighbors[node] = /* @__PURE__ */ new Set();
        neighbors.forEach((neighbor) => {
          var _a2, _b2;
          (_a2 = undirectedGraph[neighbor]) != null ? _a2 : undirectedGraph[neighbor] = [];
          (_b2 = visitedNeighbors[neighbor]) != null ? _b2 : visitedNeighbors[neighbor] = /* @__PURE__ */ new Set();
          if (!visitedNeighbors[node].has(neighbor)) {
            undirectedGraph[node].push(neighbor);
            visitedNeighbors[node].add(neighbor);
          }
          if (!visitedNeighbors[neighbor].has(node)) {
            undirectedGraph[neighbor].push(node);
            visitedNeighbors[neighbor].add(node);
          }
        });
      });
      return undirectedGraph;
    };
    var splitSubgraphs = ({ graph }) => {
      const visited = /* @__PURE__ */ new Set();
      const subgraphs = [];
      const undirectedGraph = createUndirectedAdjacencyList({ graph });
      const visit = (node, subgraphNodes) => {
        var _a;
        visited.add(node);
        subgraphNodes.push(node);
        (_a = undirectedGraph[node]) == null ? void 0 : _a.forEach((neighbor) => {
          if (visited.has(neighbor)) {
            return;
          }
          visit(neighbor, subgraphNodes);
        });
      };
      Object.keys(graph).forEach((node) => {
        if (visited.has(node)) {
          return;
        }
        const subgraphNodes = [];
        visit(node, subgraphNodes);
        const subgraph = {};
        let subgraphHasContent = false;
        subgraphNodes.forEach((subgraphNode) => {
          if (subgraphNode in graph) {
            subgraph[subgraphNode] = graph[subgraphNode];
            subgraphHasContent = true;
          }
        });
        if (subgraphHasContent) {
          subgraphs.push(subgraph);
        }
      });
      return subgraphs;
    };
    var detectCycle = ({ graph }) => {
      const visited = /* @__PURE__ */ new Set();
      const stack = /* @__PURE__ */ new Set();
      const path = [];
      const visit = (node) => {
        var _a;
        if (stack.has(node)) {
          return path.slice(path.indexOf(node));
        }
        if (visited.has(node)) {
          return void 0;
        }
        visited.add(node);
        stack.add(node);
        path.push(node);
        let cycleFromNode;
        (_a = graph[node]) == null ? void 0 : _a.some((neighbor) => {
          cycleFromNode = visit(neighbor);
          return !!cycleFromNode;
        });
        if (cycleFromNode) {
          return cycleFromNode;
        }
        stack.delete(node);
        path.pop();
        return void 0;
      };
      let firstCycle;
      Object.keys(graph).some((node) => {
        if (visited.has(node)) {
          return false;
        }
        firstCycle = visit(node);
        return !!firstCycle;
      });
      return firstCycle;
    };
    var countIncomingEdges = ({ graph }) => {
      let nodeCount = 0;
      const incomingEdges = {};
      Object.values(graph).forEach((neighbors) => {
        nodeCount += 1;
        neighbors.forEach((neighbor) => {
          var _a;
          incomingEdges[neighbor] = ((_a = incomingEdges[neighbor]) != null ? _a : 0) + 1;
        });
      });
      return { nodeCount, incomingEdges };
    };
    var findValidStartNodes = ({
      graph,
      incomingEdges
    }) => {
      return Object.keys(graph).filter((node) => !incomingEdges[node]);
    };
    var topologicalSort = ({
      graph,
      handleCycle
    }) => {
      var _a;
      const { nodeCount, incomingEdges } = countIncomingEdges({ graph });
      const validStartNodes = findValidStartNodes({ graph, incomingEdges });
      const topologicalOrder = [];
      while (validStartNodes.length > 0) {
        const node = validStartNodes.shift();
        if (!node) {
          return [];
        }
        topologicalOrder.unshift(node);
        (_a = graph[node]) == null ? void 0 : _a.forEach((neighbor) => {
          var _a2;
          incomingEdges[neighbor] = ((_a2 = incomingEdges[neighbor]) != null ? _a2 : 0) - 1;
          if (!incomingEdges[neighbor] && neighbor in graph) {
            validStartNodes.push(neighbor);
          }
        });
      }
      if (topologicalOrder.length !== nodeCount && typeof handleCycle === "function") {
        const nodesInCycle = detectCycle({ graph });
        if (nodesInCycle == null ? void 0 : nodesInCycle.length) {
          handleCycle(nodesInCycle);
        }
      }
      return topologicalOrder;
    };
    var filterByIds = ({
      expressions,
      expressionIds
    }) => {
      if (Array.isArray(expressionIds)) {
        return Object.fromEntries(
          Object.entries(expressions).filter(
            ([id]) => expressionIds.includes(id)
          )
        );
      }
      return expressions;
    };
    var getEvalOrders = ({
      expressions: allExpressions,
      expressionIds,
      createDAG,
      handleCycle
    }) => {
      const expressions = filterByIds({
        expressions: allExpressions,
        expressionIds
      });
      const allConditionsGraph = createDAG({ expressions });
      const conditionChains = splitSubgraphs({ graph: allConditionsGraph });
      return conditionChains.map((graph) => topologicalSort({ graph, handleCycle })).filter((nodeList) => nodeList.length > 0);
    };
    var injectInterimResultTokens = ({
      expressions,
      results,
      tokens,
      namespace,
      castResult
    }) => {
      var _a;
      return __spreadProps(__spreadValues({}, tokens != null ? tokens : {}), {
        [namespace]: __spreadValues(__spreadValues({}, (_a = tokens == null ? void 0 : tokens[namespace]) != null ? _a : {}), Object.fromEntries(
          Object.entries(results).map(([expressionId, value]) => [
            expressions[expressionId].name,
            castResult(value)
          ])
        ))
      });
    };
    var NOPCast = (result) => result;
    var processPromiseChain = ({
      expressions,
      tokens,
      chain,
      namespace,
      expressionType = (0, i18n_exports._)("expression"),
      castResult = NOPCast
    }) => {
      const results = {};
      return chain.reduce((previousPromise, expressionId) => __async(void 0, null, function* () {
        yield previousPromise;
        const condition = expressions[expressionId];
        if (!condition) {
          const error = ExpressionDoesNotExistError(
            expressionId,
            expressionType,
            results
          );
          return Promise.reject(error);
        }
        const evalResult = yield asyncJsonataEvaluation({
          expression: condition.value,
          tokens: injectInterimResultTokens({
            expressions,
            results,
            tokens,
            namespace,
            castResult
          })
        });
        if (!evalResult.success) {
          const jsonataError = FormattedJSONataError({
            errorCode: evalResult.code,
            errorPosition: evalResult.position,
            errorReason: evalResult.reason,
            expressionId,
            partialResults: results
          });
          return Promise.reject(jsonataError);
        }
        results[expressionId] = castResult(evalResult.value);
        return Promise.resolve(results);
      }), Promise.resolve(results));
    };
    var evaluateExpressions = ({
      expressions,
      expressionIds,
      expressionType,
      targetNamespace,
      castResult,
      tokens,
      signal,
      createDAG,
      onError
    }) => {
      const handleCycle = (nodesInCycle) => {
        console_default.warn(DAGCycleError({ expressionType, nodesInCycle }).message);
      };
      const chains = getEvalOrders({
        expressions,
        expressionIds,
        createDAG,
        handleCycle
      });
      return chains.map((chain) => __async(void 0, null, function* () {
        try {
          const results = yield processPromiseChain({
            expressions,
            tokens,
            chain,
            namespace: targetNamespace,
            expressionType,
            castResult
          });
          if (signal.aborted) {
            throw AbortedPromiseError();
          }
          return Promise.resolve(results);
        } catch (error) {
          if (error instanceof EvaluationChainError) {
            onError({
              error,
              conditionChain: chain,
              erroredCondition: error.expressionId
            });
            return Promise.resolve(error.partialResults);
          }
          if (error instanceof Error) {
            onError({ error, conditionChain: chain });
          }
          return Promise.resolve({});
        }
      }));
    };
    var evaluateConditions = (arg0) => {
      return evaluateExpressions(__spreadProps(__spreadValues({}, arg0), {
        expressionType: (0, i18n_exports._)("conditions"),
        targetNamespace: CONDITION_TOKEN_NAMESPACE,
        createDAG: createConditionsDependencyGraph,
        castResult: (r2) => !!r2
      }));
    };
    var evaluateTokenExpressions = (arg0) => {
      return evaluateExpressions(__spreadProps(__spreadValues({}, arg0), {
        expressionType: (0, i18n_exports._)("token evaluation"),
        targetNamespace: EVAL_TOKEN_NAMESPACE,
        createDAG: createTokenEvalDependencyGraph
      }));
    };
    var genJsonataAst = (expression) => {
      try {
        const formattedExpression = formatIsSetCall(expression).replaceAll(
          new RegExp(`(?<!")(${TokenRegExp.source})(?!")`, "g"),
          '"$1"'
        );
        return {
          success: true,
          result: jsonata_default(formattedExpression).ast()
        };
      } catch (error) {
        if (isJsonataError(error)) {
          return {
            success: false,
            position: error.position,
            reason: error.message,
            code: error.code
          };
        }
        return { success: false, reason: UnknownErrorMessage };
      }
    };
    var isPlainObject5 = (val) => !!val && !Array.isArray(val) && typeof val === "object";
    var isEmptyOrUndefined = (val) => {
      if (typeof val === "undefined" || val === null) {
        return true;
      }
      if (typeof val !== "object") {
        return false;
      }
      return Array.isArray(val) && !val.length || !Object.keys(val).length;
    };
    var isDefined = (val) => typeof val !== "undefined" && val !== null;
    var isPrimitive = (val) => (
      // disallow functions
      typeof val !== "function" && // symbols
      typeof val !== "symbol" && // and objects (but allow null which is typed as 'object')
      (typeof val !== "object" || val === null)
    );
    var isPrimitiveArray = (val) => Array.isArray(val) && val.every(isPrimitive);
    var isLayoutItem = (val) => typeof val === "object" && typeof (val == null ? void 0 : val.item) === "string";
    var isLayoutStructure = (val) => Array.isArray(val) && (val.length < 1 || isLayoutItem(val[0]));
    var isEmptyArray = (val) => Array.isArray(val) && val.filter((v) => v !== void 0).length === 0;
    var isEmptyObject = (val) => isPlainObject5(val) && Object.keys(val).length === 0;
    var isEmpty2 = (val) => val === null || // null
    typeof val === "undefined" || // undefined
    typeof val === "string" && !val || // Empty string
    typeof val !== "string" && typeof val !== "object" || // Non-object/non-string (things such as functions)
    isEmptyArray(val) || // Empty array or array with only `undefined` elements
    isEmptyObject(val);
    var hasFocus = () => document.activeElement !== document.body;
    var getFocus = () => document.activeElement === document.body ? null : document.activeElement;
    var isVizFocused = () => {
      var _a;
      return ((_a = document.activeElement) == null ? void 0 : _a.getAttribute("data-test")) === "select-outline";
    };
    var allowKeyboardShortcut = () => !hasFocus() || isVizFocused();
    var memoize_one_exports = {};
    __export2(memoize_one_exports, {
      default: () => memoize_one_default
    });
    var defaultImport12 = __toESM2((init_memoize_one_esm(), __toCommonJS(memoize_one_esm_exports)));
    __reExport(memoize_one_exports, (init_memoize_one_esm(), __toCommonJS(memoize_one_esm_exports)));
    var memoize_one_default = "default" in defaultImport12 ? defaultImport12.default : defaultImport12;
    var DEFAULT_SCALE_FACTOR = 3;
    var VIZ_DEFAULT_HEIGHT_PX = 400;
    var DEFAULT_CANVAS_WIDTH = 1200;
    var DEFAULT_CANVAS_HEIGHT = 900;
    var DEFAULT_INPUT_ON_CANVAS_WIDTH = 198;
    var DEFAULT_INPUT_ON_CANVAS_HEIGHT = 82;
    var collides = (layoutItemA, layoutItemB) => {
      if (layoutItemA.item === layoutItemB.item) {
        return false;
      }
      if (layoutItemA.position.x + layoutItemA.position.w <= layoutItemB.position.x) {
        return false;
      }
      if (layoutItemA.position.x >= layoutItemB.position.x + layoutItemB.position.w) {
        return false;
      }
      if (layoutItemA.position.y + layoutItemA.position.h <= layoutItemB.position.y) {
        return false;
      }
      if (layoutItemA.position.y >= layoutItemB.position.y + layoutItemB.position.h) {
        return false;
      }
      return true;
    };
    var computeLocationPort = (endPosition, layout) => {
      const id = endPosition.item;
      const index = layout.map((item) => item.item).indexOf(id);
      let position;
      if (index >= 0) {
        position = (0, lodash_exports.cloneDeep)(layout[index].position);
      } else {
        return null;
      }
      switch (endPosition.port) {
        case "n":
          return { x: position.x + position.w / 2, y: position.y };
        case "e":
          return {
            x: position.x + position.w,
            y: position.y + position.h / 2
          };
        case "s":
          return {
            x: position.x + position.w / 2,
            y: position.y + position.h
          };
        case "w":
          return { x: position.x, y: position.y + position.h / 2 };
        default:
          return null;
      }
    };
    var toCoordinate = (itemPosition, layout) => {
      var _a;
      const topLeft = { x: 0, y: 0 };
      if (itemPosition.item && itemPosition.port) {
        return (_a = computeLocationPort(
          { item: itemPosition.item, port: itemPosition.port },
          layout
        )) != null ? _a : topLeft;
      }
      if (typeof itemPosition.x === "number" && typeof itemPosition.y === "number") {
        return { x: itemPosition.x, y: itemPosition.y };
      }
      return topLeft;
    };
    var convertLineToBlockItem = (itemPosition, layout) => {
      const from = toCoordinate(itemPosition.from, layout);
      const to = toCoordinate(itemPosition.to, layout);
      return {
        x: Math.min(from.x, to.x),
        y: Math.min(from.y, to.y),
        w: Math.abs(from.x - to.x),
        h: Math.abs(from.y - to.y)
      };
    };
    var convertToBlockItem = (item, layout) => {
      const blockItem = {
        item: item.item,
        type: "block",
        position: {
          x: 0,
          y: 0,
          w: 0,
          h: 0
        }
      };
      if (item.type === "line") {
        blockItem.position = convertLineToBlockItem(item.position, layout);
      } else {
        if (item.type === "input") {
          blockItem.type = "input";
        }
        blockItem.position = (0, lodash_exports.cloneDeep)(item.position);
      }
      return blockItem;
    };
    var convertToBlockItems = (layout) => {
      return layout.map((item) => convertToBlockItem(item, layout));
    };
    var sortLayoutItems = (layout) => {
      return (0, lodash_exports.cloneDeep)(layout).sort((BlockItem1, BlockItem2) => {
        let res = -1;
        if (BlockItem1.position.y > BlockItem2.position.y || BlockItem1.position.y === BlockItem2.position.y && BlockItem1.position.x > BlockItem2.position.x) {
          res = 1;
        } else if (BlockItem1.position.y === BlockItem2.position.y && BlockItem1.position.x === BlockItem2.position.x) {
          res = 0;
        }
        return res;
      });
    };
    var getFirstCollision = (layout, layoutItem) => {
      return layout.find((item) => collides(item, layoutItem));
    };
    var getPositionByType = ({
      col,
      row,
      width,
      height,
      type
    }) => {
      if (type === "line") {
        return {
          from: {
            x: col,
            y: row + height
          },
          to: {
            x: col + width,
            y: row + height / 2
          }
        };
      }
      return {
        x: col,
        y: row,
        w: width,
        h: height
      };
    };
    var getDefaultPosition = ({
      canvasWidth,
      canvasHeight,
      width,
      height,
      type
    }) => {
      if (type === "line") {
        return {
          from: {
            x: Math.round(canvasWidth / DEFAULT_SCALE_FACTOR),
            y: Math.round(canvasHeight / DEFAULT_SCALE_FACTOR)
          },
          to: {
            x: Math.round(canvasWidth / DEFAULT_SCALE_FACTOR + width),
            y: Math.round(canvasHeight / DEFAULT_SCALE_FACTOR + height)
          }
        };
      }
      return {
        x: Math.round(canvasWidth / DEFAULT_SCALE_FACTOR),
        y: Math.round(canvasHeight / DEFAULT_SCALE_FACTOR),
        w: width,
        h: height
      };
    };
    var computeNextAvailablePosition = ({
      width,
      height,
      canvasHeight,
      canvasWidth,
      items,
      type
    }) => {
      const rectA = {
        item: "__canvas__",
        position: {
          x: 0,
          y: 0,
          w: width,
          h: height
        }
      };
      let minHeight;
      const layout = convertToBlockItems(items);
      const sorted = sortLayoutItems(layout);
      let row = 0;
      let col;
      for (; row < canvasHeight; row += 1) {
        minHeight = canvasHeight - 1;
        col = 0;
        for (; col < canvasWidth; col += 1) {
          rectA.position.x = col;
          rectA.position.y = row;
          const rightBoundary = rectA.position.x + rectA.position.w - 1;
          const bottomBoundary = rectA.position.y + rectA.position.h - 1;
          if (!(rightBoundary > canvasWidth || bottomBoundary > canvasHeight)) {
            const collision = getFirstCollision(sorted, rectA);
            if (collision) {
              minHeight = Math.min(
                minHeight,
                collision.position.y + collision.position.h - 1
              );
              col = collision.position.x + collision.position.w - 1;
            } else {
              return getPositionByType({ col, row, width, height, type });
            }
          } else {
            break;
          }
        }
        row = minHeight;
      }
      return getDefaultPosition({
        canvasWidth,
        canvasHeight,
        width,
        height,
        type
      });
    };
    var computeNewBlockItemPosition = ({
      canvasWidth,
      canvasHeight,
      vizContract,
      config,
      items
    }) => {
      var _a, _b, _c, _d, _e, _f, _g, _h;
      const width = (_d = (_c = (_a = vizContract == null ? void 0 : vizContract.initialDimension) == null ? void 0 : _a.width) != null ? _c : (_b = config == null ? void 0 : config.size) == null ? void 0 : _b.initialWidth) != null ? _d : Math.round(canvasWidth / 3);
      const height = (_h = (_g = (_e = vizContract == null ? void 0 : vizContract.initialDimension) == null ? void 0 : _e.height) != null ? _g : (_f = config == null ? void 0 : config.size) == null ? void 0 : _f.initialHeight) != null ? _h : Math.round(canvasHeight / 3);
      return computeNextAvailablePosition({
        width,
        height,
        canvasHeight,
        canvasWidth,
        items,
        type: "block"
      });
    };
    var computeNewLinePosition = ({
      canvasWidth,
      canvasHeight,
      items
    }) => {
      const width = 150;
      const height = 20;
      return computeNextAvailablePosition({
        width,
        height,
        canvasHeight,
        canvasWidth,
        items,
        type: "line"
      });
    };
    var computeNewInputPosition = ({
      canvasWidth,
      canvasHeight,
      items
    }) => {
      const width = DEFAULT_INPUT_ON_CANVAS_WIDTH;
      const height = DEFAULT_INPUT_ON_CANVAS_HEIGHT;
      return computeNextAvailablePosition({
        width,
        height,
        canvasHeight,
        canvasWidth,
        items,
        type: "input"
      });
    };
    var computeMaxHeight = (layoutItems, minHeight = 0) => {
      return layoutItems.length > 0 ? Math.max(
        ...layoutItems.map((item) => item.position.y + item.position.h),
        1
      ) : minHeight;
    };
    var computeNewAbsoluteStructureItem = ({
      itemId,
      type = "block",
      canvasWidth,
      canvasHeight,
      vizContract,
      layoutItems,
      config
    }) => {
      if (type === "line") {
        return {
          item: itemId,
          type: "line",
          position: computeNewLinePosition({
            canvasWidth,
            canvasHeight,
            items: layoutItems
          })
        };
      }
      if (type === "input") {
        return {
          item: itemId,
          type: "input",
          position: computeNewInputPosition({
            canvasWidth,
            canvasHeight,
            items: layoutItems
          })
        };
      }
      return {
        item: itemId,
        type,
        position: computeNewBlockItemPosition({
          canvasWidth,
          canvasHeight,
          vizContract,
          config,
          items: layoutItems
        })
      };
    };
    var computeNewGridStructureItem = ({
      itemId,
      layoutItems,
      canvasWidth,
      type = "block"
    }) => ({
      item: itemId,
      type,
      position: {
        x: 0,
        y: computeMaxHeight(layoutItems),
        w: canvasWidth,
        h: VIZ_DEFAULT_HEIGHT_PX
      }
    });
    var getScrollbarWidth = memoize_one_default(() => {
      const scrollDiv = document.createElement("div");
      scrollDiv.setAttribute(
        "style",
        "width:100px;height:100px;overflow:scroll;position:absolute;top:-9999px;"
      );
      document.body.appendChild(scrollDiv);
      const scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;
      document.body.removeChild(scrollDiv);
      return scrollbarWidth;
    });
    var isBlockItem = (item) => typeof item === "object" && item !== null && (typeof item.type === "undefined" || item.type === "block" || item.type === "input");
    var isInVerticalRange = (itemPosition, vizPosition) => {
      return vizPosition.y >= itemPosition.y && vizPosition.y + vizPosition.h <= itemPosition.y + itemPosition.h;
    };
    var isInHorizontalRange = (itemPosition, vizPosition) => {
      return vizPosition.x >= itemPosition.x && vizPosition.x + vizPosition.w <= itemPosition.x + itemPosition.w;
    };
    var isLeftNeighbor = (item, viz) => {
      const isLeftOf = viz.position.x + viz.position.w === item.position.x;
      return isLeftOf && isInVerticalRange(item.position, viz.position);
    };
    var isRightNeighbor = (item, viz) => {
      const isRightOf = viz.position.x === item.position.x + item.position.w;
      return isRightOf && isInVerticalRange(item.position, viz.position);
    };
    var isTopNeighbor = (item, viz) => {
      const isAbove = viz.position.y + viz.position.h === item.position.y;
      return isAbove && isInHorizontalRange(item.position, viz.position);
    };
    var isBottomNeighbor = (item, viz) => {
      const isBelow = viz.position.y === item.position.y + item.position.h;
      return isBelow && isInHorizontalRange(item.position, viz.position);
    };
    var findHorizontalNeighbors = ({
      item,
      visualizations
    }) => {
      let leftHeight = 0;
      let rightHeight = 0;
      let leftNeighbors = [];
      let rightNeighbors = [];
      visualizations.forEach((viz) => {
        if ((0, lodash_exports.isEqual)(item, viz)) {
          return;
        }
        if (isLeftNeighbor(item, viz)) {
          leftHeight += viz.position.h;
          leftNeighbors.push(viz);
        }
        if (isRightNeighbor(item, viz)) {
          rightHeight += viz.position.h;
          rightNeighbors.push(viz);
        }
      });
      if (leftHeight !== item.position.h) {
        leftNeighbors = [];
      }
      if (rightHeight !== item.position.h) {
        rightNeighbors = [];
      }
      return { leftNeighbors, rightNeighbors };
    };
    var findVerticalNeighbors = ({
      item,
      visualizations
    }) => {
      let topWidth = 0;
      let bottomWidth = 0;
      let topNeighbors = [];
      let bottomNeighbors = [];
      visualizations.forEach((viz) => {
        if ((0, lodash_exports.isEqual)(item, viz)) {
          return;
        }
        if (isTopNeighbor(item, viz)) {
          topWidth += viz.position.w;
          topNeighbors.push(viz);
        }
        if (isBottomNeighbor(item, viz)) {
          bottomWidth += viz.position.w;
          bottomNeighbors.push(viz);
        }
      });
      if (topWidth !== item.position.w) {
        topNeighbors = [];
      }
      if (bottomWidth !== item.position.w) {
        bottomNeighbors = [];
      }
      return { topNeighbors, bottomNeighbors };
    };
    var getItemsWithUpdatedPositions = ({
      itemToRemove,
      visualizations
    }) => {
      const updatedVisualizations = [];
      visualizations.forEach((viz) => {
        if (itemToRemove.position.y < viz.position.y) {
          updatedVisualizations.push(__spreadProps(__spreadValues({}, viz), {
            position: __spreadProps(__spreadValues({}, viz.position), {
              y: viz.position.y - itemToRemove.position.h
            })
          }));
        }
      });
      return updatedVisualizations;
    };
    var updateRemovedVizNeighbors = ({
      itemToRemove,
      items,
      width
    }) => {
      const updatedItems = [];
      if (itemToRemove.position.w === width) {
        return getItemsWithUpdatedPositions({
          itemToRemove,
          visualizations: items
        });
      }
      const { leftNeighbors, rightNeighbors } = findHorizontalNeighbors({
        item: itemToRemove,
        visualizations: items
      });
      if (leftNeighbors.length || rightNeighbors.length) {
        if (leftNeighbors.length && rightNeighbors.length) {
          const leftWidthToAdd = Math.floor(itemToRemove.position.w / 2);
          const rightWidthToAdd = Math.ceil(itemToRemove.position.w / 2);
          leftNeighbors.forEach((viz) => {
            updatedItems.push(__spreadProps(__spreadValues({}, viz), {
              position: __spreadProps(__spreadValues({}, viz.position), {
                w: viz.position.w + leftWidthToAdd
              })
            }));
          });
          rightNeighbors.forEach((viz) => {
            updatedItems.push(__spreadProps(__spreadValues({}, viz), {
              position: __spreadProps(__spreadValues({}, viz.position), {
                x: viz.position.x - rightWidthToAdd,
                w: viz.position.w + rightWidthToAdd
              })
            }));
          });
        } else if (leftNeighbors.length) {
          leftNeighbors.forEach((viz) => {
            updatedItems.push(__spreadProps(__spreadValues({}, viz), {
              position: __spreadProps(__spreadValues({}, viz.position), {
                w: viz.position.w + itemToRemove.position.w
              })
            }));
          });
        } else {
          rightNeighbors.forEach((viz) => {
            updatedItems.push(__spreadProps(__spreadValues({}, viz), {
              position: __spreadProps(__spreadValues({}, viz.position), {
                x: viz.position.x - itemToRemove.position.w,
                w: viz.position.w + itemToRemove.position.w
              })
            }));
          });
        }
      } else {
        const { topNeighbors, bottomNeighbors } = findVerticalNeighbors({
          item: itemToRemove,
          visualizations: items
        });
        if (topNeighbors.length || bottomNeighbors.length) {
          if (topNeighbors.length && bottomNeighbors.length) {
            const topHeightToAdd = Math.floor(itemToRemove.position.h / 2);
            const bottomHeightToAdd = Math.ceil(
              itemToRemove.position.h / 2
            );
            topNeighbors.forEach((viz) => {
              updatedItems.push(__spreadProps(__spreadValues({}, viz), {
                position: __spreadProps(__spreadValues({}, viz.position), {
                  h: viz.position.h + topHeightToAdd
                })
              }));
            });
            bottomNeighbors.forEach((viz) => {
              updatedItems.push(__spreadProps(__spreadValues({}, viz), {
                position: __spreadProps(__spreadValues({}, viz.position), {
                  y: viz.position.y - bottomHeightToAdd,
                  h: viz.position.h + bottomHeightToAdd
                })
              }));
            });
          } else if (topNeighbors.length) {
            topNeighbors.forEach((viz) => {
              updatedItems.push(__spreadProps(__spreadValues({}, viz), {
                position: __spreadProps(__spreadValues({}, viz.position), {
                  h: viz.position.h + itemToRemove.position.h
                })
              }));
            });
          } else {
            bottomNeighbors.forEach((viz) => {
              updatedItems.push(__spreadProps(__spreadValues({}, viz), {
                position: __spreadProps(__spreadValues({}, viz.position), {
                  y: viz.position.y - itemToRemove.position.h,
                  h: viz.position.h + itemToRemove.position.h
                })
              }));
            });
          }
        }
      }
      return updatedItems;
    };
    var legacyPresetTypes = [
      "viz.area",
      "viz.bar",
      "viz.bubble",
      "viz.choropleth.svg",
      "viz.column",
      "viz.ellipse",
      "viz.fillergauge",
      "viz.geojson.us",
      "viz.geojson.world",
      "viz.img",
      "viz.line",
      "viz.markdown",
      "viz.markergauge",
      "viz.pie",
      "viz.punchcard",
      "viz.scatter",
      "viz.singlevalue",
      "viz.singlevalueicon",
      "viz.singlevalueradial",
      "viz.table",
      "viz.text"
    ];
    var isDeprecated = ({
      deprecatedPresetTypes,
      supportedPresetTypes,
      itemType
    }) => {
      if (deprecatedPresetTypes.includes(itemType)) {
        return true;
      }
      return legacyPresetTypes.includes(itemType) && !supportedPresetTypes.includes(itemType);
    };
    var processPreset = ({ visualizations }) => {
      const deprecatedTypes = [];
      const supportedTypes = [];
      Object.keys(visualizations).forEach((key) => {
        var _a;
        if ((_a = visualizations[key].meta) == null ? void 0 : _a.deprecated) {
          deprecatedTypes.push(key);
        } else {
          supportedTypes.push(key);
        }
      });
      return {
        deprecatedPresetTypes: deprecatedTypes,
        supportedPresetTypes: supportedTypes
      };
    };
    var findDeprecatedVisualizations = ({
      def,
      deprecatedPresetTypes,
      supportedPresetTypes
    }) => {
      var _a;
      const result = [];
      Object.entries((_a = def.visualizations) != null ? _a : []).forEach(([key, viz]) => {
        if (isDeprecated({
          deprecatedPresetTypes,
          supportedPresetTypes,
          itemType: viz.type
        })) {
          result.push({ id: key, type: viz.type });
        }
      });
      return result;
    };
    var getDeprecatedVisualizations = ({
      def,
      preset
    }) => {
      const processedPreset = processPreset(preset);
      const deprecatedVisualizations = findDeprecatedVisualizations(__spreadValues({
        def
      }, processedPreset));
      return deprecatedVisualizations;
    };
    var migrateInputDefaultValueToTokenDefaults = ({ definition }) => {
      var _a, _b;
      if (!(definition == null ? void 0 : definition.inputs)) {
        return definition;
      }
      const tokens = (0, lodash_exports.cloneDeep)((_b = (_a = definition.defaults) == null ? void 0 : _a.tokens) != null ? _b : {});
      const inputs = (0, lodash_exports.cloneDeep)(definition.inputs);
      const processedTokens = /* @__PURE__ */ new Set();
      let migratedInput = false;
      Object.keys(inputs).forEach((id) => {
        var _a2, _b2;
        const input = inputs[id];
        if (!((_a2 = input.options) == null ? void 0 : _a2.token)) {
          return;
        }
        const {
          tokenNamespace = "default",
          token,
          defaultValue
        } = input.options;
        if (!processedTokens.has(`${tokenNamespace}:${token}`) && // allow falsy values like 0 or '', but not undefined or null
        typeof defaultValue !== "undefined" && defaultValue !== null) {
          (_b2 = tokens[tokenNamespace]) != null ? _b2 : tokens[tokenNamespace] = {};
          tokens[tokenNamespace][token] = {
            value: Array.isArray(defaultValue) ? defaultValue : `${defaultValue}`
          };
        }
        if (Object.hasOwn(input.options, "defaultValue")) {
          delete input.options.defaultValue;
          migratedInput = true;
        }
        processedTokens.add(`${tokenNamespace}:${token}`);
      });
      if (migratedInput) {
        return __spreadProps(__spreadValues({}, definition), {
          inputs,
          defaults: __spreadProps(__spreadValues({}, definition.defaults), {
            tokens
          })
        });
      }
      return definition;
    };
    var visualization_migrations_exports = {};
    __export2(visualization_migrations_exports, {
      default: () => visualization_migrations_default
    });
    var defaultImport13 = __toESM2(require_visualization_migrations());
    __reExport(visualization_migrations_exports, require_visualization_migrations());
    var visualization_migrations_default = "default" in defaultImport13 ? defaultImport13.default : defaultImport13;
    var tryMigration = ({
      type,
      vizDefaults,
      vizPresets
    }) => {
      const toType = (0, visualization_migrations_exports.inferToType)(type);
      if (vizPresets[toType] && (0, visualization_migrations_exports.canMigrate)({ fromType: type, toType })) {
        const _a = (0, visualization_migrations_exports.migrate)({
          definition: __spreadProps(__spreadValues({}, vizDefaults[type]), { type })
        }), { type: migratedType } = _a, migratedDefinition = __objRest(_a, ["type"]);
        return {
          newDefaults: {
            [migratedType]: migratedDefinition
          },
          success: true
        };
      }
      if (vizPresets[toType] && type !== toType) {
        const migratedDefault = {};
        Object.entries(vizDefaults[type]).forEach(([key, value]) => {
          if (typeof value !== "undefined" && key !== "options") {
            migratedDefault[key] = value;
          }
        });
        if (Object.keys(migratedDefault).length) {
          return {
            newDefaults: {
              [toType]: migratedDefault
            },
            success: true
          };
        }
        return { success: true };
      }
      return {
        newDefaults: {
          [type]: vizDefaults[type]
        },
        success: false
      };
    };
    var migrateVisualizationDefaults = ({
      definition,
      preset: { visualizations: vizPresets }
    }) => {
      if (!(definition == null ? void 0 : definition.visualizations)) {
        return definition;
      }
      const vizDefaults = definition.visualizations;
      const migratedDefaults = {};
      let migrated = false;
      Object.keys(vizDefaults).forEach((type) => {
        try {
          const { success, newDefaults = {} } = tryMigration({
            vizPresets,
            vizDefaults,
            type
          });
          migrated || (migrated = success);
          Object.assign(migratedDefaults, newDefaults);
        } catch (e) {
          console_default.error(`Error migrating default: ${type}`, e);
          migratedDefaults[type] = vizDefaults[type];
        }
      });
      return migrated ? __spreadProps(__spreadValues({}, definition), { visualizations: migratedDefaults }) : definition;
    };
    var migrateVisualizationDefinitions = ({
      definition,
      preset: { visualizations: vizPresets }
    }) => {
      if (!definition || !Object.keys(definition).length) {
        return definition;
      }
      let migrated = false;
      const migratedSection = {};
      Object.entries(definition).forEach(([vizId, def]) => {
        try {
          const toType = (0, visualization_migrations_exports.inferToType)(def.type);
          if (vizPresets[toType] && (0, visualization_migrations_exports.canMigrate)({ fromType: def.type, toType })) {
            migratedSection[vizId] = (0, visualization_migrations_exports.migrate)({ definition: def });
            migrated = true;
          } else if (vizPresets[toType] && def.type !== toType) {
            migratedSection[vizId] = __spreadProps(__spreadValues({}, def), { type: toType });
            delete migratedSection[vizId].encoding;
            delete migratedSection[vizId].options;
            migrated = true;
          } else {
            migratedSection[vizId] = def;
          }
        } catch (e) {
          console_default.error(`Error migrating visualization: ${vizId}`, e);
          migratedSection[vizId] = def;
        }
      });
      return migrated ? migratedSection : definition;
    };
    var migrateLegacyVisualizationsToPlatformVisualizations = ({ definition, preset }) => {
      if (!definition) {
        return definition;
      }
      const migratedDefaults = migrateVisualizationDefaults({
        definition: definition.defaults,
        preset
      });
      const migratedVisualizations = migrateVisualizationDefinitions({
        definition: definition.visualizations,
        preset
      });
      if (migratedDefaults !== definition.defaults || migratedVisualizations !== definition.visualizations) {
        return __spreadProps(__spreadValues({}, definition), {
          visualizations: migratedVisualizations,
          defaults: migratedDefaults
        });
      }
      return definition;
    };
    var migrateDashboardDefinition = migrateLegacyVisualizationsToPlatformVisualizations;
    var UNDEFINED_DEFINITION_ERROR = (0, i18n_exports._)(
      "No `definition` was provided for the migration"
    );
    var NON_OBJECT_LAYOUT_ERROR = (0, i18n_exports._)(
      "Only non-null object values can be migrated. `definition.layout` was null, undefined, or not an object."
    );
    var failedMigration = (definition, reason) => ({
      success: false,
      definition,
      reason
    });
    var successfulMigration = (definition) => ({
      success: true,
      definition
    });
    var breakoutGlobalOptions = (_a) => {
      var _b = _a, {
        submitButton,
        submitOnDashboardLoad,
        showTitleAndDescription
      } = _b, tabOptions = __objRest(_b, [
        "submitButton",
        "submitOnDashboardLoad",
        "showTitleAndDescription"
      ]);
      let globalOptions;
      if (typeof submitButton !== "undefined") {
        globalOptions != null ? globalOptions : globalOptions = {};
        globalOptions.submitButton = submitButton;
      }
      if (typeof submitOnDashboardLoad !== "undefined") {
        globalOptions != null ? globalOptions : globalOptions = {};
        globalOptions.submitOnDashboardLoad = submitOnDashboardLoad;
      }
      if (typeof showTitleAndDescription !== "undefined") {
        globalOptions != null ? globalOptions : globalOptions = {};
        globalOptions.showTitleAndDescription = showTitleAndDescription;
      }
      return { globalOptions, tabOptions };
    };
    var createTabDefinition = (_a) => {
      var _b = _a, {
        type,
        tabOptions,
        structure
      } = _b, rest = __objRest(_b, [
        "type",
        "tabOptions",
        "structure"
      ]);
      const tabDefinition = __spreadValues({
        type
      }, rest);
      if (Object.keys(tabOptions != null ? tabOptions : {}).length) {
        tabDefinition.options = tabOptions;
      }
      if (structure) {
        tabDefinition.structure = structure;
      }
      return tabDefinition;
    };
    var migrateToTabsLayout = ({ definition }) => {
      var _a;
      if (!definition) {
        return failedMigration(definition, UNDEFINED_DEFINITION_ERROR);
      }
      if ((0, lodash_exports.isObjectLike)(definition.layout) && (0, lodash_exports.isObjectLike)((_a = definition.layout) == null ? void 0 : _a.tabs)) {
        return successfulMigration(definition);
      }
      const _b = definition, { layout } = _b, initialDefinition = __objRest(_b, ["layout"]);
      if (!(0, lodash_exports.isObjectLike)(layout)) {
        return successfulMigration(definition);
      }
      const migratedDefinition = __spreadValues({}, initialDefinition);
      const _c = layout, {
        globalInputs,
        type,
        structure,
        options: legacyOptions = {}
      } = _c, rest = __objRest(_c, [
        "globalInputs",
        "type",
        "structure",
        "options"
      ]);
      const { globalOptions, tabOptions } = breakoutGlobalOptions(legacyOptions);
      migratedDefinition.layout = {
        tabs: {
          items: [
            {
              layoutId: "layout_1",
              label: (0, i18n_exports._)("New tab")
            }
          ]
        },
        layoutDefinitions: {
          layout_1: createTabDefinition(__spreadValues({
            type,
            tabOptions,
            structure
          }, rest))
        }
      };
      if (globalInputs) {
        migratedDefinition.layout.globalInputs = globalInputs;
      }
      if (globalOptions) {
        migratedDefinition.layout.options = globalOptions;
      }
      return successfulMigration(migratedDefinition);
    };
    var noop2 = () => void 0;
    var noop_default = noop2;
    var isRiskyCommandError = (message) => {
      return !!message && message.startsWith("Found potentially risky commands:");
    };
    var getRiskyCommands = (message) => {
      if (!isRiskyCommandError(message)) {
        return [];
      }
      return message ? Array.from(new Set(message.split(":")[1].trim().split(" "))) : [];
    };
    var formatRiskyCommandErrorMessage = (message) => {
      return (0, i18n_exports._)("Found potentially risky command(s): ") + getRiskyCommands(message).join(" ");
    };
    var DS_STATUS = {
      QUEUED: "queued",
      PARSING: "parsing",
      RUNNING: "running",
      PAUSE: "pause",
      FINALIZING: "finalizing",
      FAILED: "failed",
      STOPPED: "stopped",
      DONE: "done",
      CANCELED: "canceled",
      REFRESHING: "refreshing"
    };
    var RUNNING_SEARCH_STATUSES = [
      DS_STATUS.RUNNING,
      DS_STATUS.QUEUED,
      DS_STATUS.PARSING,
      DS_STATUS.PAUSE,
      DS_STATUS.FINALIZING,
      DS_STATUS.REFRESHING
    ];
    var COMPLETED_SEARCH_STATUSES = [
      DS_STATUS.FAILED,
      DS_STATUS.STOPPED,
      DS_STATUS.DONE,
      DS_STATUS.CANCELED
    ];
    var MAX_CHAIN_LENGTH = 10;
    var intersection_exports = {};
    __export2(intersection_exports, {
      default: () => intersection_default
    });
    var defaultImport14 = __toESM2(require_intersection());
    __reExport(intersection_exports, require_intersection());
    var intersection_default = "default" in defaultImport14 ? defaultImport14.default : defaultImport14;
    var difference_exports = {};
    __export2(difference_exports, {
      default: () => difference_default
    });
    var defaultImport15 = __toESM2(require_difference());
    __reExport(difference_exports, require_difference());
    var difference_default = "default" in defaultImport15 ? defaultImport15.default : defaultImport15;
    var every_exports = {};
    __export2(every_exports, {
      default: () => every_default
    });
    var defaultImport16 = __toESM2(require_every());
    __reExport(every_exports, require_every());
    var every_default = "default" in defaultImport16 ? defaultImport16.default : defaultImport16;
    var shallowEqual_default = (obj1, obj2, { includeKeys = [], omitKeys = [] } = {}) => {
      if (obj1 === obj2) {
        return true;
      }
      let keysA = Object.keys(obj1);
      let keysB = Object.keys(obj2);
      if (includeKeys.length) {
        keysA = intersection_default(keysA, includeKeys);
        keysB = intersection_default(keysB, includeKeys);
      }
      if (omitKeys.length) {
        keysA = difference_default(keysA, omitKeys);
        keysB = difference_default(keysB, omitKeys);
      }
      return keysA.length === keysB.length && every_default(keysA, (key) => obj1[key] === obj2[key]);
    };
    var isNumber_exports = {};
    __export2(isNumber_exports, {
      default: () => isNumber_default
    });
    var defaultImport17 = __toESM2(require_isNumber());
    __reExport(isNumber_exports, require_isNumber());
    var isNumber_default = "default" in defaultImport17 ? defaultImport17.default : defaultImport17;
    var toPx = (num, defaultNumber = 0) => isNumber_default(num) ? `${num}px` : num || toPx(defaultNumber);
    var toDimension = ({ width, height }) => {
      let css = "";
      if (width || width === 0) {
        css = `
        width: ${toPx(width)};
        `;
      }
      if (height || height === 0) {
        css = `
        ${css}
        height: ${toPx(height)};
        `;
      }
      return css;
    };
    var arrayToCSSProp = (prop, values2 = [0, 0, 0, 0]) => {
      if (Array.isArray(values2)) {
        return `
            ${prop}: ${toPx(values2[0])} ${toPx(values2[1])} ${toPx(
          values2[2]
        )} ${toPx(values2[3])};
        `;
      }
      return `${prop}: ${toPx(values2)};`;
    };
    var toMargin = (margins = [0, 0, 0, 0]) => arrayToCSSProp("margin", margins);
    var toPadding = (paddings = [0, 0, 0, 0]) => arrayToCSSProp("padding", paddings);
    var find_exports = {};
    __export2(find_exports, {
      default: () => find_default
    });
    var defaultImport18 = __toESM2(require_find());
    __reExport(find_exports, require_find());
    var find_default = "default" in defaultImport18 ? defaultImport18.default : defaultImport18;
    var has_exports = {};
    __export2(has_exports, {
      default: () => has_default
    });
    var defaultImport19 = __toESM2(require_has());
    __reExport(has_exports, require_has());
    var has_default = "default" in defaultImport19 ? defaultImport19.default : defaultImport19;
    var isString_exports = {};
    __export2(isString_exports, {
      default: () => isString_default
    });
    var defaultImport20 = __toESM2(require_isString());
    __reExport(isString_exports, require_isString());
    var isString_default = "default" in defaultImport20 ? defaultImport20.default : defaultImport20;
    var isFinite_exports = {};
    __export2(isFinite_exports, {
      default: () => isFinite_default
    });
    var defaultImport21 = __toESM2(require_isFinite());
    __reExport(isFinite_exports, require_isFinite());
    var isFinite_default = "default" in defaultImport21 ? defaultImport21.default : defaultImport21;
    var SecondsDescription = {
      abbr: "s",
      singular: (0, i18n_exports._)("second"),
      plural: (0, i18n_exports._)("seconds")
    };
    var MinutesDescription = {
      abbr: "m",
      singular: (0, i18n_exports._)("minute"),
      plural: (0, i18n_exports._)("minutes")
    };
    var HoursDescription = { abbr: "h", singular: (0, i18n_exports._)("hour"), plural: (0, i18n_exports._)("hours") };
    var DaysDescription = { abbr: "d", singular: (0, i18n_exports._)("day"), plural: (0, i18n_exports._)("days") };
    var WeeksDescription = { abbr: "w", singular: (0, i18n_exports._)("week"), plural: (0, i18n_exports._)("weeks") };
    var MonthsDescription = {
      abbr: "mon",
      singular: (0, i18n_exports._)("month"),
      plural: (0, i18n_exports._)("months")
    };
    var QuartersDescription = {
      abbr: "q",
      singular: (0, i18n_exports._)("quarter"),
      plural: (0, i18n_exports._)("quarters")
    };
    var YearsDescription = {
      abbr: "y",
      singular: (0, i18n_exports._)("year"),
      plural: (0, i18n_exports._)("years")
    };
    var u = {
      s: SecondsDescription,
      sec: SecondsDescription,
      secs: SecondsDescription,
      second: SecondsDescription,
      seconds: SecondsDescription,
      m: MinutesDescription,
      min: MinutesDescription,
      mins: MinutesDescription,
      minute: MinutesDescription,
      minutes: MinutesDescription,
      h: HoursDescription,
      hr: HoursDescription,
      hrs: HoursDescription,
      hour: HoursDescription,
      hours: HoursDescription,
      d: DaysDescription,
      day: DaysDescription,
      days: DaysDescription,
      w: WeeksDescription,
      week: WeeksDescription,
      weeks: WeeksDescription,
      mon: MonthsDescription,
      month: MonthsDescription,
      months: MonthsDescription,
      q: QuartersDescription,
      qtr: QuartersDescription,
      qtrs: QuartersDescription,
      quarter: QuartersDescription,
      quarters: QuartersDescription,
      y: YearsDescription,
      yr: YearsDescription,
      yrs: YearsDescription,
      year: YearsDescription,
      years: YearsDescription
    };
    var timeUnits = u;
    var snapUnits = __spreadProps(__spreadValues({}, u), {
      w0: { abbr: "w0", singular: (0, i18n_exports._)("Sunday"), plural: (0, i18n_exports._)("Sundays") },
      w1: { abbr: "w1", singular: (0, i18n_exports._)("Monday"), plural: (0, i18n_exports._)("Mondays") },
      w2: { abbr: "w2", singular: (0, i18n_exports._)("Tuesday"), plural: (0, i18n_exports._)("Tuesdays") },
      w3: {
        abbr: "w3",
        singular: (0, i18n_exports._)("Wednesday"),
        plural: (0, i18n_exports._)("Wednesdays")
      },
      w4: { abbr: "w4", singular: (0, i18n_exports._)("Thursday"), plural: (0, i18n_exports._)("Thursdays") },
      w5: { abbr: "w5", singular: (0, i18n_exports._)("Friday"), plural: (0, i18n_exports._)("Fridays") },
      w6: { abbr: "w6", singular: (0, i18n_exports._)("Saturday"), plural: (0, i18n_exports._)("Saturdays") },
      w7: { abbr: "w7", singular: (0, i18n_exports._)("Sunday"), plural: (0, i18n_exports._)("Sundays") }
    });
    var momentUnits = {
      s: "s",
      m: "m",
      h: "h",
      d: "d",
      w: "w",
      mon: "M",
      q: "Q",
      y: "y"
    };
    var momentSnaps = {
      s: "second",
      m: "minute",
      h: "hour",
      d: "day",
      w: "week",
      mon: "month",
      q: "quarter",
      y: "year"
    };
    var weekDaySnaps = {
      w0: 0,
      w1: 1,
      w2: 2,
      w3: 3,
      w4: 4,
      w5: 5,
      w6: 6,
      w7: 0
    };
    var toSplunkMoment = (time) => {
      if (moment_default.getDefaultSplunkTimezone()) {
        return moment_default.newSplunkTime({ time });
      }
      return moment_default(time);
    };
    var epochToMoment = (epoch) => {
      const time = epoch || epoch === 0 ? epoch * 1e3 : (/* @__PURE__ */ new Date()).getTime();
      return toSplunkMoment(time);
    };
    function normalizeUnit(abbr, removeInvalid = true) {
      const hasUnit = has_default(timeUnits, abbr);
      const defaultUnit = removeInvalid ? "" : timeUnits.s.abbr;
      return hasUnit ? timeUnits[abbr].abbr : defaultUnit;
    }
    function normalizeSnapUnit(abbr, removeInvalid = true) {
      const hasUnit = has_default(snapUnits, abbr);
      const defaultUnit = removeInvalid ? "" : timeUnits.s.abbr;
      return hasUnit ? snapUnits[abbr].abbr : defaultUnit;
    }
    function getUnitLabel(unit, plural = false) {
      return snapUnits[unit][plural ? "plural" : "singular"];
    }
    function removeRealTime(time) {
      if (time === "rt") {
        return "now";
      }
      return time.replace(/^rt/, "");
    }
    function removeISOTimezone(time) {
      return time.replace(/[+-]\d?\d:\d\d$/, "");
    }
    function isEpoch(time) {
      return isFinite_default(time) || isString_default(time) && /^\d+((\.\d+)|(\d*))$/.test(time);
    }
    function isISO(time) {
      return !!time.match(
        /^\d\d\d\d-\d\d?-\d\d?T\d\d?:\d\d?(:\d\d?)?(\.\d\d?\d?)?([+-]\d\d?:\d\d|Z)?$/
      );
    }
    function isoToEpoch(time) {
      return new Date(time).getTime() / 1e3;
    }
    function epochToISO(time) {
      const epochSeconds = Number(time);
      return new Date(epochSeconds * 1e3).toISOString();
    }
    function isAbsolute(time) {
      if (time === void 0) {
        return false;
      }
      return isEpoch(time) || isISO(time);
    }
    function parseTimeString(timeString) {
      if (!isString_default(timeString)) {
        return false;
      }
      const ast = {
        string: timeString,
        type: "relative",
        isFullyParsed: true,
        modifiers: []
      };
      if (isISO(timeString)) {
        ast.type = "iso";
        return ast;
      }
      if (isEpoch(timeString)) {
        ast.type = "epoch";
        return ast;
      }
      const segments = timeString.trim().replace(/-/g, "\n-").replace(/\+/g, "\n+").split("\n");
      if (segments[0].startsWith("@")) {
        segments.unshift("");
      }
      if (segments[0] === "rt" || segments[0] === "rtnow") {
        ast.type = "realTime";
      } else if (["rt", "now", "rtnow", ""].indexOf(segments[0]) < 0) {
        ast.isFullyParsed = false;
        return ast;
      } else {
        ast.type = "relative";
      }
      ast.modifiers = segments.slice(1).map((segmentString) => {
        const segment = {
          string: segmentString,
          unit: "s",
          amount: 0,
          snap: false,
          isParsed: false
        };
        const sParse = segmentString.match(
          /^(([-+]\d*)([a-zA-Z]*))?(@([a-zA-Z][a-zA-Z0-7]*))?$/
        );
        if (sParse) {
          segment.unit = sParse[3] && normalizeUnit(sParse[3], false);
          segment.amount = segment.unit ? parseInt(sParse[2], 10) || 1 : 0;
          segment.snap = !!sParse[4] && normalizeSnapUnit(sParse[5], false);
          segment.isParsed = true;
          if (sParse[5] && !snapUnits[sParse[5]] || // invalid unit
          sParse[3] && !timeUnits[sParse[3]] || // invalid snap unit
          segmentString.length === 1) {
            ast.isFullyParsed = false;
            segment.isParsed = false;
          }
        } else {
          ast.isFullyParsed = false;
        }
        return segment;
      });
      return ast;
    }
    function isValidTime(time) {
      const parsedTime = parseTimeString(time);
      return parsedTime && parsedTime.isFullyParsed;
    }
    function isRealTime(time) {
      const parsedTimeString = parseTimeString(time);
      return parsedTimeString && parsedTimeString.type === "realTime" && parsedTimeString.isFullyParsed;
    }
    function isWholeDay(time) {
      if (isString_default(time) && isISO(time) || moment_default.isMoment(time) && time.isValid()) {
        const timeMoment = moment_default(time);
        return timeMoment.valueOf() === timeMoment.startOf("day").valueOf();
      }
      return false;
    }
    function isEarliestEmpty(time) {
      return !time || time === "0";
    }
    function isLatestNow(time) {
      return !time || isString_default(time) && time === "now";
    }
    function isAllTime(earliest, latest) {
      return isEarliestEmpty(removeRealTime(earliest)) && isLatestNow(removeRealTime(latest));
    }
    function timeRangesAreEquivalent(range1, range2) {
      const earliest1 = range1.earliest;
      const latest1 = range1.latest;
      const earliest2 = range2.earliest;
      const latest2 = range2.latest;
      let earliestEqual = false;
      let latestEqual = false;
      if (isEarliestEmpty(earliest1) && isEarliestEmpty(earliest2)) {
        earliestEqual = true;
      } else {
        earliestEqual = earliest1 === earliest2;
      }
      if (isLatestNow(latest1) && isLatestNow(latest2)) {
        latestEqual = true;
      } else {
        latestEqual = latest1 === latest2;
      }
      return earliestEqual && latestEqual;
    }
    function findPresetLabel(presets, earliest, latest) {
      const currentPreset = find_default(presets, (preset) => {
        const range2 = { earliest: preset.earliest, latest: preset.latest };
        return timeRangesAreEquivalent({ earliest, latest }, range2);
      });
      return currentPreset ? currentPreset.label : false;
    }
    function createRealTimeLabel(earliest, latest) {
      if (isRealTime(earliest) || isRealTime(latest)) {
        const earliestParse = parseTimeString(earliest);
        const latestParse = parseTimeString(latest);
        if (!earliestParse || !latestParse) {
          return false;
        }
        const earliestModifier = earliestParse.modifiers[0];
        const labelTemplates = {
          s: (0, i18n_exports._)("%(time)d second window"),
          m: (0, i18n_exports._)("%(time)d minute window"),
          h: (0, i18n_exports._)("%(time)d hour window"),
          d: (0, i18n_exports._)("%(time)d day window"),
          w: (0, i18n_exports._)("%(time)d week window"),
          mon: (0, i18n_exports._)("%(time)d month window"),
          q: (0, i18n_exports._)("%(time)d quarter window"),
          y: (0, i18n_exports._)("%(time)d year window")
        };
        if (earliestModifier && earliestParse.type === "realTime" && latestParse.type === "realTime" && latestParse.modifiers.length === 0 && (earliestModifier == null ? void 0 : earliestModifier.unit) && has_default(labelTemplates, earliestModifier.unit) && earliestParse.modifiers.length === 1) {
          return (0, format_exports.sprintf)(
            labelTemplates[earliestModifier.unit],
            {
              time: Math.abs(earliestModifier.amount || 0)
            }
          );
        }
        return (0, i18n_exports._)("Real-time");
      }
      return false;
    }
    function createRelativeTimeLabel(earliest, latest) {
      const earliestParse = parseTimeString(earliest);
      const latestParse = parseTimeString(latest);
      if (!earliestParse || !latestParse) {
        return false;
      }
      const earliestModifier = earliestParse.modifiers[0];
      const latestModifier = latestParse.modifiers[0];
      if (earliestParse.type === "realTime" || latestParse.type === "realTime" || !earliestModifier || earliestParse.modifiers.length > 1 || latestParse.modifiers.length > 1) {
        return false;
      }
      if (earliestModifier.amount < 0 && (!earliestModifier.snap || earliestModifier.unit === earliestModifier.snap) && (isLatestNow(latest) || latestModifier && !latestModifier.amount) && (!latestModifier || !latestModifier.snap || earliestModifier.unit === latestModifier.snap)) {
        const amount = Math.abs(earliestModifier.amount);
        const pluralKey = amount > 1 ? "plural" : "singular";
        return (0, format_exports.sprintf)((0, i18n_exports._)("Last %(amount)d %(unit)s"), {
          amount,
          unit: timeUnits[earliestModifier.unit][pluralKey]
        });
      }
      return false;
    }
    function areSameDay(a, b) {
      const aTime = a.clone().startOf("day");
      const bTime = b.clone().startOf("day");
      return aTime.isSame(bTime);
    }
    function largestDateUnit(date) {
      return find_default(["year", "month", "date"], (unit) => {
        const dateStart = date.clone().startOf(unit);
        return date.isSame(dateStart);
      });
    }
    function findSingleDateUnit(a, b) {
      if (!(isWholeDay(a) && isWholeDay(b))) {
        return null;
      }
      if (a.month() === 0 && b.month() === 0 && a.date() === 1 && b.date() === 1) {
        return "year";
      }
      if (a.year() === b.year() && a.date() === 1 && b.date() === 1 || a.year() + 1 === b.year() && b.month() === 0 && a.date() === 1 && b.date() === 1) {
        return "month";
      }
      if (a.year() === b.year() && a.month() === b.month() || a.year() === b.year() && a.month() + 1 === b.month() && b.date() === 1 || a.year() + 1 === b.year() && b.month() === 0) {
        return "date";
      }
      return null;
    }
    function createSingleUnitOnLabel(date, unit) {
      switch (unit) {
        case "year":
          return date.format("YYYY");
        case "month":
          return (0, format_exports.sprintf)((0, i18n_exports._)("%(month)s %(year)s"), {
            month: date.format("MMM"),
            year: date.format("YYYY")
          });
        default:
          return date.format("ll");
      }
    }
    function createSingleUnitThroughLabel(a, b, unit) {
      const b2 = b.subtract(1, unit === "date" ? "day" : unit);
      switch (unit) {
        case "year":
          return (0, format_exports.sprintf)((0, i18n_exports._)("%(earliestYear)s through %(latestYear)s"), {
            earliestYear: a.format("YYYY"),
            latestYear: b2.format("YYYY")
          });
        case "month":
          return (0, format_exports.sprintf)(
            (0, i18n_exports._)("%(earliestMonth)s through %(latestMonth)s, %(inYear)s"),
            {
              earliestMonth: a.format("MMM"),
              latestMonth: b2.format("MMM"),
              inYear: b2.format("YYYY")
            }
          );
        default:
          return (0, format_exports.sprintf)(
            (0, i18n_exports._)(
              "%(month)s %(earliestDayOfMonth)s through %(latestDayOfMonth)s, %(inYear)s"
            ),
            {
              month: a.format("MMM"),
              earliestDayOfMonth: a.format("D"),
              latestDayOfMonth: b2.format("D"),
              inYear: b2.format("YYYY")
            }
          );
      }
    }
    function createDateTimeLabel(date) {
      if (date.millisecond()) {
        return date.splunkFormat("llms");
      }
      if (date.second()) {
        return date.splunkFormat("lls");
      }
      return date.splunkFormat("lll");
    }
    function createTimeLabel(time) {
      if (time.millisecond()) {
        return time.splunkFormat("LTMS");
      }
      if (time.second()) {
        return time.format("LTS");
      }
      return time.format("LT");
    }
    function createTimeRangeLabel(a, b) {
      let format;
      if (a.millisecond() || b.millisecond()) {
        format = "llms";
      } else if (a.second() || b.second()) {
        format = "lls";
      } else {
        format = "lll";
      }
      return (0, format_exports.sprintf)((0, i18n_exports._)("%(earliestDateTime)s to %(latestDateTime)s"), {
        earliestDateTime: a.splunkFormat(format),
        latestDateTime: b.splunkFormat(format)
      });
    }
    function createPartOfDayLabel(a, b) {
      return (0, format_exports.sprintf)((0, i18n_exports._)("%(earliestTime)s to %(latestTime)s, %(date)s"), {
        earliestTime: createTimeLabel(a),
        latestTime: createTimeLabel(b),
        date: a.format("ll")
      });
    }
    function conformToMaxChars(label, shortLabel, maxChars) {
      return maxChars && label.length > Math.max(shortLabel.length, maxChars) ? shortLabel : label;
    }
    function createDateTimeRangeLabel(earliest, latest, maxChars) {
      const a = isISO(earliest) ? toSplunkMoment(earliest).locale(config_exports.locale || "en_US") : void 0;
      const b = isISO(latest) ? toSplunkMoment(latest).locale(config_exports.locale || "en_US") : void 0;
      if (a && b) {
        const unit = findSingleDateUnit(a, b);
        const next = unit && moment_default(a).add(1, unit === "date" ? "days" : unit);
        if (unit && next[unit]() === b[unit]()) {
          return createSingleUnitOnLabel(a, unit);
        }
        if (unit) {
          return conformToMaxChars(
            createSingleUnitThroughLabel(a, b, unit),
            (0, i18n_exports._)("Date Range"),
            maxChars
          );
        }
        if (areSameDay(a, b)) {
          return conformToMaxChars(
            createPartOfDayLabel(a, b),
            (0, i18n_exports._)("Part of a Day"),
            maxChars
          );
        }
        return conformToMaxChars(
          createTimeRangeLabel(a, b),
          (0, i18n_exports._)("Between Date-times"),
          maxChars
        );
      }
      if (a && isLatestNow(latest)) {
        const unit = largestDateUnit(a);
        const since = unit ? createSingleUnitOnLabel(a, unit) : createDateTimeLabel(a);
        const longLabel = (0, format_exports.sprintf)((0, i18n_exports._)("Since %(dateTime)s"), { dateTime: since });
        return conformToMaxChars(longLabel, (0, i18n_exports._)("Since Date-time"), maxChars);
      }
      if (isEarliestEmpty(earliest) && b) {
        const unit = largestDateUnit(b);
        const before = unit ? createSingleUnitOnLabel(b, unit) : createDateTimeLabel(b);
        const longLabel = (0, format_exports.sprintf)((0, i18n_exports._)("Before %(dateTime)s"), {
          dateTime: before
        });
        return conformToMaxChars(longLabel, (0, i18n_exports._)("Before Date-time"), maxChars);
      }
      return null;
    }
    function createAllTimeLabel(earliest, latest) {
      if (isEarliestEmpty(earliest) && isLatestNow(latest)) {
        return (0, i18n_exports._)("All time");
      }
      return false;
    }
    function createRangeLabel(earliest, latest, { presets, maxChars = 0 } = {}) {
      const earliestTrimmed = earliest.trim();
      const latestTrimmed = latest.trim();
      return createAllTimeLabel(earliestTrimmed, latestTrimmed) || presets && findPresetLabel(presets, earliestTrimmed, latestTrimmed) || createRealTimeLabel(earliestTrimmed, latestTrimmed) || createRelativeTimeLabel(earliestTrimmed, latestTrimmed) || createDateTimeRangeLabel(earliestTrimmed, latestTrimmed, maxChars) || (0, i18n_exports._)("Custom time");
    }
    function pluralize(singular, plural, numberOf) {
      if (numberOf === 0) {
        return null;
      }
      return numberOf === 1 ? singular : (0, format_exports.sprintf)(plural, { numberOf });
    }
    function formatDuration(ms) {
      if (ms <= 0) {
        return null;
      }
      const duration = moment_default.duration(ms);
      return [
        pluralize((0, i18n_exports._)("1 year"), (0, i18n_exports._)("%(numberOf)d years"), duration.years()),
        pluralize((0, i18n_exports._)("1 month"), (0, i18n_exports._)("%(numberOf)d months"), duration.months()),
        pluralize((0, i18n_exports._)("1 day"), (0, i18n_exports._)("%(numberOf)d days"), duration.days()),
        pluralize((0, i18n_exports._)("1 hour"), (0, i18n_exports._)("%(numberOf)d hours"), duration.hours()),
        pluralize((0, i18n_exports._)("1 minute"), (0, i18n_exports._)("%(numberOf)d minutes"), duration.minutes()),
        pluralize((0, i18n_exports._)("1 second"), (0, i18n_exports._)("%(numberOf)d seconds"), duration.seconds()),
        pluralize(
          (0, i18n_exports._)("1 millisecond"),
          (0, i18n_exports._)("%(numberOf)d milliseconds"),
          duration.milliseconds()
        )
      ].filter((display) => !!display).join(" ");
    }
    var parse = (time, baseTime = epochToMoment()) => {
      const parsed = parseTimeString(time);
      if (time === "" || !parsed) {
        return { error: new Error("Invalid time string"), time };
      }
      if (!parsed.isFullyParsed) {
        return {
          error: new Error("The time string could not be parsed"),
          time
        };
      }
      if (parsed.type === "iso") {
        return { error: null, iso: time, time };
      }
      if (parsed.type === "epoch") {
        return {
          error: null,
          iso: epochToMoment(parseFloat(time)).format(),
          time
        };
      }
      const date = moment_default(baseTime);
      parsed.modifiers.forEach((mod) => {
        if (mod.amount && momentUnits[mod.unit]) {
          date.add(mod.amount, momentUnits[mod.unit]);
        }
        if (mod.snap) {
          if (momentSnaps[mod.snap]) {
            date.startOf(momentSnaps[mod.snap]);
          } else if (weekDaySnaps[mod.snap] != null) {
            date.startOf(momentSnaps.w).add(
              weekDaySnaps[mod.snap],
              "d"
            );
            if (epochToMoment().isBefore(date)) {
              date.add(-1, "w");
            }
          }
        }
      });
      return { error: null, iso: date.format(), time, momentTime: date };
    };
    var defaultTimePreset = [
      { label: (0, i18n_exports._)("Today"), earliest: "@d", latest: "now" },
      { label: (0, i18n_exports._)("Week to date"), earliest: "@w0", latest: "now" },
      { label: (0, i18n_exports._)("Business week to date"), earliest: "@w1", latest: "now" },
      { label: (0, i18n_exports._)("Month to date"), earliest: "@mon", latest: "now" },
      { label: (0, i18n_exports._)("Year to date"), earliest: "@y", latest: "now" },
      { label: (0, i18n_exports._)("Yesterday"), earliest: "-1d@d", latest: "@d" },
      { label: (0, i18n_exports._)("Previous week"), earliest: "-7d@w0", latest: "@w0" },
      {
        label: (0, i18n_exports._)("Previous business week"),
        earliest: "-6d@w1",
        latest: "-1d@w6"
      },
      { label: (0, i18n_exports._)("Previous month"), earliest: "-1mon@mon", latest: "@mon" },
      { label: (0, i18n_exports._)("Previous year"), earliest: "-1y@y", latest: "@y" },
      { label: (0, i18n_exports._)("Last 15 minutes"), earliest: "-15m", latest: "now" },
      { label: (0, i18n_exports._)("Last 60 minutes"), earliest: "-60m@m", latest: "now" },
      { label: (0, i18n_exports._)("Last 4 hours"), earliest: "-4h@m", latest: "now" },
      { label: (0, i18n_exports._)("Last 24 hours"), earliest: "-24h@h", latest: "now" },
      { label: (0, i18n_exports._)("Last 7 days"), earliest: "-7d@h", latest: "now" },
      { label: (0, i18n_exports._)("Last 30 days"), earliest: "-30d@d", latest: "now" },
      { label: (0, i18n_exports._)("All time"), earliest: "0", latest: "now" }
    ];
    var defaultRealTimePreset = [
      { label: (0, i18n_exports._)("30 second window"), earliest: "rt-30s", latest: "rt" },
      { label: (0, i18n_exports._)("1 minute window"), earliest: "rt-1m", latest: "rt" },
      { label: (0, i18n_exports._)("5 minute window"), earliest: "rt-5m", latest: "rt" },
      { label: (0, i18n_exports._)("30 minute window"), earliest: "rt-30m", latest: "rt" },
      { label: (0, i18n_exports._)("1 hour window"), earliest: "rt-1h", latest: "rt" },
      { label: (0, i18n_exports._)("All time (real-time)"), earliest: "rt", latest: "rt" }
    ].concat(defaultTimePreset);
    var isAbsoluteURL = (url) => {
      return /^https?:\/\//.test(url);
    };
    var isRelativeURL = (url) => {
      return !!(url == null ? void 0 : url.length) && url[0] === "/" && !/^\/\//.test(url);
    };
    var hasWhiteSpace = (url) => {
      return /\s/g.test(url);
    };
    var isValidUrl = (url) => {
      return !hasWhiteSpace(url) && (isAbsoluteURL(url) || isRelativeURL(url));
    };
    var getWindowLocationSearch = () => window.location.search;
    var navigateToUrl = (url, newTab = false) => {
      if (newTab) {
        window.open(url, "_blank");
      } else {
        window.location.href = url;
      }
    };
    var regex = /Mac/;
    var isMac = () => {
      var _a, _b, _c, _d, _e;
      if ((_b = (_a = globalThis.navigator) == null ? void 0 : _a.userAgentData) == null ? void 0 : _b.platform) {
        return ((_d = (_c = globalThis.navigator) == null ? void 0 : _c.userAgentData) == null ? void 0 : _d.platform) === "macOS";
      }
      return regex.test(((_e = globalThis.navigator) == null ? void 0 : _e.userAgent) || "");
    };
    var mergeExpressionsStanza = ({
      expressions1 = {},
      expressions2 = {},
      mergeInfo
    }) => {
      var _a, _b, _c, _d;
      const expressions = {
        conditions: __spreadValues({}, (_a = expressions1.conditions) != null ? _a : {}),
        eval: __spreadValues({}, (_b = expressions1.eval) != null ? _b : {})
      };
      Object.entries((_c = expressions2.conditions) != null ? _c : {}).forEach(([id, def]) => {
        var _a2;
        const newDef = __spreadValues({}, def);
        if (def.name && def.name in mergeInfo.conditionNameChange) {
          newDef.name = mergeInfo.conditionNameChange[def.name];
        }
        const newId = (_a2 = mergeInfo.conditionIdChange[id]) != null ? _a2 : id;
        expressions.conditions[newId] = newDef;
      });
      Object.entries((_d = expressions2.eval) != null ? _d : {}).forEach(([id, def]) => {
        var _a2;
        const newDef = __spreadValues({}, def);
        if (def.name && def.name in mergeInfo.evalNameChange) {
          newDef.name = mergeInfo.evalNameChange[def.name];
        }
        const newId = (_a2 = mergeInfo.evalIdChange[id]) != null ? _a2 : id;
        expressions.eval[newId] = newDef;
      });
      return expressions;
    };
    var isCoordinate = (position) => typeof position.x === "number" && typeof position.y === "number";
    var updateItem = ({ id, mergeInfo }) => {
      var _a, _b;
      return (_b = (_a = mergeInfo.vizIdChange[id]) != null ? _a : mergeInfo.inputIdChange[id]) != null ? _b : id;
    };
    var updateLineConnections = ({
      item,
      mergeInfo
    }) => __spreadProps(__spreadValues({}, item), {
      position: {
        from: isCoordinate(item.position.from) ? item.position.from : __spreadProps(__spreadValues({}, item.position.from), {
          item: updateItem({ id: item.position.from.item, mergeInfo })
        }),
        to: isCoordinate(item.position.to) ? item.position.to : __spreadProps(__spreadValues({}, item.position.to), {
          item: updateItem({ id: item.position.to.item, mergeInfo })
        })
      }
    });
    var trackStructureChanges = ({
      newLayoutDefinition,
      srcLayoutStructure,
      mergeInfo
    }) => {
      srcLayoutStructure.forEach((item) => {
        const updatedItemId = updateItem({ id: item.item, mergeInfo });
        if (item.type === "line") {
          newLayoutDefinition.structure.push(__spreadProps(__spreadValues({}, updateLineConnections({ item, mergeInfo })), {
            item: updatedItemId
          }));
        } else {
          newLayoutDefinition.structure.push(__spreadProps(__spreadValues({}, item), {
            item: updatedItemId
          }));
        }
      });
    };
    var mergeLayoutStanza = ({
      layout1,
      layout2,
      mergeInfo
    }) => {
      var _a, _b;
      if (!layout1 || !layout2) {
        return layout1 != null ? layout1 : layout2;
      }
      const layout = __spreadValues({}, layout1);
      layout2 == null ? void 0 : layout2.tabs.items.forEach((tab) => {
        var _a2;
        const tabDef = __spreadProps(__spreadValues({}, tab), {
          // use new id if it has been renamed, otherwise use existing one.
          layoutId: (_a2 = mergeInfo.layoutIdChange[tab.layoutId]) != null ? _a2 : tab.layoutId
        });
        layout.tabs.items.push(tabDef);
      });
      Object.entries((_a = layout2.layoutDefinitions) != null ? _a : {}).forEach(
        ([layoutId, layoutDef]) => {
          var _a2, _b2;
          const newDef = __spreadProps(__spreadValues({}, layoutDef), {
            structure: []
          });
          if (isLayoutStructure(layoutDef.structure)) {
            trackStructureChanges({
              newLayoutDefinition: newDef,
              srcLayoutStructure: layoutDef.structure,
              mergeInfo
            });
          }
          const newId = (_a2 = mergeInfo.layoutIdChange[layoutId]) != null ? _a2 : layoutId;
          (_b2 = layout.layoutDefinitions) != null ? _b2 : layout.layoutDefinitions = {};
          layout.layoutDefinitions[newId] = newDef;
        }
      );
      (_b = layout2.globalInputs) == null ? void 0 : _b.forEach((inputId) => {
        var _a2, _b2;
        const newId = (_a2 = mergeInfo.inputIdChange[inputId]) != null ? _a2 : inputId;
        (_b2 = layout.globalInputs) == null ? void 0 : _b2.push(newId);
      });
      return layout;
    };
    var reconcileDataSourceIDs = ({
      definition,
      mergeInfo
    }) => {
      var _a;
      Object.entries((_a = definition.dataSources) != null ? _a : {}).forEach(
        ([bindingType, dsId]) => {
          const newId = mergeInfo.dsIdChange[dsId];
          if (definition.dataSources && newId) {
            definition.dataSources[bindingType] = newId;
          }
        }
      );
    };
    var reconcileEventHandlerTokens = ({
      definition,
      mergeInfo
    }) => {
      var _a;
      ((_a = definition.eventHandlers) != null ? _a : []).forEach((handlerDef) => {
        var _a2;
        const options = handlerDef == null ? void 0 : handlerDef.options;
        if (!Array.isArray(options == null ? void 0 : options.tokens)) {
          return;
        }
        const namespace = (_a2 = options.tokenNamespace) != null ? _a2 : DEFAULT_TOKEN_NAMESPACE;
        options.tokens.forEach((setToken) => {
          var _a3, _b;
          if (typeof setToken === "object" && (setToken == null ? void 0 : setToken.token)) {
            setToken.token = (_b = (_a3 = mergeInfo.tokenNameChange[namespace]) == null ? void 0 : _a3[setToken.token]) != null ? _b : setToken.token;
          }
        });
      });
    };
    var reconcileVisibilityConditions = ({
      definition,
      mergeInfo
    }) => {
      var _a, _b, _c, _d, _e, _f, _g;
      const visibilityOptions = (_a = definition.containerOptions) == null ? void 0 : _a.visibility;
      if (Array.isArray(visibilityOptions == null ? void 0 : visibilityOptions.hideConditions) || Array.isArray(visibilityOptions == null ? void 0 : visibilityOptions.conditions)) {
        const hideConditions = Array.from(
          /* @__PURE__ */ new Set([
            ...(_b = visibilityOptions.hideConditions) != null ? _b : [],
            ...(_c = visibilityOptions.conditions) != null ? _c : []
          ])
        );
        if (hideConditions.length) {
          definition.containerOptions.visibility.hideConditions = hideConditions.map(
            (id) => {
              var _a2;
              return (_a2 = mergeInfo.conditionIdChange[id]) != null ? _a2 : id;
            }
          );
        }
        (_e = (_d = definition.containerOptions) == null ? void 0 : _d.visibility) == null ? true : delete _e.conditions;
      }
      if (Array.isArray(
        (_g = (_f = definition.containerOptions) == null ? void 0 : _f.visibility) == null ? void 0 : _g.showConditions
      ) && definition.containerOptions.visibility.showConditions.length) {
        definition.containerOptions.visibility.showConditions = definition.containerOptions.visibility.showConditions.map(
          (id) => {
            var _a2;
            return (_a2 = mergeInfo.conditionIdChange[id]) != null ? _a2 : id;
          }
        );
      }
    };
    var reconcileEventHandlerLayouts = ({
      definition,
      mergeInfo
    }) => {
      var _a;
      ((_a = definition.eventHandlers) != null ? _a : []).forEach((handlerDef) => {
        var _a2;
        const options = handlerDef == null ? void 0 : handlerDef.options;
        if (typeof (options == null ? void 0 : options.tabId) !== "string") {
          return;
        }
        const newId = (_a2 = mergeInfo.layoutIdChange[options.tabId]) != null ? _a2 : options.tabId;
        options.tabId = newId;
      });
    };
    var mergeVisualizationsStanza = ({
      visualizations1 = {},
      visualizations2 = {},
      mergeInfo
    }) => {
      const visualizations = __spreadValues({}, visualizations1);
      Object.entries(visualizations2).forEach(([vizId, vizDef]) => {
        var _a;
        const newDef = __spreadValues({}, vizDef);
        if (vizDef.dataSources) {
          reconcileDataSourceIDs({ definition: newDef, mergeInfo });
        }
        if (vizDef.eventHandlers) {
          reconcileEventHandlerTokens({ definition: newDef, mergeInfo });
          reconcileEventHandlerLayouts({ definition: newDef, mergeInfo });
        }
        reconcileVisibilityConditions({ definition: newDef, mergeInfo });
        const newVizId = (_a = mergeInfo.vizIdChange[vizId]) != null ? _a : vizId;
        visualizations[newVizId] = newDef;
      });
      return visualizations;
    };
    var mergeInputsStanza = ({
      inputs1 = {},
      inputs2 = {},
      mergeInfo
    }) => {
      const inputs = __spreadValues({}, inputs1);
      Object.entries(inputs2).forEach(([inputId, inputDef]) => {
        var _a, _b, _c;
        const newDef = __spreadValues({}, inputDef);
        Object.entries((_a = inputDef.dataSources) != null ? _a : {}).forEach(
          ([bindingType, dsId]) => {
            const newId = mergeInfo.dsIdChange[dsId];
            if (newDef.dataSources && newId) {
              newDef.dataSources[bindingType] = newId;
            }
          }
        );
        const { options = {} } = newDef;
        const namespace = (_b = options.tokenNamespace) != null ? _b : DEFAULT_TOKEN_NAMESPACE;
        if (options.token && mergeInfo.tokenNameChange[namespace][options.token]) {
          options.token = mergeInfo.tokenNameChange[namespace][options.token];
        }
        reconcileVisibilityConditions({ definition: newDef, mergeInfo });
        const newInputId = (_c = mergeInfo.inputIdChange[inputId]) != null ? _c : inputId;
        inputs[newInputId] = newDef;
      });
      return inputs;
    };
    var mergeDefaultsStanza = ({
      defaults1 = {},
      defaults2 = {},
      mergeInfo
    }) => {
      var _a;
      const defaults = __spreadValues({}, defaults1);
      Object.entries((_a = defaults2.tokens) != null ? _a : {}).forEach(([namespace, tokensMap]) => {
        var _a2, _b, _c;
        (_a2 = defaults.tokens) != null ? _a2 : defaults.tokens = {};
        (_c = (_b = defaults.tokens)[namespace]) != null ? _c : _b[namespace] = {};
        if (!mergeInfo.tokenNameChange[namespace]) {
          Object.entries(tokensMap).forEach(([tokenName, tokenObj]) => {
            defaults.tokens[namespace][tokenName] = tokenObj;
          });
          return;
        }
        Object.entries(tokensMap).forEach(([tokenName, tokenObj]) => {
          var _a3;
          const newToken = (_a3 = mergeInfo.tokenNameChange[namespace][tokenName]) != null ? _a3 : tokenName;
          defaults.tokens[namespace][newToken] = tokenObj;
        });
      });
      return defaults;
    };
    var mergeDataSourceStanza = ({
      dataSources1 = {},
      dataSources2 = {},
      mergeInfo
    }) => {
      const dataSources = __spreadValues({}, dataSources1);
      Object.entries(dataSources2).forEach(([dsId, dsDef]) => {
        var _a, _b;
        const newDef = __spreadValues({}, dsDef);
        if (newDef.name && mergeInfo.dsNameChange[newDef.name]) {
          newDef.name = mergeInfo.dsNameChange[newDef.name];
        }
        const parentId = (_a = newDef.options) == null ? void 0 : _a.extend;
        if (newDef.options && parentId && mergeInfo.dsIdChange[parentId]) {
          newDef.options.extend = mergeInfo.dsIdChange[parentId];
        }
        const newDsId = (_b = mergeInfo.dsIdChange[dsId]) != null ? _b : dsId;
        dataSources[newDsId] = newDef;
      });
      return dataSources;
    };
    var createNewIds = ({
      stanza1 = {},
      stanza2 = {},
      mergeInfo,
      mergeInfoKey,
      prefix
    }) => {
      Object.keys(stanza2).forEach((itemId) => {
        if (typeof stanza1[itemId] === "undefined") {
          return;
        }
        const newId = generateId(
          prefix,
          (id) => typeof stanza1[id] !== "undefined"
        );
        mergeInfo[mergeInfoKey][itemId] = newId;
      });
    };
    var createNewDefinitionIds = ({
      definitionOne,
      definitionTwo,
      mergeInfo
    }) => {
      var _a, _b, _c, _d, _e, _f;
      createNewIds({
        stanza1: definitionOne.dataSources,
        stanza2: definitionTwo.dataSources,
        mergeInfoKey: "dsIdChange",
        prefix: "ds",
        mergeInfo
      });
      createNewIds({
        stanza1: definitionOne.visualizations,
        stanza2: definitionTwo.visualizations,
        mergeInfoKey: "vizIdChange",
        prefix: "viz",
        mergeInfo
      });
      createNewIds({
        stanza1: definitionOne.inputs,
        stanza2: definitionTwo.inputs,
        mergeInfoKey: "inputIdChange",
        prefix: "input",
        mergeInfo
      });
      createNewIds({
        stanza1: (_a = definitionOne.layout) == null ? void 0 : _a.layoutDefinitions,
        stanza2: (_b = definitionTwo.layout) == null ? void 0 : _b.layoutDefinitions,
        mergeInfoKey: "layoutIdChange",
        prefix: "layout",
        mergeInfo
      });
      createNewIds({
        stanza1: (_c = definitionOne.expressions) == null ? void 0 : _c.conditions,
        stanza2: (_d = definitionTwo.expressions) == null ? void 0 : _d.conditions,
        mergeInfoKey: "conditionIdChange",
        prefix: "condition",
        mergeInfo
      });
      createNewIds({
        stanza1: (_e = definitionOne.expressions) == null ? void 0 : _e.eval,
        stanza2: (_f = definitionTwo.expressions) == null ? void 0 : _f.eval,
        mergeInfoKey: "evalIdChange",
        prefix: "eval",
        mergeInfo
      });
    };
    var generateNewDataSourceName = ({
      dsName,
      srcDataSourceNames,
      newDataSourceNames
    }) => {
      const nameInUse = (name) => srcDataSourceNames.has(name) || newDataSourceNames.has(name);
      let dsIndex = 1;
      while (nameInUse(`${dsName}_${dsIndex}`)) {
        if (dsIndex > Number.MAX_SAFE_INTEGER) {
          throw new Error((0, i18n_exports._)("Could not generate new search name"));
        }
        dsIndex += 1;
      }
      return `${dsName}_${dsIndex}`;
    };
    var generateCopiedDataSourceName = ({
      dsName,
      dataSourceNames
    }) => {
      const copyRegex = / copy (\d+)$/;
      const pureDSName = dsName.replace(copyRegex, "");
      let newCopyIndex = 1;
      dataSourceNames.forEach((existingName) => {
        const regex2 = RegExp(copyRegex);
        const match = regex2.exec(existingName);
        const nextCopyIndex = match ? parseInt(match[1], 10) + 1 : 1;
        newCopyIndex = Math.max(newCopyIndex, nextCopyIndex);
      }, 1);
      return `${pureDSName} copy ${newCopyIndex}`;
    };
    var correctDSConflicts = ({
      initialDataSourceNames,
      incomingDataSourceNames,
      isCopy = false
    }) => {
      if (!initialDataSourceNames.length) {
        return {};
      }
      const renamedDataSources = {};
      const srcDataSourceNames = new Set(initialDataSourceNames);
      const newDataSourceNames = new Set(incomingDataSourceNames);
      incomingDataSourceNames.forEach((dsName) => {
        if (!srcDataSourceNames.has(dsName)) {
          return;
        }
        if (isCopy) {
          renamedDataSources[dsName] = generateCopiedDataSourceName({
            dsName,
            dataSourceNames: /* @__PURE__ */ new Set([
              ...srcDataSourceNames,
              ...newDataSourceNames
            ])
          });
        } else {
          renamedDataSources[dsName] = generateNewDataSourceName({
            dsName,
            srcDataSourceNames,
            newDataSourceNames
          });
        }
        newDataSourceNames.add(renamedDataSources[dsName]);
      });
      return renamedDataSources;
    };
    var getDataSourceNames = ({
      definition
    }) => {
      var _a;
      return Object.values((_a = definition.dataSources) != null ? _a : {}).map((ds) => ds.name).filter((value) => typeof value === "string");
    };
    var getExistingTokens = ({
      definition
    }) => {
      var _a, _b, _c, _d;
      const tokenList = {};
      Object.values((_a = definition.inputs) != null ? _a : {}).forEach((inputDef) => {
        var _a2, _b2;
        const { options } = inputDef;
        if (!(options == null ? void 0 : options.token)) {
          return;
        }
        const namespace = (_a2 = options.tokenNamespace) != null ? _a2 : DEFAULT_TOKEN_NAMESPACE;
        (_b2 = tokenList[namespace]) != null ? _b2 : tokenList[namespace] = /* @__PURE__ */ new Set();
        tokenList[namespace].add(options.token);
      });
      Object.entries((_c = (_b = definition.defaults) == null ? void 0 : _b.tokens) != null ? _c : {}).forEach(
        ([namespace, tokensMap]) => {
          var _a2;
          const tokenNames = Object.keys(tokensMap);
          (_a2 = tokenList[namespace]) != null ? _a2 : tokenList[namespace] = /* @__PURE__ */ new Set();
          tokenNames.forEach((tokenName) => {
            tokenList[namespace].add(tokenName);
          });
        }
      );
      Object.values((_d = definition.visualizations) != null ? _d : {}).forEach((vizDef) => {
        var _a2;
        if (!vizDef.eventHandlers) {
          return;
        }
        Object.values((_a2 = vizDef.eventHandlers) != null ? _a2 : {}).forEach((handlerDef) => {
          var _a3, _b2;
          const options = handlerDef == null ? void 0 : handlerDef.options;
          if (!Array.isArray(options == null ? void 0 : options.tokens)) {
            return;
          }
          const namespace = (_a3 = options.tokenNamespace) != null ? _a3 : DEFAULT_TOKEN_NAMESPACE;
          (_b2 = tokenList[namespace]) != null ? _b2 : tokenList[namespace] = /* @__PURE__ */ new Set();
          options.tokens.forEach((setToken) => {
            if (typeof setToken === "object" && (setToken == null ? void 0 : setToken.token)) {
              tokenList[namespace].add(setToken.token);
            }
          });
        });
      });
      return tokenList;
    };
    var generateNewToken = ({
      initialTokens,
      renamedTokens
    }) => {
      const newTokens = new Set(Object.values(renamedTokens != null ? renamedTokens : {}));
      return generateId(
        "token",
        (nextId) => initialTokens.has(nextId) || newTokens.has(nextId)
      );
    };
    var correctTokenConflicts = ({
      initialTokens,
      incomingTokens
    }) => {
      const renamedTokens = {};
      Object.entries(incomingTokens).forEach(([namespace, tokens]) => {
        var _a;
        (_a = renamedTokens[namespace]) != null ? _a : renamedTokens[namespace] = {};
        Array.from(tokens).forEach((token) => {
          renamedTokens[namespace][token] = token;
        });
      });
      Object.entries(renamedTokens).forEach(([namespace, tokens]) => {
        var _a;
        if (!((_a = initialTokens[namespace]) == null ? void 0 : _a.size)) {
          return;
        }
        Object.keys(tokens).forEach((token) => {
          var _a2;
          if (initialTokens[namespace].has(token)) {
            (_a2 = renamedTokens[namespace]) != null ? _a2 : renamedTokens[namespace] = {};
            renamedTokens[namespace][token] = generateNewToken({
              initialTokens: initialTokens[namespace],
              renamedTokens: renamedTokens[namespace]
            });
          }
        });
      });
      return renamedTokens;
    };
    var generateNewExpressionName = ({
      name,
      srcNames,
      newNames
    }) => {
      const nameInUse = (n) => srcNames.has(n) || newNames.has(n);
      let index = 1;
      while (nameInUse(`${name}_${index}`)) {
        if (index > Number.MAX_SAFE_INTEGER) {
          throw new Error((0, i18n_exports._)("Could not generate new name"));
        }
        index += 1;
      }
      return `${name}_${index}`;
    };
    var correctExpressionConflicts = ({
      definitionOne,
      definitionTwo,
      expressionType
    }) => {
      var _a, _b, _c, _d;
      const stanza = expressionType === "eval" ? "eval" : "conditions";
      const expressions1 = Object.values(
        (_b = (_a = definitionOne == null ? void 0 : definitionOne.expressions) == null ? void 0 : _a[stanza]) != null ? _b : {}
      );
      const expressions2 = Object.values(
        (_d = (_c = definitionTwo == null ? void 0 : definitionTwo.expressions) == null ? void 0 : _c[stanza]) != null ? _d : {}
      );
      if (!expressions1.length || !expressions2.length) {
        return {};
      }
      const renamedExpressions = {};
      const usedNames = new Set(expressions1.map(({ name }) => name));
      const def2Names = new Set(expressions2.map(({ name }) => name));
      expressions2.forEach(({ name }) => {
        if (usedNames.has(name)) {
          const newName = generateNewExpressionName({
            srcNames: def2Names,
            newNames: usedNames,
            name
          });
          renamedExpressions[name] = newName;
          usedNames.add(newName);
        } else {
          usedNames.add(name);
        }
      });
      return renamedExpressions;
    };
    var initializeMergeInfo = ({
      definitionOne,
      definitionTwo,
      isCopy = false
    }) => {
      var _a, _b, _c, _d, _e, _f;
      const initialTokens = getExistingTokens({ definition: definitionOne });
      const incomingTokens = getExistingTokens({ definition: definitionTwo });
      const initialDataSourceNames = getDataSourceNames({
        definition: definitionOne
      });
      const incomingDataSourceNames = getDataSourceNames({
        definition: definitionTwo
      });
      const mergeInfo = {
        dsNameChange: correctDSConflicts({
          initialDataSourceNames,
          incomingDataSourceNames,
          isCopy
        }),
        tokenNameChange: correctTokenConflicts({
          initialTokens,
          incomingTokens
        }),
        dsIdChange: {},
        inputIdChange: {},
        layoutIdChange: {},
        vizIdChange: {},
        conditionIdChange: {},
        conditionNameChange: correctExpressionConflicts({
          expressionType: "condition",
          definitionOne,
          definitionTwo
        }),
        evalIdChange: {},
        evalNameChange: correctExpressionConflicts({
          expressionType: "eval",
          definitionOne,
          definitionTwo
        })
      };
      const conditionNameChanges = Object.entries(mergeInfo.conditionNameChange);
      if (conditionNameChanges.length) {
        (_c = (_a = mergeInfo.tokenNameChange)[_b = CONDITION_TOKEN_NAMESPACE]) != null ? _c : _a[_b] = {};
        conditionNameChanges.forEach(([oldName, newName]) => {
          mergeInfo.tokenNameChange[CONDITION_TOKEN_NAMESPACE][oldName] = newName;
        });
      }
      const evalNameChanges = Object.entries(mergeInfo.evalNameChange);
      if (evalNameChanges.length) {
        (_f = (_d = mergeInfo.tokenNameChange)[_e = EVAL_TOKEN_NAMESPACE]) != null ? _f : _d[_e] = {};
        evalNameChanges.forEach(([oldName, newName]) => {
          mergeInfo.tokenNameChange[EVAL_TOKEN_NAMESPACE][oldName] = newName;
        });
      }
      createNewDefinitionIds({ definitionOne, definitionTwo, mergeInfo });
      return mergeInfo;
    };
    var appendFilterLetter = (filter) => (v) => `${v.slice(0, v.length - 1)}|${filter}$`;
    var ignoreFiltersObject = {
      h: appendFilterLetter("h"),
      u: appendFilterLetter("u"),
      s: appendFilterLetter("s"),
      v: appendFilterLetter("v"),
      n: appendFilterLetter("n")
    };
    var createTokenString = ({
      newNamespace,
      newTokenName
    }) => {
      const namespace = newNamespace === DEFAULT_TOKEN_NAMESPACE ? "" : `${newNamespace}:`;
      return `$${namespace}${newTokenName}$`;
    };
    var replaceRenamedTokens = ({
      mergeInfo,
      definition
    }) => {
      const extractedTokens = extractTokensFromObject(definition);
      const tokensToReplace = {};
      extractedTokens.forEach((token) => {
        var _a, _b, _c, _d, _e;
        let newToken = "";
        const newNamespace = mergeInfo.dsNameChange[token.namespace];
        const newTokenName = (_a = mergeInfo.tokenNameChange[token.namespace]) == null ? void 0 : _a[token.name];
        if (newNamespace) {
          newToken = createTokenString({
            newNamespace,
            newTokenName: token.name
          });
          (_c = tokensToReplace[_b = token.namespace]) != null ? _c : tokensToReplace[_b] = {};
          tokensToReplace[token.namespace][token.name] = newToken;
        } else if (newTokenName) {
          newToken = createTokenString({
            newNamespace: token.namespace,
            newTokenName
          });
        }
        if (newToken) {
          (_e = tokensToReplace[_d = token.namespace]) != null ? _e : tokensToReplace[_d] = {};
          tokensToReplace[token.namespace][token.name] = newToken;
        }
      });
      const newDef = replaceTokensForObject({
        value: definition,
        tokens: tokensToReplace,
        tokenFilters: ignoreFiltersObject
      });
      return newDef;
    };
    var mergeDashboardDefinitions = ({
      definitionOne: initialDefinition,
      definitionTwo: incomingDefinition,
      isCopy = false
    }) => {
      var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l;
      const definitionOne = (0, lodash_exports.cloneDeep)(initialDefinition);
      const migration = migrateToTabsLayout({
        definition: (0, lodash_exports.cloneDeep)(incomingDefinition)
      });
      if (!migration.success) {
        return {
          success: false,
          reason: migration.reason
        };
      }
      const mergeInfo = initializeMergeInfo({
        definitionOne,
        definitionTwo: migration.definition,
        isCopy
      });
      const definitionTwo = replaceRenamedTokens({
        definition: migration.definition,
        mergeInfo
      });
      const mergedDefinition = __spreadValues(__spreadValues({}, definitionTwo), definitionOne);
      mergedDefinition.dataSources = mergeDataSourceStanza({
        dataSources1: definitionOne.dataSources,
        dataSources2: definitionTwo.dataSources,
        mergeInfo
      });
      if (!Object.keys((_a = mergedDefinition.dataSources) != null ? _a : {}).length) {
        delete mergedDefinition.dataSources;
      }
      mergedDefinition.defaults = mergeDefaultsStanza({
        defaults1: definitionOne.defaults,
        defaults2: definitionTwo.defaults,
        mergeInfo
      });
      if (!Object.keys((_b = mergedDefinition.defaults) != null ? _b : {}).length) {
        delete mergedDefinition.defaults;
      }
      mergedDefinition.inputs = mergeInputsStanza({
        inputs1: definitionOne.inputs,
        inputs2: definitionTwo.inputs,
        mergeInfo
      });
      if (!Object.keys((_c = mergedDefinition.inputs) != null ? _c : {}).length) {
        delete mergedDefinition.inputs;
      }
      mergedDefinition.layout = mergeLayoutStanza({
        layout1: definitionOne.layout,
        layout2: definitionTwo.layout,
        mergeInfo
      });
      if (!Object.keys((_d = mergedDefinition.layout) != null ? _d : {}).length) {
        delete mergedDefinition.layout;
      }
      mergedDefinition.visualizations = mergeVisualizationsStanza({
        visualizations1: definitionOne.visualizations,
        visualizations2: definitionTwo.visualizations,
        mergeInfo
      });
      if (!Object.keys((_e = mergedDefinition.visualizations) != null ? _e : {}).length) {
        delete mergedDefinition.visualizations;
      }
      mergedDefinition.expressions = mergeExpressionsStanza({
        expressions1: definitionOne.expressions,
        expressions2: definitionTwo.expressions,
        mergeInfo
      });
      if (!Object.keys((_g = (_f = mergedDefinition.expressions) == null ? void 0 : _f.conditions) != null ? _g : {}).length) {
        (_h = mergedDefinition.expressions) == null ? true : delete _h.conditions;
      }
      if (!Object.keys((_j = (_i = mergedDefinition.expressions) == null ? void 0 : _i.eval) != null ? _j : {}).length) {
        (_k = mergedDefinition.expressions) == null ? true : delete _k.eval;
      }
      if (!Object.keys((_l = mergedDefinition.expressions) != null ? _l : {}).length) {
        delete mergedDefinition.expressions;
      }
      return { success: true, definition: mergedDefinition, mergeInfo };
    };
    var hasNoResults = (searchData) => {
      var _a, _b, _c;
      if (typeof searchData === "undefined") {
        return true;
      }
      return ((_b = (_a = searchData.meta) == null ? void 0 : _a.totalCount) != null ? _b : 0) === 0 && ((_c = searchData == null ? void 0 : searchData.meta) == null ? void 0 : _c.status) !== DS_STATUS.REFRESHING;
    };
    var processHideConditions = ({
      conditions,
      conditionResults,
      hideWhenConditions
    }) => {
      if (conditions.length !== 0) {
        return hideWhenConditions === "all-true" ? conditions.every((condId) => conditionResults[condId]) : conditions.some((condId) => conditionResults[condId]);
      }
      return void 0;
    };
    var processShowConditions = ({
      conditions,
      conditionResults,
      showWhenConditions
    }) => {
      if (conditions.length !== 0) {
        return showWhenConditions === "all-true" ? conditions.some((condId) => !conditionResults[condId]) : conditions.every((condId) => !conditionResults[condId]);
      }
      return void 0;
    };
    var shouldHideItem = ({
      itemType,
      definition,
      searchData,
      conditionResults
    }) => {
      var _a, _b, _c, _d;
      if (!definition) {
        return false;
      }
      if (itemType === "line") {
        return false;
      }
      const {
        hideWhenNoData,
        conditions = [],
        hideConditions = [],
        showConditions = [],
        hideWhenConditions,
        showWhenConditions
      } = (_b = (_a = definition.containerOptions) == null ? void 0 : _a.visibility) != null ? _b : {};
      if (!!(hideWhenNoData != null ? hideWhenNoData : definition.hideWhenNoData) && hasNoResults(searchData)) {
        return true;
      }
      if (((_c = definition.containerOptions) == null ? void 0 : _c.visibility) && "hideInViewMode" in definition.containerOptions.visibility && !!((_d = definition.containerOptions.visibility) == null ? void 0 : _d.hideInViewMode)) {
        return true;
      }
      const legacyHide = processHideConditions({
        conditions,
        hideWhenConditions,
        conditionResults
      });
      const shouldHide = processHideConditions({
        conditions: hideConditions,
        hideWhenConditions,
        conditionResults
      });
      const shouldNotShow = processShowConditions({
        conditions: showConditions,
        showWhenConditions,
        conditionResults
      });
      return !!(legacyHide || shouldHide || shouldNotShow);
    };
    var IS_SUPPORTED = {
      requestAnimationFrame: () => typeof (globalThis == null ? void 0 : globalThis.requestAnimationFrame) === "function",
      MessageChannel: () => typeof (globalThis == null ? void 0 : globalThis.MessageChannel) !== "undefined"
    };
    var UnsupportedFeatureMessage = (0, i18n_exports._)(
      "%(featureName)s is not supported in the current environment. invokeAfterPaint will not delay callback invocation"
    );
    var warnUnsupportedFeature = (0, lodash_exports.memoize)(
      (featureName) => console_default.warn((0, format_exports.sprintf)(UnsupportedFeatureMessage, { featureName }))
    );
    var isFeatureSupported = (feature) => {
      if (IS_SUPPORTED[feature]()) {
        return true;
      }
      warnUnsupportedFeature(feature);
      return false;
    };
    var invokeAfterPaint = (callback) => {
      if (!isFeatureSupported("requestAnimationFrame") || !isFeatureSupported("MessageChannel")) {
        callback();
        return noop_default;
      }
      const abortController = new AbortController();
      const handleMessage = () => {
        if (abortController.signal.aborted) {
          return;
        }
        callback();
      };
      const messageChannel = new MessageChannel();
      messageChannel.port1.onmessage = handleMessage;
      const frameHandle = requestAnimationFrame(() => {
        messageChannel.port2.postMessage(void 0);
      });
      return () => {
        abortController.abort();
        cancelAnimationFrame(frameHandle);
      };
    };
  }
});

export {
  memoize_one_esm_exports,
  init_memoize_one_esm,
  require_cookie,
  require_config,
  require_moment,
  require_cjs,
  require_chroma,
  require_parserUtils,
  require_nearley,
  require_numbro_min,
  require_dsl,
  require_deepMergeWithArrayPrimitiveOverrides,
  require_visualization_migrations,
  require_baseDifference,
  require_difference,
  require_findIndex,
  require_find,
  require_dashboard_utils
};
/*! Bundled license information:

@splunk/moment/index.js:
  (*! For license information please see index.js.LICENSE.txt *)

chroma-js/dist/chroma.cjs:
  (**
   * chroma.js - JavaScript library for color conversions
   *
   * Copyright (c) 2011-2024, Gregor Aisch
   * All rights reserved.
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are met:
   *
   * 1. Redistributions of source code must retain the above copyright notice, this
   * list of conditions and the following disclaimer.
   *
   * 2. Redistributions in binary form must reproduce the above copyright notice,
   * this list of conditions and the following disclaimer in the documentation
   * and/or other materials provided with the distribution.
   *
   * 3. The name Gregor Aisch may not be used to endorse or promote products
   * derived from this software without specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
   * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
   * DISCLAIMED. IN NO EVENT SHALL GREGOR AISCH OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
   * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
   * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
   * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
   * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
   * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   *
   * -------------------------------------------------------
   *
   * chroma.js includes colors from colorbrewer2.org, which are released under
   * the following license:
   *
   * Copyright (c) 2002 Cynthia Brewer, Mark Harrower,
   * and The Pennsylvania State University.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing,
   * software distributed under the License is distributed on an
   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
   * either express or implied. See the License for the specific
   * language governing permissions and limitations under the License.
   *
   * ------------------------------------------------------
   *
   * Named colors are taken from X11 Color Names.
   * http://www.w3.org/TR/css3-color/#svg-color
   *
   * @preserve
   *)

numbro/dist/numbro.min.js:
  (*!
  	 * Copyright (c) 2017 Benjamin Van Ryseghem<benjamin@vanryseghem.com>
  	 *
  	 * Permission is hereby granted, free of charge, to any person obtaining a copy
  	 * of this software and associated documentation files (the "Software"), to deal
  	 * in the Software without restriction, including without limitation the rights
  	 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  	 * copies of the Software, and to permit persons to whom the Software is
  	 * furnished to do so, subject to the following conditions:
  	 *
  	 * The above copyright notice and this permission notice shall be included in
  	 * all copies or substantial portions of the Software.
  	 *
  	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  	 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  	 * SOFTWARE.
  	 *)
*/
//# sourceMappingURL=chunk-XH2XD4WE.js.map
