{
  "version": 3,
  "sources": ["../../@splunk/datasource-utils/src/index.ts", "../../@splunk/datasource-utils/lodash", "../../@splunk/datasource-utils/src/DataSet.ts", "../../@splunk/datasource-utils/@splunk/dashboard-utils", "../../@splunk/datasource-utils/src/BaseChainUtils.ts", "../../@splunk/datasource-utils/src/datasource.ts", "../../@splunk/datasource-utils/src/visualization-utils.ts", "../../@splunk/datasource-utils/src/SavedSearchUtils.ts", "../../@splunk/datasource-utils/src/constants.ts", "../../@splunk/datasource-utils/@splunk/ui-utils/i18n", "../../@splunk/datasource-utils/src/SPL2Utils.ts"],
  "sourcesContent": ["export * from './DataSet';\nexport { default as DataSet } from './DataSet';\nexport * from './BaseChainUtils';\nexport * from './datasource';\nexport * from './visualization-utils';\nexport * from './SavedSearchUtils';\nexport * from './constants';\nexport * from './SPL2Utils';\n", "\nimport * as defaultImport from \"lodash\";\nexport * from \"lodash\";\nexport default ('default' in defaultImport ? defaultImport.default : defaultImport);\n", "import { isEqual, isString, zip, zipObject, findIndex } from 'lodash';\nimport type {\n    FieldObj,\n    ColumnValue,\n    RowItem,\n    JSONArray,\n    JSONCols,\n    JSONRows,\n} from '@splunk/dashboard-types';\n\nexport type Field = string | FieldObj;\n\n/**\n * @class\n * DataSet represent a set of 2 dimensional data\n */\nexport default class DataSet {\n    fields: FieldObj[];\n\n    columns: ColumnValue[][];\n\n    /**\n     * @constructor\n     * @param {Field[]} [fields= []] List of field name or field objects\n     * @param {ColumnValue[][]} [columns=[]] List of column values related to fields\n     * @returns DataSet\n     */\n    constructor(fields: Field[] = [], columns: ColumnValue[][] = []) {\n        this.fields = fields.map((field) => {\n            if (isString(field)) {\n                return {\n                    name: field,\n                };\n            }\n            return field;\n        });\n        this.columns = columns;\n    }\n\n    /**\n     * Returns a empty Dataset\n     *\n     * Examples:\n     * ```js\n     * const empty = DataSet.empty();\n     * ```\n     * @returns {DataSet} DataSet\n     * @public\n     */\n    static empty(): DataSet {\n        return new DataSet();\n    }\n\n    /**\n     * Construct a Dataset with data in json array format\n     *\n     * Examples:\n     * ```js\n     *  const dataset = DataSet.fromJSONArray(\n     *     [{ name: 'x' }, { name: 'y' }, { name: 'z' }],\n     *     [{ x: 'a', y: 4, z: 70 }, { x: 'b', y: 5, z: 80 }, { x: 'c', y: 6, z: 90 }]\n     *  );\n     * ```\n     * @param {FieldObj[]} [fields=[]] List of objects containing field names\n     * @param {RowItem[]} [results=[]] List of objects containing results for each field\n     * @returns {DataSet}\n     * @public\n     */\n    static fromJSONArray(\n        fields: FieldObj[] | null = [],\n        results: RowItem[] = []\n    ): DataSet {\n        let fieldList = fields;\n        if (fieldList == null || fieldList.length === 0) {\n            if (results.length > 0) {\n                const rowSample = results[0];\n                fieldList = Object.keys(rowSample).map((field) => ({\n                    name: field,\n                }));\n            } else {\n                fieldList = [];\n            }\n        }\n\n        const columns = fieldList.map(({ name }) =>\n            results.reduce<ColumnValue[]>((col, row) => {\n                // if a field is not present on a result entry we set it to null\n                col.push(row[name] === undefined ? null : row[name]);\n                return col;\n            }, [])\n        );\n\n        return new DataSet(fieldList, columns);\n    }\n\n    /**\n     * Construct a Dataset with data in json columns format\n     *\n     * Examples:\n     * ```js\n     *  const dataset = DataSet.fromJSONCols(\n     *     [{ name: 'x' }, { name: 'y' }, { name: 'z' }],\n     *     [['a', 'b', 'c'], [4, 5, 6], [70, 80, 90]];\n     *  );\n     * ```\n     * @param {Field[]} [fields=[]] List of fields\n     * @param {ColumnValue[][]} [columns=[]] list of column values\n     * @returns {DataSet}\n     * @public\n     */\n    static fromJSONCols(\n        fields: Field[] = [],\n        columns: ColumnValue[][] = []\n    ): DataSet {\n        return new DataSet(fields, columns);\n    }\n\n    /**\n     * Construct a Dataset with data in json rows format\n     *\n     * Examples:\n     * ```js\n     *  const dataset = DataSet.fromJSONRows(\n     *     [{ name: 'x' }, { name: 'y' }, { name: 'z' }],\n     *     [['a', 4, 70], ['b', 5, 80], ['c', 6, 90]];\n     *  );\n     * ```\n     * @param {Field[]} [fields=[]] List of fields\n     * @param {ColumnValue[][]} [columns=[]] list of column values\n     * @returns {DataSet}\n     * @public\n     */\n    static fromJSONRows(\n        fields: Field[] = [],\n        rows: ColumnValue[][] = []\n    ): DataSet {\n        return new DataSet(fields, zip(...rows));\n    }\n\n    /**\n     * Convert data to json array\n     * @return {JSONArray} data in json array format\n     * @public\n     */\n    toJSONArray(): JSONArray {\n        return {\n            fields: this.fields,\n            results: zip(...this.columns).map((row) =>\n                zipObject(\n                    this.fields.map((field) => field.name),\n                    row\n                )\n            ),\n        };\n    }\n\n    /**\n     * Convert data to json columns\n     * @return {JSONCols} data in json columns format\n     * @public\n     */\n    toJSONCols(): JSONCols {\n        const { fields, columns } = this;\n\n        return { fields, columns };\n    }\n\n    /**\n     * Convert data to json rows\n     * @return {JSONRows} data in json rows format\n     * @public\n     */\n    toJSONRows(): JSONRows {\n        return {\n            fields: this.fields,\n            rows: zip(...this.columns),\n        };\n    }\n\n    /**\n     * List all fields\n     * @return {FieldObj[]} fields array\n     * @public\n     */\n    getFields(): FieldObj[] {\n        return this.fields;\n    }\n\n    /**\n     * List data columns\n     * @return {Object} columns array\n     * @public\n     */\n    getColumns(): ColumnValue[][] {\n        return this.columns;\n    }\n\n    /**\n     *\n     * @param {String} fieldName\n     * @return {ColumnValue[]} column data\n     * @public\n     */\n    getColumnByField(fieldName: string): ColumnValue[] {\n        const index = findIndex(this.fields, ({ name }) => name === fieldName);\n        return this.columns[index];\n    }\n\n    /**\n     *\n     * @param {String} fieldName\n     * @return {Boolean}\n     * @public\n     */\n    hasField(fieldName: string): boolean {\n        return findIndex(this.fields, ({ name }) => name === fieldName) !== -1;\n    }\n\n    /**\n     * @return {Boolean} true if DataSet has no data\n     * @public\n     */\n    isEmpty(): boolean {\n        return this.columns.length === 0;\n    }\n\n    /**\n     *\n     * @param {DataSet} dataSet DataSet to compare\n     * @return {Boolean} true if another dataset is equals to current one\n     * @public\n     */\n    equals(dataSet: DataSet): boolean {\n        return (\n            isEqual(this.fields, dataSet.fields) &&\n            isEqual(this.columns, dataSet.columns)\n        );\n    }\n\n    /**\n     * Returns a slice of the dataset, useful for pagination.\n     * @param options {Object}\n     * @param options.count {Number} number of rows\n     * @param options.offset {Number} starting row index\n     * @returns {DataSet}\n     * @public\n     */\n    getPage({\n        count = 0,\n        offset = 0,\n    }: {\n        count?: number;\n        offset?: number;\n    }): DataSet {\n        const end = count <= 0 ? undefined : offset + count;\n        return DataSet.fromJSONCols(\n            this.getFields(),\n            this.getColumns().map((column) => column.slice(offset, end))\n        );\n    }\n\n    /**\n     * Get total number of rows. Note this is not affected by the pagination.\n     * @public\n     */\n    getTotalCount(): number {\n        return this.columns[0]?.length ?? 0;\n    }\n}\n", "\nimport * as defaultImport from \"@splunk/dashboard-utils\";\nexport * from \"@splunk/dashboard-utils\";\nexport default ('default' in defaultImport ? defaultImport.default : defaultImport);\n", "import { get, pickBy, some, each, uniq } from 'lodash';\nimport type {\n    ExtendableDataSourceDefinition,\n    TokenState,\n} from '@splunk/dashboard-types';\nimport type { DashboardDefinition } from '@splunk/dashboard-definition';\nimport {\n    MAX_CHAIN_LENGTH,\n    replaceTokens,\n    replaceTokensForObject,\n} from '@splunk/dashboard-utils';\n\ntype RootDataSourcesDefinition = Record<string, ExtendableDataSourceDefinition>;\n\n/**\n *\n * @param {String} dataSourceId\n * @param {Object} definition data source definition\n * @returns {Boolean}\n */\nexport const isBaseDataSource = (\n    dataSourceId: string,\n    definition: RootDataSourcesDefinition = {}\n): boolean => {\n    const dataSourceDef = definition[dataSourceId];\n\n    if (!dataSourceDef || get(dataSourceDef, ['options', 'extend'])) {\n        return false;\n    }\n    return some(\n        Object.values(definition),\n        (dsDef) => get(dsDef, ['options', 'extend']) === dataSourceId\n    );\n};\n\n/**\n *\n * @param {String} dataSourceId\n * @param {Object} definition data source definition\n * @returns {Boolean}\n */\nexport const isChainDataSource = (\n    dataSourceId: string,\n    definition: RootDataSourcesDefinition = {}\n): boolean => {\n    const dataSourceDef = definition[dataSourceId];\n    if (!dataSourceDef) {\n        return false;\n    }\n\n    return !!get(dataSourceDef, ['options', 'extend']);\n};\n\n/**\n *\n * @param {String} dataSourceId\n * @param {Object} definition data source definition\n * @returns {Object} chain data sources\n */\nexport const getChainDataSources = (\n    dataSourceId: string,\n    definition: RootDataSourcesDefinition = {}\n): RootDataSourcesDefinition => {\n    return pickBy(\n        definition,\n        (dataSourceDef) =>\n            get(dataSourceDef, ['options', 'extend']) === dataSourceId\n    );\n};\n\n/**\n *\n * @param {String} dataSourceId\n * @param {Object} definition data source definition\n * @returns {Object} parent data source definition\n */\nexport const getParentDataSource = (\n    dataSourceId: string,\n    definition: RootDataSourcesDefinition = {}\n): ExtendableDataSourceDefinition => {\n    const extend = get(definition, [\n        dataSourceId,\n        'options',\n        'extend',\n    ]) as string;\n    return definition[extend];\n};\n\n/**\n * Merge base and sub searches with pipe '|'\n * @param {String} base\n * @param {String} sub\n */\nexport const mergeSearches = (base = '', sub = ''): string =>\n    [base.replace(/\\s*\\|\\s*$/g, ''), sub.replace(/^\\s*\\|\\s*/g, '')].join(' | ');\n\n/**\n * Creates a post search query array, containing all the descendant chain searches of a base search.\n * If shouldPreRunChainSearchesWithTokens=false, excludes chain searches and descendants that use tokens\n * @param {String} baseDataSourceId\n * @param {Object} definition data source definition\n * @param {Object} parentQuery used for function recursion\n * @param {boolean} param.shouldPreRunChainSearchesWithTokens if chain searches with tokens should be added to the array\n * @returns {Array} Post Search query array\n */\nexport const createPostSearchQueryArray = (\n    baseDataSourceId: string,\n    definition: RootDataSourcesDefinition = {},\n    parentQuery = '',\n    {\n        shouldPreRunChainSearchesWithTokens = true,\n    }: { shouldPreRunChainSearchesWithTokens?: boolean } = {}\n): string[] => {\n    const baseDataSourceDef = definition[baseDataSourceId];\n\n    if (!baseDataSourceDef) {\n        return [];\n    }\n    const results: string[] = [];\n    const chainDataSources = getChainDataSources(baseDataSourceId, definition);\n\n    each(chainDataSources, (chainDataSourceDef, chainDataSourceId) => {\n        const query = get(chainDataSourceDef, ['options', 'query']) as string;\n\n        if (\n            !shouldPreRunChainSearchesWithTokens &&\n            chainDataSourceDef.usageMeta?.usesTokens\n        ) {\n            return;\n        }\n\n        const fullQuery = parentQuery\n            ? mergeSearches(parentQuery, query)\n            : query;\n\n        results.push(\n            fullQuery,\n            ...createPostSearchQueryArray(\n                chainDataSourceId,\n                definition,\n                fullQuery,\n                { shouldPreRunChainSearchesWithTokens }\n            )\n        );\n    });\n\n    return uniq(results);\n};\n\n/**\n * Reducer to filter out subset of searches that chain from the given search\n * @param {String} baseDataSourceId\n * @param {Object} definition data source definition\n * @returns {Object} baseChainModel\n */\n/* eslint no-param-reassign: [\"error\", { \"props\": true, \"ignorePropertyModificationsFor\": [\"result\"] }] */\nexport const createBaseChainModel = (\n    baseDataSourceId: string,\n    definition: RootDataSourcesDefinition = {},\n    result: RootDataSourcesDefinition = {}\n): RootDataSourcesDefinition => {\n    result[baseDataSourceId] = definition[baseDataSourceId];\n\n    const chainDataSources = getChainDataSources(baseDataSourceId, definition);\n\n    Object.keys(chainDataSources).forEach((chainDataSourceId) =>\n        createBaseChainModel(chainDataSourceId, definition, result)\n    );\n\n    return result;\n};\n\n/**\n *\n * @param {String} dataSourceId\n * @param {Object} definition ata source definition\n * @returns {String}\n */\nexport const getBaseDataSourceId = (\n    dataSourceId: string,\n    definition: RootDataSourcesDefinition = {}\n): string | null => {\n    if (isBaseDataSource(dataSourceId, definition)) {\n        return dataSourceId;\n    }\n\n    const extend = get(definition, [dataSourceId, 'options', 'extend']);\n\n    return extend ? getBaseDataSourceId(extend, definition) : null;\n};\n\ninterface DataSourceMeta {\n    savedSearchQuery?: string;\n    earliestTime?: string;\n    latestTime?: string;\n    [key: string]: unknown;\n}\n\ninterface GetCompleteSearchQueryProps {\n    definition: DashboardDefinition;\n    dataSourceId: string;\n    getMetaData?: (dataSourceId: string) => DataSourceMeta;\n    count?: number;\n    submittedTokens?: TokenState;\n}\n\n/**\n * Fetch the complete SPL search of a datasource including its ancestors\n * @param {Object} definition DashboardDefinition\n * @param {String} dataSourceId\n * @param {Function} getMetaData A method used to get the query for a saved search\n * @param {Number} count\n * @param {Object} submittedTokens to replace $tokens$ in the query with current values\n * @returns {String} SPL search query of a data source and its ancestors\n */\nexport const getCompleteSearchQuery = ({\n    definition,\n    dataSourceId,\n    getMetaData,\n    count = 0,\n    submittedTokens,\n}: GetCompleteSearchQueryProps): string => {\n    const ds = definition.getDataSource(dataSourceId);\n    // if the base search is a saved search use getMetaData to get the query\n    const rawQuery =\n        get(ds, 'type', '') === 'ds.savedSearch' && getMetaData\n            ? get(getMetaData(dataSourceId), 'savedSearchQuery', '')\n            : get(ds, 'options.query', '');\n\n    const query = submittedTokens\n        ? (replaceTokens({\n              value: rawQuery,\n              tokens: submittedTokens,\n          }) as string)\n        : rawQuery;\n\n    const parentDsId = get(ds, 'options.extend', '') as string;\n    return parentDsId && count < MAX_CHAIN_LENGTH\n        ? `${getCompleteSearchQuery({\n              definition,\n              dataSourceId: parentDsId,\n              getMetaData,\n              count: count + 1,\n              submittedTokens,\n          })} \\n| ${query.trim().replace(/^\\|\\s*/g, '')}`\n        : query;\n};\n\ninterface GetBaseTimeProps {\n    definition: DashboardDefinition;\n    dataSourceId?: string;\n    getMetaData?: (dataSourceId: string) => DataSourceMeta;\n}\n\n/**\n * Get earliest and latest query parameters of the highest ancestor in datasource chain\n * @param {Object} definition DashboardDefinition\n * @param {String} dataSourceId\n * @param {Function} getMetaData A method used to get the query for a saved search\n * @returns {Object} The search times of the base search of this datasource chain\n */\nexport const getBaseTime = ({\n    definition,\n    dataSourceId,\n    getMetaData,\n}: GetBaseTimeProps): { earliest: string; latest: string } => {\n    const defaultEarliest = '-24h@h';\n    const defaultLatest = 'now';\n\n    if (!dataSourceId) {\n        return {\n            earliest: defaultEarliest,\n            latest: defaultLatest,\n        };\n    }\n    let parentDsId = dataSourceId;\n    let highestAncestorDsId = dataSourceId;\n    let count = 0;\n    while (parentDsId && count <= MAX_CHAIN_LENGTH) {\n        highestAncestorDsId = parentDsId;\n        parentDsId = get(\n            definition.getDataSource(parentDsId),\n            'options.extend',\n            ''\n        );\n        count += 1;\n    }\n    const highestAncestorDs = definition.getDataSource(highestAncestorDsId);\n\n    // if the base search is a saved search use getMetaData to get the query\n    if (\n        highestAncestorDs &&\n        highestAncestorDs.type === 'ds.savedSearch' &&\n        getMetaData\n    ) {\n        const { earliestTime, latestTime } = getMetaData(highestAncestorDsId);\n        return {\n            earliest: earliestTime || defaultEarliest,\n            latest: latestTime || defaultLatest,\n        };\n    }\n\n    const baseSearchDefaultQueryParameters =\n        (definition.getDataSourceDefaultOptions(highestAncestorDsId)\n            ?.queryParameters ?? {}) as Record<string, string>;\n    const baseSearchQueryParameters = (highestAncestorDs?.options\n        ?.queryParameters ?? {}) as Record<string, string>;\n    return {\n        earliest:\n            baseSearchQueryParameters.earliest ??\n            baseSearchDefaultQueryParameters.earliest ??\n            defaultEarliest,\n        latest:\n            baseSearchQueryParameters.latest ??\n            baseSearchDefaultQueryParameters.latest ??\n            defaultLatest,\n    };\n};\n\ntype GetCompleteSearchQueryAndParametersProps = GetBaseTimeProps & {\n    submittedTokens?: TokenState;\n};\n\n/**\n * Fetch the complete SPL search query and query parameters of a datasource including its ancestors\n * @param {DashboardDefinition} definition DashboardDefinition\n * @param {String} dataSourceId\n * @param {Function} getMetaData A method used to get the query for a saved search\n * @param {Object} submittedTokens Tokens we use in the query\n * @returns {Object} Search options including the query and query parameters\n */\nexport const getCompleteSearchQueryAndParameters = ({\n    definition,\n    dataSourceId,\n    getMetaData,\n    submittedTokens,\n}: GetCompleteSearchQueryAndParametersProps): {\n    query?: string;\n    queryParameters?: Record<string, unknown>;\n} => {\n    if (!dataSourceId) {\n        return {};\n    }\n\n    const queryParameters = getBaseTime({\n        definition,\n        dataSourceId,\n        getMetaData,\n    });\n\n    return {\n        query: getCompleteSearchQuery({\n            definition,\n            dataSourceId,\n            getMetaData,\n            submittedTokens,\n        }),\n        queryParameters: submittedTokens\n            ? replaceTokensForObject({\n                  value: queryParameters,\n                  tokens: submittedTokens,\n              })\n            : queryParameters,\n    };\n};\n", "/* eslint-disable no-param-reassign */\nimport type { JSONCols, RequestParams } from '@splunk/dashboard-types';\nimport DataSet from './DataSet';\n\nconst emptyInitialRequestParams = {};\n\ninterface ConsumerModule {\n    config?: {\n        dataContract?: {\n            initialRequestParams?: RequestParams;\n        };\n    };\n    initialRequestParams?: RequestParams;\n}\n\nconst normalizeRequestParamsFromConsumerModule = (\n    bindingType: string,\n    consumerModule?: ConsumerModule\n): RequestParams => {\n    if (consumerModule == null) {\n        return emptyInitialRequestParams;\n    }\n\n    let initialRequestParams =\n        consumerModule.config?.dataContract?.initialRequestParams?.[\n            bindingType\n        ];\n    if (!initialRequestParams) {\n        initialRequestParams =\n            consumerModule.initialRequestParams || emptyInitialRequestParams;\n    }\n\n    return initialRequestParams as RequestParams; // NOSONAR\n};\n\n/**\n * Compute initial request params for given visualization and dataSource\n * @param {Object} config\n * @param {String} config.bindingType dataSource binding type\n * @param {Object} config.consumerModule module from preset\n * @param {Object} config.options current visualization/input options\n * @private\n */\nexport const findInitialRequestParams = ({\n    bindingType = 'primary',\n    consumerModule,\n    options = {},\n}: {\n    bindingType?: string;\n    consumerModule?: ConsumerModule;\n    options?: Record<string, unknown>;\n} = {}): RequestParams => {\n    const initialRequestParams = normalizeRequestParamsFromConsumerModule(\n        bindingType,\n        consumerModule\n    );\n\n    if (typeof initialRequestParams === 'function') {\n        return (\n            initialRequestParams as unknown as (\n                opts: Record<string, unknown>\n            ) => RequestParams\n        )(options);\n    }\n    return initialRequestParams;\n};\n\nexport const formatData = (data?: DataSet | JSONCols): JSONCols | null => {\n    if (data == null) {\n        return DataSet.empty().toJSONCols();\n    }\n    if (data.constructor === DataSet) {\n        return data.toJSONCols(); // we use json cols by default\n    }\n\n    // 'fields' and 'columns' exist in DataSet as private properties\n    if (\n        (data as unknown as JSONCols)?.fields &&\n        (data as unknown as JSONCols)?.columns\n    ) {\n        return data as unknown as JSONCols;\n    }\n    return null; // return null as invalid data\n};\n", "// Originally part of @splunk/react-visualizations-utils, this code replaces that package to consolidate things related to DataSet\nimport type {\n    BindingType,\n    DataSourceMeta,\n    SearchData,\n} from '@splunk/dashboard-types';\nimport DataSet from './DataSet';\n\nexport interface VizProps {\n    dataSources?: Record<BindingType, SearchData>;\n}\n\n/**\n * Returns a dataset instance based on data from props\n * @param {object} vizProps\n * @param {string} [dataSourceType='primary']\n * @returns {DataSet | null}\n */\nexport function getDataSet(vizProps: VizProps, dataSourceType = 'primary') {\n    const data = vizProps.dataSources?.[dataSourceType]?.data;\n    return data ? DataSet.fromJSONCols(data.fields, data.columns) : null;\n}\n\n/**\n * Returns the dataset instance for dataSourceType = 'primary'\n * @param {object} vizProps\n * @returns {DataSet | null}\n */\nexport function getPrimaryDataSet(vizProps: VizProps) {\n    return getDataSet(vizProps, 'primary');\n}\n\n/**\n * Returns the request parameters for a dataSourceType in vizProps\n * @param {object} vizProps visualization props object\n * @param {string} [dataSourceType='primary']\n * @returns {RequestParams | undefined}\n */\nexport function getRequestParams(\n    vizProps: VizProps,\n    dataSourceType = 'primary'\n) {\n    return vizProps.dataSources?.[dataSourceType]?.requestParams;\n}\n\n/**\n * Returns the request parameters for the primary data in vizProps\n * @param {object} vizProps visualization props object\n * @returns {RequestParams | undefined}\n */\nexport function getPrimaryRequestParams(vizProps: VizProps) {\n    return getRequestParams(vizProps, 'primary');\n}\n\nconst emptyMeta: DataSourceMeta = {};\n\n/**\n * Returns the meta data for a dataSourceType in vizProps\n * @param {object} vizProps visualization props object\n * @param {string} [dataSourceType='primary']\n * @returns {DataSourceMeta}\n */\nexport function getMeta(vizProps: VizProps, dataSourceType = 'primary') {\n    return vizProps.dataSources?.[dataSourceType]?.meta ?? emptyMeta;\n}\n\n/**\n * Returns the meta data for the primary data in vizProps\n * @param {object} vizProps visualization props object\n * @returns {DataSourceMeta}\n */\nexport function getPrimaryMeta(vizProps: VizProps) {\n    return getMeta(vizProps, 'primary');\n}\n", "import type { SavedSearchMetadata } from '@splunk/dashboard-types';\nimport type { SplunkSavedSearch } from '@splunk/splunk-utils/savedSearch';\n\nexport const extractMetadata = (\n    entry?: Partial<SplunkSavedSearch>\n): SavedSearchMetadata => {\n    return {\n        author: entry?.author,\n        updated: entry?.updated,\n        app: entry?.acl?.app,\n        sharing: entry?.acl?.sharing,\n        isScheduled: entry?.content?.is_scheduled,\n        nextScheduledTime: entry?.content?.next_scheduled_time,\n        savedSearchQuery: entry?.content?.search,\n        earliestTime: entry?.content?.['dispatch.earliest_time'],\n        latestTime: entry?.content?.['dispatch.latest_time'],\n        alertType: entry?.content?.alert_type,\n        alertTrack: entry?.content?.['alert.track'],\n        actions: entry?.content?.actions,\n    };\n};\n", "import type { DSStatusEnum } from '@splunk/dashboard-types';\n\nexport const DS_STATUS: DSStatusEnum = {\n    QUEUED: 'queued',\n    PARSING: 'parsing',\n    RUNNING: 'running',\n    PAUSE: 'pause',\n    FINALIZING: 'finalizing',\n    FAILED: 'failed',\n    STOPPED: 'stopped',\n    DONE: 'done',\n    CANCELED: 'canceled',\n    REFRESHING: 'refreshing',\n} as const;\n", "\nimport * as defaultImport from \"@splunk/ui-utils/i18n\";\nexport * from \"@splunk/ui-utils/i18n\";\nexport default ('default' in defaultImport ? defaultImport.default : defaultImport);\n", "import { _ } from '@splunk/ui-utils/i18n';\nimport { type RequestParams } from '@splunk/dashboard-types';\n\nconst APPS_REGEX = /^(~\\.|(\\w+\\.)+)apps(\\.[\\w-]+){1,2}$/;\nconst PRIVATE_REGEX = /^(~\\.|(\\w+\\.)+)users\\.[\\w-]+\\.apps(\\.[\\w-]+){1,2}$/;\n\n/**\n * Generates an SPL2 query from request parameters that can reference an exported view from a module\n *\n * @returns {string}\n * @private\n * @param view\n * @param namespace\n */\nexport const generateSPL2ViewQuery = (\n    view: string,\n    namespace?: string\n): string => {\n    const trimmedView = view.trim();\n    const trimmedNamespace = namespace?.trim();\n    if (!trimmedNamespace) {\n        // if no namespace, fallback to default namespace\n        return `| @spl2 | from ${trimmedView}`;\n    }\n    return `| @spl2 | from ${trimmedNamespace}.${trimmedView}`;\n};\n\nexport const stripPostProcessRequestParams = (\n    requestParams: RequestParams\n): RequestParams => {\n    const requestParamsWithoutPostprocess = { ...requestParams };\n    delete requestParamsWithoutPostprocess.search;\n    return requestParamsWithoutPostprocess;\n};\n\n/**\n * Gets the sharing from the namespace.\n *\n * Sharing is Private if namespace matches the following formats:\n * ~.users.<user_name>.apps.<app_name>\n * ~.users.<user_name>.apps.<app_name>.<module_name>\n * <some_path>.users.<user_name>.apps.<app_name>\n * <some_path>.users.<user_name>.apps.<app_name>.<module_name>\n *\n * Sharing is App if namespace matches the following formats:\n * ~.apps.<app_name>\n * ~.apps.<app_name>.<module_name>\n * <some_path>.apps.<app_name>\n * <some_path>.apps.<app_name>.<module_name>\n *\n * Sharing is Custom otherwise\n *\n * @param namespace\n */\nexport const getSharingFromNamespace = (namespace: string) => {\n    if (PRIVATE_REGEX.test(namespace)) {\n        return _('Private');\n    }\n    if (APPS_REGEX.test(namespace)) {\n        return _('App');\n    }\n    return _('Custom');\n};\n\n/**\n * Gets the app name from the namespace. Returns null if namespace is not in one of the expected formats.\n *\n * Valid shorcut formats:\n * ~.apps.<app_name>\n * ~.apps.<app_name>.<module_name>\n * ~.users.<user_name>.apps.<app_name>\n * ~.users.<user_name>.apps.<app_name>.<module_name>\n *\n * Valid absolute formats:\n * <some_path>.apps.<app_name>\n * <some_path>.apps.<app_name>.<module_name>\n * <some_path>.users.<user_name>.apps.<app_name>\n * <some_path>.users.<user_name>.apps.<app_name>.<module_name>\n *\n * @param namespace\n */\nexport const getAppFromNamespace = (namespace: string) => {\n    if (APPS_REGEX.test(namespace) || PRIVATE_REGEX.test(namespace)) {\n        const namespaceArray = namespace.split('.apps.');\n        return namespaceArray[namespaceArray.length - 1].split('.')[0];\n    }\n    return null;\n};\n"],
  "mappings": "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",
  "names": ["__toESM", "defaultImport"]
}
