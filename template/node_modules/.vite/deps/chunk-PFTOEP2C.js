import __buffer_polyfill from 'vite-plugin-node-polyfills/shims/buffer'
globalThis.Buffer = globalThis.Buffer || __buffer_polyfill
import __global_polyfill from 'vite-plugin-node-polyfills/shims/global'
globalThis.global = globalThis.global || __global_polyfill
import __process_polyfill from 'vite-plugin-node-polyfills/shims/process'
globalThis.process = globalThis.process || __process_polyfill

import {
  init_modifiers_esm,
  modifiers_esm_exports,
  require_Prose
} from "./chunk-OARYEIS3.js";
import {
  require_DotsThreeVertical
} from "./chunk-6DX5PQFN.js";
import {
  require_Plus,
  require_dashboard_layouts
} from "./chunk-FNRCM6U5.js";
import {
  require_dashboard_ui
} from "./chunk-PKQHJYV2.js";
import {
  require_List,
  require_Menu,
  require_Paragraph
} from "./chunk-A5UOW6LZ.js";
import {
  require_Dropdown
} from "./chunk-2MABM7SQ.js";
import {
  require_Popover,
  require_Tooltip,
  require_usePrevious
} from "./chunk-G6OHCFVG.js";
import {
  require_debounce,
  require_throttle
} from "./chunk-27LK67HU.js";
import {
  core_esm_exports,
  init_core_esm,
  init_sortable_esm,
  init_utilities_esm,
  require_dashboard_definition,
  require_dashboard_telemetry,
  require_dist as require_dist4,
  require_dist2 as require_dist5,
  sortable_esm_exports,
  utilities_esm_exports
} from "./chunk-AIIXJTVL.js";
import {
  require_Button,
  require_CaretSmallDown
} from "./chunk-ICO5BW3R.js";
import {
  require_Clickable,
  require_ScreenReaderContent,
  require_omit
} from "./chunk-62I7WT4R.js";
import {
  require_IconProvider,
  require_SVG
} from "./chunk-2FMSEQJ6.js";
import {
  require_mixins,
  require_themes
} from "./chunk-CHFSHVDX.js";
import {
  init_styled_components_esm,
  styled_components_esm_exports
} from "./chunk-3A7H6U64.js";
import {
  require_prop_types
} from "./chunk-QNBKYQLU.js";
import {
  require_datasource_utils
} from "./chunk-DMMSRVDK.js";
import {
  require_react_dom
} from "./chunk-5LHX6SPM.js";
import {
  require_dashboard_utils
} from "./chunk-XH2XD4WE.js";
import {
  require_format
} from "./chunk-6CXBXVKR.js";
import {
  require_id
} from "./chunk-ADRYVMRQ.js";
import {
  require_i18n
} from "./chunk-SFZFMFKO.js";
import {
  require_lodash
} from "./chunk-FUC7W543.js";
import {
  require_react
} from "./chunk-ACNULIE3.js";
import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS,
  __toESM,
  require_dist,
  require_dist2,
  require_dist3
} from "./chunk-2RF6DQJU.js";

// node_modules/ajv/dist/compile/codegen/code.js
var require_code = __commonJS({
  "node_modules/ajv/dist/compile/codegen/code.js"(exports) {
    "use strict";
    var import_dist16 = __toESM(require_dist());
    var import_dist17 = __toESM(require_dist2());
    var import_dist18 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.regexpCode = exports.getEsmExportName = exports.getProperty = exports.safeStringify = exports.stringify = exports.strConcat = exports.addCodeArg = exports.str = exports._ = exports.nil = exports._Code = exports.Name = exports.IDENTIFIER = exports._CodeOrName = void 0;
    var _CodeOrName = class {
    };
    exports._CodeOrName = _CodeOrName;
    exports.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
    var Name = class extends _CodeOrName {
      constructor(s) {
        super();
        if (!exports.IDENTIFIER.test(s))
          throw new Error("CodeGen: name must be a valid identifier");
        this.str = s;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        return false;
      }
      get names() {
        return { [this.str]: 1 };
      }
    };
    exports.Name = Name;
    var _Code = class extends _CodeOrName {
      constructor(code) {
        super();
        this._items = typeof code === "string" ? [code] : code;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        if (this._items.length > 1)
          return false;
        const item = this._items[0];
        return item === "" || item === '""';
      }
      get str() {
        var _a;
        return (_a = this._str) !== null && _a !== void 0 ? _a : this._str = this._items.reduce((s, c) => `${s}${c}`, "");
      }
      get names() {
        var _a;
        return (_a = this._names) !== null && _a !== void 0 ? _a : this._names = this._items.reduce((names, c) => {
          if (c instanceof Name)
            names[c.str] = (names[c.str] || 0) + 1;
          return names;
        }, {});
      }
    };
    exports._Code = _Code;
    exports.nil = new _Code("");
    function _(strs, ...args) {
      const code = [strs[0]];
      let i = 0;
      while (i < args.length) {
        addCodeArg(code, args[i]);
        code.push(strs[++i]);
      }
      return new _Code(code);
    }
    exports._ = _;
    var plus = new _Code("+");
    function str(strs, ...args) {
      const expr = [safeStringify(strs[0])];
      let i = 0;
      while (i < args.length) {
        expr.push(plus);
        addCodeArg(expr, args[i]);
        expr.push(plus, safeStringify(strs[++i]));
      }
      optimize(expr);
      return new _Code(expr);
    }
    exports.str = str;
    function addCodeArg(code, arg) {
      if (arg instanceof _Code)
        code.push(...arg._items);
      else if (arg instanceof Name)
        code.push(arg);
      else
        code.push(interpolate(arg));
    }
    exports.addCodeArg = addCodeArg;
    function optimize(expr) {
      let i = 1;
      while (i < expr.length - 1) {
        if (expr[i] === plus) {
          const res = mergeExprItems(expr[i - 1], expr[i + 1]);
          if (res !== void 0) {
            expr.splice(i - 1, 3, res);
            continue;
          }
          expr[i++] = "+";
        }
        i++;
      }
    }
    function mergeExprItems(a, b) {
      if (b === '""')
        return a;
      if (a === '""')
        return b;
      if (typeof a == "string") {
        if (b instanceof Name || a[a.length - 1] !== '"')
          return;
        if (typeof b != "string")
          return `${a.slice(0, -1)}${b}"`;
        if (b[0] === '"')
          return a.slice(0, -1) + b.slice(1);
        return;
      }
      if (typeof b == "string" && b[0] === '"' && !(a instanceof Name))
        return `"${a}${b.slice(1)}`;
      return;
    }
    function strConcat(c1, c2) {
      return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str`${c1}${c2}`;
    }
    exports.strConcat = strConcat;
    function interpolate(x) {
      return typeof x == "number" || typeof x == "boolean" || x === null ? x : safeStringify(Array.isArray(x) ? x.join(",") : x);
    }
    function stringify(x) {
      return new _Code(safeStringify(x));
    }
    exports.stringify = stringify;
    function safeStringify(x) {
      return JSON.stringify(x).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
    }
    exports.safeStringify = safeStringify;
    function getProperty(key2) {
      return typeof key2 == "string" && exports.IDENTIFIER.test(key2) ? new _Code(`.${key2}`) : _`[${key2}]`;
    }
    exports.getProperty = getProperty;
    function getEsmExportName(key2) {
      if (typeof key2 == "string" && exports.IDENTIFIER.test(key2)) {
        return new _Code(`${key2}`);
      }
      throw new Error(`CodeGen: invalid export name: ${key2}, use explicit $id name mapping`);
    }
    exports.getEsmExportName = getEsmExportName;
    function regexpCode(rx) {
      return new _Code(rx.toString());
    }
    exports.regexpCode = regexpCode;
  }
});

// node_modules/ajv/dist/compile/codegen/scope.js
var require_scope = __commonJS({
  "node_modules/ajv/dist/compile/codegen/scope.js"(exports) {
    "use strict";
    var import_dist16 = __toESM(require_dist());
    var import_dist17 = __toESM(require_dist2());
    var import_dist18 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ValueScope = exports.ValueScopeName = exports.Scope = exports.varKinds = exports.UsedValueState = void 0;
    var code_1 = require_code();
    var ValueError = class extends Error {
      constructor(name) {
        super(`CodeGen: "code" for ${name} not defined`);
        this.value = name.value;
      }
    };
    var UsedValueState;
    (function(UsedValueState2) {
      UsedValueState2[UsedValueState2["Started"] = 0] = "Started";
      UsedValueState2[UsedValueState2["Completed"] = 1] = "Completed";
    })(UsedValueState || (exports.UsedValueState = UsedValueState = {}));
    exports.varKinds = {
      const: new code_1.Name("const"),
      let: new code_1.Name("let"),
      var: new code_1.Name("var")
    };
    var Scope = class {
      constructor({ prefixes, parent } = {}) {
        this._names = {};
        this._prefixes = prefixes;
        this._parent = parent;
      }
      toName(nameOrPrefix) {
        return nameOrPrefix instanceof code_1.Name ? nameOrPrefix : this.name(nameOrPrefix);
      }
      name(prefix) {
        return new code_1.Name(this._newName(prefix));
      }
      _newName(prefix) {
        const ng = this._names[prefix] || this._nameGroup(prefix);
        return `${prefix}${ng.index++}`;
      }
      _nameGroup(prefix) {
        var _a, _b;
        if (((_b = (_a = this._parent) === null || _a === void 0 ? void 0 : _a._prefixes) === null || _b === void 0 ? void 0 : _b.has(prefix)) || this._prefixes && !this._prefixes.has(prefix)) {
          throw new Error(`CodeGen: prefix "${prefix}" is not allowed in this scope`);
        }
        return this._names[prefix] = { prefix, index: 0 };
      }
    };
    exports.Scope = Scope;
    var ValueScopeName = class extends code_1.Name {
      constructor(prefix, nameStr) {
        super(nameStr);
        this.prefix = prefix;
      }
      setValue(value, { property, itemIndex }) {
        this.value = value;
        this.scopePath = (0, code_1._)`.${new code_1.Name(property)}[${itemIndex}]`;
      }
    };
    exports.ValueScopeName = ValueScopeName;
    var line = (0, code_1._)`\n`;
    var ValueScope = class extends Scope {
      constructor(opts) {
        super(opts);
        this._values = {};
        this._scope = opts.scope;
        this.opts = { ...opts, _n: opts.lines ? line : code_1.nil };
      }
      get() {
        return this._scope;
      }
      name(prefix) {
        return new ValueScopeName(prefix, this._newName(prefix));
      }
      value(nameOrPrefix, value) {
        var _a;
        if (value.ref === void 0)
          throw new Error("CodeGen: ref must be passed in value");
        const name = this.toName(nameOrPrefix);
        const { prefix } = name;
        const valueKey = (_a = value.key) !== null && _a !== void 0 ? _a : value.ref;
        let vs = this._values[prefix];
        if (vs) {
          const _name = vs.get(valueKey);
          if (_name)
            return _name;
        } else {
          vs = this._values[prefix] = /* @__PURE__ */ new Map();
        }
        vs.set(valueKey, name);
        const s = this._scope[prefix] || (this._scope[prefix] = []);
        const itemIndex = s.length;
        s[itemIndex] = value.ref;
        name.setValue(value, { property: prefix, itemIndex });
        return name;
      }
      getValue(prefix, keyOrRef) {
        const vs = this._values[prefix];
        if (!vs)
          return;
        return vs.get(keyOrRef);
      }
      scopeRefs(scopeName, values = this._values) {
        return this._reduceValues(values, (name) => {
          if (name.scopePath === void 0)
            throw new Error(`CodeGen: name "${name}" has no value`);
          return (0, code_1._)`${scopeName}${name.scopePath}`;
        });
      }
      scopeCode(values = this._values, usedValues, getCode) {
        return this._reduceValues(values, (name) => {
          if (name.value === void 0)
            throw new Error(`CodeGen: name "${name}" has no value`);
          return name.value.code;
        }, usedValues, getCode);
      }
      _reduceValues(values, valueCode, usedValues = {}, getCode) {
        let code = code_1.nil;
        for (const prefix in values) {
          const vs = values[prefix];
          if (!vs)
            continue;
          const nameSet = usedValues[prefix] = usedValues[prefix] || /* @__PURE__ */ new Map();
          vs.forEach((name) => {
            if (nameSet.has(name))
              return;
            nameSet.set(name, UsedValueState.Started);
            let c = valueCode(name);
            if (c) {
              const def = this.opts.es5 ? exports.varKinds.var : exports.varKinds.const;
              code = (0, code_1._)`${code}${def} ${name} = ${c};${this.opts._n}`;
            } else if (c = getCode === null || getCode === void 0 ? void 0 : getCode(name)) {
              code = (0, code_1._)`${code}${c}${this.opts._n}`;
            } else {
              throw new ValueError(name);
            }
            nameSet.set(name, UsedValueState.Completed);
          });
        }
        return code;
      }
    };
    exports.ValueScope = ValueScope;
  }
});

// node_modules/ajv/dist/compile/codegen/index.js
var require_codegen = __commonJS({
  "node_modules/ajv/dist/compile/codegen/index.js"(exports) {
    "use strict";
    var import_dist16 = __toESM(require_dist());
    var import_dist17 = __toESM(require_dist2());
    var import_dist18 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.or = exports.and = exports.not = exports.CodeGen = exports.operators = exports.varKinds = exports.ValueScopeName = exports.ValueScope = exports.Scope = exports.Name = exports.regexpCode = exports.stringify = exports.getProperty = exports.nil = exports.strConcat = exports.str = exports._ = void 0;
    var code_1 = require_code();
    var scope_1 = require_scope();
    var code_2 = require_code();
    Object.defineProperty(exports, "_", { enumerable: true, get: function() {
      return code_2._;
    } });
    Object.defineProperty(exports, "str", { enumerable: true, get: function() {
      return code_2.str;
    } });
    Object.defineProperty(exports, "strConcat", { enumerable: true, get: function() {
      return code_2.strConcat;
    } });
    Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
      return code_2.nil;
    } });
    Object.defineProperty(exports, "getProperty", { enumerable: true, get: function() {
      return code_2.getProperty;
    } });
    Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
      return code_2.stringify;
    } });
    Object.defineProperty(exports, "regexpCode", { enumerable: true, get: function() {
      return code_2.regexpCode;
    } });
    Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
      return code_2.Name;
    } });
    var scope_2 = require_scope();
    Object.defineProperty(exports, "Scope", { enumerable: true, get: function() {
      return scope_2.Scope;
    } });
    Object.defineProperty(exports, "ValueScope", { enumerable: true, get: function() {
      return scope_2.ValueScope;
    } });
    Object.defineProperty(exports, "ValueScopeName", { enumerable: true, get: function() {
      return scope_2.ValueScopeName;
    } });
    Object.defineProperty(exports, "varKinds", { enumerable: true, get: function() {
      return scope_2.varKinds;
    } });
    exports.operators = {
      GT: new code_1._Code(">"),
      GTE: new code_1._Code(">="),
      LT: new code_1._Code("<"),
      LTE: new code_1._Code("<="),
      EQ: new code_1._Code("==="),
      NEQ: new code_1._Code("!=="),
      NOT: new code_1._Code("!"),
      OR: new code_1._Code("||"),
      AND: new code_1._Code("&&"),
      ADD: new code_1._Code("+")
    };
    var Node = class {
      optimizeNodes() {
        return this;
      }
      optimizeNames(_names, _constants) {
        return this;
      }
    };
    var Def = class extends Node {
      constructor(varKind, name, rhs) {
        super();
        this.varKind = varKind;
        this.name = name;
        this.rhs = rhs;
      }
      render({ es5, _n }) {
        const varKind = es5 ? scope_1.varKinds.var : this.varKind;
        const rhs = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
        return `${varKind} ${this.name}${rhs};` + _n;
      }
      optimizeNames(names, constants) {
        if (!names[this.name.str])
          return;
        if (this.rhs)
          this.rhs = optimizeExpr(this.rhs, names, constants);
        return this;
      }
      get names() {
        return this.rhs instanceof code_1._CodeOrName ? this.rhs.names : {};
      }
    };
    var Assign = class extends Node {
      constructor(lhs, rhs, sideEffects) {
        super();
        this.lhs = lhs;
        this.rhs = rhs;
        this.sideEffects = sideEffects;
      }
      render({ _n }) {
        return `${this.lhs} = ${this.rhs};` + _n;
      }
      optimizeNames(names, constants) {
        if (this.lhs instanceof code_1.Name && !names[this.lhs.str] && !this.sideEffects)
          return;
        this.rhs = optimizeExpr(this.rhs, names, constants);
        return this;
      }
      get names() {
        const names = this.lhs instanceof code_1.Name ? {} : { ...this.lhs.names };
        return addExprNames(names, this.rhs);
      }
    };
    var AssignOp = class extends Assign {
      constructor(lhs, op, rhs, sideEffects) {
        super(lhs, rhs, sideEffects);
        this.op = op;
      }
      render({ _n }) {
        return `${this.lhs} ${this.op}= ${this.rhs};` + _n;
      }
    };
    var Label = class extends Node {
      constructor(label) {
        super();
        this.label = label;
        this.names = {};
      }
      render({ _n }) {
        return `${this.label}:` + _n;
      }
    };
    var Break = class extends Node {
      constructor(label) {
        super();
        this.label = label;
        this.names = {};
      }
      render({ _n }) {
        const label = this.label ? ` ${this.label}` : "";
        return `break${label};` + _n;
      }
    };
    var Throw = class extends Node {
      constructor(error) {
        super();
        this.error = error;
      }
      render({ _n }) {
        return `throw ${this.error};` + _n;
      }
      get names() {
        return this.error.names;
      }
    };
    var AnyCode = class extends Node {
      constructor(code) {
        super();
        this.code = code;
      }
      render({ _n }) {
        return `${this.code};` + _n;
      }
      optimizeNodes() {
        return `${this.code}` ? this : void 0;
      }
      optimizeNames(names, constants) {
        this.code = optimizeExpr(this.code, names, constants);
        return this;
      }
      get names() {
        return this.code instanceof code_1._CodeOrName ? this.code.names : {};
      }
    };
    var ParentNode = class extends Node {
      constructor(nodes = []) {
        super();
        this.nodes = nodes;
      }
      render(opts) {
        return this.nodes.reduce((code, n) => code + n.render(opts), "");
      }
      optimizeNodes() {
        const { nodes } = this;
        let i = nodes.length;
        while (i--) {
          const n = nodes[i].optimizeNodes();
          if (Array.isArray(n))
            nodes.splice(i, 1, ...n);
          else if (n)
            nodes[i] = n;
          else
            nodes.splice(i, 1);
        }
        return nodes.length > 0 ? this : void 0;
      }
      optimizeNames(names, constants) {
        const { nodes } = this;
        let i = nodes.length;
        while (i--) {
          const n = nodes[i];
          if (n.optimizeNames(names, constants))
            continue;
          subtractNames(names, n.names);
          nodes.splice(i, 1);
        }
        return nodes.length > 0 ? this : void 0;
      }
      get names() {
        return this.nodes.reduce((names, n) => addNames(names, n.names), {});
      }
    };
    var BlockNode = class extends ParentNode {
      render(opts) {
        return "{" + opts._n + super.render(opts) + "}" + opts._n;
      }
    };
    var Root = class extends ParentNode {
    };
    var Else = class extends BlockNode {
    };
    Else.kind = "else";
    var If = class _If extends BlockNode {
      constructor(condition, nodes) {
        super(nodes);
        this.condition = condition;
      }
      render(opts) {
        let code = `if(${this.condition})` + super.render(opts);
        if (this.else)
          code += "else " + this.else.render(opts);
        return code;
      }
      optimizeNodes() {
        super.optimizeNodes();
        const cond = this.condition;
        if (cond === true)
          return this.nodes;
        let e = this.else;
        if (e) {
          const ns = e.optimizeNodes();
          e = this.else = Array.isArray(ns) ? new Else(ns) : ns;
        }
        if (e) {
          if (cond === false)
            return e instanceof _If ? e : e.nodes;
          if (this.nodes.length)
            return this;
          return new _If(not(cond), e instanceof _If ? [e] : e.nodes);
        }
        if (cond === false || !this.nodes.length)
          return void 0;
        return this;
      }
      optimizeNames(names, constants) {
        var _a;
        this.else = (_a = this.else) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants);
        if (!(super.optimizeNames(names, constants) || this.else))
          return;
        this.condition = optimizeExpr(this.condition, names, constants);
        return this;
      }
      get names() {
        const names = super.names;
        addExprNames(names, this.condition);
        if (this.else)
          addNames(names, this.else.names);
        return names;
      }
    };
    If.kind = "if";
    var For = class extends BlockNode {
    };
    For.kind = "for";
    var ForLoop = class extends For {
      constructor(iteration) {
        super();
        this.iteration = iteration;
      }
      render(opts) {
        return `for(${this.iteration})` + super.render(opts);
      }
      optimizeNames(names, constants) {
        if (!super.optimizeNames(names, constants))
          return;
        this.iteration = optimizeExpr(this.iteration, names, constants);
        return this;
      }
      get names() {
        return addNames(super.names, this.iteration.names);
      }
    };
    var ForRange = class extends For {
      constructor(varKind, name, from, to) {
        super();
        this.varKind = varKind;
        this.name = name;
        this.from = from;
        this.to = to;
      }
      render(opts) {
        const varKind = opts.es5 ? scope_1.varKinds.var : this.varKind;
        const { name, from, to } = this;
        return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts);
      }
      get names() {
        const names = addExprNames(super.names, this.from);
        return addExprNames(names, this.to);
      }
    };
    var ForIter = class extends For {
      constructor(loop, varKind, name, iterable) {
        super();
        this.loop = loop;
        this.varKind = varKind;
        this.name = name;
        this.iterable = iterable;
      }
      render(opts) {
        return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts);
      }
      optimizeNames(names, constants) {
        if (!super.optimizeNames(names, constants))
          return;
        this.iterable = optimizeExpr(this.iterable, names, constants);
        return this;
      }
      get names() {
        return addNames(super.names, this.iterable.names);
      }
    };
    var Func = class extends BlockNode {
      constructor(name, args, async) {
        super();
        this.name = name;
        this.args = args;
        this.async = async;
      }
      render(opts) {
        const _async = this.async ? "async " : "";
        return `${_async}function ${this.name}(${this.args})` + super.render(opts);
      }
    };
    Func.kind = "func";
    var Return = class extends ParentNode {
      render(opts) {
        return "return " + super.render(opts);
      }
    };
    Return.kind = "return";
    var Try = class extends BlockNode {
      render(opts) {
        let code = "try" + super.render(opts);
        if (this.catch)
          code += this.catch.render(opts);
        if (this.finally)
          code += this.finally.render(opts);
        return code;
      }
      optimizeNodes() {
        var _a, _b;
        super.optimizeNodes();
        (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNodes();
        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNodes();
        return this;
      }
      optimizeNames(names, constants) {
        var _a, _b;
        super.optimizeNames(names, constants);
        (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants);
        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNames(names, constants);
        return this;
      }
      get names() {
        const names = super.names;
        if (this.catch)
          addNames(names, this.catch.names);
        if (this.finally)
          addNames(names, this.finally.names);
        return names;
      }
    };
    var Catch = class extends BlockNode {
      constructor(error) {
        super();
        this.error = error;
      }
      render(opts) {
        return `catch(${this.error})` + super.render(opts);
      }
    };
    Catch.kind = "catch";
    var Finally = class extends BlockNode {
      render(opts) {
        return "finally" + super.render(opts);
      }
    };
    Finally.kind = "finally";
    var CodeGen = class {
      constructor(extScope, opts = {}) {
        this._values = {};
        this._blockStarts = [];
        this._constants = {};
        this.opts = { ...opts, _n: opts.lines ? "\n" : "" };
        this._extScope = extScope;
        this._scope = new scope_1.Scope({ parent: extScope });
        this._nodes = [new Root()];
      }
      toString() {
        return this._root.render(this.opts);
      }
      // returns unique name in the internal scope
      name(prefix) {
        return this._scope.name(prefix);
      }
      // reserves unique name in the external scope
      scopeName(prefix) {
        return this._extScope.name(prefix);
      }
      // reserves unique name in the external scope and assigns value to it
      scopeValue(prefixOrName, value) {
        const name = this._extScope.value(prefixOrName, value);
        const vs = this._values[name.prefix] || (this._values[name.prefix] = /* @__PURE__ */ new Set());
        vs.add(name);
        return name;
      }
      getScopeValue(prefix, keyOrRef) {
        return this._extScope.getValue(prefix, keyOrRef);
      }
      // return code that assigns values in the external scope to the names that are used internally
      // (same names that were returned by gen.scopeName or gen.scopeValue)
      scopeRefs(scopeName) {
        return this._extScope.scopeRefs(scopeName, this._values);
      }
      scopeCode() {
        return this._extScope.scopeCode(this._values);
      }
      _def(varKind, nameOrPrefix, rhs, constant) {
        const name = this._scope.toName(nameOrPrefix);
        if (rhs !== void 0 && constant)
          this._constants[name.str] = rhs;
        this._leafNode(new Def(varKind, name, rhs));
        return name;
      }
      // `const` declaration (`var` in es5 mode)
      const(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);
      }
      // `let` declaration with optional assignment (`var` in es5 mode)
      let(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);
      }
      // `var` declaration with optional assignment
      var(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);
      }
      // assignment code
      assign(lhs, rhs, sideEffects) {
        return this._leafNode(new Assign(lhs, rhs, sideEffects));
      }
      // `+=` code
      add(lhs, rhs) {
        return this._leafNode(new AssignOp(lhs, exports.operators.ADD, rhs));
      }
      // appends passed SafeExpr to code or executes Block
      code(c) {
        if (typeof c == "function")
          c();
        else if (c !== code_1.nil)
          this._leafNode(new AnyCode(c));
        return this;
      }
      // returns code for object literal for the passed argument list of key-value pairs
      object(...keyValues) {
        const code = ["{"];
        for (const [key2, value] of keyValues) {
          if (code.length > 1)
            code.push(",");
          code.push(key2);
          if (key2 !== value || this.opts.es5) {
            code.push(":");
            (0, code_1.addCodeArg)(code, value);
          }
        }
        code.push("}");
        return new code_1._Code(code);
      }
      // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
      if(condition, thenBody, elseBody) {
        this._blockNode(new If(condition));
        if (thenBody && elseBody) {
          this.code(thenBody).else().code(elseBody).endIf();
        } else if (thenBody) {
          this.code(thenBody).endIf();
        } else if (elseBody) {
          throw new Error('CodeGen: "else" body without "then" body');
        }
        return this;
      }
      // `else if` clause - invalid without `if` or after `else` clauses
      elseIf(condition) {
        return this._elseNode(new If(condition));
      }
      // `else` clause - only valid after `if` or `else if` clauses
      else() {
        return this._elseNode(new Else());
      }
      // end `if` statement (needed if gen.if was used only with condition)
      endIf() {
        return this._endBlockNode(If, Else);
      }
      _for(node, forBody) {
        this._blockNode(node);
        if (forBody)
          this.code(forBody).endFor();
        return this;
      }
      // a generic `for` clause (or statement if `forBody` is passed)
      for(iteration, forBody) {
        return this._for(new ForLoop(iteration), forBody);
      }
      // `for` statement for a range of values
      forRange(nameOrPrefix, from, to, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let) {
        const name = this._scope.toName(nameOrPrefix);
        return this._for(new ForRange(varKind, name, from, to), () => forBody(name));
      }
      // `for-of` statement (in es5 mode replace with a normal for loop)
      forOf(nameOrPrefix, iterable, forBody, varKind = scope_1.varKinds.const) {
        const name = this._scope.toName(nameOrPrefix);
        if (this.opts.es5) {
          const arr = iterable instanceof code_1.Name ? iterable : this.var("_arr", iterable);
          return this.forRange("_i", 0, (0, code_1._)`${arr}.length`, (i) => {
            this.var(name, (0, code_1._)`${arr}[${i}]`);
            forBody(name);
          });
        }
        return this._for(new ForIter("of", varKind, name, iterable), () => forBody(name));
      }
      // `for-in` statement.
      // With option `ownProperties` replaced with a `for-of` loop for object keys
      forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const) {
        if (this.opts.ownProperties) {
          return this.forOf(nameOrPrefix, (0, code_1._)`Object.keys(${obj})`, forBody);
        }
        const name = this._scope.toName(nameOrPrefix);
        return this._for(new ForIter("in", varKind, name, obj), () => forBody(name));
      }
      // end `for` loop
      endFor() {
        return this._endBlockNode(For);
      }
      // `label` statement
      label(label) {
        return this._leafNode(new Label(label));
      }
      // `break` statement
      break(label) {
        return this._leafNode(new Break(label));
      }
      // `return` statement
      return(value) {
        const node = new Return();
        this._blockNode(node);
        this.code(value);
        if (node.nodes.length !== 1)
          throw new Error('CodeGen: "return" should have one node');
        return this._endBlockNode(Return);
      }
      // `try` statement
      try(tryBody, catchCode, finallyCode) {
        if (!catchCode && !finallyCode)
          throw new Error('CodeGen: "try" without "catch" and "finally"');
        const node = new Try();
        this._blockNode(node);
        this.code(tryBody);
        if (catchCode) {
          const error = this.name("e");
          this._currNode = node.catch = new Catch(error);
          catchCode(error);
        }
        if (finallyCode) {
          this._currNode = node.finally = new Finally();
          this.code(finallyCode);
        }
        return this._endBlockNode(Catch, Finally);
      }
      // `throw` statement
      throw(error) {
        return this._leafNode(new Throw(error));
      }
      // start self-balancing block
      block(body, nodeCount) {
        this._blockStarts.push(this._nodes.length);
        if (body)
          this.code(body).endBlock(nodeCount);
        return this;
      }
      // end the current self-balancing block
      endBlock(nodeCount) {
        const len = this._blockStarts.pop();
        if (len === void 0)
          throw new Error("CodeGen: not in self-balancing block");
        const toClose = this._nodes.length - len;
        if (toClose < 0 || nodeCount !== void 0 && toClose !== nodeCount) {
          throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);
        }
        this._nodes.length = len;
        return this;
      }
      // `function` heading (or definition if funcBody is passed)
      func(name, args = code_1.nil, async, funcBody) {
        this._blockNode(new Func(name, args, async));
        if (funcBody)
          this.code(funcBody).endFunc();
        return this;
      }
      // end function definition
      endFunc() {
        return this._endBlockNode(Func);
      }
      optimize(n = 1) {
        while (n-- > 0) {
          this._root.optimizeNodes();
          this._root.optimizeNames(this._root.names, this._constants);
        }
      }
      _leafNode(node) {
        this._currNode.nodes.push(node);
        return this;
      }
      _blockNode(node) {
        this._currNode.nodes.push(node);
        this._nodes.push(node);
      }
      _endBlockNode(N1, N2) {
        const n = this._currNode;
        if (n instanceof N1 || N2 && n instanceof N2) {
          this._nodes.pop();
          return this;
        }
        throw new Error(`CodeGen: not in block "${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}"`);
      }
      _elseNode(node) {
        const n = this._currNode;
        if (!(n instanceof If)) {
          throw new Error('CodeGen: "else" without "if"');
        }
        this._currNode = n.else = node;
        return this;
      }
      get _root() {
        return this._nodes[0];
      }
      get _currNode() {
        const ns = this._nodes;
        return ns[ns.length - 1];
      }
      set _currNode(node) {
        const ns = this._nodes;
        ns[ns.length - 1] = node;
      }
    };
    exports.CodeGen = CodeGen;
    function addNames(names, from) {
      for (const n in from)
        names[n] = (names[n] || 0) + (from[n] || 0);
      return names;
    }
    function addExprNames(names, from) {
      return from instanceof code_1._CodeOrName ? addNames(names, from.names) : names;
    }
    function optimizeExpr(expr, names, constants) {
      if (expr instanceof code_1.Name)
        return replaceName(expr);
      if (!canOptimize(expr))
        return expr;
      return new code_1._Code(expr._items.reduce((items, c) => {
        if (c instanceof code_1.Name)
          c = replaceName(c);
        if (c instanceof code_1._Code)
          items.push(...c._items);
        else
          items.push(c);
        return items;
      }, []));
      function replaceName(n) {
        const c = constants[n.str];
        if (c === void 0 || names[n.str] !== 1)
          return n;
        delete names[n.str];
        return c;
      }
      function canOptimize(e) {
        return e instanceof code_1._Code && e._items.some((c) => c instanceof code_1.Name && names[c.str] === 1 && constants[c.str] !== void 0);
      }
    }
    function subtractNames(names, from) {
      for (const n in from)
        names[n] = (names[n] || 0) - (from[n] || 0);
    }
    function not(x) {
      return typeof x == "boolean" || typeof x == "number" || x === null ? !x : (0, code_1._)`!${par(x)}`;
    }
    exports.not = not;
    var andCode = mappend(exports.operators.AND);
    function and(...args) {
      return args.reduce(andCode);
    }
    exports.and = and;
    var orCode = mappend(exports.operators.OR);
    function or(...args) {
      return args.reduce(orCode);
    }
    exports.or = or;
    function mappend(op) {
      return (x, y) => x === code_1.nil ? y : y === code_1.nil ? x : (0, code_1._)`${par(x)} ${op} ${par(y)}`;
    }
    function par(x) {
      return x instanceof code_1.Name ? x : (0, code_1._)`(${x})`;
    }
  }
});

// node_modules/ajv/dist/compile/util.js
var require_util = __commonJS({
  "node_modules/ajv/dist/compile/util.js"(exports) {
    "use strict";
    var import_dist16 = __toESM(require_dist());
    var import_dist17 = __toESM(require_dist2());
    var import_dist18 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.checkStrictMode = exports.getErrorPath = exports.Type = exports.useFunc = exports.setEvaluated = exports.evaluatedPropsToName = exports.mergeEvaluated = exports.eachItem = exports.unescapeJsonPointer = exports.escapeJsonPointer = exports.escapeFragment = exports.unescapeFragment = exports.schemaRefOrVal = exports.schemaHasRulesButRef = exports.schemaHasRules = exports.checkUnknownRules = exports.alwaysValidSchema = exports.toHash = void 0;
    var codegen_1 = require_codegen();
    var code_1 = require_code();
    function toHash(arr) {
      const hash = {};
      for (const item of arr)
        hash[item] = true;
      return hash;
    }
    exports.toHash = toHash;
    function alwaysValidSchema(it, schema) {
      if (typeof schema == "boolean")
        return schema;
      if (Object.keys(schema).length === 0)
        return true;
      checkUnknownRules(it, schema);
      return !schemaHasRules(schema, it.self.RULES.all);
    }
    exports.alwaysValidSchema = alwaysValidSchema;
    function checkUnknownRules(it, schema = it.schema) {
      const { opts, self } = it;
      if (!opts.strictSchema)
        return;
      if (typeof schema === "boolean")
        return;
      const rules = self.RULES.keywords;
      for (const key2 in schema) {
        if (!rules[key2])
          checkStrictMode(it, `unknown keyword: "${key2}"`);
      }
    }
    exports.checkUnknownRules = checkUnknownRules;
    function schemaHasRules(schema, rules) {
      if (typeof schema == "boolean")
        return !schema;
      for (const key2 in schema)
        if (rules[key2])
          return true;
      return false;
    }
    exports.schemaHasRules = schemaHasRules;
    function schemaHasRulesButRef(schema, RULES) {
      if (typeof schema == "boolean")
        return !schema;
      for (const key2 in schema)
        if (key2 !== "$ref" && RULES.all[key2])
          return true;
      return false;
    }
    exports.schemaHasRulesButRef = schemaHasRulesButRef;
    function schemaRefOrVal({ topSchemaRef, schemaPath }, schema, keyword, $data) {
      if (!$data) {
        if (typeof schema == "number" || typeof schema == "boolean")
          return schema;
        if (typeof schema == "string")
          return (0, codegen_1._)`${schema}`;
      }
      return (0, codegen_1._)`${topSchemaRef}${schemaPath}${(0, codegen_1.getProperty)(keyword)}`;
    }
    exports.schemaRefOrVal = schemaRefOrVal;
    function unescapeFragment(str) {
      return unescapeJsonPointer(decodeURIComponent(str));
    }
    exports.unescapeFragment = unescapeFragment;
    function escapeFragment(str) {
      return encodeURIComponent(escapeJsonPointer(str));
    }
    exports.escapeFragment = escapeFragment;
    function escapeJsonPointer(str) {
      if (typeof str == "number")
        return `${str}`;
      return str.replace(/~/g, "~0").replace(/\//g, "~1");
    }
    exports.escapeJsonPointer = escapeJsonPointer;
    function unescapeJsonPointer(str) {
      return str.replace(/~1/g, "/").replace(/~0/g, "~");
    }
    exports.unescapeJsonPointer = unescapeJsonPointer;
    function eachItem(xs, f) {
      if (Array.isArray(xs)) {
        for (const x of xs)
          f(x);
      } else {
        f(xs);
      }
    }
    exports.eachItem = eachItem;
    function makeMergeEvaluated({ mergeNames, mergeToName, mergeValues, resultToName }) {
      return (gen, from, to, toName) => {
        const res = to === void 0 ? from : to instanceof codegen_1.Name ? (from instanceof codegen_1.Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to) : from instanceof codegen_1.Name ? (mergeToName(gen, to, from), from) : mergeValues(from, to);
        return toName === codegen_1.Name && !(res instanceof codegen_1.Name) ? resultToName(gen, res) : res;
      };
    }
    exports.mergeEvaluated = {
      props: makeMergeEvaluated({
        mergeNames: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true && ${from} !== undefined`, () => {
          gen.if((0, codegen_1._)`${from} === true`, () => gen.assign(to, true), () => gen.assign(to, (0, codegen_1._)`${to} || {}`).code((0, codegen_1._)`Object.assign(${to}, ${from})`));
        }),
        mergeToName: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true`, () => {
          if (from === true) {
            gen.assign(to, true);
          } else {
            gen.assign(to, (0, codegen_1._)`${to} || {}`);
            setEvaluated(gen, to, from);
          }
        }),
        mergeValues: (from, to) => from === true ? true : { ...from, ...to },
        resultToName: evaluatedPropsToName
      }),
      items: makeMergeEvaluated({
        mergeNames: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true && ${from} !== undefined`, () => gen.assign(to, (0, codegen_1._)`${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)),
        mergeToName: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true`, () => gen.assign(to, from === true ? true : (0, codegen_1._)`${to} > ${from} ? ${to} : ${from}`)),
        mergeValues: (from, to) => from === true ? true : Math.max(from, to),
        resultToName: (gen, items) => gen.var("items", items)
      })
    };
    function evaluatedPropsToName(gen, ps) {
      if (ps === true)
        return gen.var("props", true);
      const props = gen.var("props", (0, codegen_1._)`{}`);
      if (ps !== void 0)
        setEvaluated(gen, props, ps);
      return props;
    }
    exports.evaluatedPropsToName = evaluatedPropsToName;
    function setEvaluated(gen, props, ps) {
      Object.keys(ps).forEach((p) => gen.assign((0, codegen_1._)`${props}${(0, codegen_1.getProperty)(p)}`, true));
    }
    exports.setEvaluated = setEvaluated;
    var snippets = {};
    function useFunc(gen, f) {
      return gen.scopeValue("func", {
        ref: f,
        code: snippets[f.code] || (snippets[f.code] = new code_1._Code(f.code))
      });
    }
    exports.useFunc = useFunc;
    var Type;
    (function(Type2) {
      Type2[Type2["Num"] = 0] = "Num";
      Type2[Type2["Str"] = 1] = "Str";
    })(Type || (exports.Type = Type = {}));
    function getErrorPath(dataProp, dataPropType, jsPropertySyntax) {
      if (dataProp instanceof codegen_1.Name) {
        const isNumber = dataPropType === Type.Num;
        return jsPropertySyntax ? isNumber ? (0, codegen_1._)`"[" + ${dataProp} + "]"` : (0, codegen_1._)`"['" + ${dataProp} + "']"` : isNumber ? (0, codegen_1._)`"/" + ${dataProp}` : (0, codegen_1._)`"/" + ${dataProp}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
      }
      return jsPropertySyntax ? (0, codegen_1.getProperty)(dataProp).toString() : "/" + escapeJsonPointer(dataProp);
    }
    exports.getErrorPath = getErrorPath;
    function checkStrictMode(it, msg, mode = it.opts.strictSchema) {
      if (!mode)
        return;
      msg = `strict mode: ${msg}`;
      if (mode === true)
        throw new Error(msg);
      it.self.logger.warn(msg);
    }
    exports.checkStrictMode = checkStrictMode;
  }
});

// node_modules/ajv/dist/compile/names.js
var require_names = __commonJS({
  "node_modules/ajv/dist/compile/names.js"(exports) {
    "use strict";
    var import_dist16 = __toESM(require_dist());
    var import_dist17 = __toESM(require_dist2());
    var import_dist18 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var names = {
      // validation function arguments
      data: new codegen_1.Name("data"),
      // data passed to validation function
      // args passed from referencing schema
      valCxt: new codegen_1.Name("valCxt"),
      // validation/data context - should not be used directly, it is destructured to the names below
      instancePath: new codegen_1.Name("instancePath"),
      parentData: new codegen_1.Name("parentData"),
      parentDataProperty: new codegen_1.Name("parentDataProperty"),
      rootData: new codegen_1.Name("rootData"),
      // root data - same as the data passed to the first/top validation function
      dynamicAnchors: new codegen_1.Name("dynamicAnchors"),
      // used to support recursiveRef and dynamicRef
      // function scoped variables
      vErrors: new codegen_1.Name("vErrors"),
      // null or array of validation errors
      errors: new codegen_1.Name("errors"),
      // counter of validation errors
      this: new codegen_1.Name("this"),
      // "globals"
      self: new codegen_1.Name("self"),
      scope: new codegen_1.Name("scope"),
      // JTD serialize/parse name for JSON string and position
      json: new codegen_1.Name("json"),
      jsonPos: new codegen_1.Name("jsonPos"),
      jsonLen: new codegen_1.Name("jsonLen"),
      jsonPart: new codegen_1.Name("jsonPart")
    };
    exports.default = names;
  }
});

// node_modules/ajv/dist/compile/errors.js
var require_errors = __commonJS({
  "node_modules/ajv/dist/compile/errors.js"(exports) {
    "use strict";
    var import_dist16 = __toESM(require_dist());
    var import_dist17 = __toESM(require_dist2());
    var import_dist18 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.extendErrors = exports.resetErrorsCount = exports.reportExtraError = exports.reportError = exports.keyword$DataError = exports.keywordError = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var names_1 = require_names();
    exports.keywordError = {
      message: ({ keyword }) => (0, codegen_1.str)`must pass "${keyword}" keyword validation`
    };
    exports.keyword$DataError = {
      message: ({ keyword, schemaType }) => schemaType ? (0, codegen_1.str)`"${keyword}" keyword must be ${schemaType} ($data)` : (0, codegen_1.str)`"${keyword}" keyword is invalid ($data)`
    };
    function reportError(cxt, error = exports.keywordError, errorPaths, overrideAllErrors) {
      const { it } = cxt;
      const { gen, compositeRule, allErrors } = it;
      const errObj = errorObjectCode(cxt, error, errorPaths);
      if (overrideAllErrors !== null && overrideAllErrors !== void 0 ? overrideAllErrors : compositeRule || allErrors) {
        addError(gen, errObj);
      } else {
        returnErrors(it, (0, codegen_1._)`[${errObj}]`);
      }
    }
    exports.reportError = reportError;
    function reportExtraError(cxt, error = exports.keywordError, errorPaths) {
      const { it } = cxt;
      const { gen, compositeRule, allErrors } = it;
      const errObj = errorObjectCode(cxt, error, errorPaths);
      addError(gen, errObj);
      if (!(compositeRule || allErrors)) {
        returnErrors(it, names_1.default.vErrors);
      }
    }
    exports.reportExtraError = reportExtraError;
    function resetErrorsCount(gen, errsCount) {
      gen.assign(names_1.default.errors, errsCount);
      gen.if((0, codegen_1._)`${names_1.default.vErrors} !== null`, () => gen.if(errsCount, () => gen.assign((0, codegen_1._)`${names_1.default.vErrors}.length`, errsCount), () => gen.assign(names_1.default.vErrors, null)));
    }
    exports.resetErrorsCount = resetErrorsCount;
    function extendErrors({ gen, keyword, schemaValue, data, errsCount, it }) {
      if (errsCount === void 0)
        throw new Error("ajv implementation error");
      const err = gen.name("err");
      gen.forRange("i", errsCount, names_1.default.errors, (i) => {
        gen.const(err, (0, codegen_1._)`${names_1.default.vErrors}[${i}]`);
        gen.if((0, codegen_1._)`${err}.instancePath === undefined`, () => gen.assign((0, codegen_1._)`${err}.instancePath`, (0, codegen_1.strConcat)(names_1.default.instancePath, it.errorPath)));
        gen.assign((0, codegen_1._)`${err}.schemaPath`, (0, codegen_1.str)`${it.errSchemaPath}/${keyword}`);
        if (it.opts.verbose) {
          gen.assign((0, codegen_1._)`${err}.schema`, schemaValue);
          gen.assign((0, codegen_1._)`${err}.data`, data);
        }
      });
    }
    exports.extendErrors = extendErrors;
    function addError(gen, errObj) {
      const err = gen.const("err", errObj);
      gen.if((0, codegen_1._)`${names_1.default.vErrors} === null`, () => gen.assign(names_1.default.vErrors, (0, codegen_1._)`[${err}]`), (0, codegen_1._)`${names_1.default.vErrors}.push(${err})`);
      gen.code((0, codegen_1._)`${names_1.default.errors}++`);
    }
    function returnErrors(it, errs) {
      const { gen, validateName, schemaEnv } = it;
      if (schemaEnv.$async) {
        gen.throw((0, codegen_1._)`new ${it.ValidationError}(${errs})`);
      } else {
        gen.assign((0, codegen_1._)`${validateName}.errors`, errs);
        gen.return(false);
      }
    }
    var E = {
      keyword: new codegen_1.Name("keyword"),
      schemaPath: new codegen_1.Name("schemaPath"),
      // also used in JTD errors
      params: new codegen_1.Name("params"),
      propertyName: new codegen_1.Name("propertyName"),
      message: new codegen_1.Name("message"),
      schema: new codegen_1.Name("schema"),
      parentSchema: new codegen_1.Name("parentSchema")
    };
    function errorObjectCode(cxt, error, errorPaths) {
      const { createErrors } = cxt.it;
      if (createErrors === false)
        return (0, codegen_1._)`{}`;
      return errorObject(cxt, error, errorPaths);
    }
    function errorObject(cxt, error, errorPaths = {}) {
      const { gen, it } = cxt;
      const keyValues = [
        errorInstancePath(it, errorPaths),
        errorSchemaPath(cxt, errorPaths)
      ];
      extraErrorProps(cxt, error, keyValues);
      return gen.object(...keyValues);
    }
    function errorInstancePath({ errorPath }, { instancePath }) {
      const instPath = instancePath ? (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(instancePath, util_1.Type.Str)}` : errorPath;
      return [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, instPath)];
    }
    function errorSchemaPath({ keyword, it: { errSchemaPath } }, { schemaPath, parentSchema }) {
      let schPath = parentSchema ? errSchemaPath : (0, codegen_1.str)`${errSchemaPath}/${keyword}`;
      if (schemaPath) {
        schPath = (0, codegen_1.str)`${schPath}${(0, util_1.getErrorPath)(schemaPath, util_1.Type.Str)}`;
      }
      return [E.schemaPath, schPath];
    }
    function extraErrorProps(cxt, { params, message }, keyValues) {
      const { keyword, data, schemaValue, it } = cxt;
      const { opts, propertyName, topSchemaRef, schemaPath } = it;
      keyValues.push([E.keyword, keyword], [E.params, typeof params == "function" ? params(cxt) : params || (0, codegen_1._)`{}`]);
      if (opts.messages) {
        keyValues.push([E.message, typeof message == "function" ? message(cxt) : message]);
      }
      if (opts.verbose) {
        keyValues.push([E.schema, schemaValue], [E.parentSchema, (0, codegen_1._)`${topSchemaRef}${schemaPath}`], [names_1.default.data, data]);
      }
      if (propertyName)
        keyValues.push([E.propertyName, propertyName]);
    }
  }
});

// node_modules/ajv/dist/compile/validate/boolSchema.js
var require_boolSchema = __commonJS({
  "node_modules/ajv/dist/compile/validate/boolSchema.js"(exports) {
    "use strict";
    var import_dist16 = __toESM(require_dist());
    var import_dist17 = __toESM(require_dist2());
    var import_dist18 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.boolOrEmptySchema = exports.topBoolOrEmptySchema = void 0;
    var errors_1 = require_errors();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var boolError = {
      message: "boolean schema is false"
    };
    function topBoolOrEmptySchema(it) {
      const { gen, schema, validateName } = it;
      if (schema === false) {
        falseSchemaError(it, false);
      } else if (typeof schema == "object" && schema.$async === true) {
        gen.return(names_1.default.data);
      } else {
        gen.assign((0, codegen_1._)`${validateName}.errors`, null);
        gen.return(true);
      }
    }
    exports.topBoolOrEmptySchema = topBoolOrEmptySchema;
    function boolOrEmptySchema(it, valid) {
      const { gen, schema } = it;
      if (schema === false) {
        gen.var(valid, false);
        falseSchemaError(it);
      } else {
        gen.var(valid, true);
      }
    }
    exports.boolOrEmptySchema = boolOrEmptySchema;
    function falseSchemaError(it, overrideAllErrors) {
      const { gen, data } = it;
      const cxt = {
        gen,
        keyword: "false schema",
        data,
        schema: false,
        schemaCode: false,
        schemaValue: false,
        params: {},
        it
      };
      (0, errors_1.reportError)(cxt, boolError, void 0, overrideAllErrors);
    }
  }
});

// node_modules/ajv/dist/compile/rules.js
var require_rules = __commonJS({
  "node_modules/ajv/dist/compile/rules.js"(exports) {
    "use strict";
    var import_dist16 = __toESM(require_dist());
    var import_dist17 = __toESM(require_dist2());
    var import_dist18 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getRules = exports.isJSONType = void 0;
    var _jsonTypes = ["string", "number", "integer", "boolean", "null", "object", "array"];
    var jsonTypes = new Set(_jsonTypes);
    function isJSONType(x) {
      return typeof x == "string" && jsonTypes.has(x);
    }
    exports.isJSONType = isJSONType;
    function getRules() {
      const groups = {
        number: { type: "number", rules: [] },
        string: { type: "string", rules: [] },
        array: { type: "array", rules: [] },
        object: { type: "object", rules: [] }
      };
      return {
        types: { ...groups, integer: true, boolean: true, null: true },
        rules: [{ rules: [] }, groups.number, groups.string, groups.array, groups.object],
        post: { rules: [] },
        all: {},
        keywords: {}
      };
    }
    exports.getRules = getRules;
  }
});

// node_modules/ajv/dist/compile/validate/applicability.js
var require_applicability = __commonJS({
  "node_modules/ajv/dist/compile/validate/applicability.js"(exports) {
    "use strict";
    var import_dist16 = __toESM(require_dist());
    var import_dist17 = __toESM(require_dist2());
    var import_dist18 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.shouldUseRule = exports.shouldUseGroup = exports.schemaHasRulesForType = void 0;
    function schemaHasRulesForType({ schema, self }, type) {
      const group = self.RULES.types[type];
      return group && group !== true && shouldUseGroup(schema, group);
    }
    exports.schemaHasRulesForType = schemaHasRulesForType;
    function shouldUseGroup(schema, group) {
      return group.rules.some((rule) => shouldUseRule(schema, rule));
    }
    exports.shouldUseGroup = shouldUseGroup;
    function shouldUseRule(schema, rule) {
      var _a;
      return schema[rule.keyword] !== void 0 || ((_a = rule.definition.implements) === null || _a === void 0 ? void 0 : _a.some((kwd) => schema[kwd] !== void 0));
    }
    exports.shouldUseRule = shouldUseRule;
  }
});

// node_modules/ajv/dist/compile/validate/dataType.js
var require_dataType = __commonJS({
  "node_modules/ajv/dist/compile/validate/dataType.js"(exports) {
    "use strict";
    var import_dist16 = __toESM(require_dist());
    var import_dist17 = __toESM(require_dist2());
    var import_dist18 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.reportTypeError = exports.checkDataTypes = exports.checkDataType = exports.coerceAndCheckDataType = exports.getJSONTypes = exports.getSchemaTypes = exports.DataType = void 0;
    var rules_1 = require_rules();
    var applicability_1 = require_applicability();
    var errors_1 = require_errors();
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var DataType;
    (function(DataType2) {
      DataType2[DataType2["Correct"] = 0] = "Correct";
      DataType2[DataType2["Wrong"] = 1] = "Wrong";
    })(DataType || (exports.DataType = DataType = {}));
    function getSchemaTypes(schema) {
      const types = getJSONTypes(schema.type);
      const hasNull = types.includes("null");
      if (hasNull) {
        if (schema.nullable === false)
          throw new Error("type: null contradicts nullable: false");
      } else {
        if (!types.length && schema.nullable !== void 0) {
          throw new Error('"nullable" cannot be used without "type"');
        }
        if (schema.nullable === true)
          types.push("null");
      }
      return types;
    }
    exports.getSchemaTypes = getSchemaTypes;
    function getJSONTypes(ts) {
      const types = Array.isArray(ts) ? ts : ts ? [ts] : [];
      if (types.every(rules_1.isJSONType))
        return types;
      throw new Error("type must be JSONType or JSONType[]: " + types.join(","));
    }
    exports.getJSONTypes = getJSONTypes;
    function coerceAndCheckDataType(it, types) {
      const { gen, data, opts } = it;
      const coerceTo = coerceToTypes(types, opts.coerceTypes);
      const checkTypes = types.length > 0 && !(coerceTo.length === 0 && types.length === 1 && (0, applicability_1.schemaHasRulesForType)(it, types[0]));
      if (checkTypes) {
        const wrongType = checkDataTypes(types, data, opts.strictNumbers, DataType.Wrong);
        gen.if(wrongType, () => {
          if (coerceTo.length)
            coerceData(it, types, coerceTo);
          else
            reportTypeError(it);
        });
      }
      return checkTypes;
    }
    exports.coerceAndCheckDataType = coerceAndCheckDataType;
    var COERCIBLE = /* @__PURE__ */ new Set(["string", "number", "integer", "boolean", "null"]);
    function coerceToTypes(types, coerceTypes) {
      return coerceTypes ? types.filter((t) => COERCIBLE.has(t) || coerceTypes === "array" && t === "array") : [];
    }
    function coerceData(it, types, coerceTo) {
      const { gen, data, opts } = it;
      const dataType = gen.let("dataType", (0, codegen_1._)`typeof ${data}`);
      const coerced = gen.let("coerced", (0, codegen_1._)`undefined`);
      if (opts.coerceTypes === "array") {
        gen.if((0, codegen_1._)`${dataType} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () => gen.assign(data, (0, codegen_1._)`${data}[0]`).assign(dataType, (0, codegen_1._)`typeof ${data}`).if(checkDataTypes(types, data, opts.strictNumbers), () => gen.assign(coerced, data)));
      }
      gen.if((0, codegen_1._)`${coerced} !== undefined`);
      for (const t of coerceTo) {
        if (COERCIBLE.has(t) || t === "array" && opts.coerceTypes === "array") {
          coerceSpecificType(t);
        }
      }
      gen.else();
      reportTypeError(it);
      gen.endIf();
      gen.if((0, codegen_1._)`${coerced} !== undefined`, () => {
        gen.assign(data, coerced);
        assignParentData(it, coerced);
      });
      function coerceSpecificType(t) {
        switch (t) {
          case "string":
            gen.elseIf((0, codegen_1._)`${dataType} == "number" || ${dataType} == "boolean"`).assign(coerced, (0, codegen_1._)`"" + ${data}`).elseIf((0, codegen_1._)`${data} === null`).assign(coerced, (0, codegen_1._)`""`);
            return;
          case "number":
            gen.elseIf((0, codegen_1._)`${dataType} == "boolean" || ${data} === null
              || (${dataType} == "string" && ${data} && ${data} == +${data})`).assign(coerced, (0, codegen_1._)`+${data}`);
            return;
          case "integer":
            gen.elseIf((0, codegen_1._)`${dataType} === "boolean" || ${data} === null
              || (${dataType} === "string" && ${data} && ${data} == +${data} && !(${data} % 1))`).assign(coerced, (0, codegen_1._)`+${data}`);
            return;
          case "boolean":
            gen.elseIf((0, codegen_1._)`${data} === "false" || ${data} === 0 || ${data} === null`).assign(coerced, false).elseIf((0, codegen_1._)`${data} === "true" || ${data} === 1`).assign(coerced, true);
            return;
          case "null":
            gen.elseIf((0, codegen_1._)`${data} === "" || ${data} === 0 || ${data} === false`);
            gen.assign(coerced, null);
            return;
          case "array":
            gen.elseIf((0, codegen_1._)`${dataType} === "string" || ${dataType} === "number"
              || ${dataType} === "boolean" || ${data} === null`).assign(coerced, (0, codegen_1._)`[${data}]`);
        }
      }
    }
    function assignParentData({ gen, parentData, parentDataProperty }, expr) {
      gen.if((0, codegen_1._)`${parentData} !== undefined`, () => gen.assign((0, codegen_1._)`${parentData}[${parentDataProperty}]`, expr));
    }
    function checkDataType(dataType, data, strictNums, correct = DataType.Correct) {
      const EQ = correct === DataType.Correct ? codegen_1.operators.EQ : codegen_1.operators.NEQ;
      let cond;
      switch (dataType) {
        case "null":
          return (0, codegen_1._)`${data} ${EQ} null`;
        case "array":
          cond = (0, codegen_1._)`Array.isArray(${data})`;
          break;
        case "object":
          cond = (0, codegen_1._)`${data} && typeof ${data} == "object" && !Array.isArray(${data})`;
          break;
        case "integer":
          cond = numCond((0, codegen_1._)`!(${data} % 1) && !isNaN(${data})`);
          break;
        case "number":
          cond = numCond();
          break;
        default:
          return (0, codegen_1._)`typeof ${data} ${EQ} ${dataType}`;
      }
      return correct === DataType.Correct ? cond : (0, codegen_1.not)(cond);
      function numCond(_cond = codegen_1.nil) {
        return (0, codegen_1.and)((0, codegen_1._)`typeof ${data} == "number"`, _cond, strictNums ? (0, codegen_1._)`isFinite(${data})` : codegen_1.nil);
      }
    }
    exports.checkDataType = checkDataType;
    function checkDataTypes(dataTypes, data, strictNums, correct) {
      if (dataTypes.length === 1) {
        return checkDataType(dataTypes[0], data, strictNums, correct);
      }
      let cond;
      const types = (0, util_1.toHash)(dataTypes);
      if (types.array && types.object) {
        const notObj = (0, codegen_1._)`typeof ${data} != "object"`;
        cond = types.null ? notObj : (0, codegen_1._)`!${data} || ${notObj}`;
        delete types.null;
        delete types.array;
        delete types.object;
      } else {
        cond = codegen_1.nil;
      }
      if (types.number)
        delete types.integer;
      for (const t in types)
        cond = (0, codegen_1.and)(cond, checkDataType(t, data, strictNums, correct));
      return cond;
    }
    exports.checkDataTypes = checkDataTypes;
    var typeError = {
      message: ({ schema }) => `must be ${schema}`,
      params: ({ schema, schemaValue }) => typeof schema == "string" ? (0, codegen_1._)`{type: ${schema}}` : (0, codegen_1._)`{type: ${schemaValue}}`
    };
    function reportTypeError(it) {
      const cxt = getTypeErrorContext(it);
      (0, errors_1.reportError)(cxt, typeError);
    }
    exports.reportTypeError = reportTypeError;
    function getTypeErrorContext(it) {
      const { gen, data, schema } = it;
      const schemaCode = (0, util_1.schemaRefOrVal)(it, schema, "type");
      return {
        gen,
        keyword: "type",
        data,
        schema: schema.type,
        schemaCode,
        schemaValue: schemaCode,
        parentSchema: schema,
        params: {},
        it
      };
    }
  }
});

// node_modules/ajv/dist/compile/validate/defaults.js
var require_defaults = __commonJS({
  "node_modules/ajv/dist/compile/validate/defaults.js"(exports) {
    "use strict";
    var import_dist16 = __toESM(require_dist());
    var import_dist17 = __toESM(require_dist2());
    var import_dist18 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.assignDefaults = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    function assignDefaults(it, ty) {
      const { properties, items } = it.schema;
      if (ty === "object" && properties) {
        for (const key2 in properties) {
          assignDefault(it, key2, properties[key2].default);
        }
      } else if (ty === "array" && Array.isArray(items)) {
        items.forEach((sch, i) => assignDefault(it, i, sch.default));
      }
    }
    exports.assignDefaults = assignDefaults;
    function assignDefault(it, prop, defaultValue) {
      const { gen, compositeRule, data, opts } = it;
      if (defaultValue === void 0)
        return;
      const childData = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(prop)}`;
      if (compositeRule) {
        (0, util_1.checkStrictMode)(it, `default is ignored for: ${childData}`);
        return;
      }
      let condition = (0, codegen_1._)`${childData} === undefined`;
      if (opts.useDefaults === "empty") {
        condition = (0, codegen_1._)`${condition} || ${childData} === null || ${childData} === ""`;
      }
      gen.if(condition, (0, codegen_1._)`${childData} = ${(0, codegen_1.stringify)(defaultValue)}`);
    }
  }
});

// node_modules/ajv/dist/vocabularies/code.js
var require_code2 = __commonJS({
  "node_modules/ajv/dist/vocabularies/code.js"(exports) {
    "use strict";
    var import_dist16 = __toESM(require_dist());
    var import_dist17 = __toESM(require_dist2());
    var import_dist18 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateUnion = exports.validateArray = exports.usePattern = exports.callValidateCode = exports.schemaProperties = exports.allSchemaProperties = exports.noPropertyInData = exports.propertyInData = exports.isOwnProperty = exports.hasPropFunc = exports.reportMissingProp = exports.checkMissingProp = exports.checkReportMissingProp = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var names_1 = require_names();
    var util_2 = require_util();
    function checkReportMissingProp(cxt, prop) {
      const { gen, data, it } = cxt;
      gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {
        cxt.setParams({ missingProperty: (0, codegen_1._)`${prop}` }, true);
        cxt.error();
      });
    }
    exports.checkReportMissingProp = checkReportMissingProp;
    function checkMissingProp({ gen, data, it: { opts } }, properties, missing) {
      return (0, codegen_1.or)(...properties.map((prop) => (0, codegen_1.and)(noPropertyInData(gen, data, prop, opts.ownProperties), (0, codegen_1._)`${missing} = ${prop}`)));
    }
    exports.checkMissingProp = checkMissingProp;
    function reportMissingProp(cxt, missing) {
      cxt.setParams({ missingProperty: missing }, true);
      cxt.error();
    }
    exports.reportMissingProp = reportMissingProp;
    function hasPropFunc(gen) {
      return gen.scopeValue("func", {
        // eslint-disable-next-line @typescript-eslint/unbound-method
        ref: Object.prototype.hasOwnProperty,
        code: (0, codegen_1._)`Object.prototype.hasOwnProperty`
      });
    }
    exports.hasPropFunc = hasPropFunc;
    function isOwnProperty(gen, data, property) {
      return (0, codegen_1._)`${hasPropFunc(gen)}.call(${data}, ${property})`;
    }
    exports.isOwnProperty = isOwnProperty;
    function propertyInData(gen, data, property, ownProperties) {
      const cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(property)} !== undefined`;
      return ownProperties ? (0, codegen_1._)`${cond} && ${isOwnProperty(gen, data, property)}` : cond;
    }
    exports.propertyInData = propertyInData;
    function noPropertyInData(gen, data, property, ownProperties) {
      const cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(property)} === undefined`;
      return ownProperties ? (0, codegen_1.or)(cond, (0, codegen_1.not)(isOwnProperty(gen, data, property))) : cond;
    }
    exports.noPropertyInData = noPropertyInData;
    function allSchemaProperties(schemaMap) {
      return schemaMap ? Object.keys(schemaMap).filter((p) => p !== "__proto__") : [];
    }
    exports.allSchemaProperties = allSchemaProperties;
    function schemaProperties(it, schemaMap) {
      return allSchemaProperties(schemaMap).filter((p) => !(0, util_1.alwaysValidSchema)(it, schemaMap[p]));
    }
    exports.schemaProperties = schemaProperties;
    function callValidateCode({ schemaCode, data, it: { gen, topSchemaRef, schemaPath, errorPath }, it }, func, context, passSchema) {
      const dataAndSchema = passSchema ? (0, codegen_1._)`${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data;
      const valCxt = [
        [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, errorPath)],
        [names_1.default.parentData, it.parentData],
        [names_1.default.parentDataProperty, it.parentDataProperty],
        [names_1.default.rootData, names_1.default.rootData]
      ];
      if (it.opts.dynamicRef)
        valCxt.push([names_1.default.dynamicAnchors, names_1.default.dynamicAnchors]);
      const args = (0, codegen_1._)`${dataAndSchema}, ${gen.object(...valCxt)}`;
      return context !== codegen_1.nil ? (0, codegen_1._)`${func}.call(${context}, ${args})` : (0, codegen_1._)`${func}(${args})`;
    }
    exports.callValidateCode = callValidateCode;
    var newRegExp = (0, codegen_1._)`new RegExp`;
    function usePattern({ gen, it: { opts } }, pattern) {
      const u = opts.unicodeRegExp ? "u" : "";
      const { regExp } = opts.code;
      const rx = regExp(pattern, u);
      return gen.scopeValue("pattern", {
        key: rx.toString(),
        ref: rx,
        code: (0, codegen_1._)`${regExp.code === "new RegExp" ? newRegExp : (0, util_2.useFunc)(gen, regExp)}(${pattern}, ${u})`
      });
    }
    exports.usePattern = usePattern;
    function validateArray(cxt) {
      const { gen, data, keyword, it } = cxt;
      const valid = gen.name("valid");
      if (it.allErrors) {
        const validArr = gen.let("valid", true);
        validateItems(() => gen.assign(validArr, false));
        return validArr;
      }
      gen.var(valid, true);
      validateItems(() => gen.break());
      return valid;
      function validateItems(notValid) {
        const len = gen.const("len", (0, codegen_1._)`${data}.length`);
        gen.forRange("i", 0, len, (i) => {
          cxt.subschema({
            keyword,
            dataProp: i,
            dataPropType: util_1.Type.Num
          }, valid);
          gen.if((0, codegen_1.not)(valid), notValid);
        });
      }
    }
    exports.validateArray = validateArray;
    function validateUnion(cxt) {
      const { gen, schema, keyword, it } = cxt;
      if (!Array.isArray(schema))
        throw new Error("ajv implementation error");
      const alwaysValid = schema.some((sch) => (0, util_1.alwaysValidSchema)(it, sch));
      if (alwaysValid && !it.opts.unevaluated)
        return;
      const valid = gen.let("valid", false);
      const schValid = gen.name("_valid");
      gen.block(() => schema.forEach((_sch, i) => {
        const schCxt = cxt.subschema({
          keyword,
          schemaProp: i,
          compositeRule: true
        }, schValid);
        gen.assign(valid, (0, codegen_1._)`${valid} || ${schValid}`);
        const merged = cxt.mergeValidEvaluated(schCxt, schValid);
        if (!merged)
          gen.if((0, codegen_1.not)(valid));
      }));
      cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
    }
    exports.validateUnion = validateUnion;
  }
});

// node_modules/ajv/dist/compile/validate/keyword.js
var require_keyword = __commonJS({
  "node_modules/ajv/dist/compile/validate/keyword.js"(exports) {
    "use strict";
    var import_dist16 = __toESM(require_dist());
    var import_dist17 = __toESM(require_dist2());
    var import_dist18 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateKeywordUsage = exports.validSchemaType = exports.funcKeywordCode = exports.macroKeywordCode = void 0;
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var code_1 = require_code2();
    var errors_1 = require_errors();
    function macroKeywordCode(cxt, def) {
      const { gen, keyword, schema, parentSchema, it } = cxt;
      const macroSchema = def.macro.call(it.self, schema, parentSchema, it);
      const schemaRef = useKeyword(gen, keyword, macroSchema);
      if (it.opts.validateSchema !== false)
        it.self.validateSchema(macroSchema, true);
      const valid = gen.name("valid");
      cxt.subschema({
        schema: macroSchema,
        schemaPath: codegen_1.nil,
        errSchemaPath: `${it.errSchemaPath}/${keyword}`,
        topSchemaRef: schemaRef,
        compositeRule: true
      }, valid);
      cxt.pass(valid, () => cxt.error(true));
    }
    exports.macroKeywordCode = macroKeywordCode;
    function funcKeywordCode(cxt, def) {
      var _a;
      const { gen, keyword, schema, parentSchema, $data, it } = cxt;
      checkAsyncKeyword(it, def);
      const validate = !$data && def.compile ? def.compile.call(it.self, schema, parentSchema, it) : def.validate;
      const validateRef = useKeyword(gen, keyword, validate);
      const valid = gen.let("valid");
      cxt.block$data(valid, validateKeyword);
      cxt.ok((_a = def.valid) !== null && _a !== void 0 ? _a : valid);
      function validateKeyword() {
        if (def.errors === false) {
          assignValid();
          if (def.modifying)
            modifyData(cxt);
          reportErrs(() => cxt.error());
        } else {
          const ruleErrs = def.async ? validateAsync() : validateSync();
          if (def.modifying)
            modifyData(cxt);
          reportErrs(() => addErrs(cxt, ruleErrs));
        }
      }
      function validateAsync() {
        const ruleErrs = gen.let("ruleErrs", null);
        gen.try(() => assignValid((0, codegen_1._)`await `), (e) => gen.assign(valid, false).if((0, codegen_1._)`${e} instanceof ${it.ValidationError}`, () => gen.assign(ruleErrs, (0, codegen_1._)`${e}.errors`), () => gen.throw(e)));
        return ruleErrs;
      }
      function validateSync() {
        const validateErrs = (0, codegen_1._)`${validateRef}.errors`;
        gen.assign(validateErrs, null);
        assignValid(codegen_1.nil);
        return validateErrs;
      }
      function assignValid(_await = def.async ? (0, codegen_1._)`await ` : codegen_1.nil) {
        const passCxt = it.opts.passContext ? names_1.default.this : names_1.default.self;
        const passSchema = !("compile" in def && !$data || def.schema === false);
        gen.assign(valid, (0, codegen_1._)`${_await}${(0, code_1.callValidateCode)(cxt, validateRef, passCxt, passSchema)}`, def.modifying);
      }
      function reportErrs(errors) {
        var _a2;
        gen.if((0, codegen_1.not)((_a2 = def.valid) !== null && _a2 !== void 0 ? _a2 : valid), errors);
      }
    }
    exports.funcKeywordCode = funcKeywordCode;
    function modifyData(cxt) {
      const { gen, data, it } = cxt;
      gen.if(it.parentData, () => gen.assign(data, (0, codegen_1._)`${it.parentData}[${it.parentDataProperty}]`));
    }
    function addErrs(cxt, errs) {
      const { gen } = cxt;
      gen.if((0, codegen_1._)`Array.isArray(${errs})`, () => {
        gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`).assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);
        (0, errors_1.extendErrors)(cxt);
      }, () => cxt.error());
    }
    function checkAsyncKeyword({ schemaEnv }, def) {
      if (def.async && !schemaEnv.$async)
        throw new Error("async keyword in sync schema");
    }
    function useKeyword(gen, keyword, result) {
      if (result === void 0)
        throw new Error(`keyword "${keyword}" failed to compile`);
      return gen.scopeValue("keyword", typeof result == "function" ? { ref: result } : { ref: result, code: (0, codegen_1.stringify)(result) });
    }
    function validSchemaType(schema, schemaType, allowUndefined = false) {
      return !schemaType.length || schemaType.some((st) => st === "array" ? Array.isArray(schema) : st === "object" ? schema && typeof schema == "object" && !Array.isArray(schema) : typeof schema == st || allowUndefined && typeof schema == "undefined");
    }
    exports.validSchemaType = validSchemaType;
    function validateKeywordUsage({ schema, opts, self, errSchemaPath }, def, keyword) {
      if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword) {
        throw new Error("ajv implementation error");
      }
      const deps = def.dependencies;
      if (deps === null || deps === void 0 ? void 0 : deps.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {
        throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(",")}`);
      }
      if (def.validateSchema) {
        const valid = def.validateSchema(schema[keyword]);
        if (!valid) {
          const msg = `keyword "${keyword}" value is invalid at path "${errSchemaPath}": ` + self.errorsText(def.validateSchema.errors);
          if (opts.validateSchema === "log")
            self.logger.error(msg);
          else
            throw new Error(msg);
        }
      }
    }
    exports.validateKeywordUsage = validateKeywordUsage;
  }
});

// node_modules/ajv/dist/compile/validate/subschema.js
var require_subschema = __commonJS({
  "node_modules/ajv/dist/compile/validate/subschema.js"(exports) {
    "use strict";
    var import_dist16 = __toESM(require_dist());
    var import_dist17 = __toESM(require_dist2());
    var import_dist18 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.extendSubschemaMode = exports.extendSubschemaData = exports.getSubschema = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    function getSubschema(it, { keyword, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef }) {
      if (keyword !== void 0 && schema !== void 0) {
        throw new Error('both "keyword" and "schema" passed, only one allowed');
      }
      if (keyword !== void 0) {
        const sch = it.schema[keyword];
        return schemaProp === void 0 ? {
          schema: sch,
          schemaPath: (0, codegen_1._)`${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}`,
          errSchemaPath: `${it.errSchemaPath}/${keyword}`
        } : {
          schema: sch[schemaProp],
          schemaPath: (0, codegen_1._)`${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}${(0, codegen_1.getProperty)(schemaProp)}`,
          errSchemaPath: `${it.errSchemaPath}/${keyword}/${(0, util_1.escapeFragment)(schemaProp)}`
        };
      }
      if (schema !== void 0) {
        if (schemaPath === void 0 || errSchemaPath === void 0 || topSchemaRef === void 0) {
          throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
        }
        return {
          schema,
          schemaPath,
          topSchemaRef,
          errSchemaPath
        };
      }
      throw new Error('either "keyword" or "schema" must be passed');
    }
    exports.getSubschema = getSubschema;
    function extendSubschemaData(subschema, it, { dataProp, dataPropType: dpType, data, dataTypes, propertyName }) {
      if (data !== void 0 && dataProp !== void 0) {
        throw new Error('both "data" and "dataProp" passed, only one allowed');
      }
      const { gen } = it;
      if (dataProp !== void 0) {
        const { errorPath, dataPathArr, opts } = it;
        const nextData = gen.let("data", (0, codegen_1._)`${it.data}${(0, codegen_1.getProperty)(dataProp)}`, true);
        dataContextProps(nextData);
        subschema.errorPath = (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(dataProp, dpType, opts.jsPropertySyntax)}`;
        subschema.parentDataProperty = (0, codegen_1._)`${dataProp}`;
        subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty];
      }
      if (data !== void 0) {
        const nextData = data instanceof codegen_1.Name ? data : gen.let("data", data, true);
        dataContextProps(nextData);
        if (propertyName !== void 0)
          subschema.propertyName = propertyName;
      }
      if (dataTypes)
        subschema.dataTypes = dataTypes;
      function dataContextProps(_nextData) {
        subschema.data = _nextData;
        subschema.dataLevel = it.dataLevel + 1;
        subschema.dataTypes = [];
        it.definedProperties = /* @__PURE__ */ new Set();
        subschema.parentData = it.data;
        subschema.dataNames = [...it.dataNames, _nextData];
      }
    }
    exports.extendSubschemaData = extendSubschemaData;
    function extendSubschemaMode(subschema, { jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors }) {
      if (compositeRule !== void 0)
        subschema.compositeRule = compositeRule;
      if (createErrors !== void 0)
        subschema.createErrors = createErrors;
      if (allErrors !== void 0)
        subschema.allErrors = allErrors;
      subschema.jtdDiscriminator = jtdDiscriminator;
      subschema.jtdMetadata = jtdMetadata;
    }
    exports.extendSubschemaMode = extendSubschemaMode;
  }
});

// node_modules/fast-deep-equal/index.js
var require_fast_deep_equal = __commonJS({
  "node_modules/fast-deep-equal/index.js"(exports, module) {
    "use strict";
    var import_dist16 = __toESM(require_dist());
    var import_dist17 = __toESM(require_dist2());
    var import_dist18 = __toESM(require_dist3());
    module.exports = function equal(a, b) {
      if (a === b) return true;
      if (a && b && typeof a == "object" && typeof b == "object") {
        if (a.constructor !== b.constructor) return false;
        var length, i, keys;
        if (Array.isArray(a)) {
          length = a.length;
          if (length != b.length) return false;
          for (i = length; i-- !== 0; )
            if (!equal(a[i], b[i])) return false;
          return true;
        }
        if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
        if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
        if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();
        keys = Object.keys(a);
        length = keys.length;
        if (length !== Object.keys(b).length) return false;
        for (i = length; i-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;
        for (i = length; i-- !== 0; ) {
          var key2 = keys[i];
          if (!equal(a[key2], b[key2])) return false;
        }
        return true;
      }
      return a !== a && b !== b;
    };
  }
});

// node_modules/json-schema-traverse/index.js
var require_json_schema_traverse = __commonJS({
  "node_modules/json-schema-traverse/index.js"(exports, module) {
    "use strict";
    var import_dist16 = __toESM(require_dist());
    var import_dist17 = __toESM(require_dist2());
    var import_dist18 = __toESM(require_dist3());
    var traverse = module.exports = function(schema, opts, cb) {
      if (typeof opts == "function") {
        cb = opts;
        opts = {};
      }
      cb = opts.cb || cb;
      var pre = typeof cb == "function" ? cb : cb.pre || function() {
      };
      var post = cb.post || function() {
      };
      _traverse(opts, pre, post, schema, "", schema);
    };
    traverse.keywords = {
      additionalItems: true,
      items: true,
      contains: true,
      additionalProperties: true,
      propertyNames: true,
      not: true,
      if: true,
      then: true,
      else: true
    };
    traverse.arrayKeywords = {
      items: true,
      allOf: true,
      anyOf: true,
      oneOf: true
    };
    traverse.propsKeywords = {
      $defs: true,
      definitions: true,
      properties: true,
      patternProperties: true,
      dependencies: true
    };
    traverse.skipKeywords = {
      default: true,
      enum: true,
      const: true,
      required: true,
      maximum: true,
      minimum: true,
      exclusiveMaximum: true,
      exclusiveMinimum: true,
      multipleOf: true,
      maxLength: true,
      minLength: true,
      pattern: true,
      format: true,
      maxItems: true,
      minItems: true,
      uniqueItems: true,
      maxProperties: true,
      minProperties: true
    };
    function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
      if (schema && typeof schema == "object" && !Array.isArray(schema)) {
        pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
        for (var key2 in schema) {
          var sch = schema[key2];
          if (Array.isArray(sch)) {
            if (key2 in traverse.arrayKeywords) {
              for (var i = 0; i < sch.length; i++)
                _traverse(opts, pre, post, sch[i], jsonPtr + "/" + key2 + "/" + i, rootSchema, jsonPtr, key2, schema, i);
            }
          } else if (key2 in traverse.propsKeywords) {
            if (sch && typeof sch == "object") {
              for (var prop in sch)
                _traverse(opts, pre, post, sch[prop], jsonPtr + "/" + key2 + "/" + escapeJsonPtr(prop), rootSchema, jsonPtr, key2, schema, prop);
            }
          } else if (key2 in traverse.keywords || opts.allKeys && !(key2 in traverse.skipKeywords)) {
            _traverse(opts, pre, post, sch, jsonPtr + "/" + key2, rootSchema, jsonPtr, key2, schema);
          }
        }
        post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
      }
    }
    function escapeJsonPtr(str) {
      return str.replace(/~/g, "~0").replace(/\//g, "~1");
    }
  }
});

// node_modules/ajv/dist/compile/resolve.js
var require_resolve = __commonJS({
  "node_modules/ajv/dist/compile/resolve.js"(exports) {
    "use strict";
    var import_dist16 = __toESM(require_dist());
    var import_dist17 = __toESM(require_dist2());
    var import_dist18 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getSchemaRefs = exports.resolveUrl = exports.normalizeId = exports._getFullPath = exports.getFullPath = exports.inlineRef = void 0;
    var util_1 = require_util();
    var equal = require_fast_deep_equal();
    var traverse = require_json_schema_traverse();
    var SIMPLE_INLINED = /* @__PURE__ */ new Set([
      "type",
      "format",
      "pattern",
      "maxLength",
      "minLength",
      "maxProperties",
      "minProperties",
      "maxItems",
      "minItems",
      "maximum",
      "minimum",
      "uniqueItems",
      "multipleOf",
      "required",
      "enum",
      "const"
    ]);
    function inlineRef(schema, limit = true) {
      if (typeof schema == "boolean")
        return true;
      if (limit === true)
        return !hasRef(schema);
      if (!limit)
        return false;
      return countKeys(schema) <= limit;
    }
    exports.inlineRef = inlineRef;
    var REF_KEYWORDS = /* @__PURE__ */ new Set([
      "$ref",
      "$recursiveRef",
      "$recursiveAnchor",
      "$dynamicRef",
      "$dynamicAnchor"
    ]);
    function hasRef(schema) {
      for (const key2 in schema) {
        if (REF_KEYWORDS.has(key2))
          return true;
        const sch = schema[key2];
        if (Array.isArray(sch) && sch.some(hasRef))
          return true;
        if (typeof sch == "object" && hasRef(sch))
          return true;
      }
      return false;
    }
    function countKeys(schema) {
      let count = 0;
      for (const key2 in schema) {
        if (key2 === "$ref")
          return Infinity;
        count++;
        if (SIMPLE_INLINED.has(key2))
          continue;
        if (typeof schema[key2] == "object") {
          (0, util_1.eachItem)(schema[key2], (sch) => count += countKeys(sch));
        }
        if (count === Infinity)
          return Infinity;
      }
      return count;
    }
    function getFullPath(resolver, id = "", normalize) {
      if (normalize !== false)
        id = normalizeId(id);
      const p = resolver.parse(id);
      return _getFullPath(resolver, p);
    }
    exports.getFullPath = getFullPath;
    function _getFullPath(resolver, p) {
      const serialized = resolver.serialize(p);
      return serialized.split("#")[0] + "#";
    }
    exports._getFullPath = _getFullPath;
    var TRAILING_SLASH_HASH = /#\/?$/;
    function normalizeId(id) {
      return id ? id.replace(TRAILING_SLASH_HASH, "") : "";
    }
    exports.normalizeId = normalizeId;
    function resolveUrl(resolver, baseId, id) {
      id = normalizeId(id);
      return resolver.resolve(baseId, id);
    }
    exports.resolveUrl = resolveUrl;
    var ANCHOR = /^[a-z_][-a-z0-9._]*$/i;
    function getSchemaRefs(schema, baseId) {
      if (typeof schema == "boolean")
        return {};
      const { schemaId, uriResolver } = this.opts;
      const schId = normalizeId(schema[schemaId] || baseId);
      const baseIds = { "": schId };
      const pathPrefix = getFullPath(uriResolver, schId, false);
      const localRefs = {};
      const schemaRefs = /* @__PURE__ */ new Set();
      traverse(schema, { allKeys: true }, (sch, jsonPtr, _, parentJsonPtr) => {
        if (parentJsonPtr === void 0)
          return;
        const fullPath = pathPrefix + jsonPtr;
        let innerBaseId = baseIds[parentJsonPtr];
        if (typeof sch[schemaId] == "string")
          innerBaseId = addRef.call(this, sch[schemaId]);
        addAnchor.call(this, sch.$anchor);
        addAnchor.call(this, sch.$dynamicAnchor);
        baseIds[jsonPtr] = innerBaseId;
        function addRef(ref) {
          const _resolve = this.opts.uriResolver.resolve;
          ref = normalizeId(innerBaseId ? _resolve(innerBaseId, ref) : ref);
          if (schemaRefs.has(ref))
            throw ambiguos(ref);
          schemaRefs.add(ref);
          let schOrRef = this.refs[ref];
          if (typeof schOrRef == "string")
            schOrRef = this.refs[schOrRef];
          if (typeof schOrRef == "object") {
            checkAmbiguosRef(sch, schOrRef.schema, ref);
          } else if (ref !== normalizeId(fullPath)) {
            if (ref[0] === "#") {
              checkAmbiguosRef(sch, localRefs[ref], ref);
              localRefs[ref] = sch;
            } else {
              this.refs[ref] = fullPath;
            }
          }
          return ref;
        }
        function addAnchor(anchor) {
          if (typeof anchor == "string") {
            if (!ANCHOR.test(anchor))
              throw new Error(`invalid anchor "${anchor}"`);
            addRef.call(this, `#${anchor}`);
          }
        }
      });
      return localRefs;
      function checkAmbiguosRef(sch1, sch2, ref) {
        if (sch2 !== void 0 && !equal(sch1, sch2))
          throw ambiguos(ref);
      }
      function ambiguos(ref) {
        return new Error(`reference "${ref}" resolves to more than one schema`);
      }
    }
    exports.getSchemaRefs = getSchemaRefs;
  }
});

// node_modules/ajv/dist/compile/validate/index.js
var require_validate = __commonJS({
  "node_modules/ajv/dist/compile/validate/index.js"(exports) {
    "use strict";
    var import_dist16 = __toESM(require_dist());
    var import_dist17 = __toESM(require_dist2());
    var import_dist18 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getData = exports.KeywordCxt = exports.validateFunctionCode = void 0;
    var boolSchema_1 = require_boolSchema();
    var dataType_1 = require_dataType();
    var applicability_1 = require_applicability();
    var dataType_2 = require_dataType();
    var defaults_1 = require_defaults();
    var keyword_1 = require_keyword();
    var subschema_1 = require_subschema();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var resolve_1 = require_resolve();
    var util_1 = require_util();
    var errors_1 = require_errors();
    function validateFunctionCode(it) {
      if (isSchemaObj(it)) {
        checkKeywords(it);
        if (schemaCxtHasRules(it)) {
          topSchemaObjCode(it);
          return;
        }
      }
      validateFunction(it, () => (0, boolSchema_1.topBoolOrEmptySchema)(it));
    }
    exports.validateFunctionCode = validateFunctionCode;
    function validateFunction({ gen, validateName, schema, schemaEnv, opts }, body) {
      if (opts.code.es5) {
        gen.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${names_1.default.valCxt}`, schemaEnv.$async, () => {
          gen.code((0, codegen_1._)`"use strict"; ${funcSourceUrl(schema, opts)}`);
          destructureValCxtES5(gen, opts);
          gen.code(body);
        });
      } else {
        gen.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema, opts)).code(body));
      }
    }
    function destructureValCxt(opts) {
      return (0, codegen_1._)`{${names_1.default.instancePath}="", ${names_1.default.parentData}, ${names_1.default.parentDataProperty}, ${names_1.default.rootData}=${names_1.default.data}${opts.dynamicRef ? (0, codegen_1._)`, ${names_1.default.dynamicAnchors}={}` : codegen_1.nil}}={}`;
    }
    function destructureValCxtES5(gen, opts) {
      gen.if(names_1.default.valCxt, () => {
        gen.var(names_1.default.instancePath, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.instancePath}`);
        gen.var(names_1.default.parentData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentData}`);
        gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentDataProperty}`);
        gen.var(names_1.default.rootData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.rootData}`);
        if (opts.dynamicRef)
          gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.dynamicAnchors}`);
      }, () => {
        gen.var(names_1.default.instancePath, (0, codegen_1._)`""`);
        gen.var(names_1.default.parentData, (0, codegen_1._)`undefined`);
        gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`undefined`);
        gen.var(names_1.default.rootData, names_1.default.data);
        if (opts.dynamicRef)
          gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`{}`);
      });
    }
    function topSchemaObjCode(it) {
      const { schema, opts, gen } = it;
      validateFunction(it, () => {
        if (opts.$comment && schema.$comment)
          commentKeyword(it);
        checkNoDefault(it);
        gen.let(names_1.default.vErrors, null);
        gen.let(names_1.default.errors, 0);
        if (opts.unevaluated)
          resetEvaluated(it);
        typeAndKeywords(it);
        returnResults(it);
      });
      return;
    }
    function resetEvaluated(it) {
      const { gen, validateName } = it;
      it.evaluated = gen.const("evaluated", (0, codegen_1._)`${validateName}.evaluated`);
      gen.if((0, codegen_1._)`${it.evaluated}.dynamicProps`, () => gen.assign((0, codegen_1._)`${it.evaluated}.props`, (0, codegen_1._)`undefined`));
      gen.if((0, codegen_1._)`${it.evaluated}.dynamicItems`, () => gen.assign((0, codegen_1._)`${it.evaluated}.items`, (0, codegen_1._)`undefined`));
    }
    function funcSourceUrl(schema, opts) {
      const schId = typeof schema == "object" && schema[opts.schemaId];
      return schId && (opts.code.source || opts.code.process) ? (0, codegen_1._)`/*# sourceURL=${schId} */` : codegen_1.nil;
    }
    function subschemaCode(it, valid) {
      if (isSchemaObj(it)) {
        checkKeywords(it);
        if (schemaCxtHasRules(it)) {
          subSchemaObjCode(it, valid);
          return;
        }
      }
      (0, boolSchema_1.boolOrEmptySchema)(it, valid);
    }
    function schemaCxtHasRules({ schema, self }) {
      if (typeof schema == "boolean")
        return !schema;
      for (const key2 in schema)
        if (self.RULES.all[key2])
          return true;
      return false;
    }
    function isSchemaObj(it) {
      return typeof it.schema != "boolean";
    }
    function subSchemaObjCode(it, valid) {
      const { schema, gen, opts } = it;
      if (opts.$comment && schema.$comment)
        commentKeyword(it);
      updateContext(it);
      checkAsyncSchema(it);
      const errsCount = gen.const("_errs", names_1.default.errors);
      typeAndKeywords(it, errsCount);
      gen.var(valid, (0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
    }
    function checkKeywords(it) {
      (0, util_1.checkUnknownRules)(it);
      checkRefsAndKeywords(it);
    }
    function typeAndKeywords(it, errsCount) {
      if (it.opts.jtd)
        return schemaKeywords(it, [], false, errsCount);
      const types = (0, dataType_1.getSchemaTypes)(it.schema);
      const checkedTypes = (0, dataType_1.coerceAndCheckDataType)(it, types);
      schemaKeywords(it, types, !checkedTypes, errsCount);
    }
    function checkRefsAndKeywords(it) {
      const { schema, errSchemaPath, opts, self } = it;
      if (schema.$ref && opts.ignoreKeywordsWithRef && (0, util_1.schemaHasRulesButRef)(schema, self.RULES)) {
        self.logger.warn(`$ref: keywords ignored in schema at path "${errSchemaPath}"`);
      }
    }
    function checkNoDefault(it) {
      const { schema, opts } = it;
      if (schema.default !== void 0 && opts.useDefaults && opts.strictSchema) {
        (0, util_1.checkStrictMode)(it, "default is ignored in the schema root");
      }
    }
    function updateContext(it) {
      const schId = it.schema[it.opts.schemaId];
      if (schId)
        it.baseId = (0, resolve_1.resolveUrl)(it.opts.uriResolver, it.baseId, schId);
    }
    function checkAsyncSchema(it) {
      if (it.schema.$async && !it.schemaEnv.$async)
        throw new Error("async schema in sync schema");
    }
    function commentKeyword({ gen, schemaEnv, schema, errSchemaPath, opts }) {
      const msg = schema.$comment;
      if (opts.$comment === true) {
        gen.code((0, codegen_1._)`${names_1.default.self}.logger.log(${msg})`);
      } else if (typeof opts.$comment == "function") {
        const schemaPath = (0, codegen_1.str)`${errSchemaPath}/$comment`;
        const rootName = gen.scopeValue("root", { ref: schemaEnv.root });
        gen.code((0, codegen_1._)`${names_1.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);
      }
    }
    function returnResults(it) {
      const { gen, schemaEnv, validateName, ValidationError, opts } = it;
      if (schemaEnv.$async) {
        gen.if((0, codegen_1._)`${names_1.default.errors} === 0`, () => gen.return(names_1.default.data), () => gen.throw((0, codegen_1._)`new ${ValidationError}(${names_1.default.vErrors})`));
      } else {
        gen.assign((0, codegen_1._)`${validateName}.errors`, names_1.default.vErrors);
        if (opts.unevaluated)
          assignEvaluated(it);
        gen.return((0, codegen_1._)`${names_1.default.errors} === 0`);
      }
    }
    function assignEvaluated({ gen, evaluated, props, items }) {
      if (props instanceof codegen_1.Name)
        gen.assign((0, codegen_1._)`${evaluated}.props`, props);
      if (items instanceof codegen_1.Name)
        gen.assign((0, codegen_1._)`${evaluated}.items`, items);
    }
    function schemaKeywords(it, types, typeErrors, errsCount) {
      const { gen, schema, data, allErrors, opts, self } = it;
      const { RULES } = self;
      if (schema.$ref && (opts.ignoreKeywordsWithRef || !(0, util_1.schemaHasRulesButRef)(schema, RULES))) {
        gen.block(() => keywordCode(it, "$ref", RULES.all.$ref.definition));
        return;
      }
      if (!opts.jtd)
        checkStrictTypes(it, types);
      gen.block(() => {
        for (const group of RULES.rules)
          groupKeywords(group);
        groupKeywords(RULES.post);
      });
      function groupKeywords(group) {
        if (!(0, applicability_1.shouldUseGroup)(schema, group))
          return;
        if (group.type) {
          gen.if((0, dataType_2.checkDataType)(group.type, data, opts.strictNumbers));
          iterateKeywords(it, group);
          if (types.length === 1 && types[0] === group.type && typeErrors) {
            gen.else();
            (0, dataType_2.reportTypeError)(it);
          }
          gen.endIf();
        } else {
          iterateKeywords(it, group);
        }
        if (!allErrors)
          gen.if((0, codegen_1._)`${names_1.default.errors} === ${errsCount || 0}`);
      }
    }
    function iterateKeywords(it, group) {
      const { gen, schema, opts: { useDefaults } } = it;
      if (useDefaults)
        (0, defaults_1.assignDefaults)(it, group.type);
      gen.block(() => {
        for (const rule of group.rules) {
          if ((0, applicability_1.shouldUseRule)(schema, rule)) {
            keywordCode(it, rule.keyword, rule.definition, group.type);
          }
        }
      });
    }
    function checkStrictTypes(it, types) {
      if (it.schemaEnv.meta || !it.opts.strictTypes)
        return;
      checkContextTypes(it, types);
      if (!it.opts.allowUnionTypes)
        checkMultipleTypes(it, types);
      checkKeywordTypes(it, it.dataTypes);
    }
    function checkContextTypes(it, types) {
      if (!types.length)
        return;
      if (!it.dataTypes.length) {
        it.dataTypes = types;
        return;
      }
      types.forEach((t) => {
        if (!includesType(it.dataTypes, t)) {
          strictTypesError(it, `type "${t}" not allowed by context "${it.dataTypes.join(",")}"`);
        }
      });
      narrowSchemaTypes(it, types);
    }
    function checkMultipleTypes(it, ts) {
      if (ts.length > 1 && !(ts.length === 2 && ts.includes("null"))) {
        strictTypesError(it, "use allowUnionTypes to allow union type keyword");
      }
    }
    function checkKeywordTypes(it, ts) {
      const rules = it.self.RULES.all;
      for (const keyword in rules) {
        const rule = rules[keyword];
        if (typeof rule == "object" && (0, applicability_1.shouldUseRule)(it.schema, rule)) {
          const { type } = rule.definition;
          if (type.length && !type.some((t) => hasApplicableType(ts, t))) {
            strictTypesError(it, `missing type "${type.join(",")}" for keyword "${keyword}"`);
          }
        }
      }
    }
    function hasApplicableType(schTs, kwdT) {
      return schTs.includes(kwdT) || kwdT === "number" && schTs.includes("integer");
    }
    function includesType(ts, t) {
      return ts.includes(t) || t === "integer" && ts.includes("number");
    }
    function narrowSchemaTypes(it, withTypes) {
      const ts = [];
      for (const t of it.dataTypes) {
        if (includesType(withTypes, t))
          ts.push(t);
        else if (withTypes.includes("integer") && t === "number")
          ts.push("integer");
      }
      it.dataTypes = ts;
    }
    function strictTypesError(it, msg) {
      const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
      msg += ` at "${schemaPath}" (strictTypes)`;
      (0, util_1.checkStrictMode)(it, msg, it.opts.strictTypes);
    }
    var KeywordCxt = class {
      constructor(it, def, keyword) {
        (0, keyword_1.validateKeywordUsage)(it, def, keyword);
        this.gen = it.gen;
        this.allErrors = it.allErrors;
        this.keyword = keyword;
        this.data = it.data;
        this.schema = it.schema[keyword];
        this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data;
        this.schemaValue = (0, util_1.schemaRefOrVal)(it, this.schema, keyword, this.$data);
        this.schemaType = def.schemaType;
        this.parentSchema = it.schema;
        this.params = {};
        this.it = it;
        this.def = def;
        if (this.$data) {
          this.schemaCode = it.gen.const("vSchema", getData(this.$data, it));
        } else {
          this.schemaCode = this.schemaValue;
          if (!(0, keyword_1.validSchemaType)(this.schema, def.schemaType, def.allowUndefined)) {
            throw new Error(`${keyword} value must be ${JSON.stringify(def.schemaType)}`);
          }
        }
        if ("code" in def ? def.trackErrors : def.errors !== false) {
          this.errsCount = it.gen.const("_errs", names_1.default.errors);
        }
      }
      result(condition, successAction, failAction) {
        this.failResult((0, codegen_1.not)(condition), successAction, failAction);
      }
      failResult(condition, successAction, failAction) {
        this.gen.if(condition);
        if (failAction)
          failAction();
        else
          this.error();
        if (successAction) {
          this.gen.else();
          successAction();
          if (this.allErrors)
            this.gen.endIf();
        } else {
          if (this.allErrors)
            this.gen.endIf();
          else
            this.gen.else();
        }
      }
      pass(condition, failAction) {
        this.failResult((0, codegen_1.not)(condition), void 0, failAction);
      }
      fail(condition) {
        if (condition === void 0) {
          this.error();
          if (!this.allErrors)
            this.gen.if(false);
          return;
        }
        this.gen.if(condition);
        this.error();
        if (this.allErrors)
          this.gen.endIf();
        else
          this.gen.else();
      }
      fail$data(condition) {
        if (!this.$data)
          return this.fail(condition);
        const { schemaCode } = this;
        this.fail((0, codegen_1._)`${schemaCode} !== undefined && (${(0, codegen_1.or)(this.invalid$data(), condition)})`);
      }
      error(append, errorParams, errorPaths) {
        if (errorParams) {
          this.setParams(errorParams);
          this._error(append, errorPaths);
          this.setParams({});
          return;
        }
        this._error(append, errorPaths);
      }
      _error(append, errorPaths) {
        ;
        (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);
      }
      $dataError() {
        (0, errors_1.reportError)(this, this.def.$dataError || errors_1.keyword$DataError);
      }
      reset() {
        if (this.errsCount === void 0)
          throw new Error('add "trackErrors" to keyword definition');
        (0, errors_1.resetErrorsCount)(this.gen, this.errsCount);
      }
      ok(cond) {
        if (!this.allErrors)
          this.gen.if(cond);
      }
      setParams(obj, assign) {
        if (assign)
          Object.assign(this.params, obj);
        else
          this.params = obj;
      }
      block$data(valid, codeBlock, $dataValid = codegen_1.nil) {
        this.gen.block(() => {
          this.check$data(valid, $dataValid);
          codeBlock();
        });
      }
      check$data(valid = codegen_1.nil, $dataValid = codegen_1.nil) {
        if (!this.$data)
          return;
        const { gen, schemaCode, schemaType, def } = this;
        gen.if((0, codegen_1.or)((0, codegen_1._)`${schemaCode} === undefined`, $dataValid));
        if (valid !== codegen_1.nil)
          gen.assign(valid, true);
        if (schemaType.length || def.validateSchema) {
          gen.elseIf(this.invalid$data());
          this.$dataError();
          if (valid !== codegen_1.nil)
            gen.assign(valid, false);
        }
        gen.else();
      }
      invalid$data() {
        const { gen, schemaCode, schemaType, def, it } = this;
        return (0, codegen_1.or)(wrong$DataType(), invalid$DataSchema());
        function wrong$DataType() {
          if (schemaType.length) {
            if (!(schemaCode instanceof codegen_1.Name))
              throw new Error("ajv implementation error");
            const st = Array.isArray(schemaType) ? schemaType : [schemaType];
            return (0, codegen_1._)`${(0, dataType_2.checkDataTypes)(st, schemaCode, it.opts.strictNumbers, dataType_2.DataType.Wrong)}`;
          }
          return codegen_1.nil;
        }
        function invalid$DataSchema() {
          if (def.validateSchema) {
            const validateSchemaRef = gen.scopeValue("validate$data", { ref: def.validateSchema });
            return (0, codegen_1._)`!${validateSchemaRef}(${schemaCode})`;
          }
          return codegen_1.nil;
        }
      }
      subschema(appl, valid) {
        const subschema = (0, subschema_1.getSubschema)(this.it, appl);
        (0, subschema_1.extendSubschemaData)(subschema, this.it, appl);
        (0, subschema_1.extendSubschemaMode)(subschema, appl);
        const nextContext = { ...this.it, ...subschema, items: void 0, props: void 0 };
        subschemaCode(nextContext, valid);
        return nextContext;
      }
      mergeEvaluated(schemaCxt, toName) {
        const { it, gen } = this;
        if (!it.opts.unevaluated)
          return;
        if (it.props !== true && schemaCxt.props !== void 0) {
          it.props = util_1.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName);
        }
        if (it.items !== true && schemaCxt.items !== void 0) {
          it.items = util_1.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName);
        }
      }
      mergeValidEvaluated(schemaCxt, valid) {
        const { it, gen } = this;
        if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {
          gen.if(valid, () => this.mergeEvaluated(schemaCxt, codegen_1.Name));
          return true;
        }
      }
    };
    exports.KeywordCxt = KeywordCxt;
    function keywordCode(it, keyword, def, ruleType) {
      const cxt = new KeywordCxt(it, def, keyword);
      if ("code" in def) {
        def.code(cxt, ruleType);
      } else if (cxt.$data && def.validate) {
        (0, keyword_1.funcKeywordCode)(cxt, def);
      } else if ("macro" in def) {
        (0, keyword_1.macroKeywordCode)(cxt, def);
      } else if (def.compile || def.validate) {
        (0, keyword_1.funcKeywordCode)(cxt, def);
      }
    }
    var JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
    var RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
    function getData($data, { dataLevel, dataNames, dataPathArr }) {
      let jsonPointer;
      let data;
      if ($data === "")
        return names_1.default.rootData;
      if ($data[0] === "/") {
        if (!JSON_POINTER.test($data))
          throw new Error(`Invalid JSON-pointer: ${$data}`);
        jsonPointer = $data;
        data = names_1.default.rootData;
      } else {
        const matches = RELATIVE_JSON_POINTER.exec($data);
        if (!matches)
          throw new Error(`Invalid JSON-pointer: ${$data}`);
        const up = +matches[1];
        jsonPointer = matches[2];
        if (jsonPointer === "#") {
          if (up >= dataLevel)
            throw new Error(errorMsg("property/index", up));
          return dataPathArr[dataLevel - up];
        }
        if (up > dataLevel)
          throw new Error(errorMsg("data", up));
        data = dataNames[dataLevel - up];
        if (!jsonPointer)
          return data;
      }
      let expr = data;
      const segments = jsonPointer.split("/");
      for (const segment of segments) {
        if (segment) {
          data = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)((0, util_1.unescapeJsonPointer)(segment))}`;
          expr = (0, codegen_1._)`${expr} && ${data}`;
        }
      }
      return expr;
      function errorMsg(pointerType, up) {
        return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;
      }
    }
    exports.getData = getData;
  }
});

// node_modules/ajv/dist/runtime/validation_error.js
var require_validation_error = __commonJS({
  "node_modules/ajv/dist/runtime/validation_error.js"(exports) {
    "use strict";
    var import_dist16 = __toESM(require_dist());
    var import_dist17 = __toESM(require_dist2());
    var import_dist18 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var ValidationError = class extends Error {
      constructor(errors) {
        super("validation failed");
        this.errors = errors;
        this.ajv = this.validation = true;
      }
    };
    exports.default = ValidationError;
  }
});

// node_modules/ajv/dist/compile/ref_error.js
var require_ref_error = __commonJS({
  "node_modules/ajv/dist/compile/ref_error.js"(exports) {
    "use strict";
    var import_dist16 = __toESM(require_dist());
    var import_dist17 = __toESM(require_dist2());
    var import_dist18 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var resolve_1 = require_resolve();
    var MissingRefError = class extends Error {
      constructor(resolver, baseId, ref, msg) {
        super(msg || `can't resolve reference ${ref} from id ${baseId}`);
        this.missingRef = (0, resolve_1.resolveUrl)(resolver, baseId, ref);
        this.missingSchema = (0, resolve_1.normalizeId)((0, resolve_1.getFullPath)(resolver, this.missingRef));
      }
    };
    exports.default = MissingRefError;
  }
});

// node_modules/ajv/dist/compile/index.js
var require_compile = __commonJS({
  "node_modules/ajv/dist/compile/index.js"(exports) {
    "use strict";
    var import_dist16 = __toESM(require_dist());
    var import_dist17 = __toESM(require_dist2());
    var import_dist18 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.resolveSchema = exports.getCompilingSchema = exports.resolveRef = exports.compileSchema = exports.SchemaEnv = void 0;
    var codegen_1 = require_codegen();
    var validation_error_1 = require_validation_error();
    var names_1 = require_names();
    var resolve_1 = require_resolve();
    var util_1 = require_util();
    var validate_1 = require_validate();
    var SchemaEnv = class {
      constructor(env) {
        var _a;
        this.refs = {};
        this.dynamicAnchors = {};
        let schema;
        if (typeof env.schema == "object")
          schema = env.schema;
        this.schema = env.schema;
        this.schemaId = env.schemaId;
        this.root = env.root || this;
        this.baseId = (_a = env.baseId) !== null && _a !== void 0 ? _a : (0, resolve_1.normalizeId)(schema === null || schema === void 0 ? void 0 : schema[env.schemaId || "$id"]);
        this.schemaPath = env.schemaPath;
        this.localRefs = env.localRefs;
        this.meta = env.meta;
        this.$async = schema === null || schema === void 0 ? void 0 : schema.$async;
        this.refs = {};
      }
    };
    exports.SchemaEnv = SchemaEnv;
    function compileSchema(sch) {
      const _sch = getCompilingSchema.call(this, sch);
      if (_sch)
        return _sch;
      const rootId = (0, resolve_1.getFullPath)(this.opts.uriResolver, sch.root.baseId);
      const { es5, lines } = this.opts.code;
      const { ownProperties } = this.opts;
      const gen = new codegen_1.CodeGen(this.scope, { es5, lines, ownProperties });
      let _ValidationError;
      if (sch.$async) {
        _ValidationError = gen.scopeValue("Error", {
          ref: validation_error_1.default,
          code: (0, codegen_1._)`require("ajv/dist/runtime/validation_error").default`
        });
      }
      const validateName = gen.scopeName("validate");
      sch.validateName = validateName;
      const schemaCxt = {
        gen,
        allErrors: this.opts.allErrors,
        data: names_1.default.data,
        parentData: names_1.default.parentData,
        parentDataProperty: names_1.default.parentDataProperty,
        dataNames: [names_1.default.data],
        dataPathArr: [codegen_1.nil],
        // TODO can its length be used as dataLevel if nil is removed?
        dataLevel: 0,
        dataTypes: [],
        definedProperties: /* @__PURE__ */ new Set(),
        topSchemaRef: gen.scopeValue("schema", this.opts.code.source === true ? { ref: sch.schema, code: (0, codegen_1.stringify)(sch.schema) } : { ref: sch.schema }),
        validateName,
        ValidationError: _ValidationError,
        schema: sch.schema,
        schemaEnv: sch,
        rootId,
        baseId: sch.baseId || rootId,
        schemaPath: codegen_1.nil,
        errSchemaPath: sch.schemaPath || (this.opts.jtd ? "" : "#"),
        errorPath: (0, codegen_1._)`""`,
        opts: this.opts,
        self: this
      };
      let sourceCode;
      try {
        this._compilations.add(sch);
        (0, validate_1.validateFunctionCode)(schemaCxt);
        gen.optimize(this.opts.code.optimize);
        const validateCode = gen.toString();
        sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${validateCode}`;
        if (this.opts.code.process)
          sourceCode = this.opts.code.process(sourceCode, sch);
        const makeValidate = new Function(`${names_1.default.self}`, `${names_1.default.scope}`, sourceCode);
        const validate = makeValidate(this, this.scope.get());
        this.scope.value(validateName, { ref: validate });
        validate.errors = null;
        validate.schema = sch.schema;
        validate.schemaEnv = sch;
        if (sch.$async)
          validate.$async = true;
        if (this.opts.code.source === true) {
          validate.source = { validateName, validateCode, scopeValues: gen._values };
        }
        if (this.opts.unevaluated) {
          const { props, items } = schemaCxt;
          validate.evaluated = {
            props: props instanceof codegen_1.Name ? void 0 : props,
            items: items instanceof codegen_1.Name ? void 0 : items,
            dynamicProps: props instanceof codegen_1.Name,
            dynamicItems: items instanceof codegen_1.Name
          };
          if (validate.source)
            validate.source.evaluated = (0, codegen_1.stringify)(validate.evaluated);
        }
        sch.validate = validate;
        return sch;
      } catch (e) {
        delete sch.validate;
        delete sch.validateName;
        if (sourceCode)
          this.logger.error("Error compiling schema, function code:", sourceCode);
        throw e;
      } finally {
        this._compilations.delete(sch);
      }
    }
    exports.compileSchema = compileSchema;
    function resolveRef(root, baseId, ref) {
      var _a;
      ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, ref);
      const schOrFunc = root.refs[ref];
      if (schOrFunc)
        return schOrFunc;
      let _sch = resolve.call(this, root, ref);
      if (_sch === void 0) {
        const schema = (_a = root.localRefs) === null || _a === void 0 ? void 0 : _a[ref];
        const { schemaId } = this.opts;
        if (schema)
          _sch = new SchemaEnv({ schema, schemaId, root, baseId });
      }
      if (_sch === void 0)
        return;
      return root.refs[ref] = inlineOrCompile.call(this, _sch);
    }
    exports.resolveRef = resolveRef;
    function inlineOrCompile(sch) {
      if ((0, resolve_1.inlineRef)(sch.schema, this.opts.inlineRefs))
        return sch.schema;
      return sch.validate ? sch : compileSchema.call(this, sch);
    }
    function getCompilingSchema(schEnv) {
      for (const sch of this._compilations) {
        if (sameSchemaEnv(sch, schEnv))
          return sch;
      }
    }
    exports.getCompilingSchema = getCompilingSchema;
    function sameSchemaEnv(s1, s2) {
      return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;
    }
    function resolve(root, ref) {
      let sch;
      while (typeof (sch = this.refs[ref]) == "string")
        ref = sch;
      return sch || this.schemas[ref] || resolveSchema.call(this, root, ref);
    }
    function resolveSchema(root, ref) {
      const p = this.opts.uriResolver.parse(ref);
      const refPath = (0, resolve_1._getFullPath)(this.opts.uriResolver, p);
      let baseId = (0, resolve_1.getFullPath)(this.opts.uriResolver, root.baseId, void 0);
      if (Object.keys(root.schema).length > 0 && refPath === baseId) {
        return getJsonPointer.call(this, p, root);
      }
      const id = (0, resolve_1.normalizeId)(refPath);
      const schOrRef = this.refs[id] || this.schemas[id];
      if (typeof schOrRef == "string") {
        const sch = resolveSchema.call(this, root, schOrRef);
        if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== "object")
          return;
        return getJsonPointer.call(this, p, sch);
      }
      if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== "object")
        return;
      if (!schOrRef.validate)
        compileSchema.call(this, schOrRef);
      if (id === (0, resolve_1.normalizeId)(ref)) {
        const { schema } = schOrRef;
        const { schemaId } = this.opts;
        const schId = schema[schemaId];
        if (schId)
          baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
        return new SchemaEnv({ schema, schemaId, root, baseId });
      }
      return getJsonPointer.call(this, p, schOrRef);
    }
    exports.resolveSchema = resolveSchema;
    var PREVENT_SCOPE_CHANGE = /* @__PURE__ */ new Set([
      "properties",
      "patternProperties",
      "enum",
      "dependencies",
      "definitions"
    ]);
    function getJsonPointer(parsedRef, { baseId, schema, root }) {
      var _a;
      if (((_a = parsedRef.fragment) === null || _a === void 0 ? void 0 : _a[0]) !== "/")
        return;
      for (const part of parsedRef.fragment.slice(1).split("/")) {
        if (typeof schema === "boolean")
          return;
        const partSchema = schema[(0, util_1.unescapeFragment)(part)];
        if (partSchema === void 0)
          return;
        schema = partSchema;
        const schId = typeof schema === "object" && schema[this.opts.schemaId];
        if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {
          baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
        }
      }
      let env;
      if (typeof schema != "boolean" && schema.$ref && !(0, util_1.schemaHasRulesButRef)(schema, this.RULES)) {
        const $ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schema.$ref);
        env = resolveSchema.call(this, root, $ref);
      }
      const { schemaId } = this.opts;
      env = env || new SchemaEnv({ schema, schemaId, root, baseId });
      if (env.schema !== env.root.schema)
        return env;
      return void 0;
    }
  }
});

// node_modules/ajv/dist/refs/data.json
var require_data = __commonJS({
  "node_modules/ajv/dist/refs/data.json"(exports, module) {
    module.exports = {
      $id: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
      description: "Meta-schema for $data reference (JSON AnySchema extension proposal)",
      type: "object",
      required: ["$data"],
      properties: {
        $data: {
          type: "string",
          anyOf: [{ format: "relative-json-pointer" }, { format: "json-pointer" }]
        }
      },
      additionalProperties: false
    };
  }
});

// node_modules/fast-uri/lib/scopedChars.js
var require_scopedChars = __commonJS({
  "node_modules/fast-uri/lib/scopedChars.js"(exports, module) {
    "use strict";
    var import_dist16 = __toESM(require_dist());
    var import_dist17 = __toESM(require_dist2());
    var import_dist18 = __toESM(require_dist3());
    var HEX = {
      0: 0,
      1: 1,
      2: 2,
      3: 3,
      4: 4,
      5: 5,
      6: 6,
      7: 7,
      8: 8,
      9: 9,
      a: 10,
      A: 10,
      b: 11,
      B: 11,
      c: 12,
      C: 12,
      d: 13,
      D: 13,
      e: 14,
      E: 14,
      f: 15,
      F: 15
    };
    module.exports = {
      HEX
    };
  }
});

// node_modules/fast-uri/lib/utils.js
var require_utils = __commonJS({
  "node_modules/fast-uri/lib/utils.js"(exports, module) {
    "use strict";
    var import_dist16 = __toESM(require_dist());
    var import_dist17 = __toESM(require_dist2());
    var import_dist18 = __toESM(require_dist3());
    var { HEX } = require_scopedChars();
    var IPV4_REG = /^(?:(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)$/u;
    function normalizeIPv4(host) {
      if (findToken(host, ".") < 3) {
        return { host, isIPV4: false };
      }
      const matches = host.match(IPV4_REG) || [];
      const [address] = matches;
      if (address) {
        return { host: stripLeadingZeros(address, "."), isIPV4: true };
      } else {
        return { host, isIPV4: false };
      }
    }
    function stringArrayToHexStripped(input, keepZero = false) {
      let acc = "";
      let strip = true;
      for (const c of input) {
        if (HEX[c] === void 0) return void 0;
        if (c !== "0" && strip === true) strip = false;
        if (!strip) acc += c;
      }
      if (keepZero && acc.length === 0) acc = "0";
      return acc;
    }
    function getIPV6(input) {
      let tokenCount = 0;
      const output = { error: false, address: "", zone: "" };
      const address = [];
      const buffer = [];
      let isZone = false;
      let endipv6Encountered = false;
      let endIpv6 = false;
      function consume() {
        if (buffer.length) {
          if (isZone === false) {
            const hex = stringArrayToHexStripped(buffer);
            if (hex !== void 0) {
              address.push(hex);
            } else {
              output.error = true;
              return false;
            }
          }
          buffer.length = 0;
        }
        return true;
      }
      for (let i = 0; i < input.length; i++) {
        const cursor = input[i];
        if (cursor === "[" || cursor === "]") {
          continue;
        }
        if (cursor === ":") {
          if (endipv6Encountered === true) {
            endIpv6 = true;
          }
          if (!consume()) {
            break;
          }
          tokenCount++;
          address.push(":");
          if (tokenCount > 7) {
            output.error = true;
            break;
          }
          if (i - 1 >= 0 && input[i - 1] === ":") {
            endipv6Encountered = true;
          }
          continue;
        } else if (cursor === "%") {
          if (!consume()) {
            break;
          }
          isZone = true;
        } else {
          buffer.push(cursor);
          continue;
        }
      }
      if (buffer.length) {
        if (isZone) {
          output.zone = buffer.join("");
        } else if (endIpv6) {
          address.push(buffer.join(""));
        } else {
          address.push(stringArrayToHexStripped(buffer));
        }
      }
      output.address = address.join("");
      return output;
    }
    function normalizeIPv6(host) {
      if (findToken(host, ":") < 2) {
        return { host, isIPV6: false };
      }
      const ipv6 = getIPV6(host);
      if (!ipv6.error) {
        let newHost = ipv6.address;
        let escapedHost = ipv6.address;
        if (ipv6.zone) {
          newHost += "%" + ipv6.zone;
          escapedHost += "%25" + ipv6.zone;
        }
        return { host: newHost, escapedHost, isIPV6: true };
      } else {
        return { host, isIPV6: false };
      }
    }
    function stripLeadingZeros(str, token) {
      let out = "";
      let skip = true;
      const l = str.length;
      for (let i = 0; i < l; i++) {
        const c = str[i];
        if (c === "0" && skip) {
          if (i + 1 <= l && str[i + 1] === token || i + 1 === l) {
            out += c;
            skip = false;
          }
        } else {
          if (c === token) {
            skip = true;
          } else {
            skip = false;
          }
          out += c;
        }
      }
      return out;
    }
    function findToken(str, token) {
      let ind = 0;
      for (let i = 0; i < str.length; i++) {
        if (str[i] === token) ind++;
      }
      return ind;
    }
    var RDS1 = /^\.\.?\//u;
    var RDS2 = /^\/\.(?:\/|$)/u;
    var RDS3 = /^\/\.\.(?:\/|$)/u;
    var RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/u;
    function removeDotSegments(input) {
      const output = [];
      while (input.length) {
        if (input.match(RDS1)) {
          input = input.replace(RDS1, "");
        } else if (input.match(RDS2)) {
          input = input.replace(RDS2, "/");
        } else if (input.match(RDS3)) {
          input = input.replace(RDS3, "/");
          output.pop();
        } else if (input === "." || input === "..") {
          input = "";
        } else {
          const im = input.match(RDS5);
          if (im) {
            const s = im[0];
            input = input.slice(s.length);
            output.push(s);
          } else {
            throw new Error("Unexpected dot segment condition");
          }
        }
      }
      return output.join("");
    }
    function normalizeComponentEncoding(components, esc) {
      const func = esc !== true ? escape : unescape;
      if (components.scheme !== void 0) {
        components.scheme = func(components.scheme);
      }
      if (components.userinfo !== void 0) {
        components.userinfo = func(components.userinfo);
      }
      if (components.host !== void 0) {
        components.host = func(components.host);
      }
      if (components.path !== void 0) {
        components.path = func(components.path);
      }
      if (components.query !== void 0) {
        components.query = func(components.query);
      }
      if (components.fragment !== void 0) {
        components.fragment = func(components.fragment);
      }
      return components;
    }
    function recomposeAuthority(components) {
      const uriTokens = [];
      if (components.userinfo !== void 0) {
        uriTokens.push(components.userinfo);
        uriTokens.push("@");
      }
      if (components.host !== void 0) {
        let host = unescape(components.host);
        const ipV4res = normalizeIPv4(host);
        if (ipV4res.isIPV4) {
          host = ipV4res.host;
        } else {
          const ipV6res = normalizeIPv6(ipV4res.host);
          if (ipV6res.isIPV6 === true) {
            host = `[${ipV6res.escapedHost}]`;
          } else {
            host = components.host;
          }
        }
        uriTokens.push(host);
      }
      if (typeof components.port === "number" || typeof components.port === "string") {
        uriTokens.push(":");
        uriTokens.push(String(components.port));
      }
      return uriTokens.length ? uriTokens.join("") : void 0;
    }
    module.exports = {
      recomposeAuthority,
      normalizeComponentEncoding,
      removeDotSegments,
      normalizeIPv4,
      normalizeIPv6,
      stringArrayToHexStripped
    };
  }
});

// node_modules/fast-uri/lib/schemes.js
var require_schemes = __commonJS({
  "node_modules/fast-uri/lib/schemes.js"(exports, module) {
    "use strict";
    var import_dist16 = __toESM(require_dist());
    var import_dist17 = __toESM(require_dist2());
    var import_dist18 = __toESM(require_dist3());
    var UUID_REG = /^[\da-f]{8}-[\da-f]{4}-[\da-f]{4}-[\da-f]{4}-[\da-f]{12}$/iu;
    var URN_REG = /([\da-z][\d\-a-z]{0,31}):((?:[\w!$'()*+,\-.:;=@]|%[\da-f]{2})+)/iu;
    function isSecure(wsComponents) {
      return typeof wsComponents.secure === "boolean" ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === "wss";
    }
    function httpParse(components) {
      if (!components.host) {
        components.error = components.error || "HTTP URIs must have a host.";
      }
      return components;
    }
    function httpSerialize(components) {
      const secure = String(components.scheme).toLowerCase() === "https";
      if (components.port === (secure ? 443 : 80) || components.port === "") {
        components.port = void 0;
      }
      if (!components.path) {
        components.path = "/";
      }
      return components;
    }
    function wsParse(wsComponents) {
      wsComponents.secure = isSecure(wsComponents);
      wsComponents.resourceName = (wsComponents.path || "/") + (wsComponents.query ? "?" + wsComponents.query : "");
      wsComponents.path = void 0;
      wsComponents.query = void 0;
      return wsComponents;
    }
    function wsSerialize(wsComponents) {
      if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === "") {
        wsComponents.port = void 0;
      }
      if (typeof wsComponents.secure === "boolean") {
        wsComponents.scheme = wsComponents.secure ? "wss" : "ws";
        wsComponents.secure = void 0;
      }
      if (wsComponents.resourceName) {
        const [path, query] = wsComponents.resourceName.split("?");
        wsComponents.path = path && path !== "/" ? path : void 0;
        wsComponents.query = query;
        wsComponents.resourceName = void 0;
      }
      wsComponents.fragment = void 0;
      return wsComponents;
    }
    function urnParse(urnComponents, options) {
      if (!urnComponents.path) {
        urnComponents.error = "URN can not be parsed";
        return urnComponents;
      }
      const matches = urnComponents.path.match(URN_REG);
      if (matches) {
        const scheme = options.scheme || urnComponents.scheme || "urn";
        urnComponents.nid = matches[1].toLowerCase();
        urnComponents.nss = matches[2];
        const urnScheme = `${scheme}:${options.nid || urnComponents.nid}`;
        const schemeHandler = SCHEMES[urnScheme];
        urnComponents.path = void 0;
        if (schemeHandler) {
          urnComponents = schemeHandler.parse(urnComponents, options);
        }
      } else {
        urnComponents.error = urnComponents.error || "URN can not be parsed.";
      }
      return urnComponents;
    }
    function urnSerialize(urnComponents, options) {
      const scheme = options.scheme || urnComponents.scheme || "urn";
      const nid = urnComponents.nid.toLowerCase();
      const urnScheme = `${scheme}:${options.nid || nid}`;
      const schemeHandler = SCHEMES[urnScheme];
      if (schemeHandler) {
        urnComponents = schemeHandler.serialize(urnComponents, options);
      }
      const uriComponents = urnComponents;
      const nss = urnComponents.nss;
      uriComponents.path = `${nid || options.nid}:${nss}`;
      options.skipEscape = true;
      return uriComponents;
    }
    function urnuuidParse(urnComponents, options) {
      const uuidComponents = urnComponents;
      uuidComponents.uuid = uuidComponents.nss;
      uuidComponents.nss = void 0;
      if (!options.tolerant && (!uuidComponents.uuid || !UUID_REG.test(uuidComponents.uuid))) {
        uuidComponents.error = uuidComponents.error || "UUID is not valid.";
      }
      return uuidComponents;
    }
    function urnuuidSerialize(uuidComponents) {
      const urnComponents = uuidComponents;
      urnComponents.nss = (uuidComponents.uuid || "").toLowerCase();
      return urnComponents;
    }
    var http = {
      scheme: "http",
      domainHost: true,
      parse: httpParse,
      serialize: httpSerialize
    };
    var https = {
      scheme: "https",
      domainHost: http.domainHost,
      parse: httpParse,
      serialize: httpSerialize
    };
    var ws = {
      scheme: "ws",
      domainHost: true,
      parse: wsParse,
      serialize: wsSerialize
    };
    var wss = {
      scheme: "wss",
      domainHost: ws.domainHost,
      parse: ws.parse,
      serialize: ws.serialize
    };
    var urn = {
      scheme: "urn",
      parse: urnParse,
      serialize: urnSerialize,
      skipNormalize: true
    };
    var urnuuid = {
      scheme: "urn:uuid",
      parse: urnuuidParse,
      serialize: urnuuidSerialize,
      skipNormalize: true
    };
    var SCHEMES = {
      http,
      https,
      ws,
      wss,
      urn,
      "urn:uuid": urnuuid
    };
    module.exports = SCHEMES;
  }
});

// node_modules/fast-uri/index.js
var require_fast_uri = __commonJS({
  "node_modules/fast-uri/index.js"(exports, module) {
    "use strict";
    var import_dist16 = __toESM(require_dist());
    var import_dist17 = __toESM(require_dist2());
    var import_dist18 = __toESM(require_dist3());
    var { normalizeIPv6, normalizeIPv4, removeDotSegments, recomposeAuthority, normalizeComponentEncoding } = require_utils();
    var SCHEMES = require_schemes();
    function normalize(uri, options) {
      if (typeof uri === "string") {
        uri = serialize(parse(uri, options), options);
      } else if (typeof uri === "object") {
        uri = parse(serialize(uri, options), options);
      }
      return uri;
    }
    function resolve(baseURI, relativeURI, options) {
      const schemelessOptions = Object.assign({ scheme: "null" }, options);
      const resolved = resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true);
      return serialize(resolved, { ...schemelessOptions, skipEscape: true });
    }
    function resolveComponents(base, relative, options, skipNormalization) {
      const target = {};
      if (!skipNormalization) {
        base = parse(serialize(base, options), options);
        relative = parse(serialize(relative, options), options);
      }
      options = options || {};
      if (!options.tolerant && relative.scheme) {
        target.scheme = relative.scheme;
        target.userinfo = relative.userinfo;
        target.host = relative.host;
        target.port = relative.port;
        target.path = removeDotSegments(relative.path || "");
        target.query = relative.query;
      } else {
        if (relative.userinfo !== void 0 || relative.host !== void 0 || relative.port !== void 0) {
          target.userinfo = relative.userinfo;
          target.host = relative.host;
          target.port = relative.port;
          target.path = removeDotSegments(relative.path || "");
          target.query = relative.query;
        } else {
          if (!relative.path) {
            target.path = base.path;
            if (relative.query !== void 0) {
              target.query = relative.query;
            } else {
              target.query = base.query;
            }
          } else {
            if (relative.path.charAt(0) === "/") {
              target.path = removeDotSegments(relative.path);
            } else {
              if ((base.userinfo !== void 0 || base.host !== void 0 || base.port !== void 0) && !base.path) {
                target.path = "/" + relative.path;
              } else if (!base.path) {
                target.path = relative.path;
              } else {
                target.path = base.path.slice(0, base.path.lastIndexOf("/") + 1) + relative.path;
              }
              target.path = removeDotSegments(target.path);
            }
            target.query = relative.query;
          }
          target.userinfo = base.userinfo;
          target.host = base.host;
          target.port = base.port;
        }
        target.scheme = base.scheme;
      }
      target.fragment = relative.fragment;
      return target;
    }
    function equal(uriA, uriB, options) {
      if (typeof uriA === "string") {
        uriA = unescape(uriA);
        uriA = serialize(normalizeComponentEncoding(parse(uriA, options), true), { ...options, skipEscape: true });
      } else if (typeof uriA === "object") {
        uriA = serialize(normalizeComponentEncoding(uriA, true), { ...options, skipEscape: true });
      }
      if (typeof uriB === "string") {
        uriB = unescape(uriB);
        uriB = serialize(normalizeComponentEncoding(parse(uriB, options), true), { ...options, skipEscape: true });
      } else if (typeof uriB === "object") {
        uriB = serialize(normalizeComponentEncoding(uriB, true), { ...options, skipEscape: true });
      }
      return uriA.toLowerCase() === uriB.toLowerCase();
    }
    function serialize(cmpts, opts) {
      const components = {
        host: cmpts.host,
        scheme: cmpts.scheme,
        userinfo: cmpts.userinfo,
        port: cmpts.port,
        path: cmpts.path,
        query: cmpts.query,
        nid: cmpts.nid,
        nss: cmpts.nss,
        uuid: cmpts.uuid,
        fragment: cmpts.fragment,
        reference: cmpts.reference,
        resourceName: cmpts.resourceName,
        secure: cmpts.secure,
        error: ""
      };
      const options = Object.assign({}, opts);
      const uriTokens = [];
      const schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
      if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options);
      if (components.path !== void 0) {
        if (!options.skipEscape) {
          components.path = escape(components.path);
          if (components.scheme !== void 0) {
            components.path = components.path.split("%3A").join(":");
          }
        } else {
          components.path = unescape(components.path);
        }
      }
      if (options.reference !== "suffix" && components.scheme) {
        uriTokens.push(components.scheme, ":");
      }
      const authority = recomposeAuthority(components);
      if (authority !== void 0) {
        if (options.reference !== "suffix") {
          uriTokens.push("//");
        }
        uriTokens.push(authority);
        if (components.path && components.path.charAt(0) !== "/") {
          uriTokens.push("/");
        }
      }
      if (components.path !== void 0) {
        let s = components.path;
        if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
          s = removeDotSegments(s);
        }
        if (authority === void 0) {
          s = s.replace(/^\/\//u, "/%2F");
        }
        uriTokens.push(s);
      }
      if (components.query !== void 0) {
        uriTokens.push("?", components.query);
      }
      if (components.fragment !== void 0) {
        uriTokens.push("#", components.fragment);
      }
      return uriTokens.join("");
    }
    var hexLookUp = Array.from({ length: 127 }, (_v, k) => /[^!"$&'()*+,\-.;=_`a-z{}~]/u.test(String.fromCharCode(k)));
    function nonSimpleDomain(value) {
      let code = 0;
      for (let i = 0, len = value.length; i < len; ++i) {
        code = value.charCodeAt(i);
        if (code > 126 || hexLookUp[code]) {
          return true;
        }
      }
      return false;
    }
    var URI_PARSE = /^(?:([^#/:?]+):)?(?:\/\/((?:([^#/?@]*)@)?(\[[^#/?\]]+\]|[^#/:?]*)(?::(\d*))?))?([^#?]*)(?:\?([^#]*))?(?:#((?:.|[\n\r])*))?/u;
    function parse(uri, opts) {
      const options = Object.assign({}, opts);
      const parsed = {
        scheme: void 0,
        userinfo: void 0,
        host: "",
        port: void 0,
        path: "",
        query: void 0,
        fragment: void 0
      };
      const gotEncoding = uri.indexOf("%") !== -1;
      let isIP = false;
      if (options.reference === "suffix") uri = (options.scheme ? options.scheme + ":" : "") + "//" + uri;
      const matches = uri.match(URI_PARSE);
      if (matches) {
        parsed.scheme = matches[1];
        parsed.userinfo = matches[3];
        parsed.host = matches[4];
        parsed.port = parseInt(matches[5], 10);
        parsed.path = matches[6] || "";
        parsed.query = matches[7];
        parsed.fragment = matches[8];
        if (isNaN(parsed.port)) {
          parsed.port = matches[5];
        }
        if (parsed.host) {
          const ipv4result = normalizeIPv4(parsed.host);
          if (ipv4result.isIPV4 === false) {
            const ipv6result = normalizeIPv6(ipv4result.host);
            parsed.host = ipv6result.host.toLowerCase();
            isIP = ipv6result.isIPV6;
          } else {
            parsed.host = ipv4result.host;
            isIP = true;
          }
        }
        if (parsed.scheme === void 0 && parsed.userinfo === void 0 && parsed.host === void 0 && parsed.port === void 0 && parsed.query === void 0 && !parsed.path) {
          parsed.reference = "same-document";
        } else if (parsed.scheme === void 0) {
          parsed.reference = "relative";
        } else if (parsed.fragment === void 0) {
          parsed.reference = "absolute";
        } else {
          parsed.reference = "uri";
        }
        if (options.reference && options.reference !== "suffix" && options.reference !== parsed.reference) {
          parsed.error = parsed.error || "URI is not a " + options.reference + " reference.";
        }
        const schemeHandler = SCHEMES[(options.scheme || parsed.scheme || "").toLowerCase()];
        if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
          if (parsed.host && (options.domainHost || schemeHandler && schemeHandler.domainHost) && isIP === false && nonSimpleDomain(parsed.host)) {
            try {
              parsed.host = URL.domainToASCII(parsed.host.toLowerCase());
            } catch (e) {
              parsed.error = parsed.error || "Host's domain name can not be converted to ASCII: " + e;
            }
          }
        }
        if (!schemeHandler || schemeHandler && !schemeHandler.skipNormalize) {
          if (gotEncoding && parsed.scheme !== void 0) {
            parsed.scheme = unescape(parsed.scheme);
          }
          if (gotEncoding && parsed.host !== void 0) {
            parsed.host = unescape(parsed.host);
          }
          if (parsed.path) {
            parsed.path = escape(unescape(parsed.path));
          }
          if (parsed.fragment) {
            parsed.fragment = encodeURI(decodeURIComponent(parsed.fragment));
          }
        }
        if (schemeHandler && schemeHandler.parse) {
          schemeHandler.parse(parsed, options);
        }
      } else {
        parsed.error = parsed.error || "URI can not be parsed.";
      }
      return parsed;
    }
    var fastUri = {
      SCHEMES,
      normalize,
      resolve,
      resolveComponents,
      equal,
      serialize,
      parse
    };
    module.exports = fastUri;
    module.exports.default = fastUri;
    module.exports.fastUri = fastUri;
  }
});

// node_modules/ajv/dist/runtime/uri.js
var require_uri = __commonJS({
  "node_modules/ajv/dist/runtime/uri.js"(exports) {
    "use strict";
    var import_dist16 = __toESM(require_dist());
    var import_dist17 = __toESM(require_dist2());
    var import_dist18 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var uri = require_fast_uri();
    uri.code = 'require("ajv/dist/runtime/uri").default';
    exports.default = uri;
  }
});

// node_modules/ajv/dist/core.js
var require_core = __commonJS({
  "node_modules/ajv/dist/core.js"(exports) {
    "use strict";
    var import_dist16 = __toESM(require_dist());
    var import_dist17 = __toESM(require_dist2());
    var import_dist18 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;
    var validate_1 = require_validate();
    Object.defineProperty(exports, "KeywordCxt", { enumerable: true, get: function() {
      return validate_1.KeywordCxt;
    } });
    var codegen_1 = require_codegen();
    Object.defineProperty(exports, "_", { enumerable: true, get: function() {
      return codegen_1._;
    } });
    Object.defineProperty(exports, "str", { enumerable: true, get: function() {
      return codegen_1.str;
    } });
    Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
      return codegen_1.stringify;
    } });
    Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
      return codegen_1.nil;
    } });
    Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
      return codegen_1.Name;
    } });
    Object.defineProperty(exports, "CodeGen", { enumerable: true, get: function() {
      return codegen_1.CodeGen;
    } });
    var validation_error_1 = require_validation_error();
    var ref_error_1 = require_ref_error();
    var rules_1 = require_rules();
    var compile_1 = require_compile();
    var codegen_2 = require_codegen();
    var resolve_1 = require_resolve();
    var dataType_1 = require_dataType();
    var util_1 = require_util();
    var $dataRefSchema = require_data();
    var uri_1 = require_uri();
    var defaultRegExp = (str, flags) => new RegExp(str, flags);
    defaultRegExp.code = "new RegExp";
    var META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes"];
    var EXT_SCOPE_NAMES = /* @__PURE__ */ new Set([
      "validate",
      "serialize",
      "parse",
      "wrapper",
      "root",
      "schema",
      "keyword",
      "pattern",
      "formats",
      "validate$data",
      "func",
      "obj",
      "Error"
    ]);
    var removedOptions = {
      errorDataPath: "",
      format: "`validateFormats: false` can be used instead.",
      nullable: '"nullable" keyword is supported by default.',
      jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
      extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
      missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
      processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
      sourceCode: "Use option `code: {source: true}`",
      strictDefaults: "It is default now, see option `strict`.",
      strictKeywords: "It is default now, see option `strict`.",
      uniqueItems: '"uniqueItems" keyword is always validated.',
      unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
      cache: "Map is used as cache, schema object as key.",
      serialize: "Map is used as cache, schema object as key.",
      ajvErrors: "It is default now."
    };
    var deprecatedOptions = {
      ignoreKeywordsWithRef: "",
      jsPropertySyntax: "",
      unicode: '"minLength"/"maxLength" account for unicode characters by default.'
    };
    var MAX_EXPRESSION = 200;
    function requiredOptions(o) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;
      const s = o.strict;
      const _optz = (_a = o.code) === null || _a === void 0 ? void 0 : _a.optimize;
      const optimize = _optz === true || _optz === void 0 ? 1 : _optz || 0;
      const regExp = (_c = (_b = o.code) === null || _b === void 0 ? void 0 : _b.regExp) !== null && _c !== void 0 ? _c : defaultRegExp;
      const uriResolver = (_d = o.uriResolver) !== null && _d !== void 0 ? _d : uri_1.default;
      return {
        strictSchema: (_f = (_e = o.strictSchema) !== null && _e !== void 0 ? _e : s) !== null && _f !== void 0 ? _f : true,
        strictNumbers: (_h = (_g = o.strictNumbers) !== null && _g !== void 0 ? _g : s) !== null && _h !== void 0 ? _h : true,
        strictTypes: (_k = (_j = o.strictTypes) !== null && _j !== void 0 ? _j : s) !== null && _k !== void 0 ? _k : "log",
        strictTuples: (_m = (_l = o.strictTuples) !== null && _l !== void 0 ? _l : s) !== null && _m !== void 0 ? _m : "log",
        strictRequired: (_p = (_o = o.strictRequired) !== null && _o !== void 0 ? _o : s) !== null && _p !== void 0 ? _p : false,
        code: o.code ? { ...o.code, optimize, regExp } : { optimize, regExp },
        loopRequired: (_q = o.loopRequired) !== null && _q !== void 0 ? _q : MAX_EXPRESSION,
        loopEnum: (_r = o.loopEnum) !== null && _r !== void 0 ? _r : MAX_EXPRESSION,
        meta: (_s = o.meta) !== null && _s !== void 0 ? _s : true,
        messages: (_t = o.messages) !== null && _t !== void 0 ? _t : true,
        inlineRefs: (_u = o.inlineRefs) !== null && _u !== void 0 ? _u : true,
        schemaId: (_v = o.schemaId) !== null && _v !== void 0 ? _v : "$id",
        addUsedSchema: (_w = o.addUsedSchema) !== null && _w !== void 0 ? _w : true,
        validateSchema: (_x = o.validateSchema) !== null && _x !== void 0 ? _x : true,
        validateFormats: (_y = o.validateFormats) !== null && _y !== void 0 ? _y : true,
        unicodeRegExp: (_z = o.unicodeRegExp) !== null && _z !== void 0 ? _z : true,
        int32range: (_0 = o.int32range) !== null && _0 !== void 0 ? _0 : true,
        uriResolver
      };
    }
    var Ajv = class {
      constructor(opts = {}) {
        this.schemas = {};
        this.refs = {};
        this.formats = {};
        this._compilations = /* @__PURE__ */ new Set();
        this._loading = {};
        this._cache = /* @__PURE__ */ new Map();
        opts = this.opts = { ...opts, ...requiredOptions(opts) };
        const { es5, lines } = this.opts.code;
        this.scope = new codegen_2.ValueScope({ scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines });
        this.logger = getLogger(opts.logger);
        const formatOpt = opts.validateFormats;
        opts.validateFormats = false;
        this.RULES = (0, rules_1.getRules)();
        checkOptions.call(this, removedOptions, opts, "NOT SUPPORTED");
        checkOptions.call(this, deprecatedOptions, opts, "DEPRECATED", "warn");
        this._metaOpts = getMetaSchemaOptions.call(this);
        if (opts.formats)
          addInitialFormats.call(this);
        this._addVocabularies();
        this._addDefaultMetaSchema();
        if (opts.keywords)
          addInitialKeywords.call(this, opts.keywords);
        if (typeof opts.meta == "object")
          this.addMetaSchema(opts.meta);
        addInitialSchemas.call(this);
        opts.validateFormats = formatOpt;
      }
      _addVocabularies() {
        this.addKeyword("$async");
      }
      _addDefaultMetaSchema() {
        const { $data, meta, schemaId } = this.opts;
        let _dataRefSchema = $dataRefSchema;
        if (schemaId === "id") {
          _dataRefSchema = { ...$dataRefSchema };
          _dataRefSchema.id = _dataRefSchema.$id;
          delete _dataRefSchema.$id;
        }
        if (meta && $data)
          this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);
      }
      defaultMeta() {
        const { meta, schemaId } = this.opts;
        return this.opts.defaultMeta = typeof meta == "object" ? meta[schemaId] || meta : void 0;
      }
      validate(schemaKeyRef, data) {
        let v;
        if (typeof schemaKeyRef == "string") {
          v = this.getSchema(schemaKeyRef);
          if (!v)
            throw new Error(`no schema with key or ref "${schemaKeyRef}"`);
        } else {
          v = this.compile(schemaKeyRef);
        }
        const valid = v(data);
        if (!("$async" in v))
          this.errors = v.errors;
        return valid;
      }
      compile(schema, _meta) {
        const sch = this._addSchema(schema, _meta);
        return sch.validate || this._compileSchemaEnv(sch);
      }
      compileAsync(schema, meta) {
        if (typeof this.opts.loadSchema != "function") {
          throw new Error("options.loadSchema should be a function");
        }
        const { loadSchema } = this.opts;
        return runCompileAsync.call(this, schema, meta);
        async function runCompileAsync(_schema, _meta) {
          await loadMetaSchema.call(this, _schema.$schema);
          const sch = this._addSchema(_schema, _meta);
          return sch.validate || _compileAsync.call(this, sch);
        }
        async function loadMetaSchema($ref) {
          if ($ref && !this.getSchema($ref)) {
            await runCompileAsync.call(this, { $ref }, true);
          }
        }
        async function _compileAsync(sch) {
          try {
            return this._compileSchemaEnv(sch);
          } catch (e) {
            if (!(e instanceof ref_error_1.default))
              throw e;
            checkLoaded.call(this, e);
            await loadMissingSchema.call(this, e.missingSchema);
            return _compileAsync.call(this, sch);
          }
        }
        function checkLoaded({ missingSchema: ref, missingRef }) {
          if (this.refs[ref]) {
            throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`);
          }
        }
        async function loadMissingSchema(ref) {
          const _schema = await _loadSchema.call(this, ref);
          if (!this.refs[ref])
            await loadMetaSchema.call(this, _schema.$schema);
          if (!this.refs[ref])
            this.addSchema(_schema, ref, meta);
        }
        async function _loadSchema(ref) {
          const p = this._loading[ref];
          if (p)
            return p;
          try {
            return await (this._loading[ref] = loadSchema(ref));
          } finally {
            delete this._loading[ref];
          }
        }
      }
      // Adds schema to the instance
      addSchema(schema, key2, _meta, _validateSchema = this.opts.validateSchema) {
        if (Array.isArray(schema)) {
          for (const sch of schema)
            this.addSchema(sch, void 0, _meta, _validateSchema);
          return this;
        }
        let id;
        if (typeof schema === "object") {
          const { schemaId } = this.opts;
          id = schema[schemaId];
          if (id !== void 0 && typeof id != "string") {
            throw new Error(`schema ${schemaId} must be string`);
          }
        }
        key2 = (0, resolve_1.normalizeId)(key2 || id);
        this._checkUnique(key2);
        this.schemas[key2] = this._addSchema(schema, _meta, key2, _validateSchema, true);
        return this;
      }
      // Add schema that will be used to validate other schemas
      // options in META_IGNORE_OPTIONS are alway set to false
      addMetaSchema(schema, key2, _validateSchema = this.opts.validateSchema) {
        this.addSchema(schema, key2, true, _validateSchema);
        return this;
      }
      //  Validate schema against its meta-schema
      validateSchema(schema, throwOrLogError) {
        if (typeof schema == "boolean")
          return true;
        let $schema;
        $schema = schema.$schema;
        if ($schema !== void 0 && typeof $schema != "string") {
          throw new Error("$schema must be a string");
        }
        $schema = $schema || this.opts.defaultMeta || this.defaultMeta();
        if (!$schema) {
          this.logger.warn("meta-schema not available");
          this.errors = null;
          return true;
        }
        const valid = this.validate($schema, schema);
        if (!valid && throwOrLogError) {
          const message = "schema is invalid: " + this.errorsText();
          if (this.opts.validateSchema === "log")
            this.logger.error(message);
          else
            throw new Error(message);
        }
        return valid;
      }
      // Get compiled schema by `key` or `ref`.
      // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
      getSchema(keyRef) {
        let sch;
        while (typeof (sch = getSchEnv.call(this, keyRef)) == "string")
          keyRef = sch;
        if (sch === void 0) {
          const { schemaId } = this.opts;
          const root = new compile_1.SchemaEnv({ schema: {}, schemaId });
          sch = compile_1.resolveSchema.call(this, root, keyRef);
          if (!sch)
            return;
          this.refs[keyRef] = sch;
        }
        return sch.validate || this._compileSchemaEnv(sch);
      }
      // Remove cached schema(s).
      // If no parameter is passed all schemas but meta-schemas are removed.
      // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
      // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
      removeSchema(schemaKeyRef) {
        if (schemaKeyRef instanceof RegExp) {
          this._removeAllSchemas(this.schemas, schemaKeyRef);
          this._removeAllSchemas(this.refs, schemaKeyRef);
          return this;
        }
        switch (typeof schemaKeyRef) {
          case "undefined":
            this._removeAllSchemas(this.schemas);
            this._removeAllSchemas(this.refs);
            this._cache.clear();
            return this;
          case "string": {
            const sch = getSchEnv.call(this, schemaKeyRef);
            if (typeof sch == "object")
              this._cache.delete(sch.schema);
            delete this.schemas[schemaKeyRef];
            delete this.refs[schemaKeyRef];
            return this;
          }
          case "object": {
            const cacheKey = schemaKeyRef;
            this._cache.delete(cacheKey);
            let id = schemaKeyRef[this.opts.schemaId];
            if (id) {
              id = (0, resolve_1.normalizeId)(id);
              delete this.schemas[id];
              delete this.refs[id];
            }
            return this;
          }
          default:
            throw new Error("ajv.removeSchema: invalid parameter");
        }
      }
      // add "vocabulary" - a collection of keywords
      addVocabulary(definitions) {
        for (const def of definitions)
          this.addKeyword(def);
        return this;
      }
      addKeyword(kwdOrDef, def) {
        let keyword;
        if (typeof kwdOrDef == "string") {
          keyword = kwdOrDef;
          if (typeof def == "object") {
            this.logger.warn("these parameters are deprecated, see docs for addKeyword");
            def.keyword = keyword;
          }
        } else if (typeof kwdOrDef == "object" && def === void 0) {
          def = kwdOrDef;
          keyword = def.keyword;
          if (Array.isArray(keyword) && !keyword.length) {
            throw new Error("addKeywords: keyword must be string or non-empty array");
          }
        } else {
          throw new Error("invalid addKeywords parameters");
        }
        checkKeyword.call(this, keyword, def);
        if (!def) {
          (0, util_1.eachItem)(keyword, (kwd) => addRule.call(this, kwd));
          return this;
        }
        keywordMetaschema.call(this, def);
        const definition = {
          ...def,
          type: (0, dataType_1.getJSONTypes)(def.type),
          schemaType: (0, dataType_1.getJSONTypes)(def.schemaType)
        };
        (0, util_1.eachItem)(keyword, definition.type.length === 0 ? (k) => addRule.call(this, k, definition) : (k) => definition.type.forEach((t) => addRule.call(this, k, definition, t)));
        return this;
      }
      getKeyword(keyword) {
        const rule = this.RULES.all[keyword];
        return typeof rule == "object" ? rule.definition : !!rule;
      }
      // Remove keyword
      removeKeyword(keyword) {
        const { RULES } = this;
        delete RULES.keywords[keyword];
        delete RULES.all[keyword];
        for (const group of RULES.rules) {
          const i = group.rules.findIndex((rule) => rule.keyword === keyword);
          if (i >= 0)
            group.rules.splice(i, 1);
        }
        return this;
      }
      // Add format
      addFormat(name, format) {
        if (typeof format == "string")
          format = new RegExp(format);
        this.formats[name] = format;
        return this;
      }
      errorsText(errors = this.errors, { separator = ", ", dataVar = "data" } = {}) {
        if (!errors || errors.length === 0)
          return "No errors";
        return errors.map((e) => `${dataVar}${e.instancePath} ${e.message}`).reduce((text, msg) => text + separator + msg);
      }
      $dataMetaSchema(metaSchema, keywordsJsonPointers) {
        const rules = this.RULES.all;
        metaSchema = JSON.parse(JSON.stringify(metaSchema));
        for (const jsonPointer of keywordsJsonPointers) {
          const segments = jsonPointer.split("/").slice(1);
          let keywords = metaSchema;
          for (const seg of segments)
            keywords = keywords[seg];
          for (const key2 in rules) {
            const rule = rules[key2];
            if (typeof rule != "object")
              continue;
            const { $data } = rule.definition;
            const schema = keywords[key2];
            if ($data && schema)
              keywords[key2] = schemaOrData(schema);
          }
        }
        return metaSchema;
      }
      _removeAllSchemas(schemas, regex) {
        for (const keyRef in schemas) {
          const sch = schemas[keyRef];
          if (!regex || regex.test(keyRef)) {
            if (typeof sch == "string") {
              delete schemas[keyRef];
            } else if (sch && !sch.meta) {
              this._cache.delete(sch.schema);
              delete schemas[keyRef];
            }
          }
        }
      }
      _addSchema(schema, meta, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {
        let id;
        const { schemaId } = this.opts;
        if (typeof schema == "object") {
          id = schema[schemaId];
        } else {
          if (this.opts.jtd)
            throw new Error("schema must be object");
          else if (typeof schema != "boolean")
            throw new Error("schema must be object or boolean");
        }
        let sch = this._cache.get(schema);
        if (sch !== void 0)
          return sch;
        baseId = (0, resolve_1.normalizeId)(id || baseId);
        const localRefs = resolve_1.getSchemaRefs.call(this, schema, baseId);
        sch = new compile_1.SchemaEnv({ schema, schemaId, meta, baseId, localRefs });
        this._cache.set(sch.schema, sch);
        if (addSchema && !baseId.startsWith("#")) {
          if (baseId)
            this._checkUnique(baseId);
          this.refs[baseId] = sch;
        }
        if (validateSchema)
          this.validateSchema(schema, true);
        return sch;
      }
      _checkUnique(id) {
        if (this.schemas[id] || this.refs[id]) {
          throw new Error(`schema with key or id "${id}" already exists`);
        }
      }
      _compileSchemaEnv(sch) {
        if (sch.meta)
          this._compileMetaSchema(sch);
        else
          compile_1.compileSchema.call(this, sch);
        if (!sch.validate)
          throw new Error("ajv implementation error");
        return sch.validate;
      }
      _compileMetaSchema(sch) {
        const currentOpts = this.opts;
        this.opts = this._metaOpts;
        try {
          compile_1.compileSchema.call(this, sch);
        } finally {
          this.opts = currentOpts;
        }
      }
    };
    Ajv.ValidationError = validation_error_1.default;
    Ajv.MissingRefError = ref_error_1.default;
    exports.default = Ajv;
    function checkOptions(checkOpts, options, msg, log = "error") {
      for (const key2 in checkOpts) {
        const opt = key2;
        if (opt in options)
          this.logger[log](`${msg}: option ${key2}. ${checkOpts[opt]}`);
      }
    }
    function getSchEnv(keyRef) {
      keyRef = (0, resolve_1.normalizeId)(keyRef);
      return this.schemas[keyRef] || this.refs[keyRef];
    }
    function addInitialSchemas() {
      const optsSchemas = this.opts.schemas;
      if (!optsSchemas)
        return;
      if (Array.isArray(optsSchemas))
        this.addSchema(optsSchemas);
      else
        for (const key2 in optsSchemas)
          this.addSchema(optsSchemas[key2], key2);
    }
    function addInitialFormats() {
      for (const name in this.opts.formats) {
        const format = this.opts.formats[name];
        if (format)
          this.addFormat(name, format);
      }
    }
    function addInitialKeywords(defs) {
      if (Array.isArray(defs)) {
        this.addVocabulary(defs);
        return;
      }
      this.logger.warn("keywords option as map is deprecated, pass array");
      for (const keyword in defs) {
        const def = defs[keyword];
        if (!def.keyword)
          def.keyword = keyword;
        this.addKeyword(def);
      }
    }
    function getMetaSchemaOptions() {
      const metaOpts = { ...this.opts };
      for (const opt of META_IGNORE_OPTIONS)
        delete metaOpts[opt];
      return metaOpts;
    }
    var noLogs = { log() {
    }, warn() {
    }, error() {
    } };
    function getLogger(logger) {
      if (logger === false)
        return noLogs;
      if (logger === void 0)
        return console;
      if (logger.log && logger.warn && logger.error)
        return logger;
      throw new Error("logger must implement log, warn and error methods");
    }
    var KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;
    function checkKeyword(keyword, def) {
      const { RULES } = this;
      (0, util_1.eachItem)(keyword, (kwd) => {
        if (RULES.keywords[kwd])
          throw new Error(`Keyword ${kwd} is already defined`);
        if (!KEYWORD_NAME.test(kwd))
          throw new Error(`Keyword ${kwd} has invalid name`);
      });
      if (!def)
        return;
      if (def.$data && !("code" in def || "validate" in def)) {
        throw new Error('$data keyword must have "code" or "validate" function');
      }
    }
    function addRule(keyword, definition, dataType) {
      var _a;
      const post = definition === null || definition === void 0 ? void 0 : definition.post;
      if (dataType && post)
        throw new Error('keyword with "post" flag cannot have "type"');
      const { RULES } = this;
      let ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t }) => t === dataType);
      if (!ruleGroup) {
        ruleGroup = { type: dataType, rules: [] };
        RULES.rules.push(ruleGroup);
      }
      RULES.keywords[keyword] = true;
      if (!definition)
        return;
      const rule = {
        keyword,
        definition: {
          ...definition,
          type: (0, dataType_1.getJSONTypes)(definition.type),
          schemaType: (0, dataType_1.getJSONTypes)(definition.schemaType)
        }
      };
      if (definition.before)
        addBeforeRule.call(this, ruleGroup, rule, definition.before);
      else
        ruleGroup.rules.push(rule);
      RULES.all[keyword] = rule;
      (_a = definition.implements) === null || _a === void 0 ? void 0 : _a.forEach((kwd) => this.addKeyword(kwd));
    }
    function addBeforeRule(ruleGroup, rule, before) {
      const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before);
      if (i >= 0) {
        ruleGroup.rules.splice(i, 0, rule);
      } else {
        ruleGroup.rules.push(rule);
        this.logger.warn(`rule ${before} is not defined`);
      }
    }
    function keywordMetaschema(def) {
      let { metaSchema } = def;
      if (metaSchema === void 0)
        return;
      if (def.$data && this.opts.$data)
        metaSchema = schemaOrData(metaSchema);
      def.validateSchema = this.compile(metaSchema, true);
    }
    var $dataRef = {
      $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
    };
    function schemaOrData(schema) {
      return { anyOf: [schema, $dataRef] };
    }
  }
});

// node_modules/ajv/dist/vocabularies/core/id.js
var require_id2 = __commonJS({
  "node_modules/ajv/dist/vocabularies/core/id.js"(exports) {
    "use strict";
    var import_dist16 = __toESM(require_dist());
    var import_dist17 = __toESM(require_dist2());
    var import_dist18 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var def = {
      keyword: "id",
      code() {
        throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/core/ref.js
var require_ref = __commonJS({
  "node_modules/ajv/dist/vocabularies/core/ref.js"(exports) {
    "use strict";
    var import_dist16 = __toESM(require_dist());
    var import_dist17 = __toESM(require_dist2());
    var import_dist18 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.callRef = exports.getValidate = void 0;
    var ref_error_1 = require_ref_error();
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var compile_1 = require_compile();
    var util_1 = require_util();
    var def = {
      keyword: "$ref",
      schemaType: "string",
      code(cxt) {
        const { gen, schema: $ref, it } = cxt;
        const { baseId, schemaEnv: env, validateName, opts, self } = it;
        const { root } = env;
        if (($ref === "#" || $ref === "#/") && baseId === root.baseId)
          return callRootRef();
        const schOrEnv = compile_1.resolveRef.call(self, root, baseId, $ref);
        if (schOrEnv === void 0)
          throw new ref_error_1.default(it.opts.uriResolver, baseId, $ref);
        if (schOrEnv instanceof compile_1.SchemaEnv)
          return callValidate(schOrEnv);
        return inlineRefSchema(schOrEnv);
        function callRootRef() {
          if (env === root)
            return callRef(cxt, validateName, env, env.$async);
          const rootName = gen.scopeValue("root", { ref: root });
          return callRef(cxt, (0, codegen_1._)`${rootName}.validate`, root, root.$async);
        }
        function callValidate(sch) {
          const v = getValidate(cxt, sch);
          callRef(cxt, v, sch, sch.$async);
        }
        function inlineRefSchema(sch) {
          const schName = gen.scopeValue("schema", opts.code.source === true ? { ref: sch, code: (0, codegen_1.stringify)(sch) } : { ref: sch });
          const valid = gen.name("valid");
          const schCxt = cxt.subschema({
            schema: sch,
            dataTypes: [],
            schemaPath: codegen_1.nil,
            topSchemaRef: schName,
            errSchemaPath: $ref
          }, valid);
          cxt.mergeEvaluated(schCxt);
          cxt.ok(valid);
        }
      }
    };
    function getValidate(cxt, sch) {
      const { gen } = cxt;
      return sch.validate ? gen.scopeValue("validate", { ref: sch.validate }) : (0, codegen_1._)`${gen.scopeValue("wrapper", { ref: sch })}.validate`;
    }
    exports.getValidate = getValidate;
    function callRef(cxt, v, sch, $async) {
      const { gen, it } = cxt;
      const { allErrors, schemaEnv: env, opts } = it;
      const passCxt = opts.passContext ? names_1.default.this : codegen_1.nil;
      if ($async)
        callAsyncRef();
      else
        callSyncRef();
      function callAsyncRef() {
        if (!env.$async)
          throw new Error("async schema referenced by sync schema");
        const valid = gen.let("valid");
        gen.try(() => {
          gen.code((0, codegen_1._)`await ${(0, code_1.callValidateCode)(cxt, v, passCxt)}`);
          addEvaluatedFrom(v);
          if (!allErrors)
            gen.assign(valid, true);
        }, (e) => {
          gen.if((0, codegen_1._)`!(${e} instanceof ${it.ValidationError})`, () => gen.throw(e));
          addErrorsFrom(e);
          if (!allErrors)
            gen.assign(valid, false);
        });
        cxt.ok(valid);
      }
      function callSyncRef() {
        cxt.result((0, code_1.callValidateCode)(cxt, v, passCxt), () => addEvaluatedFrom(v), () => addErrorsFrom(v));
      }
      function addErrorsFrom(source) {
        const errs = (0, codegen_1._)`${source}.errors`;
        gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`);
        gen.assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);
      }
      function addEvaluatedFrom(source) {
        var _a;
        if (!it.opts.unevaluated)
          return;
        const schEvaluated = (_a = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a === void 0 ? void 0 : _a.evaluated;
        if (it.props !== true) {
          if (schEvaluated && !schEvaluated.dynamicProps) {
            if (schEvaluated.props !== void 0) {
              it.props = util_1.mergeEvaluated.props(gen, schEvaluated.props, it.props);
            }
          } else {
            const props = gen.var("props", (0, codegen_1._)`${source}.evaluated.props`);
            it.props = util_1.mergeEvaluated.props(gen, props, it.props, codegen_1.Name);
          }
        }
        if (it.items !== true) {
          if (schEvaluated && !schEvaluated.dynamicItems) {
            if (schEvaluated.items !== void 0) {
              it.items = util_1.mergeEvaluated.items(gen, schEvaluated.items, it.items);
            }
          } else {
            const items = gen.var("items", (0, codegen_1._)`${source}.evaluated.items`);
            it.items = util_1.mergeEvaluated.items(gen, items, it.items, codegen_1.Name);
          }
        }
      }
    }
    exports.callRef = callRef;
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/core/index.js
var require_core2 = __commonJS({
  "node_modules/ajv/dist/vocabularies/core/index.js"(exports) {
    "use strict";
    var import_dist16 = __toESM(require_dist());
    var import_dist17 = __toESM(require_dist2());
    var import_dist18 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var id_1 = require_id2();
    var ref_1 = require_ref();
    var core = [
      "$schema",
      "$id",
      "$defs",
      "$vocabulary",
      { keyword: "$comment" },
      "definitions",
      id_1.default,
      ref_1.default
    ];
    exports.default = core;
  }
});

// node_modules/ajv/dist/vocabularies/validation/limitNumber.js
var require_limitNumber = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/limitNumber.js"(exports) {
    "use strict";
    var import_dist16 = __toESM(require_dist());
    var import_dist17 = __toESM(require_dist2());
    var import_dist18 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var ops = codegen_1.operators;
    var KWDs = {
      maximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
      minimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
      exclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
      exclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE }
    };
    var error = {
      message: ({ keyword, schemaCode }) => (0, codegen_1.str)`must be ${KWDs[keyword].okStr} ${schemaCode}`,
      params: ({ keyword, schemaCode }) => (0, codegen_1._)`{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`
    };
    var def = {
      keyword: Object.keys(KWDs),
      type: "number",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword, data, schemaCode } = cxt;
        cxt.fail$data((0, codegen_1._)`${data} ${KWDs[keyword].fail} ${schemaCode} || isNaN(${data})`);
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/multipleOf.js
var require_multipleOf = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/multipleOf.js"(exports) {
    "use strict";
    var import_dist16 = __toESM(require_dist());
    var import_dist17 = __toESM(require_dist2());
    var import_dist18 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error = {
      message: ({ schemaCode }) => (0, codegen_1.str)`must be multiple of ${schemaCode}`,
      params: ({ schemaCode }) => (0, codegen_1._)`{multipleOf: ${schemaCode}}`
    };
    var def = {
      keyword: "multipleOf",
      type: "number",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, schemaCode, it } = cxt;
        const prec = it.opts.multipleOfPrecision;
        const res = gen.let("res");
        const invalid = prec ? (0, codegen_1._)`Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}` : (0, codegen_1._)`${res} !== parseInt(${res})`;
        cxt.fail$data((0, codegen_1._)`(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`);
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/runtime/ucs2length.js
var require_ucs2length = __commonJS({
  "node_modules/ajv/dist/runtime/ucs2length.js"(exports) {
    "use strict";
    var import_dist16 = __toESM(require_dist());
    var import_dist17 = __toESM(require_dist2());
    var import_dist18 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    function ucs2length(str) {
      const len = str.length;
      let length = 0;
      let pos = 0;
      let value;
      while (pos < len) {
        length++;
        value = str.charCodeAt(pos++);
        if (value >= 55296 && value <= 56319 && pos < len) {
          value = str.charCodeAt(pos);
          if ((value & 64512) === 56320)
            pos++;
        }
      }
      return length;
    }
    exports.default = ucs2length;
    ucs2length.code = 'require("ajv/dist/runtime/ucs2length").default';
  }
});

// node_modules/ajv/dist/vocabularies/validation/limitLength.js
var require_limitLength = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/limitLength.js"(exports) {
    "use strict";
    var import_dist16 = __toESM(require_dist());
    var import_dist17 = __toESM(require_dist2());
    var import_dist18 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var ucs2length_1 = require_ucs2length();
    var error = {
      message({ keyword, schemaCode }) {
        const comp = keyword === "maxLength" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} characters`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
    };
    var def = {
      keyword: ["maxLength", "minLength"],
      type: "string",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword, data, schemaCode, it } = cxt;
        const op = keyword === "maxLength" ? codegen_1.operators.GT : codegen_1.operators.LT;
        const len = it.opts.unicode === false ? (0, codegen_1._)`${data}.length` : (0, codegen_1._)`${(0, util_1.useFunc)(cxt.gen, ucs2length_1.default)}(${data})`;
        cxt.fail$data((0, codegen_1._)`${len} ${op} ${schemaCode}`);
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/pattern.js
var require_pattern = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/pattern.js"(exports) {
    "use strict";
    var import_dist16 = __toESM(require_dist());
    var import_dist17 = __toESM(require_dist2());
    var import_dist18 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var error = {
      message: ({ schemaCode }) => (0, codegen_1.str)`must match pattern "${schemaCode}"`,
      params: ({ schemaCode }) => (0, codegen_1._)`{pattern: ${schemaCode}}`
    };
    var def = {
      keyword: "pattern",
      type: "string",
      schemaType: "string",
      $data: true,
      error,
      code(cxt) {
        const { data, $data, schema, schemaCode, it } = cxt;
        const u = it.opts.unicodeRegExp ? "u" : "";
        const regExp = $data ? (0, codegen_1._)`(new RegExp(${schemaCode}, ${u}))` : (0, code_1.usePattern)(cxt, schema);
        cxt.fail$data((0, codegen_1._)`!${regExp}.test(${data})`);
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/limitProperties.js
var require_limitProperties = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/limitProperties.js"(exports) {
    "use strict";
    var import_dist16 = __toESM(require_dist());
    var import_dist17 = __toESM(require_dist2());
    var import_dist18 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error = {
      message({ keyword, schemaCode }) {
        const comp = keyword === "maxProperties" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} properties`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
    };
    var def = {
      keyword: ["maxProperties", "minProperties"],
      type: "object",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword, data, schemaCode } = cxt;
        const op = keyword === "maxProperties" ? codegen_1.operators.GT : codegen_1.operators.LT;
        cxt.fail$data((0, codegen_1._)`Object.keys(${data}).length ${op} ${schemaCode}`);
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/required.js
var require_required = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/required.js"(exports) {
    "use strict";
    var import_dist16 = __toESM(require_dist());
    var import_dist17 = __toESM(require_dist2());
    var import_dist18 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: ({ params: { missingProperty } }) => (0, codegen_1.str)`must have required property '${missingProperty}'`,
      params: ({ params: { missingProperty } }) => (0, codegen_1._)`{missingProperty: ${missingProperty}}`
    };
    var def = {
      keyword: "required",
      type: "object",
      schemaType: "array",
      $data: true,
      error,
      code(cxt) {
        const { gen, schema, schemaCode, data, $data, it } = cxt;
        const { opts } = it;
        if (!$data && schema.length === 0)
          return;
        const useLoop = schema.length >= opts.loopRequired;
        if (it.allErrors)
          allErrorsMode();
        else
          exitOnErrorMode();
        if (opts.strictRequired) {
          const props = cxt.parentSchema.properties;
          const { definedProperties } = cxt.it;
          for (const requiredKey of schema) {
            if ((props === null || props === void 0 ? void 0 : props[requiredKey]) === void 0 && !definedProperties.has(requiredKey)) {
              const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
              const msg = `required property "${requiredKey}" is not defined at "${schemaPath}" (strictRequired)`;
              (0, util_1.checkStrictMode)(it, msg, it.opts.strictRequired);
            }
          }
        }
        function allErrorsMode() {
          if (useLoop || $data) {
            cxt.block$data(codegen_1.nil, loopAllRequired);
          } else {
            for (const prop of schema) {
              (0, code_1.checkReportMissingProp)(cxt, prop);
            }
          }
        }
        function exitOnErrorMode() {
          const missing = gen.let("missing");
          if (useLoop || $data) {
            const valid = gen.let("valid", true);
            cxt.block$data(valid, () => loopUntilMissing(missing, valid));
            cxt.ok(valid);
          } else {
            gen.if((0, code_1.checkMissingProp)(cxt, schema, missing));
            (0, code_1.reportMissingProp)(cxt, missing);
            gen.else();
          }
        }
        function loopAllRequired() {
          gen.forOf("prop", schemaCode, (prop) => {
            cxt.setParams({ missingProperty: prop });
            gen.if((0, code_1.noPropertyInData)(gen, data, prop, opts.ownProperties), () => cxt.error());
          });
        }
        function loopUntilMissing(missing, valid) {
          cxt.setParams({ missingProperty: missing });
          gen.forOf(missing, schemaCode, () => {
            gen.assign(valid, (0, code_1.propertyInData)(gen, data, missing, opts.ownProperties));
            gen.if((0, codegen_1.not)(valid), () => {
              cxt.error();
              gen.break();
            });
          }, codegen_1.nil);
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/limitItems.js
var require_limitItems = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/limitItems.js"(exports) {
    "use strict";
    var import_dist16 = __toESM(require_dist());
    var import_dist17 = __toESM(require_dist2());
    var import_dist18 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error = {
      message({ keyword, schemaCode }) {
        const comp = keyword === "maxItems" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} items`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
    };
    var def = {
      keyword: ["maxItems", "minItems"],
      type: "array",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword, data, schemaCode } = cxt;
        const op = keyword === "maxItems" ? codegen_1.operators.GT : codegen_1.operators.LT;
        cxt.fail$data((0, codegen_1._)`${data}.length ${op} ${schemaCode}`);
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/runtime/equal.js
var require_equal = __commonJS({
  "node_modules/ajv/dist/runtime/equal.js"(exports) {
    "use strict";
    var import_dist16 = __toESM(require_dist());
    var import_dist17 = __toESM(require_dist2());
    var import_dist18 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var equal = require_fast_deep_equal();
    equal.code = 'require("ajv/dist/runtime/equal").default';
    exports.default = equal;
  }
});

// node_modules/ajv/dist/vocabularies/validation/uniqueItems.js
var require_uniqueItems = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/uniqueItems.js"(exports) {
    "use strict";
    var import_dist16 = __toESM(require_dist());
    var import_dist17 = __toESM(require_dist2());
    var import_dist18 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var dataType_1 = require_dataType();
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var equal_1 = require_equal();
    var error = {
      message: ({ params: { i, j } }) => (0, codegen_1.str)`must NOT have duplicate items (items ## ${j} and ${i} are identical)`,
      params: ({ params: { i, j } }) => (0, codegen_1._)`{i: ${i}, j: ${j}}`
    };
    var def = {
      keyword: "uniqueItems",
      type: "array",
      schemaType: "boolean",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, $data, schema, parentSchema, schemaCode, it } = cxt;
        if (!$data && !schema)
          return;
        const valid = gen.let("valid");
        const itemTypes = parentSchema.items ? (0, dataType_1.getSchemaTypes)(parentSchema.items) : [];
        cxt.block$data(valid, validateUniqueItems, (0, codegen_1._)`${schemaCode} === false`);
        cxt.ok(valid);
        function validateUniqueItems() {
          const i = gen.let("i", (0, codegen_1._)`${data}.length`);
          const j = gen.let("j");
          cxt.setParams({ i, j });
          gen.assign(valid, true);
          gen.if((0, codegen_1._)`${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j));
        }
        function canOptimize() {
          return itemTypes.length > 0 && !itemTypes.some((t) => t === "object" || t === "array");
        }
        function loopN(i, j) {
          const item = gen.name("item");
          const wrongType = (0, dataType_1.checkDataTypes)(itemTypes, item, it.opts.strictNumbers, dataType_1.DataType.Wrong);
          const indices = gen.const("indices", (0, codegen_1._)`{}`);
          gen.for((0, codegen_1._)`;${i}--;`, () => {
            gen.let(item, (0, codegen_1._)`${data}[${i}]`);
            gen.if(wrongType, (0, codegen_1._)`continue`);
            if (itemTypes.length > 1)
              gen.if((0, codegen_1._)`typeof ${item} == "string"`, (0, codegen_1._)`${item} += "_"`);
            gen.if((0, codegen_1._)`typeof ${indices}[${item}] == "number"`, () => {
              gen.assign(j, (0, codegen_1._)`${indices}[${item}]`);
              cxt.error();
              gen.assign(valid, false).break();
            }).code((0, codegen_1._)`${indices}[${item}] = ${i}`);
          });
        }
        function loopN2(i, j) {
          const eql = (0, util_1.useFunc)(gen, equal_1.default);
          const outer = gen.name("outer");
          gen.label(outer).for((0, codegen_1._)`;${i}--;`, () => gen.for((0, codegen_1._)`${j} = ${i}; ${j}--;`, () => gen.if((0, codegen_1._)`${eql}(${data}[${i}], ${data}[${j}])`, () => {
            cxt.error();
            gen.assign(valid, false).break(outer);
          })));
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/const.js
var require_const = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/const.js"(exports) {
    "use strict";
    var import_dist16 = __toESM(require_dist());
    var import_dist17 = __toESM(require_dist2());
    var import_dist18 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var equal_1 = require_equal();
    var error = {
      message: "must be equal to constant",
      params: ({ schemaCode }) => (0, codegen_1._)`{allowedValue: ${schemaCode}}`
    };
    var def = {
      keyword: "const",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, $data, schemaCode, schema } = cxt;
        if ($data || schema && typeof schema == "object") {
          cxt.fail$data((0, codegen_1._)`!${(0, util_1.useFunc)(gen, equal_1.default)}(${data}, ${schemaCode})`);
        } else {
          cxt.fail((0, codegen_1._)`${schema} !== ${data}`);
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/enum.js
var require_enum = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/enum.js"(exports) {
    "use strict";
    var import_dist16 = __toESM(require_dist());
    var import_dist17 = __toESM(require_dist2());
    var import_dist18 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var equal_1 = require_equal();
    var error = {
      message: "must be equal to one of the allowed values",
      params: ({ schemaCode }) => (0, codegen_1._)`{allowedValues: ${schemaCode}}`
    };
    var def = {
      keyword: "enum",
      schemaType: "array",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, $data, schema, schemaCode, it } = cxt;
        if (!$data && schema.length === 0)
          throw new Error("enum must have non-empty array");
        const useLoop = schema.length >= it.opts.loopEnum;
        let eql;
        const getEql = () => eql !== null && eql !== void 0 ? eql : eql = (0, util_1.useFunc)(gen, equal_1.default);
        let valid;
        if (useLoop || $data) {
          valid = gen.let("valid");
          cxt.block$data(valid, loopEnum);
        } else {
          if (!Array.isArray(schema))
            throw new Error("ajv implementation error");
          const vSchema = gen.const("vSchema", schemaCode);
          valid = (0, codegen_1.or)(...schema.map((_x, i) => equalCode(vSchema, i)));
        }
        cxt.pass(valid);
        function loopEnum() {
          gen.assign(valid, false);
          gen.forOf("v", schemaCode, (v) => gen.if((0, codegen_1._)`${getEql()}(${data}, ${v})`, () => gen.assign(valid, true).break()));
        }
        function equalCode(vSchema, i) {
          const sch = schema[i];
          return typeof sch === "object" && sch !== null ? (0, codegen_1._)`${getEql()}(${data}, ${vSchema}[${i}])` : (0, codegen_1._)`${data} === ${sch}`;
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/index.js
var require_validation = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/index.js"(exports) {
    "use strict";
    var import_dist16 = __toESM(require_dist());
    var import_dist17 = __toESM(require_dist2());
    var import_dist18 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var limitNumber_1 = require_limitNumber();
    var multipleOf_1 = require_multipleOf();
    var limitLength_1 = require_limitLength();
    var pattern_1 = require_pattern();
    var limitProperties_1 = require_limitProperties();
    var required_1 = require_required();
    var limitItems_1 = require_limitItems();
    var uniqueItems_1 = require_uniqueItems();
    var const_1 = require_const();
    var enum_1 = require_enum();
    var validation = [
      // number
      limitNumber_1.default,
      multipleOf_1.default,
      // string
      limitLength_1.default,
      pattern_1.default,
      // object
      limitProperties_1.default,
      required_1.default,
      // array
      limitItems_1.default,
      uniqueItems_1.default,
      // any
      { keyword: "type", schemaType: ["string", "array"] },
      { keyword: "nullable", schemaType: "boolean" },
      const_1.default,
      enum_1.default
    ];
    exports.default = validation;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/additionalItems.js
var require_additionalItems = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/additionalItems.js"(exports) {
    "use strict";
    var import_dist16 = __toESM(require_dist());
    var import_dist17 = __toESM(require_dist2());
    var import_dist18 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateAdditionalItems = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,
      params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`
    };
    var def = {
      keyword: "additionalItems",
      type: "array",
      schemaType: ["boolean", "object"],
      before: "uniqueItems",
      error,
      code(cxt) {
        const { parentSchema, it } = cxt;
        const { items } = parentSchema;
        if (!Array.isArray(items)) {
          (0, util_1.checkStrictMode)(it, '"additionalItems" is ignored when "items" is not an array of schemas');
          return;
        }
        validateAdditionalItems(cxt, items);
      }
    };
    function validateAdditionalItems(cxt, items) {
      const { gen, schema, data, keyword, it } = cxt;
      it.items = true;
      const len = gen.const("len", (0, codegen_1._)`${data}.length`);
      if (schema === false) {
        cxt.setParams({ len: items.length });
        cxt.pass((0, codegen_1._)`${len} <= ${items.length}`);
      } else if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it, schema)) {
        const valid = gen.var("valid", (0, codegen_1._)`${len} <= ${items.length}`);
        gen.if((0, codegen_1.not)(valid), () => validateItems(valid));
        cxt.ok(valid);
      }
      function validateItems(valid) {
        gen.forRange("i", items.length, len, (i) => {
          cxt.subschema({ keyword, dataProp: i, dataPropType: util_1.Type.Num }, valid);
          if (!it.allErrors)
            gen.if((0, codegen_1.not)(valid), () => gen.break());
        });
      }
    }
    exports.validateAdditionalItems = validateAdditionalItems;
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/items.js
var require_items = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/items.js"(exports) {
    "use strict";
    var import_dist16 = __toESM(require_dist());
    var import_dist17 = __toESM(require_dist2());
    var import_dist18 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateTuple = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var code_1 = require_code2();
    var def = {
      keyword: "items",
      type: "array",
      schemaType: ["object", "array", "boolean"],
      before: "uniqueItems",
      code(cxt) {
        const { schema, it } = cxt;
        if (Array.isArray(schema))
          return validateTuple(cxt, "additionalItems", schema);
        it.items = true;
        if ((0, util_1.alwaysValidSchema)(it, schema))
          return;
        cxt.ok((0, code_1.validateArray)(cxt));
      }
    };
    function validateTuple(cxt, extraItems, schArr = cxt.schema) {
      const { gen, parentSchema, data, keyword, it } = cxt;
      checkStrictTuple(parentSchema);
      if (it.opts.unevaluated && schArr.length && it.items !== true) {
        it.items = util_1.mergeEvaluated.items(gen, schArr.length, it.items);
      }
      const valid = gen.name("valid");
      const len = gen.const("len", (0, codegen_1._)`${data}.length`);
      schArr.forEach((sch, i) => {
        if ((0, util_1.alwaysValidSchema)(it, sch))
          return;
        gen.if((0, codegen_1._)`${len} > ${i}`, () => cxt.subschema({
          keyword,
          schemaProp: i,
          dataProp: i
        }, valid));
        cxt.ok(valid);
      });
      function checkStrictTuple(sch) {
        const { opts, errSchemaPath } = it;
        const l = schArr.length;
        const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false);
        if (opts.strictTuples && !fullTuple) {
          const msg = `"${keyword}" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path "${errSchemaPath}"`;
          (0, util_1.checkStrictMode)(it, msg, opts.strictTuples);
        }
      }
    }
    exports.validateTuple = validateTuple;
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/prefixItems.js
var require_prefixItems = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/prefixItems.js"(exports) {
    "use strict";
    var import_dist16 = __toESM(require_dist());
    var import_dist17 = __toESM(require_dist2());
    var import_dist18 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var items_1 = require_items();
    var def = {
      keyword: "prefixItems",
      type: "array",
      schemaType: ["array"],
      before: "uniqueItems",
      code: (cxt) => (0, items_1.validateTuple)(cxt, "items")
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/items2020.js
var require_items2020 = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/items2020.js"(exports) {
    "use strict";
    var import_dist16 = __toESM(require_dist());
    var import_dist17 = __toESM(require_dist2());
    var import_dist18 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var code_1 = require_code2();
    var additionalItems_1 = require_additionalItems();
    var error = {
      message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,
      params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`
    };
    var def = {
      keyword: "items",
      type: "array",
      schemaType: ["object", "boolean"],
      before: "uniqueItems",
      error,
      code(cxt) {
        const { schema, parentSchema, it } = cxt;
        const { prefixItems } = parentSchema;
        it.items = true;
        if ((0, util_1.alwaysValidSchema)(it, schema))
          return;
        if (prefixItems)
          (0, additionalItems_1.validateAdditionalItems)(cxt, prefixItems);
        else
          cxt.ok((0, code_1.validateArray)(cxt));
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/contains.js
var require_contains = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/contains.js"(exports) {
    "use strict";
    var import_dist16 = __toESM(require_dist());
    var import_dist17 = __toESM(require_dist2());
    var import_dist18 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1.str)`must contain at least ${min} valid item(s)` : (0, codegen_1.str)`must contain at least ${min} and no more than ${max} valid item(s)`,
      params: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1._)`{minContains: ${min}}` : (0, codegen_1._)`{minContains: ${min}, maxContains: ${max}}`
    };
    var def = {
      keyword: "contains",
      type: "array",
      schemaType: ["object", "boolean"],
      before: "uniqueItems",
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, schema, parentSchema, data, it } = cxt;
        let min;
        let max;
        const { minContains, maxContains } = parentSchema;
        if (it.opts.next) {
          min = minContains === void 0 ? 1 : minContains;
          max = maxContains;
        } else {
          min = 1;
        }
        const len = gen.const("len", (0, codegen_1._)`${data}.length`);
        cxt.setParams({ min, max });
        if (max === void 0 && min === 0) {
          (0, util_1.checkStrictMode)(it, `"minContains" == 0 without "maxContains": "contains" keyword ignored`);
          return;
        }
        if (max !== void 0 && min > max) {
          (0, util_1.checkStrictMode)(it, `"minContains" > "maxContains" is always invalid`);
          cxt.fail();
          return;
        }
        if ((0, util_1.alwaysValidSchema)(it, schema)) {
          let cond = (0, codegen_1._)`${len} >= ${min}`;
          if (max !== void 0)
            cond = (0, codegen_1._)`${cond} && ${len} <= ${max}`;
          cxt.pass(cond);
          return;
        }
        it.items = true;
        const valid = gen.name("valid");
        if (max === void 0 && min === 1) {
          validateItems(valid, () => gen.if(valid, () => gen.break()));
        } else if (min === 0) {
          gen.let(valid, true);
          if (max !== void 0)
            gen.if((0, codegen_1._)`${data}.length > 0`, validateItemsWithCount);
        } else {
          gen.let(valid, false);
          validateItemsWithCount();
        }
        cxt.result(valid, () => cxt.reset());
        function validateItemsWithCount() {
          const schValid = gen.name("_valid");
          const count = gen.let("count", 0);
          validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)));
        }
        function validateItems(_valid, block) {
          gen.forRange("i", 0, len, (i) => {
            cxt.subschema({
              keyword: "contains",
              dataProp: i,
              dataPropType: util_1.Type.Num,
              compositeRule: true
            }, _valid);
            block();
          });
        }
        function checkLimits(count) {
          gen.code((0, codegen_1._)`${count}++`);
          if (max === void 0) {
            gen.if((0, codegen_1._)`${count} >= ${min}`, () => gen.assign(valid, true).break());
          } else {
            gen.if((0, codegen_1._)`${count} > ${max}`, () => gen.assign(valid, false).break());
            if (min === 1)
              gen.assign(valid, true);
            else
              gen.if((0, codegen_1._)`${count} >= ${min}`, () => gen.assign(valid, true));
          }
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/dependencies.js
var require_dependencies = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/dependencies.js"(exports) {
    "use strict";
    var import_dist16 = __toESM(require_dist());
    var import_dist17 = __toESM(require_dist2());
    var import_dist18 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateSchemaDeps = exports.validatePropertyDeps = exports.error = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var code_1 = require_code2();
    exports.error = {
      message: ({ params: { property, depsCount, deps } }) => {
        const property_ies = depsCount === 1 ? "property" : "properties";
        return (0, codegen_1.str)`must have ${property_ies} ${deps} when property ${property} is present`;
      },
      params: ({ params: { property, depsCount, deps, missingProperty } }) => (0, codegen_1._)`{property: ${property},
    missingProperty: ${missingProperty},
    depsCount: ${depsCount},
    deps: ${deps}}`
      // TODO change to reference
    };
    var def = {
      keyword: "dependencies",
      type: "object",
      schemaType: "object",
      error: exports.error,
      code(cxt) {
        const [propDeps, schDeps] = splitDependencies(cxt);
        validatePropertyDeps(cxt, propDeps);
        validateSchemaDeps(cxt, schDeps);
      }
    };
    function splitDependencies({ schema }) {
      const propertyDeps = {};
      const schemaDeps = {};
      for (const key2 in schema) {
        if (key2 === "__proto__")
          continue;
        const deps = Array.isArray(schema[key2]) ? propertyDeps : schemaDeps;
        deps[key2] = schema[key2];
      }
      return [propertyDeps, schemaDeps];
    }
    function validatePropertyDeps(cxt, propertyDeps = cxt.schema) {
      const { gen, data, it } = cxt;
      if (Object.keys(propertyDeps).length === 0)
        return;
      const missing = gen.let("missing");
      for (const prop in propertyDeps) {
        const deps = propertyDeps[prop];
        if (deps.length === 0)
          continue;
        const hasProperty = (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties);
        cxt.setParams({
          property: prop,
          depsCount: deps.length,
          deps: deps.join(", ")
        });
        if (it.allErrors) {
          gen.if(hasProperty, () => {
            for (const depProp of deps) {
              (0, code_1.checkReportMissingProp)(cxt, depProp);
            }
          });
        } else {
          gen.if((0, codegen_1._)`${hasProperty} && (${(0, code_1.checkMissingProp)(cxt, deps, missing)})`);
          (0, code_1.reportMissingProp)(cxt, missing);
          gen.else();
        }
      }
    }
    exports.validatePropertyDeps = validatePropertyDeps;
    function validateSchemaDeps(cxt, schemaDeps = cxt.schema) {
      const { gen, data, keyword, it } = cxt;
      const valid = gen.name("valid");
      for (const prop in schemaDeps) {
        if ((0, util_1.alwaysValidSchema)(it, schemaDeps[prop]))
          continue;
        gen.if(
          (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties),
          () => {
            const schCxt = cxt.subschema({ keyword, schemaProp: prop }, valid);
            cxt.mergeValidEvaluated(schCxt, valid);
          },
          () => gen.var(valid, true)
          // TODO var
        );
        cxt.ok(valid);
      }
    }
    exports.validateSchemaDeps = validateSchemaDeps;
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/propertyNames.js
var require_propertyNames = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/propertyNames.js"(exports) {
    "use strict";
    var import_dist16 = __toESM(require_dist());
    var import_dist17 = __toESM(require_dist2());
    var import_dist18 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: "property name must be valid",
      params: ({ params }) => (0, codegen_1._)`{propertyName: ${params.propertyName}}`
    };
    var def = {
      keyword: "propertyNames",
      type: "object",
      schemaType: ["object", "boolean"],
      error,
      code(cxt) {
        const { gen, schema, data, it } = cxt;
        if ((0, util_1.alwaysValidSchema)(it, schema))
          return;
        const valid = gen.name("valid");
        gen.forIn("key", data, (key2) => {
          cxt.setParams({ propertyName: key2 });
          cxt.subschema({
            keyword: "propertyNames",
            data: key2,
            dataTypes: ["string"],
            propertyName: key2,
            compositeRule: true
          }, valid);
          gen.if((0, codegen_1.not)(valid), () => {
            cxt.error(true);
            if (!it.allErrors)
              gen.break();
          });
        });
        cxt.ok(valid);
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js
var require_additionalProperties = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js"(exports) {
    "use strict";
    var import_dist16 = __toESM(require_dist());
    var import_dist17 = __toESM(require_dist2());
    var import_dist18 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var util_1 = require_util();
    var error = {
      message: "must NOT have additional properties",
      params: ({ params }) => (0, codegen_1._)`{additionalProperty: ${params.additionalProperty}}`
    };
    var def = {
      keyword: "additionalProperties",
      type: ["object"],
      schemaType: ["boolean", "object"],
      allowUndefined: true,
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, schema, parentSchema, data, errsCount, it } = cxt;
        if (!errsCount)
          throw new Error("ajv implementation error");
        const { allErrors, opts } = it;
        it.props = true;
        if (opts.removeAdditional !== "all" && (0, util_1.alwaysValidSchema)(it, schema))
          return;
        const props = (0, code_1.allSchemaProperties)(parentSchema.properties);
        const patProps = (0, code_1.allSchemaProperties)(parentSchema.patternProperties);
        checkAdditionalProperties();
        cxt.ok((0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
        function checkAdditionalProperties() {
          gen.forIn("key", data, (key2) => {
            if (!props.length && !patProps.length)
              additionalPropertyCode(key2);
            else
              gen.if(isAdditional(key2), () => additionalPropertyCode(key2));
          });
        }
        function isAdditional(key2) {
          let definedProp;
          if (props.length > 8) {
            const propsSchema = (0, util_1.schemaRefOrVal)(it, parentSchema.properties, "properties");
            definedProp = (0, code_1.isOwnProperty)(gen, propsSchema, key2);
          } else if (props.length) {
            definedProp = (0, codegen_1.or)(...props.map((p) => (0, codegen_1._)`${key2} === ${p}`));
          } else {
            definedProp = codegen_1.nil;
          }
          if (patProps.length) {
            definedProp = (0, codegen_1.or)(definedProp, ...patProps.map((p) => (0, codegen_1._)`${(0, code_1.usePattern)(cxt, p)}.test(${key2})`));
          }
          return (0, codegen_1.not)(definedProp);
        }
        function deleteAdditional(key2) {
          gen.code((0, codegen_1._)`delete ${data}[${key2}]`);
        }
        function additionalPropertyCode(key2) {
          if (opts.removeAdditional === "all" || opts.removeAdditional && schema === false) {
            deleteAdditional(key2);
            return;
          }
          if (schema === false) {
            cxt.setParams({ additionalProperty: key2 });
            cxt.error();
            if (!allErrors)
              gen.break();
            return;
          }
          if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it, schema)) {
            const valid = gen.name("valid");
            if (opts.removeAdditional === "failing") {
              applyAdditionalSchema(key2, valid, false);
              gen.if((0, codegen_1.not)(valid), () => {
                cxt.reset();
                deleteAdditional(key2);
              });
            } else {
              applyAdditionalSchema(key2, valid);
              if (!allErrors)
                gen.if((0, codegen_1.not)(valid), () => gen.break());
            }
          }
        }
        function applyAdditionalSchema(key2, valid, errors) {
          const subschema = {
            keyword: "additionalProperties",
            dataProp: key2,
            dataPropType: util_1.Type.Str
          };
          if (errors === false) {
            Object.assign(subschema, {
              compositeRule: true,
              createErrors: false,
              allErrors: false
            });
          }
          cxt.subschema(subschema, valid);
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/properties.js
var require_properties = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/properties.js"(exports) {
    "use strict";
    var import_dist16 = __toESM(require_dist());
    var import_dist17 = __toESM(require_dist2());
    var import_dist18 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var validate_1 = require_validate();
    var code_1 = require_code2();
    var util_1 = require_util();
    var additionalProperties_1 = require_additionalProperties();
    var def = {
      keyword: "properties",
      type: "object",
      schemaType: "object",
      code(cxt) {
        const { gen, schema, parentSchema, data, it } = cxt;
        if (it.opts.removeAdditional === "all" && parentSchema.additionalProperties === void 0) {
          additionalProperties_1.default.code(new validate_1.KeywordCxt(it, additionalProperties_1.default, "additionalProperties"));
        }
        const allProps = (0, code_1.allSchemaProperties)(schema);
        for (const prop of allProps) {
          it.definedProperties.add(prop);
        }
        if (it.opts.unevaluated && allProps.length && it.props !== true) {
          it.props = util_1.mergeEvaluated.props(gen, (0, util_1.toHash)(allProps), it.props);
        }
        const properties = allProps.filter((p) => !(0, util_1.alwaysValidSchema)(it, schema[p]));
        if (properties.length === 0)
          return;
        const valid = gen.name("valid");
        for (const prop of properties) {
          if (hasDefault(prop)) {
            applyPropertySchema(prop);
          } else {
            gen.if((0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties));
            applyPropertySchema(prop);
            if (!it.allErrors)
              gen.else().var(valid, true);
            gen.endIf();
          }
          cxt.it.definedProperties.add(prop);
          cxt.ok(valid);
        }
        function hasDefault(prop) {
          return it.opts.useDefaults && !it.compositeRule && schema[prop].default !== void 0;
        }
        function applyPropertySchema(prop) {
          cxt.subschema({
            keyword: "properties",
            schemaProp: prop,
            dataProp: prop
          }, valid);
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/patternProperties.js
var require_patternProperties = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/patternProperties.js"(exports) {
    "use strict";
    var import_dist16 = __toESM(require_dist());
    var import_dist17 = __toESM(require_dist2());
    var import_dist18 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var util_2 = require_util();
    var def = {
      keyword: "patternProperties",
      type: "object",
      schemaType: "object",
      code(cxt) {
        const { gen, schema, data, parentSchema, it } = cxt;
        const { opts } = it;
        const patterns = (0, code_1.allSchemaProperties)(schema);
        const alwaysValidPatterns = patterns.filter((p) => (0, util_1.alwaysValidSchema)(it, schema[p]));
        if (patterns.length === 0 || alwaysValidPatterns.length === patterns.length && (!it.opts.unevaluated || it.props === true)) {
          return;
        }
        const checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;
        const valid = gen.name("valid");
        if (it.props !== true && !(it.props instanceof codegen_1.Name)) {
          it.props = (0, util_2.evaluatedPropsToName)(gen, it.props);
        }
        const { props } = it;
        validatePatternProperties();
        function validatePatternProperties() {
          for (const pat of patterns) {
            if (checkProperties)
              checkMatchingProperties(pat);
            if (it.allErrors) {
              validateProperties(pat);
            } else {
              gen.var(valid, true);
              validateProperties(pat);
              gen.if(valid);
            }
          }
        }
        function checkMatchingProperties(pat) {
          for (const prop in checkProperties) {
            if (new RegExp(pat).test(prop)) {
              (0, util_1.checkStrictMode)(it, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);
            }
          }
        }
        function validateProperties(pat) {
          gen.forIn("key", data, (key2) => {
            gen.if((0, codegen_1._)`${(0, code_1.usePattern)(cxt, pat)}.test(${key2})`, () => {
              const alwaysValid = alwaysValidPatterns.includes(pat);
              if (!alwaysValid) {
                cxt.subschema({
                  keyword: "patternProperties",
                  schemaProp: pat,
                  dataProp: key2,
                  dataPropType: util_2.Type.Str
                }, valid);
              }
              if (it.opts.unevaluated && props !== true) {
                gen.assign((0, codegen_1._)`${props}[${key2}]`, true);
              } else if (!alwaysValid && !it.allErrors) {
                gen.if((0, codegen_1.not)(valid), () => gen.break());
              }
            });
          });
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/not.js
var require_not = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/not.js"(exports) {
    "use strict";
    var import_dist16 = __toESM(require_dist());
    var import_dist17 = __toESM(require_dist2());
    var import_dist18 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var util_1 = require_util();
    var def = {
      keyword: "not",
      schemaType: ["object", "boolean"],
      trackErrors: true,
      code(cxt) {
        const { gen, schema, it } = cxt;
        if ((0, util_1.alwaysValidSchema)(it, schema)) {
          cxt.fail();
          return;
        }
        const valid = gen.name("valid");
        cxt.subschema({
          keyword: "not",
          compositeRule: true,
          createErrors: false,
          allErrors: false
        }, valid);
        cxt.failResult(valid, () => cxt.reset(), () => cxt.error());
      },
      error: { message: "must NOT be valid" }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/anyOf.js
var require_anyOf = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/anyOf.js"(exports) {
    "use strict";
    var import_dist16 = __toESM(require_dist());
    var import_dist17 = __toESM(require_dist2());
    var import_dist18 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var code_1 = require_code2();
    var def = {
      keyword: "anyOf",
      schemaType: "array",
      trackErrors: true,
      code: code_1.validateUnion,
      error: { message: "must match a schema in anyOf" }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/oneOf.js
var require_oneOf = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/oneOf.js"(exports) {
    "use strict";
    var import_dist16 = __toESM(require_dist());
    var import_dist17 = __toESM(require_dist2());
    var import_dist18 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: "must match exactly one schema in oneOf",
      params: ({ params }) => (0, codegen_1._)`{passingSchemas: ${params.passing}}`
    };
    var def = {
      keyword: "oneOf",
      schemaType: "array",
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, schema, parentSchema, it } = cxt;
        if (!Array.isArray(schema))
          throw new Error("ajv implementation error");
        if (it.opts.discriminator && parentSchema.discriminator)
          return;
        const schArr = schema;
        const valid = gen.let("valid", false);
        const passing = gen.let("passing", null);
        const schValid = gen.name("_valid");
        cxt.setParams({ passing });
        gen.block(validateOneOf);
        cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
        function validateOneOf() {
          schArr.forEach((sch, i) => {
            let schCxt;
            if ((0, util_1.alwaysValidSchema)(it, sch)) {
              gen.var(schValid, true);
            } else {
              schCxt = cxt.subschema({
                keyword: "oneOf",
                schemaProp: i,
                compositeRule: true
              }, schValid);
            }
            if (i > 0) {
              gen.if((0, codegen_1._)`${schValid} && ${valid}`).assign(valid, false).assign(passing, (0, codegen_1._)`[${passing}, ${i}]`).else();
            }
            gen.if(schValid, () => {
              gen.assign(valid, true);
              gen.assign(passing, i);
              if (schCxt)
                cxt.mergeEvaluated(schCxt, codegen_1.Name);
            });
          });
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/allOf.js
var require_allOf = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/allOf.js"(exports) {
    "use strict";
    var import_dist16 = __toESM(require_dist());
    var import_dist17 = __toESM(require_dist2());
    var import_dist18 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var util_1 = require_util();
    var def = {
      keyword: "allOf",
      schemaType: "array",
      code(cxt) {
        const { gen, schema, it } = cxt;
        if (!Array.isArray(schema))
          throw new Error("ajv implementation error");
        const valid = gen.name("valid");
        schema.forEach((sch, i) => {
          if ((0, util_1.alwaysValidSchema)(it, sch))
            return;
          const schCxt = cxt.subschema({ keyword: "allOf", schemaProp: i }, valid);
          cxt.ok(valid);
          cxt.mergeEvaluated(schCxt);
        });
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/if.js
var require_if = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/if.js"(exports) {
    "use strict";
    var import_dist16 = __toESM(require_dist());
    var import_dist17 = __toESM(require_dist2());
    var import_dist18 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: ({ params }) => (0, codegen_1.str)`must match "${params.ifClause}" schema`,
      params: ({ params }) => (0, codegen_1._)`{failingKeyword: ${params.ifClause}}`
    };
    var def = {
      keyword: "if",
      schemaType: ["object", "boolean"],
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, parentSchema, it } = cxt;
        if (parentSchema.then === void 0 && parentSchema.else === void 0) {
          (0, util_1.checkStrictMode)(it, '"if" without "then" and "else" is ignored');
        }
        const hasThen = hasSchema(it, "then");
        const hasElse = hasSchema(it, "else");
        if (!hasThen && !hasElse)
          return;
        const valid = gen.let("valid", true);
        const schValid = gen.name("_valid");
        validateIf();
        cxt.reset();
        if (hasThen && hasElse) {
          const ifClause = gen.let("ifClause");
          cxt.setParams({ ifClause });
          gen.if(schValid, validateClause("then", ifClause), validateClause("else", ifClause));
        } else if (hasThen) {
          gen.if(schValid, validateClause("then"));
        } else {
          gen.if((0, codegen_1.not)(schValid), validateClause("else"));
        }
        cxt.pass(valid, () => cxt.error(true));
        function validateIf() {
          const schCxt = cxt.subschema({
            keyword: "if",
            compositeRule: true,
            createErrors: false,
            allErrors: false
          }, schValid);
          cxt.mergeEvaluated(schCxt);
        }
        function validateClause(keyword, ifClause) {
          return () => {
            const schCxt = cxt.subschema({ keyword }, schValid);
            gen.assign(valid, schValid);
            cxt.mergeValidEvaluated(schCxt, valid);
            if (ifClause)
              gen.assign(ifClause, (0, codegen_1._)`${keyword}`);
            else
              cxt.setParams({ ifClause: keyword });
          };
        }
      }
    };
    function hasSchema(it, keyword) {
      const schema = it.schema[keyword];
      return schema !== void 0 && !(0, util_1.alwaysValidSchema)(it, schema);
    }
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/thenElse.js
var require_thenElse = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/thenElse.js"(exports) {
    "use strict";
    var import_dist16 = __toESM(require_dist());
    var import_dist17 = __toESM(require_dist2());
    var import_dist18 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var util_1 = require_util();
    var def = {
      keyword: ["then", "else"],
      schemaType: ["object", "boolean"],
      code({ keyword, parentSchema, it }) {
        if (parentSchema.if === void 0)
          (0, util_1.checkStrictMode)(it, `"${keyword}" without "if" is ignored`);
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/index.js
var require_applicator = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/index.js"(exports) {
    "use strict";
    var import_dist16 = __toESM(require_dist());
    var import_dist17 = __toESM(require_dist2());
    var import_dist18 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var additionalItems_1 = require_additionalItems();
    var prefixItems_1 = require_prefixItems();
    var items_1 = require_items();
    var items2020_1 = require_items2020();
    var contains_1 = require_contains();
    var dependencies_1 = require_dependencies();
    var propertyNames_1 = require_propertyNames();
    var additionalProperties_1 = require_additionalProperties();
    var properties_1 = require_properties();
    var patternProperties_1 = require_patternProperties();
    var not_1 = require_not();
    var anyOf_1 = require_anyOf();
    var oneOf_1 = require_oneOf();
    var allOf_1 = require_allOf();
    var if_1 = require_if();
    var thenElse_1 = require_thenElse();
    function getApplicator(draft2020 = false) {
      const applicator = [
        // any
        not_1.default,
        anyOf_1.default,
        oneOf_1.default,
        allOf_1.default,
        if_1.default,
        thenElse_1.default,
        // object
        propertyNames_1.default,
        additionalProperties_1.default,
        dependencies_1.default,
        properties_1.default,
        patternProperties_1.default
      ];
      if (draft2020)
        applicator.push(prefixItems_1.default, items2020_1.default);
      else
        applicator.push(additionalItems_1.default, items_1.default);
      applicator.push(contains_1.default);
      return applicator;
    }
    exports.default = getApplicator;
  }
});

// node_modules/ajv/dist/vocabularies/format/format.js
var require_format2 = __commonJS({
  "node_modules/ajv/dist/vocabularies/format/format.js"(exports) {
    "use strict";
    var import_dist16 = __toESM(require_dist());
    var import_dist17 = __toESM(require_dist2());
    var import_dist18 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error = {
      message: ({ schemaCode }) => (0, codegen_1.str)`must match format "${schemaCode}"`,
      params: ({ schemaCode }) => (0, codegen_1._)`{format: ${schemaCode}}`
    };
    var def = {
      keyword: "format",
      type: ["number", "string"],
      schemaType: "string",
      $data: true,
      error,
      code(cxt, ruleType) {
        const { gen, data, $data, schema, schemaCode, it } = cxt;
        const { opts, errSchemaPath, schemaEnv, self } = it;
        if (!opts.validateFormats)
          return;
        if ($data)
          validate$DataFormat();
        else
          validateFormat();
        function validate$DataFormat() {
          const fmts = gen.scopeValue("formats", {
            ref: self.formats,
            code: opts.code.formats
          });
          const fDef = gen.const("fDef", (0, codegen_1._)`${fmts}[${schemaCode}]`);
          const fType = gen.let("fType");
          const format = gen.let("format");
          gen.if((0, codegen_1._)`typeof ${fDef} == "object" && !(${fDef} instanceof RegExp)`, () => gen.assign(fType, (0, codegen_1._)`${fDef}.type || "string"`).assign(format, (0, codegen_1._)`${fDef}.validate`), () => gen.assign(fType, (0, codegen_1._)`"string"`).assign(format, fDef));
          cxt.fail$data((0, codegen_1.or)(unknownFmt(), invalidFmt()));
          function unknownFmt() {
            if (opts.strictSchema === false)
              return codegen_1.nil;
            return (0, codegen_1._)`${schemaCode} && !${format}`;
          }
          function invalidFmt() {
            const callFormat = schemaEnv.$async ? (0, codegen_1._)`(${fDef}.async ? await ${format}(${data}) : ${format}(${data}))` : (0, codegen_1._)`${format}(${data})`;
            const validData = (0, codegen_1._)`(typeof ${format} == "function" ? ${callFormat} : ${format}.test(${data}))`;
            return (0, codegen_1._)`${format} && ${format} !== true && ${fType} === ${ruleType} && !${validData}`;
          }
        }
        function validateFormat() {
          const formatDef = self.formats[schema];
          if (!formatDef) {
            unknownFormat();
            return;
          }
          if (formatDef === true)
            return;
          const [fmtType, format, fmtRef] = getFormat(formatDef);
          if (fmtType === ruleType)
            cxt.pass(validCondition());
          function unknownFormat() {
            if (opts.strictSchema === false) {
              self.logger.warn(unknownMsg());
              return;
            }
            throw new Error(unknownMsg());
            function unknownMsg() {
              return `unknown format "${schema}" ignored in schema at path "${errSchemaPath}"`;
            }
          }
          function getFormat(fmtDef) {
            const code = fmtDef instanceof RegExp ? (0, codegen_1.regexpCode)(fmtDef) : opts.code.formats ? (0, codegen_1._)`${opts.code.formats}${(0, codegen_1.getProperty)(schema)}` : void 0;
            const fmt = gen.scopeValue("formats", { key: schema, ref: fmtDef, code });
            if (typeof fmtDef == "object" && !(fmtDef instanceof RegExp)) {
              return [fmtDef.type || "string", fmtDef.validate, (0, codegen_1._)`${fmt}.validate`];
            }
            return ["string", fmtDef, fmt];
          }
          function validCondition() {
            if (typeof formatDef == "object" && !(formatDef instanceof RegExp) && formatDef.async) {
              if (!schemaEnv.$async)
                throw new Error("async format in sync schema");
              return (0, codegen_1._)`await ${fmtRef}(${data})`;
            }
            return typeof format == "function" ? (0, codegen_1._)`${fmtRef}(${data})` : (0, codegen_1._)`${fmtRef}.test(${data})`;
          }
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/format/index.js
var require_format3 = __commonJS({
  "node_modules/ajv/dist/vocabularies/format/index.js"(exports) {
    "use strict";
    var import_dist16 = __toESM(require_dist());
    var import_dist17 = __toESM(require_dist2());
    var import_dist18 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var format_1 = require_format2();
    var format = [format_1.default];
    exports.default = format;
  }
});

// node_modules/ajv/dist/vocabularies/metadata.js
var require_metadata = __commonJS({
  "node_modules/ajv/dist/vocabularies/metadata.js"(exports) {
    "use strict";
    var import_dist16 = __toESM(require_dist());
    var import_dist17 = __toESM(require_dist2());
    var import_dist18 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.contentVocabulary = exports.metadataVocabulary = void 0;
    exports.metadataVocabulary = [
      "title",
      "description",
      "default",
      "deprecated",
      "readOnly",
      "writeOnly",
      "examples"
    ];
    exports.contentVocabulary = [
      "contentMediaType",
      "contentEncoding",
      "contentSchema"
    ];
  }
});

// node_modules/ajv/dist/vocabularies/draft7.js
var require_draft7 = __commonJS({
  "node_modules/ajv/dist/vocabularies/draft7.js"(exports) {
    "use strict";
    var import_dist16 = __toESM(require_dist());
    var import_dist17 = __toESM(require_dist2());
    var import_dist18 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var core_1 = require_core2();
    var validation_1 = require_validation();
    var applicator_1 = require_applicator();
    var format_1 = require_format3();
    var metadata_1 = require_metadata();
    var draft7Vocabularies = [
      core_1.default,
      validation_1.default,
      (0, applicator_1.default)(),
      format_1.default,
      metadata_1.metadataVocabulary,
      metadata_1.contentVocabulary
    ];
    exports.default = draft7Vocabularies;
  }
});

// node_modules/ajv/dist/vocabularies/discriminator/types.js
var require_types = __commonJS({
  "node_modules/ajv/dist/vocabularies/discriminator/types.js"(exports) {
    "use strict";
    var import_dist16 = __toESM(require_dist());
    var import_dist17 = __toESM(require_dist2());
    var import_dist18 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DiscrError = void 0;
    var DiscrError;
    (function(DiscrError2) {
      DiscrError2["Tag"] = "tag";
      DiscrError2["Mapping"] = "mapping";
    })(DiscrError || (exports.DiscrError = DiscrError = {}));
  }
});

// node_modules/ajv/dist/vocabularies/discriminator/index.js
var require_discriminator = __commonJS({
  "node_modules/ajv/dist/vocabularies/discriminator/index.js"(exports) {
    "use strict";
    var import_dist16 = __toESM(require_dist());
    var import_dist17 = __toESM(require_dist2());
    var import_dist18 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var types_1 = require_types();
    var compile_1 = require_compile();
    var ref_error_1 = require_ref_error();
    var util_1 = require_util();
    var error = {
      message: ({ params: { discrError, tagName } }) => discrError === types_1.DiscrError.Tag ? `tag "${tagName}" must be string` : `value of tag "${tagName}" must be in oneOf`,
      params: ({ params: { discrError, tag, tagName } }) => (0, codegen_1._)`{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`
    };
    var def = {
      keyword: "discriminator",
      type: "object",
      schemaType: "object",
      error,
      code(cxt) {
        const { gen, data, schema, parentSchema, it } = cxt;
        const { oneOf } = parentSchema;
        if (!it.opts.discriminator) {
          throw new Error("discriminator: requires discriminator option");
        }
        const tagName = schema.propertyName;
        if (typeof tagName != "string")
          throw new Error("discriminator: requires propertyName");
        if (schema.mapping)
          throw new Error("discriminator: mapping is not supported");
        if (!oneOf)
          throw new Error("discriminator: requires oneOf keyword");
        const valid = gen.let("valid", false);
        const tag = gen.const("tag", (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(tagName)}`);
        gen.if((0, codegen_1._)`typeof ${tag} == "string"`, () => validateMapping(), () => cxt.error(false, { discrError: types_1.DiscrError.Tag, tag, tagName }));
        cxt.ok(valid);
        function validateMapping() {
          const mapping = getMapping();
          gen.if(false);
          for (const tagValue in mapping) {
            gen.elseIf((0, codegen_1._)`${tag} === ${tagValue}`);
            gen.assign(valid, applyTagSchema(mapping[tagValue]));
          }
          gen.else();
          cxt.error(false, { discrError: types_1.DiscrError.Mapping, tag, tagName });
          gen.endIf();
        }
        function applyTagSchema(schemaProp) {
          const _valid = gen.name("valid");
          const schCxt = cxt.subschema({ keyword: "oneOf", schemaProp }, _valid);
          cxt.mergeEvaluated(schCxt, codegen_1.Name);
          return _valid;
        }
        function getMapping() {
          var _a;
          const oneOfMapping = {};
          const topRequired = hasRequired(parentSchema);
          let tagRequired = true;
          for (let i = 0; i < oneOf.length; i++) {
            let sch = oneOf[i];
            if ((sch === null || sch === void 0 ? void 0 : sch.$ref) && !(0, util_1.schemaHasRulesButRef)(sch, it.self.RULES)) {
              const ref = sch.$ref;
              sch = compile_1.resolveRef.call(it.self, it.schemaEnv.root, it.baseId, ref);
              if (sch instanceof compile_1.SchemaEnv)
                sch = sch.schema;
              if (sch === void 0)
                throw new ref_error_1.default(it.opts.uriResolver, it.baseId, ref);
            }
            const propSch = (_a = sch === null || sch === void 0 ? void 0 : sch.properties) === null || _a === void 0 ? void 0 : _a[tagName];
            if (typeof propSch != "object") {
              throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${tagName}"`);
            }
            tagRequired = tagRequired && (topRequired || hasRequired(sch));
            addMappings(propSch, i);
          }
          if (!tagRequired)
            throw new Error(`discriminator: "${tagName}" must be required`);
          return oneOfMapping;
          function hasRequired({ required }) {
            return Array.isArray(required) && required.includes(tagName);
          }
          function addMappings(sch, i) {
            if (sch.const) {
              addMapping(sch.const, i);
            } else if (sch.enum) {
              for (const tagValue of sch.enum) {
                addMapping(tagValue, i);
              }
            } else {
              throw new Error(`discriminator: "properties/${tagName}" must have "const" or "enum"`);
            }
          }
          function addMapping(tagValue, i) {
            if (typeof tagValue != "string" || tagValue in oneOfMapping) {
              throw new Error(`discriminator: "${tagName}" values must be unique strings`);
            }
            oneOfMapping[tagValue] = i;
          }
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/refs/json-schema-draft-07.json
var require_json_schema_draft_07 = __commonJS({
  "node_modules/ajv/dist/refs/json-schema-draft-07.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-07/schema#",
      $id: "http://json-schema.org/draft-07/schema#",
      title: "Core schema meta-schema",
      definitions: {
        schemaArray: {
          type: "array",
          minItems: 1,
          items: { $ref: "#" }
        },
        nonNegativeInteger: {
          type: "integer",
          minimum: 0
        },
        nonNegativeIntegerDefault0: {
          allOf: [{ $ref: "#/definitions/nonNegativeInteger" }, { default: 0 }]
        },
        simpleTypes: {
          enum: ["array", "boolean", "integer", "null", "number", "object", "string"]
        },
        stringArray: {
          type: "array",
          items: { type: "string" },
          uniqueItems: true,
          default: []
        }
      },
      type: ["object", "boolean"],
      properties: {
        $id: {
          type: "string",
          format: "uri-reference"
        },
        $schema: {
          type: "string",
          format: "uri"
        },
        $ref: {
          type: "string",
          format: "uri-reference"
        },
        $comment: {
          type: "string"
        },
        title: {
          type: "string"
        },
        description: {
          type: "string"
        },
        default: true,
        readOnly: {
          type: "boolean",
          default: false
        },
        examples: {
          type: "array",
          items: true
        },
        multipleOf: {
          type: "number",
          exclusiveMinimum: 0
        },
        maximum: {
          type: "number"
        },
        exclusiveMaximum: {
          type: "number"
        },
        minimum: {
          type: "number"
        },
        exclusiveMinimum: {
          type: "number"
        },
        maxLength: { $ref: "#/definitions/nonNegativeInteger" },
        minLength: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        pattern: {
          type: "string",
          format: "regex"
        },
        additionalItems: { $ref: "#" },
        items: {
          anyOf: [{ $ref: "#" }, { $ref: "#/definitions/schemaArray" }],
          default: true
        },
        maxItems: { $ref: "#/definitions/nonNegativeInteger" },
        minItems: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        uniqueItems: {
          type: "boolean",
          default: false
        },
        contains: { $ref: "#" },
        maxProperties: { $ref: "#/definitions/nonNegativeInteger" },
        minProperties: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        required: { $ref: "#/definitions/stringArray" },
        additionalProperties: { $ref: "#" },
        definitions: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {}
        },
        properties: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {}
        },
        patternProperties: {
          type: "object",
          additionalProperties: { $ref: "#" },
          propertyNames: { format: "regex" },
          default: {}
        },
        dependencies: {
          type: "object",
          additionalProperties: {
            anyOf: [{ $ref: "#" }, { $ref: "#/definitions/stringArray" }]
          }
        },
        propertyNames: { $ref: "#" },
        const: true,
        enum: {
          type: "array",
          items: true,
          minItems: 1,
          uniqueItems: true
        },
        type: {
          anyOf: [
            { $ref: "#/definitions/simpleTypes" },
            {
              type: "array",
              items: { $ref: "#/definitions/simpleTypes" },
              minItems: 1,
              uniqueItems: true
            }
          ]
        },
        format: { type: "string" },
        contentMediaType: { type: "string" },
        contentEncoding: { type: "string" },
        if: { $ref: "#" },
        then: { $ref: "#" },
        else: { $ref: "#" },
        allOf: { $ref: "#/definitions/schemaArray" },
        anyOf: { $ref: "#/definitions/schemaArray" },
        oneOf: { $ref: "#/definitions/schemaArray" },
        not: { $ref: "#" }
      },
      default: true
    };
  }
});

// node_modules/ajv/dist/ajv.js
var require_ajv = __commonJS({
  "node_modules/ajv/dist/ajv.js"(exports, module) {
    "use strict";
    var import_dist16 = __toESM(require_dist());
    var import_dist17 = __toESM(require_dist2());
    var import_dist18 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MissingRefError = exports.ValidationError = exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = exports.Ajv = void 0;
    var core_1 = require_core();
    var draft7_1 = require_draft7();
    var discriminator_1 = require_discriminator();
    var draft7MetaSchema = require_json_schema_draft_07();
    var META_SUPPORT_DATA = ["/properties"];
    var META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";
    var Ajv = class extends core_1.default {
      _addVocabularies() {
        super._addVocabularies();
        draft7_1.default.forEach((v) => this.addVocabulary(v));
        if (this.opts.discriminator)
          this.addKeyword(discriminator_1.default);
      }
      _addDefaultMetaSchema() {
        super._addDefaultMetaSchema();
        if (!this.opts.meta)
          return;
        const metaSchema = this.opts.$data ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA) : draft7MetaSchema;
        this.addMetaSchema(metaSchema, META_SCHEMA_ID, false);
        this.refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
      }
      defaultMeta() {
        return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0);
      }
    };
    exports.Ajv = Ajv;
    module.exports = exports = Ajv;
    module.exports.Ajv = Ajv;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = Ajv;
    var validate_1 = require_validate();
    Object.defineProperty(exports, "KeywordCxt", { enumerable: true, get: function() {
      return validate_1.KeywordCxt;
    } });
    var codegen_1 = require_codegen();
    Object.defineProperty(exports, "_", { enumerable: true, get: function() {
      return codegen_1._;
    } });
    Object.defineProperty(exports, "str", { enumerable: true, get: function() {
      return codegen_1.str;
    } });
    Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
      return codegen_1.stringify;
    } });
    Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
      return codegen_1.nil;
    } });
    Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
      return codegen_1.Name;
    } });
    Object.defineProperty(exports, "CodeGen", { enumerable: true, get: function() {
      return codegen_1.CodeGen;
    } });
    var validation_error_1 = require_validation_error();
    Object.defineProperty(exports, "ValidationError", { enumerable: true, get: function() {
      return validation_error_1.default;
    } });
    var ref_error_1 = require_ref_error();
    Object.defineProperty(exports, "MissingRefError", { enumerable: true, get: function() {
      return ref_error_1.default;
    } });
  }
});

// node_modules/ajv-errors/dist/index.js
var require_dist6 = __commonJS({
  "node_modules/ajv-errors/dist/index.js"(exports, module) {
    "use strict";
    var import_dist16 = __toESM(require_dist());
    var import_dist17 = __toESM(require_dist2());
    var import_dist18 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var ajv_1 = require_ajv();
    var codegen_1 = require_codegen();
    var code_1 = require_code();
    var validate_1 = require_validate();
    var errors_1 = require_errors();
    var names_1 = require_names();
    var keyword = "errorMessage";
    var used = new ajv_1.Name("emUsed");
    var KEYWORD_PROPERTY_PARAMS = {
      required: "missingProperty",
      dependencies: "property",
      dependentRequired: "property"
    };
    var INTERPOLATION = /\$\{[^}]+\}/;
    var INTERPOLATION_REPLACE = /\$\{([^}]+)\}/g;
    var EMPTY_STR = /^""\s*\+\s*|\s*\+\s*""$/g;
    function errorMessage(options) {
      return {
        keyword,
        schemaType: ["string", "object"],
        post: true,
        code(cxt) {
          const { gen, data, schema, schemaValue, it } = cxt;
          if (it.createErrors === false)
            return;
          const sch = schema;
          const instancePath = codegen_1.strConcat(names_1.default.instancePath, it.errorPath);
          gen.if(ajv_1._`${names_1.default.errors} > 0`, () => {
            if (typeof sch == "object") {
              const [kwdPropErrors, kwdErrors] = keywordErrorsConfig(sch);
              if (kwdErrors)
                processKeywordErrors(kwdErrors);
              if (kwdPropErrors)
                processKeywordPropErrors(kwdPropErrors);
              processChildErrors(childErrorsConfig(sch));
            }
            const schMessage = typeof sch == "string" ? sch : sch._;
            if (schMessage)
              processAllErrors(schMessage);
            if (!options.keepErrors)
              removeUsedErrors();
          });
          function childErrorsConfig({ properties, items }) {
            const errors = {};
            if (properties) {
              errors.props = {};
              for (const p in properties)
                errors.props[p] = [];
            }
            if (items) {
              errors.items = {};
              for (let i = 0; i < items.length; i++)
                errors.items[i] = [];
            }
            return errors;
          }
          function keywordErrorsConfig(emSchema) {
            let propErrors;
            let errors;
            for (const k in emSchema) {
              if (k === "properties" || k === "items")
                continue;
              const kwdSch = emSchema[k];
              if (typeof kwdSch == "object") {
                propErrors || (propErrors = {});
                const errMap = propErrors[k] = {};
                for (const p in kwdSch)
                  errMap[p] = [];
              } else {
                errors || (errors = {});
                errors[k] = [];
              }
            }
            return [propErrors, errors];
          }
          function processKeywordErrors(kwdErrors) {
            const kwdErrs = gen.const("emErrors", ajv_1.stringify(kwdErrors));
            const templates = gen.const("templates", getTemplatesCode(kwdErrors, schema));
            gen.forOf("err", names_1.default.vErrors, (err) => gen.if(matchKeywordError(err, kwdErrs), () => gen.code(ajv_1._`${kwdErrs}[${err}.keyword].push(${err})`).assign(ajv_1._`${err}.${used}`, true)));
            const { singleError } = options;
            if (singleError) {
              const message = gen.let("message", ajv_1._`""`);
              const paramsErrors = gen.let("paramsErrors", ajv_1._`[]`);
              loopErrors((key2) => {
                gen.if(message, () => gen.code(ajv_1._`${message} += ${typeof singleError == "string" ? singleError : ";"}`));
                gen.code(ajv_1._`${message} += ${errMessage(key2)}`);
                gen.assign(paramsErrors, ajv_1._`${paramsErrors}.concat(${kwdErrs}[${key2}])`);
              });
              errors_1.reportError(cxt, { message, params: ajv_1._`{errors: ${paramsErrors}}` });
            } else {
              loopErrors((key2) => errors_1.reportError(cxt, {
                message: errMessage(key2),
                params: ajv_1._`{errors: ${kwdErrs}[${key2}]}`
              }));
            }
            function loopErrors(body) {
              gen.forIn("key", kwdErrs, (key2) => gen.if(ajv_1._`${kwdErrs}[${key2}].length`, () => body(key2)));
            }
            function errMessage(key2) {
              return ajv_1._`${key2} in ${templates} ? ${templates}[${key2}]() : ${schemaValue}[${key2}]`;
            }
          }
          function processKeywordPropErrors(kwdPropErrors) {
            const kwdErrs = gen.const("emErrors", ajv_1.stringify(kwdPropErrors));
            const templatesCode = [];
            for (const k in kwdPropErrors) {
              templatesCode.push([
                k,
                getTemplatesCode(kwdPropErrors[k], schema[k])
              ]);
            }
            const templates = gen.const("templates", gen.object(...templatesCode));
            const kwdPropParams = gen.scopeValue("obj", {
              ref: KEYWORD_PROPERTY_PARAMS,
              code: ajv_1.stringify(KEYWORD_PROPERTY_PARAMS)
            });
            const propParam = gen.let("emPropParams");
            const paramsErrors = gen.let("emParamsErrors");
            gen.forOf("err", names_1.default.vErrors, (err) => gen.if(matchKeywordError(err, kwdErrs), () => {
              gen.assign(propParam, ajv_1._`${kwdPropParams}[${err}.keyword]`);
              gen.assign(paramsErrors, ajv_1._`${kwdErrs}[${err}.keyword][${err}.params[${propParam}]]`);
              gen.if(paramsErrors, () => gen.code(ajv_1._`${paramsErrors}.push(${err})`).assign(ajv_1._`${err}.${used}`, true));
            }));
            gen.forIn("key", kwdErrs, (key2) => gen.forIn("keyProp", ajv_1._`${kwdErrs}[${key2}]`, (keyProp) => {
              gen.assign(paramsErrors, ajv_1._`${kwdErrs}[${key2}][${keyProp}]`);
              gen.if(ajv_1._`${paramsErrors}.length`, () => {
                const tmpl = gen.const("tmpl", ajv_1._`${templates}[${key2}] && ${templates}[${key2}][${keyProp}]`);
                errors_1.reportError(cxt, {
                  message: ajv_1._`${tmpl} ? ${tmpl}() : ${schemaValue}[${key2}][${keyProp}]`,
                  params: ajv_1._`{errors: ${paramsErrors}}`
                });
              });
            }));
          }
          function processChildErrors(childErrors) {
            const { props, items } = childErrors;
            if (!props && !items)
              return;
            const isObj = ajv_1._`typeof ${data} == "object"`;
            const isArr = ajv_1._`Array.isArray(${data})`;
            const childErrs = gen.let("emErrors");
            let childKwd;
            let childProp;
            const templates = gen.let("templates");
            if (props && items) {
              childKwd = gen.let("emChildKwd");
              gen.if(isObj);
              gen.if(isArr, () => {
                init(items, schema.items);
                gen.assign(childKwd, ajv_1.str`items`);
              }, () => {
                init(props, schema.properties);
                gen.assign(childKwd, ajv_1.str`properties`);
              });
              childProp = ajv_1._`[${childKwd}]`;
            } else if (items) {
              gen.if(isArr);
              init(items, schema.items);
              childProp = ajv_1._`.items`;
            } else if (props) {
              gen.if(codegen_1.and(isObj, codegen_1.not(isArr)));
              init(props, schema.properties);
              childProp = ajv_1._`.properties`;
            }
            gen.forOf("err", names_1.default.vErrors, (err) => ifMatchesChildError(err, childErrs, (child) => gen.code(ajv_1._`${childErrs}[${child}].push(${err})`).assign(ajv_1._`${err}.${used}`, true)));
            gen.forIn("key", childErrs, (key2) => gen.if(ajv_1._`${childErrs}[${key2}].length`, () => {
              errors_1.reportError(cxt, {
                message: ajv_1._`${key2} in ${templates} ? ${templates}[${key2}]() : ${schemaValue}${childProp}[${key2}]`,
                params: ajv_1._`{errors: ${childErrs}[${key2}]}`
              });
              gen.assign(ajv_1._`${names_1.default.vErrors}[${names_1.default.errors}-1].instancePath`, ajv_1._`${instancePath} + "/" + ${key2}.replace(/~/g, "~0").replace(/\\//g, "~1")`);
            }));
            gen.endIf();
            function init(children, msgs) {
              gen.assign(childErrs, ajv_1.stringify(children));
              gen.assign(templates, getTemplatesCode(children, msgs));
            }
          }
          function processAllErrors(schMessage) {
            const errs = gen.const("emErrs", ajv_1._`[]`);
            gen.forOf("err", names_1.default.vErrors, (err) => gen.if(matchAnyError(err), () => gen.code(ajv_1._`${errs}.push(${err})`).assign(ajv_1._`${err}.${used}`, true)));
            gen.if(ajv_1._`${errs}.length`, () => errors_1.reportError(cxt, {
              message: templateExpr(schMessage),
              params: ajv_1._`{errors: ${errs}}`
            }));
          }
          function removeUsedErrors() {
            const errs = gen.const("emErrs", ajv_1._`[]`);
            gen.forOf("err", names_1.default.vErrors, (err) => gen.if(ajv_1._`!${err}.${used}`, () => gen.code(ajv_1._`${errs}.push(${err})`)));
            gen.assign(names_1.default.vErrors, errs).assign(names_1.default.errors, ajv_1._`${errs}.length`);
          }
          function matchKeywordError(err, kwdErrs) {
            return codegen_1.and(
              ajv_1._`${err}.keyword !== ${keyword}`,
              ajv_1._`!${err}.${used}`,
              ajv_1._`${err}.instancePath === ${instancePath}`,
              ajv_1._`${err}.keyword in ${kwdErrs}`,
              // TODO match the end of the string?
              ajv_1._`${err}.schemaPath.indexOf(${it.errSchemaPath}) === 0`,
              ajv_1._`/^\\/[^\\/]*$/.test(${err}.schemaPath.slice(${it.errSchemaPath.length}))`
            );
          }
          function ifMatchesChildError(err, childErrs, thenBody) {
            gen.if(codegen_1.and(ajv_1._`${err}.keyword !== ${keyword}`, ajv_1._`!${err}.${used}`, ajv_1._`${err}.instancePath.indexOf(${instancePath}) === 0`), () => {
              const childRegex = gen.scopeValue("pattern", {
                ref: /^\/([^/]*)(?:\/|$)/,
                code: ajv_1._`new RegExp("^\\\/([^/]*)(?:\\\/|$)")`
              });
              const matches = gen.const("emMatches", ajv_1._`${childRegex}.exec(${err}.instancePath.slice(${instancePath}.length))`);
              const child = gen.const("emChild", ajv_1._`${matches} && ${matches}[1].replace(/~1/g, "/").replace(/~0/g, "~")`);
              gen.if(ajv_1._`${child} !== undefined && ${child} in ${childErrs}`, () => thenBody(child));
            });
          }
          function matchAnyError(err) {
            return codegen_1.and(ajv_1._`${err}.keyword !== ${keyword}`, ajv_1._`!${err}.${used}`, codegen_1.or(ajv_1._`${err}.instancePath === ${instancePath}`, codegen_1.and(ajv_1._`${err}.instancePath.indexOf(${instancePath}) === 0`, ajv_1._`${err}.instancePath[${instancePath}.length] === "/"`)), ajv_1._`${err}.schemaPath.indexOf(${it.errSchemaPath}) === 0`, ajv_1._`${err}.schemaPath[${it.errSchemaPath}.length] === "/"`);
          }
          function getTemplatesCode(keys, msgs) {
            const templatesCode = [];
            for (const k in keys) {
              const msg = msgs[k];
              if (INTERPOLATION.test(msg))
                templatesCode.push([k, templateFunc(msg)]);
            }
            return gen.object(...templatesCode);
          }
          function templateExpr(msg) {
            if (!INTERPOLATION.test(msg))
              return ajv_1.stringify(msg);
            return new code_1._Code(code_1.safeStringify(msg).replace(INTERPOLATION_REPLACE, (_s, ptr) => `" + JSON.stringify(${validate_1.getData(ptr, it)}) + "`).replace(EMPTY_STR, ""));
          }
          function templateFunc(msg) {
            return ajv_1._`function(){return ${templateExpr(msg)}}`;
          }
        },
        metaSchema: {
          anyOf: [
            { type: "string" },
            {
              type: "object",
              properties: {
                properties: { $ref: "#/$defs/stringMap" },
                items: { $ref: "#/$defs/stringList" },
                required: { $ref: "#/$defs/stringOrMap" },
                dependencies: { $ref: "#/$defs/stringOrMap" }
              },
              additionalProperties: { type: "string" }
            }
          ],
          $defs: {
            stringMap: {
              type: "object",
              additionalProperties: { type: "string" }
            },
            stringOrMap: {
              anyOf: [{ type: "string" }, { $ref: "#/$defs/stringMap" }]
            },
            stringList: { type: "array", items: { type: "string" } }
          }
        }
      };
    }
    var ajvErrors = (ajv, options = {}) => {
      if (!ajv.opts.allErrors)
        throw new Error("ajv-errors: Ajv option allErrors must be true");
      if (ajv.opts.jsPropertySyntax) {
        throw new Error("ajv-errors: ajv option jsPropertySyntax is not supported");
      }
      return ajv.addKeyword(errorMessage(options));
    };
    exports.default = ajvErrors;
    module.exports = ajvErrors;
    module.exports.default = ajvErrors;
  }
});

// node_modules/@splunk/dashboard-validation/dist/cjs/index.js
var require_cjs = __commonJS({
  "node_modules/@splunk/dashboard-validation/dist/cjs/index.js"(exports, module) {
    "use strict";
    var import_dist16 = __toESM(require_dist());
    var import_dist17 = __toESM(require_dist2());
    var import_dist18 = __toESM(require_dist3());
    var __create = Object.create;
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __getProtoOf = Object.getPrototypeOf;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key2 of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key2) && key2 !== except)
            __defProp(to, key2, { get: () => from[key2], enumerable: !(desc = __getOwnPropDesc(from, key2)) || desc.enumerable });
      }
      return to;
    };
    var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
    var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
      // If the importer is in node compatibility mode or this is not an ESM
      // file that has been converted to a CommonJS file using a Babel-
      // compatible transform (i.e. "__esModule" has not been set), then set
      // "default" to the CommonJS "module.exports" for node compatibility.
      isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
      mod
    ));
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export2(src_exports, {
      DashboardValidator: () => DashboardValidator,
      Validator: () => Validator,
      checkDuplicateTokens: () => checkDuplicateTokens,
      checkInputsInStructure: () => checkInputsInStructure,
      checkVisualizationsInStructure: () => checkVisualizationsInStructure
    });
    module.exports = __toCommonJS2(src_exports);
    var react_exports = {};
    __export2(react_exports, {
      default: () => react_default
    });
    var defaultImport = __toESM2(require_react());
    __reExport(react_exports, require_react());
    var react_default = "default" in defaultImport ? defaultImport.default : defaultImport;
    var useWorker = ({
      WorkerClass,
      onMessage,
      postMessage
    }) => {
      const enabled = typeof Worker !== "undefined";
      const isFirstRender = (0, react_exports.useRef)(true);
      const createInitialWorker = (0, react_exports.useCallback)(() => {
        if (!isFirstRender.current || !enabled) {
          return void 0;
        }
        isFirstRender.current = false;
        return new WorkerClass();
      }, [WorkerClass, enabled]);
      const worker = (0, react_exports.useRef)(createInitialWorker());
      (0, react_exports.useEffect)(() => {
        const workerToCleanUp = worker.current;
        return () => {
          var _a;
          (_a = workerToCleanUp == null ? void 0 : workerToCleanUp.terminate) == null ? void 0 : _a.call(workerToCleanUp);
        };
      }, []);
      const onMessageHandlerRef = (0, react_exports.useRef)();
      onMessageHandlerRef.current = onMessage;
      const onMessageHandler = (0, react_exports.useCallback)((...args) => {
        var _a;
        (_a = onMessageHandlerRef.current) == null ? void 0 : _a.call(onMessageHandlerRef, ...args);
      }, []);
      (0, react_exports.useEffect)(() => {
        const currentWorker = worker.current;
        if (enabled && currentWorker) {
          currentWorker.addEventListener("message", onMessageHandler);
        }
        return () => {
          if (enabled && currentWorker) {
            currentWorker.removeEventListener("message", onMessageHandler);
          }
        };
      }, [onMessageHandler, enabled]);
      (0, react_exports.useEffect)(() => {
        if (enabled && worker.current) {
          postMessage(worker.current);
        }
      }, [enabled, postMessage]);
      return { enabled };
    };
    function InlineWorker() {
      const url = URL.createObjectURL(new Blob(['"use strict";var ud=Object.create;var ts=Object.defineProperty,cd=Object.defineProperties,ld=Object.getOwnPropertyDescriptor,dd=Object.getOwnPropertyDescriptors,fd=Object.getOwnPropertyNames,to=Object.getOwnPropertySymbols,pd=Object.getPrototypeOf,so=Object.prototype.hasOwnProperty,hd=Object.prototype.propertyIsEnumerable;var ro=(e,t,r)=>t in e?ts(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r,L=(e,t)=>{for(var r in t||(t={}))so.call(t,r)&&ro(e,r,t[r]);if(to)for(var r of to(t))hd.call(t,r)&&ro(e,r,t[r]);return e},W=(e,t)=>cd(e,dd(t));var d=(e,t)=>()=>(t||e((t={exports:{}}).exports,t),t.exports);var md=(e,t,r,s)=>{if(t&&typeof t=="object"||typeof t=="function")for(let n of fd(t))!so.call(e,n)&&n!==r&&ts(e,n,{get:()=>t[n],enumerable:!(s=ld(t,n))||s.enumerable});return e};var pe=(e,t,r)=>(r=e!=null?ud(pd(e)):{},md(t||!e||!e.__esModule?ts(r,"default",{value:e,enumerable:!0}):r,e));var et=(e,t,r)=>new Promise((s,n)=>{var o=u=>{try{i(r.next(u))}catch(c){n(c)}},a=u=>{try{i(r.throw(u))}catch(c){n(c)}},i=u=>u.done?s(u.value):Promise.resolve(u.value).then(o,a);i((r=r.apply(e,t)).next())});var Te=d(tt=>{"use strict";Object.defineProperty(tt,"__esModule",{value:!0});tt.gettext=yd;tt._=_d;tt.setSharedTranslator=no;tt.resetSharedTranslator=oo;var rs;function yd(){return rs.apply(void 0,arguments)}function _d(){return rs.apply(void 0,arguments)}function no(e){rs=e}function oo(){no(typeof window!="undefined"&&window.gettext||function(e){return e})}oo()});var Oo=d((jv,No)=>{var Sd=/\\s/;function Pd(e){for(var t=e.length;t--&&Sd.test(e.charAt(t)););return t}No.exports=Pd});var Io=d((kv,To)=>{var Nd=Oo(),Od=/^\\s+/;function Td(e){return e&&e.slice(0,Nd(e)+1).replace(Od,"")}To.exports=Td});var St=d((Cv,qo)=>{function Id(e){var t=typeof e;return e!=null&&(t=="object"||t=="function")}qo.exports=Id});var ko=d((Rv,jo)=>{var qd=typeof global=="object"&&global&&global.Object===Object&&global;jo.exports=qd});var Pt=d((Av,Co)=>{var jd=ko(),kd=typeof self=="object"&&self&&self.Object===Object&&self,Cd=jd||kd||Function("return this")();Co.exports=Cd});var cr=d((Dv,Ro)=>{var Rd=Pt(),Ad=Rd.Symbol;Ro.exports=Ad});var xo=d((Mv,Mo)=>{var Ao=cr(),Do=Object.prototype,Dd=Do.hasOwnProperty,Md=Do.toString,Nt=Ao?Ao.toStringTag:void 0;function xd(e){var t=Dd.call(e,Nt),r=e[Nt];try{e[Nt]=void 0;var s=!0}catch(o){}var n=Md.call(e);return s&&(t?e[Nt]=r:delete e[Nt]),n}Mo.exports=xd});var zo=d((xv,Vo)=>{var Vd=Object.prototype,zd=Vd.toString;function Ld(e){return zd.call(e)}Vo.exports=Ld});var Ot=d((Vv,Fo)=>{var Lo=cr(),Ud=xo(),Fd=zo(),Kd="[object Null]",Hd="[object Undefined]",Uo=Lo?Lo.toStringTag:void 0;function Gd(e){return e==null?e===void 0?Hd:Kd:Uo&&Uo in Object(e)?Ud(e):Fd(e)}Fo.exports=Gd});var Tt=d((zv,Ko)=>{function Jd(e){return e!=null&&typeof e=="object"}Ko.exports=Jd});var It=d((Lv,Ho)=>{var Wd=Ot(),Xd=Tt(),Bd="[object Symbol]";function Yd(e){return typeof e=="symbol"||Xd(e)&&Wd(e)==Bd}Ho.exports=Yd});var lr=d((Uv,Wo)=>{var Zd=Io(),Go=St(),Qd=It(),Jo=NaN,ef=/^[-+]0x[0-9a-f]+$/i,tf=/^0b[01]+$/i,rf=/^0o[0-7]+$/i,sf=parseInt;function nf(e){if(typeof e=="number")return e;if(Qd(e))return Jo;if(Go(e)){var t=typeof e.valueOf=="function"?e.valueOf():e;e=Go(t)?t+"":t}if(typeof e!="string")return e===0?e:+e;e=Zd(e);var r=tf.test(e);return r||rf.test(e)?sf(e.slice(2),r?2:8):ef.test(e)?Jo:+e}Wo.exports=nf});var Bo=d((Fv,Xo)=>{var of=Ot(),af=Tt(),uf="[object Number]";function cf(e){return typeof e=="number"||af(e)&&of(e)==uf}Xo.exports=cf});var Qo=d((Kv,Zo)=>{var lf=lr(),Yo=1/0,df=17976931348623157e292;function ff(e){if(!e)return e===0?e:0;if(e=lf(e),e===Yo||e===-Yo){var t=e<0?-1:1;return t*df}return e===e?e:0}Zo.exports=ff});var ss=d((Hv,ea)=>{var pf=Qo();function hf(e){var t=pf(e),r=t%1;return t===t?r?t-r:t:0}ea.exports=hf});var ra=d((Gv,ta)=>{function mf(e,t){for(var r=-1,s=e==null?0:e.length,n=Array(s);++r<s;)n[r]=t(e[r],r,e);return n}ta.exports=mf});var qt=d((Jv,sa)=>{var yf=Array.isArray;sa.exports=yf});var ca=d((Wv,ua)=>{var na=cr(),_f=ra(),gf=qt(),$f=It(),vf=1/0,oa=na?na.prototype:void 0,aa=oa?oa.toString:void 0;function ia(e){if(typeof e=="string")return e;if(gf(e))return _f(e,ia)+"";if($f(e))return aa?aa.call(e):"";var t=e+"";return t=="0"&&1/e==-vf?"-0":t}ua.exports=ia});var dr=d((Xv,la)=>{var bf=ca();function Ef(e){return e==null?"":bf(e)}la.exports=Ef});var pa=d((Bv,fa)=>{var wf=Pt(),Sf=ss(),Pf=lr(),da=dr(),Nf=wf.isFinite,Of=Math.min;function Tf(e){var t=Math[e];return function(r,s){if(r=Pf(r),s=s==null?0:Of(Sf(s),292),s&&Nf(r)){var n=(da(r)+"e").split("e"),o=t(n[0]+"e"+(+n[1]+s));return n=(da(o)+"e").split("e"),+(n[0]+"e"+(+n[1]-s))}return t(r)}}fa.exports=Tf});var ma=d((Yv,ha)=>{var If=pa(),qf=If("round");ha.exports=qf});var ga=d(Fe=>{"use strict";Object.defineProperty(Fe,"__esModule",{value:!0});Fe.strictParseFloat=Af;Fe.roundToDecimal=Df;Fe.floorPowerOfTen=Mf;Fe.isLessThanMinSafeInt=xf;Fe.isGreaterThanMaxSafeInt=Vf;var ya=_a(Bo()),jf=_a(ma());function _a(e){return e&&e.__esModule?e:{default:e}}var kf=/(^[-+]?[0-9]*[.]?[0-9]*$)|(^[-+]?[0-9][.]?[0-9]*e[-+]?[0-9][0-9]*$)/i,Cf=-9007199254740991,Rf=9007199254740991;function Af(e){return kf.test(e)?parseFloat(e):NaN}function Df(e){var t=arguments.length>1&&arguments[1]!==void 0?arguments[1]:0;return(0,jf.default)(e,t*-1)}function Mf(e){return Math.pow(10,Math.floor(Math.log(e)/Math.LN10))}function xf(e){return(0,ya.default)(e)?e<=Cf:!1}function Vf(e){return(0,ya.default)(e)?e>=Rf:!1}});var va=d((Qv,$a)=>{var zf=Object.prototype,Lf=zf.hasOwnProperty;function Uf(e,t){return e!=null&&Lf.call(e,t)}$a.exports=Uf});var Ea=d((eb,ba)=>{var Ff=qt(),Kf=It(),Hf=/\\.|\\[(?:[^[\\]]*|(["\'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,Gf=/^\\w*$/;function Jf(e,t){if(Ff(e))return!1;var r=typeof e;return r=="number"||r=="symbol"||r=="boolean"||e==null||Kf(e)?!0:Gf.test(e)||!Hf.test(e)||t!=null&&e in Object(t)}ba.exports=Jf});var ns=d((tb,wa)=>{var Wf=Ot(),Xf=St(),Bf="[object AsyncFunction]",Yf="[object Function]",Zf="[object GeneratorFunction]",Qf="[object Proxy]";function ep(e){if(!Xf(e))return!1;var t=Wf(e);return t==Yf||t==Zf||t==Bf||t==Qf}wa.exports=ep});var Pa=d((rb,Sa)=>{var tp=Pt(),rp=tp["__core-js_shared__"];Sa.exports=rp});var Ta=d((sb,Oa)=>{var os=Pa(),Na=function(){var e=/[^.]+$/.exec(os&&os.keys&&os.keys.IE_PROTO||"");return e?"Symbol(src)_1."+e:""}();function sp(e){return!!Na&&Na in e}Oa.exports=sp});var qa=d((nb,Ia)=>{var np=Function.prototype,op=np.toString;function ap(e){if(e!=null){try{return op.call(e)}catch(t){}try{return e+""}catch(t){}}return""}Ia.exports=ap});var ka=d((ob,ja)=>{var ip=ns(),up=Ta(),cp=St(),lp=qa(),dp=/[\\\\^$.*+?()[\\]{}|]/g,fp=/^\\[object .+?Constructor\\]$/,pp=Function.prototype,hp=Object.prototype,mp=pp.toString,yp=hp.hasOwnProperty,_p=RegExp("^"+mp.call(yp).replace(dp,"\\\\$&").replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g,"$1.*?")+"$");function gp(e){if(!cp(e)||up(e))return!1;var t=ip(e)?_p:fp;return t.test(lp(e))}ja.exports=gp});var Ra=d((ab,Ca)=>{function $p(e,t){return e==null?void 0:e[t]}Ca.exports=$p});var as=d((ib,Aa)=>{var vp=ka(),bp=Ra();function Ep(e,t){var r=bp(e,t);return vp(r)?r:void 0}Aa.exports=Ep});var jt=d((ub,Da)=>{var wp=as(),Sp=wp(Object,"create");Da.exports=Sp});var Va=d((cb,xa)=>{var Ma=jt();function Pp(){this.__data__=Ma?Ma(null):{},this.size=0}xa.exports=Pp});var La=d((lb,za)=>{function Np(e){var t=this.has(e)&&delete this.__data__[e];return this.size-=t?1:0,t}za.exports=Np});var Fa=d((db,Ua)=>{var Op=jt(),Tp="__lodash_hash_undefined__",Ip=Object.prototype,qp=Ip.hasOwnProperty;function jp(e){var t=this.__data__;if(Op){var r=t[e];return r===Tp?void 0:r}return qp.call(t,e)?t[e]:void 0}Ua.exports=jp});var Ha=d((fb,Ka)=>{var kp=jt(),Cp=Object.prototype,Rp=Cp.hasOwnProperty;function Ap(e){var t=this.__data__;return kp?t[e]!==void 0:Rp.call(t,e)}Ka.exports=Ap});var Ja=d((pb,Ga)=>{var Dp=jt(),Mp="__lodash_hash_undefined__";function xp(e,t){var r=this.__data__;return this.size+=this.has(e)?0:1,r[e]=Dp&&t===void 0?Mp:t,this}Ga.exports=xp});var Xa=d((hb,Wa)=>{var Vp=Va(),zp=La(),Lp=Fa(),Up=Ha(),Fp=Ja();function rt(e){var t=-1,r=e==null?0:e.length;for(this.clear();++t<r;){var s=e[t];this.set(s[0],s[1])}}rt.prototype.clear=Vp;rt.prototype.delete=zp;rt.prototype.get=Lp;rt.prototype.has=Up;rt.prototype.set=Fp;Wa.exports=rt});var Ya=d((mb,Ba)=>{function Kp(){this.__data__=[],this.size=0}Ba.exports=Kp});var is=d((yb,Za)=>{function Hp(e,t){return e===t||e!==e&&t!==t}Za.exports=Hp});var kt=d((_b,Qa)=>{var Gp=is();function Jp(e,t){for(var r=e.length;r--;)if(Gp(e[r][0],t))return r;return-1}Qa.exports=Jp});var ti=d((gb,ei)=>{var Wp=kt(),Xp=Array.prototype,Bp=Xp.splice;function Yp(e){var t=this.__data__,r=Wp(t,e);if(r<0)return!1;var s=t.length-1;return r==s?t.pop():Bp.call(t,r,1),--this.size,!0}ei.exports=Yp});var si=d(($b,ri)=>{var Zp=kt();function Qp(e){var t=this.__data__,r=Zp(t,e);return r<0?void 0:t[r][1]}ri.exports=Qp});var oi=d((vb,ni)=>{var eh=kt();function th(e){return eh(this.__data__,e)>-1}ni.exports=th});var ii=d((bb,ai)=>{var rh=kt();function sh(e,t){var r=this.__data__,s=rh(r,e);return s<0?(++this.size,r.push([e,t])):r[s][1]=t,this}ai.exports=sh});var ci=d((Eb,ui)=>{var nh=Ya(),oh=ti(),ah=si(),ih=oi(),uh=ii();function st(e){var t=-1,r=e==null?0:e.length;for(this.clear();++t<r;){var s=e[t];this.set(s[0],s[1])}}st.prototype.clear=nh;st.prototype.delete=oh;st.prototype.get=ah;st.prototype.has=ih;st.prototype.set=uh;ui.exports=st});var di=d((wb,li)=>{var ch=as(),lh=Pt(),dh=ch(lh,"Map");li.exports=dh});var hi=d((Sb,pi)=>{var fi=Xa(),fh=ci(),ph=di();function hh(){this.size=0,this.__data__={hash:new fi,map:new(ph||fh),string:new fi}}pi.exports=hh});var yi=d((Pb,mi)=>{function mh(e){var t=typeof e;return t=="string"||t=="number"||t=="symbol"||t=="boolean"?e!=="__proto__":e===null}mi.exports=mh});var Ct=d((Nb,_i)=>{var yh=yi();function _h(e,t){var r=e.__data__;return yh(t)?r[typeof t=="string"?"string":"hash"]:r.map}_i.exports=_h});var $i=d((Ob,gi)=>{var gh=Ct();function $h(e){var t=gh(this,e).delete(e);return this.size-=t?1:0,t}gi.exports=$h});var bi=d((Tb,vi)=>{var vh=Ct();function bh(e){return vh(this,e).get(e)}vi.exports=bh});var wi=d((Ib,Ei)=>{var Eh=Ct();function wh(e){return Eh(this,e).has(e)}Ei.exports=wh});var Pi=d((qb,Si)=>{var Sh=Ct();function Ph(e,t){var r=Sh(this,e),s=r.size;return r.set(e,t),this.size+=r.size==s?0:1,this}Si.exports=Ph});var Oi=d((jb,Ni)=>{var Nh=hi(),Oh=$i(),Th=bi(),Ih=wi(),qh=Pi();function nt(e){var t=-1,r=e==null?0:e.length;for(this.clear();++t<r;){var s=e[t];this.set(s[0],s[1])}}nt.prototype.clear=Nh;nt.prototype.delete=Oh;nt.prototype.get=Th;nt.prototype.has=Ih;nt.prototype.set=qh;Ni.exports=nt});var qi=d((kb,Ii)=>{var Ti=Oi(),jh="Expected a function";function us(e,t){if(typeof e!="function"||t!=null&&typeof t!="function")throw new TypeError(jh);var r=function(){var s=arguments,n=t?t.apply(this,s):s[0],o=r.cache;if(o.has(n))return o.get(n);var a=e.apply(this,s);return r.cache=o.set(n,a)||o,a};return r.cache=new(us.Cache||Ti),r}us.Cache=Ti;Ii.exports=us});var ki=d((Cb,ji)=>{var kh=qi(),Ch=500;function Rh(e){var t=kh(e,function(s){return r.size===Ch&&r.clear(),s}),r=t.cache;return t}ji.exports=Rh});var Ri=d((Rb,Ci)=>{var Ah=ki(),Dh=/[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|(["\'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g,Mh=/\\\\(\\\\)?/g,xh=Ah(function(e){var t=[];return e.charCodeAt(0)===46&&t.push(""),e.replace(Dh,function(r,s,n,o){t.push(n?o.replace(Mh,"$1"):s||r)}),t});Ci.exports=xh});var Di=d((Ab,Ai)=>{var Vh=qt(),zh=Ea(),Lh=Ri(),Uh=dr();function Fh(e,t){return Vh(e)?e:zh(e,t)?[e]:Lh(Uh(e))}Ai.exports=Fh});var xi=d((Db,Mi)=>{var Kh=Ot(),Hh=Tt(),Gh="[object Arguments]";function Jh(e){return Hh(e)&&Kh(e)==Gh}Mi.exports=Jh});var Ui=d((Mb,Li)=>{var Vi=xi(),Wh=Tt(),zi=Object.prototype,Xh=zi.hasOwnProperty,Bh=zi.propertyIsEnumerable,Yh=Vi(function(){return arguments}())?Vi:function(e){return Wh(e)&&Xh.call(e,"callee")&&!Bh.call(e,"callee")};Li.exports=Yh});var cs=d((xb,Fi)=>{var Zh=9007199254740991,Qh=/^(?:0|[1-9]\\d*)$/;function em(e,t){var r=typeof e;return t=t==null?Zh:t,!!t&&(r=="number"||r!="symbol"&&Qh.test(e))&&e>-1&&e%1==0&&e<t}Fi.exports=em});var ls=d((Vb,Ki)=>{var tm=9007199254740991;function rm(e){return typeof e=="number"&&e>-1&&e%1==0&&e<=tm}Ki.exports=rm});var Gi=d((zb,Hi)=>{var sm=It(),nm=1/0;function om(e){if(typeof e=="string"||sm(e))return e;var t=e+"";return t=="0"&&1/e==-nm?"-0":t}Hi.exports=om});var Wi=d((Lb,Ji)=>{var am=Di(),im=Ui(),um=qt(),cm=cs(),lm=ls(),dm=Gi();function fm(e,t,r){t=am(t,e);for(var s=-1,n=t.length,o=!1;++s<n;){var a=dm(t[s]);if(!(o=e!=null&&r(e,a)))break;e=e[a]}return o||++s!=n?o:(n=e==null?0:e.length,!!n&&lm(n)&&cm(a,n)&&(um(e)||im(e)))}Ji.exports=fm});var Bi=d((Ub,Xi)=>{var pm=va(),hm=Wi();function mm(e,t){return e!=null&&hm(e,t,pm)}Xi.exports=mm});var Zi=d((Fb,Yi)=>{var ym=9007199254740991,_m=Math.floor;function gm(e,t){var r="";if(!e||t<1||t>ym)return r;do t%2&&(r+=e),t=_m(t/2),t&&(e+=e);while(t);return r}Yi.exports=gm});var eu=d((Kb,Qi)=>{var $m=ns(),vm=ls();function bm(e){return e!=null&&vm(e.length)&&!$m(e)}Qi.exports=bm});var ru=d((Hb,tu)=>{var Em=is(),wm=eu(),Sm=cs(),Pm=St();function Nm(e,t,r){if(!Pm(r))return!1;var s=typeof t;return(s=="number"?wm(r)&&Sm(t,r.length):s=="string"&&t in r)?Em(r[t],e):!1}tu.exports=Nm});var nu=d((Gb,su)=>{var Om=Zi(),Tm=ru(),Im=ss(),qm=dr();function jm(e,t,r){return(r?Tm(e,t,r):t===void 0)?t=1:t=Im(t),Om(qm(e),t)}su.exports=jm});var cu=d(pr=>{"use strict";Object.defineProperty(pr,"__esModule",{value:!0});pr.sprintfFormat=iu;pr.sprintfParse=uu;var km=au(Bi()),Cm=au(nu());function au(e){return e&&e.__esModule?e:{default:e}}function ds(e){"@babel/helpers - typeof";return ds=typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?function(t){return typeof t}:function(t){return t&&typeof Symbol=="function"&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},ds(e)}var le={notType:/[^T]/,notPrimitive:/[^v]/,number:/[diefg]/,numericArg:/[bcdiefguxX]/,json:/[j]/,text:/^[^\\x25]+/,modulo:/^\\x25{2}/,placeholder:/^\\x25(?:([1-9]\\d*)\\$|\\(([^)]+)\\))?(\\+)?(0|\'[^$])?(-)?(\\d+)?(?:\\.(\\d+))?([b-gijostTuvxX])/,key:/^([a-z_][a-z_\\d]*)/i,keyAccess:/^\\.([a-z_][a-z_\\d]*)/i,indexAccess:/^\\[(\\d+)\\]/,sign:/^[+-]/};function ou(e){for(var t=arguments.length,r=new Array(t>1?t-1:0),s=1;s<t;s++)r[s-1]=arguments[s];return iu(uu(e),[e].concat(r))}function iu(e,t){var r=e.length,s=1,n,o="",a,i,u,c,l,f,_,m;for(a=0;a<r;a+=1)if(typeof e[a]=="string")o+=e[a];else if(ds(e[a])==="object"){if(u=e[a],u.keys)for(n=t[s],i=0;i<u.keys.length;i+=1){if(!(0,km.default)(n,u.keys[i]))throw new Error(ou(\'[sprintf] property "%s" does not exist\',u.keys[i]));n=n[u.keys[i]]}else u.paramNo?n=t[u.paramNo]:(n=t[s],s+=1);if(le.notType.test(u.type)&&le.notPrimitive.test(u.type)&&n instanceof Function&&(n=n()),le.numericArg.test(u.type)&&typeof n!="number"&&Number.isNaN(Number(n)))throw new TypeError(ou("[sprintf] expecting number but found %T",n));switch(le.number.test(u.type)&&(_=n>=0),u.type){case"b":n=parseInt(n,10).toString(2);break;case"c":n=String.fromCharCode(parseInt(n,10));break;case"d":case"i":n=parseInt(n,10);break;case"j":n=JSON.stringify(n,null,u.width?parseInt(u.width,10):0);break;case"e":n=u.precision?parseFloat(n).toExponential(u.precision):parseFloat(n).toExponential();break;case"f":n=u.precision?parseFloat(n).toFixed(u.precision):parseFloat(n);break;case"g":n=u.precision?String(Number(n.toPrecision(u.precision))):parseFloat(n);break;case"o":n=(parseInt(n,10)>>>0).toString(8);break;case"s":n=String(n),n=u.precision?n.substring(0,u.precision):n;break;case"t":n=String(!!n),n=u.precision?n.substring(0,u.precision):n;break;case"T":n=Object.prototype.toString.call(n).slice(8,-1).toLowerCase(),n=u.precision?n.substring(0,u.precision):n;break;case"u":n=parseInt(n,10)>>>0;break;case"v":n=n.valueOf(),n=u.precision?n.substring(0,u.precision):n;break;case"x":n=(parseInt(n,10)>>>0).toString(16);break;case"X":n=(parseInt(n,10)>>>0).toString(16).toUpperCase();break}le.json.test(u.type)?o+=n:(le.number.test(u.type)&&(!_||u.sign)?(m=_?"+":"-",n=n.toString().replace(le.sign,"")):m="",l=u.padChar?u.padChar==="0"?"0":u.padChar.charAt(1):" ",f=u.width-(m+n).length,c=u.width&&f>0?(0,Cm.default)(l,f):"",o+=u.align?m+n+c:l==="0"?m+c+n:c+m+n)}return o}var fr=Object.create(null);function uu(e){if(fr[e])return fr[e];for(var t=e,r,s=0,n=[];t;){if((r=le.text.exec(t))!==null)n.push(r[0]);else if((r=le.modulo.exec(t))!==null)n.push("%");else if((r=le.placeholder.exec(t))!==null){if(r[2]){s|=1;var o=r[2],a=[],i=[];if((a=le.key.exec(o))!==null)for(i.push(a[1]);(o=o.substring(a[0].length))!=="";)if((a=le.keyAccess.exec(o))!==null)i.push(a[1]);else if((a=le.indexAccess.exec(o))!==null)i.push(a[1]);else throw new SyntaxError("[sprintf] failed to parse named argument key");else throw new SyntaxError("[sprintf] failed to parse named argument key");r[2]=i}else s|=2;if(s===3)throw new Error("[sprintf] mixing positional and named placeholders is not (yet) supported");n.push({placeholder:r[0],paramNo:r[1],keys:r[2],sign:r[3],padChar:r[4],align:r[5],width:r[6],precision:r[7],type:r[8]})}else throw new SyntaxError("[sprintf] unexpected placeholder");t=t.substring(r[0].length)}return fr[e]=n,fr[e]}});var hr=d(ot=>{"use strict";Object.defineProperty(ot,"__esModule",{value:!0});ot.sprintf=te;ot.abbreviateNumber=Dm;ot.bytesToFileSize=Mm;ot.smartTrim=xm;var Rm=Am(lr()),ne=Te(),de=ga(),lu=cu();function Am(e){return e&&e.__esModule?e:{default:e}}function te(e){for(var t=arguments.length,r=new Array(t>1?t-1:0),s=1;s<t;s++)r[s-1]=arguments[s];return(0,lu.sprintfFormat)((0,lu.sprintfParse)(e),[e].concat(r))}function Dm(e){var t=arguments.length>1&&arguments[1]!==void 0?arguments[1]:"en-us",r=(0,Rm.default)(e);return r<=1e3?r.toLocaleString(t):r<1e4?te((0,ne._)("%sK"),(0,de.roundToDecimal)(r/1e3,-2).toLocaleString(t)):r<1e5?te((0,ne._)("%sK"),(0,de.roundToDecimal)(r/1e3,-1).toLocaleString(t)):r<999500?te((0,ne._)("%sK"),(0,de.roundToDecimal)(r/1e3,0).toLocaleString(t)):r<1e7?te((0,ne._)("%sM"),(0,de.roundToDecimal)(r/1e6,-2).toLocaleString(t)):r<1e8?te((0,ne._)("%sM"),(0,de.roundToDecimal)(r/1e6,-1).toLocaleString(t)):r<9995e5?te((0,ne._)("%sM"),(0,de.roundToDecimal)(r/1e6,0).toLocaleString(t)):r<1e10?te((0,ne._)("%sB"),(0,de.roundToDecimal)(r/1e9,-2).toLocaleString(t)):r<1e11?te((0,ne._)("%sB"),(0,de.roundToDecimal)(r/1e9,-1).toLocaleString(t)):te((0,ne._)("%sB"),(0,de.roundToDecimal)(r/1e9,0).toLocaleString(t))}function Mm(e){var t=arguments.length>1&&arguments[1]!==void 0?arguments[1]:"en-us",r=(e||0)/1024;if(r<0)throw new RangeError("bytes must be >= 0");if(Math.floor(r)===0)return te((0,ne._)("%s B"),e.toLocaleString(t));var s=r/1024;if(Math.floor(s)===0)return te((0,ne._)("%s KB"),(0,de.roundToDecimal)(r,-2).toLocaleString(t));var n=s/1024;if(Math.floor(n)===0)return te((0,ne._)("%s MB"),(0,de.roundToDecimal)(s,-2).toLocaleString(t));var o=n/1024;return Math.floor(o)===0?te((0,ne._)("%s GB"),(0,de.roundToDecimal)(n,-2).toLocaleString(t)):te((0,ne._)("%s TB"),(0,de.roundToDecimal)(o,-2).toLocaleString(t))}function xm(e,t){var r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{},s=r.precomposed,n=s===void 0?!1:s;if(!e||t<1||e.length<=t)return e;var o=n?"\\u2026":"...";if(t===1)return"".concat(e[0]).concat(o);var a=Math.ceil(e.length/2),i=e.length-t,u=Math.ceil(i/2),c=i-u;return"".concat(e.substring(0,a-u)).concat(o).concat(e.substring(a+c))}});var at=d(A=>{"use strict";Object.defineProperty(A,"__esModule",{value:!0});A.regexpCode=A.getEsmExportName=A.getProperty=A.safeStringify=A.stringify=A.strConcat=A.addCodeArg=A.str=A._=A.nil=A._Code=A.Name=A.IDENTIFIER=A._CodeOrName=void 0;var At=class{};A._CodeOrName=At;A.IDENTIFIER=/^[a-z$_][a-z$_0-9]*$/i;var Ke=class extends At{constructor(t){if(super(),!A.IDENTIFIER.test(t))throw new Error("CodeGen: name must be a valid identifier");this.str=t}toString(){return this.str}emptyStr(){return!1}get names(){return{[this.str]:1}}};A.Name=Ke;var he=class extends At{constructor(t){super(),this._items=typeof t=="string"?[t]:t}toString(){return this.str}emptyStr(){if(this._items.length>1)return!1;let t=this._items[0];return t===""||t===\'""\'}get str(){var t;return(t=this._str)!==null&&t!==void 0?t:this._str=this._items.reduce((r,s)=>`${r}${s}`,"")}get names(){var t;return(t=this._names)!==null&&t!==void 0?t:this._names=this._items.reduce((r,s)=>(s instanceof Ke&&(r[s.str]=(r[s.str]||0)+1),r),{})}};A._Code=he;A.nil=new he("");function yu(e,...t){let r=[e[0]],s=0;for(;s<t.length;)hs(r,t[s]),r.push(e[++s]);return new he(r)}A._=yu;var ps=new he("+");function _u(e,...t){let r=[Dt(e[0])],s=0;for(;s<t.length;)r.push(ps),hs(r,t[s]),r.push(ps,Dt(e[++s]));return Fm(r),new he(r)}A.str=_u;function hs(e,t){t instanceof he?e.push(...t._items):t instanceof Ke?e.push(t):e.push(Gm(t))}A.addCodeArg=hs;function Fm(e){let t=1;for(;t<e.length-1;){if(e[t]===ps){let r=Km(e[t-1],e[t+1]);if(r!==void 0){e.splice(t-1,3,r);continue}e[t++]="+"}t++}}function Km(e,t){if(t===\'""\')return e;if(e===\'""\')return t;if(typeof e=="string")return t instanceof Ke||e[e.length-1]!==\'"\'?void 0:typeof t!="string"?`${e.slice(0,-1)}${t}"`:t[0]===\'"\'?e.slice(0,-1)+t.slice(1):void 0;if(typeof t=="string"&&t[0]===\'"\'&&!(e instanceof Ke))return`"${e}${t.slice(1)}`}function Hm(e,t){return t.emptyStr()?e:e.emptyStr()?t:_u`${e}${t}`}A.strConcat=Hm;function Gm(e){return typeof e=="number"||typeof e=="boolean"||e===null?e:Dt(Array.isArray(e)?e.join(","):e)}function Jm(e){return new he(Dt(e))}A.stringify=Jm;function Dt(e){return JSON.stringify(e).replace(/\\u2028/g,"\\\\u2028").replace(/\\u2029/g,"\\\\u2029")}A.safeStringify=Dt;function Wm(e){return typeof e=="string"&&A.IDENTIFIER.test(e)?new he(`.${e}`):yu`[${e}]`}A.getProperty=Wm;function Xm(e){if(typeof e=="string"&&A.IDENTIFIER.test(e))return new he(`${e}`);throw new Error(`CodeGen: invalid export name: ${e}, use explicit $id name mapping`)}A.getEsmExportName=Xm;function Bm(e){return new he(e.toString())}A.regexpCode=Bm});var _s=d(ae=>{"use strict";Object.defineProperty(ae,"__esModule",{value:!0});ae.ValueScope=ae.ValueScopeName=ae.Scope=ae.varKinds=ae.UsedValueState=void 0;var oe=at(),ms=class extends Error{constructor(t){super(`CodeGen: "code" for ${t} not defined`),this.value=t.value}},_r;(function(e){e[e.Started=0]="Started",e[e.Completed=1]="Completed"})(_r||(ae.UsedValueState=_r={}));ae.varKinds={const:new oe.Name("const"),let:new oe.Name("let"),var:new oe.Name("var")};var gr=class{constructor({prefixes:t,parent:r}={}){this._names={},this._prefixes=t,this._parent=r}toName(t){return t instanceof oe.Name?t:this.name(t)}name(t){return new oe.Name(this._newName(t))}_newName(t){let r=this._names[t]||this._nameGroup(t);return`${t}${r.index++}`}_nameGroup(t){var r,s;if(!((s=(r=this._parent)===null||r===void 0?void 0:r._prefixes)===null||s===void 0)&&s.has(t)||this._prefixes&&!this._prefixes.has(t))throw new Error(`CodeGen: prefix "${t}" is not allowed in this scope`);return this._names[t]={prefix:t,index:0}}};ae.Scope=gr;var $r=class extends oe.Name{constructor(t,r){super(r),this.prefix=t}setValue(t,{property:r,itemIndex:s}){this.value=t,this.scopePath=(0,oe._)`.${new oe.Name(r)}[${s}]`}};ae.ValueScopeName=$r;var Ym=(0,oe._)`\\n`,ys=class extends gr{constructor(t){super(t),this._values={},this._scope=t.scope,this.opts=W(L({},t),{_n:t.lines?Ym:oe.nil})}get(){return this._scope}name(t){return new $r(t,this._newName(t))}value(t,r){var s;if(r.ref===void 0)throw new Error("CodeGen: ref must be passed in value");let n=this.toName(t),{prefix:o}=n,a=(s=r.key)!==null&&s!==void 0?s:r.ref,i=this._values[o];if(i){let l=i.get(a);if(l)return l}else i=this._values[o]=new Map;i.set(a,n);let u=this._scope[o]||(this._scope[o]=[]),c=u.length;return u[c]=r.ref,n.setValue(r,{property:o,itemIndex:c}),n}getValue(t,r){let s=this._values[t];if(s)return s.get(r)}scopeRefs(t,r=this._values){return this._reduceValues(r,s=>{if(s.scopePath===void 0)throw new Error(`CodeGen: name "${s}" has no value`);return(0,oe._)`${t}${s.scopePath}`})}scopeCode(t=this._values,r,s){return this._reduceValues(t,n=>{if(n.value===void 0)throw new Error(`CodeGen: name "${n}" has no value`);return n.value.code},r,s)}_reduceValues(t,r,s={},n){let o=oe.nil;for(let a in t){let i=t[a];if(!i)continue;let u=s[a]=s[a]||new Map;i.forEach(c=>{if(u.has(c))return;u.set(c,_r.Started);let l=r(c);if(l){let f=this.opts.es5?ae.varKinds.var:ae.varKinds.const;o=(0,oe._)`${o}${f} ${c} = ${l};${this.opts._n}`}else if(l=n==null?void 0:n(c))o=(0,oe._)`${o}${l}${this.opts._n}`;else throw new ms(c);u.set(c,_r.Completed)})}return o}};ae.ValueScope=ys});var I=d(T=>{"use strict";Object.defineProperty(T,"__esModule",{value:!0});T.or=T.and=T.not=T.CodeGen=T.operators=T.varKinds=T.ValueScopeName=T.ValueScope=T.Scope=T.Name=T.regexpCode=T.stringify=T.getProperty=T.nil=T.strConcat=T.str=T._=void 0;var C=at(),ge=_s(),Ce=at();Object.defineProperty(T,"_",{enumerable:!0,get:function(){return Ce._}});Object.defineProperty(T,"str",{enumerable:!0,get:function(){return Ce.str}});Object.defineProperty(T,"strConcat",{enumerable:!0,get:function(){return Ce.strConcat}});Object.defineProperty(T,"nil",{enumerable:!0,get:function(){return Ce.nil}});Object.defineProperty(T,"getProperty",{enumerable:!0,get:function(){return Ce.getProperty}});Object.defineProperty(T,"stringify",{enumerable:!0,get:function(){return Ce.stringify}});Object.defineProperty(T,"regexpCode",{enumerable:!0,get:function(){return Ce.regexpCode}});Object.defineProperty(T,"Name",{enumerable:!0,get:function(){return Ce.Name}});var wr=_s();Object.defineProperty(T,"Scope",{enumerable:!0,get:function(){return wr.Scope}});Object.defineProperty(T,"ValueScope",{enumerable:!0,get:function(){return wr.ValueScope}});Object.defineProperty(T,"ValueScopeName",{enumerable:!0,get:function(){return wr.ValueScopeName}});Object.defineProperty(T,"varKinds",{enumerable:!0,get:function(){return wr.varKinds}});T.operators={GT:new C._Code(">"),GTE:new C._Code(">="),LT:new C._Code("<"),LTE:new C._Code("<="),EQ:new C._Code("==="),NEQ:new C._Code("!=="),NOT:new C._Code("!"),OR:new C._Code("||"),AND:new C._Code("&&"),ADD:new C._Code("+")};var Ie=class{optimizeNodes(){return this}optimizeNames(t,r){return this}},gs=class extends Ie{constructor(t,r,s){super(),this.varKind=t,this.name=r,this.rhs=s}render({es5:t,_n:r}){let s=t?ge.varKinds.var:this.varKind,n=this.rhs===void 0?"":` = ${this.rhs}`;return`${s} ${this.name}${n};`+r}optimizeNames(t,r){if(t[this.name.str])return this.rhs&&(this.rhs=ut(this.rhs,t,r)),this}get names(){return this.rhs instanceof C._CodeOrName?this.rhs.names:{}}},vr=class extends Ie{constructor(t,r,s){super(),this.lhs=t,this.rhs=r,this.sideEffects=s}render({_n:t}){return`${this.lhs} = ${this.rhs};`+t}optimizeNames(t,r){if(!(this.lhs instanceof C.Name&&!t[this.lhs.str]&&!this.sideEffects))return this.rhs=ut(this.rhs,t,r),this}get names(){let t=this.lhs instanceof C.Name?{}:L({},this.lhs.names);return Er(t,this.rhs)}},$s=class extends vr{constructor(t,r,s,n){super(t,s,n),this.op=r}render({_n:t}){return`${this.lhs} ${this.op}= ${this.rhs};`+t}},vs=class extends Ie{constructor(t){super(),this.label=t,this.names={}}render({_n:t}){return`${this.label}:`+t}},bs=class extends Ie{constructor(t){super(),this.label=t,this.names={}}render({_n:t}){return`break${this.label?` ${this.label}`:""};`+t}},Es=class extends Ie{constructor(t){super(),this.error=t}render({_n:t}){return`throw ${this.error};`+t}get names(){return this.error.names}},ws=class extends Ie{constructor(t){super(),this.code=t}render({_n:t}){return`${this.code};`+t}optimizeNodes(){return`${this.code}`?this:void 0}optimizeNames(t,r){return this.code=ut(this.code,t,r),this}get names(){return this.code instanceof C._CodeOrName?this.code.names:{}}},Mt=class extends Ie{constructor(t=[]){super(),this.nodes=t}render(t){return this.nodes.reduce((r,s)=>r+s.render(t),"")}optimizeNodes(){let{nodes:t}=this,r=t.length;for(;r--;){let s=t[r].optimizeNodes();Array.isArray(s)?t.splice(r,1,...s):s?t[r]=s:t.splice(r,1)}return t.length>0?this:void 0}optimizeNames(t,r){let{nodes:s}=this,n=s.length;for(;n--;){let o=s[n];o.optimizeNames(t,r)||(Zm(t,o.names),s.splice(n,1))}return s.length>0?this:void 0}get names(){return this.nodes.reduce((t,r)=>Je(t,r.names),{})}},qe=class extends Mt{render(t){return"{"+t._n+super.render(t)+"}"+t._n}},Ss=class extends Mt{},it=class extends qe{};it.kind="else";var He=class e extends qe{constructor(t,r){super(r),this.condition=t}render(t){let r=`if(${this.condition})`+super.render(t);return this.else&&(r+="else "+this.else.render(t)),r}optimizeNodes(){super.optimizeNodes();let t=this.condition;if(t===!0)return this.nodes;let r=this.else;if(r){let s=r.optimizeNodes();r=this.else=Array.isArray(s)?new it(s):s}if(r)return t===!1?r instanceof e?r:r.nodes:this.nodes.length?this:new e(gu(t),r instanceof e?[r]:r.nodes);if(!(t===!1||!this.nodes.length))return this}optimizeNames(t,r){var s;if(this.else=(s=this.else)===null||s===void 0?void 0:s.optimizeNames(t,r),!!(super.optimizeNames(t,r)||this.else))return this.condition=ut(this.condition,t,r),this}get names(){let t=super.names;return Er(t,this.condition),this.else&&Je(t,this.else.names),t}};He.kind="if";var Ge=class extends qe{};Ge.kind="for";var Ps=class extends Ge{constructor(t){super(),this.iteration=t}render(t){return`for(${this.iteration})`+super.render(t)}optimizeNames(t,r){if(super.optimizeNames(t,r))return this.iteration=ut(this.iteration,t,r),this}get names(){return Je(super.names,this.iteration.names)}},Ns=class extends Ge{constructor(t,r,s,n){super(),this.varKind=t,this.name=r,this.from=s,this.to=n}render(t){let r=t.es5?ge.varKinds.var:this.varKind,{name:s,from:n,to:o}=this;return`for(${r} ${s}=${n}; ${s}<${o}; ${s}++)`+super.render(t)}get names(){let t=Er(super.names,this.from);return Er(t,this.to)}},br=class extends Ge{constructor(t,r,s,n){super(),this.loop=t,this.varKind=r,this.name=s,this.iterable=n}render(t){return`for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})`+super.render(t)}optimizeNames(t,r){if(super.optimizeNames(t,r))return this.iterable=ut(this.iterable,t,r),this}get names(){return Je(super.names,this.iterable.names)}},xt=class extends qe{constructor(t,r,s){super(),this.name=t,this.args=r,this.async=s}render(t){return`${this.async?"async ":""}function ${this.name}(${this.args})`+super.render(t)}};xt.kind="func";var Vt=class extends Mt{render(t){return"return "+super.render(t)}};Vt.kind="return";var Os=class extends qe{render(t){let r="try"+super.render(t);return this.catch&&(r+=this.catch.render(t)),this.finally&&(r+=this.finally.render(t)),r}optimizeNodes(){var t,r;return super.optimizeNodes(),(t=this.catch)===null||t===void 0||t.optimizeNodes(),(r=this.finally)===null||r===void 0||r.optimizeNodes(),this}optimizeNames(t,r){var s,n;return super.optimizeNames(t,r),(s=this.catch)===null||s===void 0||s.optimizeNames(t,r),(n=this.finally)===null||n===void 0||n.optimizeNames(t,r),this}get names(){let t=super.names;return this.catch&&Je(t,this.catch.names),this.finally&&Je(t,this.finally.names),t}},zt=class extends qe{constructor(t){super(),this.error=t}render(t){return`catch(${this.error})`+super.render(t)}};zt.kind="catch";var Lt=class extends qe{render(t){return"finally"+super.render(t)}};Lt.kind="finally";var Ts=class{constructor(t,r={}){this._values={},this._blockStarts=[],this._constants={},this.opts=W(L({},r),{_n:r.lines?`\n`:""}),this._extScope=t,this._scope=new ge.Scope({parent:t}),this._nodes=[new Ss]}toString(){return this._root.render(this.opts)}name(t){return this._scope.name(t)}scopeName(t){return this._extScope.name(t)}scopeValue(t,r){let s=this._extScope.value(t,r);return(this._values[s.prefix]||(this._values[s.prefix]=new Set)).add(s),s}getScopeValue(t,r){return this._extScope.getValue(t,r)}scopeRefs(t){return this._extScope.scopeRefs(t,this._values)}scopeCode(){return this._extScope.scopeCode(this._values)}_def(t,r,s,n){let o=this._scope.toName(r);return s!==void 0&&n&&(this._constants[o.str]=s),this._leafNode(new gs(t,o,s)),o}const(t,r,s){return this._def(ge.varKinds.const,t,r,s)}let(t,r,s){return this._def(ge.varKinds.let,t,r,s)}var(t,r,s){return this._def(ge.varKinds.var,t,r,s)}assign(t,r,s){return this._leafNode(new vr(t,r,s))}add(t,r){return this._leafNode(new $s(t,T.operators.ADD,r))}code(t){return typeof t=="function"?t():t!==C.nil&&this._leafNode(new ws(t)),this}object(...t){let r=["{"];for(let[s,n]of t)r.length>1&&r.push(","),r.push(s),(s!==n||this.opts.es5)&&(r.push(":"),(0,C.addCodeArg)(r,n));return r.push("}"),new C._Code(r)}if(t,r,s){if(this._blockNode(new He(t)),r&&s)this.code(r).else().code(s).endIf();else if(r)this.code(r).endIf();else if(s)throw new Error(\'CodeGen: "else" body without "then" body\');return this}elseIf(t){return this._elseNode(new He(t))}else(){return this._elseNode(new it)}endIf(){return this._endBlockNode(He,it)}_for(t,r){return this._blockNode(t),r&&this.code(r).endFor(),this}for(t,r){return this._for(new Ps(t),r)}forRange(t,r,s,n,o=this.opts.es5?ge.varKinds.var:ge.varKinds.let){let a=this._scope.toName(t);return this._for(new Ns(o,a,r,s),()=>n(a))}forOf(t,r,s,n=ge.varKinds.const){let o=this._scope.toName(t);if(this.opts.es5){let a=r instanceof C.Name?r:this.var("_arr",r);return this.forRange("_i",0,(0,C._)`${a}.length`,i=>{this.var(o,(0,C._)`${a}[${i}]`),s(o)})}return this._for(new br("of",n,o,r),()=>s(o))}forIn(t,r,s,n=this.opts.es5?ge.varKinds.var:ge.varKinds.const){if(this.opts.ownProperties)return this.forOf(t,(0,C._)`Object.keys(${r})`,s);let o=this._scope.toName(t);return this._for(new br("in",n,o,r),()=>s(o))}endFor(){return this._endBlockNode(Ge)}label(t){return this._leafNode(new vs(t))}break(t){return this._leafNode(new bs(t))}return(t){let r=new Vt;if(this._blockNode(r),this.code(t),r.nodes.length!==1)throw new Error(\'CodeGen: "return" should have one node\');return this._endBlockNode(Vt)}try(t,r,s){if(!r&&!s)throw new Error(\'CodeGen: "try" without "catch" and "finally"\');let n=new Os;if(this._blockNode(n),this.code(t),r){let o=this.name("e");this._currNode=n.catch=new zt(o),r(o)}return s&&(this._currNode=n.finally=new Lt,this.code(s)),this._endBlockNode(zt,Lt)}throw(t){return this._leafNode(new Es(t))}block(t,r){return this._blockStarts.push(this._nodes.length),t&&this.code(t).endBlock(r),this}endBlock(t){let r=this._blockStarts.pop();if(r===void 0)throw new Error("CodeGen: not in self-balancing block");let s=this._nodes.length-r;if(s<0||t!==void 0&&s!==t)throw new Error(`CodeGen: wrong number of nodes: ${s} vs ${t} expected`);return this._nodes.length=r,this}func(t,r=C.nil,s,n){return this._blockNode(new xt(t,r,s)),n&&this.code(n).endFunc(),this}endFunc(){return this._endBlockNode(xt)}optimize(t=1){for(;t-- >0;)this._root.optimizeNodes(),this._root.optimizeNames(this._root.names,this._constants)}_leafNode(t){return this._currNode.nodes.push(t),this}_blockNode(t){this._currNode.nodes.push(t),this._nodes.push(t)}_endBlockNode(t,r){let s=this._currNode;if(s instanceof t||r&&s instanceof r)return this._nodes.pop(),this;throw new Error(`CodeGen: not in block "${r?`${t.kind}/${r.kind}`:t.kind}"`)}_elseNode(t){let r=this._currNode;if(!(r instanceof He))throw new Error(\'CodeGen: "else" without "if"\');return this._currNode=r.else=t,this}get _root(){return this._nodes[0]}get _currNode(){let t=this._nodes;return t[t.length-1]}set _currNode(t){let r=this._nodes;r[r.length-1]=t}};T.CodeGen=Ts;function Je(e,t){for(let r in t)e[r]=(e[r]||0)+(t[r]||0);return e}function Er(e,t){return t instanceof C._CodeOrName?Je(e,t.names):e}function ut(e,t,r){if(e instanceof C.Name)return s(e);if(!n(e))return e;return new C._Code(e._items.reduce((o,a)=>(a instanceof C.Name&&(a=s(a)),a instanceof C._Code?o.push(...a._items):o.push(a),o),[]));function s(o){let a=r[o.str];return a===void 0||t[o.str]!==1?o:(delete t[o.str],a)}function n(o){return o instanceof C._Code&&o._items.some(a=>a instanceof C.Name&&t[a.str]===1&&r[a.str]!==void 0)}}function Zm(e,t){for(let r in t)e[r]=(e[r]||0)-(t[r]||0)}function gu(e){return typeof e=="boolean"||typeof e=="number"||e===null?!e:(0,C._)`!${Is(e)}`}T.not=gu;var Qm=$u(T.operators.AND);function ey(...e){return e.reduce(Qm)}T.and=ey;var ty=$u(T.operators.OR);function ry(...e){return e.reduce(ty)}T.or=ry;function $u(e){return(t,r)=>t===C.nil?r:r===C.nil?t:(0,C._)`${Is(t)} ${e} ${Is(r)}`}function Is(e){return e instanceof C.Name?e:(0,C._)`(${e})`}});var D=d(q=>{"use strict";Object.defineProperty(q,"__esModule",{value:!0});q.checkStrictMode=q.getErrorPath=q.Type=q.useFunc=q.setEvaluated=q.evaluatedPropsToName=q.mergeEvaluated=q.eachItem=q.unescapeJsonPointer=q.escapeJsonPointer=q.escapeFragment=q.unescapeFragment=q.schemaRefOrVal=q.schemaHasRulesButRef=q.schemaHasRules=q.checkUnknownRules=q.alwaysValidSchema=q.toHash=void 0;var U=I(),sy=at();function ny(e){let t={};for(let r of e)t[r]=!0;return t}q.toHash=ny;function oy(e,t){return typeof t=="boolean"?t:Object.keys(t).length===0?!0:(Eu(e,t),!wu(t,e.self.RULES.all))}q.alwaysValidSchema=oy;function Eu(e,t=e.schema){let{opts:r,self:s}=e;if(!r.strictSchema||typeof t=="boolean")return;let n=s.RULES.keywords;for(let o in t)n[o]||Nu(e,`unknown keyword: "${o}"`)}q.checkUnknownRules=Eu;function wu(e,t){if(typeof e=="boolean")return!e;for(let r in e)if(t[r])return!0;return!1}q.schemaHasRules=wu;function ay(e,t){if(typeof e=="boolean")return!e;for(let r in e)if(r!=="$ref"&&t.all[r])return!0;return!1}q.schemaHasRulesButRef=ay;function iy({topSchemaRef:e,schemaPath:t},r,s,n){if(!n){if(typeof r=="number"||typeof r=="boolean")return r;if(typeof r=="string")return(0,U._)`${r}`}return(0,U._)`${e}${t}${(0,U.getProperty)(s)}`}q.schemaRefOrVal=iy;function uy(e){return Su(decodeURIComponent(e))}q.unescapeFragment=uy;function cy(e){return encodeURIComponent(js(e))}q.escapeFragment=cy;function js(e){return typeof e=="number"?`${e}`:e.replace(/~/g,"~0").replace(/\\//g,"~1")}q.escapeJsonPointer=js;function Su(e){return e.replace(/~1/g,"/").replace(/~0/g,"~")}q.unescapeJsonPointer=Su;function ly(e,t){if(Array.isArray(e))for(let r of e)t(r);else t(e)}q.eachItem=ly;function vu({mergeNames:e,mergeToName:t,mergeValues:r,resultToName:s}){return(n,o,a,i)=>{let u=a===void 0?o:a instanceof U.Name?(o instanceof U.Name?e(n,o,a):t(n,o,a),a):o instanceof U.Name?(t(n,a,o),o):r(o,a);return i===U.Name&&!(u instanceof U.Name)?s(n,u):u}}q.mergeEvaluated={props:vu({mergeNames:(e,t,r)=>e.if((0,U._)`${r} !== true && ${t} !== undefined`,()=>{e.if((0,U._)`${t} === true`,()=>e.assign(r,!0),()=>e.assign(r,(0,U._)`${r} || {}`).code((0,U._)`Object.assign(${r}, ${t})`))}),mergeToName:(e,t,r)=>e.if((0,U._)`${r} !== true`,()=>{t===!0?e.assign(r,!0):(e.assign(r,(0,U._)`${r} || {}`),ks(e,r,t))}),mergeValues:(e,t)=>e===!0?!0:L(L({},e),t),resultToName:Pu}),items:vu({mergeNames:(e,t,r)=>e.if((0,U._)`${r} !== true && ${t} !== undefined`,()=>e.assign(r,(0,U._)`${t} === true ? true : ${r} > ${t} ? ${r} : ${t}`)),mergeToName:(e,t,r)=>e.if((0,U._)`${r} !== true`,()=>e.assign(r,t===!0?!0:(0,U._)`${r} > ${t} ? ${r} : ${t}`)),mergeValues:(e,t)=>e===!0?!0:Math.max(e,t),resultToName:(e,t)=>e.var("items",t)})};function Pu(e,t){if(t===!0)return e.var("props",!0);let r=e.var("props",(0,U._)`{}`);return t!==void 0&&ks(e,r,t),r}q.evaluatedPropsToName=Pu;function ks(e,t,r){Object.keys(r).forEach(s=>e.assign((0,U._)`${t}${(0,U.getProperty)(s)}`,!0))}q.setEvaluated=ks;var bu={};function dy(e,t){return e.scopeValue("func",{ref:t,code:bu[t.code]||(bu[t.code]=new sy._Code(t.code))})}q.useFunc=dy;var qs;(function(e){e[e.Num=0]="Num",e[e.Str=1]="Str"})(qs||(q.Type=qs={}));function fy(e,t,r){if(e instanceof U.Name){let s=t===qs.Num;return r?s?(0,U._)`"[" + ${e} + "]"`:(0,U._)`"[\'" + ${e} + "\']"`:s?(0,U._)`"/" + ${e}`:(0,U._)`"/" + ${e}.replace(/~/g, "~0").replace(/\\\\//g, "~1")`}return r?(0,U.getProperty)(e).toString():"/"+js(e)}q.getErrorPath=fy;function Nu(e,t,r=e.opts.strictSchema){if(r){if(t=`strict mode: ${t}`,r===!0)throw new Error(t);e.self.logger.warn(t)}}q.checkStrictMode=Nu});var we=d(Cs=>{"use strict";Object.defineProperty(Cs,"__esModule",{value:!0});var Z=I(),py={data:new Z.Name("data"),valCxt:new Z.Name("valCxt"),instancePath:new Z.Name("instancePath"),parentData:new Z.Name("parentData"),parentDataProperty:new Z.Name("parentDataProperty"),rootData:new Z.Name("rootData"),dynamicAnchors:new Z.Name("dynamicAnchors"),vErrors:new Z.Name("vErrors"),errors:new Z.Name("errors"),this:new Z.Name("this"),self:new Z.Name("self"),scope:new Z.Name("scope"),json:new Z.Name("json"),jsonPos:new Z.Name("jsonPos"),jsonLen:new Z.Name("jsonLen"),jsonPart:new Z.Name("jsonPart")};Cs.default=py});var ct=d(Q=>{"use strict";Object.defineProperty(Q,"__esModule",{value:!0});Q.extendErrors=Q.resetErrorsCount=Q.reportExtraError=Q.reportError=Q.keyword$DataError=Q.keywordError=void 0;var R=I(),Sr=D(),re=we();Q.keywordError={message:({keyword:e})=>(0,R.str)`must pass "${e}" keyword validation`};Q.keyword$DataError={message:({keyword:e,schemaType:t})=>t?(0,R.str)`"${e}" keyword must be ${t} ($data)`:(0,R.str)`"${e}" keyword is invalid ($data)`};function hy(e,t=Q.keywordError,r,s){let{it:n}=e,{gen:o,compositeRule:a,allErrors:i}=n,u=Iu(e,t,r);(s!=null?s:a||i)?Ou(o,u):Tu(n,(0,R._)`[${u}]`)}Q.reportError=hy;function my(e,t=Q.keywordError,r){let{it:s}=e,{gen:n,compositeRule:o,allErrors:a}=s,i=Iu(e,t,r);Ou(n,i),o||a||Tu(s,re.default.vErrors)}Q.reportExtraError=my;function yy(e,t){e.assign(re.default.errors,t),e.if((0,R._)`${re.default.vErrors} !== null`,()=>e.if(t,()=>e.assign((0,R._)`${re.default.vErrors}.length`,t),()=>e.assign(re.default.vErrors,null)))}Q.resetErrorsCount=yy;function _y({gen:e,keyword:t,schemaValue:r,data:s,errsCount:n,it:o}){if(n===void 0)throw new Error("ajv implementation error");let a=e.name("err");e.forRange("i",n,re.default.errors,i=>{e.const(a,(0,R._)`${re.default.vErrors}[${i}]`),e.if((0,R._)`${a}.instancePath === undefined`,()=>e.assign((0,R._)`${a}.instancePath`,(0,R.strConcat)(re.default.instancePath,o.errorPath))),e.assign((0,R._)`${a}.schemaPath`,(0,R.str)`${o.errSchemaPath}/${t}`),o.opts.verbose&&(e.assign((0,R._)`${a}.schema`,r),e.assign((0,R._)`${a}.data`,s))})}Q.extendErrors=_y;function Ou(e,t){let r=e.const("err",t);e.if((0,R._)`${re.default.vErrors} === null`,()=>e.assign(re.default.vErrors,(0,R._)`[${r}]`),(0,R._)`${re.default.vErrors}.push(${r})`),e.code((0,R._)`${re.default.errors}++`)}function Tu(e,t){let{gen:r,validateName:s,schemaEnv:n}=e;n.$async?r.throw((0,R._)`new ${e.ValidationError}(${t})`):(r.assign((0,R._)`${s}.errors`,t),r.return(!1))}var We={keyword:new R.Name("keyword"),schemaPath:new R.Name("schemaPath"),params:new R.Name("params"),propertyName:new R.Name("propertyName"),message:new R.Name("message"),schema:new R.Name("schema"),parentSchema:new R.Name("parentSchema")};function Iu(e,t,r){let{createErrors:s}=e.it;return s===!1?(0,R._)`{}`:gy(e,t,r)}function gy(e,t,r={}){let{gen:s,it:n}=e,o=[$y(n,r),vy(e,r)];return by(e,t,o),s.object(...o)}function $y({errorPath:e},{instancePath:t}){let r=t?(0,R.str)`${e}${(0,Sr.getErrorPath)(t,Sr.Type.Str)}`:e;return[re.default.instancePath,(0,R.strConcat)(re.default.instancePath,r)]}function vy({keyword:e,it:{errSchemaPath:t}},{schemaPath:r,parentSchema:s}){let n=s?t:(0,R.str)`${t}/${e}`;return r&&(n=(0,R.str)`${n}${(0,Sr.getErrorPath)(r,Sr.Type.Str)}`),[We.schemaPath,n]}function by(e,{params:t,message:r},s){let{keyword:n,data:o,schemaValue:a,it:i}=e,{opts:u,propertyName:c,topSchemaRef:l,schemaPath:f}=i;s.push([We.keyword,n],[We.params,typeof t=="function"?t(e):t||(0,R._)`{}`]),u.messages&&s.push([We.message,typeof r=="function"?r(e):r]),u.verbose&&s.push([We.schema,a],[We.parentSchema,(0,R._)`${l}${f}`],[re.default.data,o]),c&&s.push([We.propertyName,c])}});var ju=d(lt=>{"use strict";Object.defineProperty(lt,"__esModule",{value:!0});lt.boolOrEmptySchema=lt.topBoolOrEmptySchema=void 0;var Ey=ct(),wy=I(),Sy=we(),Py={message:"boolean schema is false"};function Ny(e){let{gen:t,schema:r,validateName:s}=e;r===!1?qu(e,!1):typeof r=="object"&&r.$async===!0?t.return(Sy.default.data):(t.assign((0,wy._)`${s}.errors`,null),t.return(!0))}lt.topBoolOrEmptySchema=Ny;function Oy(e,t){let{gen:r,schema:s}=e;s===!1?(r.var(t,!1),qu(e)):r.var(t,!0)}lt.boolOrEmptySchema=Oy;function qu(e,t){let{gen:r,data:s}=e,n={gen:r,keyword:"false schema",data:s,schema:!1,schemaCode:!1,schemaValue:!1,params:{},it:e};(0,Ey.reportError)(n,Py,void 0,t)}});var Rs=d(dt=>{"use strict";Object.defineProperty(dt,"__esModule",{value:!0});dt.getRules=dt.isJSONType=void 0;var Ty=["string","number","integer","boolean","null","object","array"],Iy=new Set(Ty);function qy(e){return typeof e=="string"&&Iy.has(e)}dt.isJSONType=qy;function jy(){let e={number:{type:"number",rules:[]},string:{type:"string",rules:[]},array:{type:"array",rules:[]},object:{type:"object",rules:[]}};return{types:W(L({},e),{integer:!0,boolean:!0,null:!0}),rules:[{rules:[]},e.number,e.string,e.array,e.object],post:{rules:[]},all:{},keywords:{}}}dt.getRules=jy});var As=d(Re=>{"use strict";Object.defineProperty(Re,"__esModule",{value:!0});Re.shouldUseRule=Re.shouldUseGroup=Re.schemaHasRulesForType=void 0;function ky({schema:e,self:t},r){let s=t.RULES.types[r];return s&&s!==!0&&ku(e,s)}Re.schemaHasRulesForType=ky;function ku(e,t){return t.rules.some(r=>Cu(e,r))}Re.shouldUseGroup=ku;function Cu(e,t){var r;return e[t.keyword]!==void 0||((r=t.definition.implements)===null||r===void 0?void 0:r.some(s=>e[s]!==void 0))}Re.shouldUseRule=Cu});var Ut=d(ee=>{"use strict";Object.defineProperty(ee,"__esModule",{value:!0});ee.reportTypeError=ee.checkDataTypes=ee.checkDataType=ee.coerceAndCheckDataType=ee.getJSONTypes=ee.getSchemaTypes=ee.DataType=void 0;var Cy=Rs(),Ry=As(),Ay=ct(),P=I(),Ru=D(),ft;(function(e){e[e.Correct=0]="Correct",e[e.Wrong=1]="Wrong"})(ft||(ee.DataType=ft={}));function Dy(e){let t=Au(e.type);if(t.includes("null")){if(e.nullable===!1)throw new Error("type: null contradicts nullable: false")}else{if(!t.length&&e.nullable!==void 0)throw new Error(\'"nullable" cannot be used without "type"\');e.nullable===!0&&t.push("null")}return t}ee.getSchemaTypes=Dy;function Au(e){let t=Array.isArray(e)?e:e?[e]:[];if(t.every(Cy.isJSONType))return t;throw new Error("type must be JSONType or JSONType[]: "+t.join(","))}ee.getJSONTypes=Au;function My(e,t){let{gen:r,data:s,opts:n}=e,o=xy(t,n.coerceTypes),a=t.length>0&&!(o.length===0&&t.length===1&&(0,Ry.schemaHasRulesForType)(e,t[0]));if(a){let i=Ms(t,s,n.strictNumbers,ft.Wrong);r.if(i,()=>{o.length?Vy(e,t,o):xs(e)})}return a}ee.coerceAndCheckDataType=My;var Du=new Set(["string","number","integer","boolean","null"]);function xy(e,t){return t?e.filter(r=>Du.has(r)||t==="array"&&r==="array"):[]}function Vy(e,t,r){let{gen:s,data:n,opts:o}=e,a=s.let("dataType",(0,P._)`typeof ${n}`),i=s.let("coerced",(0,P._)`undefined`);o.coerceTypes==="array"&&s.if((0,P._)`${a} == \'object\' && Array.isArray(${n}) && ${n}.length == 1`,()=>s.assign(n,(0,P._)`${n}[0]`).assign(a,(0,P._)`typeof ${n}`).if(Ms(t,n,o.strictNumbers),()=>s.assign(i,n))),s.if((0,P._)`${i} !== undefined`);for(let c of r)(Du.has(c)||c==="array"&&o.coerceTypes==="array")&&u(c);s.else(),xs(e),s.endIf(),s.if((0,P._)`${i} !== undefined`,()=>{s.assign(n,i),zy(e,i)});function u(c){switch(c){case"string":s.elseIf((0,P._)`${a} == "number" || ${a} == "boolean"`).assign(i,(0,P._)`"" + ${n}`).elseIf((0,P._)`${n} === null`).assign(i,(0,P._)`""`);return;case"number":s.elseIf((0,P._)`${a} == "boolean" || ${n} === null\n              || (${a} == "string" && ${n} && ${n} == +${n})`).assign(i,(0,P._)`+${n}`);return;case"integer":s.elseIf((0,P._)`${a} === "boolean" || ${n} === null\n              || (${a} === "string" && ${n} && ${n} == +${n} && !(${n} % 1))`).assign(i,(0,P._)`+${n}`);return;case"boolean":s.elseIf((0,P._)`${n} === "false" || ${n} === 0 || ${n} === null`).assign(i,!1).elseIf((0,P._)`${n} === "true" || ${n} === 1`).assign(i,!0);return;case"null":s.elseIf((0,P._)`${n} === "" || ${n} === 0 || ${n} === false`),s.assign(i,null);return;case"array":s.elseIf((0,P._)`${a} === "string" || ${a} === "number"\n              || ${a} === "boolean" || ${n} === null`).assign(i,(0,P._)`[${n}]`)}}}function zy({gen:e,parentData:t,parentDataProperty:r},s){e.if((0,P._)`${t} !== undefined`,()=>e.assign((0,P._)`${t}[${r}]`,s))}function Ds(e,t,r,s=ft.Correct){let n=s===ft.Correct?P.operators.EQ:P.operators.NEQ,o;switch(e){case"null":return(0,P._)`${t} ${n} null`;case"array":o=(0,P._)`Array.isArray(${t})`;break;case"object":o=(0,P._)`${t} && typeof ${t} == "object" && !Array.isArray(${t})`;break;case"integer":o=a((0,P._)`!(${t} % 1) && !isNaN(${t})`);break;case"number":o=a();break;default:return(0,P._)`typeof ${t} ${n} ${e}`}return s===ft.Correct?o:(0,P.not)(o);function a(i=P.nil){return(0,P.and)((0,P._)`typeof ${t} == "number"`,i,r?(0,P._)`isFinite(${t})`:P.nil)}}ee.checkDataType=Ds;function Ms(e,t,r,s){if(e.length===1)return Ds(e[0],t,r,s);let n,o=(0,Ru.toHash)(e);if(o.array&&o.object){let a=(0,P._)`typeof ${t} != "object"`;n=o.null?a:(0,P._)`!${t} || ${a}`,delete o.null,delete o.array,delete o.object}else n=P.nil;o.number&&delete o.integer;for(let a in o)n=(0,P.and)(n,Ds(a,t,r,s));return n}ee.checkDataTypes=Ms;var Ly={message:({schema:e})=>`must be ${e}`,params:({schema:e,schemaValue:t})=>typeof e=="string"?(0,P._)`{type: ${e}}`:(0,P._)`{type: ${t}}`};function xs(e){let t=Uy(e);(0,Ay.reportError)(t,Ly)}ee.reportTypeError=xs;function Uy(e){let{gen:t,data:r,schema:s}=e,n=(0,Ru.schemaRefOrVal)(e,s,"type");return{gen:t,keyword:"type",data:r,schema:s.type,schemaCode:n,schemaValue:n,parentSchema:s,params:{},it:e}}});var xu=d(Pr=>{"use strict";Object.defineProperty(Pr,"__esModule",{value:!0});Pr.assignDefaults=void 0;var pt=I(),Fy=D();function Ky(e,t){let{properties:r,items:s}=e.schema;if(t==="object"&&r)for(let n in r)Mu(e,n,r[n].default);else t==="array"&&Array.isArray(s)&&s.forEach((n,o)=>Mu(e,o,n.default))}Pr.assignDefaults=Ky;function Mu(e,t,r){let{gen:s,compositeRule:n,data:o,opts:a}=e;if(r===void 0)return;let i=(0,pt._)`${o}${(0,pt.getProperty)(t)}`;if(n){(0,Fy.checkStrictMode)(e,`default is ignored for: ${i}`);return}let u=(0,pt._)`${i} === undefined`;a.useDefaults==="empty"&&(u=(0,pt._)`${u} || ${i} === null || ${i} === ""`),s.if(u,(0,pt._)`${i} = ${(0,pt.stringify)(r)}`)}});var me=d(z=>{"use strict";Object.defineProperty(z,"__esModule",{value:!0});z.validateUnion=z.validateArray=z.usePattern=z.callValidateCode=z.schemaProperties=z.allSchemaProperties=z.noPropertyInData=z.propertyInData=z.isOwnProperty=z.hasPropFunc=z.reportMissingProp=z.checkMissingProp=z.checkReportMissingProp=void 0;var F=I(),Vs=D(),Ae=we(),Hy=D();function Gy(e,t){let{gen:r,data:s,it:n}=e;r.if(Ls(r,s,t,n.opts.ownProperties),()=>{e.setParams({missingProperty:(0,F._)`${t}`},!0),e.error()})}z.checkReportMissingProp=Gy;function Jy({gen:e,data:t,it:{opts:r}},s,n){return(0,F.or)(...s.map(o=>(0,F.and)(Ls(e,t,o,r.ownProperties),(0,F._)`${n} = ${o}`)))}z.checkMissingProp=Jy;function Wy(e,t){e.setParams({missingProperty:t},!0),e.error()}z.reportMissingProp=Wy;function Vu(e){return e.scopeValue("func",{ref:Object.prototype.hasOwnProperty,code:(0,F._)`Object.prototype.hasOwnProperty`})}z.hasPropFunc=Vu;function zs(e,t,r){return(0,F._)`${Vu(e)}.call(${t}, ${r})`}z.isOwnProperty=zs;function Xy(e,t,r,s){let n=(0,F._)`${t}${(0,F.getProperty)(r)} !== undefined`;return s?(0,F._)`${n} && ${zs(e,t,r)}`:n}z.propertyInData=Xy;function Ls(e,t,r,s){let n=(0,F._)`${t}${(0,F.getProperty)(r)} === undefined`;return s?(0,F.or)(n,(0,F.not)(zs(e,t,r))):n}z.noPropertyInData=Ls;function zu(e){return e?Object.keys(e).filter(t=>t!=="__proto__"):[]}z.allSchemaProperties=zu;function By(e,t){return zu(t).filter(r=>!(0,Vs.alwaysValidSchema)(e,t[r]))}z.schemaProperties=By;function Yy({schemaCode:e,data:t,it:{gen:r,topSchemaRef:s,schemaPath:n,errorPath:o},it:a},i,u,c){let l=c?(0,F._)`${e}, ${t}, ${s}${n}`:t,f=[[Ae.default.instancePath,(0,F.strConcat)(Ae.default.instancePath,o)],[Ae.default.parentData,a.parentData],[Ae.default.parentDataProperty,a.parentDataProperty],[Ae.default.rootData,Ae.default.rootData]];a.opts.dynamicRef&&f.push([Ae.default.dynamicAnchors,Ae.default.dynamicAnchors]);let _=(0,F._)`${l}, ${r.object(...f)}`;return u!==F.nil?(0,F._)`${i}.call(${u}, ${_})`:(0,F._)`${i}(${_})`}z.callValidateCode=Yy;var Zy=(0,F._)`new RegExp`;function Qy({gen:e,it:{opts:t}},r){let s=t.unicodeRegExp?"u":"",{regExp:n}=t.code,o=n(r,s);return e.scopeValue("pattern",{key:o.toString(),ref:o,code:(0,F._)`${n.code==="new RegExp"?Zy:(0,Hy.useFunc)(e,n)}(${r}, ${s})`})}z.usePattern=Qy;function e_(e){let{gen:t,data:r,keyword:s,it:n}=e,o=t.name("valid");if(n.allErrors){let i=t.let("valid",!0);return a(()=>t.assign(i,!1)),i}return t.var(o,!0),a(()=>t.break()),o;function a(i){let u=t.const("len",(0,F._)`${r}.length`);t.forRange("i",0,u,c=>{e.subschema({keyword:s,dataProp:c,dataPropType:Vs.Type.Num},o),t.if((0,F.not)(o),i)})}}z.validateArray=e_;function t_(e){let{gen:t,schema:r,keyword:s,it:n}=e;if(!Array.isArray(r))throw new Error("ajv implementation error");if(r.some(u=>(0,Vs.alwaysValidSchema)(n,u))&&!n.opts.unevaluated)return;let a=t.let("valid",!1),i=t.name("_valid");t.block(()=>r.forEach((u,c)=>{let l=e.subschema({keyword:s,schemaProp:c,compositeRule:!0},i);t.assign(a,(0,F._)`${a} || ${i}`),e.mergeValidEvaluated(l,i)||t.if((0,F.not)(a))})),e.result(a,()=>e.reset(),()=>e.error(!0))}z.validateUnion=t_});var Fu=d(Se=>{"use strict";Object.defineProperty(Se,"__esModule",{value:!0});Se.validateKeywordUsage=Se.validSchemaType=Se.funcKeywordCode=Se.macroKeywordCode=void 0;var se=I(),Xe=we(),r_=me(),s_=ct();function n_(e,t){let{gen:r,keyword:s,schema:n,parentSchema:o,it:a}=e,i=t.macro.call(a.self,n,o,a),u=Uu(r,s,i);a.opts.validateSchema!==!1&&a.self.validateSchema(i,!0);let c=r.name("valid");e.subschema({schema:i,schemaPath:se.nil,errSchemaPath:`${a.errSchemaPath}/${s}`,topSchemaRef:u,compositeRule:!0},c),e.pass(c,()=>e.error(!0))}Se.macroKeywordCode=n_;function o_(e,t){var r;let{gen:s,keyword:n,schema:o,parentSchema:a,$data:i,it:u}=e;i_(u,t);let c=!i&&t.compile?t.compile.call(u.self,o,a,u):t.validate,l=Uu(s,n,c),f=s.let("valid");e.block$data(f,_),e.ok((r=t.valid)!==null&&r!==void 0?r:f);function _(){if(t.errors===!1)p(),t.modifying&&Lu(e),y(()=>e.error());else{let $=t.async?m():h();t.modifying&&Lu(e),y(()=>a_(e,$))}}function m(){let $=s.let("ruleErrs",null);return s.try(()=>p((0,se._)`await `),j=>s.assign(f,!1).if((0,se._)`${j} instanceof ${u.ValidationError}`,()=>s.assign($,(0,se._)`${j}.errors`),()=>s.throw(j))),$}function h(){let $=(0,se._)`${l}.errors`;return s.assign($,null),p(se.nil),$}function p($=t.async?(0,se._)`await `:se.nil){let j=u.opts.passContext?Xe.default.this:Xe.default.self,N=!("compile"in t&&!i||t.schema===!1);s.assign(f,(0,se._)`${$}${(0,r_.callValidateCode)(e,l,j,N)}`,t.modifying)}function y($){var j;s.if((0,se.not)((j=t.valid)!==null&&j!==void 0?j:f),$)}}Se.funcKeywordCode=o_;function Lu(e){let{gen:t,data:r,it:s}=e;t.if(s.parentData,()=>t.assign(r,(0,se._)`${s.parentData}[${s.parentDataProperty}]`))}function a_(e,t){let{gen:r}=e;r.if((0,se._)`Array.isArray(${t})`,()=>{r.assign(Xe.default.vErrors,(0,se._)`${Xe.default.vErrors} === null ? ${t} : ${Xe.default.vErrors}.concat(${t})`).assign(Xe.default.errors,(0,se._)`${Xe.default.vErrors}.length`),(0,s_.extendErrors)(e)},()=>e.error())}function i_({schemaEnv:e},t){if(t.async&&!e.$async)throw new Error("async keyword in sync schema")}function Uu(e,t,r){if(r===void 0)throw new Error(`keyword "${t}" failed to compile`);return e.scopeValue("keyword",typeof r=="function"?{ref:r}:{ref:r,code:(0,se.stringify)(r)})}function u_(e,t,r=!1){return!t.length||t.some(s=>s==="array"?Array.isArray(e):s==="object"?e&&typeof e=="object"&&!Array.isArray(e):typeof e==s||r&&typeof e=="undefined")}Se.validSchemaType=u_;function c_({schema:e,opts:t,self:r,errSchemaPath:s},n,o){if(Array.isArray(n.keyword)?!n.keyword.includes(o):n.keyword!==o)throw new Error("ajv implementation error");let a=n.dependencies;if(a!=null&&a.some(i=>!Object.prototype.hasOwnProperty.call(e,i)))throw new Error(`parent schema must have dependencies of ${o}: ${a.join(",")}`);if(n.validateSchema&&!n.validateSchema(e[o])){let u=`keyword "${o}" value is invalid at path "${s}": `+r.errorsText(n.validateSchema.errors);if(t.validateSchema==="log")r.logger.error(u);else throw new Error(u)}}Se.validateKeywordUsage=c_});var Hu=d(De=>{"use strict";Object.defineProperty(De,"__esModule",{value:!0});De.extendSubschemaMode=De.extendSubschemaData=De.getSubschema=void 0;var Pe=I(),Ku=D();function l_(e,{keyword:t,schemaProp:r,schema:s,schemaPath:n,errSchemaPath:o,topSchemaRef:a}){if(t!==void 0&&s!==void 0)throw new Error(\'both "keyword" and "schema" passed, only one allowed\');if(t!==void 0){let i=e.schema[t];return r===void 0?{schema:i,schemaPath:(0,Pe._)`${e.schemaPath}${(0,Pe.getProperty)(t)}`,errSchemaPath:`${e.errSchemaPath}/${t}`}:{schema:i[r],schemaPath:(0,Pe._)`${e.schemaPath}${(0,Pe.getProperty)(t)}${(0,Pe.getProperty)(r)}`,errSchemaPath:`${e.errSchemaPath}/${t}/${(0,Ku.escapeFragment)(r)}`}}if(s!==void 0){if(n===void 0||o===void 0||a===void 0)throw new Error(\'"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"\');return{schema:s,schemaPath:n,topSchemaRef:a,errSchemaPath:o}}throw new Error(\'either "keyword" or "schema" must be passed\')}De.getSubschema=l_;function d_(e,t,{dataProp:r,dataPropType:s,data:n,dataTypes:o,propertyName:a}){if(n!==void 0&&r!==void 0)throw new Error(\'both "data" and "dataProp" passed, only one allowed\');let{gen:i}=t;if(r!==void 0){let{errorPath:c,dataPathArr:l,opts:f}=t,_=i.let("data",(0,Pe._)`${t.data}${(0,Pe.getProperty)(r)}`,!0);u(_),e.errorPath=(0,Pe.str)`${c}${(0,Ku.getErrorPath)(r,s,f.jsPropertySyntax)}`,e.parentDataProperty=(0,Pe._)`${r}`,e.dataPathArr=[...l,e.parentDataProperty]}if(n!==void 0){let c=n instanceof Pe.Name?n:i.let("data",n,!0);u(c),a!==void 0&&(e.propertyName=a)}o&&(e.dataTypes=o);function u(c){e.data=c,e.dataLevel=t.dataLevel+1,e.dataTypes=[],t.definedProperties=new Set,e.parentData=t.data,e.dataNames=[...t.dataNames,c]}}De.extendSubschemaData=d_;function f_(e,{jtdDiscriminator:t,jtdMetadata:r,compositeRule:s,createErrors:n,allErrors:o}){s!==void 0&&(e.compositeRule=s),n!==void 0&&(e.createErrors=n),o!==void 0&&(e.allErrors=o),e.jtdDiscriminator=t,e.jtdMetadata=r}De.extendSubschemaMode=f_});var Us=d((EE,Gu)=>{"use strict";Gu.exports=function e(t,r){if(t===r)return!0;if(t&&r&&typeof t=="object"&&typeof r=="object"){if(t.constructor!==r.constructor)return!1;var s,n,o;if(Array.isArray(t)){if(s=t.length,s!=r.length)return!1;for(n=s;n--!==0;)if(!e(t[n],r[n]))return!1;return!0}if(t.constructor===RegExp)return t.source===r.source&&t.flags===r.flags;if(t.valueOf!==Object.prototype.valueOf)return t.valueOf()===r.valueOf();if(t.toString!==Object.prototype.toString)return t.toString()===r.toString();if(o=Object.keys(t),s=o.length,s!==Object.keys(r).length)return!1;for(n=s;n--!==0;)if(!Object.prototype.hasOwnProperty.call(r,o[n]))return!1;for(n=s;n--!==0;){var a=o[n];if(!e(t[a],r[a]))return!1}return!0}return t!==t&&r!==r}});var Wu=d((wE,Ju)=>{"use strict";var Me=Ju.exports=function(e,t,r){typeof t=="function"&&(r=t,t={}),r=t.cb||r;var s=typeof r=="function"?r:r.pre||function(){},n=r.post||function(){};Nr(t,s,n,e,"",e)};Me.keywords={additionalItems:!0,items:!0,contains:!0,additionalProperties:!0,propertyNames:!0,not:!0,if:!0,then:!0,else:!0};Me.arrayKeywords={items:!0,allOf:!0,anyOf:!0,oneOf:!0};Me.propsKeywords={$defs:!0,definitions:!0,properties:!0,patternProperties:!0,dependencies:!0};Me.skipKeywords={default:!0,enum:!0,const:!0,required:!0,maximum:!0,minimum:!0,exclusiveMaximum:!0,exclusiveMinimum:!0,multipleOf:!0,maxLength:!0,minLength:!0,pattern:!0,format:!0,maxItems:!0,minItems:!0,uniqueItems:!0,maxProperties:!0,minProperties:!0};function Nr(e,t,r,s,n,o,a,i,u,c){if(s&&typeof s=="object"&&!Array.isArray(s)){t(s,n,o,a,i,u,c);for(var l in s){var f=s[l];if(Array.isArray(f)){if(l in Me.arrayKeywords)for(var _=0;_<f.length;_++)Nr(e,t,r,f[_],n+"/"+l+"/"+_,o,n,l,s,_)}else if(l in Me.propsKeywords){if(f&&typeof f=="object")for(var m in f)Nr(e,t,r,f[m],n+"/"+l+"/"+p_(m),o,n,l,s,m)}else(l in Me.keywords||e.allKeys&&!(l in Me.skipKeywords))&&Nr(e,t,r,f,n+"/"+l,o,n,l,s)}r(s,n,o,a,i,u,c)}}function p_(e){return e.replace(/~/g,"~0").replace(/\\//g,"~1")}});var Ft=d(ie=>{"use strict";Object.defineProperty(ie,"__esModule",{value:!0});ie.getSchemaRefs=ie.resolveUrl=ie.normalizeId=ie._getFullPath=ie.getFullPath=ie.inlineRef=void 0;var h_=D(),m_=Us(),y_=Wu(),__=new Set(["type","format","pattern","maxLength","minLength","maxProperties","minProperties","maxItems","minItems","maximum","minimum","uniqueItems","multipleOf","required","enum","const"]);function g_(e,t=!0){return typeof e=="boolean"?!0:t===!0?!Fs(e):t?Xu(e)<=t:!1}ie.inlineRef=g_;var $_=new Set(["$ref","$recursiveRef","$recursiveAnchor","$dynamicRef","$dynamicAnchor"]);function Fs(e){for(let t in e){if($_.has(t))return!0;let r=e[t];if(Array.isArray(r)&&r.some(Fs)||typeof r=="object"&&Fs(r))return!0}return!1}function Xu(e){let t=0;for(let r in e){if(r==="$ref")return 1/0;if(t++,!__.has(r)&&(typeof e[r]=="object"&&(0,h_.eachItem)(e[r],s=>t+=Xu(s)),t===1/0))return 1/0}return t}function Bu(e,t="",r){r!==!1&&(t=ht(t));let s=e.parse(t);return Yu(e,s)}ie.getFullPath=Bu;function Yu(e,t){return e.serialize(t).split("#")[0]+"#"}ie._getFullPath=Yu;var v_=/#\\/?$/;function ht(e){return e?e.replace(v_,""):""}ie.normalizeId=ht;function b_(e,t,r){return r=ht(r),e.resolve(t,r)}ie.resolveUrl=b_;var E_=/^[a-z_][-a-z0-9._]*$/i;function w_(e,t){if(typeof e=="boolean")return{};let{schemaId:r,uriResolver:s}=this.opts,n=ht(e[r]||t),o={"":n},a=Bu(s,n,!1),i={},u=new Set;return y_(e,{allKeys:!0},(f,_,m,h)=>{if(h===void 0)return;let p=a+_,y=o[h];typeof f[r]=="string"&&(y=$.call(this,f[r])),j.call(this,f.$anchor),j.call(this,f.$dynamicAnchor),o[_]=y;function $(N){let V=this.opts.uriResolver.resolve;if(N=ht(y?V(y,N):N),u.has(N))throw l(N);u.add(N);let S=this.refs[N];return typeof S=="string"&&(S=this.refs[S]),typeof S=="object"?c(f,S.schema,N):N!==ht(p)&&(N[0]==="#"?(c(f,i[N],N),i[N]=f):this.refs[N]=p),N}function j(N){if(typeof N=="string"){if(!E_.test(N))throw new Error(`invalid anchor "${N}"`);$.call(this,`#${N}`)}}}),i;function c(f,_,m){if(_!==void 0&&!m_(f,_))throw l(m)}function l(f){return new Error(`reference "${f}" resolves to more than one schema`)}}ie.getSchemaRefs=w_});var mt=d(xe=>{"use strict";Object.defineProperty(xe,"__esModule",{value:!0});xe.getData=xe.KeywordCxt=xe.validateFunctionCode=void 0;var rc=ju(),Zu=Ut(),Hs=As(),Or=Ut(),S_=xu(),Ht=Fu(),Ks=Hu(),b=I(),w=we(),P_=Ft(),je=D(),Kt=ct();function N_(e){if(oc(e)&&(ac(e),nc(e))){I_(e);return}sc(e,()=>(0,rc.topBoolOrEmptySchema)(e))}xe.validateFunctionCode=N_;function sc({gen:e,validateName:t,schema:r,schemaEnv:s,opts:n},o){n.code.es5?e.func(t,(0,b._)`${w.default.data}, ${w.default.valCxt}`,s.$async,()=>{e.code((0,b._)`"use strict"; ${Qu(r,n)}`),T_(e,n),e.code(o)}):e.func(t,(0,b._)`${w.default.data}, ${O_(n)}`,s.$async,()=>e.code(Qu(r,n)).code(o))}function O_(e){return(0,b._)`{${w.default.instancePath}="", ${w.default.parentData}, ${w.default.parentDataProperty}, ${w.default.rootData}=${w.default.data}${e.dynamicRef?(0,b._)`, ${w.default.dynamicAnchors}={}`:b.nil}}={}`}function T_(e,t){e.if(w.default.valCxt,()=>{e.var(w.default.instancePath,(0,b._)`${w.default.valCxt}.${w.default.instancePath}`),e.var(w.default.parentData,(0,b._)`${w.default.valCxt}.${w.default.parentData}`),e.var(w.default.parentDataProperty,(0,b._)`${w.default.valCxt}.${w.default.parentDataProperty}`),e.var(w.default.rootData,(0,b._)`${w.default.valCxt}.${w.default.rootData}`),t.dynamicRef&&e.var(w.default.dynamicAnchors,(0,b._)`${w.default.valCxt}.${w.default.dynamicAnchors}`)},()=>{e.var(w.default.instancePath,(0,b._)`""`),e.var(w.default.parentData,(0,b._)`undefined`),e.var(w.default.parentDataProperty,(0,b._)`undefined`),e.var(w.default.rootData,w.default.data),t.dynamicRef&&e.var(w.default.dynamicAnchors,(0,b._)`{}`)})}function I_(e){let{schema:t,opts:r,gen:s}=e;sc(e,()=>{r.$comment&&t.$comment&&uc(e),R_(e),s.let(w.default.vErrors,null),s.let(w.default.errors,0),r.unevaluated&&q_(e),ic(e),M_(e)})}function q_(e){let{gen:t,validateName:r}=e;e.evaluated=t.const("evaluated",(0,b._)`${r}.evaluated`),t.if((0,b._)`${e.evaluated}.dynamicProps`,()=>t.assign((0,b._)`${e.evaluated}.props`,(0,b._)`undefined`)),t.if((0,b._)`${e.evaluated}.dynamicItems`,()=>t.assign((0,b._)`${e.evaluated}.items`,(0,b._)`undefined`))}function Qu(e,t){let r=typeof e=="object"&&e[t.schemaId];return r&&(t.code.source||t.code.process)?(0,b._)`/*# sourceURL=${r} */`:b.nil}function j_(e,t){if(oc(e)&&(ac(e),nc(e))){k_(e,t);return}(0,rc.boolOrEmptySchema)(e,t)}function nc({schema:e,self:t}){if(typeof e=="boolean")return!e;for(let r in e)if(t.RULES.all[r])return!0;return!1}function oc(e){return typeof e.schema!="boolean"}function k_(e,t){let{schema:r,gen:s,opts:n}=e;n.$comment&&r.$comment&&uc(e),A_(e),D_(e);let o=s.const("_errs",w.default.errors);ic(e,o),s.var(t,(0,b._)`${o} === ${w.default.errors}`)}function ac(e){(0,je.checkUnknownRules)(e),C_(e)}function ic(e,t){if(e.opts.jtd)return ec(e,[],!1,t);let r=(0,Zu.getSchemaTypes)(e.schema),s=(0,Zu.coerceAndCheckDataType)(e,r);ec(e,r,!s,t)}function C_(e){let{schema:t,errSchemaPath:r,opts:s,self:n}=e;t.$ref&&s.ignoreKeywordsWithRef&&(0,je.schemaHasRulesButRef)(t,n.RULES)&&n.logger.warn(`$ref: keywords ignored in schema at path "${r}"`)}function R_(e){let{schema:t,opts:r}=e;t.default!==void 0&&r.useDefaults&&r.strictSchema&&(0,je.checkStrictMode)(e,"default is ignored in the schema root")}function A_(e){let t=e.schema[e.opts.schemaId];t&&(e.baseId=(0,P_.resolveUrl)(e.opts.uriResolver,e.baseId,t))}function D_(e){if(e.schema.$async&&!e.schemaEnv.$async)throw new Error("async schema in sync schema")}function uc({gen:e,schemaEnv:t,schema:r,errSchemaPath:s,opts:n}){let o=r.$comment;if(n.$comment===!0)e.code((0,b._)`${w.default.self}.logger.log(${o})`);else if(typeof n.$comment=="function"){let a=(0,b.str)`${s}/$comment`,i=e.scopeValue("root",{ref:t.root});e.code((0,b._)`${w.default.self}.opts.$comment(${o}, ${a}, ${i}.schema)`)}}function M_(e){let{gen:t,schemaEnv:r,validateName:s,ValidationError:n,opts:o}=e;r.$async?t.if((0,b._)`${w.default.errors} === 0`,()=>t.return(w.default.data),()=>t.throw((0,b._)`new ${n}(${w.default.vErrors})`)):(t.assign((0,b._)`${s}.errors`,w.default.vErrors),o.unevaluated&&x_(e),t.return((0,b._)`${w.default.errors} === 0`))}function x_({gen:e,evaluated:t,props:r,items:s}){r instanceof b.Name&&e.assign((0,b._)`${t}.props`,r),s instanceof b.Name&&e.assign((0,b._)`${t}.items`,s)}function ec(e,t,r,s){let{gen:n,schema:o,data:a,allErrors:i,opts:u,self:c}=e,{RULES:l}=c;if(o.$ref&&(u.ignoreKeywordsWithRef||!(0,je.schemaHasRulesButRef)(o,l))){n.block(()=>lc(e,"$ref",l.all.$ref.definition));return}u.jtd||V_(e,t),n.block(()=>{for(let _ of l.rules)f(_);f(l.post)});function f(_){(0,Hs.shouldUseGroup)(o,_)&&(_.type?(n.if((0,Or.checkDataType)(_.type,a,u.strictNumbers)),tc(e,_),t.length===1&&t[0]===_.type&&r&&(n.else(),(0,Or.reportTypeError)(e)),n.endIf()):tc(e,_),i||n.if((0,b._)`${w.default.errors} === ${s||0}`))}}function tc(e,t){let{gen:r,schema:s,opts:{useDefaults:n}}=e;n&&(0,S_.assignDefaults)(e,t.type),r.block(()=>{for(let o of t.rules)(0,Hs.shouldUseRule)(s,o)&&lc(e,o.keyword,o.definition,t.type)})}function V_(e,t){e.schemaEnv.meta||!e.opts.strictTypes||(z_(e,t),e.opts.allowUnionTypes||L_(e,t),U_(e,e.dataTypes))}function z_(e,t){if(t.length){if(!e.dataTypes.length){e.dataTypes=t;return}t.forEach(r=>{cc(e.dataTypes,r)||Gs(e,`type "${r}" not allowed by context "${e.dataTypes.join(",")}"`)}),K_(e,t)}}function L_(e,t){t.length>1&&!(t.length===2&&t.includes("null"))&&Gs(e,"use allowUnionTypes to allow union type keyword")}function U_(e,t){let r=e.self.RULES.all;for(let s in r){let n=r[s];if(typeof n=="object"&&(0,Hs.shouldUseRule)(e.schema,n)){let{type:o}=n.definition;o.length&&!o.some(a=>F_(t,a))&&Gs(e,`missing type "${o.join(",")}" for keyword "${s}"`)}}}function F_(e,t){return e.includes(t)||t==="number"&&e.includes("integer")}function cc(e,t){return e.includes(t)||t==="integer"&&e.includes("number")}function K_(e,t){let r=[];for(let s of e.dataTypes)cc(t,s)?r.push(s):t.includes("integer")&&s==="number"&&r.push("integer");e.dataTypes=r}function Gs(e,t){let r=e.schemaEnv.baseId+e.errSchemaPath;t+=` at "${r}" (strictTypes)`,(0,je.checkStrictMode)(e,t,e.opts.strictTypes)}var Tr=class{constructor(t,r,s){if((0,Ht.validateKeywordUsage)(t,r,s),this.gen=t.gen,this.allErrors=t.allErrors,this.keyword=s,this.data=t.data,this.schema=t.schema[s],this.$data=r.$data&&t.opts.$data&&this.schema&&this.schema.$data,this.schemaValue=(0,je.schemaRefOrVal)(t,this.schema,s,this.$data),this.schemaType=r.schemaType,this.parentSchema=t.schema,this.params={},this.it=t,this.def=r,this.$data)this.schemaCode=t.gen.const("vSchema",dc(this.$data,t));else if(this.schemaCode=this.schemaValue,!(0,Ht.validSchemaType)(this.schema,r.schemaType,r.allowUndefined))throw new Error(`${s} value must be ${JSON.stringify(r.schemaType)}`);("code"in r?r.trackErrors:r.errors!==!1)&&(this.errsCount=t.gen.const("_errs",w.default.errors))}result(t,r,s){this.failResult((0,b.not)(t),r,s)}failResult(t,r,s){this.gen.if(t),s?s():this.error(),r?(this.gen.else(),r(),this.allErrors&&this.gen.endIf()):this.allErrors?this.gen.endIf():this.gen.else()}pass(t,r){this.failResult((0,b.not)(t),void 0,r)}fail(t){if(t===void 0){this.error(),this.allErrors||this.gen.if(!1);return}this.gen.if(t),this.error(),this.allErrors?this.gen.endIf():this.gen.else()}fail$data(t){if(!this.$data)return this.fail(t);let{schemaCode:r}=this;this.fail((0,b._)`${r} !== undefined && (${(0,b.or)(this.invalid$data(),t)})`)}error(t,r,s){if(r){this.setParams(r),this._error(t,s),this.setParams({});return}this._error(t,s)}_error(t,r){(t?Kt.reportExtraError:Kt.reportError)(this,this.def.error,r)}$dataError(){(0,Kt.reportError)(this,this.def.$dataError||Kt.keyword$DataError)}reset(){if(this.errsCount===void 0)throw new Error(\'add "trackErrors" to keyword definition\');(0,Kt.resetErrorsCount)(this.gen,this.errsCount)}ok(t){this.allErrors||this.gen.if(t)}setParams(t,r){r?Object.assign(this.params,t):this.params=t}block$data(t,r,s=b.nil){this.gen.block(()=>{this.check$data(t,s),r()})}check$data(t=b.nil,r=b.nil){if(!this.$data)return;let{gen:s,schemaCode:n,schemaType:o,def:a}=this;s.if((0,b.or)((0,b._)`${n} === undefined`,r)),t!==b.nil&&s.assign(t,!0),(o.length||a.validateSchema)&&(s.elseIf(this.invalid$data()),this.$dataError(),t!==b.nil&&s.assign(t,!1)),s.else()}invalid$data(){let{gen:t,schemaCode:r,schemaType:s,def:n,it:o}=this;return(0,b.or)(a(),i());function a(){if(s.length){if(!(r instanceof b.Name))throw new Error("ajv implementation error");let u=Array.isArray(s)?s:[s];return(0,b._)`${(0,Or.checkDataTypes)(u,r,o.opts.strictNumbers,Or.DataType.Wrong)}`}return b.nil}function i(){if(n.validateSchema){let u=t.scopeValue("validate$data",{ref:n.validateSchema});return(0,b._)`!${u}(${r})`}return b.nil}}subschema(t,r){let s=(0,Ks.getSubschema)(this.it,t);(0,Ks.extendSubschemaData)(s,this.it,t),(0,Ks.extendSubschemaMode)(s,t);let n=W(L(L({},this.it),s),{items:void 0,props:void 0});return j_(n,r),n}mergeEvaluated(t,r){let{it:s,gen:n}=this;s.opts.unevaluated&&(s.props!==!0&&t.props!==void 0&&(s.props=je.mergeEvaluated.props(n,t.props,s.props,r)),s.items!==!0&&t.items!==void 0&&(s.items=je.mergeEvaluated.items(n,t.items,s.items,r)))}mergeValidEvaluated(t,r){let{it:s,gen:n}=this;if(s.opts.unevaluated&&(s.props!==!0||s.items!==!0))return n.if(r,()=>this.mergeEvaluated(t,b.Name)),!0}};xe.KeywordCxt=Tr;function lc(e,t,r,s){let n=new Tr(e,r,t);"code"in r?r.code(n,s):n.$data&&r.validate?(0,Ht.funcKeywordCode)(n,r):"macro"in r?(0,Ht.macroKeywordCode)(n,r):(r.compile||r.validate)&&(0,Ht.funcKeywordCode)(n,r)}var H_=/^\\/(?:[^~]|~0|~1)*$/,G_=/^([0-9]+)(#|\\/(?:[^~]|~0|~1)*)?$/;function dc(e,{dataLevel:t,dataNames:r,dataPathArr:s}){let n,o;if(e==="")return w.default.rootData;if(e[0]==="/"){if(!H_.test(e))throw new Error(`Invalid JSON-pointer: ${e}`);n=e,o=w.default.rootData}else{let c=G_.exec(e);if(!c)throw new Error(`Invalid JSON-pointer: ${e}`);let l=+c[1];if(n=c[2],n==="#"){if(l>=t)throw new Error(u("property/index",l));return s[t-l]}if(l>t)throw new Error(u("data",l));if(o=r[t-l],!n)return o}let a=o,i=n.split("/");for(let c of i)c&&(o=(0,b._)`${o}${(0,b.getProperty)((0,je.unescapeJsonPointer)(c))}`,a=(0,b._)`${a} && ${o}`);return a;function u(c,l){return`Cannot access ${c} ${l} levels up, current level is ${t}`}}xe.getData=dc});var Ir=d(Ws=>{"use strict";Object.defineProperty(Ws,"__esModule",{value:!0});var Js=class extends Error{constructor(t){super("validation failed"),this.errors=t,this.ajv=this.validation=!0}};Ws.default=Js});var Gt=d(Ys=>{"use strict";Object.defineProperty(Ys,"__esModule",{value:!0});var Xs=Ft(),Bs=class extends Error{constructor(t,r,s,n){super(n||`can\'t resolve reference ${s} from id ${r}`),this.missingRef=(0,Xs.resolveUrl)(t,r,s),this.missingSchema=(0,Xs.normalizeId)((0,Xs.getFullPath)(t,this.missingRef))}};Ys.default=Bs});var jr=d(ye=>{"use strict";Object.defineProperty(ye,"__esModule",{value:!0});ye.resolveSchema=ye.getCompilingSchema=ye.resolveRef=ye.compileSchema=ye.SchemaEnv=void 0;var $e=I(),J_=Ir(),Be=we(),ve=Ft(),fc=D(),W_=mt(),yt=class{constructor(t){var r;this.refs={},this.dynamicAnchors={};let s;typeof t.schema=="object"&&(s=t.schema),this.schema=t.schema,this.schemaId=t.schemaId,this.root=t.root||this,this.baseId=(r=t.baseId)!==null&&r!==void 0?r:(0,ve.normalizeId)(s==null?void 0:s[t.schemaId||"$id"]),this.schemaPath=t.schemaPath,this.localRefs=t.localRefs,this.meta=t.meta,this.$async=s==null?void 0:s.$async,this.refs={}}};ye.SchemaEnv=yt;function Qs(e){let t=pc.call(this,e);if(t)return t;let r=(0,ve.getFullPath)(this.opts.uriResolver,e.root.baseId),{es5:s,lines:n}=this.opts.code,{ownProperties:o}=this.opts,a=new $e.CodeGen(this.scope,{es5:s,lines:n,ownProperties:o}),i;e.$async&&(i=a.scopeValue("Error",{ref:J_.default,code:(0,$e._)`require("ajv/dist/runtime/validation_error").default`}));let u=a.scopeName("validate");e.validateName=u;let c={gen:a,allErrors:this.opts.allErrors,data:Be.default.data,parentData:Be.default.parentData,parentDataProperty:Be.default.parentDataProperty,dataNames:[Be.default.data],dataPathArr:[$e.nil],dataLevel:0,dataTypes:[],definedProperties:new Set,topSchemaRef:a.scopeValue("schema",this.opts.code.source===!0?{ref:e.schema,code:(0,$e.stringify)(e.schema)}:{ref:e.schema}),validateName:u,ValidationError:i,schema:e.schema,schemaEnv:e,rootId:r,baseId:e.baseId||r,schemaPath:$e.nil,errSchemaPath:e.schemaPath||(this.opts.jtd?"":"#"),errorPath:(0,$e._)`""`,opts:this.opts,self:this},l;try{this._compilations.add(e),(0,W_.validateFunctionCode)(c),a.optimize(this.opts.code.optimize);let f=a.toString();l=`${a.scopeRefs(Be.default.scope)}return ${f}`,this.opts.code.process&&(l=this.opts.code.process(l,e));let m=new Function(`${Be.default.self}`,`${Be.default.scope}`,l)(this,this.scope.get());if(this.scope.value(u,{ref:m}),m.errors=null,m.schema=e.schema,m.schemaEnv=e,e.$async&&(m.$async=!0),this.opts.code.source===!0&&(m.source={validateName:u,validateCode:f,scopeValues:a._values}),this.opts.unevaluated){let{props:h,items:p}=c;m.evaluated={props:h instanceof $e.Name?void 0:h,items:p instanceof $e.Name?void 0:p,dynamicProps:h instanceof $e.Name,dynamicItems:p instanceof $e.Name},m.source&&(m.source.evaluated=(0,$e.stringify)(m.evaluated))}return e.validate=m,e}catch(f){throw delete e.validate,delete e.validateName,l&&this.logger.error("Error compiling schema, function code:",l),f}finally{this._compilations.delete(e)}}ye.compileSchema=Qs;function X_(e,t,r){var s;r=(0,ve.resolveUrl)(this.opts.uriResolver,t,r);let n=e.refs[r];if(n)return n;let o=Z_.call(this,e,r);if(o===void 0){let a=(s=e.localRefs)===null||s===void 0?void 0:s[r],{schemaId:i}=this.opts;a&&(o=new yt({schema:a,schemaId:i,root:e,baseId:t}))}if(o!==void 0)return e.refs[r]=B_.call(this,o)}ye.resolveRef=X_;function B_(e){return(0,ve.inlineRef)(e.schema,this.opts.inlineRefs)?e.schema:e.validate?e:Qs.call(this,e)}function pc(e){for(let t of this._compilations)if(Y_(t,e))return t}ye.getCompilingSchema=pc;function Y_(e,t){return e.schema===t.schema&&e.root===t.root&&e.baseId===t.baseId}function Z_(e,t){let r;for(;typeof(r=this.refs[t])=="string";)t=r;return r||this.schemas[t]||qr.call(this,e,t)}function qr(e,t){let r=this.opts.uriResolver.parse(t),s=(0,ve._getFullPath)(this.opts.uriResolver,r),n=(0,ve.getFullPath)(this.opts.uriResolver,e.baseId,void 0);if(Object.keys(e.schema).length>0&&s===n)return Zs.call(this,r,e);let o=(0,ve.normalizeId)(s),a=this.refs[o]||this.schemas[o];if(typeof a=="string"){let i=qr.call(this,e,a);return typeof(i==null?void 0:i.schema)!="object"?void 0:Zs.call(this,r,i)}if(typeof(a==null?void 0:a.schema)=="object"){if(a.validate||Qs.call(this,a),o===(0,ve.normalizeId)(t)){let{schema:i}=a,{schemaId:u}=this.opts,c=i[u];return c&&(n=(0,ve.resolveUrl)(this.opts.uriResolver,n,c)),new yt({schema:i,schemaId:u,root:e,baseId:n})}return Zs.call(this,r,a)}}ye.resolveSchema=qr;var Q_=new Set(["properties","patternProperties","enum","dependencies","definitions"]);function Zs(e,{baseId:t,schema:r,root:s}){var n;if(((n=e.fragment)===null||n===void 0?void 0:n[0])!=="/")return;for(let i of e.fragment.slice(1).split("/")){if(typeof r=="boolean")return;let u=r[(0,fc.unescapeFragment)(i)];if(u===void 0)return;r=u;let c=typeof r=="object"&&r[this.opts.schemaId];!Q_.has(i)&&c&&(t=(0,ve.resolveUrl)(this.opts.uriResolver,t,c))}let o;if(typeof r!="boolean"&&r.$ref&&!(0,fc.schemaHasRulesButRef)(r,this.RULES)){let i=(0,ve.resolveUrl)(this.opts.uriResolver,t,r.$ref);o=qr.call(this,s,i)}let{schemaId:a}=this.opts;if(o=o||new yt({schema:r,schemaId:a,root:s,baseId:t}),o.schema!==o.root.schema)return o}});var hc=d((qE,eg)=>{eg.exports={$id:"https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",description:"Meta-schema for $data reference (JSON AnySchema extension proposal)",type:"object",required:["$data"],properties:{$data:{type:"string",anyOf:[{format:"relative-json-pointer"},{format:"json-pointer"}]}},additionalProperties:!1}});var yc=d((jE,mc)=>{"use strict";var tg={0:0,1:1,2:2,3:3,4:4,5:5,6:6,7:7,8:8,9:9,a:10,A:10,b:11,B:11,c:12,C:12,d:13,D:13,e:14,E:14,f:15,F:15};mc.exports={HEX:tg}});var Sc=d((kE,wc)=>{"use strict";var{HEX:rg}=yc();function vc(e){if(Ec(e,".")<3)return{host:e,isIPV4:!1};let t=e.match(/^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/u)||[],[r]=t;return r?{host:ng(r,"."),isIPV4:!0}:{host:e,isIPV4:!1}}function en(e,t=!1){let r="",s=!0;for(let n of e){if(rg[n]===void 0)return;n!=="0"&&s===!0&&(s=!1),s||(r+=n)}return t&&r.length===0&&(r="0"),r}function sg(e){let t=0,r={error:!1,address:"",zone:""},s=[],n=[],o=!1,a=!1,i=!1;function u(){if(n.length){if(o===!1){let c=en(n);if(c!==void 0)s.push(c);else return r.error=!0,!1}n.length=0}return!0}for(let c=0;c<e.length;c++){let l=e[c];if(!(l==="["||l==="]"))if(l===":"){if(a===!0&&(i=!0),!u())break;if(t++,s.push(":"),t>7){r.error=!0;break}c-1>=0&&e[c-1]===":"&&(a=!0);continue}else if(l==="%"){if(!u())break;o=!0}else{n.push(l);continue}}return n.length&&(o?r.zone=n.join(""):i?s.push(n.join("")):s.push(en(n))),r.address=s.join(""),r}function bc(e,t={}){if(Ec(e,":")<2)return{host:e,isIPV6:!1};let r=sg(e);if(r.error)return{host:e,isIPV6:!1};{let s=r.address,n=r.address;return r.zone&&(s+="%"+r.zone,n+="%25"+r.zone),{host:s,escapedHost:n,isIPV6:!0}}}function ng(e,t){let r="",s=!0,n=e.length;for(let o=0;o<n;o++){let a=e[o];a==="0"&&s?(o+1<=n&&e[o+1]===t||o+1===n)&&(r+=a,s=!1):(a===t?s=!0:s=!1,r+=a)}return r}function Ec(e,t){let r=0;for(let s=0;s<e.length;s++)e[s]===t&&r++;return r}var _c=/^\\.\\.?\\//u,gc=/^\\/\\.(?:\\/|$)/u,$c=/^\\/\\.\\.(?:\\/|$)/u,og=/^\\/?(?:.|\\n)*?(?=\\/|$)/u;function ag(e){let t=[];for(;e.length;)if(e.match(_c))e=e.replace(_c,"");else if(e.match(gc))e=e.replace(gc,"/");else if(e.match($c))e=e.replace($c,"/"),t.pop();else if(e==="."||e==="..")e="";else{let r=e.match(og);if(r){let s=r[0];e=e.slice(s.length),t.push(s)}else throw new Error("Unexpected dot segment condition")}return t.join("")}function ig(e,t){let r=t!==!0?escape:unescape;return e.scheme!==void 0&&(e.scheme=r(e.scheme)),e.userinfo!==void 0&&(e.userinfo=r(e.userinfo)),e.host!==void 0&&(e.host=r(e.host)),e.path!==void 0&&(e.path=r(e.path)),e.query!==void 0&&(e.query=r(e.query)),e.fragment!==void 0&&(e.fragment=r(e.fragment)),e}function ug(e,t){let r=[];if(e.userinfo!==void 0&&(r.push(e.userinfo),r.push("@")),e.host!==void 0){let s=unescape(e.host),n=vc(s);if(n.isIPV4)s=n.host;else{let o=bc(n.host,{isIPV4:!1});o.isIPV6===!0?s=`[${o.escapedHost}]`:s=e.host}r.push(s)}return(typeof e.port=="number"||typeof e.port=="string")&&(r.push(":"),r.push(String(e.port))),r.length?r.join(""):void 0}wc.exports={recomposeAuthority:ug,normalizeComponentEncoding:ig,removeDotSegments:ag,normalizeIPv4:vc,normalizeIPv6:bc,stringArrayToHexStripped:en}});var qc=d((CE,Ic)=>{"use strict";var cg=/^[\\da-f]{8}\\b-[\\da-f]{4}\\b-[\\da-f]{4}\\b-[\\da-f]{4}\\b-[\\da-f]{12}$/iu,lg=/([\\da-z][\\d\\-a-z]{0,31}):((?:[\\w!$\'()*+,\\-.:;=@]|%[\\da-f]{2})+)/iu;function Pc(e){return typeof e.secure=="boolean"?e.secure:String(e.scheme).toLowerCase()==="wss"}function Nc(e){return e.host||(e.error=e.error||"HTTP URIs must have a host."),e}function Oc(e){let t=String(e.scheme).toLowerCase()==="https";return(e.port===(t?443:80)||e.port==="")&&(e.port=void 0),e.path||(e.path="/"),e}function dg(e){return e.secure=Pc(e),e.resourceName=(e.path||"/")+(e.query?"?"+e.query:""),e.path=void 0,e.query=void 0,e}function fg(e){if((e.port===(Pc(e)?443:80)||e.port==="")&&(e.port=void 0),typeof e.secure=="boolean"&&(e.scheme=e.secure?"wss":"ws",e.secure=void 0),e.resourceName){let[t,r]=e.resourceName.split("?");e.path=t&&t!=="/"?t:void 0,e.query=r,e.resourceName=void 0}return e.fragment=void 0,e}function pg(e,t){if(!e.path)return e.error="URN can not be parsed",e;let r=e.path.match(lg);if(r){let s=t.scheme||e.scheme||"urn";e.nid=r[1].toLowerCase(),e.nss=r[2];let n=`${s}:${t.nid||e.nid}`,o=tn[n];e.path=void 0,o&&(e=o.parse(e,t))}else e.error=e.error||"URN can not be parsed.";return e}function hg(e,t){let r=t.scheme||e.scheme||"urn",s=e.nid.toLowerCase(),n=`${r}:${t.nid||s}`,o=tn[n];o&&(e=o.serialize(e,t));let a=e,i=e.nss;return a.path=`${s||t.nid}:${i}`,t.skipEscape=!0,a}function mg(e,t){let r=e;return r.uuid=r.nss,r.nss=void 0,!t.tolerant&&(!r.uuid||!cg.test(r.uuid))&&(r.error=r.error||"UUID is not valid."),r}function yg(e){let t=e;return t.nss=(e.uuid||"").toLowerCase(),t}var Tc={scheme:"http",domainHost:!0,parse:Nc,serialize:Oc},_g={scheme:"https",domainHost:Tc.domainHost,parse:Nc,serialize:Oc},kr={scheme:"ws",domainHost:!0,parse:dg,serialize:fg},gg={scheme:"wss",domainHost:kr.domainHost,parse:kr.parse,serialize:kr.serialize},$g={scheme:"urn",parse:pg,serialize:hg,skipNormalize:!0},vg={scheme:"urn:uuid",parse:mg,serialize:yg,skipNormalize:!0},tn={http:Tc,https:_g,ws:kr,wss:gg,urn:$g,"urn:uuid":vg};Ic.exports=tn});var kc=d((RE,Rr)=>{"use strict";var{normalizeIPv6:bg,normalizeIPv4:Eg,removeDotSegments:Jt,recomposeAuthority:wg,normalizeComponentEncoding:Cr}=Sc(),rn=qc();function Sg(e,t){return typeof e=="string"?e=Ne(ke(e,t),t):typeof e=="object"&&(e=ke(Ne(e,t),t)),e}function Pg(e,t,r){let s=Object.assign({scheme:"null"},r),n=jc(ke(e,s),ke(t,s),s,!0);return Ne(n,W(L({},s),{skipEscape:!0}))}function jc(e,t,r,s){let n={};return s||(e=ke(Ne(e,r),r),t=ke(Ne(t,r),r)),r=r||{},!r.tolerant&&t.scheme?(n.scheme=t.scheme,n.userinfo=t.userinfo,n.host=t.host,n.port=t.port,n.path=Jt(t.path||""),n.query=t.query):(t.userinfo!==void 0||t.host!==void 0||t.port!==void 0?(n.userinfo=t.userinfo,n.host=t.host,n.port=t.port,n.path=Jt(t.path||""),n.query=t.query):(t.path?(t.path.charAt(0)==="/"?n.path=Jt(t.path):((e.userinfo!==void 0||e.host!==void 0||e.port!==void 0)&&!e.path?n.path="/"+t.path:e.path?n.path=e.path.slice(0,e.path.lastIndexOf("/")+1)+t.path:n.path=t.path,n.path=Jt(n.path)),n.query=t.query):(n.path=e.path,t.query!==void 0?n.query=t.query:n.query=e.query),n.userinfo=e.userinfo,n.host=e.host,n.port=e.port),n.scheme=e.scheme),n.fragment=t.fragment,n}function Ng(e,t,r){return typeof e=="string"?(e=unescape(e),e=Ne(Cr(ke(e,r),!0),W(L({},r),{skipEscape:!0}))):typeof e=="object"&&(e=Ne(Cr(e,!0),W(L({},r),{skipEscape:!0}))),typeof t=="string"?(t=unescape(t),t=Ne(Cr(ke(t,r),!0),W(L({},r),{skipEscape:!0}))):typeof t=="object"&&(t=Ne(Cr(t,!0),W(L({},r),{skipEscape:!0}))),e.toLowerCase()===t.toLowerCase()}function Ne(e,t){let r={host:e.host,scheme:e.scheme,userinfo:e.userinfo,port:e.port,path:e.path,query:e.query,nid:e.nid,nss:e.nss,uuid:e.uuid,fragment:e.fragment,reference:e.reference,resourceName:e.resourceName,secure:e.secure,error:""},s=Object.assign({},t),n=[],o=rn[(s.scheme||r.scheme||"").toLowerCase()];o&&o.serialize&&o.serialize(r,s),r.path!==void 0&&(s.skipEscape?r.path=unescape(r.path):(r.path=escape(r.path),r.scheme!==void 0&&(r.path=r.path.split("%3A").join(":")))),s.reference!=="suffix"&&r.scheme&&n.push(r.scheme,":");let a=wg(r,s);if(a!==void 0&&(s.reference!=="suffix"&&n.push("//"),n.push(a),r.path&&r.path.charAt(0)!=="/"&&n.push("/")),r.path!==void 0){let i=r.path;!s.absolutePath&&(!o||!o.absolutePath)&&(i=Jt(i)),a===void 0&&(i=i.replace(/^\\/\\//u,"/%2F")),n.push(i)}return r.query!==void 0&&n.push("?",r.query),r.fragment!==void 0&&n.push("#",r.fragment),n.join("")}var Og=Array.from({length:127},(e,t)=>/[^!"$&\'()*+,\\-.;=_`a-z{}~]/u.test(String.fromCharCode(t)));function Tg(e){let t=0;for(let r=0,s=e.length;r<s;++r)if(t=e.charCodeAt(r),t>126||Og[t])return!0;return!1}var Ig=/^(?:([^#/:?]+):)?(?:\\/\\/((?:([^#/?@]*)@)?(\\[[^#/?\\]]+\\]|[^#/:?]*)(?::(\\d*))?))?([^#?]*)(?:\\?([^#]*))?(?:#((?:.|[\\n\\r])*))?/u;function ke(e,t){let r=Object.assign({},t),s={scheme:void 0,userinfo:void 0,host:"",port:void 0,path:"",query:void 0,fragment:void 0},n=e.indexOf("%")!==-1,o=!1;r.reference==="suffix"&&(e=(r.scheme?r.scheme+":":"")+"//"+e);let a=e.match(Ig);if(a){if(s.scheme=a[1],s.userinfo=a[3],s.host=a[4],s.port=parseInt(a[5],10),s.path=a[6]||"",s.query=a[7],s.fragment=a[8],isNaN(s.port)&&(s.port=a[5]),s.host){let u=Eg(s.host);if(u.isIPV4===!1){let c=bg(u.host,{isIPV4:!1});s.host=c.host.toLowerCase(),o=c.isIPV6}else s.host=u.host,o=!0}s.scheme===void 0&&s.userinfo===void 0&&s.host===void 0&&s.port===void 0&&!s.path&&s.query===void 0?s.reference="same-document":s.scheme===void 0?s.reference="relative":s.fragment===void 0?s.reference="absolute":s.reference="uri",r.reference&&r.reference!=="suffix"&&r.reference!==s.reference&&(s.error=s.error||"URI is not a "+r.reference+" reference.");let i=rn[(r.scheme||s.scheme||"").toLowerCase()];if(!r.unicodeSupport&&(!i||!i.unicodeSupport)&&s.host&&(r.domainHost||i&&i.domainHost)&&o===!1&&Tg(s.host))try{s.host=URL.domainToASCII(s.host.toLowerCase())}catch(u){s.error=s.error||"Host\'s domain name can not be converted to ASCII: "+u}(!i||i&&!i.skipNormalize)&&(n&&s.scheme!==void 0&&(s.scheme=unescape(s.scheme)),n&&s.host!==void 0&&(s.host=unescape(s.host)),s.path!==void 0&&s.path.length&&(s.path=escape(unescape(s.path))),s.fragment!==void 0&&s.fragment.length&&(s.fragment=encodeURI(decodeURIComponent(s.fragment)))),i&&i.parse&&i.parse(s,r)}else s.error=s.error||"URI can not be parsed.";return s}var sn={SCHEMES:rn,normalize:Sg,resolve:Pg,resolveComponents:jc,equal:Ng,serialize:Ne,parse:ke};Rr.exports=sn;Rr.exports.default=sn;Rr.exports.fastUri=sn});var Rc=d(nn=>{"use strict";Object.defineProperty(nn,"__esModule",{value:!0});var Cc=kc();Cc.code=\'require("ajv/dist/runtime/uri").default\';nn.default=Cc});var Uc=d(B=>{"use strict";Object.defineProperty(B,"__esModule",{value:!0});B.CodeGen=B.Name=B.nil=B.stringify=B.str=B._=B.KeywordCxt=void 0;var qg=mt();Object.defineProperty(B,"KeywordCxt",{enumerable:!0,get:function(){return qg.KeywordCxt}});var _t=I();Object.defineProperty(B,"_",{enumerable:!0,get:function(){return _t._}});Object.defineProperty(B,"str",{enumerable:!0,get:function(){return _t.str}});Object.defineProperty(B,"stringify",{enumerable:!0,get:function(){return _t.stringify}});Object.defineProperty(B,"nil",{enumerable:!0,get:function(){return _t.nil}});Object.defineProperty(B,"Name",{enumerable:!0,get:function(){return _t.Name}});Object.defineProperty(B,"CodeGen",{enumerable:!0,get:function(){return _t.CodeGen}});var jg=Ir(),Vc=Gt(),kg=Rs(),Wt=jr(),Cg=I(),Xt=Ft(),Ar=Ut(),an=D(),Ac=hc(),Rg=Rc(),zc=(e,t)=>new RegExp(e,t);zc.code="new RegExp";var Ag=["removeAdditional","useDefaults","coerceTypes"],Dg=new Set(["validate","serialize","parse","wrapper","root","schema","keyword","pattern","formats","validate$data","func","obj","Error"]),Mg={errorDataPath:"",format:"`validateFormats: false` can be used instead.",nullable:\'"nullable" keyword is supported by default.\',jsonPointers:"Deprecated jsPropertySyntax can be used instead.",extendRefs:"Deprecated ignoreKeywordsWithRef can be used instead.",missingRefs:"Pass empty schema with $id that should be ignored to ajv.addSchema.",processCode:"Use option `code: {process: (code, schemaEnv: object) => string}`",sourceCode:"Use option `code: {source: true}`",strictDefaults:"It is default now, see option `strict`.",strictKeywords:"It is default now, see option `strict`.",uniqueItems:\'"uniqueItems" keyword is always validated.\',unknownFormats:"Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",cache:"Map is used as cache, schema object as key.",serialize:"Map is used as cache, schema object as key.",ajvErrors:"It is default now."},xg={ignoreKeywordsWithRef:"",jsPropertySyntax:"",unicode:\'"minLength"/"maxLength" account for unicode characters by default.\'},Dc=200;function Vg(e){var t,r,s,n,o,a,i,u,c,l,f,_,m,h,p,y,$,j,N,V,S,v,E,O,x;let H=e.strict,G=(t=e.code)===null||t===void 0?void 0:t.optimize,k=G===!0||G===void 0?1:G||0,M=(s=(r=e.code)===null||r===void 0?void 0:r.regExp)!==null&&s!==void 0?s:zc,fe=(n=e.uriResolver)!==null&&n!==void 0?n:Rg.default;return{strictSchema:(a=(o=e.strictSchema)!==null&&o!==void 0?o:H)!==null&&a!==void 0?a:!0,strictNumbers:(u=(i=e.strictNumbers)!==null&&i!==void 0?i:H)!==null&&u!==void 0?u:!0,strictTypes:(l=(c=e.strictTypes)!==null&&c!==void 0?c:H)!==null&&l!==void 0?l:"log",strictTuples:(_=(f=e.strictTuples)!==null&&f!==void 0?f:H)!==null&&_!==void 0?_:"log",strictRequired:(h=(m=e.strictRequired)!==null&&m!==void 0?m:H)!==null&&h!==void 0?h:!1,code:e.code?W(L({},e.code),{optimize:k,regExp:M}):{optimize:k,regExp:M},loopRequired:(p=e.loopRequired)!==null&&p!==void 0?p:Dc,loopEnum:(y=e.loopEnum)!==null&&y!==void 0?y:Dc,meta:($=e.meta)!==null&&$!==void 0?$:!0,messages:(j=e.messages)!==null&&j!==void 0?j:!0,inlineRefs:(N=e.inlineRefs)!==null&&N!==void 0?N:!0,schemaId:(V=e.schemaId)!==null&&V!==void 0?V:"$id",addUsedSchema:(S=e.addUsedSchema)!==null&&S!==void 0?S:!0,validateSchema:(v=e.validateSchema)!==null&&v!==void 0?v:!0,validateFormats:(E=e.validateFormats)!==null&&E!==void 0?E:!0,unicodeRegExp:(O=e.unicodeRegExp)!==null&&O!==void 0?O:!0,int32range:(x=e.int32range)!==null&&x!==void 0?x:!0,uriResolver:fe}}var Bt=class{constructor(t={}){this.schemas={},this.refs={},this.formats={},this._compilations=new Set,this._loading={},this._cache=new Map,t=this.opts=L(L({},t),Vg(t));let{es5:r,lines:s}=this.opts.code;this.scope=new Cg.ValueScope({scope:{},prefixes:Dg,es5:r,lines:s}),this.logger=Hg(t.logger);let n=t.validateFormats;t.validateFormats=!1,this.RULES=(0,kg.getRules)(),Mc.call(this,Mg,t,"NOT SUPPORTED"),Mc.call(this,xg,t,"DEPRECATED","warn"),this._metaOpts=Fg.call(this),t.formats&&Lg.call(this),this._addVocabularies(),this._addDefaultMetaSchema(),t.keywords&&Ug.call(this,t.keywords),typeof t.meta=="object"&&this.addMetaSchema(t.meta),zg.call(this),t.validateFormats=n}_addVocabularies(){this.addKeyword("$async")}_addDefaultMetaSchema(){let{$data:t,meta:r,schemaId:s}=this.opts,n=Ac;s==="id"&&(n=L({},Ac),n.id=n.$id,delete n.$id),r&&t&&this.addMetaSchema(n,n[s],!1)}defaultMeta(){let{meta:t,schemaId:r}=this.opts;return this.opts.defaultMeta=typeof t=="object"?t[r]||t:void 0}validate(t,r){let s;if(typeof t=="string"){if(s=this.getSchema(t),!s)throw new Error(`no schema with key or ref "${t}"`)}else s=this.compile(t);let n=s(r);return"$async"in s||(this.errors=s.errors),n}compile(t,r){let s=this._addSchema(t,r);return s.validate||this._compileSchemaEnv(s)}compileAsync(t,r){if(typeof this.opts.loadSchema!="function")throw new Error("options.loadSchema should be a function");let{loadSchema:s}=this.opts;return n.call(this,t,r);function n(l,f){return et(this,null,function*(){yield o.call(this,l.$schema);let _=this._addSchema(l,f);return _.validate||a.call(this,_)})}function o(l){return et(this,null,function*(){l&&!this.getSchema(l)&&(yield n.call(this,{$ref:l},!0))})}function a(l){return et(this,null,function*(){try{return this._compileSchemaEnv(l)}catch(f){if(!(f instanceof Vc.default))throw f;return i.call(this,f),yield u.call(this,f.missingSchema),a.call(this,l)}})}function i({missingSchema:l,missingRef:f}){if(this.refs[l])throw new Error(`AnySchema ${l} is loaded but ${f} cannot be resolved`)}function u(l){return et(this,null,function*(){let f=yield c.call(this,l);this.refs[l]||(yield o.call(this,f.$schema)),this.refs[l]||this.addSchema(f,l,r)})}function c(l){return et(this,null,function*(){let f=this._loading[l];if(f)return f;try{return yield this._loading[l]=s(l)}finally{delete this._loading[l]}})}}addSchema(t,r,s,n=this.opts.validateSchema){if(Array.isArray(t)){for(let a of t)this.addSchema(a,void 0,s,n);return this}let o;if(typeof t=="object"){let{schemaId:a}=this.opts;if(o=t[a],o!==void 0&&typeof o!="string")throw new Error(`schema ${a} must be string`)}return r=(0,Xt.normalizeId)(r||o),this._checkUnique(r),this.schemas[r]=this._addSchema(t,s,r,n,!0),this}addMetaSchema(t,r,s=this.opts.validateSchema){return this.addSchema(t,r,!0,s),this}validateSchema(t,r){if(typeof t=="boolean")return!0;let s;if(s=t.$schema,s!==void 0&&typeof s!="string")throw new Error("$schema must be a string");if(s=s||this.opts.defaultMeta||this.defaultMeta(),!s)return this.logger.warn("meta-schema not available"),this.errors=null,!0;let n=this.validate(s,t);if(!n&&r){let o="schema is invalid: "+this.errorsText();if(this.opts.validateSchema==="log")this.logger.error(o);else throw new Error(o)}return n}getSchema(t){let r;for(;typeof(r=xc.call(this,t))=="string";)t=r;if(r===void 0){let{schemaId:s}=this.opts,n=new Wt.SchemaEnv({schema:{},schemaId:s});if(r=Wt.resolveSchema.call(this,n,t),!r)return;this.refs[t]=r}return r.validate||this._compileSchemaEnv(r)}removeSchema(t){if(t instanceof RegExp)return this._removeAllSchemas(this.schemas,t),this._removeAllSchemas(this.refs,t),this;switch(typeof t){case"undefined":return this._removeAllSchemas(this.schemas),this._removeAllSchemas(this.refs),this._cache.clear(),this;case"string":{let r=xc.call(this,t);return typeof r=="object"&&this._cache.delete(r.schema),delete this.schemas[t],delete this.refs[t],this}case"object":{let r=t;this._cache.delete(r);let s=t[this.opts.schemaId];return s&&(s=(0,Xt.normalizeId)(s),delete this.schemas[s],delete this.refs[s]),this}default:throw new Error("ajv.removeSchema: invalid parameter")}}addVocabulary(t){for(let r of t)this.addKeyword(r);return this}addKeyword(t,r){let s;if(typeof t=="string")s=t,typeof r=="object"&&(this.logger.warn("these parameters are deprecated, see docs for addKeyword"),r.keyword=s);else if(typeof t=="object"&&r===void 0){if(r=t,s=r.keyword,Array.isArray(s)&&!s.length)throw new Error("addKeywords: keyword must be string or non-empty array")}else throw new Error("invalid addKeywords parameters");if(Jg.call(this,s,r),!r)return(0,an.eachItem)(s,o=>on.call(this,o)),this;Xg.call(this,r);let n=W(L({},r),{type:(0,Ar.getJSONTypes)(r.type),schemaType:(0,Ar.getJSONTypes)(r.schemaType)});return(0,an.eachItem)(s,n.type.length===0?o=>on.call(this,o,n):o=>n.type.forEach(a=>on.call(this,o,n,a))),this}getKeyword(t){let r=this.RULES.all[t];return typeof r=="object"?r.definition:!!r}removeKeyword(t){let{RULES:r}=this;delete r.keywords[t],delete r.all[t];for(let s of r.rules){let n=s.rules.findIndex(o=>o.keyword===t);n>=0&&s.rules.splice(n,1)}return this}addFormat(t,r){return typeof r=="string"&&(r=new RegExp(r)),this.formats[t]=r,this}errorsText(t=this.errors,{separator:r=", ",dataVar:s="data"}={}){return!t||t.length===0?"No errors":t.map(n=>`${s}${n.instancePath} ${n.message}`).reduce((n,o)=>n+r+o)}$dataMetaSchema(t,r){let s=this.RULES.all;t=JSON.parse(JSON.stringify(t));for(let n of r){let o=n.split("/").slice(1),a=t;for(let i of o)a=a[i];for(let i in s){let u=s[i];if(typeof u!="object")continue;let{$data:c}=u.definition,l=a[i];c&&l&&(a[i]=Lc(l))}}return t}_removeAllSchemas(t,r){for(let s in t){let n=t[s];(!r||r.test(s))&&(typeof n=="string"?delete t[s]:n&&!n.meta&&(this._cache.delete(n.schema),delete t[s]))}}_addSchema(t,r,s,n=this.opts.validateSchema,o=this.opts.addUsedSchema){let a,{schemaId:i}=this.opts;if(typeof t=="object")a=t[i];else{if(this.opts.jtd)throw new Error("schema must be object");if(typeof t!="boolean")throw new Error("schema must be object or boolean")}let u=this._cache.get(t);if(u!==void 0)return u;s=(0,Xt.normalizeId)(a||s);let c=Xt.getSchemaRefs.call(this,t,s);return u=new Wt.SchemaEnv({schema:t,schemaId:i,meta:r,baseId:s,localRefs:c}),this._cache.set(u.schema,u),o&&!s.startsWith("#")&&(s&&this._checkUnique(s),this.refs[s]=u),n&&this.validateSchema(t,!0),u}_checkUnique(t){if(this.schemas[t]||this.refs[t])throw new Error(`schema with key or id "${t}" already exists`)}_compileSchemaEnv(t){if(t.meta?this._compileMetaSchema(t):Wt.compileSchema.call(this,t),!t.validate)throw new Error("ajv implementation error");return t.validate}_compileMetaSchema(t){let r=this.opts;this.opts=this._metaOpts;try{Wt.compileSchema.call(this,t)}finally{this.opts=r}}};Bt.ValidationError=jg.default;Bt.MissingRefError=Vc.default;B.default=Bt;function Mc(e,t,r,s="error"){for(let n in e){let o=n;o in t&&this.logger[s](`${r}: option ${n}. ${e[o]}`)}}function xc(e){return e=(0,Xt.normalizeId)(e),this.schemas[e]||this.refs[e]}function zg(){let e=this.opts.schemas;if(e)if(Array.isArray(e))this.addSchema(e);else for(let t in e)this.addSchema(e[t],t)}function Lg(){for(let e in this.opts.formats){let t=this.opts.formats[e];t&&this.addFormat(e,t)}}function Ug(e){if(Array.isArray(e)){this.addVocabulary(e);return}this.logger.warn("keywords option as map is deprecated, pass array");for(let t in e){let r=e[t];r.keyword||(r.keyword=t),this.addKeyword(r)}}function Fg(){let e=L({},this.opts);for(let t of Ag)delete e[t];return e}var Kg={log(){},warn(){},error(){}};function Hg(e){if(e===!1)return Kg;if(e===void 0)return console;if(e.log&&e.warn&&e.error)return e;throw new Error("logger must implement log, warn and error methods")}var Gg=/^[a-z_$][a-z0-9_$:-]*$/i;function Jg(e,t){let{RULES:r}=this;if((0,an.eachItem)(e,s=>{if(r.keywords[s])throw new Error(`Keyword ${s} is already defined`);if(!Gg.test(s))throw new Error(`Keyword ${s} has invalid name`)}),!!t&&t.$data&&!("code"in t||"validate"in t))throw new Error(\'$data keyword must have "code" or "validate" function\')}function on(e,t,r){var s;let n=t==null?void 0:t.post;if(r&&n)throw new Error(\'keyword with "post" flag cannot have "type"\');let{RULES:o}=this,a=n?o.post:o.rules.find(({type:u})=>u===r);if(a||(a={type:r,rules:[]},o.rules.push(a)),o.keywords[e]=!0,!t)return;let i={keyword:e,definition:W(L({},t),{type:(0,Ar.getJSONTypes)(t.type),schemaType:(0,Ar.getJSONTypes)(t.schemaType)})};t.before?Wg.call(this,a,i,t.before):a.rules.push(i),o.all[e]=i,(s=t.implements)===null||s===void 0||s.forEach(u=>this.addKeyword(u))}function Wg(e,t,r){let s=e.rules.findIndex(n=>n.keyword===r);s>=0?e.rules.splice(s,0,t):(e.rules.push(t),this.logger.warn(`rule ${r} is not defined`))}function Xg(e){let{metaSchema:t}=e;t!==void 0&&(e.$data&&this.opts.$data&&(t=Lc(t)),e.validateSchema=this.compile(t,!0))}var Bg={$ref:"https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"};function Lc(e){return{anyOf:[e,Bg]}}});var Fc=d(un=>{"use strict";Object.defineProperty(un,"__esModule",{value:!0});var Yg={keyword:"id",code(){throw new Error(\'NOT SUPPORTED: keyword "id", use "$id" for schema ID\')}};un.default=Yg});var Jc=d(Ye=>{"use strict";Object.defineProperty(Ye,"__esModule",{value:!0});Ye.callRef=Ye.getValidate=void 0;var Zg=Gt(),Kc=me(),ue=I(),gt=we(),Hc=jr(),Dr=D(),Qg={keyword:"$ref",schemaType:"string",code(e){let{gen:t,schema:r,it:s}=e,{baseId:n,schemaEnv:o,validateName:a,opts:i,self:u}=s,{root:c}=o;if((r==="#"||r==="#/")&&n===c.baseId)return f();let l=Hc.resolveRef.call(u,c,n,r);if(l===void 0)throw new Zg.default(s.opts.uriResolver,n,r);if(l instanceof Hc.SchemaEnv)return _(l);return m(l);function f(){if(o===c)return Mr(e,a,o,o.$async);let h=t.scopeValue("root",{ref:c});return Mr(e,(0,ue._)`${h}.validate`,c,c.$async)}function _(h){let p=Gc(e,h);Mr(e,p,h,h.$async)}function m(h){let p=t.scopeValue("schema",i.code.source===!0?{ref:h,code:(0,ue.stringify)(h)}:{ref:h}),y=t.name("valid"),$=e.subschema({schema:h,dataTypes:[],schemaPath:ue.nil,topSchemaRef:p,errSchemaPath:r},y);e.mergeEvaluated($),e.ok(y)}}};function Gc(e,t){let{gen:r}=e;return t.validate?r.scopeValue("validate",{ref:t.validate}):(0,ue._)`${r.scopeValue("wrapper",{ref:t})}.validate`}Ye.getValidate=Gc;function Mr(e,t,r,s){let{gen:n,it:o}=e,{allErrors:a,schemaEnv:i,opts:u}=o,c=u.passContext?gt.default.this:ue.nil;s?l():f();function l(){if(!i.$async)throw new Error("async schema referenced by sync schema");let h=n.let("valid");n.try(()=>{n.code((0,ue._)`await ${(0,Kc.callValidateCode)(e,t,c)}`),m(t),a||n.assign(h,!0)},p=>{n.if((0,ue._)`!(${p} instanceof ${o.ValidationError})`,()=>n.throw(p)),_(p),a||n.assign(h,!1)}),e.ok(h)}function f(){e.result((0,Kc.callValidateCode)(e,t,c),()=>m(t),()=>_(t))}function _(h){let p=(0,ue._)`${h}.errors`;n.assign(gt.default.vErrors,(0,ue._)`${gt.default.vErrors} === null ? ${p} : ${gt.default.vErrors}.concat(${p})`),n.assign(gt.default.errors,(0,ue._)`${gt.default.vErrors}.length`)}function m(h){var p;if(!o.opts.unevaluated)return;let y=(p=r==null?void 0:r.validate)===null||p===void 0?void 0:p.evaluated;if(o.props!==!0)if(y&&!y.dynamicProps)y.props!==void 0&&(o.props=Dr.mergeEvaluated.props(n,y.props,o.props));else{let $=n.var("props",(0,ue._)`${h}.evaluated.props`);o.props=Dr.mergeEvaluated.props(n,$,o.props,ue.Name)}if(o.items!==!0)if(y&&!y.dynamicItems)y.items!==void 0&&(o.items=Dr.mergeEvaluated.items(n,y.items,o.items));else{let $=n.var("items",(0,ue._)`${h}.evaluated.items`);o.items=Dr.mergeEvaluated.items(n,$,o.items,ue.Name)}}}Ye.callRef=Mr;Ye.default=Qg});var Wc=d(cn=>{"use strict";Object.defineProperty(cn,"__esModule",{value:!0});var e0=Fc(),t0=Jc(),r0=["$schema","$id","$defs","$vocabulary",{keyword:"$comment"},"definitions",e0.default,t0.default];cn.default=r0});var Xc=d(ln=>{"use strict";Object.defineProperty(ln,"__esModule",{value:!0});var xr=I(),Ve=xr.operators,Vr={maximum:{okStr:"<=",ok:Ve.LTE,fail:Ve.GT},minimum:{okStr:">=",ok:Ve.GTE,fail:Ve.LT},exclusiveMaximum:{okStr:"<",ok:Ve.LT,fail:Ve.GTE},exclusiveMinimum:{okStr:">",ok:Ve.GT,fail:Ve.LTE}},s0={message:({keyword:e,schemaCode:t})=>(0,xr.str)`must be ${Vr[e].okStr} ${t}`,params:({keyword:e,schemaCode:t})=>(0,xr._)`{comparison: ${Vr[e].okStr}, limit: ${t}}`},n0={keyword:Object.keys(Vr),type:"number",schemaType:"number",$data:!0,error:s0,code(e){let{keyword:t,data:r,schemaCode:s}=e;e.fail$data((0,xr._)`${r} ${Vr[t].fail} ${s} || isNaN(${r})`)}};ln.default=n0});var Bc=d(dn=>{"use strict";Object.defineProperty(dn,"__esModule",{value:!0});var Yt=I(),o0={message:({schemaCode:e})=>(0,Yt.str)`must be multiple of ${e}`,params:({schemaCode:e})=>(0,Yt._)`{multipleOf: ${e}}`},a0={keyword:"multipleOf",type:"number",schemaType:"number",$data:!0,error:o0,code(e){let{gen:t,data:r,schemaCode:s,it:n}=e,o=n.opts.multipleOfPrecision,a=t.let("res"),i=o?(0,Yt._)`Math.abs(Math.round(${a}) - ${a}) > 1e-${o}`:(0,Yt._)`${a} !== parseInt(${a})`;e.fail$data((0,Yt._)`(${s} === 0 || (${a} = ${r}/${s}, ${i}))`)}};dn.default=a0});var Zc=d(fn=>{"use strict";Object.defineProperty(fn,"__esModule",{value:!0});function Yc(e){let t=e.length,r=0,s=0,n;for(;s<t;)r++,n=e.charCodeAt(s++),n>=55296&&n<=56319&&s<t&&(n=e.charCodeAt(s),(n&64512)===56320&&s++);return r}fn.default=Yc;Yc.code=\'require("ajv/dist/runtime/ucs2length").default\'});var Qc=d(pn=>{"use strict";Object.defineProperty(pn,"__esModule",{value:!0});var Ze=I(),i0=D(),u0=Zc(),c0={message({keyword:e,schemaCode:t}){let r=e==="maxLength"?"more":"fewer";return(0,Ze.str)`must NOT have ${r} than ${t} characters`},params:({schemaCode:e})=>(0,Ze._)`{limit: ${e}}`},l0={keyword:["maxLength","minLength"],type:"string",schemaType:"number",$data:!0,error:c0,code(e){let{keyword:t,data:r,schemaCode:s,it:n}=e,o=t==="maxLength"?Ze.operators.GT:Ze.operators.LT,a=n.opts.unicode===!1?(0,Ze._)`${r}.length`:(0,Ze._)`${(0,i0.useFunc)(e.gen,u0.default)}(${r})`;e.fail$data((0,Ze._)`${a} ${o} ${s}`)}};pn.default=l0});var el=d(hn=>{"use strict";Object.defineProperty(hn,"__esModule",{value:!0});var d0=me(),zr=I(),f0={message:({schemaCode:e})=>(0,zr.str)`must match pattern "${e}"`,params:({schemaCode:e})=>(0,zr._)`{pattern: ${e}}`},p0={keyword:"pattern",type:"string",schemaType:"string",$data:!0,error:f0,code(e){let{data:t,$data:r,schema:s,schemaCode:n,it:o}=e,a=o.opts.unicodeRegExp?"u":"",i=r?(0,zr._)`(new RegExp(${n}, ${a}))`:(0,d0.usePattern)(e,s);e.fail$data((0,zr._)`!${i}.test(${t})`)}};hn.default=p0});var tl=d(mn=>{"use strict";Object.defineProperty(mn,"__esModule",{value:!0});var Zt=I(),h0={message({keyword:e,schemaCode:t}){let r=e==="maxProperties"?"more":"fewer";return(0,Zt.str)`must NOT have ${r} than ${t} properties`},params:({schemaCode:e})=>(0,Zt._)`{limit: ${e}}`},m0={keyword:["maxProperties","minProperties"],type:"object",schemaType:"number",$data:!0,error:h0,code(e){let{keyword:t,data:r,schemaCode:s}=e,n=t==="maxProperties"?Zt.operators.GT:Zt.operators.LT;e.fail$data((0,Zt._)`Object.keys(${r}).length ${n} ${s}`)}};mn.default=m0});var rl=d(yn=>{"use strict";Object.defineProperty(yn,"__esModule",{value:!0});var Qt=me(),er=I(),y0=D(),_0={message:({params:{missingProperty:e}})=>(0,er.str)`must have required property \'${e}\'`,params:({params:{missingProperty:e}})=>(0,er._)`{missingProperty: ${e}}`},g0={keyword:"required",type:"object",schemaType:"array",$data:!0,error:_0,code(e){let{gen:t,schema:r,schemaCode:s,data:n,$data:o,it:a}=e,{opts:i}=a;if(!o&&r.length===0)return;let u=r.length>=i.loopRequired;if(a.allErrors?c():l(),i.strictRequired){let m=e.parentSchema.properties,{definedProperties:h}=e.it;for(let p of r)if((m==null?void 0:m[p])===void 0&&!h.has(p)){let y=a.schemaEnv.baseId+a.errSchemaPath,$=`required property "${p}" is not defined at "${y}" (strictRequired)`;(0,y0.checkStrictMode)(a,$,a.opts.strictRequired)}}function c(){if(u||o)e.block$data(er.nil,f);else for(let m of r)(0,Qt.checkReportMissingProp)(e,m)}function l(){let m=t.let("missing");if(u||o){let h=t.let("valid",!0);e.block$data(h,()=>_(m,h)),e.ok(h)}else t.if((0,Qt.checkMissingProp)(e,r,m)),(0,Qt.reportMissingProp)(e,m),t.else()}function f(){t.forOf("prop",s,m=>{e.setParams({missingProperty:m}),t.if((0,Qt.noPropertyInData)(t,n,m,i.ownProperties),()=>e.error())})}function _(m,h){e.setParams({missingProperty:m}),t.forOf(m,s,()=>{t.assign(h,(0,Qt.propertyInData)(t,n,m,i.ownProperties)),t.if((0,er.not)(h),()=>{e.error(),t.break()})},er.nil)}}};yn.default=g0});var sl=d(_n=>{"use strict";Object.defineProperty(_n,"__esModule",{value:!0});var tr=I(),$0={message({keyword:e,schemaCode:t}){let r=e==="maxItems"?"more":"fewer";return(0,tr.str)`must NOT have ${r} than ${t} items`},params:({schemaCode:e})=>(0,tr._)`{limit: ${e}}`},v0={keyword:["maxItems","minItems"],type:"array",schemaType:"number",$data:!0,error:$0,code(e){let{keyword:t,data:r,schemaCode:s}=e,n=t==="maxItems"?tr.operators.GT:tr.operators.LT;e.fail$data((0,tr._)`${r}.length ${n} ${s}`)}};_n.default=v0});var Lr=d(gn=>{"use strict";Object.defineProperty(gn,"__esModule",{value:!0});var nl=Us();nl.code=\'require("ajv/dist/runtime/equal").default\';gn.default=nl});var ol=d(vn=>{"use strict";Object.defineProperty(vn,"__esModule",{value:!0});var $n=Ut(),Y=I(),b0=D(),E0=Lr(),w0={message:({params:{i:e,j:t}})=>(0,Y.str)`must NOT have duplicate items (items ## ${t} and ${e} are identical)`,params:({params:{i:e,j:t}})=>(0,Y._)`{i: ${e}, j: ${t}}`},S0={keyword:"uniqueItems",type:"array",schemaType:"boolean",$data:!0,error:w0,code(e){let{gen:t,data:r,$data:s,schema:n,parentSchema:o,schemaCode:a,it:i}=e;if(!s&&!n)return;let u=t.let("valid"),c=o.items?(0,$n.getSchemaTypes)(o.items):[];e.block$data(u,l,(0,Y._)`${a} === false`),e.ok(u);function l(){let h=t.let("i",(0,Y._)`${r}.length`),p=t.let("j");e.setParams({i:h,j:p}),t.assign(u,!0),t.if((0,Y._)`${h} > 1`,()=>(f()?_:m)(h,p))}function f(){return c.length>0&&!c.some(h=>h==="object"||h==="array")}function _(h,p){let y=t.name("item"),$=(0,$n.checkDataTypes)(c,y,i.opts.strictNumbers,$n.DataType.Wrong),j=t.const("indices",(0,Y._)`{}`);t.for((0,Y._)`;${h}--;`,()=>{t.let(y,(0,Y._)`${r}[${h}]`),t.if($,(0,Y._)`continue`),c.length>1&&t.if((0,Y._)`typeof ${y} == "string"`,(0,Y._)`${y} += "_"`),t.if((0,Y._)`typeof ${j}[${y}] == "number"`,()=>{t.assign(p,(0,Y._)`${j}[${y}]`),e.error(),t.assign(u,!1).break()}).code((0,Y._)`${j}[${y}] = ${h}`)})}function m(h,p){let y=(0,b0.useFunc)(t,E0.default),$=t.name("outer");t.label($).for((0,Y._)`;${h}--;`,()=>t.for((0,Y._)`${p} = ${h}; ${p}--;`,()=>t.if((0,Y._)`${y}(${r}[${h}], ${r}[${p}])`,()=>{e.error(),t.assign(u,!1).break($)})))}}};vn.default=S0});var al=d(En=>{"use strict";Object.defineProperty(En,"__esModule",{value:!0});var bn=I(),P0=D(),N0=Lr(),O0={message:"must be equal to constant",params:({schemaCode:e})=>(0,bn._)`{allowedValue: ${e}}`},T0={keyword:"const",$data:!0,error:O0,code(e){let{gen:t,data:r,$data:s,schemaCode:n,schema:o}=e;s||o&&typeof o=="object"?e.fail$data((0,bn._)`!${(0,P0.useFunc)(t,N0.default)}(${r}, ${n})`):e.fail((0,bn._)`${o} !== ${r}`)}};En.default=T0});var il=d(wn=>{"use strict";Object.defineProperty(wn,"__esModule",{value:!0});var rr=I(),I0=D(),q0=Lr(),j0={message:"must be equal to one of the allowed values",params:({schemaCode:e})=>(0,rr._)`{allowedValues: ${e}}`},k0={keyword:"enum",schemaType:"array",$data:!0,error:j0,code(e){let{gen:t,data:r,$data:s,schema:n,schemaCode:o,it:a}=e;if(!s&&n.length===0)throw new Error("enum must have non-empty array");let i=n.length>=a.opts.loopEnum,u,c=()=>u!=null?u:u=(0,I0.useFunc)(t,q0.default),l;if(i||s)l=t.let("valid"),e.block$data(l,f);else{if(!Array.isArray(n))throw new Error("ajv implementation error");let m=t.const("vSchema",o);l=(0,rr.or)(...n.map((h,p)=>_(m,p)))}e.pass(l);function f(){t.assign(l,!1),t.forOf("v",o,m=>t.if((0,rr._)`${c()}(${r}, ${m})`,()=>t.assign(l,!0).break()))}function _(m,h){let p=n[h];return typeof p=="object"&&p!==null?(0,rr._)`${c()}(${r}, ${m}[${h}])`:(0,rr._)`${r} === ${p}`}}};wn.default=k0});var ul=d(Sn=>{"use strict";Object.defineProperty(Sn,"__esModule",{value:!0});var C0=Xc(),R0=Bc(),A0=Qc(),D0=el(),M0=tl(),x0=rl(),V0=sl(),z0=ol(),L0=al(),U0=il(),F0=[C0.default,R0.default,A0.default,D0.default,M0.default,x0.default,V0.default,z0.default,{keyword:"type",schemaType:["string","array"]},{keyword:"nullable",schemaType:"boolean"},L0.default,U0.default];Sn.default=F0});var Nn=d(sr=>{"use strict";Object.defineProperty(sr,"__esModule",{value:!0});sr.validateAdditionalItems=void 0;var Qe=I(),Pn=D(),K0={message:({params:{len:e}})=>(0,Qe.str)`must NOT have more than ${e} items`,params:({params:{len:e}})=>(0,Qe._)`{limit: ${e}}`},H0={keyword:"additionalItems",type:"array",schemaType:["boolean","object"],before:"uniqueItems",error:K0,code(e){let{parentSchema:t,it:r}=e,{items:s}=t;if(!Array.isArray(s)){(0,Pn.checkStrictMode)(r,\'"additionalItems" is ignored when "items" is not an array of schemas\');return}cl(e,s)}};function cl(e,t){let{gen:r,schema:s,data:n,keyword:o,it:a}=e;a.items=!0;let i=r.const("len",(0,Qe._)`${n}.length`);if(s===!1)e.setParams({len:t.length}),e.pass((0,Qe._)`${i} <= ${t.length}`);else if(typeof s=="object"&&!(0,Pn.alwaysValidSchema)(a,s)){let c=r.var("valid",(0,Qe._)`${i} <= ${t.length}`);r.if((0,Qe.not)(c),()=>u(c)),e.ok(c)}function u(c){r.forRange("i",t.length,i,l=>{e.subschema({keyword:o,dataProp:l,dataPropType:Pn.Type.Num},c),a.allErrors||r.if((0,Qe.not)(c),()=>r.break())})}}sr.validateAdditionalItems=cl;sr.default=H0});var On=d(nr=>{"use strict";Object.defineProperty(nr,"__esModule",{value:!0});nr.validateTuple=void 0;var ll=I(),Ur=D(),G0=me(),J0={keyword:"items",type:"array",schemaType:["object","array","boolean"],before:"uniqueItems",code(e){let{schema:t,it:r}=e;if(Array.isArray(t))return dl(e,"additionalItems",t);r.items=!0,!(0,Ur.alwaysValidSchema)(r,t)&&e.ok((0,G0.validateArray)(e))}};function dl(e,t,r=e.schema){let{gen:s,parentSchema:n,data:o,keyword:a,it:i}=e;l(n),i.opts.unevaluated&&r.length&&i.items!==!0&&(i.items=Ur.mergeEvaluated.items(s,r.length,i.items));let u=s.name("valid"),c=s.const("len",(0,ll._)`${o}.length`);r.forEach((f,_)=>{(0,Ur.alwaysValidSchema)(i,f)||(s.if((0,ll._)`${c} > ${_}`,()=>e.subschema({keyword:a,schemaProp:_,dataProp:_},u)),e.ok(u))});function l(f){let{opts:_,errSchemaPath:m}=i,h=r.length,p=h===f.minItems&&(h===f.maxItems||f[t]===!1);if(_.strictTuples&&!p){let y=`"${a}" is ${h}-tuple, but minItems or maxItems/${t} are not specified or different at path "${m}"`;(0,Ur.checkStrictMode)(i,y,_.strictTuples)}}}nr.validateTuple=dl;nr.default=J0});var fl=d(Tn=>{"use strict";Object.defineProperty(Tn,"__esModule",{value:!0});var W0=On(),X0={keyword:"prefixItems",type:"array",schemaType:["array"],before:"uniqueItems",code:e=>(0,W0.validateTuple)(e,"items")};Tn.default=X0});var hl=d(In=>{"use strict";Object.defineProperty(In,"__esModule",{value:!0});var pl=I(),B0=D(),Y0=me(),Z0=Nn(),Q0={message:({params:{len:e}})=>(0,pl.str)`must NOT have more than ${e} items`,params:({params:{len:e}})=>(0,pl._)`{limit: ${e}}`},e$={keyword:"items",type:"array",schemaType:["object","boolean"],before:"uniqueItems",error:Q0,code(e){let{schema:t,parentSchema:r,it:s}=e,{prefixItems:n}=r;s.items=!0,!(0,B0.alwaysValidSchema)(s,t)&&(n?(0,Z0.validateAdditionalItems)(e,n):e.ok((0,Y0.validateArray)(e)))}};In.default=e$});var ml=d(qn=>{"use strict";Object.defineProperty(qn,"__esModule",{value:!0});var _e=I(),Fr=D(),t$={message:({params:{min:e,max:t}})=>t===void 0?(0,_e.str)`must contain at least ${e} valid item(s)`:(0,_e.str)`must contain at least ${e} and no more than ${t} valid item(s)`,params:({params:{min:e,max:t}})=>t===void 0?(0,_e._)`{minContains: ${e}}`:(0,_e._)`{minContains: ${e}, maxContains: ${t}}`},r$={keyword:"contains",type:"array",schemaType:["object","boolean"],before:"uniqueItems",trackErrors:!0,error:t$,code(e){let{gen:t,schema:r,parentSchema:s,data:n,it:o}=e,a,i,{minContains:u,maxContains:c}=s;o.opts.next?(a=u===void 0?1:u,i=c):a=1;let l=t.const("len",(0,_e._)`${n}.length`);if(e.setParams({min:a,max:i}),i===void 0&&a===0){(0,Fr.checkStrictMode)(o,\'"minContains" == 0 without "maxContains": "contains" keyword ignored\');return}if(i!==void 0&&a>i){(0,Fr.checkStrictMode)(o,\'"minContains" > "maxContains" is always invalid\'),e.fail();return}if((0,Fr.alwaysValidSchema)(o,r)){let p=(0,_e._)`${l} >= ${a}`;i!==void 0&&(p=(0,_e._)`${p} && ${l} <= ${i}`),e.pass(p);return}o.items=!0;let f=t.name("valid");i===void 0&&a===1?m(f,()=>t.if(f,()=>t.break())):a===0?(t.let(f,!0),i!==void 0&&t.if((0,_e._)`${n}.length > 0`,_)):(t.let(f,!1),_()),e.result(f,()=>e.reset());function _(){let p=t.name("_valid"),y=t.let("count",0);m(p,()=>t.if(p,()=>h(y)))}function m(p,y){t.forRange("i",0,l,$=>{e.subschema({keyword:"contains",dataProp:$,dataPropType:Fr.Type.Num,compositeRule:!0},p),y()})}function h(p){t.code((0,_e._)`${p}++`),i===void 0?t.if((0,_e._)`${p} >= ${a}`,()=>t.assign(f,!0).break()):(t.if((0,_e._)`${p} > ${i}`,()=>t.assign(f,!1).break()),a===1?t.assign(f,!0):t.if((0,_e._)`${p} >= ${a}`,()=>t.assign(f,!0)))}}};qn.default=r$});var gl=d(Oe=>{"use strict";Object.defineProperty(Oe,"__esModule",{value:!0});Oe.validateSchemaDeps=Oe.validatePropertyDeps=Oe.error=void 0;var jn=I(),s$=D(),or=me();Oe.error={message:({params:{property:e,depsCount:t,deps:r}})=>{let s=t===1?"property":"properties";return(0,jn.str)`must have ${s} ${r} when property ${e} is present`},params:({params:{property:e,depsCount:t,deps:r,missingProperty:s}})=>(0,jn._)`{property: ${e},\n    missingProperty: ${s},\n    depsCount: ${t},\n    deps: ${r}}`};var n$={keyword:"dependencies",type:"object",schemaType:"object",error:Oe.error,code(e){let[t,r]=o$(e);yl(e,t),_l(e,r)}};function o$({schema:e}){let t={},r={};for(let s in e){if(s==="__proto__")continue;let n=Array.isArray(e[s])?t:r;n[s]=e[s]}return[t,r]}function yl(e,t=e.schema){let{gen:r,data:s,it:n}=e;if(Object.keys(t).length===0)return;let o=r.let("missing");for(let a in t){let i=t[a];if(i.length===0)continue;let u=(0,or.propertyInData)(r,s,a,n.opts.ownProperties);e.setParams({property:a,depsCount:i.length,deps:i.join(", ")}),n.allErrors?r.if(u,()=>{for(let c of i)(0,or.checkReportMissingProp)(e,c)}):(r.if((0,jn._)`${u} && (${(0,or.checkMissingProp)(e,i,o)})`),(0,or.reportMissingProp)(e,o),r.else())}}Oe.validatePropertyDeps=yl;function _l(e,t=e.schema){let{gen:r,data:s,keyword:n,it:o}=e,a=r.name("valid");for(let i in t)(0,s$.alwaysValidSchema)(o,t[i])||(r.if((0,or.propertyInData)(r,s,i,o.opts.ownProperties),()=>{let u=e.subschema({keyword:n,schemaProp:i},a);e.mergeValidEvaluated(u,a)},()=>r.var(a,!0)),e.ok(a))}Oe.validateSchemaDeps=_l;Oe.default=n$});var vl=d(kn=>{"use strict";Object.defineProperty(kn,"__esModule",{value:!0});var $l=I(),a$=D(),i$={message:"property name must be valid",params:({params:e})=>(0,$l._)`{propertyName: ${e.propertyName}}`},u$={keyword:"propertyNames",type:"object",schemaType:["object","boolean"],error:i$,code(e){let{gen:t,schema:r,data:s,it:n}=e;if((0,a$.alwaysValidSchema)(n,r))return;let o=t.name("valid");t.forIn("key",s,a=>{e.setParams({propertyName:a}),e.subschema({keyword:"propertyNames",data:a,dataTypes:["string"],propertyName:a,compositeRule:!0},o),t.if((0,$l.not)(o),()=>{e.error(!0),n.allErrors||t.break()})}),e.ok(o)}};kn.default=u$});var Rn=d(Cn=>{"use strict";Object.defineProperty(Cn,"__esModule",{value:!0});var Kr=me(),be=I(),c$=we(),Hr=D(),l$={message:"must NOT have additional properties",params:({params:e})=>(0,be._)`{additionalProperty: ${e.additionalProperty}}`},d$={keyword:"additionalProperties",type:["object"],schemaType:["boolean","object"],allowUndefined:!0,trackErrors:!0,error:l$,code(e){let{gen:t,schema:r,parentSchema:s,data:n,errsCount:o,it:a}=e;if(!o)throw new Error("ajv implementation error");let{allErrors:i,opts:u}=a;if(a.props=!0,u.removeAdditional!=="all"&&(0,Hr.alwaysValidSchema)(a,r))return;let c=(0,Kr.allSchemaProperties)(s.properties),l=(0,Kr.allSchemaProperties)(s.patternProperties);f(),e.ok((0,be._)`${o} === ${c$.default.errors}`);function f(){t.forIn("key",n,y=>{!c.length&&!l.length?h(y):t.if(_(y),()=>h(y))})}function _(y){let $;if(c.length>8){let j=(0,Hr.schemaRefOrVal)(a,s.properties,"properties");$=(0,Kr.isOwnProperty)(t,j,y)}else c.length?$=(0,be.or)(...c.map(j=>(0,be._)`${y} === ${j}`)):$=be.nil;return l.length&&($=(0,be.or)($,...l.map(j=>(0,be._)`${(0,Kr.usePattern)(e,j)}.test(${y})`))),(0,be.not)($)}function m(y){t.code((0,be._)`delete ${n}[${y}]`)}function h(y){if(u.removeAdditional==="all"||u.removeAdditional&&r===!1){m(y);return}if(r===!1){e.setParams({additionalProperty:y}),e.error(),i||t.break();return}if(typeof r=="object"&&!(0,Hr.alwaysValidSchema)(a,r)){let $=t.name("valid");u.removeAdditional==="failing"?(p(y,$,!1),t.if((0,be.not)($),()=>{e.reset(),m(y)})):(p(y,$),i||t.if((0,be.not)($),()=>t.break()))}}function p(y,$,j){let N={keyword:"additionalProperties",dataProp:y,dataPropType:Hr.Type.Str};j===!1&&Object.assign(N,{compositeRule:!0,createErrors:!1,allErrors:!1}),e.subschema(N,$)}}};Cn.default=d$});var wl=d(Dn=>{"use strict";Object.defineProperty(Dn,"__esModule",{value:!0});var f$=mt(),bl=me(),An=D(),El=Rn(),p$={keyword:"properties",type:"object",schemaType:"object",code(e){let{gen:t,schema:r,parentSchema:s,data:n,it:o}=e;o.opts.removeAdditional==="all"&&s.additionalProperties===void 0&&El.default.code(new f$.KeywordCxt(o,El.default,"additionalProperties"));let a=(0,bl.allSchemaProperties)(r);for(let f of a)o.definedProperties.add(f);o.opts.unevaluated&&a.length&&o.props!==!0&&(o.props=An.mergeEvaluated.props(t,(0,An.toHash)(a),o.props));let i=a.filter(f=>!(0,An.alwaysValidSchema)(o,r[f]));if(i.length===0)return;let u=t.name("valid");for(let f of i)c(f)?l(f):(t.if((0,bl.propertyInData)(t,n,f,o.opts.ownProperties)),l(f),o.allErrors||t.else().var(u,!0),t.endIf()),e.it.definedProperties.add(f),e.ok(u);function c(f){return o.opts.useDefaults&&!o.compositeRule&&r[f].default!==void 0}function l(f){e.subschema({keyword:"properties",schemaProp:f,dataProp:f},u)}}};Dn.default=p$});var Ol=d(Mn=>{"use strict";Object.defineProperty(Mn,"__esModule",{value:!0});var Sl=me(),Gr=I(),Pl=D(),Nl=D(),h$={keyword:"patternProperties",type:"object",schemaType:"object",code(e){let{gen:t,schema:r,data:s,parentSchema:n,it:o}=e,{opts:a}=o,i=(0,Sl.allSchemaProperties)(r),u=i.filter(p=>(0,Pl.alwaysValidSchema)(o,r[p]));if(i.length===0||u.length===i.length&&(!o.opts.unevaluated||o.props===!0))return;let c=a.strictSchema&&!a.allowMatchingProperties&&n.properties,l=t.name("valid");o.props!==!0&&!(o.props instanceof Gr.Name)&&(o.props=(0,Nl.evaluatedPropsToName)(t,o.props));let{props:f}=o;_();function _(){for(let p of i)c&&m(p),o.allErrors?h(p):(t.var(l,!0),h(p),t.if(l))}function m(p){for(let y in c)new RegExp(p).test(y)&&(0,Pl.checkStrictMode)(o,`property ${y} matches pattern ${p} (use allowMatchingProperties)`)}function h(p){t.forIn("key",s,y=>{t.if((0,Gr._)`${(0,Sl.usePattern)(e,p)}.test(${y})`,()=>{let $=u.includes(p);$||e.subschema({keyword:"patternProperties",schemaProp:p,dataProp:y,dataPropType:Nl.Type.Str},l),o.opts.unevaluated&&f!==!0?t.assign((0,Gr._)`${f}[${y}]`,!0):!$&&!o.allErrors&&t.if((0,Gr.not)(l),()=>t.break())})})}}};Mn.default=h$});var Tl=d(xn=>{"use strict";Object.defineProperty(xn,"__esModule",{value:!0});var m$=D(),y$={keyword:"not",schemaType:["object","boolean"],trackErrors:!0,code(e){let{gen:t,schema:r,it:s}=e;if((0,m$.alwaysValidSchema)(s,r)){e.fail();return}let n=t.name("valid");e.subschema({keyword:"not",compositeRule:!0,createErrors:!1,allErrors:!1},n),e.failResult(n,()=>e.reset(),()=>e.error())},error:{message:"must NOT be valid"}};xn.default=y$});var Il=d(Vn=>{"use strict";Object.defineProperty(Vn,"__esModule",{value:!0});var _$=me(),g$={keyword:"anyOf",schemaType:"array",trackErrors:!0,code:_$.validateUnion,error:{message:"must match a schema in anyOf"}};Vn.default=g$});var ql=d(zn=>{"use strict";Object.defineProperty(zn,"__esModule",{value:!0});var Jr=I(),$$=D(),v$={message:"must match exactly one schema in oneOf",params:({params:e})=>(0,Jr._)`{passingSchemas: ${e.passing}}`},b$={keyword:"oneOf",schemaType:"array",trackErrors:!0,error:v$,code(e){let{gen:t,schema:r,parentSchema:s,it:n}=e;if(!Array.isArray(r))throw new Error("ajv implementation error");if(n.opts.discriminator&&s.discriminator)return;let o=r,a=t.let("valid",!1),i=t.let("passing",null),u=t.name("_valid");e.setParams({passing:i}),t.block(c),e.result(a,()=>e.reset(),()=>e.error(!0));function c(){o.forEach((l,f)=>{let _;(0,$$.alwaysValidSchema)(n,l)?t.var(u,!0):_=e.subschema({keyword:"oneOf",schemaProp:f,compositeRule:!0},u),f>0&&t.if((0,Jr._)`${u} && ${a}`).assign(a,!1).assign(i,(0,Jr._)`[${i}, ${f}]`).else(),t.if(u,()=>{t.assign(a,!0),t.assign(i,f),_&&e.mergeEvaluated(_,Jr.Name)})})}}};zn.default=b$});var jl=d(Ln=>{"use strict";Object.defineProperty(Ln,"__esModule",{value:!0});var E$=D(),w$={keyword:"allOf",schemaType:"array",code(e){let{gen:t,schema:r,it:s}=e;if(!Array.isArray(r))throw new Error("ajv implementation error");let n=t.name("valid");r.forEach((o,a)=>{if((0,E$.alwaysValidSchema)(s,o))return;let i=e.subschema({keyword:"allOf",schemaProp:a},n);e.ok(n),e.mergeEvaluated(i)})}};Ln.default=w$});var Rl=d(Un=>{"use strict";Object.defineProperty(Un,"__esModule",{value:!0});var Wr=I(),Cl=D(),S$={message:({params:e})=>(0,Wr.str)`must match "${e.ifClause}" schema`,params:({params:e})=>(0,Wr._)`{failingKeyword: ${e.ifClause}}`},P$={keyword:"if",schemaType:["object","boolean"],trackErrors:!0,error:S$,code(e){let{gen:t,parentSchema:r,it:s}=e;r.then===void 0&&r.else===void 0&&(0,Cl.checkStrictMode)(s,\'"if" without "then" and "else" is ignored\');let n=kl(s,"then"),o=kl(s,"else");if(!n&&!o)return;let a=t.let("valid",!0),i=t.name("_valid");if(u(),e.reset(),n&&o){let l=t.let("ifClause");e.setParams({ifClause:l}),t.if(i,c("then",l),c("else",l))}else n?t.if(i,c("then")):t.if((0,Wr.not)(i),c("else"));e.pass(a,()=>e.error(!0));function u(){let l=e.subschema({keyword:"if",compositeRule:!0,createErrors:!1,allErrors:!1},i);e.mergeEvaluated(l)}function c(l,f){return()=>{let _=e.subschema({keyword:l},i);t.assign(a,i),e.mergeValidEvaluated(_,a),f?t.assign(f,(0,Wr._)`${l}`):e.setParams({ifClause:l})}}}};function kl(e,t){let r=e.schema[t];return r!==void 0&&!(0,Cl.alwaysValidSchema)(e,r)}Un.default=P$});var Al=d(Fn=>{"use strict";Object.defineProperty(Fn,"__esModule",{value:!0});var N$=D(),O$={keyword:["then","else"],schemaType:["object","boolean"],code({keyword:e,parentSchema:t,it:r}){t.if===void 0&&(0,N$.checkStrictMode)(r,`"${e}" without "if" is ignored`)}};Fn.default=O$});var Dl=d(Kn=>{"use strict";Object.defineProperty(Kn,"__esModule",{value:!0});var T$=Nn(),I$=fl(),q$=On(),j$=hl(),k$=ml(),C$=gl(),R$=vl(),A$=Rn(),D$=wl(),M$=Ol(),x$=Tl(),V$=Il(),z$=ql(),L$=jl(),U$=Rl(),F$=Al();function K$(e=!1){let t=[x$.default,V$.default,z$.default,L$.default,U$.default,F$.default,R$.default,A$.default,C$.default,D$.default,M$.default];return e?t.push(I$.default,j$.default):t.push(T$.default,q$.default),t.push(k$.default),t}Kn.default=K$});var Ml=d(Hn=>{"use strict";Object.defineProperty(Hn,"__esModule",{value:!0});var J=I(),H$={message:({schemaCode:e})=>(0,J.str)`must match format "${e}"`,params:({schemaCode:e})=>(0,J._)`{format: ${e}}`},G$={keyword:"format",type:["number","string"],schemaType:"string",$data:!0,error:H$,code(e,t){let{gen:r,data:s,$data:n,schema:o,schemaCode:a,it:i}=e,{opts:u,errSchemaPath:c,schemaEnv:l,self:f}=i;if(!u.validateFormats)return;n?_():m();function _(){let h=r.scopeValue("formats",{ref:f.formats,code:u.code.formats}),p=r.const("fDef",(0,J._)`${h}[${a}]`),y=r.let("fType"),$=r.let("format");r.if((0,J._)`typeof ${p} == "object" && !(${p} instanceof RegExp)`,()=>r.assign(y,(0,J._)`${p}.type || "string"`).assign($,(0,J._)`${p}.validate`),()=>r.assign(y,(0,J._)`"string"`).assign($,p)),e.fail$data((0,J.or)(j(),N()));function j(){return u.strictSchema===!1?J.nil:(0,J._)`${a} && !${$}`}function N(){let V=l.$async?(0,J._)`(${p}.async ? await ${$}(${s}) : ${$}(${s}))`:(0,J._)`${$}(${s})`,S=(0,J._)`(typeof ${$} == "function" ? ${V} : ${$}.test(${s}))`;return(0,J._)`${$} && ${$} !== true && ${y} === ${t} && !${S}`}}function m(){let h=f.formats[o];if(!h){j();return}if(h===!0)return;let[p,y,$]=N(h);p===t&&e.pass(V());function j(){if(u.strictSchema===!1){f.logger.warn(S());return}throw new Error(S());function S(){return`unknown format "${o}" ignored in schema at path "${c}"`}}function N(S){let v=S instanceof RegExp?(0,J.regexpCode)(S):u.code.formats?(0,J._)`${u.code.formats}${(0,J.getProperty)(o)}`:void 0,E=r.scopeValue("formats",{key:o,ref:S,code:v});return typeof S=="object"&&!(S instanceof RegExp)?[S.type||"string",S.validate,(0,J._)`${E}.validate`]:["string",S,E]}function V(){if(typeof h=="object"&&!(h instanceof RegExp)&&h.async){if(!l.$async)throw new Error("async format in sync schema");return(0,J._)`await ${$}(${s})`}return typeof y=="function"?(0,J._)`${$}(${s})`:(0,J._)`${$}.test(${s})`}}}};Hn.default=G$});var xl=d(Gn=>{"use strict";Object.defineProperty(Gn,"__esModule",{value:!0});var J$=Ml(),W$=[J$.default];Gn.default=W$});var Vl=d($t=>{"use strict";Object.defineProperty($t,"__esModule",{value:!0});$t.contentVocabulary=$t.metadataVocabulary=void 0;$t.metadataVocabulary=["title","description","default","deprecated","readOnly","writeOnly","examples"];$t.contentVocabulary=["contentMediaType","contentEncoding","contentSchema"]});var Ll=d(Jn=>{"use strict";Object.defineProperty(Jn,"__esModule",{value:!0});var X$=Wc(),B$=ul(),Y$=Dl(),Z$=xl(),zl=Vl(),Q$=[X$.default,B$.default,(0,Y$.default)(),Z$.default,zl.metadataVocabulary,zl.contentVocabulary];Jn.default=Q$});var Fl=d(Xr=>{"use strict";Object.defineProperty(Xr,"__esModule",{value:!0});Xr.DiscrError=void 0;var Ul;(function(e){e.Tag="tag",e.Mapping="mapping"})(Ul||(Xr.DiscrError=Ul={}))});var Hl=d(Xn=>{"use strict";Object.defineProperty(Xn,"__esModule",{value:!0});var vt=I(),Wn=Fl(),Kl=jr(),ev=Gt(),tv=D(),rv={message:({params:{discrError:e,tagName:t}})=>e===Wn.DiscrError.Tag?`tag "${t}" must be string`:`value of tag "${t}" must be in oneOf`,params:({params:{discrError:e,tag:t,tagName:r}})=>(0,vt._)`{error: ${e}, tag: ${r}, tagValue: ${t}}`},sv={keyword:"discriminator",type:"object",schemaType:"object",error:rv,code(e){let{gen:t,data:r,schema:s,parentSchema:n,it:o}=e,{oneOf:a}=n;if(!o.opts.discriminator)throw new Error("discriminator: requires discriminator option");let i=s.propertyName;if(typeof i!="string")throw new Error("discriminator: requires propertyName");if(s.mapping)throw new Error("discriminator: mapping is not supported");if(!a)throw new Error("discriminator: requires oneOf keyword");let u=t.let("valid",!1),c=t.const("tag",(0,vt._)`${r}${(0,vt.getProperty)(i)}`);t.if((0,vt._)`typeof ${c} == "string"`,()=>l(),()=>e.error(!1,{discrError:Wn.DiscrError.Tag,tag:c,tagName:i})),e.ok(u);function l(){let m=_();t.if(!1);for(let h in m)t.elseIf((0,vt._)`${c} === ${h}`),t.assign(u,f(m[h]));t.else(),e.error(!1,{discrError:Wn.DiscrError.Mapping,tag:c,tagName:i}),t.endIf()}function f(m){let h=t.name("valid"),p=e.subschema({keyword:"oneOf",schemaProp:m},h);return e.mergeEvaluated(p,vt.Name),h}function _(){var m;let h={},p=$(n),y=!0;for(let V=0;V<a.length;V++){let S=a[V];if(S!=null&&S.$ref&&!(0,tv.schemaHasRulesButRef)(S,o.self.RULES)){let E=S.$ref;if(S=Kl.resolveRef.call(o.self,o.schemaEnv.root,o.baseId,E),S instanceof Kl.SchemaEnv&&(S=S.schema),S===void 0)throw new ev.default(o.opts.uriResolver,o.baseId,E)}let v=(m=S==null?void 0:S.properties)===null||m===void 0?void 0:m[i];if(typeof v!="object")throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${i}"`);y=y&&(p||$(S)),j(v,V)}if(!y)throw new Error(`discriminator: "${i}" must be required`);return h;function $({required:V}){return Array.isArray(V)&&V.includes(i)}function j(V,S){if(V.const)N(V.const,S);else if(V.enum)for(let v of V.enum)N(v,S);else throw new Error(`discriminator: "properties/${i}" must have "const" or "enum"`)}function N(V,S){if(typeof V!="string"||V in h)throw new Error(`discriminator: "${i}" values must be unique strings`);h[V]=S}}}};Xn.default=sv});var Gl=d((Sw,nv)=>{nv.exports={$schema:"http://json-schema.org/draft-07/schema#",$id:"http://json-schema.org/draft-07/schema#",title:"Core schema meta-schema",definitions:{schemaArray:{type:"array",minItems:1,items:{$ref:"#"}},nonNegativeInteger:{type:"integer",minimum:0},nonNegativeIntegerDefault0:{allOf:[{$ref:"#/definitions/nonNegativeInteger"},{default:0}]},simpleTypes:{enum:["array","boolean","integer","null","number","object","string"]},stringArray:{type:"array",items:{type:"string"},uniqueItems:!0,default:[]}},type:["object","boolean"],properties:{$id:{type:"string",format:"uri-reference"},$schema:{type:"string",format:"uri"},$ref:{type:"string",format:"uri-reference"},$comment:{type:"string"},title:{type:"string"},description:{type:"string"},default:!0,readOnly:{type:"boolean",default:!1},examples:{type:"array",items:!0},multipleOf:{type:"number",exclusiveMinimum:0},maximum:{type:"number"},exclusiveMaximum:{type:"number"},minimum:{type:"number"},exclusiveMinimum:{type:"number"},maxLength:{$ref:"#/definitions/nonNegativeInteger"},minLength:{$ref:"#/definitions/nonNegativeIntegerDefault0"},pattern:{type:"string",format:"regex"},additionalItems:{$ref:"#"},items:{anyOf:[{$ref:"#"},{$ref:"#/definitions/schemaArray"}],default:!0},maxItems:{$ref:"#/definitions/nonNegativeInteger"},minItems:{$ref:"#/definitions/nonNegativeIntegerDefault0"},uniqueItems:{type:"boolean",default:!1},contains:{$ref:"#"},maxProperties:{$ref:"#/definitions/nonNegativeInteger"},minProperties:{$ref:"#/definitions/nonNegativeIntegerDefault0"},required:{$ref:"#/definitions/stringArray"},additionalProperties:{$ref:"#"},definitions:{type:"object",additionalProperties:{$ref:"#"},default:{}},properties:{type:"object",additionalProperties:{$ref:"#"},default:{}},patternProperties:{type:"object",additionalProperties:{$ref:"#"},propertyNames:{format:"regex"},default:{}},dependencies:{type:"object",additionalProperties:{anyOf:[{$ref:"#"},{$ref:"#/definitions/stringArray"}]}},propertyNames:{$ref:"#"},const:!0,enum:{type:"array",items:!0,minItems:1,uniqueItems:!0},type:{anyOf:[{$ref:"#/definitions/simpleTypes"},{type:"array",items:{$ref:"#/definitions/simpleTypes"},minItems:1,uniqueItems:!0}]},format:{type:"string"},contentMediaType:{type:"string"},contentEncoding:{type:"string"},if:{$ref:"#"},then:{$ref:"#"},else:{$ref:"#"},allOf:{$ref:"#/definitions/schemaArray"},anyOf:{$ref:"#/definitions/schemaArray"},oneOf:{$ref:"#/definitions/schemaArray"},not:{$ref:"#"}},default:!0}});var Yn=d((K,Bn)=>{"use strict";Object.defineProperty(K,"__esModule",{value:!0});K.MissingRefError=K.ValidationError=K.CodeGen=K.Name=K.nil=K.stringify=K.str=K._=K.KeywordCxt=K.Ajv=void 0;var ov=Uc(),av=Ll(),iv=Hl(),Jl=Gl(),uv=["/properties"],Br="http://json-schema.org/draft-07/schema",bt=class extends ov.default{_addVocabularies(){super._addVocabularies(),av.default.forEach(t=>this.addVocabulary(t)),this.opts.discriminator&&this.addKeyword(iv.default)}_addDefaultMetaSchema(){if(super._addDefaultMetaSchema(),!this.opts.meta)return;let t=this.opts.$data?this.$dataMetaSchema(Jl,uv):Jl;this.addMetaSchema(t,Br,!1),this.refs["http://json-schema.org/schema"]=Br}defaultMeta(){return this.opts.defaultMeta=super.defaultMeta()||(this.getSchema(Br)?Br:void 0)}};K.Ajv=bt;Bn.exports=K=bt;Bn.exports.Ajv=bt;Object.defineProperty(K,"__esModule",{value:!0});K.default=bt;var cv=mt();Object.defineProperty(K,"KeywordCxt",{enumerable:!0,get:function(){return cv.KeywordCxt}});var Et=I();Object.defineProperty(K,"_",{enumerable:!0,get:function(){return Et._}});Object.defineProperty(K,"str",{enumerable:!0,get:function(){return Et.str}});Object.defineProperty(K,"stringify",{enumerable:!0,get:function(){return Et.stringify}});Object.defineProperty(K,"nil",{enumerable:!0,get:function(){return Et.nil}});Object.defineProperty(K,"Name",{enumerable:!0,get:function(){return Et.Name}});Object.defineProperty(K,"CodeGen",{enumerable:!0,get:function(){return Et.CodeGen}});var lv=Ir();Object.defineProperty(K,"ValidationError",{enumerable:!0,get:function(){return lv.default}});var dv=Gt();Object.defineProperty(K,"MissingRefError",{enumerable:!0,get:function(){return dv.default}})});var Yl=d((Qn,eo)=>{"use strict";Object.defineProperty(Qn,"__esModule",{value:!0});var g=Yn(),ze=I(),Wl=at(),fv=mt(),ar=ct(),Ee=we(),Yr="errorMessage",Le=new g.Name("emUsed"),Xl={required:"missingProperty",dependencies:"property",dependentRequired:"property"},Bl=/\\$\\{[^}]+\\}/,pv=/\\$\\{([^}]+)\\}/g,hv=/^""\\s*\\+\\s*|\\s*\\+\\s*""$/g;function mv(e){return{keyword:Yr,schemaType:["string","object"],post:!0,code(t){let{gen:r,data:s,schema:n,schemaValue:o,it:a}=t;if(a.createErrors===!1)return;let i=n,u=ze.strConcat(Ee.default.instancePath,a.errorPath);r.if(g._`${Ee.default.errors} > 0`,()=>{if(typeof i=="object"){let[E,O]=l(i);O&&f(O),E&&_(E),m(c(i))}let v=typeof i=="string"?i:i._;v&&h(v),e.keepErrors||p()});function c({properties:v,items:E}){let O={};if(v){O.props={};for(let x in v)O.props[x]=[]}if(E){O.items={};for(let x=0;x<E.length;x++)O.items[x]=[]}return O}function l(v){let E,O;for(let x in v){if(x==="properties"||x==="items")continue;let H=v[x];if(typeof H=="object"){E||(E={});let G=E[x]={};for(let k in H)G[k]=[]}else O||(O={}),O[x]=[]}return[E,O]}function f(v){let E=r.const("emErrors",g.stringify(v)),O=r.const("templates",N(v,n));r.forOf("err",Ee.default.vErrors,k=>r.if(y(k,E),()=>r.code(g._`${E}[${k}.keyword].push(${k})`).assign(g._`${k}.${Le}`,!0)));let{singleError:x}=e;if(x){let k=r.let("message",g._`""`),M=r.let("paramsErrors",g._`[]`);H(fe=>{r.if(k,()=>r.code(g._`${k} += ${typeof x=="string"?x:";"}`)),r.code(g._`${k} += ${G(fe)}`),r.assign(M,g._`${M}.concat(${E}[${fe}])`)}),ar.reportError(t,{message:k,params:g._`{errors: ${M}}`})}else H(k=>ar.reportError(t,{message:G(k),params:g._`{errors: ${E}[${k}]}`}));function H(k){r.forIn("key",E,M=>r.if(g._`${E}[${M}].length`,()=>k(M)))}function G(k){return g._`${k} in ${O} ? ${O}[${k}]() : ${o}[${k}]`}}function _(v){let E=r.const("emErrors",g.stringify(v)),O=[];for(let M in v)O.push([M,N(v[M],n[M])]);let x=r.const("templates",r.object(...O)),H=r.scopeValue("obj",{ref:Xl,code:g.stringify(Xl)}),G=r.let("emPropParams"),k=r.let("emParamsErrors");r.forOf("err",Ee.default.vErrors,M=>r.if(y(M,E),()=>{r.assign(G,g._`${H}[${M}.keyword]`),r.assign(k,g._`${E}[${M}.keyword][${M}.params[${G}]]`),r.if(k,()=>r.code(g._`${k}.push(${M})`).assign(g._`${M}.${Le}`,!0))})),r.forIn("key",E,M=>r.forIn("keyProp",g._`${E}[${M}]`,fe=>{r.assign(k,g._`${E}[${M}][${fe}]`),r.if(g._`${k}.length`,()=>{let Ue=r.const("tmpl",g._`${x}[${M}] && ${x}[${M}][${fe}]`);ar.reportError(t,{message:g._`${Ue} ? ${Ue}() : ${o}[${M}][${fe}]`,params:g._`{errors: ${k}}`})})}))}function m(v){let{props:E,items:O}=v;if(!E&&!O)return;let x=g._`typeof ${s} == "object"`,H=g._`Array.isArray(${s})`,G=r.let("emErrors"),k,M,fe=r.let("templates");E&&O?(k=r.let("emChildKwd"),r.if(x),r.if(H,()=>{Ue(O,n.items),r.assign(k,g.str`items`)},()=>{Ue(E,n.properties),r.assign(k,g.str`properties`)}),M=g._`[${k}]`):O?(r.if(H),Ue(O,n.items),M=g._`.items`):E&&(r.if(ze.and(x,ze.not(H))),Ue(E,n.properties),M=g._`.properties`),r.forOf("err",Ee.default.vErrors,ce=>$(ce,G,es=>r.code(g._`${G}[${es}].push(${ce})`).assign(g._`${ce}.${Le}`,!0))),r.forIn("key",G,ce=>r.if(g._`${G}[${ce}].length`,()=>{ar.reportError(t,{message:g._`${ce} in ${fe} ? ${fe}[${ce}]() : ${o}${M}[${ce}]`,params:g._`{errors: ${G}[${ce}]}`}),r.assign(g._`${Ee.default.vErrors}[${Ee.default.errors}-1].instancePath`,g._`${u} + "/" + ${ce}.replace(/~/g, "~0").replace(/\\\\//g, "~1")`)})),r.endIf();function Ue(ce,es){r.assign(G,g.stringify(ce)),r.assign(fe,N(ce,es))}}function h(v){let E=r.const("emErrs",g._`[]`);r.forOf("err",Ee.default.vErrors,O=>r.if(j(O),()=>r.code(g._`${E}.push(${O})`).assign(g._`${O}.${Le}`,!0))),r.if(g._`${E}.length`,()=>ar.reportError(t,{message:V(v),params:g._`{errors: ${E}}`}))}function p(){let v=r.const("emErrs",g._`[]`);r.forOf("err",Ee.default.vErrors,E=>r.if(g._`!${E}.${Le}`,()=>r.code(g._`${v}.push(${E})`))),r.assign(Ee.default.vErrors,v).assign(Ee.default.errors,g._`${v}.length`)}function y(v,E){return ze.and(g._`${v}.keyword !== ${Yr}`,g._`!${v}.${Le}`,g._`${v}.instancePath === ${u}`,g._`${v}.keyword in ${E}`,g._`${v}.schemaPath.indexOf(${a.errSchemaPath}) === 0`,g._`/^\\\\/[^\\\\/]*$/.test(${v}.schemaPath.slice(${a.errSchemaPath.length}))`)}function $(v,E,O){r.if(ze.and(g._`${v}.keyword !== ${Yr}`,g._`!${v}.${Le}`,g._`${v}.instancePath.indexOf(${u}) === 0`),()=>{let x=r.scopeValue("pattern",{ref:/^\\/([^/]*)(?:\\/|$)/,code:g._`new RegExp("^\\\\\\/([^/]*)(?:\\\\\\/|$)")`}),H=r.const("emMatches",g._`${x}.exec(${v}.instancePath.slice(${u}.length))`),G=r.const("emChild",g._`${H} && ${H}[1].replace(/~1/g, "/").replace(/~0/g, "~")`);r.if(g._`${G} !== undefined && ${G} in ${E}`,()=>O(G))})}function j(v){return ze.and(g._`${v}.keyword !== ${Yr}`,g._`!${v}.${Le}`,ze.or(g._`${v}.instancePath === ${u}`,ze.and(g._`${v}.instancePath.indexOf(${u}) === 0`,g._`${v}.instancePath[${u}.length] === "/"`)),g._`${v}.schemaPath.indexOf(${a.errSchemaPath}) === 0`,g._`${v}.schemaPath[${a.errSchemaPath}.length] === "/"`)}function N(v,E){let O=[];for(let x in v){let H=E[x];Bl.test(H)&&O.push([x,S(H)])}return r.object(...O)}function V(v){return Bl.test(v)?new Wl._Code(Wl.safeStringify(v).replace(pv,(E,O)=>`" + JSON.stringify(${fv.getData(O,a)}) + "`).replace(hv,"")):g.stringify(v)}function S(v){return g._`function(){return ${V(v)}}`}},metaSchema:{anyOf:[{type:"string"},{type:"object",properties:{properties:{$ref:"#/$defs/stringMap"},items:{$ref:"#/$defs/stringList"},required:{$ref:"#/$defs/stringOrMap"},dependencies:{$ref:"#/$defs/stringOrMap"}},additionalProperties:{type:"string"}}],$defs:{stringMap:{type:"object",additionalProperties:{type:"string"}},stringOrMap:{anyOf:[{type:"string"},{$ref:"#/$defs/stringMap"}]},stringList:{type:"array",items:{type:"string"}}}}}}var Zn=(e,t={})=>{if(!e.opts.allErrors)throw new Error("ajv-errors: Ajv option allErrors must be true");if(e.opts.jsPropertySyntax)throw new Error("ajv-errors: ajv option jsPropertySyntax is not supported");return e.addKeyword(mv(t))};Qn.default=Zn;eo.exports=Zn;eo.exports.default=Zn});var wo=pe(Te());var X=pe(Te()),ao=(0,X._)("Error: Token duplicated across multiple inputs"),io=(0,X._)("Error: Item duplicated in layout structure"),uo=(0,X._)("Error: Input duplicated in both layout structure and global inputs"),co=(0,X._)("Error: Input in layout structure does not exist"),lo=(0,X._)("Error: Input in global input structure does not exist"),fo=(0,X._)("Error: Input is not present in the global inputs structure or layout structure"),po=(0,X._)("Error: Visualization in layout structure does not exist"),ho=(0,X._)("Error: Visualization is not present in layout structure"),mo=(0,X._)("When a data source is unnamed, generated tokens for the search results and job status will not be available"),yo=(0,X._)("When a data source is configured with an invalid name, generated tokens for the search results and job status will not be available"),_o=(0,X._)("When multiple data sources have the same name, generated tokens for the search results and job status may be unpredictable"),go=(0,X._)("Error: Layout id is not present in layoutDefinitions"),$o=(0,X._)("Error: Layout id duplicated across multiple tabs"),vo=(0,X._)(\'Error: Multiple conditions are configured with the name "%(conditionName)s"\'),bo=(0,X._)("Since the condition name is used as a token, there can be no duplicate names"),Eo=(0,X._)("Condition %(id)s cannot be used in both showConditions and hideConditions configurations for the same dashboard element");var gd=Object.freeze({}),So=e=>{let t={},r=[],{inputs:s}=e;return Object.entries(s!=null?s:{}).forEach(([n,o])=>{let{token:a}=o.options||gd;a!==void 0&&(a in t?t[a].push(n):t[a]=[n])}),Object.entries(t).forEach(([n,o])=>{if(o.length>1){let a=o[o.length-1],i=o.slice(0,-1).join(", ");r.push({instancePath:ao,message:(0,wo._)(`${i} and ${a} have the same token (${n})`)})}}),r};var ur=pe(Te());var wt=e=>!!e&&!Array.isArray(e)&&typeof e=="object";var $d=e=>Array.isArray(e)&&e.filter(t=>t!==void 0).length===0,vd=e=>wt(e)&&Object.keys(e).length===0,ir=e=>e===null||typeof e=="undefined"||typeof e=="string"&&!e||typeof e!="string"&&typeof e!="object"||$d(e)||vd(e);var bd=e=>{var t,r;return(r=(t=e.layout)==null?void 0:t.globalInputs)!=null?r:[]},Ed=e=>{var s,n;let t=(n=(s=e.layout)==null?void 0:s.layoutDefinitions)!=null?n:{},r=new Set;return Object.values(t).forEach(o=>{var a,i;!Array.isArray(o.structure)||!((i=(a=o.structure)==null?void 0:a[0])!=null&&i.item)||o.structure.forEach(u=>{u.type==="input"&&r.add(u.item)})}),r},wd=e=>{var t;return Object.keys((t=e.inputs)!=null?t:{})},Po=e=>{var a;let t=wd(e),r=(a=e.inputs)!=null?a:{},s=bd(e),n=Ed(e),o=[];return t.forEach(i=>{!s.includes(i)&&!n.has(i)&&o.push({instancePath:fo,message:(0,ur._)(`Input "${i}" is defined but not used in either the Global Inputs Structure or in any Layout Structure`)})}),s.forEach((i,u)=>{ir(r[i])&&o.push({instancePath:lo,message:(0,ur._)(`Input item ${u} references an input "${i}" that does not exist`)}),n.has(i)&&o.push({instancePath:uo,message:(0,ur._)(`Input "${i}" exists in both layout structure and global inputs`)})}),o};var mr=pe(hr()),yr=pe(Te());var Vm=({dataSource:e})=>{var t;return e.name||((t=e.options)==null?void 0:t.ref)},zm=(e,t)=>!t.has(e)&&/^([ \\w-.]+)$/.test(e)&&e!=="default",du=(e,t=[])=>{let{dataSources:r={}}=e,s=new Set(t),n=new Set,o=new Set;return Object.keys(r).reduce((a,i)=>{var c;if(!((c=r[i].options)!=null&&c.enableSmartSources))return a;let u=Vm({dataSource:r[i]});return u?(zm(u,s)?n.has(u)&&!o.has(u)&&(a.push({instancePath:(0,mr.sprintf)((0,yr._)(\'Error: Multiple data sources are configured with the name "%(dsName)s"\'),{dsName:u}),message:_o}),o.add(u)):a.push({instancePath:(0,mr.sprintf)((0,yr._)(\'Error: The data source "%(dsName)s" has an invalid name\'),{dsName:u}),message:yo}),n.add(u),a):(a.push({instancePath:(0,mr.sprintf)((0,yr._)(\'Error: The data source "%(dsId)s" is unnamed\'),{dsId:i}),message:mo}),a)},[])};var fu=pe(Te());var pu=e=>{var n,o,a,i,u;let t=[],r=(a=(o=(n=e.layout)==null?void 0:n.tabs)==null?void 0:o.items)!=null?a:[],s=(u=(i=e.layout)==null?void 0:i.layoutDefinitions)!=null?u:{};return r.forEach(({layoutId:c})=>{typeof s[c]=="undefined"&&t.push({instancePath:go,message:(0,fu._)(`Layout "${c}" does not reference an existing layout definition`)})}),t};var Rt=pe(Te());var Lm=e=>{var s,n;let t=(n=(s=e.layout)==null?void 0:s.layoutDefinitions)!=null?n:{},r=new Set;return Object.values(t).forEach(o=>{var a,i;!Array.isArray(o.structure)||!((i=(a=o.structure)==null?void 0:a[0])!=null&&i.item)||o.structure.forEach(u=>{u.type!=="input"&&r.add(u.item)})}),r},Um=({visualizations:e,inputs:t,layoutId:r,layoutDefinition:s,errors:n})=>{var i,u;let o=new Set;if(!Array.isArray(s.structure)||!((u=(i=s.structure)==null?void 0:i[0])!=null&&u.item))return;s.structure.forEach((c,l)=>{o.has(c.item)&&n.push({instancePath:io,message:(0,Rt._)(`Structure item ${l} has the same key "${c.item}" as another structure item in layout ${r}`)}),c.type!=="input"&&!wt(e==null?void 0:e[c.item])&&n.push({instancePath:po,message:(0,Rt._)(`Structure item ${l} references a visualization "${c.item}" that does not exist in layout ${r}`)}),c.type==="input"&&!wt(t==null?void 0:t[c.item])&&n.push({instancePath:co,message:(0,Rt._)(`Structure item ${l} references an input "${c.item}" that does not exist in layout ${r}`)}),o.add(c.item)})},hu=e=>{var a,i,u,c;let t=[],r=(a=e.visualizations)!=null?a:{},s=(i=e.inputs)!=null?i:{},n=(c=(u=e.layout)==null?void 0:u.layoutDefinitions)!=null?c:{},o=Lm(e);return Object.entries(n).forEach(([l,f])=>Um({visualizations:r,inputs:s,layoutId:l,layoutDefinition:f,errors:t})),Object.keys(r).forEach(l=>{o.has(l)||t.push({instancePath:ho,message:(0,Rt._)(`Visualization "${l}" is not present in any Layout Structure`)})}),t};var fs=pe(Te());var mu=e=>{var n,o,a;let t={},r=[];return((a=(o=(n=e.layout)==null?void 0:n.tabs)==null?void 0:o.items)!=null?a:[]).forEach(({layoutId:i,label:u})=>{var l;let c=u!=null?u:(0,fs._)("[Unnamed Tab]");i!==void 0&&((l=t[i])!=null||(t[i]=[]),t[i].push(c))}),Object.entries(t).forEach(([i,u])=>{if(u.length>1){let c=u[u.length-1],l=u.slice(0,-1).join(", ");r.push({instancePath:$o,message:(0,fs._)(`${l} and ${c} have the same layout (${i})`)})}}),r};var Ql=pe(Yn()),ed=pe(Yl());var Zl=(e,t)=>{let r={};return(...s)=>{let n=t(...s);return r[n]||(r[n]=e(...s)),r[n]}};var Zr=new Ql.default({allErrors:!0,allowMatchingProperties:!0,allowUnionTypes:!0,code:{optimize:typeof Worker=="undefined"?!1:1}});(0,ed.default)(Zr);var td=Zl(e=>(e!=null&&e.$id&&Zr.getSchema(e.$id)&&Zr.removeSchema(e.$id),Zr.compile(e)),JSON.stringify);var rd=pe(hr());var sd=e=>{var n,o;let t=(o=(n=e.expressions)==null?void 0:n.conditions)!=null?o:{},r=new Set,s=new Set;return Object.keys(t).reduce((a,i)=>{let u=t[i];return u.name&&(r.has(u.name)&&!s.has(u.name)&&(a.push({instancePath:(0,rd.sprintf)(vo,{conditionName:u.name}),message:bo}),s.add(u.name)),r.add(u.name)),a},[])};var od=pe(hr());var yv=e=>Array.isArray(e==null?void 0:e.showConditions)&&(Array.isArray(e==null?void 0:e.conditions)||Array.isArray(e==null?void 0:e.hideConditions)),_v=e=>{if(!yv(e))return[];let{showConditions:t,hideConditions:r,conditions:s}=e,n=new Set([...r!=null?r:[],...s!=null?s:[]]);return(t!=null?t:[]).reduce((o,a,i)=>(n.has(a)&&o.push([a,i]),o),[])},nd=({stanza:e,stanzaName:t})=>{let r=[];return Object.entries(e!=null?e:{}).forEach(([s,n])=>{var u;let o=(u=n==null?void 0:n.containerOptions)==null?void 0:u.visibility,a=_v(o);if(!a.length)return;let i=`/${t}/${s}/containerOptions/visibility/showConditions`;a.forEach(([c,l])=>{r.push({instancePath:`${i}/${l}`,message:(0,od.sprintf)(Eo,{id:c})})})}),r},ad=e=>[...nd({stanza:e.inputs,stanzaName:"inputs"}),...nd({stanza:e.visualizations,stanzaName:"visualizations"})];var Qr=class{constructor(){this.validateDefinition=null}setSchema(t){if(!(t!=null&&t.$id))return null;try{this.validateDefinition=td(t)}catch(r){return r}return null}validate(t,r){var o,a;if(!this.validateDefinition)throw new Error("setSchema must be called first");if(!this.validateDefinition(t)&&((a=(o=this.validateDefinition)==null?void 0:o.errors)!=null&&a.length))return this.validateDefinition.errors;let n=[...So(t),...hu(t),...Po(t),...du(t,r),...pu(t),...mu(t),...sd(t),...ad(t)];return ir(n)?null:n}};var id=e=>{let{schema:t,definition:r,readOnlyTokenNamespaces:s}=e.data,n=new Qr,o=n.setSchema(t);return o||n.validate(r,s)};var gv=self,$v=e=>postMessage(id(e));gv.addEventListener("message",$v);\n'], { type: "text/javascript" }));
      const worker = new Worker(url);
      URL.revokeObjectURL(url);
      return worker;
    }
    var i18n_exports = {};
    __export2(i18n_exports, {
      default: () => i18n_default
    });
    var defaultImport2 = __toESM2(require_i18n());
    __reExport(i18n_exports, require_i18n());
    var i18n_default = "default" in defaultImport2 ? defaultImport2.default : defaultImport2;
    var DUPLICATE_INPUT_TOKEN = (0, i18n_exports._)(
      "Error: Token duplicated across multiple inputs"
    );
    var DUPLICATE_ITEM = (0, i18n_exports._)("Error: Item duplicated in layout structure");
    var DUPLICATE_INPUT = (0, i18n_exports._)(
      "Error: Input duplicated in both layout structure and global inputs"
    );
    var CANVAS_INPUT_NONEXISTENT = (0, i18n_exports._)(
      "Error: Input in layout structure does not exist"
    );
    var GLOBAL_INPUT_NONEXISTENT = (0, i18n_exports._)(
      "Error: Input in global input structure does not exist"
    );
    var GLOBAL_INPUT_NOT_PRESENT = (0, i18n_exports._)(
      "Error: Input is not present in the global inputs structure or layout structure"
    );
    var VISUALIZATION_NONEXISTENT = (0, i18n_exports._)(
      "Error: Visualization in layout structure does not exist"
    );
    var VISUALIZATION_NOT_PRESENT = (0, i18n_exports._)(
      "Error: Visualization is not present in layout structure"
    );
    var CANNOT_CREATE_DS_TOKENS_UNNAMED = (0, i18n_exports._)(
      "When a data source is unnamed, generated tokens for the search results and job status will not be available"
    );
    var CANNOT_CREATE_DS_TOKENS_INVALID = (0, i18n_exports._)(
      "When a data source is configured with an invalid name, generated tokens for the search results and job status will not be available"
    );
    var CANNOT_ENSURE_DS_TOKEN_STABILITY = (0, i18n_exports._)(
      "When multiple data sources have the same name, generated tokens for the search results and job status may be unpredictable"
    );
    var LAYOUT_ID_NONEXISTENT = (0, i18n_exports._)(
      "Error: Layout id is not present in layoutDefinitions"
    );
    var DUPLICATE_LAYOUT_ID = (0, i18n_exports._)(
      "Error: Layout id duplicated across multiple tabs"
    );
    var DUPLICATE_CONDITION_NAME_PATH = (0, i18n_exports._)(
      'Error: Multiple conditions are configured with the name "%(conditionName)s"'
    );
    var DUPLICATE_CONDITION_NAME_MESSAGE = (0, i18n_exports._)(
      "Since the condition name is used as a token, there can be no duplicate names"
    );
    var CONDITION_USED_FOR_SHOW_AND_HIDE_MESSAGE = (0, i18n_exports._)(
      "Condition %(id)s cannot be used in both showConditions and hideConditions configurations for the same dashboard element"
    );
    var EmptyInputOptions = Object.freeze({});
    var checkDuplicateTokens = (definition) => {
      const cache = {};
      const errors = [];
      const { inputs } = definition;
      Object.entries(inputs != null ? inputs : {}).forEach(([key2, input]) => {
        const { token } = input.options || EmptyInputOptions;
        if (token === void 0) {
          return;
        }
        if (token in cache) {
          cache[token].push(key2);
        } else {
          cache[token] = [key2];
        }
      });
      Object.entries(cache).forEach(([token, keys]) => {
        if (keys.length > 1) {
          const lastKey = keys[keys.length - 1];
          const msg = keys.slice(0, -1).join(", ");
          errors.push({
            instancePath: DUPLICATE_INPUT_TOKEN,
            message: (0, i18n_exports._)(
              `${msg} and ${lastKey} have the same token (${token})`
            )
          });
        }
      });
      return errors;
    };
    var isPlainObject = (val) => !!val && !Array.isArray(val) && typeof val === "object";
    var isEmptyArray = (val) => Array.isArray(val) && val.filter((v) => v !== void 0).length === 0;
    var isEmptyObject = (val) => isPlainObject(val) && Object.keys(val).length === 0;
    var isEmpty = (val) => val === null || // null
    typeof val === "undefined" || // undefined
    typeof val === "string" && !val || // Empty string
    typeof val !== "string" && typeof val !== "object" || // Non-object/non-string (things such as functions)
    isEmptyArray(val) || // Empty array or array with only `undefined` elements
    isEmptyObject(val);
    var getGlobalInputIds = (definition) => {
      var _a, _b;
      return (_b = (_a = definition.layout) == null ? void 0 : _a.globalInputs) != null ? _b : [];
    };
    var getLayoutInputIds = (definition) => {
      var _a, _b;
      const layouts = (_b = (_a = definition.layout) == null ? void 0 : _a.layoutDefinitions) != null ? _b : {};
      const inputIds = /* @__PURE__ */ new Set();
      Object.values(layouts).forEach((layout) => {
        var _a2, _b2;
        if (!Array.isArray(layout.structure) || !((_b2 = (_a2 = layout.structure) == null ? void 0 : _a2[0]) == null ? void 0 : _b2.item)) {
          return;
        }
        layout.structure.forEach((item) => {
          if (item.type === "input") {
            inputIds.add(item.item);
          }
        });
      });
      return inputIds;
    };
    var getInputStanzaIds = (definition) => {
      var _a;
      return Object.keys((_a = definition.inputs) != null ? _a : {});
    };
    var checkInputsInStructure = (definition) => {
      var _a;
      const inputIds = getInputStanzaIds(definition);
      const inputs = (_a = definition.inputs) != null ? _a : {};
      const globalInputs = getGlobalInputIds(definition);
      const layoutInputIds = getLayoutInputIds(definition);
      const errors = [];
      inputIds.forEach((inputId) => {
        if (!globalInputs.includes(inputId) && !layoutInputIds.has(inputId)) {
          errors.push({
            instancePath: GLOBAL_INPUT_NOT_PRESENT,
            message: (0, i18n_exports._)(
              `Input "${inputId}" is defined but not used in either the Global Inputs Structure or in any Layout Structure`
            )
          });
        }
      });
      globalInputs.forEach((inputId, idx) => {
        if (isEmpty(inputs[inputId])) {
          errors.push({
            instancePath: GLOBAL_INPUT_NONEXISTENT,
            message: (0, i18n_exports._)(
              `Input item ${idx} references an input "${inputId}" that does not exist`
            )
          });
        }
        if (layoutInputIds.has(inputId)) {
          errors.push({
            instancePath: DUPLICATE_INPUT,
            message: (0, i18n_exports._)(
              `Input "${inputId}" exists in both layout structure and global inputs`
            )
          });
        }
      });
      return errors;
    };
    var format_exports = {};
    __export2(format_exports, {
      default: () => format_default
    });
    var defaultImport3 = __toESM2(require_format());
    __reExport(format_exports, require_format());
    var format_default = "default" in defaultImport3 ? defaultImport3.default : defaultImport3;
    var getDSName = ({
      dataSource
    }) => {
      var _a;
      return dataSource.name || ((_a = dataSource.options) == null ? void 0 : _a.ref);
    };
    var isDataSourceNameValid = (dsName, readOnlyTokenNamespaces) => !readOnlyTokenNamespaces.has(dsName) && /^([ \w-.]+)$/.test(dsName) && dsName !== "default";
    var checkInvalidSmartSources = (definition, readOnlyTokenNamespaces = []) => {
      const { dataSources = {} } = definition;
      const readOnlyTokenNamespacesSet = new Set(readOnlyTokenNamespaces);
      const seenSmartSources = /* @__PURE__ */ new Set();
      const clashingNamesErrors = /* @__PURE__ */ new Set();
      return Object.keys(dataSources).reduce((errors, dsId) => {
        var _a;
        if (!((_a = dataSources[dsId].options) == null ? void 0 : _a.enableSmartSources)) {
          return errors;
        }
        const dsName = getDSName({ dataSource: dataSources[dsId] });
        if (!dsName) {
          errors.push({
            instancePath: (0, format_exports.sprintf)(
              (0, i18n_exports._)('Error: The data source "%(dsId)s" is unnamed'),
              { dsId }
            ),
            message: CANNOT_CREATE_DS_TOKENS_UNNAMED
          });
          return errors;
        }
        if (!isDataSourceNameValid(dsName, readOnlyTokenNamespacesSet)) {
          errors.push({
            instancePath: (0, format_exports.sprintf)(
              (0, i18n_exports._)(
                'Error: The data source "%(dsName)s" has an invalid name'
              ),
              {
                dsName
              }
            ),
            message: CANNOT_CREATE_DS_TOKENS_INVALID
          });
        } else if (seenSmartSources.has(dsName) && !clashingNamesErrors.has(dsName)) {
          errors.push({
            instancePath: (0, format_exports.sprintf)(
              (0, i18n_exports._)(
                'Error: Multiple data sources are configured with the name "%(dsName)s"'
              ),
              {
                dsName
              }
            ),
            message: CANNOT_ENSURE_DS_TOKEN_STABILITY
          });
          clashingNamesErrors.add(dsName);
        }
        seenSmartSources.add(dsName);
        return errors;
      }, []);
    };
    var checkLayoutsInTabs = (definition) => {
      var _a, _b, _c, _d, _e;
      const errors = [];
      const tabs = (_c = (_b = (_a = definition.layout) == null ? void 0 : _a.tabs) == null ? void 0 : _b.items) != null ? _c : [];
      const layouts = (_e = (_d = definition.layout) == null ? void 0 : _d.layoutDefinitions) != null ? _e : {};
      tabs.forEach(({ layoutId }) => {
        if (typeof layouts[layoutId] === "undefined") {
          errors.push({
            instancePath: LAYOUT_ID_NONEXISTENT,
            message: (0, i18n_exports._)(
              `Layout "${layoutId}" does not reference an existing layout definition`
            )
          });
        }
      });
      return errors;
    };
    var getLayoutVizIds = (definition) => {
      var _a, _b;
      const layouts = (_b = (_a = definition.layout) == null ? void 0 : _a.layoutDefinitions) != null ? _b : {};
      const vizIds = /* @__PURE__ */ new Set();
      Object.values(layouts).forEach((layout) => {
        var _a2, _b2;
        if (!Array.isArray(layout.structure) || !((_b2 = (_a2 = layout.structure) == null ? void 0 : _a2[0]) == null ? void 0 : _b2.item)) {
          return;
        }
        layout.structure.forEach((item) => {
          if (item.type !== "input") {
            vizIds.add(item.item);
          }
        });
      });
      return vizIds;
    };
    var checkStructure = ({
      visualizations,
      inputs,
      layoutId,
      layoutDefinition,
      errors
    }) => {
      var _a, _b;
      const seen = /* @__PURE__ */ new Set();
      if (!Array.isArray(layoutDefinition.structure) || !((_b = (_a = layoutDefinition.structure) == null ? void 0 : _a[0]) == null ? void 0 : _b.item)) {
        return;
      }
      const structure = layoutDefinition.structure;
      structure.forEach((item, idx) => {
        if (seen.has(item.item)) {
          errors.push({
            instancePath: DUPLICATE_ITEM,
            message: (0, i18n_exports._)(
              `Structure item ${idx} has the same key "${item.item}" as another structure item in layout ${layoutId}`
            )
          });
        }
        if (item.type !== "input" && !isPlainObject(visualizations == null ? void 0 : visualizations[item.item])) {
          errors.push({
            instancePath: VISUALIZATION_NONEXISTENT,
            message: (0, i18n_exports._)(
              `Structure item ${idx} references a visualization "${item.item}" that does not exist in layout ${layoutId}`
            )
          });
        }
        if (item.type === "input" && !isPlainObject(inputs == null ? void 0 : inputs[item.item])) {
          errors.push({
            instancePath: CANVAS_INPUT_NONEXISTENT,
            message: (0, i18n_exports._)(
              `Structure item ${idx} references an input "${item.item}" that does not exist in layout ${layoutId}`
            )
          });
        }
        seen.add(item.item);
      });
    };
    var checkVisualizationsInStructure = (definition) => {
      var _a, _b, _c, _d;
      const errors = [];
      const visualizations = (_a = definition.visualizations) != null ? _a : {};
      const inputs = (_b = definition.inputs) != null ? _b : {};
      const layouts = (_d = (_c = definition.layout) == null ? void 0 : _c.layoutDefinitions) != null ? _d : {};
      const layoutVizIds = getLayoutVizIds(definition);
      Object.entries(layouts).forEach(
        ([layoutId, layout]) => checkStructure({
          visualizations,
          inputs,
          layoutId,
          layoutDefinition: layout,
          errors
        })
      );
      Object.keys(visualizations).forEach((vizId) => {
        if (!layoutVizIds.has(vizId)) {
          errors.push({
            instancePath: VISUALIZATION_NOT_PRESENT,
            message: (0, i18n_exports._)(
              `Visualization "${vizId}" is not present in any Layout Structure`
            )
          });
        }
      });
      return errors;
    };
    var checkDuplicateLayoutsInTabs = (definition) => {
      var _a, _b, _c;
      const cache = {};
      const errors = [];
      const tabs = (_c = (_b = (_a = definition.layout) == null ? void 0 : _a.tabs) == null ? void 0 : _b.items) != null ? _c : [];
      tabs.forEach(({ layoutId, label }) => {
        var _a2;
        const tabLabel = label != null ? label : (0, i18n_exports._)("[Unnamed Tab]");
        if (layoutId === void 0) {
          return;
        }
        (_a2 = cache[layoutId]) != null ? _a2 : cache[layoutId] = [];
        cache[layoutId].push(tabLabel);
      });
      Object.entries(cache).forEach(([layoutId, labels]) => {
        if (labels.length > 1) {
          const lastLabel = labels[labels.length - 1];
          const msg = labels.slice(0, -1).join(", ");
          errors.push({
            instancePath: DUPLICATE_LAYOUT_ID,
            message: (0, i18n_exports._)(
              `${msg} and ${lastLabel} have the same layout (${layoutId})`
            )
          });
        }
      });
      return errors;
    };
    var ajv_exports = {};
    __export2(ajv_exports, {
      default: () => ajv_default
    });
    var defaultImport4 = __toESM2(require_ajv());
    __reExport(ajv_exports, require_ajv());
    var ajv_default = "default" in defaultImport4 ? defaultImport4.default : defaultImport4;
    var ajv_errors_exports = {};
    __export2(ajv_errors_exports, {
      default: () => ajv_errors_default
    });
    var defaultImport5 = __toESM2(require_dist6());
    __reExport(ajv_errors_exports, require_dist6());
    var ajv_errors_default = "default" in defaultImport5 ? defaultImport5.default : defaultImport5;
    var memoize = (func, resolver) => {
      const memoizedComputations = {};
      return (...args) => {
        const argKey = resolver(...args);
        if (!memoizedComputations[argKey]) {
          memoizedComputations[argKey] = func(...args);
        }
        return memoizedComputations[argKey];
      };
    };
    var ajv = new ajv_default({
      allErrors: true,
      // This is to make sure the definition `defaults` can have both `properties` and `patternProperties`
      allowMatchingProperties: true,
      // todo: lots of viz schemas violate this rule, will fix them later
      allowUnionTypes: true,
      code: {
        // Don't optimize when web worker support isn't detected. All supported browser targets do support
        // web workers, so this likely indicates a test environment where the code optimization will error
        optimize: typeof Worker === "undefined" ? false : 1
      }
    });
    ajv_errors_default(ajv);
    var memoizedSchemaCompile = memoize(
      (newSchema) => {
        if ((newSchema == null ? void 0 : newSchema.$id) && ajv.getSchema(newSchema.$id)) {
          ajv.removeSchema(newSchema.$id);
        }
        return ajv.compile(newSchema);
      },
      JSON.stringify
    );
    var checkInvalidConditions = (definition) => {
      var _a, _b;
      const conditions = (_b = (_a = definition.expressions) == null ? void 0 : _a.conditions) != null ? _b : {};
      const seenConditionNames = /* @__PURE__ */ new Set();
      const clashingConditionNames = /* @__PURE__ */ new Set();
      return Object.keys(conditions).reduce(
        (errors, conditionId) => {
          const condition = conditions[conditionId];
          if (!condition.name) {
            return errors;
          }
          if (seenConditionNames.has(condition.name) && !clashingConditionNames.has(condition.name)) {
            errors.push({
              instancePath: (0, format_exports.sprintf)(DUPLICATE_CONDITION_NAME_PATH, {
                conditionName: condition.name
              }),
              message: DUPLICATE_CONDITION_NAME_MESSAGE
            });
            clashingConditionNames.add(condition.name);
          }
          seenConditionNames.add(condition.name);
          return errors;
        },
        []
      );
    };
    var couldHaveConflictingConditions = (arg0) => Array.isArray(arg0 == null ? void 0 : arg0.showConditions) && (Array.isArray(arg0 == null ? void 0 : arg0.conditions) || Array.isArray(arg0 == null ? void 0 : arg0.hideConditions));
    var getInvalidConditions = (visibilityOptions) => {
      if (!couldHaveConflictingConditions(visibilityOptions)) {
        return [];
      }
      const { showConditions, hideConditions, conditions } = visibilityOptions;
      const rejects = /* @__PURE__ */ new Set([...hideConditions != null ? hideConditions : [], ...conditions != null ? conditions : []]);
      return (showConditions != null ? showConditions : []).reduce(
        (accum, id, idx) => {
          if (rejects.has(id)) {
            accum.push([id, idx]);
          }
          return accum;
        },
        []
      );
    };
    var checkStanza = ({
      stanza,
      stanzaName
    }) => {
      const errors = [];
      Object.entries(stanza != null ? stanza : {}).forEach(([itemId, itemDefinition]) => {
        var _a;
        const visibilityOptions = (_a = itemDefinition == null ? void 0 : itemDefinition.containerOptions) == null ? void 0 : _a.visibility;
        const offendingIds = getInvalidConditions(visibilityOptions);
        if (!offendingIds.length) {
          return;
        }
        const instancePath = `/${stanzaName}/${itemId}/containerOptions/visibility/showConditions`;
        offendingIds.forEach(([id, idx]) => {
          errors.push({
            instancePath: `${instancePath}/${idx}`,
            message: (0, format_exports.sprintf)(CONDITION_USED_FOR_SHOW_AND_HIDE_MESSAGE, {
              id
            })
          });
        });
      });
      return errors;
    };
    var validateNoMixedShowHideConditions = (definition) => [
      ...checkStanza({ stanza: definition.inputs, stanzaName: "inputs" }),
      ...checkStanza({
        stanza: definition.visualizations,
        stanzaName: "visualizations"
      })
    ];
    var DashboardValidator = class {
      constructor() {
        this.validateDefinition = null;
      }
      /**
       * set up customized schema
       * @method setSchema
       * @param {Object} newSchema
       * @returns {Object} error
       */
      setSchema(newSchema) {
        if (!(newSchema == null ? void 0 : newSchema.$id)) {
          return null;
        }
        try {
          this.validateDefinition = memoizedSchemaCompile(newSchema);
        } catch (error) {
          return error;
        }
        return null;
      }
      /**
       * Validates the current definition
       * @method validate
       * @returns {Array} list of errors, or null
       */
      validate(definition, readOnlyTokenNamespaces) {
        var _a, _b;
        if (!this.validateDefinition) {
          throw new Error("setSchema must be called first");
        }
        const valid = this.validateDefinition(definition);
        if (!valid && ((_b = (_a = this.validateDefinition) == null ? void 0 : _a.errors) == null ? void 0 : _b.length)) {
          return this.validateDefinition.errors;
        }
        const res = [
          ...checkDuplicateTokens(definition),
          ...checkVisualizationsInStructure(definition),
          ...checkInputsInStructure(definition),
          ...checkInvalidSmartSources(definition, readOnlyTokenNamespaces),
          ...checkLayoutsInTabs(definition),
          ...checkDuplicateLayoutsInTabs(definition),
          ...checkInvalidConditions(definition),
          ...validateNoMixedShowHideConditions(definition)
        ];
        return isEmpty(res) ? null : res;
      }
    };
    var handleEvent = (event) => {
      const { schema, definition, readOnlyTokenNamespaces } = event.data;
      const validator = new DashboardValidator();
      const errors = validator.setSchema(schema);
      if (errors) {
        return errors;
      }
      return validator.validate(definition, readOnlyTokenNamespaces);
    };
    var defaultReadOnlyTokenNamespaces = [];
    var ValidatorComponent = ({
      schema,
      definition,
      onError,
      readOnlyTokenNamespaces = defaultReadOnlyTokenNamespaces
    }) => {
      const onMessage = (0, react_exports.useCallback)(
        ({ data }) => {
          if (data) {
            onError(data);
          }
        },
        [onError]
      );
      const postMessage = (0, react_exports.useCallback)(
        (worker) => {
          worker.postMessage({ schema, definition, readOnlyTokenNamespaces });
        },
        [schema, definition, readOnlyTokenNamespaces]
      );
      const { enabled } = useWorker({
        WorkerClass: InlineWorker,
        onMessage,
        postMessage
      });
      (0, react_exports.useEffect)(() => {
        if (!enabled) {
          onMessage({
            data: handleEvent(
              new MessageEvent("pseudoValidationEvent", {
                data: { schema, definition, readOnlyTokenNamespaces }
              })
            )
          });
        }
      }, [definition, enabled, schema, readOnlyTokenNamespaces, onMessage]);
      return null;
    };
    var isEqual = (arg0, arg1) => arg0 === arg1 || JSON.stringify(arg0) === JSON.stringify(arg1);
    var Validator = (0, react_exports.memo)(
      ValidatorComponent,
      (prevProps, nextProps) => prevProps.onError === nextProps.onError && isEqual(prevProps.schema, nextProps.schema) && isEqual(prevProps.definition, nextProps.definition) && isEqual(
        prevProps.readOnlyTokenNamespaces,
        nextProps.readOnlyTokenNamespaces
      )
    );
  }
});

// node_modules/@splunk/dashboard-core/node_modules/react-resize-detector/build/utils.js
var import_dist, import_dist2, import_dist3, React, import_debounce, import_throttle, patchResizeCallback, useCallbackRef, useRefProxy, getDimensions;
var init_utils = __esm({
  "node_modules/@splunk/dashboard-core/node_modules/react-resize-detector/build/utils.js"() {
    import_dist = __toESM(require_dist(), 1);
    import_dist2 = __toESM(require_dist2(), 1);
    import_dist3 = __toESM(require_dist3(), 1);
    React = __toESM(require_react(), 1);
    import_debounce = __toESM(require_debounce(), 1);
    import_throttle = __toESM(require_throttle(), 1);
    patchResizeCallback = (resizeCallback, refreshMode, refreshRate, refreshOptions) => {
      switch (refreshMode) {
        case "debounce":
          return (0, import_debounce.default)(resizeCallback, refreshRate, refreshOptions);
        case "throttle":
          return (0, import_throttle.default)(resizeCallback, refreshRate, refreshOptions);
        default:
          return resizeCallback;
      }
    };
    useCallbackRef = // eslint-disable-next-line @typescript-eslint/no-explicit-any
    (callback) => {
      const callbackRef = React.useRef(callback);
      React.useEffect(() => {
        callbackRef.current = callback;
      });
      return React.useMemo(() => ((...args) => {
        var _a;
        return (_a = callbackRef.current) === null || _a === void 0 ? void 0 : _a.call(callbackRef, ...args);
      }), []);
    };
    useRefProxy = // eslint-disable-next-line @typescript-eslint/no-explicit-any
    (targetRef) => {
      const [refElement, setRefElement] = React.useState((targetRef === null || targetRef === void 0 ? void 0 : targetRef.current) || null);
      if (targetRef) {
        setTimeout(() => {
          if (targetRef.current !== refElement) {
            setRefElement(targetRef.current);
          }
        }, 0);
      }
      const refProxy = React.useMemo(() => new Proxy((node) => {
        if (node !== refElement) {
          setRefElement(node);
        }
      }, {
        get(target, prop) {
          if (prop === "current") {
            return refElement;
          }
          return target[prop];
        },
        set(target, prop, value) {
          if (prop === "current") {
            setRefElement(value);
          } else {
            target[prop] = value;
          }
          return true;
        }
      }), [refElement]);
      return { refProxy, refElement, setRefElement };
    };
    getDimensions = (entry, box) => {
      var _a, _b;
      const borderBox = (_a = entry.borderBoxSize) === null || _a === void 0 ? void 0 : _a[0];
      const contentBox = (_b = entry.contentBoxSize) === null || _b === void 0 ? void 0 : _b[0];
      if (box === "border-box" && borderBox) {
        return {
          width: borderBox.inlineSize,
          height: borderBox.blockSize
        };
      }
      if (box === "content-box" && contentBox) {
        return {
          width: contentBox.inlineSize,
          height: contentBox.blockSize
        };
      }
      return {
        width: entry.contentRect.width,
        height: entry.contentRect.height
      };
    };
  }
});

// node_modules/@splunk/dashboard-core/node_modules/react-resize-detector/build/useResizeDetector.js
function useResizeDetector({ skipOnMount = false, refreshMode, refreshRate = 1e3, refreshOptions, handleWidth = true, handleHeight = true, targetRef, observerOptions, onResize } = {}) {
  const skipResize = (0, import_react.useRef)(skipOnMount);
  const onResizeRef = useCallbackRef(onResize);
  const [size, setSize] = (0, import_react.useState)({
    width: void 0,
    height: void 0
  });
  const { refProxy, refElement } = useRefProxy(targetRef);
  const { box } = observerOptions || {};
  const resizeCallback = (0, import_react.useCallback)((entries) => {
    if (!handleWidth && !handleHeight)
      return;
    if (skipResize.current) {
      skipResize.current = false;
      return;
    }
    const shouldSetSize = (prevSize, nextSize) => handleWidth && prevSize.width !== nextSize.width || handleHeight && prevSize.height !== nextSize.height;
    entries.forEach((entry) => {
      const dimensions = getDimensions(entry, box);
      setSize((prevSize) => {
        if (!shouldSetSize(prevSize, dimensions))
          return prevSize;
        onResizeRef === null || onResizeRef === void 0 ? void 0 : onResizeRef({
          width: dimensions.width,
          height: dimensions.height,
          entry
        });
        return dimensions;
      });
    });
  }, [handleWidth, handleHeight, skipResize, box]);
  const resizeHandler = (0, import_react.useCallback)(patchResizeCallback(resizeCallback, refreshMode, refreshRate, refreshOptions), [
    resizeCallback,
    refreshMode,
    refreshRate,
    refreshOptions
  ]);
  (0, import_react.useEffect)(() => {
    let resizeObserver;
    if (refElement) {
      try {
        resizeObserver = new window.ResizeObserver(resizeHandler);
        resizeObserver.observe(refElement, observerOptions);
      } catch (error) {
        console.warn("ResizeObserver not supported or failed to initialize:", error);
      }
    } else if (size.width || size.height) {
      onResizeRef === null || onResizeRef === void 0 ? void 0 : onResizeRef({
        width: null,
        height: null,
        entry: null
      });
      setSize({ width: void 0, height: void 0 });
    }
    return () => {
      var _a, _b, _c;
      (_a = resizeObserver === null || resizeObserver === void 0 ? void 0 : resizeObserver.disconnect) === null || _a === void 0 ? void 0 : _a.call(resizeObserver);
      (_c = (_b = resizeHandler).cancel) === null || _c === void 0 ? void 0 : _c.call(_b);
    };
  }, [resizeHandler, refElement]);
  return Object.assign({ ref: refProxy }, size);
}
var import_dist4, import_dist5, import_dist6, import_react;
var init_useResizeDetector = __esm({
  "node_modules/@splunk/dashboard-core/node_modules/react-resize-detector/build/useResizeDetector.js"() {
    import_dist4 = __toESM(require_dist(), 1);
    import_dist5 = __toESM(require_dist2(), 1);
    import_dist6 = __toESM(require_dist3(), 1);
    import_react = __toESM(require_react(), 1);
    init_utils();
  }
});

// node_modules/@splunk/dashboard-core/node_modules/react-resize-detector/build/index.js
var build_exports = {};
__export(build_exports, {
  useResizeDetector: () => useResizeDetector
});
var import_dist7, import_dist8, import_dist9;
var init_build = __esm({
  "node_modules/@splunk/dashboard-core/node_modules/react-resize-detector/build/index.js"() {
    import_dist7 = __toESM(require_dist());
    import_dist8 = __toESM(require_dist2());
    import_dist9 = __toESM(require_dist3());
    init_useResizeDetector();
  }
});

// node_modules/@splunk/react-ui/TabBar.js
var require_TabBar = __commonJS({
  "node_modules/@splunk/react-ui/TabBar.js"(exports, module) {
    var import_dist16 = __toESM(require_dist());
    var import_dist17 = __toESM(require_dist2());
    var import_dist18 = __toESM(require_dist3());
    (() => {
      "use strict";
      var e = {};
      (() => {
        e.n = (t2) => {
          var n2 = t2 && t2.__esModule ? (
            /******/
            () => t2["default"]
          ) : () => t2;
          e.d(n2, {
            a: n2
          });
          return n2;
        };
      })();
      (() => {
        e.d = (t2, n2) => {
          for (var r2 in n2) {
            if (e.o(n2, r2) && !e.o(t2, r2)) {
              Object.defineProperty(t2, r2, {
                enumerable: true,
                get: n2[r2]
              });
            }
          }
        };
      })();
      (() => {
        e.o = (e2, t2) => Object.prototype.hasOwnProperty.call(e2, t2);
      })();
      (() => {
        e.r = (e2) => {
          if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
            Object.defineProperty(e2, Symbol.toStringTag, {
              value: "Module"
            });
          }
          Object.defineProperty(e2, "__esModule", {
            value: true
          });
        };
      })();
      var t = {};
      e.r(t);
      e.d(t, {
        Tab: () => (
          /* reexport */
          ne
        ),
        default: () => (
          /* reexport */
          je
        )
      });
      const n = require_react();
      var r = e.n(n);
      const a = require_prop_types();
      var i = e.n(a);
      const o = require_usePrevious();
      var l = e.n(o);
      const u = require_omit();
      var c = e.n(u);
      const s = require_DotsThreeVertical();
      var d = e.n(s);
      const f = require_Dropdown();
      var v = e.n(f);
      const b = require_Popover();
      var p = e.n(b);
      const m = require_ScreenReaderContent();
      var g = e.n(m);
      const y = require_i18n();
      const h = require_id();
      var S = function e2() {
        return void 0;
      };
      var w = (0, n.createContext)({
        isMenuOpen: false,
        onMenuOpen: S,
        onMenuClose: S,
        registerTab: S
      });
      w.displayName = "TabBar";
      const C = w;
      const O = (init_styled_components_esm(), __toCommonJS(styled_components_esm_exports));
      var x = e.n(O);
      const I = require_Clickable();
      var k = e.n(I);
      const T = require_themes();
      var j = (0, O.css)(["color:", ";"], T.variables.contentColorActive);
      var P = "2px";
      var E = (0, T.pickVariant)("$layout", {
        horizontal: (0, O.css)(["background:", ";height:", ";"], T.variables.contentColorAccentWeak, P),
        vertical: (0, O.css)(["background:", ";width:", ";"], T.variables.contentColorAccentWeak, P)
      });
      var M = function e2(t2) {
        var n2 = t2.$hasIcon, r2 = t2.$hasMenu, a2 = t2.$iconPosition;
        if (a2 === "above" && n2 && r2) {
          return (0, O.css)(["grid-template-areas:'icon icon icon' 'menu-counter-neg-space label menu' 'gutter gutter gutter' 'underline underline underline';grid-template-columns:", " 1fr min-content;grid-template-rows:repeat(2,auto) ", " auto;"], T.variables.spacingXSmall, T.variables.spacingXSmall);
        }
        if (a2 === "above" && n2) {
          return (0, O.css)(["grid-template-areas:'icon' 'label' 'gutter' 'underline';grid-template-columns:1fr;grid-template-rows:repeat(2,auto) ", " auto;"], T.variables.spacingXSmall);
        }
        if (a2 === "left" && n2 && r2) {
          return (0, O.css)(["grid-template-areas:'menu-counter-neg-space icon label menu' 'underline underline underline underline';grid-template-columns:", " min-content 1fr min-content;"], T.variables.spacingXSmall);
        }
        if (a2 === "left" && n2) {
          return (0, O.css)(["grid-template-areas:'icon label' 'underline underline';grid-template-columns:min-content 1fr;"]);
        }
        if (r2) {
          return (0, O.css)(["grid-template-areas:'menu-counter-neg-space label menu' 'underline underline underline';grid-template-columns:", " minmax(auto,min-content) min-content;"], T.variables.spacingXSmall);
        }
        return (0, O.css)(["grid-template-areas:'label' 'underline';grid-template-columns:minmax(auto,min-content);"]);
      };
      var $ = function e2(t2) {
        var n2 = t2.$hasIcon, r2 = t2.$iconPosition;
        if (r2 === "above" && n2) {
          return (0, O.css)(["grid-template-areas:'icon gutter underline' 'label gutter underline';grid-template-columns:1fr ", " ", ";"], T.variables.spacingXSmall, P);
        }
        if (r2 === "left" && n2) {
          return (0, O.css)(["grid-template-areas:'icon label gutter underline';grid-template-columns:min-content 1fr ", " ", ";"], T.variables.spacingXSmall, P);
        }
        return (0, O.css)(["grid-template-areas:'label gutter underline';grid-template-columns:1fr ", " ", ";"], T.variables.spacingXSmall, P);
      };
      var A = x()(k()).withConfig({
        displayName: "TabStyles__StyledClickable",
        componentId: "sc-1ry8mzj-0"
      })(["color:", ";column-gap:", ";display:grid;justify-content:center;align-items:baseline;min-height:", ";position:relative;", " ", " ", ";&[aria-selected='true']{cursor:default;color:", ";font-weight:", ";}&[aria-selected='false']{box-shadow:none;font-weight:", ";&:hover:not([disabled]){", "}&[aria-haspopup='true']{", "}}&:focus{box-shadow:", ";color:", ";}"], T.variables.contentColorDefault, T.variables.spacingXSmall, T.variables.inputHeight, (function(e2) {
        var t2 = e2.$maxTabWidth;
        return t2 && (0, O.css)(["max-width:", "px;"], t2);
      }), (function(e2) {
        var t2 = e2.$hasIcon, n2 = e2.$hasMenu, r2 = e2.$iconPosition, a2 = e2.$layout;
        if (a2 === "vertical") {
          return $({
            $hasIcon: t2,
            $iconPosition: r2
          });
        }
        return M({
          $hasIcon: t2,
          $hasMenu: n2,
          $iconPosition: r2
        });
      }), (0, T.pickVariant)("$layout", {
        horizontal: (0, O.css)(["margin-bottom:1px;"]),
        vertical: (0, O.css)(["align-items:center;right:1px;"])
      }), T.variables.contentColorActive, T.variables.fontWeightBold, T.variables.fontWeightSemiBold, j, j, T.variables.focusShadow, T.variables.contentColorActive);
      var z = x().div.withConfig({
        displayName: "TabStyles__StyledUnderline",
        componentId: "sc-1ry8mzj-1"
      })(
        ["grid-area:underline;position:absolute;", ";[aria-selected='true'] > &&{background-color:", ";", ";}", ":hover:not([disabled]):not([aria-selected='true']) > &&{", ";}[aria-selected='false'][aria-haspopup='true'] > &&{", "}"],
        (0, T.pickVariant)("$layout", {
          horizontal: (0, O.css)(["bottom:-1px;height:0;width:100%;transition:height 0.2s;"]),
          vertical: (0, O.css)(["width:1px;height:100%;right:-1px;transition:width 0.2s;"])
        }),
        T.variables.contentColorAccent,
        (0, T.pickVariant)("$layout", {
          horizontal: (0, O.css)(["height:", ";"], P),
          vertical: (0, O.css)(["width:", ";"], P)
        }),
        /* sc-sel */
        A,
        E,
        E
      );
      var _ = x().span.withConfig({
        displayName: "TabStyles__StyledMenu",
        componentId: "sc-1ry8mzj-2"
      })(
        ["display:inline-block;grid-area:menu;margin-left:4px;> svg{transform:translateY(-1px);}border-radius:", ";cursor:pointer;", " &:hover{background-color:", ";border-color:", ";}", "[aria-haspopup='true'] &,", ":hover &,", ":focus &{visibility:visible;}"],
        T.variables.borderRadius,
        (0, T.pickVariant)("$active", {
          false: (0, O.css)(["visibility:hidden;"])
        }),
        T.variables.interactiveColorOverlayHover,
        T.variables.interactiveColorBorderHover,
        /* sc-sel */
        A,
        /* sc-sel */
        A,
        /* sc-sel */
        A
      );
      var D = x().span.withConfig({
        displayName: "TabStyles__StyledIcon",
        componentId: "sc-1ry8mzj-3"
      })(["grid-area:icon;", ""], (0, T.pickVariant)("$iconPosition", {
        above: (0, O.css)(["display:flex;justify-content:center;"]),
        left: (0, O.css)(["> svg{transform:translateY(-1px);}"])
      }));
      var N = x().div.withConfig({
        displayName: "TabStyles__StyledContent",
        componentId: "sc-1ry8mzj-4"
      })(["display:inline-flex;align-items:baseline;grid-area:label;min-width:10px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;", ""], (function(e2) {
        var t2 = e2.$iconPosition;
        return t2 === "above" && (0, O.css)(["justify-content:center;text-align:center;"]);
      }));
      var R = x().div.withConfig({
        displayName: "TabStyles__StyledLabel",
        componentId: "sc-1ry8mzj-5"
      })(["&::after{display:block;content:attr(data-title);font-weight:", ";height:0;color:transparent;overflow:hidden;visibility:hidden;white-space:nowrap;}"], T.variables.fontWeightBold);
      var q = x().span.withConfig({
        displayName: "TabStyles__StyledCount",
        componentId: "sc-1ry8mzj-6"
      })(["background:", ";border-radius:18px;color:", ";display:inline-block;font-size:", ";line-height:10px;margin-inline-start:0.3em;padding:0.4em 0.6em;&[disabled]{color:", ";}"], T.variables.neutral100, T.variables.contentColorDefault, T.variables.fontSizeSmall, T.variables.contentColorDisabled);
      var V = x().div.withConfig({
        displayName: "TabStyles__StyledTooltipContent",
        componentId: "sc-1ry8mzj-7"
      })(["padding:8px;font-size:", ";"], T.variables.fontSizeSmall);
      var W = function e2(t2, n2) {
        if (t2 > n2) {
          return "".concat(n2, "+");
        }
        return t2;
      };
      function X(e2, t2) {
        if (e2) {
          if (typeof e2 === "function") {
            e2(t2);
          } else {
            e2.current = t2;
          }
        }
      }
      function B() {
        return B = Object.assign ? Object.assign.bind() : function(e2) {
          for (var t2 = 1; t2 < arguments.length; t2++) {
            var n2 = arguments[t2];
            for (var r2 in n2) {
              ({}).hasOwnProperty.call(n2, r2) && (e2[r2] = n2[r2]);
            }
          }
          return e2;
        }, B.apply(null, arguments);
      }
      function F(e2, t2) {
        return Y(e2) || K(e2, t2) || H(e2, t2) || L();
      }
      function L() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      function H(e2, t2) {
        if (e2) {
          if ("string" == typeof e2) return U(e2, t2);
          var n2 = {}.toString.call(e2).slice(8, -1);
          return "Object" === n2 && e2.constructor && (n2 = e2.constructor.name), "Map" === n2 || "Set" === n2 ? Array.from(e2) : "Arguments" === n2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2) ? U(e2, t2) : void 0;
        }
      }
      function U(e2, t2) {
        (null == t2 || t2 > e2.length) && (t2 = e2.length);
        for (var n2 = 0, r2 = Array(t2); n2 < t2; n2++) {
          r2[n2] = e2[n2];
        }
        return r2;
      }
      function K(e2, t2) {
        var n2 = null == e2 ? null : "undefined" != typeof Symbol && e2[Symbol.iterator] || e2["@@iterator"];
        if (null != n2) {
          var r2, a2, i2, o2, l2 = [], u2 = true, c2 = false;
          try {
            if (i2 = (n2 = n2.call(e2)).next, 0 === t2) {
              if (Object(n2) !== n2) return;
              u2 = false;
            } else for (; !(u2 = (r2 = i2.call(n2)).done) && (l2.push(r2.value), l2.length !== t2); u2 = true) {
            }
          } catch (e3) {
            c2 = true, a2 = e3;
          } finally {
            try {
              if (!u2 && null != n2["return"] && (o2 = n2["return"](), Object(o2) !== o2)) return;
            } finally {
              if (c2) throw a2;
            }
          }
          return l2;
        }
      }
      function Y(e2) {
        if (Array.isArray(e2)) return e2;
      }
      function G(e2, t2) {
        if (null == e2) return {};
        var n2, r2, a2 = J(e2, t2);
        if (Object.getOwnPropertySymbols) {
          var i2 = Object.getOwnPropertySymbols(e2);
          for (r2 = 0; r2 < i2.length; r2++) {
            n2 = i2[r2], -1 === t2.indexOf(n2) && {}.propertyIsEnumerable.call(e2, n2) && (a2[n2] = e2[n2]);
          }
        }
        return a2;
      }
      function J(e2, t2) {
        if (null == e2) return {};
        var n2 = {};
        for (var r2 in e2) {
          if ({}.hasOwnProperty.call(e2, r2)) {
            if (-1 !== t2.indexOf(r2)) continue;
            n2[r2] = e2[r2];
          }
        }
        return n2;
      }
      var Q = {
        ariaControls: i().string,
        count: i().number,
        disabled: i().bool,
        elementRef: i().oneOfType([i().func, i().object]),
        icon: i().node,
        id: i().string,
        label: i().oneOfType([i().string, i().element]),
        /** @private Maximum count number in tab label */
        maxCount: i().number,
        tabId: i().string,
        to: i().string,
        tooltip: i().node,
        /**
        * @private
        * Accepts a Menu component that is rendered for that Tab.
        * Is not compatible with `count`.
        * The `menu` prop is only supported in horizontal layout due to both design constraints as well as keyboard support.
        */
        menu: i().node,
        /**
        * @private
        * Internal prop injected by TabBar to track order.
        */
        index: i().number
      };
      var Z = {
        tension: 400
      };
      var ee = ["offScreen", "escapeKey"];
      var te = function e2(t2) {
        var a2 = t2.ariaControls, i2 = t2.count, o2 = t2.disabled, l2 = t2.elementRef, u2 = t2.icon, s2 = t2.label, f2 = t2.maxCount, b2 = t2.tabId, m2 = t2.to, S2 = t2.tooltip, w2 = t2.menu, O2 = t2.index, x2 = G(t2, ["ariaControls", "count", "disabled", "elementRef", "icon", "label", "maxCount", "tabId", "to", "tooltip", "menu", "index"]);
        var I2 = (0, n.useState)(false), k2 = F(I2, 2), T2 = k2[0], j2 = k2[1];
        var P2 = (0, n.useState)(null), E2 = F(P2, 2), M2 = E2[0], $2 = E2[1];
        var L2 = (0, n.useContext)(C), H2 = L2.activeTabId, U2 = L2.disabled, K2 = L2.focusedTabId, Y2 = L2.iconPosition, J2 = Y2 === void 0 ? "above" : Y2, Q2 = L2.isMenuOpen, te2 = L2.layout, ne2 = te2 === void 0 ? "horizontal" : te2, re2 = L2.maxTabWidth, ae2 = L2.onClick, ie2 = L2.onFocus, oe2 = L2.onMenuOpen, le2 = L2.onMenuClose, ue2 = L2.registerTab;
        var ce2 = (0, n.useState)((0, h.createDOMID)("aria-id")), se2 = F(ce2, 1), de2 = se2[0];
        var fe2 = (0, n.useState)((0, h.createDOMID)("menu-description")), ve2 = F(fe2, 1), be2 = ve2[0];
        var pe2 = (0, n.useState)((0, h.createDOMID)("popover")), me2 = F(pe2, 1), ge2 = me2[0];
        var ye2 = (0, n.useMemo)((function() {
          return b2 || (0, h.createGUID)();
        }), [b2]);
        var he2 = U2 || o2 ? "disabled" : false;
        var Se2 = s2 ? s2.toString() : "";
        var we2 = H2 === ye2;
        var Ce2 = (0, n.useMemo)((function() {
          return s2 && typeof s2 === "string" ? Se2 : "";
        }), [s2, Se2]);
        var Oe2 = (0, n.useCallback)((function() {
          M2 === null || M2 === void 0 ? void 0 : M2.focus();
        }), [M2]);
        var xe2 = (0, n.useCallback)((function(e3) {
          $2(e3);
          X(l2, e3);
          ue2({
            tabId: ye2,
            element: e3,
            index: O2
          });
        }), [l2, ue2, ye2, O2]);
        var Ie2 = (0, n.useCallback)((function() {
          j2(true);
        }), []);
        var ke2 = (0, n.useCallback)((function() {
          j2(false);
        }), []);
        var Te2 = (0, n.useCallback)((function(e3) {
          if (!we2) {
            ae2 === null || ae2 === void 0 ? void 0 : ae2(e3, {
              tabId: ye2
            });
          }
          if (m2 == null || m2 != null && we2) {
            e3.preventDefault();
          }
        }), [we2, ae2, ye2, m2]);
        var je2 = (0, n.useCallback)((function(e3) {
          Ie2();
          ie2 === null || ie2 === void 0 ? void 0 : ie2(e3, {
            tabId: ye2
          });
        }), [Ie2, ie2, ye2]);
        var Pe = (0, n.useCallback)((function() {
          Oe2();
        }), [Oe2]);
        var Ee = (0, n.useCallback)((function() {
          ke2();
        }), [ke2]);
        var Me = (0, n.useCallback)((function(e3) {
          e3.stopPropagation();
          oe2(ye2);
        }), [oe2, ye2]);
        var $e = K2 === ye2 && Q2 && !!w2;
        var Ae = r().createElement(_, {
          $active: we2,
          "data-test": "menu-toggle",
          tabIndex: -1,
          onFocus: Pe
        }, r().createElement(d(), null));
        var ze = function e3(t3) {
          return r().createElement(r().Fragment, null, t3, r().createElement(v(), {
            toggle: Ae,
            align: "center",
            onRequestOpen: Me,
            onRequestClose: le2,
            open: $e
          }, w2));
        };
        var _e = x2["data-title"];
        var De = r().createElement(N, {
          "data-test": "label",
          $iconPosition: J2
        }, r().createElement(R, {
          "data-title": _e || Ce2
        }, s2), !w2 && (i2 === 0 || i2) && r().createElement(r().Fragment, null, r().createElement(g(), null, ""), r().createElement(q, {
          "data-test": "count",
          disabled: !!he2
        }, f2 ? W(i2, f2) : i2)), !!w2 && r().createElement(g(), {
          "aria-hidden": true,
          id: be2
        }, (0, y._)("Press Shift + F10 to open the tabs menu")));
        return r().createElement(A, B({
          $hasIcon: !!u2,
          $hasMenu: !!w2,
          $iconPosition: J2,
          $layout: ne2,
          $maxTabWidth: re2,
          "aria-controls": a2,
          "aria-selected": we2,
          "aria-labelledby": de2,
          "aria-describedby": w2 ? be2 : void 0,
          "aria-haspopup": $e,
          "data-test": "tab",
          "data-test-tab-id": ye2,
          "data-test-popover-id": S2 ? ge2 : void 0,
          "data-test-disabled": he2 || void 0,
          disabled: he2,
          elementRef: xe2,
          onClick: Te2,
          onFocus: je2,
          onMouseEnter: Ie2,
          onBlur: Ee,
          onMouseLeave: ke2,
          role: "tab",
          tabIndex: we2 ? void 0 : -1,
          to: m2
        }, c()(x2, "elementRef")), u2 && r().createElement(D, {
          $iconPosition: J2
        }, u2), w2 && ne2 === "horizontal" ? ze(De) : De, r().createElement(z, {
          $layout: ne2
        }), !o2 && S2 && r().createElement(p(), {
          role: "tooltip",
          anchor: M2,
          animationConfig: Z,
          closeReasons: ee,
          defaultPlacement: ne2 === "vertical" ? "right" : "above",
          id: ge2,
          open: !!M2 && T2,
          align: "center"
        }, r().createElement(V, null, S2)), S2 && r().createElement(g(), {
          "aria-hidden": "true",
          id: de2
        }, S2));
      };
      te.propTypes = Q;
      te.as = "Tab";
      const ne = te;
      var re = x().div.withConfig({
        displayName: "TabBarStyles__Styled",
        componentId: "sc-1t85fen-0"
      })(["", " position:relative;&::before{content:'';display:block;position:absolute;left:0;top:0;right:0;bottom:0;border:0 solid ", ";}", ";"], T.mixins.reset("flex"), T.variables.neutral300, (0, T.pickVariant)("$layout", {
        horizontal: (0, O.css)(["column-gap:", ";&::before{border-bottom-width:1px;}"], T.variables.spacingXLarge),
        vertical: (0, O.css)(["display:inline-flex;flex-direction:column;row-gap:", ";&::before{border-right-width:1px;}"], T.variables.spacingXLarge)
      }));
      function ae(e2, t2, n2) {
        for (var r2 = 0; r2 < e2.length; r2 += 1) {
          var a2 = (r2 + n2) % e2.length;
          var i2 = e2[a2].element;
          if (i2 instanceof HTMLButtonElement && i2.disabled !== true) {
            return e2[a2];
          }
        }
        return e2[t2];
      }
      function ie(e2, t2, n2) {
        for (var r2 = e2.length; r2 > 0; r2 -= 1) {
          var a2 = (r2 + n2) % e2.length;
          var i2 = e2[a2].element;
          if (i2 instanceof HTMLButtonElement && i2.disabled !== true) {
            return e2[a2];
          }
        }
        return e2[t2];
      }
      var oe = "is deprecated and will be removed in the next major version.";
      var le = function e2(t2) {
        var n2 = t2.additionalMessage, r2 = n2 === void 0 ? "" : n2, a2 = t2.componentName;
        useEffect((function() {
          if (false) {
          }
        }), [r2, a2]);
      };
      var ue = function e2(t2) {
        var r2 = t2.additionalMessage, a2 = r2 === void 0 ? "" : r2, i2 = t2.componentName, o2 = t2.propName, l2 = t2.propValue;
        (0, n.useEffect)((function() {
          if (false) {
          }
        }), [a2, i2, o2, l2]);
      };
      var ce = function e2(t2) {
        var n2 = t2.additionalMessage, r2 = n2 === void 0 ? "" : n2, a2 = t2.componentName, i2 = t2.deprecatedPropValue, o2 = t2.propName, l2 = t2.propValue;
        useEffect((function() {
          if (false) {
          }
        }), [r2, a2, o2, l2, i2]);
      };
      function se(e2) {
        "@babel/helpers - typeof";
        return se = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e3) {
          return typeof e3;
        } : function(e3) {
          return e3 && "function" == typeof Symbol && e3.constructor === Symbol && e3 !== Symbol.prototype ? "symbol" : typeof e3;
        }, se(e2);
      }
      function de() {
        return de = Object.assign ? Object.assign.bind() : function(e2) {
          for (var t2 = 1; t2 < arguments.length; t2++) {
            var n2 = arguments[t2];
            for (var r2 in n2) {
              ({}).hasOwnProperty.call(n2, r2) && (e2[r2] = n2[r2]);
            }
          }
          return e2;
        }, de.apply(null, arguments);
      }
      function fe(e2, t2) {
        if (null == e2) return {};
        var n2, r2, a2 = ve(e2, t2);
        if (Object.getOwnPropertySymbols) {
          var i2 = Object.getOwnPropertySymbols(e2);
          for (r2 = 0; r2 < i2.length; r2++) {
            n2 = i2[r2], -1 === t2.indexOf(n2) && {}.propertyIsEnumerable.call(e2, n2) && (a2[n2] = e2[n2]);
          }
        }
        return a2;
      }
      function ve(e2, t2) {
        if (null == e2) return {};
        var n2 = {};
        for (var r2 in e2) {
          if ({}.hasOwnProperty.call(e2, r2)) {
            if (-1 !== t2.indexOf(r2)) continue;
            n2[r2] = e2[r2];
          }
        }
        return n2;
      }
      function be(e2, t2) {
        var n2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var r2 = Object.getOwnPropertySymbols(e2);
          t2 && (r2 = r2.filter((function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          }))), n2.push.apply(n2, r2);
        }
        return n2;
      }
      function pe(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var n2 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? be(Object(n2), true).forEach((function(t3) {
            me(e2, t3, n2[t3]);
          })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(n2)) : be(Object(n2)).forEach((function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(n2, t3));
          }));
        }
        return e2;
      }
      function me(e2, t2, n2) {
        return (t2 = ge(t2)) in e2 ? Object.defineProperty(e2, t2, {
          value: n2,
          enumerable: true,
          configurable: true,
          writable: true
        }) : e2[t2] = n2, e2;
      }
      function ge(e2) {
        var t2 = ye(e2, "string");
        return "symbol" == se(t2) ? t2 : t2 + "";
      }
      function ye(e2, t2) {
        if ("object" != se(e2) || !e2) return e2;
        var n2 = e2[Symbol.toPrimitive];
        if (void 0 !== n2) {
          var r2 = n2.call(e2, t2 || "default");
          if ("object" != se(r2)) return r2;
          throw new TypeError("@@toPrimitive must return a primitive value.");
        }
        return ("string" === t2 ? String : Number)(e2);
      }
      function he(e2, t2) {
        return xe(e2) || Oe(e2, t2) || we(e2, t2) || Se();
      }
      function Se() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      function we(e2, t2) {
        if (e2) {
          if ("string" == typeof e2) return Ce(e2, t2);
          var n2 = {}.toString.call(e2).slice(8, -1);
          return "Object" === n2 && e2.constructor && (n2 = e2.constructor.name), "Map" === n2 || "Set" === n2 ? Array.from(e2) : "Arguments" === n2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2) ? Ce(e2, t2) : void 0;
        }
      }
      function Ce(e2, t2) {
        (null == t2 || t2 > e2.length) && (t2 = e2.length);
        for (var n2 = 0, r2 = Array(t2); n2 < t2; n2++) {
          r2[n2] = e2[n2];
        }
        return r2;
      }
      function Oe(e2, t2) {
        var n2 = null == e2 ? null : "undefined" != typeof Symbol && e2[Symbol.iterator] || e2["@@iterator"];
        if (null != n2) {
          var r2, a2, i2, o2, l2 = [], u2 = true, c2 = false;
          try {
            if (i2 = (n2 = n2.call(e2)).next, 0 === t2) {
              if (Object(n2) !== n2) return;
              u2 = false;
            } else for (; !(u2 = (r2 = i2.call(n2)).done) && (l2.push(r2.value), l2.length !== t2); u2 = true) {
            }
          } catch (e3) {
            c2 = true, a2 = e3;
          } finally {
            try {
              if (!u2 && null != n2["return"] && (o2 = n2["return"](), Object(o2) !== o2)) return;
            } finally {
              if (c2) throw a2;
            }
          }
          return l2;
        }
      }
      function xe(e2) {
        if (Array.isArray(e2)) return e2;
      }
      var Ie = {
        autoActivate: i().bool,
        activeTabId: i().string,
        children: i().node,
        /** @private */
        disabled: i().bool,
        elementRef: i().oneOfType([i().func, i().object]),
        iconPosition: i().oneOf(["above", "left"]),
        layout: i().oneOf(["horizontal", "vertical"]),
        maxTabWidth: i().number,
        onChange: i().func
      };
      var ke = function e2(t2) {
        return Array.from(t2.entries()).sort((function(e3, t3) {
          var n2 = he(e3, 2), r2 = n2[1].index;
          var a2 = he(t3, 2), i2 = a2[1].index;
          return r2 - i2;
        })).map((function(e3) {
          var t3 = he(e3, 2), n2 = t3[0], r2 = t3[1];
          return pe({
            tabId: n2
          }, r2);
        }));
      };
      function Te(e2) {
        var t2;
        var a2 = e2.activeTabId, i2 = e2.autoActivate, o2 = e2.children, u2 = e2.disabled, c2 = u2 === void 0 ? false : u2, s2 = e2.elementRef, d2 = e2.iconPosition, f2 = d2 === void 0 ? "left" : d2, v2 = e2.layout, b2 = v2 === void 0 ? "horizontal" : v2, p2 = e2.maxTabWidth, m2 = e2.onChange, g2 = fe(e2, ["activeTabId", "autoActivate", "children", "disabled", "elementRef", "iconPosition", "layout", "maxTabWidth", "onChange"]);
        var y2 = (t2 = arguments[0]) === null || t2 === void 0 ? void 0 : t2.iconPosition;
        ue({
          componentName: "TabBar and TabLayout",
          propName: "iconPosition",
          propValue: y2
        });
        var h2 = (0, n.useState)(false), S2 = he(h2, 2), w2 = S2[0], O2 = S2[1];
        var x2 = (0, n.useState)(a2), I2 = he(x2, 2), k2 = I2[0], T2 = I2[1];
        var j2 = (0, n.useRef)(a2);
        j2.current = k2;
        var P2 = (0, n.useRef)();
        var E2 = (0, n.useRef)(null);
        var M2 = (0, n.useRef)();
        if (!M2.current) {
          M2.current = /* @__PURE__ */ new Map();
        }
        var $2 = b2 === "vertical" ? "ArrowDown" : "ArrowRight";
        var A2 = b2 === "vertical" ? "ArrowUp" : "ArrowLeft";
        var z2 = (0, n.useCallback)((function(e3) {
          var t3;
          if (!e3) {
            return;
          }
          var n2 = (t3 = M2.current) === null || t3 === void 0 ? void 0 : t3.get(e3);
          if (!n2) {
            var r2 = ke(M2.current);
            var a3 = r2[0];
            if (a3) {
              var i3;
              T2(e3);
              (i3 = a3.element) === null || i3 === void 0 ? void 0 : i3.focus();
            }
            return;
          }
          T2(e3);
          n2.element.focus();
        }), []);
        var _2 = (0, n.useCallback)((function(e3) {
          var t3 = e3.tabId, n2 = e3.element, r2 = e3.index;
          if (n2) {
            var a3;
            (a3 = M2.current) === null || a3 === void 0 ? void 0 : a3.set(t3, {
              element: n2,
              index: r2
            });
          } else {
            var i3;
            (i3 = M2.current) === null || i3 === void 0 ? void 0 : i3["delete"](t3);
            if (j2.current === t3) {
              P2.current = r2;
            }
          }
        }), []);
        var D2 = (0, n.useCallback)((function(e3) {
          E2.current = e3;
          X(s2, e3);
        }), [s2, E2]);
        var N2 = (0, n.useCallback)((function(e3, t3) {
          var n2 = t3.tabId;
          if (document.activeElement === e3.target && k2 === n2) {
            return;
          }
          z2(n2);
          if (i2 && a2 !== n2) {
            m2 === null || m2 === void 0 ? void 0 : m2(e3, {
              selectedTabId: n2
            });
          }
        }), [a2, i2, k2, z2, m2]);
        var R2 = (0, n.useCallback)((function(e3, t3) {
          var n2 = t3.tabId;
          z2(n2);
          m2 === null || m2 === void 0 ? void 0 : m2(e3, {
            selectedTabId: n2
          });
        }), [z2, m2]);
        var q2 = (0, n.useCallback)((function(e3) {
          if (e3.nativeEvent.metaKey) {
            return;
          }
          var t3 = ke(M2.current);
          var n2 = k2 ? t3.findIndex((function(e4) {
            return e4.tabId === k2;
          })) : -1;
          var r2 = t3.map((function(e4) {
            return e4.element;
          }));
          var a3 = n2 === -1 ? 0 : n2;
          var i3 = e3.key;
          var o3;
          if (i3 === $2) {
            o3 = ae(t3, a3, a3 + 1);
          } else if (i3 === A2) {
            o3 = ie(t3, a3, a3 - 1);
          } else if (i3 === "Home") {
            o3 = ae(t3, a3, 0);
          } else if (i3 === "End") {
            o3 = ie(t3, a3, r2.length - 1);
          } else if (b2 === "horizontal" && e3.shiftKey && i3 === "F10") {
            O2((function(e4) {
              if (e4) {
                var t4 = r2[a3];
                t4 === null || t4 === void 0 ? void 0 : t4.focus();
              }
              return !e4;
            }));
          } else if (b2 === "horizontal" && i3 === "ArrowDown") {
            O2(true);
          }
          if (o3) {
            z2(o3.tabId);
            e3.preventDefault();
          }
        }), [k2, z2, b2, $2, A2]);
        var V2 = (0, n.useCallback)((function(e3) {
          z2(e3);
          O2(true);
        }), [z2]);
        var W2 = (0, n.useCallback)((function(e3) {
          var t3 = e3.event;
          t3 === null || t3 === void 0 ? void 0 : t3.stopPropagation();
          O2(false);
        }), []);
        var B2 = (0, n.useMemo)((function() {
          return {
            disabled: c2,
            focusedTabId: k2,
            iconPosition: f2,
            layout: b2,
            maxTabWidth: p2,
            onClick: R2,
            onFocus: N2,
            onMenuOpen: V2,
            onMenuClose: W2,
            isMenuOpen: w2,
            registerTab: _2,
            activeTabId: a2
          };
        }), [c2, k2, f2, b2, R2, N2, p2, V2, W2, w2, _2, a2]);
        var F2 = (0, n.useMemo)((function() {
          return n.Children.toArray(o2).filter(n.isValidElement).map((function(e3, t3) {
            if (e3.type.as === "Tab") {
              return (0, n.cloneElement)(e3, {
                index: t3
              });
            }
            return e3;
          }));
        }), [o2]);
        var L2 = l()(F2);
        (0, n.useEffect)((function() {
          if (L2 !== F2) {
            var e3;
            var t3 = ke(M2.current);
            if (t3.find((function(e4) {
              return e4.tabId === j2.current;
            }))) {
              return;
            }
            var n2 = Math.min((e3 = P2.current) !== null && e3 !== void 0 ? e3 : 0, t3.length - 1);
            var r2 = t3[n2];
            if (r2) {
              z2(r2.tabId);
            }
          }
        }), [F2, z2, L2]);
        return r().createElement(re, de({
          "data-tab-layout": b2,
          "data-test-active-tab-id": a2,
          "data-test": "tab-bar",
          role: "tablist",
          ref: D2,
          $layout: b2,
          onKeyDown: q2
        }, g2), r().createElement(C.Provider, {
          value: B2
        }, F2));
      }
      Te.propTypes = Ie;
      Te.Tab = ne;
      const je = Te;
      module.exports = t;
    })();
  }
});

// node_modules/@splunk/react-icons/PlusCircle.js
var require_PlusCircle = __commonJS({
  "node_modules/@splunk/react-icons/PlusCircle.js"(exports, module) {
    var import_dist16 = __toESM(require_dist());
    var import_dist17 = __toESM(require_dist2());
    var import_dist18 = __toESM(require_dist3());
    (() => {
      "use strict";
      var e = {};
      (() => {
        e.n = (r2) => {
          var t2 = r2 && r2.__esModule ? (
            /******/
            () => r2["default"]
          ) : () => r2;
          e.d(t2, {
            a: t2
          });
          return t2;
        };
      })();
      (() => {
        e.d = (r2, t2) => {
          for (var n2 in t2) {
            if (e.o(t2, n2) && !e.o(r2, n2)) {
              Object.defineProperty(r2, n2, {
                enumerable: true,
                get: t2[n2]
              });
            }
          }
        };
      })();
      (() => {
        e.o = (e2, r2) => Object.prototype.hasOwnProperty.call(e2, r2);
      })();
      (() => {
        e.r = (e2) => {
          if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
            Object.defineProperty(e2, Symbol.toStringTag, {
              value: "Module"
            });
          }
          Object.defineProperty(e2, "__esModule", {
            value: true
          });
        };
      })();
      var r = {};
      e.r(r);
      e.d(r, {
        default: () => (
          /* binding */
          s
        )
      });
      const t = require_react();
      var n = e.n(t);
      const l = require_IconProvider();
      const a = require_SVG();
      var o = e.n(a);
      function u(e2, r2) {
        if (null == e2) return {};
        var t2, n2, l2 = i(e2, r2);
        if (Object.getOwnPropertySymbols) {
          var a2 = Object.getOwnPropertySymbols(e2);
          for (n2 = 0; n2 < a2.length; n2++) {
            t2 = a2[n2], -1 === r2.indexOf(t2) && {}.propertyIsEnumerable.call(e2, t2) && (l2[t2] = e2[t2]);
          }
        }
        return l2;
      }
      function i(e2, r2) {
        if (null == e2) return {};
        var t2 = {};
        for (var n2 in e2) {
          if ({}.hasOwnProperty.call(e2, n2)) {
            if (-1 !== r2.indexOf(n2)) continue;
            t2[n2] = e2[n2];
          }
        }
        return t2;
      }
      var c = /* @__PURE__ */ new Map();
      c.set("outlined", (function() {
        return n().createElement(n().Fragment, null, n().createElement("path", {
          d: "M12 7.00427C12.5523 7.00427 13 7.45199 13 8.00427V11H16C16.5523 11 17 11.4477 17 12C17 12.5523 16.5523 13 16 13H13V16C13 16.5523 12.5523 17 12 17C11.4477 17 11 16.5523 11 16V13H8C7.44772 13 7 12.5523 7 12C7 11.4477 7.44772 11 8 11H11V8.00427C11 7.45199 11.4477 7.00427 12 7.00427Z"
        }), n().createElement("path", {
          fillRule: "evenodd",
          clipRule: "evenodd",
          d: "M22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12ZM20 12C20 16.4183 16.4183 20 12 20C7.58172 20 4 16.4183 4 12C4 7.58172 7.58172 4 12 4C16.4183 4 20 7.58172 20 12Z"
        }));
      }));
      c.set("filled", (function() {
        return n().createElement(n().Fragment, null, n().createElement("path", {
          fillRule: "evenodd",
          clipRule: "evenodd",
          d: "M22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12ZM13 8.00427C13 7.45199 12.5523 7.00427 12 7.00427C11.4477 7.00427 11 7.45199 11 8.00427V11H8C7.44772 11 7 11.4477 7 12C7 12.5523 7.44772 13 8 13H11V16C11 16.5523 11.4477 17 12 17C12.5523 17 13 16.5523 13 16V13H16C16.5523 13 17 12.5523 17 12C17 11.4477 16.5523 11 16 11H13V8.00427Z"
        }));
      }));
      var d = ["default", "outlined", "filled"];
      var f = function e2(r2) {
        return d.indexOf(r2) >= 0;
      };
      var v = function e2(r2) {
        return r2 === "default" || r2 && !f(r2) ? "outlined" : r2;
      };
      var C = function e2(r2) {
        var a2 = r2.children, i2 = r2.variant, d2 = i2 === void 0 ? "default" : i2, f2 = u(r2, ["children", "variant"]);
        var C2 = v(d2);
        var s2 = "pluscircle-".concat(C2);
        var p = (0, t.useContext)(l.IconContext);
        var m = c.get(C2);
        if (false) {
        }
        if (p && m) {
          var y = p.toRender, b = p.addIcon;
          b(s2, m());
          if (!y) {
            return null;
          }
        }
        return n().createElement(o(), f2, a2, p ? n().createElement("use", {
          href: "#".concat(s2)
        }) : !!m && m());
      };
      const s = C;
      module.exports = r;
    })();
  }
});

// node_modules/@splunk/react-ui/SplitButton.js
var require_SplitButton = __commonJS({
  "node_modules/@splunk/react-ui/SplitButton.js"(exports, module) {
    var import_dist16 = __toESM(require_dist());
    var import_dist17 = __toESM(require_dist2());
    var import_dist18 = __toESM(require_dist3());
    (() => {
      "use strict";
      var e = {};
      (() => {
        e.n = (n2) => {
          var r2 = n2 && n2.__esModule ? (
            /******/
            () => n2["default"]
          ) : () => n2;
          e.d(r2, {
            a: r2
          });
          return r2;
        };
      })();
      (() => {
        e.d = (n2, r2) => {
          for (var t2 in r2) {
            if (e.o(r2, t2) && !e.o(n2, t2)) {
              Object.defineProperty(n2, t2, {
                enumerable: true,
                get: r2[t2]
              });
            }
          }
        };
      })();
      (() => {
        e.o = (e2, n2) => Object.prototype.hasOwnProperty.call(e2, n2);
      })();
      (() => {
        e.r = (e2) => {
          if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
            Object.defineProperty(e2, Symbol.toStringTag, {
              value: "Module"
            });
          }
          Object.defineProperty(e2, "__esModule", {
            value: true
          });
        };
      })();
      var n = {};
      e.r(n);
      e.d(n, {
        Item: () => (
          /* reexport */
          k
        ),
        default: () => (
          /* reexport */
          B
        )
      });
      const r = require_react();
      var t = e.n(r);
      const a = require_prop_types();
      var i = e.n(a);
      const o = require_CaretSmallDown();
      var l = e.n(o);
      const c = require_Dropdown();
      var u = e.n(c);
      const p = require_Menu();
      var s = e.n(p);
      const d = require_i18n();
      const f = require_omit();
      var v = e.n(f);
      const m = require_Button();
      var b = e.n(m);
      function y() {
        return y = Object.assign ? Object.assign.bind() : function(e2) {
          for (var n2 = 1; n2 < arguments.length; n2++) {
            var r2 = arguments[n2];
            for (var t2 in r2) {
              ({}).hasOwnProperty.call(r2, t2) && (e2[t2] = r2[t2]);
            }
          }
          return e2;
        }, y.apply(null, arguments);
      }
      function g(e2, n2) {
        if (null == e2) return {};
        var r2, t2, a2 = O(e2, n2);
        if (Object.getOwnPropertySymbols) {
          var i2 = Object.getOwnPropertySymbols(e2);
          for (t2 = 0; t2 < i2.length; t2++) {
            r2 = i2[t2], -1 === n2.indexOf(r2) && {}.propertyIsEnumerable.call(e2, r2) && (a2[r2] = e2[r2]);
          }
        }
        return a2;
      }
      function O(e2, n2) {
        if (null == e2) return {};
        var r2 = {};
        for (var t2 in e2) {
          if ({}.hasOwnProperty.call(e2, t2)) {
            if (-1 !== n2.indexOf(t2)) continue;
            r2[t2] = e2[t2];
          }
        }
        return r2;
      }
      var h = {
        appearance: i().oneOf(["default", "secondary", "primary", "destructive", "destructiveSecondary"]),
        children: i().node,
        disabled: i().bool,
        elementRef: i().oneOfType([i().func, i().object]),
        icon: i().node,
        isMain: i().bool,
        onClick: i().func
      };
      function S(e2) {
        var n2 = e2.appearance, a2 = n2 === void 0 ? "secondary" : n2, i2 = e2.disabled, o2 = e2.elementRef, l2 = e2.icon, c2 = e2.isMain, u2 = e2.children, p2 = e2.onClick, d2 = g(e2, ["appearance", "disabled", "elementRef", "icon", "isMain", "children", "onClick"]);
        var f2 = (0, r.useCallback)((function(e3) {
          if (!i2) {
            p2 === null || p2 === void 0 ? void 0 : p2(e3, {});
          }
        }), [i2, p2]);
        var m2 = (0, r.useCallback)((function(e3, n3) {
          var r2 = n3.action, t2 = n3.icon, a3 = n3.label, o3 = n3.value;
          if (!i2) {
            p2 === null || p2 === void 0 ? void 0 : p2(e3, {
              action: r2,
              icon: t2,
              label: a3,
              value: o3
            });
          }
        }), [i2, p2]);
        if (c2) {
          return t().createElement(b(), y({
            appearance: a2,
            append: true,
            disabled: i2,
            elementRef: o2,
            icon: l2,
            onClick: m2
          }, d2), u2);
        }
        return t().createElement(s().Item, y({
          disabled: i2,
          elementRef: o2,
          onClick: f2,
          startAdornment: l2
        }, v()(d2, ["role"])), u2);
      }
      S.propTypes = h;
      const k = S;
      const w = (init_styled_components_esm(), __toCommonJS(styled_components_esm_exports));
      var j = e.n(w);
      const E = require_themes();
      var C = j()(b()).withConfig({
        displayName: "SplitButtonStyles__StyledToggle",
        componentId: "sc-9igsyh-0"
      })(["min-width:0;width:24px;"]);
      var P = j().div.withConfig({
        displayName: "SplitButtonStyles__StyledDiv",
        componentId: "sc-9igsyh-1"
      })(["", " ", " ", ""], E.mixins.reset("inline-flex"), (function(e2) {
        var n2 = e2.$appearance;
        return (n2 === "primary" || n2 === "destructive") && (0, w.css)(["gap:1px;"]);
      }), (function(e2) {
        var n2 = e2.$inline;
        return !n2 && (0, w.css)(["width:100%;"]);
      }));
      var M = "is deprecated and will be removed in the next major version.";
      var R = function e2(n2) {
        var r2 = n2.additionalMessage, t2 = r2 === void 0 ? "" : r2, a2 = n2.componentName;
        useEffect((function() {
          if (false) {
          }
        }), [t2, a2]);
      };
      var q = function e2(n2) {
        var r2 = n2.additionalMessage, t2 = r2 === void 0 ? "" : r2, a2 = n2.componentName, i2 = n2.propName, o2 = n2.propValue;
        useEffect((function() {
          if (false) {
          }
        }), [t2, a2, i2, o2]);
      };
      var x = function e2(n2) {
        var t2 = n2.additionalMessage, a2 = t2 === void 0 ? "" : t2, i2 = n2.componentName, o2 = n2.deprecatedPropValue, l2 = n2.propName, c2 = n2.propValue;
        (0, r.useEffect)((function() {
          if (false) {
          }
        }), [a2, i2, l2, c2, o2]);
      };
      function _() {
        return _ = Object.assign ? Object.assign.bind() : function(e2) {
          for (var n2 = 1; n2 < arguments.length; n2++) {
            var r2 = arguments[n2];
            for (var t2 in r2) {
              ({}).hasOwnProperty.call(r2, t2) && (e2[t2] = r2[t2]);
            }
          }
          return e2;
        }, _.apply(null, arguments);
      }
      function N(e2, n2) {
        if (null == e2) return {};
        var r2, t2, a2 = T(e2, n2);
        if (Object.getOwnPropertySymbols) {
          var i2 = Object.getOwnPropertySymbols(e2);
          for (t2 = 0; t2 < i2.length; t2++) {
            r2 = i2[t2], -1 === n2.indexOf(r2) && {}.propertyIsEnumerable.call(e2, r2) && (a2[r2] = e2[r2]);
          }
        }
        return a2;
      }
      function T(e2, n2) {
        if (null == e2) return {};
        var r2 = {};
        for (var t2 in e2) {
          if ({}.hasOwnProperty.call(e2, t2)) {
            if (-1 !== n2.indexOf(t2)) continue;
            r2[t2] = e2[t2];
          }
        }
        return r2;
      }
      var I = {
        appearance: i().oneOf(["default", "secondary", "primary", "destructive", "destructiveSecondary"]),
        children: i().node,
        disabled: i().bool,
        elementRef: i().oneOfType([i().func, i().object]),
        onClick: i().func,
        inline: i().bool,
        toggleRef: i().oneOfType([i().func, i().object])
      };
      function V(e2) {
        var n2 = e2.appearance, a2 = n2 === void 0 ? "secondary" : n2, i2 = e2.children, o2 = e2.disabled, c2 = e2.elementRef, p2 = e2.inline, f2 = p2 === void 0 ? true : p2, v2 = e2.onClick, m2 = e2.toggleRef, b2 = N(e2, ["appearance", "children", "disabled", "elementRef", "inline", "onClick", "toggleRef"]);
        x({
          componentName: "SplitButton",
          deprecatedPropValue: "default",
          propName: "appearance",
          propValue: a2
        });
        var y2 = r.Children.toArray(i2).filter(r.isValidElement);
        var g2 = 0;
        var O2 = 0;
        y2.forEach((function(e3, n3) {
          var r2 = e3.props, t2 = r2.disabled, a3 = r2.isMain;
          if (a3) {
            g2 = n3;
          }
          if (t2) {
            O2 += 1;
          }
        }));
        var h2 = (0, r.cloneElement)(y2[g2], {
          isMain: true,
          appearance: a2,
          disabled: o2 || y2[g2].props.disabled
        });
        y2.splice(g2, 1);
        var S2 = y2;
        var k2 = t().createElement(C, {
          prepend: true,
          disabled: o2 || O2 === S2.length,
          elementRef: m2,
          appearance: a2,
          "data-test": "split-button-toggle",
          "aria-label": (0, d._)("Open more options"),
          icon: t().createElement(l(), null)
        });
        return t().createElement(P, _({
          "aria-label": (0, d._)("Split button"),
          "data-inline": f2 || null,
          "data-test": "split-button-container",
          $inline: f2,
          ref: c2,
          role: "group",
          onClick: o2 ? void 0 : v2,
          $appearance: a2
        }, b2), h2, t().createElement("div", null, t().createElement(u(), {
          toggle: k2
        }, t().createElement(s(), null, S2))));
      }
      V.propTypes = I;
      V.Item = k;
      const B = V;
      module.exports = n;
    })();
  }
});

// node_modules/fscreen/dist/fscreen.esm.js
var fscreen_esm_exports = {};
__export(fscreen_esm_exports, {
  default: () => fscreen_esm_default
});
var import_dist10, import_dist11, import_dist12, key, webkit, moz, ms, document2, vendor, fscreen, fscreen_esm_default;
var init_fscreen_esm = __esm({
  "node_modules/fscreen/dist/fscreen.esm.js"() {
    import_dist10 = __toESM(require_dist());
    import_dist11 = __toESM(require_dist2());
    import_dist12 = __toESM(require_dist3());
    key = {
      fullscreenEnabled: 0,
      fullscreenElement: 1,
      requestFullscreen: 2,
      exitFullscreen: 3,
      fullscreenchange: 4,
      fullscreenerror: 5,
      fullscreen: 6
    };
    webkit = [
      "webkitFullscreenEnabled",
      "webkitFullscreenElement",
      "webkitRequestFullscreen",
      "webkitExitFullscreen",
      "webkitfullscreenchange",
      "webkitfullscreenerror",
      "-webkit-full-screen"
    ];
    moz = [
      "mozFullScreenEnabled",
      "mozFullScreenElement",
      "mozRequestFullScreen",
      "mozCancelFullScreen",
      "mozfullscreenchange",
      "mozfullscreenerror",
      "-moz-full-screen"
    ];
    ms = [
      "msFullscreenEnabled",
      "msFullscreenElement",
      "msRequestFullscreen",
      "msExitFullscreen",
      "MSFullscreenChange",
      "MSFullscreenError",
      "-ms-fullscreen"
    ];
    document2 = typeof window !== "undefined" && typeof window.document !== "undefined" ? window.document : {};
    vendor = "fullscreenEnabled" in document2 && Object.keys(key) || webkit[0] in document2 && webkit || moz[0] in document2 && moz || ms[0] in document2 && ms || [];
    fscreen = {
      requestFullscreen: function(element) {
        return element[vendor[key.requestFullscreen]]();
      },
      requestFullscreenFunction: function(element) {
        return element[vendor[key.requestFullscreen]];
      },
      get exitFullscreen() {
        return document2[vendor[key.exitFullscreen]].bind(document2);
      },
      get fullscreenPseudoClass() {
        return ":" + vendor[key.fullscreen];
      },
      addEventListener: function(type, handler, options) {
        return document2.addEventListener(vendor[key[type]], handler, options);
      },
      removeEventListener: function(type, handler, options) {
        return document2.removeEventListener(vendor[key[type]], handler, options);
      },
      get fullscreenEnabled() {
        return Boolean(document2[vendor[key.fullscreenEnabled]]);
      },
      set fullscreenEnabled(val) {
      },
      get fullscreenElement() {
        return document2[vendor[key.fullscreenElement]];
      },
      set fullscreenElement(val) {
      },
      get onfullscreenchange() {
        return document2[("on" + vendor[key.fullscreenchange]).toLowerCase()];
      },
      set onfullscreenchange(handler) {
        return document2[("on" + vendor[key.fullscreenchange]).toLowerCase()] = handler;
      },
      get onfullscreenerror() {
        return document2[("on" + vendor[key.fullscreenerror]).toLowerCase()];
      },
      set onfullscreenerror(handler) {
        return document2[("on" + vendor[key.fullscreenerror]).toLowerCase()] = handler;
      }
    };
    fscreen_esm_default = fscreen;
  }
});

// node_modules/react-full-screen/dist/index.modern.js
var index_modern_exports = {};
__export(index_modern_exports, {
  FullScreen: () => FullScreen,
  useFullScreenHandle: () => useFullScreenHandle
});
function useFullScreenHandle() {
  var _useState = (0, import_react2.useState)(false), active = _useState[0], setActive = _useState[1];
  var node = (0, import_react2.useRef)(null);
  (0, import_react2.useEffect)(function() {
    var handleChange = function handleChange2() {
      setActive(fscreen_esm_default.fullscreenElement === node.current);
    };
    fscreen_esm_default.addEventListener("fullscreenchange", handleChange);
    return function() {
      return fscreen_esm_default.removeEventListener("fullscreenchange", handleChange);
    };
  }, []);
  var enter = (0, import_react2.useCallback)(function() {
    if (fscreen_esm_default.fullscreenElement) {
      return fscreen_esm_default.exitFullscreen().then(function() {
        return fscreen_esm_default.requestFullscreen(node.current);
      });
    } else if (node.current) {
      return fscreen_esm_default.requestFullscreen(node.current);
    }
  }, []);
  var exit = (0, import_react2.useCallback)(function() {
    if (fscreen_esm_default.fullscreenElement === node.current) {
      return fscreen_esm_default.exitFullscreen();
    }
    return Promise.resolve();
  }, []);
  return (0, import_react2.useMemo)(function() {
    return {
      active,
      enter,
      exit,
      node
    };
  }, [active, enter, exit]);
}
var import_dist13, import_dist14, import_dist15, import_react2, FullScreen;
var init_index_modern = __esm({
  "node_modules/react-full-screen/dist/index.modern.js"() {
    import_dist13 = __toESM(require_dist());
    import_dist14 = __toESM(require_dist2());
    import_dist15 = __toESM(require_dist3());
    import_react2 = __toESM(require_react());
    init_fscreen_esm();
    FullScreen = function FullScreen2(_ref) {
      var handle = _ref.handle, onChange = _ref.onChange, children = _ref.children, className = _ref.className;
      var classNames = [];
      if (className) {
        classNames.push(className);
      }
      classNames.push("fullscreen");
      if (handle.active) {
        classNames.push("fullscreen-enabled");
      }
      (0, import_react2.useEffect)(function() {
        if (onChange) {
          onChange(handle.active, handle);
        }
      }, [handle.active]);
      return import_react2.default.createElement("div", {
        className: classNames.join(" "),
        ref: handle.node,
        style: handle.active ? {
          height: "100%",
          width: "100%"
        } : void 0
      }, children);
    };
  }
});

// node_modules/@splunk/dashboard-core/index.js
var require_dashboard_core = __commonJS({
  "node_modules/@splunk/dashboard-core/index.js"(exports, module) {
    var import_dist16 = __toESM(require_dist());
    var import_dist17 = __toESM(require_dist2());
    var import_dist18 = __toESM(require_dist3());
    var __create = Object.create;
    var __defProp = Object.defineProperty;
    var __defProps = Object.defineProperties;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __getOwnPropSymbols = Object.getOwnPropertySymbols;
    var __getProtoOf = Object.getPrototypeOf;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __propIsEnum = Object.prototype.propertyIsEnumerable;
    var __defNormalProp = (obj, key2, value) => key2 in obj ? __defProp(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
    var __spreadValues = (a, b) => {
      for (var prop in b || (b = {}))
        if (__hasOwnProp.call(b, prop))
          __defNormalProp(a, prop, b[prop]);
      if (__getOwnPropSymbols)
        for (var prop of __getOwnPropSymbols(b)) {
          if (__propIsEnum.call(b, prop))
            __defNormalProp(a, prop, b[prop]);
        }
      return a;
    };
    var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
    var __objRest = (source, exclude) => {
      var target = {};
      for (var prop in source)
        if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
          target[prop] = source[prop];
      if (source != null && __getOwnPropSymbols)
        for (var prop of __getOwnPropSymbols(source)) {
          if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
            target[prop] = source[prop];
        }
      return target;
    };
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key2 of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key2) && key2 !== except)
            __defProp(to, key2, { get: () => from[key2], enumerable: !(desc = __getOwnPropDesc(from, key2)) || desc.enumerable });
      }
      return to;
    };
    var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
    var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
      // If the importer is in node compatibility mode or this is not an ESM
      // file that has been converted to a CommonJS file using a Babel-
      // compatible transform (i.e. "__esModule" has not been set), then set
      // "default" to the CommonJS "module.exports" for node compatibility.
      isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
      mod
    ));
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export2(src_exports, {
      DashboardCore: () => DashboardCore2,
      default: () => src_default
    });
    module.exports = __toCommonJS2(src_exports);
    var lodash_exports = {};
    __export2(lodash_exports, {
      default: () => lodash_default
    });
    var defaultImport = __toESM2(require_lodash());
    __reExport(lodash_exports, require_lodash());
    var lodash_default = "default" in defaultImport ? defaultImport.default : defaultImport;
    var react_exports = {};
    __export2(react_exports, {
      default: () => react_default
    });
    var defaultImport2 = __toESM2(require_react());
    __reExport(react_exports, require_react());
    var react_default = "default" in defaultImport2 ? defaultImport2.default : defaultImport2;
    var dashboard_context_exports = {};
    __export2(dashboard_context_exports, {
      default: () => dashboard_context_default
    });
    var defaultImport3 = __toESM2(require_dist5());
    __reExport(dashboard_context_exports, require_dist5());
    var dashboard_context_default = "default" in defaultImport3 ? defaultImport3.default : defaultImport3;
    var dashboard_utils_exports = {};
    __export2(dashboard_utils_exports, {
      default: () => dashboard_utils_default
    });
    var defaultImport4 = __toESM2(require_dashboard_utils());
    __reExport(dashboard_utils_exports, require_dashboard_utils());
    var dashboard_utils_default = "default" in defaultImport4 ? defaultImport4.default : defaultImport4;
    var dashboard_state_exports = {};
    __export2(dashboard_state_exports, {
      default: () => dashboard_state_default
    });
    var defaultImport5 = __toESM2(require_dist4());
    __reExport(dashboard_state_exports, require_dist4());
    var dashboard_state_default = "default" in defaultImport5 ? defaultImport5.default : defaultImport5;
    var dashboard_validation_exports = {};
    __export2(dashboard_validation_exports, {
      default: () => dashboard_validation_default
    });
    var defaultImport6 = __toESM2(require_cjs());
    __reExport(dashboard_validation_exports, require_cjs());
    var dashboard_validation_default = "default" in defaultImport6 ? defaultImport6.default : defaultImport6;
    var dashboard_ui_exports = {};
    __export2(dashboard_ui_exports, {
      default: () => dashboard_ui_default
    });
    var defaultImport7 = __toESM2(require_dashboard_ui());
    __reExport(dashboard_ui_exports, require_dashboard_ui());
    var dashboard_ui_default = "default" in defaultImport7 ? defaultImport7.default : defaultImport7;
    var styled_components_exports = {};
    __export2(styled_components_exports, {
      default: () => styled_components_default
    });
    var defaultImport8 = __toESM2((init_styled_components_esm(), __toCommonJS(styled_components_esm_exports)));
    __reExport(styled_components_exports, (init_styled_components_esm(), __toCommonJS(styled_components_esm_exports)));
    var styled_components_default = "default" in defaultImport8 ? defaultImport8.default : defaultImport8;
    var react_resize_detector_exports = {};
    __export2(react_resize_detector_exports, {
      default: () => react_resize_detector_default
    });
    var defaultImport9 = __toESM2((init_build(), __toCommonJS(build_exports)));
    __reExport(react_resize_detector_exports, (init_build(), __toCommonJS(build_exports)));
    var react_resize_detector_default = "default" in defaultImport9 ? defaultImport9.default : defaultImport9;
    var sortable_exports = {};
    __export2(sortable_exports, {
      default: () => sortable_default
    });
    var defaultImport10 = __toESM2((init_sortable_esm(), __toCommonJS(sortable_esm_exports)));
    __reExport(sortable_exports, (init_sortable_esm(), __toCommonJS(sortable_esm_exports)));
    var sortable_default = "default" in defaultImport10 ? defaultImport10.default : defaultImport10;
    var mixins_exports = {};
    __export2(mixins_exports, {
      default: () => mixins_default
    });
    var defaultImport11 = __toESM2(require_mixins());
    __reExport(mixins_exports, require_mixins());
    var mixins_default = "default" in defaultImport11 ? defaultImport11.default : defaultImport11;
    var core_exports = {};
    __export2(core_exports, {
      default: () => core_default
    });
    var defaultImport12 = __toESM2((init_core_esm(), __toCommonJS(core_esm_exports)));
    __reExport(core_exports, (init_core_esm(), __toCommonJS(core_esm_exports)));
    var core_default = "default" in defaultImport12 ? defaultImport12.default : defaultImport12;
    var EMPTY_GLOBAL_INPUTS = Object.freeze([]);
    var useDashboardDragMonitor = () => {
      var _a;
      const dashboardCoreApi = (0, dashboard_context_exports.useDashboardCoreApi)();
      const globalInputs = (0, dashboard_state_exports.useSelector)(dashboard_state_exports.selectGlobalInputs);
      const submitButton = !!((_a = (0, dashboard_state_exports.useSelector)(dashboard_state_exports.selectLayoutGlobalOptions)) == null ? void 0 : _a.submitButton);
      const globalInputIds = (0, react_exports.useMemo)(() => {
        if ((globalInputs == null ? void 0 : globalInputs.length) && submitButton) {
          return [...globalInputs, dashboard_context_exports.GlobalInputSubmitDraggableId];
        }
        return globalInputs != null ? globalInputs : EMPTY_GLOBAL_INPUTS;
      }, [globalInputs, submitButton]);
      const activeDragId = (0, react_exports.useRef)();
      (0, react_exports.useEffect)(() => {
        activeDragId.current = void 0;
      }, [globalInputs]);
      const onDragStart = (0, react_exports.useCallback)(({ active }) => {
        activeDragId.current = !(active == null ? void 0 : active.id) ? void 0 : active.id;
      }, []);
      const onDragCancel = (0, react_exports.useCallback)(() => {
        activeDragId.current = void 0;
      }, []);
      const onDragEnd = (0, react_exports.useCallback)(
        ({ active, over }) => {
          if (!activeDragId.current || (active == null ? void 0 : active.id) === (over == null ? void 0 : over.id)) {
            return;
          }
          if (!globalInputs || globalInputs.length < 2) {
            return;
          }
          dashboardCoreApi.updateInputStructure(
            (0, sortable_exports.arrayMove)(
              globalInputs,
              globalInputs.indexOf(active.id),
              globalInputs.indexOf(over == null ? void 0 : over.id)
            )
          );
          activeDragId.current = void 0;
        },
        [dashboardCoreApi, globalInputs]
      );
      (0, core_exports.useDndMonitor)({ onDragStart, onDragCancel, onDragEnd });
      return globalInputIds;
    };
    var Button_exports = {};
    __export2(Button_exports, {
      default: () => Button_default
    });
    var defaultImport13 = __toESM2(require_Button());
    __reExport(Button_exports, require_Button());
    var Button_default = "default" in defaultImport13 ? defaultImport13.default : defaultImport13;
    var Prose_exports = {};
    __export2(Prose_exports, {
      default: () => Prose_default
    });
    var defaultImport14 = __toESM2(require_Prose());
    __reExport(Prose_exports, require_Prose());
    var Prose_default = "default" in defaultImport14 ? defaultImport14.default : defaultImport14;
    var i18n_exports = {};
    __export2(i18n_exports, {
      default: () => i18n_default
    });
    var defaultImport15 = __toESM2(require_i18n());
    __reExport(i18n_exports, require_i18n());
    var i18n_default = "default" in defaultImport15 ? defaultImport15.default : defaultImport15;
    var format_exports = {};
    __export2(format_exports, {
      default: () => format_default
    });
    var defaultImport16 = __toESM2(require_format());
    __reExport(format_exports, require_format());
    var format_default = "default" in defaultImport16 ? defaultImport16.default : defaultImport16;
    var Paragraph_exports = {};
    __export2(Paragraph_exports, {
      default: () => Paragraph_default
    });
    var defaultImport17 = __toESM2(require_Paragraph());
    __reExport(Paragraph_exports, require_Paragraph());
    var Paragraph_default = "default" in defaultImport17 ? defaultImport17.default : defaultImport17;
    var formatInputName = ({
      id,
      itemDef
    }) => {
      if (!itemDef) {
        return void 0;
      }
      const {
        title,
        options: { token, tokenNamespace = dashboard_utils_exports.DEFAULT_TOKEN_NAMESPACE } = {}
      } = itemDef;
      if (title) {
        return title;
      }
      if (token) {
        return tokenNamespace && tokenNamespace !== dashboard_utils_exports.DEFAULT_TOKEN_NAMESPACE ? `${tokenNamespace}:${token}` : token;
      }
      return id;
    };
    var HideContextualInfo = (0, i18n_exports._)(
      'Deleting the time range picker "%s" might prevent search execution. Instead, you can hide it in View mode.'
    );
    var HideConfirmationText = (0, i18n_exports._)(
      "Do you want to continue deleting the time range picker?"
    );
    var DeleteContextualInfo = (0, i18n_exports._)(
      'You are about to delete the time range picker "%s".'
    );
    var DeleteConfirmationText = (0, i18n_exports._)("Are you sure?");
    var SingleItemBody = ({
      id,
      itemDef,
      canHide = false
    }) => {
      if (!itemDef) {
        return null;
      }
      const inputName = formatInputName({ id, itemDef });
      return canHide ? react_default.createElement(react_default.Fragment, null, react_default.createElement(Paragraph_default, null, (0, format_exports.sprintf)(HideContextualInfo, inputName)), react_default.createElement(Paragraph_default, null, HideConfirmationText)) : react_default.createElement(react_default.Fragment, null, react_default.createElement(Paragraph_default, null, (0, format_exports.sprintf)(DeleteContextualInfo, inputName)), react_default.createElement(Paragraph_default, null, DeleteConfirmationText));
    };
    var List_exports = {};
    __export2(List_exports, {
      default: () => List_default
    });
    var defaultImport18 = __toESM2(require_List());
    __reExport(List_exports, require_List());
    var List_default = "default" in defaultImport18 ? defaultImport18.default : defaultImport18;
    var ContentTemplate = (0, i18n_exports._)(
      "You are about to delete %d time range pickers. Are you sure?"
    );
    var DeleteMultipleBody = ({
      ids,
      inputs
    }) => react_default.createElement(react_default.Fragment, null, react_default.createElement(Paragraph_default, null, (0, format_exports.sprintf)(ContentTemplate, ids.length)), react_default.createElement(List_default, null, ids.map(
      (id) => !!(inputs == null ? void 0 : inputs[id]) && react_default.createElement(List_default.Item, { key: id }, formatInputName({ id, itemDef: inputs[id] }))
    )));
    var StyledModal = styled_components_default(dashboard_ui_exports.Modal)`
    width: 600px;
    max-width: 90%;
`;
    var StyledBodyProse = styled_components_default(Prose_default)`
    // include StyledModal to increase specificity so this overrides without !important
    ${StyledModal} & > :is(p, ul) {
        margin-block-end: 1rem;
    }
`;
    var DeleteButton = (0, dashboard_ui_exports.SecondaryActionButton)(StyledModal);
    var DeleteOneInputTitle = (0, i18n_exports._)("Delete time range picker");
    var DeleteMultipleInputsTitle = (0, i18n_exports._)("Delete time range pickers");
    var Labels = {
      cancel: (0, i18n_exports._)("Cancel"),
      hide: (0, i18n_exports._)("Hide"),
      yesDelete: (0, i18n_exports._)("Yes, delete")
    };
    var NoGlobalInputs = [];
    var ConfirmInputRemovalModal = ({
      deletionConfirmation: { modalIds, additionalIds }
    }) => {
      var _a, _b, _c, _d, _e;
      const { enableShowHide, confirmGlobalTimeRangeDeletion } = (0, dashboard_context_exports.useFeatureFlags)();
      const dashboardApi = (0, dashboard_context_exports.useDashboardCoreApi)();
      const dispatch = (0, dashboard_state_exports.useDispatch)();
      const globalInputIds = (_a = (0, dashboard_state_exports.useSelector)(dashboard_state_exports.selectGlobalInputs)) != null ? _a : NoGlobalInputs;
      const canSuggestHide = enableShowHide && modalIds.length === 1 && !(additionalIds == null ? void 0 : additionalIds.length) && globalInputIds.includes(modalIds[0]) && !((_e = (_d = (_c = (_b = dashboardApi.getDefinition().inputs) == null ? void 0 : _b[modalIds[0]]) == null ? void 0 : _c.containerOptions) == null ? void 0 : _d.visibility) == null ? void 0 : _e.hideInViewMode);
      const handleCancel = (0, react_exports.useCallback)(() => {
        dispatch((0, dashboard_state_exports.setConfirmDeletionIds)());
      }, [dispatch]);
      const handleHide = (0, react_exports.useCallback)(() => {
        (0, dashboard_state_exports.batch)(() => {
          dispatch(
            (0, dashboard_state_exports.setItemVisibility)({
              itemId: modalIds[0],
              itemType: "input",
              property: "hideInViewMode",
              value: true
            })
          );
          dispatch((0, dashboard_state_exports.setConfirmDeletionIds)());
        });
      }, [dispatch, modalIds]);
      const handleDelete = (0, react_exports.useCallback)(() => {
        (0, dashboard_state_exports.batch)(() => {
          dashboardApi.removeDashboardItems([
            ...modalIds,
            ...additionalIds != null ? additionalIds : []
          ]);
          dispatch((0, dashboard_state_exports.setConfirmDeletionIds)());
        });
      }, [additionalIds, modalIds, dashboardApi, dispatch]);
      (0, react_exports.useEffect)(() => {
        if (!confirmGlobalTimeRangeDeletion) {
          handleDelete();
        }
      }, [handleDelete, confirmGlobalTimeRangeDeletion]);
      const modalBody = (0, react_exports.useMemo)(() => {
        var _a2;
        const inputs = (_a2 = dashboardApi.getDefinition().inputs) != null ? _a2 : {};
        if (canSuggestHide) {
          const [id] = modalIds;
          return react_default.createElement(SingleItemBody, { id, itemDef: inputs[id], canHide: true });
        }
        return modalIds.length === 1 ? react_default.createElement(SingleItemBody, { id: modalIds[0], itemDef: inputs[modalIds[0]] }) : react_default.createElement(DeleteMultipleBody, { ids: modalIds, inputs });
      }, [canSuggestHide, dashboardApi, modalIds]);
      const modalTitle = modalIds.length === 1 ? DeleteOneInputTitle : DeleteMultipleInputsTitle;
      if (!confirmGlobalTimeRangeDeletion) {
        return null;
      }
      return react_default.createElement(
        StyledModal,
        {
          "data-test": "confirm-trp-deletion-modal",
          onRequestClose: handleCancel,
          open: true,
          returnFocus: dashboard_utils_exports.noop
        },
        react_default.createElement(dashboard_ui_exports.Modal.Header, { title: modalTitle }),
        react_default.createElement(dashboard_ui_exports.Modal.Body, null, react_default.createElement(StyledBodyProse, null, modalBody)),
        react_default.createElement(dashboard_ui_exports.Modal.Footer, null, canSuggestHide && react_default.createElement(
          DeleteButton,
          {
            "data-test": "delete-input-button",
            appearance: "subtle",
            onClick: handleDelete,
            label: Labels.yesDelete
          }
        ), react_default.createElement(
          Button_default,
          {
            "data-test": "cancel-button",
            appearance: "secondary",
            onClick: handleCancel,
            label: Labels.cancel
          }
        ), canSuggestHide ? react_default.createElement(
          Button_default,
          {
            "data-test": "hide-input-button",
            appearance: "primary",
            onClick: handleHide,
            label: Labels.hide
          }
        ) : react_default.createElement(
          Button_default,
          {
            "data-test": "delete-input-button",
            appearance: "destructive",
            onClick: handleDelete,
            label: Labels.yesDelete
          }
        ))
      );
    };
    var ConfirmationModal = (0, dashboard_state_exports.withSelectorValue)(ConfirmInputRemovalModal, {
      selector: dashboard_state_exports.selectDeletionConfirmation,
      selectorResultProp: "deletionConfirmation",
      validationFn: (value) => {
        var _a;
        return !!((_a = value == null ? void 0 : value.modalIds) == null ? void 0 : _a.length);
      }
    });
    var modifiers_exports = {};
    __export2(modifiers_exports, {
      default: () => modifiers_default
    });
    var defaultImport19 = __toESM2((init_modifiers_esm(), __toCommonJS(modifiers_esm_exports)));
    __reExport(modifiers_exports, (init_modifiers_esm(), __toCommonJS(modifiers_esm_exports)));
    var modifiers_default = "default" in defaultImport19 ? defaultImport19.default : defaultImport19;
    var themes_exports = {};
    __export2(themes_exports, {
      default: () => themes_default
    });
    var defaultImport20 = __toESM2(require_themes());
    __reExport(themes_exports, require_themes());
    var themes_default = "default" in defaultImport20 ? defaultImport20.default : defaultImport20;
    var Menu_exports = {};
    __export2(Menu_exports, {
      default: () => Menu_default
    });
    var defaultImport21 = __toESM2(require_Menu());
    __reExport(Menu_exports, require_Menu());
    var Menu_default = "default" in defaultImport21 ? defaultImport21.default : defaultImport21;
    var ScreenReaderContent_exports = {};
    __export2(ScreenReaderContent_exports, {
      default: () => ScreenReaderContent_default
    });
    var defaultImport22 = __toESM2(require_ScreenReaderContent());
    __reExport(ScreenReaderContent_exports, require_ScreenReaderContent());
    var ScreenReaderContent_default = "default" in defaultImport22 ? defaultImport22.default : defaultImport22;
    var TabBar_exports = {};
    __export2(TabBar_exports, {
      default: () => TabBar_default
    });
    var defaultImport23 = __toESM2(require_TabBar());
    __reExport(TabBar_exports, require_TabBar());
    var TabBar_default = "default" in defaultImport23 ? defaultImport23.default : defaultImport23;
    var createReorderMenuItems = ({
      index,
      length,
      onTabReorder
    }) => {
      if (length < 2 || index < 0 || index >= length) {
        return [];
      }
      const canMoveLeft = index > 0;
      const canMoveRight = index < length - 1;
      const canMoveCompletelyLeft = canMoveLeft && index !== 1;
      const canMoveCompletelyRight = canMoveRight && index !== length - 2;
      const onClickGenerator = ({ from, to }) => () => onTabReorder({ from, to });
      return [
        canMoveLeft && react_default.createElement(
          Menu_default.Item,
          {
            key: "move-left",
            "data-test": "move-left",
            onClick: onClickGenerator({ from: index, to: index - 1 })
          },
          (0, i18n_exports._)("Move left")
        ),
        canMoveRight && react_default.createElement(
          Menu_default.Item,
          {
            key: "move-right",
            "data-test": "move-right",
            onClick: onClickGenerator({ from: index, to: index + 1 })
          },
          (0, i18n_exports._)("Move right")
        ),
        canMoveCompletelyLeft && react_default.createElement(
          Menu_default.Item,
          {
            key: "move-completely-left",
            "data-test": "move-completely-left",
            onClick: onClickGenerator({ from: index, to: 0 })
          },
          (0, i18n_exports._)("Move completely left")
        ),
        canMoveCompletelyRight && react_default.createElement(
          Menu_default.Item,
          {
            key: "move-completely-right",
            "data-test": "move-completely-right",
            onClick: onClickGenerator({ from: index, to: length - 1 })
          },
          (0, i18n_exports._)("Move completely right")
        )
      ];
    };
    var StyledMenuItem = styled_components_default(Menu_default.Item)`
    color: ${themes_exports.variables.contentColorNegative};
`;
    var RemoveTab = ({ layoutId }) => {
      const dispatch = (0, dashboard_state_exports.useDispatch)();
      const handleOnClick = (0, react_exports.useCallback)(() => {
        dispatch((0, dashboard_state_exports.removeTab)(layoutId));
      }, [dispatch, layoutId]);
      return react_default.createElement(
        StyledMenuItem,
        {
          "data-test": "remove-tab-menu-item",
          onClick: handleOnClick
        },
        (0, i18n_exports._)("Remove tab")
      );
    };
    var useDeselectOnActiveTabPress = ({
      tabId,
      isDragging = false
    }) => {
      const dispatch = (0, dashboard_state_exports.useDispatch)();
      const activeTabId = (0, dashboard_state_exports.useSelector)(dashboard_state_exports.selectActiveTab);
      const activeTabIdRef = (0, react_exports.useRef)(activeTabId);
      activeTabIdRef.current = activeTabId;
      const isDraggingRef = (0, react_exports.useRef)(isDragging);
      isDraggingRef.current = isDragging;
      return (0, react_exports.useCallback)(
        (event) => {
          var _a;
          if (
            // if the clicked tab is currently active
            tabId === activeTabIdRef.current && // and the tab isn't being dragged
            !isDraggingRef.current && // and the user didn't click the kebab menu
            !((_a = event.target) == null ? void 0 : _a.hasAttribute("aria-haspopup"))
          ) {
            (0, dashboard_state_exports.batch)(() => {
              dispatch((0, dashboard_state_exports.updateSelectedItems)([]));
              dispatch((0, dashboard_state_exports.updateSelectedGlobalItems)([]));
            });
          }
        },
        [tabId, dispatch]
      );
    };
    var updateReactRef = (ref, current) => {
      if (!ref) {
        return;
      }
      if (typeof ref === "function") {
        ref(current);
      } else {
        ref.current = current;
      }
    };
    var ConnectedTab = (_a) => {
      var _b = _a, {
        tabId,
        elementRef,
        isDragging = false
      } = _b, rest = __objRest(_b, [
        "tabId",
        "elementRef",
        "isDragging"
      ]);
      const handleTabClick = useDeselectOnActiveTabPress({ tabId, isDragging });
      const handleRef = (0, react_exports.useMemo)(() => {
        let prevNode = null;
        let prevHandler;
        return (el) => {
          if (prevNode && prevHandler) {
            prevNode.removeEventListener("click", prevHandler);
          }
          prevNode = el;
          prevHandler = handleTabClick;
          el == null ? void 0 : el.addEventListener("click", handleTabClick);
          updateReactRef(elementRef, el);
        };
      }, [elementRef, handleTabClick]);
      return react_default.createElement(TabBar_default.Tab, __spreadProps(__spreadValues({}, rest), { tabId, elementRef: handleRef }));
    };
    ConnectedTab.as = TabBar_default.Tab.as;
    var utilities_exports = {};
    __export2(utilities_exports, {
      default: () => utilities_default
    });
    var defaultImport24 = __toESM2((init_utilities_esm(), __toCommonJS(utilities_esm_exports)));
    __reExport(utilities_exports, (init_utilities_esm(), __toCommonJS(utilities_esm_exports)));
    var utilities_default = "default" in defaultImport24 ? defaultImport24.default : defaultImport24;
    var Tab = (_a) => {
      var _b = _a, {
        tabId,
        elementRef
      } = _b, rest = __objRest(_b, [
        "tabId",
        "elementRef"
      ]);
      const { listeners, setNodeRef, transform, transition, isDragging } = (0, sortable_exports.useSortable)({
        id: tabId != null ? tabId : ""
      });
      const style = (0, react_exports.useMemo)(
        () => ({
          // CSS.Translate is needed instead of CSS.Transform because we don't want `scale` applied
          //  due to our tab sizes differing.
          transform: utilities_exports.CSS.Translate.toString(transform),
          transition
        }),
        [transform, transition]
      );
      const handleRef = (0, react_exports.useCallback)(
        (el) => {
          updateReactRef(elementRef, el);
          setNodeRef(el);
        },
        [elementRef, setNodeRef]
      );
      return react_default.createElement(
        ConnectedTab,
        __spreadProps(__spreadValues(__spreadValues({
          style,
          tabId,
          isDragging
        }, rest), listeners), {
          elementRef: handleRef
        })
      );
    };
    Tab.as = TabBar_default.Tab.as;
    var menuStyle = { width: 180 };
    var TabsContainer = styled_components_default.div.attrs({
      "data-test": "TabsContainer"
    })`
    min-width: ${({ mode }) => mode === "view" ? "100%" : "auto"};
    display: flex;
    flex-shrink: 0;
`;
    var TabsContainerInner = styled_components_default.div.attrs({
      "data-test": "TabsContainerInner"
    })`
    width: 100%;
`;
    var StyledTabBar = styled_components_default(TabBar_default)`
    padding-inline: ${themes_exports.variables.spacingMedium};
`;
    var TabBar = () => {
      const tabs = (0, dashboard_state_exports.useSelector)(dashboard_state_exports.selectTabs);
      const tabIds = (0, react_exports.useMemo)(() => tabs.map((tab) => tab.layoutId), [tabs]);
      const mode = (0, dashboard_state_exports.useSelector)(dashboard_state_exports.selectMode);
      const tabContainerRef = (0, dashboard_context_exports.useTabsRef)("container");
      const dispatch = (0, dashboard_state_exports.useDispatch)();
      const handleTabChange = (0, react_exports.useCallback)(
        (e, { selectedTabId }) => {
          if (selectedTabId) {
            dispatch((0, dashboard_state_exports.setActiveTab)(selectedTabId));
          }
        },
        [dispatch]
      );
      const handleTabReorder = (0, react_exports.useCallback)(
        ({ from, to }) => {
          const newOrder = (0, sortable_exports.arrayMove)(tabs, from, to);
          dispatch((0, dashboard_state_exports.updateTabsStructure)(newOrder));
        },
        [dispatch, tabs]
      );
      const activeTabId = (0, dashboard_state_exports.useSelector)(dashboard_state_exports.selectActiveTab);
      const activeTab = tabs.find((tab) => tab.layoutId === activeTabId);
      const tabElements = (0, react_exports.useMemo)(() => {
        const TabComponent = mode === "view" ? ConnectedTab : Tab;
        return tabs.map((tab, idx) => {
          var _a;
          const tabLabel = ((_a = tab.label) == null ? void 0 : _a.trim()) || (0, i18n_exports._)(`Unnamed tab`);
          const reorderMenuItems = createReorderMenuItems({
            index: idx,
            length: tabs.length,
            onTabReorder: handleTabReorder
          });
          const shouldRenderMenu = mode === "edit" && tabs.length > 1;
          return react_default.createElement(
            TabComponent,
            {
              key: tab.layoutId,
              label: tabLabel,
              tabId: tab.layoutId,
              menu: shouldRenderMenu && react_default.createElement(Menu_default, { style: menuStyle }, reorderMenuItems, react_default.createElement(RemoveTab, { layoutId: tab.layoutId }))
            }
          );
        });
      }, [handleTabReorder, mode, tabs]);
      const onDragEnd = (0, react_exports.useCallback)(
        ({ active, over }) => {
          if (!over || active.id === over.id) {
            return;
          }
          if (!tabs || tabs.length < 2) {
            return;
          }
          const from = tabs.findIndex((tab) => tab.layoutId === active.id);
          const to = tabs.findIndex((tab) => tab.layoutId === over.id);
          handleTabReorder({ from, to });
        },
        [handleTabReorder, tabs]
      );
      (0, core_exports.useDndMonitor)({ onDragEnd });
      if (mode === "view" && tabs.length <= 1) {
        return null;
      }
      return react_default.createElement(
        sortable_exports.SortableContext,
        {
          id: "sortable-tab-bar",
          items: tabIds,
          strategy: sortable_exports.horizontalListSortingStrategy
        },
        react_default.createElement(TabsContainer, { mode }, react_default.createElement(TabsContainerInner, null, react_default.createElement(
          StyledTabBar,
          {
            activeTabId,
            onChange: handleTabChange,
            elementRef: tabContainerRef
          },
          tabElements
        ), activeTab && react_default.createElement(ScreenReaderContent_default, { "aria-live": "polite" }, `${(0, i18n_exports._)("Active tab")}: ${activeTab.label} `)))
      );
    };
    var Tooltip_exports = {};
    __export2(Tooltip_exports, {
      default: () => Tooltip_default
    });
    var defaultImport25 = __toESM2(require_Tooltip());
    __reExport(Tooltip_exports, require_Tooltip());
    var Tooltip_default = "default" in defaultImport25 ? defaultImport25.default : defaultImport25;
    var PlusCircle_exports = {};
    __export2(PlusCircle_exports, {
      default: () => PlusCircle_default
    });
    var defaultImport26 = __toESM2(require_PlusCircle());
    __reExport(PlusCircle_exports, require_PlusCircle());
    var PlusCircle_default = "default" in defaultImport26 ? defaultImport26.default : defaultImport26;
    var Plus_exports = {};
    __export2(Plus_exports, {
      default: () => Plus_default
    });
    var defaultImport27 = __toESM2(require_Plus());
    __reExport(Plus_exports, require_Plus());
    var Plus_default = "default" in defaultImport27 ? defaultImport27.default : defaultImport27;
    var SplitButton_exports = {};
    __export2(SplitButton_exports, {
      default: () => SplitButton_default
    });
    var defaultImport28 = __toESM2(require_SplitButton());
    __reExport(SplitButton_exports, require_SplitButton());
    var SplitButton_default = "default" in defaultImport28 ? defaultImport28.default : defaultImport28;
    var plusIcon = react_default.createElement(Plus_default, null);
    var plusCircleIcon = react_default.createElement(PlusCircle_default, { width: 24, height: 24 });
    var tooltipStyle = { margin: "0 10px" };
    var addTabLabel = (0, i18n_exports._)("Add a tab");
    var importTabLabel = (0, i18n_exports._)("Import a dashboard");
    var AddTabButton = ({ label = addTabLabel }) => {
      const dispatch = (0, dashboard_state_exports.useDispatch)();
      const addTabRef = (0, dashboard_context_exports.useTabsRef)("addTab");
      const importTabRef = (0, dashboard_context_exports.useTabsRef)("importTab");
      const [mainOption, setMainOption] = (0, react_exports.useState)("addTab");
      const { importTabModal: ImportTabModal } = (0, dashboard_context_exports.useCoreOverrides)();
      const { allowImportTab } = (0, dashboard_context_exports.useFeatureFlags)();
      const [open, setOpen] = (0, react_exports.useState)(false);
      const handleAddTab = (0, react_exports.useCallback)(() => {
        setMainOption("addTab");
        dispatch((0, dashboard_state_exports.addEmptyTab)());
      }, [dispatch]);
      const handleImportTab = (0, react_exports.useCallback)(() => {
        setMainOption("importTab");
        setOpen(true);
      }, []);
      const handleRequestClose = (0, react_exports.useCallback)(() => {
        setOpen(false);
      }, []);
      if (!allowImportTab || !ImportTabModal) {
        return react_default.createElement(
          Tooltip_default,
          {
            contentRelationship: "label",
            content: label,
            style: tooltipStyle
          },
          react_default.createElement(
            Button_default,
            {
              "data-test": "add-tab-button",
              appearance: "subtle",
              icon: plusCircleIcon,
              elementRef: addTabRef,
              onClick: handleAddTab
            }
          )
        );
      }
      const duplicateOption = mainOption === "addTab" ? react_default.createElement(SplitButton_default.Item, { "data-test": "add-tab-option", onClick: handleAddTab }, addTabLabel) : react_default.createElement(
        SplitButton_default.Item,
        {
          "data-test": "import-tab-option",
          onClick: handleImportTab
        },
        importTabLabel
      );
      const addTabProps = mainOption === "addTab" ? {
        "data-test": "add-tab-button",
        icon: plusIcon,
        isMain: true
      } : { "data-test": "add-tab-option" };
      const importTabProps = mainOption === "importTab" ? {
        "data-test": "import-tab-button",
        icon: plusIcon,
        isMain: true
      } : { "data-test": "import-tab-option" };
      return react_default.createElement(react_default.Fragment, null, react_default.createElement(SplitButton_default, null, react_default.createElement(
        SplitButton_default.Item,
        __spreadValues({
          elementRef: addTabRef,
          onClick: handleAddTab
        }, addTabProps),
        addTabLabel
      ), duplicateOption, react_default.createElement(
        SplitButton_default.Item,
        __spreadValues({
          onClick: handleImportTab,
          elementRef: importTabRef
        }, importTabProps),
        importTabLabel
      )), ImportTabModal && react_default.createElement(ImportTabModal, { onModalClose: handleRequestClose, open }));
    };
    var ActionBar = styled_components_default.div.attrs({
      "data-test": "tab-action-bar"
    })`
    display: flex;
    flex-direction: row;
    justify-content: left;
    flex-grow: 1;
    align-items: center;
`;
    var TabActionBar = () => {
      const mode = (0, dashboard_state_exports.useSelector)(dashboard_state_exports.selectMode);
      const ref = (0, dashboard_context_exports.useTabsRef)("tabActionBar");
      if (mode !== "edit") {
        return null;
      }
      return react_default.createElement(ActionBar, { ref }, react_default.createElement(AddTabButton, null));
    };
    var modifiers = [modifiers_exports.restrictToHorizontalAxis, modifiers_exports.restrictToParentElement];
    var TabsContainer2 = styled_components_default.div.attrs({
      "data-test": "tabs-container"
    })`
    display: flex;
    flex-direction: row;
    width: 100%;
    flex-shrink: 0;
    gap: ${themes_exports.variables.spacingSmall};
    padding-top: ${themes_exports.variables.spacingSmall};
    // z-index needed so that focus on tabs does not get clipped by canvas
    z-index: 1;
`;
    var TabContainer = () => {
      const sensors = (0, core_exports.useSensors)(
        (0, core_exports.useSensor)(core_exports.MouseSensor, { activationConstraint: { distance: 5 } })
      );
      return react_default.createElement(TabsContainer2, null, react_default.createElement(core_exports.DndContext, { sensors, modifiers }, react_default.createElement(TabBar, null)), react_default.createElement(TabActionBar, null));
    };
    var getHasDrilldown = (eventHandlers) => {
      if (!Array.isArray(eventHandlers)) {
        return false;
      }
      return !!eventHandlers.find((eventHandler) => {
        return /^drilldown/.test(eventHandler.type);
      });
    };
    var react_dom_exports = {};
    __export2(react_dom_exports, {
      default: () => react_dom_default
    });
    var defaultImport29 = __toESM2(require_react_dom());
    __reExport(react_dom_exports, require_react_dom());
    var react_dom_default = "default" in defaultImport29 ? defaultImport29.default : defaultImport29;
    var ActionMenusContext = (0, react_exports.createContext)(null);
    var ActionMenusContextProvider = ActionMenusContext.Provider;
    var useActionMenus = () => {
      const ctx = (0, react_exports.useContext)(ActionMenusContext);
      if (ctx === null) {
        throw new Error(
          "useActionMenus can only be used in a component that is a child of a ActionMenusContextProvider"
        );
      }
      return ctx;
    };
    var ActionMenuWrapper = styled_components_default.div.attrs(
      ({ top }) => {
        return {
          "data-test": "action-menu-wrapper",
          style: __spreadValues({}, top ? { top: `${top - 1}px` } : { bottom: 0 })
        };
      }
    )`
    visibility: ${({ isSelected }) => isSelected ? "visible" : "hidden"};
    transition: visibility 0.2s ease-in 0;

    position: absolute;
    right: 0;
    width: fit-content;
    height: fit-content;
    pointer-events: ${({ isSelected }) => isSelected ? "all" : "none"};
    z-index: ${({ renderActionMenuInPortal }) => renderActionMenuInPortal ? "undefined" : "9999"};

    /* On hover of absolute-item (or menu portal) make the action menu visible */
    div[data-test='absolute-item']:hover
        + div[data-test='action-menu-portal']
        > &,
    & div[data-test='action-menus']:hover,
    ${dashboard_ui_exports.SelectableContainer}:hover & {
        transition: visibility 0.2s ease-in 0.3s;
        visibility: visible;
        pointer-events: all;
    }

    // The :hover pseudo selector cannot be mocked during visual testing, so also
    // support a data-test selector to trigger this state in storybook test cases
    // but DO NOT add a transition duration for visual tests (reduces flakiness)
    div[data-test='absolute-item'][data-test-hovered]
        + div[data-test='action-menu-portal']
        > &,
    & div[data-test='action-menus'][data-test-hovered],
    ${dashboard_ui_exports.SelectableContainer}[data-test-hovered] & {
        transition: visibility 0s;
        visibility: visible;
        pointer-events: all;
    }
`;
    var useActionMenusWithData = ({
      type,
      itemId,
      itemDefinition,
      dataSourceDefinitions
    }) => {
      const actionMenus = useActionMenus();
      return (0, react_exports.useMemo)(() => {
        return actionMenus.map(
          (item) => react_default.cloneElement(item, {
            type,
            itemId,
            itemDefinition,
            dataSources: dataSourceDefinitions
          })
        );
      }, [type, itemId, actionMenus, dataSourceDefinitions, itemDefinition]);
    };
    var ActionMenu = ({
      top,
      itemId,
      isSelected,
      dataSourceMeta,
      dataSourceDefinitions,
      type,
      itemDefinition,
      showLastUpdated,
      actionMenuPortal,
      renderActionMenuInPortal
    }) => {
      const useActionMenusWithDataProps = (0, react_exports.useMemo)(
        () => ({
          type,
          itemId,
          itemDefinition,
          dataSourceDefinitions
        }),
        [type, itemId, itemDefinition, dataSourceDefinitions]
      );
      const buttonsWithData = useActionMenusWithData(useActionMenusWithDataProps);
      const ActionMenuComponent = (0, react_exports.useMemo)(() => {
        return react_default.createElement(
          ActionMenuWrapper,
          {
            isSelected,
            top,
            renderActionMenuInPortal
          },
          react_default.createElement(
            dashboard_ui_exports.ActionMenuContainer,
            {
              actionButtons: buttonsWithData,
              lastUpdated: dataSourceMeta == null ? void 0 : dataSourceMeta.lastUpdated,
              status: dataSourceMeta == null ? void 0 : dataSourceMeta.status,
              isRealTimeSearch: dataSourceMeta == null ? void 0 : dataSourceMeta.isRealTimeSearch,
              showLastUpdated,
              itemId
            }
          )
        );
      }, [
        buttonsWithData,
        dataSourceMeta == null ? void 0 : dataSourceMeta.isRealTimeSearch,
        dataSourceMeta == null ? void 0 : dataSourceMeta.lastUpdated,
        dataSourceMeta == null ? void 0 : dataSourceMeta.status,
        itemId,
        isSelected,
        showLastUpdated,
        top,
        renderActionMenuInPortal
      ]);
      return (actionMenuPortal == null ? void 0 : actionMenuPortal.current) && renderActionMenuInPortal ? (0, react_dom_exports.createPortal)(ActionMenuComponent, actionMenuPortal.current) : ActionMenuComponent;
    };
    var minDistanceFromBottomCanvasForActionMenus = 40;
    var getActionMenuPosition = ({
      height,
      y,
      canvasHeight,
      shouldUsePortal
    }) => {
      if (typeof height !== "number") {
        return void 0;
      }
      const menuBottom = height + y;
      const canvasBottom = canvasHeight - minDistanceFromBottomCanvasForActionMenus;
      if (menuBottom <= canvasBottom) {
        return shouldUsePortal ? 1 : height + 1;
      }
      return void 0;
    };
    var useActionMenu = ({
      itemId,
      itemDefinition,
      layoutItemType,
      portalRef,
      shouldUsePortal,
      dataSourceMeta,
      dataSourceDefinitions,
      isSelected,
      menuPosition,
      mode = "view"
    }) => {
      const preset = (0, dashboard_context_exports.usePreset)();
      const { showLastUpdated: lastUpdatedFeatureFlag } = (0, dashboard_context_exports.useFeatureFlags)();
      const useLastUpdated = (0, react_exports.useMemo)(() => {
        const presetFlags = preset.shouldDisplaySiblingContent(
          itemDefinition.type,
          layoutItemType
        );
        return lastUpdatedFeatureFlag && (presetFlags == null ? void 0 : presetFlags.showLastUpdated) && itemDefinition.showLastUpdated;
      }, [
        preset,
        layoutItemType,
        itemDefinition.type,
        itemDefinition.showLastUpdated,
        lastUpdatedFeatureFlag
      ]);
      const shouldShowActionMenu = (0, react_exports.useMemo)(
        () => preset.shouldShowActionMenu({ mode, layoutItemType }),
        [preset, mode, layoutItemType]
      );
      return (0, react_exports.useMemo)(
        () => shouldShowActionMenu ? react_default.createElement(
          ActionMenu,
          {
            itemId,
            type: layoutItemType,
            top: menuPosition,
            isSelected,
            showLastUpdated: useLastUpdated,
            dataSourceMeta,
            dataSourceDefinitions,
            itemDefinition,
            actionMenuPortal: portalRef,
            renderActionMenuInPortal: shouldUsePortal
          }
        ) : null,
        [
          shouldShowActionMenu,
          portalRef,
          shouldUsePortal,
          dataSourceDefinitions,
          dataSourceMeta,
          itemId,
          layoutItemType,
          isSelected,
          useLastUpdated,
          itemDefinition,
          menuPosition
        ]
      );
    };
    var useCanItemBeHidden = ({
      itemDefinition
    }) => {
      var _a, _b, _c, _d;
      const { enableShowHide } = (0, dashboard_context_exports.useFeatureFlags)();
      const { conditions, hideConditions, showConditions, hideWhenNoData } = (_b = (_a = itemDefinition.containerOptions) == null ? void 0 : _a.visibility) != null ? _b : {};
      if (!enableShowHide) {
        return false;
      }
      if (((_c = itemDefinition.containerOptions) == null ? void 0 : _c.visibility) && "hideInViewMode" in itemDefinition.containerOptions.visibility && !!((_d = itemDefinition.containerOptions.visibility) == null ? void 0 : _d.hideInViewMode)) {
        return true;
      }
      return !!hideWhenNoData || !!itemDefinition.hideWhenNoData || !!(conditions == null ? void 0 : conditions.length) || !!(hideConditions == null ? void 0 : hideConditions.length) || !!(showConditions == null ? void 0 : showConditions.length);
    };
    var react_full_screen_exports = {};
    __export2(react_full_screen_exports, {
      default: () => react_full_screen_default
    });
    var defaultImport30 = __toESM2((init_index_modern(), __toCommonJS(index_modern_exports)));
    __reExport(react_full_screen_exports, (init_index_modern(), __toCommonJS(index_modern_exports)));
    var react_full_screen_default = "default" in defaultImport30 ? defaultImport30.default : defaultImport30;
    var dashboard_telemetry_exports = {};
    __export2(dashboard_telemetry_exports, {
      default: () => dashboard_telemetry_default
    });
    var defaultImport31 = __toESM2(require_dashboard_telemetry());
    __reExport(dashboard_telemetry_exports, require_dashboard_telemetry());
    var dashboard_telemetry_default = "default" in defaultImport31 ? defaultImport31.default : defaultImport31;
    var useVizTelemetry = ({
      width,
      height,
      id,
      type,
      loading
    }) => {
      const [timerCreated, setTimerCreated] = (0, react_exports.useState)(false);
      const telemetry = (0, dashboard_telemetry_exports.useTelemetryApi)();
      const dispatch = (0, dashboard_state_exports.useDispatch)();
      const isFirstRender = (0, dashboard_state_exports.useIsFirstRender)();
      if (isFirstRender) {
        dispatch((0, dashboard_state_exports.visualizationFirstRender)({ id, type }));
      }
      (0, react_exports.useLayoutEffect)(() => {
        if (width && height) {
          dispatch((0, dashboard_state_exports.blockItemResizing)({ vizType: type }));
        }
      }, [dispatch, height, type, width]);
      const timerId = `Visualization - ${type} - ${(0, dashboard_utils_exports.hashString)(
        id
      )} - Time to Interactive`;
      (0, react_exports.useEffect)(() => {
        const initialPayload = {
          pageAction: "performance.createTimer",
          metadata: {
            timerId,
            sourceElement: "TimeRangePicker",
            heroElement: timerId,
            currentTime: performance.now()
          }
        };
        if (!timerCreated) {
          telemetry.emit(initialPayload);
          setTimerCreated(true);
        }
      }, [telemetry, timerCreated, timerId]);
      (0, react_exports.useEffect)(() => {
        const actionPayload = {
          pageAction: "performance.mark",
          metadata: {
            timerId,
            markInformation: timerId,
            currentTime: performance.now()
          }
        };
        const initialPayload = {
          pageAction: "performance.createTimer",
          metadata: {
            timerId,
            sourceElement: "TimeRangePicker",
            heroElement: timerId,
            currentTime: performance.now()
          }
        };
        if (!loading && timerCreated) {
          telemetry.emit(actionPayload);
          telemetry.emit(initialPayload);
        }
      }, [telemetry, loading, timerCreated, timerId]);
    };
    var datasource_utils_exports = {};
    __export2(datasource_utils_exports, {
      default: () => datasource_utils_default
    });
    var defaultImport32 = __toESM2(require_datasource_utils());
    __reExport(datasource_utils_exports, require_datasource_utils());
    var datasource_utils_default = "default" in defaultImport32 ? defaultImport32.default : defaultImport32;
    var useStatusMessage = ({
      dataSource
    }) => {
      var _a, _b, _c, _d, _e, _f, _g, _h;
      const errorMessage = (_a = dataSource == null ? void 0 : dataSource.error) == null ? void 0 : _a.message;
      const warningMessage = (_d = (_c = (_b = dataSource == null ? void 0 : dataSource.meta) == null ? void 0 : _b.serverLog) == null ? void 0 : _c[0]) == null ? void 0 : _d.message;
      let message = errorMessage || warningMessage || "";
      const status = (_f = (_e = dataSource == null ? void 0 : dataSource.meta) == null ? void 0 : _e.status) != null ? _f : "";
      const noData = ((_h = (_g = dataSource == null ? void 0 : dataSource.data) == null ? void 0 : _g.columns) == null ? void 0 : _h.length) === 0;
      const noSearchResults = status === datasource_utils_exports.DS_STATUS.DONE && noData;
      if (noSearchResults) {
        message = dashboard_state_exports.NO_RESULTS_MSG;
      }
      const showWaitingForInputPlaceholder = !!(noSearchResults || errorMessage || noData && warningMessage);
      return (0, react_exports.useMemo)(
        () => ({ message, showWaitingForInputPlaceholder }),
        [message, showWaitingForInputPlaceholder]
      );
    };
    var StyledFullScreen = styled_components_default(react_full_screen_exports.FullScreen)`
    height: ${(props) => (0, dashboard_utils_exports.toPx)(props.height)};
    width: ${(props) => (0, dashboard_utils_exports.toPx)(props.width)};
`;
    var empty = {};
    var VisualizationContainer = ({
      id,
      mode,
      itemDefinition,
      height,
      width,
      loading,
      refresh,
      control,
      dataSources,
      updateRequestParams,
      onSelected,
      isFullscreen
    }) => {
      const dispatch = (0, dashboard_state_exports.useDispatch)();
      const onExitFullscreen = (0, react_exports.useCallback)(
        () => dispatch((0, dashboard_state_exports.setFullscreenItem)(null)),
        [dispatch]
      );
      const eventRegistry = (0, dashboard_context_exports.useEventRegistry)();
      const onEventTrigger = (0, react_exports.useCallback)(
        ({
          type: eventType,
          originalEvent,
          payload
        }) => {
          const eventId = eventRegistry.registerEvent(originalEvent);
          dispatch((0, dashboard_state_exports.triggerEvent)(id, eventType, payload, eventId));
        },
        [dispatch, eventRegistry, id]
      );
      const onOptionsChange = (0, react_exports.useCallback)(
        (newOptions) => dispatch((0, dashboard_state_exports.updateVizOptions)(id, newOptions)),
        [dispatch, id]
      );
      const apiRegistry = (0, dashboard_context_exports.useApiRegistry)();
      const fullscreenHandle = (0, react_full_screen_exports.useFullScreenHandle)();
      const { enter: enterFullscreen, node: vizRef } = fullscreenHandle;
      const vizApi = (0, react_exports.useMemo)(
        () => ({
          getDomElement: () => vizRef.current
        }),
        [vizRef]
      );
      (0, react_exports.useEffect)(() => {
        if (!apiRegistry.getVisualizationApi(id)) {
          apiRegistry.registerVisualizationApi(id, vizApi);
        }
        return () => {
          apiRegistry.removeVisualizationApi(id);
        };
      }, [apiRegistry, id, vizApi]);
      (0, react_exports.useEffect)(() => {
        apiRegistry.registerVisualizationActionsApi(id, { refresh, control });
        return () => {
          apiRegistry.removeVisualizationActionsApi(id);
        };
      }, [apiRegistry, id, refresh, control]);
      const registerApi = (0, react_exports.useCallback)(
        (ref) => {
          apiRegistry.registerVisualizationApi(id, __spreadValues(__spreadValues({}, ref), vizApi));
        },
        [apiRegistry, id, vizApi]
      );
      const handleToggleFullscreen = (0, react_exports.useCallback)(
        (isFull) => {
          if (isFullscreen && !isFull) {
            onExitFullscreen();
          }
        },
        [isFullscreen, onExitFullscreen]
      );
      (0, react_exports.useEffect)(() => {
        if (isFullscreen) {
          enterFullscreen();
        }
      }, []);
      const preset = (0, dashboard_context_exports.usePreset)();
      const { message, showWaitingForInputPlaceholder } = useStatusMessage({
        dataSource: dataSources == null ? void 0 : dataSources.primary
      });
      const { showProgressBar: progressFeatureFlag } = (0, dashboard_context_exports.useFeatureFlags)();
      const visualizationDefinition = (0, react_exports.useMemo)(() => {
        const presetFlags = preset == null ? void 0 : preset.shouldDisplayVisualizationSiblingContent(
          itemDefinition.type
        );
        return __spreadProps(__spreadValues({}, itemDefinition), {
          showProgressBar: !!itemDefinition.showProgressBar && progressFeatureFlag && (presetFlags == null ? void 0 : presetFlags.showProgressBar) && !showWaitingForInputPlaceholder,
          title: presetFlags.showTitleAndDescription ? itemDefinition.title : void 0,
          description: presetFlags.showTitleAndDescription ? itemDefinition.description : void 0
        });
      }, [
        itemDefinition,
        preset,
        progressFeatureFlag,
        showWaitingForInputPlaceholder
      ]);
      const { waitingForInput: WaitingForInput = dashboard_ui_exports.VisualizationWaitingForInput } = (0, dashboard_context_exports.useCoreOverrides)();
      useVizTelemetry({ width, height, id, loading, type: itemDefinition.type });
      (0, dashboard_ui_exports.useRiskySearchToast)({ dataSource: dataSources == null ? void 0 : dataSources.primary });
      const [computedProps, setComputedProps] = (0, react_exports.useState)({});
      (0, react_exports.useEffect)(() => {
        setComputedProps({});
      }, [visualizationDefinition.type]);
      const GraphicalChart = (0, react_exports.useMemo)(() => {
        const { eventHandlers } = visualizationDefinition;
        const props = __spreadProps(__spreadValues({}, visualizationDefinition), {
          // height and width props will be set by VisualizationContent
          width: "inherit",
          hasEventHandlers: eventHandlers && eventHandlers.length > 0,
          dataSources,
          loading,
          onRequestParamsChange: updateRequestParams,
          onComputedProps: setComputedProps,
          id,
          mode,
          onEventTrigger,
          vizActionHandlerRef: registerApi,
          visualizationApiRef: registerApi,
          onOptionsChange,
          // need to convert the array of string to an array of objects.
          onSelected: (e, visualizationIds) => onSelected(
            e,
            visualizationIds.map((vizId) => ({
              id: vizId,
              type: "block"
            }))
          ),
          isFullscreen
        });
        return preset.createVisualization(visualizationDefinition.type, props);
      }, [
        visualizationDefinition,
        dataSources,
        loading,
        updateRequestParams,
        id,
        mode,
        onEventTrigger,
        registerApi,
        onOptionsChange,
        isFullscreen,
        preset,
        onSelected
      ]);
      const Placeholder = (0, react_exports.useMemo)(() => {
        const { type, options = empty } = visualizationDefinition;
        const { backgroundColor } = options;
        let bgColor = computedProps.backgroundColor || backgroundColor || null;
        if (bgColor) {
          bgColor = (0, dashboard_ui_exports.sanitizeColor)(bgColor);
        }
        const PlaceholderIcon = preset.getPlaceholderIcon(type);
        return react_default.createElement(
          WaitingForInput,
          {
            width: "initial",
            dataSource: dataSources.primary,
            message,
            backgroundColor: bgColor,
            PlaceholderIcon
          }
        );
      }, [
        visualizationDefinition,
        computedProps.backgroundColor,
        preset,
        WaitingForInput,
        dataSources.primary,
        message
      ]);
      return react_default.createElement(
        StyledFullScreen,
        {
          handle: fullscreenHandle,
          onChange: handleToggleFullscreen,
          width,
          height,
          className: "styled-fullscreen"
        },
        react_default.createElement(
          dashboard_ui_exports.VisualizationContent,
          {
            id,
            visualizationDefinition,
            height,
            width,
            isFullscreen,
            dataSources,
            computedProps
          },
          showWaitingForInputPlaceholder ? Placeholder : GraphicalChart
        )
      );
    };
    var VisualizationContainer_default = VisualizationContainer;
    var AlignmentToJustifyMap = {
      top: "start",
      center: "center",
      bottom: "end"
    };
    var OnCanvasWrapper = styled_components_default.div.attrs(() => ({
      "data-test": "input-canvas-wrapper"
    }))`
    height: 100%;
    display: flex;
    flex-direction: column;
    overflow: hidden;
    justify-content: ${(props) => AlignmentToJustifyMap[props.alignment]};
    background-color: ${(props) => props.backgroundColor};
`;
    var empty2 = {};
    var getErrorDisabledStates = ({
      dataSources
    }) => {
      var _a, _b, _c, _d, _e;
      const errorLevel = (_b = (_a = dataSources == null ? void 0 : dataSources.primary) == null ? void 0 : _a.error) == null ? void 0 : _b.level;
      const message = (_e = (_d = (_c = dataSources == null ? void 0 : dataSources.primary) == null ? void 0 : _c.error) == null ? void 0 : _d.message) != null ? _e : "";
      if (errorLevel === dashboard_state_exports.ERROR_LEVEL_INFO) {
        return {
          isDisabled: true,
          disabledMessage: message || dashboard_state_exports.WAITING_FOR_INPUT_MSG
        };
      }
      if (errorLevel === dashboard_state_exports.ERROR_LEVEL_ERROR) {
        return { isError: true, errorMessage: message };
      }
      return {};
    };
    var InputContent_default = ({
      itemDefinition,
      loading = false,
      dataSources = {},
      id,
      isSelected,
      refresh,
      control,
      mode,
      onRemove,
      width,
      height,
      attributes,
      listeners,
      isOnCanvas = false
    }) => {
      var _a, _b;
      const apiRegistry = (0, dashboard_context_exports.useApiRegistry)();
      const preset = (0, dashboard_context_exports.usePreset)();
      const eventRegistry = (0, dashboard_context_exports.useEventRegistry)();
      const dispatch = (0, dashboard_state_exports.useDispatch)();
      const {
        type,
        title,
        options = empty2,
        encoding = empty2,
        context = empty2,
        containerOptions = empty2
      } = itemDefinition;
      const input = preset.findInput(type);
      const inputStaticDef = (0, react_exports.useMemo)(
        () => ({
          options,
          context
        }),
        [context, options]
      );
      const handleValueChange = (0, react_exports.useCallback)(
        (e, newValue) => {
          const eventId = eventRegistry.registerEvent(e);
          dispatch((0, dashboard_state_exports.inputValueChanged)({ id, newValue, eventId, isOnCanvas }));
        },
        [dispatch, eventRegistry, id, isOnCanvas]
      );
      const registerApi = (0, react_exports.useCallback)(
        (ref) => {
          apiRegistry.registerInputApi(id, ref);
        },
        [apiRegistry, id]
      );
      (0, react_exports.useEffect)(() => {
        return () => {
          apiRegistry.removeInputApi(id);
        };
      }, [apiRegistry, id]);
      (0, react_exports.useEffect)(() => {
        if (refresh && control) {
          apiRegistry.registerInputActionsApi(id, { refresh, control });
        }
        return () => {
          apiRegistry.removeInputActionsApi(id);
        };
      }, [apiRegistry, id, refresh, control]);
      const {
        isError: dsError = false,
        errorMessage: dsErrorMessage = "",
        isDisabled = false,
        disabledMessage = ""
      } = (0, react_exports.useMemo)(
        () => getErrorDisabledStates({
          dataSources
        }),
        [dataSources]
      );
      const { errorMessages: inputErrorMessages } = (0, react_exports.useMemo)(() => {
        const validate = input == null ? void 0 : input.validate;
        return typeof validate === "function" ? validate(inputStaticDef) : { errorMessages: [] };
      }, [inputStaticDef, input]);
      const value = (0, dashboard_state_exports.useSelector)((state) => (0, dashboard_state_exports.selectInputValue)(state, id));
      const canBeHidden = useCanItemBeHidden({ itemDefinition });
      const props = (0, react_exports.useMemo)(
        () => ({
          id,
          key: id,
          loading,
          title,
          dataSources,
          encoding,
          context,
          options,
          isError: dsError || !(0, lodash_exports.isEmpty)(inputErrorMessages),
          // dataSource error take precedence over input options error
          errorMessage: dsErrorMessage || inputErrorMessages.join(" "),
          // TODO: refactor tooltip to display multiline errors
          isDisabled,
          disabledMessage,
          value,
          isSelected,
          inputApiRef: registerApi,
          onRemove,
          onValueChange: handleValueChange,
          mode,
          width,
          height,
          isOnCanvas,
          canBeHidden,
          attributes,
          listeners,
          containerOptions
        }),
        [
          attributes,
          listeners,
          id,
          loading,
          title,
          dataSources,
          encoding,
          context,
          options,
          dsError,
          inputErrorMessages,
          dsErrorMessage,
          isDisabled,
          disabledMessage,
          value,
          isSelected,
          registerApi,
          onRemove,
          handleValueChange,
          mode,
          width,
          height,
          isOnCanvas,
          canBeHidden,
          containerOptions
        ]
      );
      const Input = (0, react_exports.useMemo)(
        () => preset.createInput(type, props),
        [preset, type, props]
      );
      const alignment = (_a = itemDefinition == null ? void 0 : itemDefinition.canvasAlignment) != null ? _a : "top";
      const backgroundColor = ((_b = itemDefinition == null ? void 0 : itemDefinition.options) == null ? void 0 : _b.backgroundColor) ? (0, dashboard_ui_exports.sanitizeColor)(itemDefinition.options.backgroundColor) : null;
      const bgColor = backgroundColor || "transparent";
      return isOnCanvas ? react_default.createElement(OnCanvasWrapper, { alignment, backgroundColor: bgColor }, Input) : Input;
    };
    var CornerRadiusContainer = styled_components_default.div`
    height: 100%;
    width: 100%;
    // If border radius is unset, then visualizations can render content outside of the container.
    // If border radius is set, overflow:hidden allows for rounded corners
    overflow: ${({ cornerRadius }) => cornerRadius === void 0 ? null : "hidden"};
    border-radius: ${({ cornerRadius }) => cornerRadius === void 0 ? null : `${(0, dashboard_utils_exports.toPx)(cornerRadius[0])}
              ${(0, dashboard_utils_exports.toPx)(cornerRadius[1])}
              ${(0, dashboard_utils_exports.toPx)(cornerRadius[2])}
              ${(0, dashboard_utils_exports.toPx)(cornerRadius[3])}`};
`;
    var CornerRadiusContainer_default = CornerRadiusContainer;
    var useChangeAnnouncer = ({
      id,
      itemDefinition,
      dataSources
    }) => {
      const preset = (0, dashboard_context_exports.usePreset)();
      const { announceVisualizationChange } = (0, dashboard_context_exports.useLiveAnnouncement)();
      const isFirstRender = (0, dashboard_context_exports.useIsFirstRender)();
      const previousDefinition = (0, dashboard_context_exports.usePrevious)(itemDefinition);
      const previousDataSources = (0, dashboard_context_exports.usePrevious)(dataSources);
      const itemShouldAnnounceChange = (0, react_exports.useMemo)(
        () => preset.getItemShouldAnnounceChange(itemDefinition.type),
        [preset, itemDefinition.type]
      );
      (0, react_exports.useEffect)(() => {
        if (isFirstRender) {
          return;
        }
        if (itemShouldAnnounceChange({
          newDefinition: itemDefinition,
          previousDefinition,
          newDataSources: dataSources,
          previousDataSources
        })) {
          announceVisualizationChange(id, itemDefinition.title);
        }
      }, [
        isFirstRender,
        id,
        itemDefinition,
        previousDefinition,
        itemShouldAnnounceChange,
        announceVisualizationChange,
        dataSources,
        previousDataSources
      ]);
    };
    var StyledSkipButton = styled_components_default(Button_default)`
    position: absolute;
    margin: 8px;
    opacity: 0;
    pointer-events: none;

    &:focus {
        opacity: 1;
        pointer-events: auto;
    }
`;
    var empty3 = {};
    var toAttrs = ({
      itemId,
      $itemType,
      layoutItemType,
      width,
      height
    }) => {
      let base;
      if (layoutItemType === "input") {
        base = {
          "data-test": "input-item",
          "data-input-type": $itemType,
          "data-input-id": itemId
        };
      } else {
        base = {
          "data-test": "viz-item",
          "data-viz-type": $itemType,
          "data-id": itemId
        };
      }
      base.style = height ? { width, height } : { width };
      return base;
    };
    var Item = styled_components_default.div.attrs((props) => toAttrs(props))`
    position: relative;
    pointer-events: auto;
`;
    var FixSizeItem = styled_components_default.div.attrs(
      (props) => toAttrs(props)
    )`
    flex-direction: column;
    pointer-events: auto;
`;
    var ItemWrapper = react_default.memo(
      ({
        width,
        height,
        children,
        itemId,
        $itemType,
        layoutItemType
      }) => {
        if (!height) {
          return react_default.createElement(
            Item,
            {
              width,
              itemId,
              $itemType,
              layoutItemType
            },
            children
          );
        }
        return react_default.createElement(
          FixSizeItem,
          {
            width,
            height,
            itemId,
            $itemType,
            layoutItemType
          },
          children
        );
      }
    );
    var ItemLayer = styled_components_default.div.attrs(() => ({
      "data-test": "item-layer"
    }))`
    z-index: ${(props) => props.zIndex};
    height: 100%;
`;
    var BaseItemContainer = ({
      id,
      width,
      height,
      layoutItemType = "block",
      y,
      canvasHeight,
      renderActionMenuInPortal,
      actionMenuPortal,
      dragHandlePortal,
      onSelected
    }) => {
      var _a, _b;
      const preset = (0, dashboard_context_exports.usePreset)();
      const selectIsSelected = (0, react_exports.useMemo)(dashboard_state_exports.makeSelectIsSelected, []);
      const isSelected = (0, dashboard_state_exports.useSelector)((state) => selectIsSelected(state, id));
      const isMultiSelect = (0, dashboard_state_exports.useSelector)(dashboard_state_exports.selectAreMultipleVizSelected);
      const mode = (0, dashboard_state_exports.useSelector)(dashboard_state_exports.selectMode);
      const isFullscreen = (0, dashboard_state_exports.useSelector)(dashboard_state_exports.selectFullscreenElement) === id;
      const containerWidth = isFullscreen ? "100vw" : width;
      const containerHeight = isFullscreen ? "100vh" : height;
      const layerData = (0, dashboard_context_exports.useLayoutLayers)();
      const { layer: itemLayer, selection: selectionLayer } = (0, react_exports.useMemo)(() => {
        var _a2;
        return (_a2 = layerData == null ? void 0 : layerData[id]) != null ? _a2 : empty3;
      }, [layerData, id]);
      const selectItemDefinition = (0, react_exports.useMemo)(
        () => (0, dashboard_state_exports.selectItemDefinitionFactory)(layoutItemType)(),
        [layoutItemType]
      );
      const selectDSDef = (0, react_exports.useMemo)(
        () => (0, dashboard_state_exports.selectDataSourceDefinitionFactory)(layoutItemType)(),
        [layoutItemType]
      );
      const itemDefinition = (0, dashboard_state_exports.useSelector)(
        (state) => selectItemDefinition(state, id)
      );
      const dataSourceDefinitions = (0, dashboard_state_exports.useSelector)(
        (state) => selectDSDef(state, id)
      );
      const itemType = itemDefinition.type;
      const dataSourceBindings = (_a = itemDefinition.dataSources) != null ? _a : empty3;
      const canBeHidden = useCanItemBeHidden({ itemDefinition });
      const radius = isFullscreen ? void 0 : itemDefinition.cornerRadius;
      const hasDrilldown = getHasDrilldown(itemDefinition.eventHandlers);
      const outlineStyle = (0, dashboard_ui_exports.getBorderStyle)({
        isSelected,
        mode,
        hasDrilldown,
        canBeHidden,
        layoutItemType
      });
      const { loading, dataSources, refresh, control, updateRequestParams } = (0, dashboard_ui_exports.useSubscribeToSearches)({
        consumerId: id,
        bindings: dataSourceBindings
      });
      useChangeAnnouncer({
        id,
        itemDefinition,
        dataSources: loading ? null : dataSources
      });
      const actionMenuPosition = getActionMenuPosition({
        height,
        y,
        canvasHeight,
        shouldUsePortal: renderActionMenuInPortal
      });
      const actionMenu = useActionMenu({
        itemId: id,
        itemDefinition,
        layoutItemType,
        portalRef: actionMenuPortal,
        shouldUsePortal: renderActionMenuInPortal,
        dataSourceMeta: (_b = dataSources == null ? void 0 : dataSources.primary) == null ? void 0 : _b.meta,
        dataSourceDefinitions,
        isSelected,
        menuPosition: actionMenuPosition,
        mode
      });
      const handleError = (0, react_exports.useCallback)(
        (message) => react_default.createElement(dashboard_ui_exports.Message, { level: "error", message }),
        []
      );
      const shouldShowDragHandle = mode === "edit" && preset.shouldShowDragHandle(itemType);
      const DragHandle = (0, dashboard_ui_exports.useDragHandleComponent)({
        id,
        shouldShowDragHandle,
        type: layoutItemType,
        portalRef: dragHandlePortal
      });
      const { setIsMouseDownOnItemWithHandle } = (0, dashboard_context_exports.useMouseEventsContext)();
      const handleMouseDown = (0, react_exports.useCallback)(
        (event) => {
          if (shouldShowDragHandle) {
            setIsMouseDownOnItemWithHandle(true);
            const newEvent = new CustomEvent(
              dashboard_ui_exports.EVENT_MOUSE_DOWN_ON_VIZ_WITH_HANDLE,
              {
                detail: {
                  vizId: id,
                  initialEvent: event,
                  type: layoutItemType
                }
              }
            );
            document.dispatchEvent(newEvent);
          }
        },
        [
          shouldShowDragHandle,
          setIsMouseDownOnItemWithHandle,
          id,
          layoutItemType
        ]
      );
      const ItemContainer = (0, react_exports.useMemo)(() => {
        const commonProps = {
          id,
          width,
          height,
          mode,
          itemDefinition,
          loading,
          refresh,
          control,
          updateRequestParams,
          dataSources
        };
        if (layoutItemType === "block") {
          return react_default.createElement(
            VisualizationContainer_default,
            __spreadProps(__spreadValues({}, commonProps), {
              isFullscreen,
              onSelected
            })
          );
        }
        return react_default.createElement(
          InputContent_default,
          __spreadProps(__spreadValues({}, commonProps), {
            isSelected: isSelected && !isMultiSelect,
            isOnCanvas: true
          })
        );
      }, [
        dataSources,
        height,
        id,
        isFullscreen,
        isSelected,
        itemDefinition,
        layoutItemType,
        loading,
        mode,
        onSelected,
        refresh,
        control,
        updateRequestParams,
        width,
        isMultiSelect
      ]);
      const actionMenuRef = (0, dashboard_context_exports.useActionMenuRef)(id);
      const skipToActionMenu = (0, react_exports.useCallback)(() => {
        var _a2;
        const focusable = (_a2 = actionMenuRef == null ? void 0 : actionMenuRef.current) == null ? void 0 : _a2.querySelectorAll(
          `button:not([disabled])`
        );
        if (focusable && focusable.length > 0) {
          focusable[0].focus();
        }
      }, [actionMenuRef]);
      return react_default.createElement(dashboard_ui_exports.ErrorBoundary, { render: handleError }, react_default.createElement(
        ItemWrapper,
        {
          width,
          height,
          layoutItemType,
          $itemType: itemType,
          itemId: id
        },
        react_default.createElement(
          dashboard_ui_exports.SelectableContainer,
          {
            itemId: id,
            width: containerWidth,
            height: containerHeight,
            outlineStyle,
            onMouseDown: handleMouseDown,
            zIndex: selectionLayer,
            canBeHidden: mode === "edit" && canBeHidden,
            tabIndex: 0
          },
          preset.shouldShowSkipButton(itemType) && react_default.createElement(
            StyledSkipButton,
            {
              appearance: "primary",
              onClick: skipToActionMenu,
              "data-test": "skip-button"
            },
            (0, i18n_exports._)("Skip to action menu")
          ),
          react_default.createElement(ItemLayer, { zIndex: itemLayer }, DragHandle, react_default.createElement(
            CornerRadiusContainer_default,
            {
              cornerRadius: radius,
              "data-test": "corner-radius-container"
            },
            ItemContainer
          )),
          !isMultiSelect && actionMenu
        )
      ));
    };
    var LineContainerWithDataSource = (props) => {
      const _a = props, { dataSourceId, vizType } = _a, lineProps = __objRest(_a, ["dataSourceId", "vizType"]);
      const dataSourceBindings = (0, react_exports.useMemo)(
        () => ({ primary: dataSourceId }),
        [dataSourceId]
      );
      const preset = (0, dashboard_context_exports.usePreset)();
      const { loading, dataSources, updateRequestParams } = (0, dashboard_ui_exports.useSubscribeToSearches)({
        consumerId: lineProps.id,
        bindings: dataSourceBindings
      });
      return preset.createVisualization(vizType, __spreadProps(__spreadValues({}, lineProps), {
        loading,
        dataSources,
        onRequestParamsChange: updateRequestParams
      }));
    };
    var LineContainer = (props) => {
      const {
        id,
        mode,
        from,
        to,
        vizDef: {
          type,
          options = {},
          dataSources: dataSourceBindings = {},
          context
        } = {},
        onLineSelect,
        onOptionsChange,
        dataSourceDefs,
        handleEvent
      } = props;
      const preset = (0, dashboard_context_exports.usePreset)();
      const eventRegistry = (0, dashboard_context_exports.useEventRegistry)();
      const onEventTrigger = (0, react_exports.useCallback)(
        ({
          type: eventType,
          originalEvent,
          payload
        }) => {
          const eventId = eventRegistry.registerEvent(originalEvent);
          handleEvent == null ? void 0 : handleEvent(eventType, payload, eventId);
        },
        [handleEvent, eventRegistry]
      );
      if (!type) {
        return null;
      }
      const lineProps = {
        id,
        mode,
        from,
        to,
        options,
        context,
        onLineSelect,
        onOptionsChange,
        onEventTrigger
      };
      const primaryDataSourceId = dataSourceBindings.primary;
      if (primaryDataSourceId && (dataSourceDefs == null ? void 0 : dataSourceDefs[primaryDataSourceId])) {
        return react_default.createElement(
          LineContainerWithDataSource,
          __spreadProps(__spreadValues({}, lineProps), {
            vizType: type,
            dataSourceId: primaryDataSourceId
          })
        );
      }
      return preset.createVisualization(type, __spreadProps(__spreadValues({}, lineProps), {
        loading: false,
        dataSources: {},
        onRequestParamsChange: dashboard_utils_exports.noop
      }));
    };
    var LineContainer_default = react_default.memo(LineContainer);
    var ConnectedLineContainer = (props) => {
      const selectVizDef = (0, react_exports.useMemo)(dashboard_state_exports.selectVisualizationDefinitionFactory, []);
      const selectDSDef = (0, react_exports.useMemo)(dashboard_state_exports.selectDataSourceDefinitionForVizFactory, []);
      const dispatch = (0, dashboard_state_exports.useDispatch)();
      const handleEvent = (0, react_exports.useCallback)(
        (eventType, payload, eventId) => dispatch((0, dashboard_state_exports.triggerEvent)(props.id, eventType, payload, eventId)),
        [dispatch, props.id]
      );
      const onOptionsChange = (0, react_exports.useCallback)(
        (newOptions) => dispatch((0, dashboard_state_exports.updateVizOptions)(props.id, newOptions)),
        [dispatch, props.id]
      );
      const mode = (0, dashboard_state_exports.useSelector)(dashboard_state_exports.selectMode);
      const vizDef = (0, dashboard_state_exports.useSelector)((state) => selectVizDef(state, props.id));
      const dataSourceDefs = (0, dashboard_state_exports.useSelector)((state) => selectDSDef(state, props.id));
      return react_default.createElement(
        LineContainer_default,
        __spreadProps(__spreadValues({}, props), {
          handleEvent,
          onOptionsChange,
          mode,
          vizDef,
          dataSourceDefs
        })
      );
    };
    var ConnectedLineContainer_default = ConnectedLineContainer;
    var renderLayoutItem = (id, props, layoutItemType, onSelected) => {
      if (layoutItemType === "line") {
        return react_default.createElement(
          ConnectedLineContainer_default,
          __spreadValues({
            key: id,
            id
          }, props)
        );
      }
      return react_default.createElement(
        BaseItemContainer,
        __spreadProps(__spreadValues({
          key: id,
          id
        }, props), {
          layoutItemType,
          onSelected
        })
      );
    };
    var LayoutContainer = ({
      handleEvent,
      height,
      // container height in pixel
      layout,
      mode,
      onLayoutItemsSelect,
      onLayoutStructureChange,
      selectedItems,
      showGrid,
      width,
      // container width in pixel
      isDashboardFullscreen,
      layoutId
    }) => {
      const eventRegistry = (0, dashboard_context_exports.useEventRegistry)();
      const preset = (0, dashboard_context_exports.usePreset)();
      const onEventTrigger = (0, react_exports.useCallback)(
        ({
          type: eventType,
          originalEvent,
          payload
        }) => {
          const eventId = eventRegistry.registerEvent(originalEvent);
          handleEvent == null ? void 0 : handleEvent(eventType, payload, eventId);
        },
        [handleEvent, eventRegistry]
      );
      return (0, react_exports.useMemo)(() => {
        const { type, options, structure: layoutStructure } = layout;
        if (!preset.findLayout(type)) {
          return react_default.createElement(
            dashboard_ui_exports.Message,
            {
              level: "error",
              message: (0, i18n_exports._)(`Layout ${type} is not defined`)
            }
          );
        }
        const layoutProps = {
          key: layoutId,
          layoutId,
          // we send down the actual width/height of dashboard-core container
          containerHeight: height,
          containerWidth: width,
          layoutStructure,
          mode,
          onEventTrigger,
          onLayoutItemsSelect,
          onLayoutStructureChange,
          options: isDashboardFullscreen && type === "absolute" && (options == null ? void 0 : options.display) !== "fit-to-width" ? __spreadProps(__spreadValues({}, options), { display: "fit-to-width" }) : options,
          renderLayoutItem,
          selectedItems,
          showGrid
        };
        return preset.createLayout(type, layoutProps);
      }, [
        layout,
        preset,
        layoutId,
        height,
        width,
        mode,
        onEventTrigger,
        onLayoutItemsSelect,
        onLayoutStructureChange,
        isDashboardFullscreen,
        selectedItems,
        showGrid
      ]);
    };
    var LayoutContainer_default = LayoutContainer;
    var ConnectedLayoutContainer_default = (_a) => {
      var _b = _a, { layoutId } = _b, rest = __objRest(_b, ["layoutId"]);
      const dispatch = (0, dashboard_state_exports.useDispatch)();
      const { enableTokensInBackgroundImage } = (0, dashboard_context_exports.useFeatureFlags)();
      const handleEvent = (0, react_exports.useCallback)(
        (eventType, payload, eventId) => dispatch((0, dashboard_state_exports.triggerEvent)(null, eventType, payload, eventId)),
        [dispatch]
      );
      const onLayoutItemsSelect = (0, react_exports.useCallback)(
        (newSelectedItems) => {
          (0, dashboard_state_exports.batch)(() => {
            dispatch((0, dashboard_state_exports.updateSelectedGlobalItems)([]));
            dispatch((0, dashboard_state_exports.updateSelectedItems)(newSelectedItems));
          });
        },
        [dispatch]
      );
      const onLayoutStructureChange = (0, react_exports.useCallback)(
        (layoutStructure) => dispatch((0, dashboard_state_exports.updateLayoutStructure)(layoutStructure, layoutId)),
        [dispatch, layoutId]
      );
      const layout = (0, dashboard_state_exports.useSelector)(
        enableTokensInBackgroundImage ? dashboard_state_exports.selectResolvedLayoutIncludingBackgroundImage : dashboard_state_exports.selectResolvedLayout
      );
      const mode = (0, dashboard_state_exports.useSelector)(dashboard_state_exports.selectMode);
      const selectedItems = (0, dashboard_state_exports.useSelector)(dashboard_state_exports.selectSelectedItems);
      const isDashboardFullscreen = (0, dashboard_state_exports.useSelector)(dashboard_state_exports.selectIsDashboardFullscreen);
      return react_default.createElement(dashboard_context_exports.MouseEventsContextProvider, null, react_default.createElement(
        LayoutContainer_default,
        __spreadProps(__spreadValues({}, rest), {
          layoutId,
          handleEvent,
          onLayoutItemsSelect,
          onLayoutStructureChange,
          layout,
          mode,
          selectedItems,
          isDashboardFullscreen
        })
      ));
    };
    var dashboard_layouts_exports = {};
    __export2(dashboard_layouts_exports, {
      default: () => dashboard_layouts_default
    });
    var defaultImport33 = __toESM2(require_dashboard_layouts());
    __reExport(dashboard_layouts_exports, require_dashboard_layouts());
    var dashboard_layouts_default = "default" in defaultImport33 ? defaultImport33.default : defaultImport33;
    var emptyConditions = [];
    var hideInViewMode = ({ inputDef }) => {
      var _a, _b;
      return ((_a = inputDef.containerOptions) == null ? void 0 : _a.visibility) && "hideInViewMode" in inputDef.containerOptions.visibility && !!((_b = inputDef.containerOptions.visibility) == null ? void 0 : _b.hideInViewMode);
    };
    var wrapperAttributes = ({
      $transform,
      $transition,
      isDragging,
      mode
    } = {}) => ({
      "data-test": "input-item",
      tabIndex: mode === "edit" ? 0 : -1,
      style: {
        transform: utilities_exports.CSS.Translate.toString($transform != null ? $transform : null),
        transition: isDragging ? $transition : void 0
      }
    });
    var Wrapper = styled_components_default.div.attrs(wrapperAttributes)`
    display: inline-block;
    z-index: ${({ isDragging }) => isDragging ? 1 : void 0};
    opacity: ${({ isDragging }) => isDragging ? 0.4 : 1};
`;
    var ConnectedInputContainer = (_a) => {
      var _b = _a, {
        setNodeRef,
        transform,
        transition,
        isDragging,
        attributes,
        listeners,
        mode,
        isSelected
      } = _b, props = __objRest(_b, [
        "setNodeRef",
        "transform",
        "transition",
        "isDragging",
        "attributes",
        "listeners",
        "mode",
        "isSelected"
      ]);
      var _a2, _b2;
      const selectInputDef = (0, react_exports.useMemo)(dashboard_state_exports.selectInputDefinitionFactory, []);
      const dispatch = (0, dashboard_state_exports.useDispatch)();
      const onRemove = (0, react_exports.useCallback)(
        (inputId) => dispatch(
          (0, dashboard_state_exports.removeDashboardItems)(
            { itemIds: [inputId] },
            { confirmDeletion: true }
          )
        ),
        [dispatch]
      );
      const onSelect = (0, react_exports.useCallback)(
        () => dispatch(
          (0, dashboard_state_exports.updateSelectedGlobalItems)([{ id: props.id, type: "input" }])
        ),
        [dispatch, props.id]
      );
      const inputDef = (0, dashboard_state_exports.useSelector)((state) => selectInputDef(state, props.id));
      const { type, dataSources: dataSourceBindings = {} } = inputDef;
      const primaryDataSourceId = dataSourceBindings.primary;
      const commonProps = {
        onRemove,
        itemDefinition: inputDef,
        mode,
        isSelected: isSelected && !isDragging,
        attributes,
        listeners
      };
      const { loading, dataSources, refresh, updateRequestParams, control } = (0, dashboard_ui_exports.useSubscribeToSearches)({
        consumerId: props.id,
        bindings: dataSourceBindings
      });
      const canBeHidden = useCanItemBeHidden({
        itemDefinition: inputDef
      });
      const {
        conditions = emptyConditions,
        hideConditions = emptyConditions,
        showConditions = emptyConditions
      } = (_b2 = (_a2 = inputDef.containerOptions) == null ? void 0 : _a2.visibility) != null ? _b2 : {};
      const selector = (0, react_exports.useCallback)(
        (state) => (0, dashboard_state_exports.selectConditionResults)(state, [
          ...conditions,
          ...hideConditions,
          ...showConditions
        ]),
        [conditions, hideConditions, showConditions]
      );
      const conditionResults = (0, dashboard_state_exports.useSelector)(selector);
      if (mode === "view" && canBeHidden) {
        if (hideInViewMode({ inputDef })) {
          return null;
        }
        if ((0, dashboard_utils_exports.shouldHideItem)({
          itemType: "input",
          definition: inputDef,
          searchData: dataSources == null ? void 0 : dataSources.primary,
          conditionResults
        })) {
          return null;
        }
      }
      return react_default.createElement(
        Wrapper,
        {
          mode,
          ref: setNodeRef,
          "data-input-id": props.id,
          "data-input-type": type,
          "data-test-selected": isSelected,
          onClick: onSelect,
          onFocus: mode === "edit" ? onSelect : void 0,
          $transform: transform,
          $transition: transition,
          isDragging
        },
        primaryDataSourceId ? react_default.createElement(
          InputContent_default,
          __spreadProps(__spreadValues(__spreadValues({}, props), commonProps), {
            loading,
            dataSources,
            refresh,
            updateRequestParams,
            control
          })
        ) : react_default.createElement(InputContent_default, __spreadValues(__spreadValues({}, props), commonProps))
      );
    };
    var MemoizedConnectedInputContainer = react_default.memo(
      ConnectedInputContainer,
      lodash_exports.isEqual
    );
    var withSortable = (Component) => (props) => {
      var _a;
      const { enableDragDropInputs } = (0, dashboard_context_exports.useFeatureFlags)();
      const mode = (0, dashboard_state_exports.useSelector)(dashboard_state_exports.selectMode);
      const selectIsInputSelected = (0, react_exports.useMemo)(dashboard_state_exports.makeSelectIsSelected, []);
      const isSelected = (0, dashboard_state_exports.useSelector)(
        (state) => selectIsInputSelected(state, props.id)
      );
      const globalInputs = (0, dashboard_state_exports.useSelector)(dashboard_state_exports.selectGlobalInputs);
      const isGlobalInput = (_a = globalInputs == null ? void 0 : globalInputs.includes(props.id)) != null ? _a : false;
      const isDraggable = (0, react_exports.useMemo)(
        () => enableDragDropInputs && mode === "edit" && isSelected && isGlobalInput,
        [enableDragDropInputs, mode, isSelected, isGlobalInput]
      );
      const {
        setNodeRef,
        transform,
        transition,
        isDragging,
        attributes,
        listeners
      } = (0, sortable_exports.useSortable)({
        id: props.id,
        disabled: !isDraggable,
        data: { snapCenterToCursor: true }
      });
      const sortableProps = {
        setNodeRef,
        transform,
        transition,
        isDragging,
        attributes: (0, lodash_exports.omit)(attributes, ["role", "tabIndex"]),
        listeners,
        mode,
        isSelected
      };
      return react_default.createElement(Component, __spreadValues(__spreadValues({}, props), sortableProps));
    };
    var ConnectedInputContainer_default = withSortable(MemoizedConnectedInputContainer);
    var renderInput = ({ inputId }) => react_default.createElement(ConnectedInputContainer_default, { key: inputId, id: inputId });
    var emptyGlobalInputs = [];
    var GlobalInputContainer_default = () => {
      var _a, _b;
      const apiRegistry = (0, dashboard_context_exports.useApiRegistry)();
      const dispatch = (0, dashboard_state_exports.useDispatch)();
      const inputsRef = (0, react_exports.useRef)(null);
      const globalInputsApi = (0, react_exports.useMemo)(() => {
        return {
          getInputsDomElement: () => {
            return inputsRef.current;
          }
        };
      }, [inputsRef]);
      const onSubmitButtonClick = (0, react_exports.useCallback)(
        () => dispatch((0, dashboard_state_exports.submitTokens)(dashboard_utils_exports.DEFAULT_TOKEN_NAMESPACE)),
        [dispatch]
      );
      const submitButtonDisabled = !(0, dashboard_state_exports.useSelector)(dashboard_state_exports.selectAreTokensReadyToSubmit);
      (0, react_exports.useEffect)(() => {
        apiRegistry.registerGlobalInputsApi(globalInputsApi);
        return () => {
          apiRegistry.removeGlobalInputsApi();
        };
      }, [apiRegistry, globalInputsApi]);
      const submitButton = !!((_a = (0, dashboard_state_exports.useSelector)(dashboard_state_exports.selectLayoutGlobalOptions)) == null ? void 0 : _a.submitButton);
      const globalInputs = (_b = (0, dashboard_state_exports.useSelector)(dashboard_state_exports.selectGlobalInputs)) != null ? _b : emptyGlobalInputs;
      return react_default.createElement(
        dashboard_layouts_exports.InputLayout,
        {
          submitButtonDisabled,
          onSubmitButtonClick,
          submitButton,
          inputStructure: globalInputs,
          renderInput,
          ref: inputsRef
        }
      );
    };
    var DashboardLayoutContainer = styled_components_default.div.attrs({
      "data-test": "DashboardLayoutContainer"
    })`
    ${(0, mixins_exports.reset)("flex")};
    position: relative;
    overflow: hidden;
    flex-direction: column;
    padding-bottom: 8px;
    max-height: 100%;
    ${(props) => (0, dashboard_utils_exports.toDimension)((0, lodash_exports.pick)(props, ["width", "height"]))};
`;
    var GlobalInputsContainer = styled_components_default.div.attrs({
      "data-test": "GlobalInputsContainer"
    })`
    flex-basis: auto;
`;
    var LayoutContainer2 = styled_components_default.div.attrs({
      "data-test": "LayoutContainer"
    })`
    flex-grow: 1;
    min-height: 0px;
    overflow: auto;
    position: relative;
`;
    var DashboardLayout = ({
      height,
      width,
      showGlobalInputs
    }) => {
      const tabs = (0, dashboard_state_exports.useSelector)(dashboard_state_exports.selectTabs);
      const showGrid = (0, dashboard_state_exports.useSelector)(dashboard_state_exports.selectAreGridLinesEnabled);
      const layoutId = (0, dashboard_state_exports.useSelector)(dashboard_state_exports.selectActiveTab);
      const globalInputsContainerRef = (0, react_exports.useRef)(null);
      const {
        width: containerWidth,
        height: containerHeight,
        ref
      } = (0, react_resize_detector_exports.useResizeDetector)();
      const globalInputsOrder = useDashboardDragMonitor();
      const renderGlobalInputsContainer = (0, react_exports.useMemo)(() => {
        if (!showGlobalInputs) {
          return null;
        }
        return react_default.createElement(GlobalInputsContainer, { ref: globalInputsContainerRef }, react_default.createElement(GlobalInputContainer_default, null));
      }, [showGlobalInputs]);
      const inputSortingStrategy = (0, react_exports.useMemo)(
        () => (0, dashboard_context_exports.horizontalMasonryStrategy)(globalInputsContainerRef),
        []
      );
      return react_default.createElement(
        DashboardLayoutContainer,
        {
          height,
          width,
          "data-udf-core-version": "29.0.0",
          ref
        },
        react_default.createElement(
          sortable_exports.SortableContext,
          {
            id: "sortable-global-inputs",
            items: globalInputsOrder,
            strategy: inputSortingStrategy
          },
          renderGlobalInputsContainer
        ),
        react_default.createElement(TabContainer, null),
        react_default.createElement(LayoutContainer2, { role: tabs.length > 1 ? "tabpanel" : void 0 }, react_default.createElement(
          ConnectedLayoutContainer_default,
          {
            width: containerWidth,
            height: containerHeight,
            showGrid,
            layoutId
          }
        )),
        react_default.createElement(ConfirmationModal, null)
      );
    };
    var DashboardLayout_default = DashboardLayout;
    var GlobalErrorMessage = ({ message }) => react_default.createElement(dashboard_ui_exports.Message, { level: "error", message });
    var renderErrorMessage = (errorMessage) => react_default.createElement(GlobalErrorMessage, { message: errorMessage });
    var defaultGlobalInputs = [];
    var DashboardContainer = ({
      message = null,
      height,
      width,
      globalInputs = defaultGlobalInputs
    }) => {
      if (message) {
        return react_default.createElement(GlobalErrorMessage, { message });
      }
      return react_default.createElement(dashboard_ui_exports.ErrorBoundary, { render: renderErrorMessage }, react_default.createElement(
        DashboardLayout_default,
        {
          width: width != null ? width : 0,
          height: height != null ? height : 0,
          showGlobalInputs: !!(Array.isArray(globalInputs) && globalInputs.length)
        }
      ));
    };
    var DashboardContainer_default = DashboardContainer;
    var ConnectedDashboardContainer_default = (props) => {
      const message = (0, dashboard_state_exports.useSelector)(dashboard_state_exports.selectGlobalMessage);
      const globalInputs = (0, dashboard_state_exports.useSelector)(dashboard_state_exports.selectGlobalInputs);
      return react_default.createElement(
        DashboardContainer_default,
        __spreadProps(__spreadValues({}, props), {
          message,
          globalInputs
        })
      );
    };
    var withDefinition = (WrappedComponent) => (props) => {
      const definition = (0, dashboard_state_exports.useSelector)(dashboard_state_exports.selectDefinition);
      return react_default.createElement(WrappedComponent, __spreadProps(__spreadValues({}, props), { definition }));
    };
    var withReadOnlyTokenNamespaces = (WrappedComponent) => (props) => {
      const namespaces = (0, dashboard_state_exports.useSelector)(dashboard_state_exports.selectReadOnlyTokenNamespaces);
      return react_default.createElement(
        WrappedComponent,
        __spreadProps(__spreadValues({}, props), {
          readOnlyTokenNamespaces: namespaces
        })
      );
    };
    var dashboard_definition_exports = {};
    __export2(dashboard_definition_exports, {
      default: () => dashboard_definition_default
    });
    var defaultImport34 = __toESM2(require_dashboard_definition());
    __reExport(dashboard_definition_exports, require_dashboard_definition());
    var dashboard_definition_default = "default" in defaultImport34 ? defaultImport34.default : defaultImport34;
    var createSchema = (preset) => {
      try {
        return (0, dashboard_definition_exports.createSchemaBasedOnPresets)(preset);
      } catch (e) {
        dashboard_utils_exports.console.error("Schema Error:", e);
        return dashboard_definition_exports.defaultSchema;
      }
    };
    var withValidationSchema = (WrappedComponent) => (props) => {
      const preset = (0, dashboard_context_exports.usePreset)();
      const schema = (0, react_exports.useMemo)(
        () => createSchema(preset.getPresetDefinition()),
        [preset]
      );
      return react_default.createElement(WrappedComponent, __spreadProps(__spreadValues({}, props), { schema }));
    };
    var useActiveTabWithUrl = () => {
      const dispatch = (0, dashboard_state_exports.useDispatch)();
      const activeTab = (0, dashboard_state_exports.useSelector)(dashboard_state_exports.selectActiveTab);
      const allTabs = (0, dashboard_state_exports.useSelector)(dashboard_state_exports.selectTabs);
      const tabIds = (0, react_exports.useMemo)(() => allTabs.map((tab) => tab.layoutId), [allTabs]);
      const handlePopState = (0, dashboard_ui_exports.useEventCallback)(() => {
        const newActiveTab = (0, dashboard_utils_exports.mapURLToActiveTab)({
          search: (0, dashboard_utils_exports.getWindowLocationSearch)(),
          tabIds
        });
        if (newActiveTab && newActiveTab !== activeTab) {
          dispatch((0, dashboard_state_exports.setActiveTab)(newActiveTab));
        }
      });
      (0, react_exports.useEffect)(() => {
        window.addEventListener("popstate", handlePopState);
        return () => {
          window.removeEventListener("popstate", handlePopState);
        };
      }, [handlePopState]);
      (0, react_exports.useEffect)(() => {
        const search = (0, dashboard_utils_exports.getWindowLocationSearch)();
        const searchWithActiveTab = (0, dashboard_utils_exports.mapActiveTabToURL)({ search, activeTab });
        if (search !== `?${searchWithActiveTab}`) {
          const url = new URL(window.location.href);
          url.search = searchWithActiveTab;
          window.history.pushState({}, "", url.toString());
        }
      }, [activeTab]);
    };
    var ActiveTabInUrl = () => {
      useActiveTabWithUrl();
      return null;
    };
    var withActiveTabInUrl = (Component) => (props) => {
      const { trackActiveTabInUrl } = (0, dashboard_context_exports.useFeatureFlags)();
      return trackActiveTabInUrl ? react_default.createElement(react_default.Fragment, null, react_default.createElement(ActiveTabInUrl, null), react_default.createElement(Component, __spreadValues({}, props))) : react_default.createElement(Component, __spreadValues({}, props));
    };
    var ErrorWithItemId = (0, i18n_exports._)(
      'The property "%(property)s" for %(itemType)s "%(itemId)s" has an invalid configuration.'
    );
    var StanzaErrorWithoutItemId = (0, i18n_exports._)(
      'The property "%(property)s" in the %(stanza)s stanza has an invalid configuration.'
    );
    var RootErrorWithoutItemId = (0, i18n_exports._)(
      'The property "%(property)s" has an invalid configuration.'
    );
    var ItemDefinitionError = (0, i18n_exports._)(
      'The definition for %(itemType)s "%(itemId)s" has an invalid configuration.'
    );
    var TypeDefaultError = (0, i18n_exports._)(
      'The default for "%(itemType)s" %(itemClass)s has an invalid configuration.'
    );
    var TypePropertyDefaultError = (0, i18n_exports._)(
      'The "%(property)s" default for "%(itemType)s" %(itemClass)s has an invalid configuration.'
    );
    var TokenNamespaceError = (0, i18n_exports._)(
      'The default for token namespace "%(namespace)s" has an invalid configuration.'
    );
    var TokenError = (0, i18n_exports._)(
      'The default for token "%(token)s" in namespace "%(namespace)s" has an invalid configuration.'
    );
    var isNumeric = (value) => typeof value === "string" && !Number.isNaN(value) && !Number.isNaN(parseFloat(value));
    var simplifyLayoutError = (pathSegments) => {
      if (pathSegments[1] === "layoutDefinitions" || pathSegments[1] === "tabs") {
        const itemType = pathSegments[1] === "layoutDefinitions" ? (0, i18n_exports._)("layout") : (0, i18n_exports._)("tab");
        if (pathSegments.length === 3) {
          return (0, format_exports.sprintf)(ItemDefinitionError, {
            itemType,
            itemId: pathSegments[2]
          });
        }
        const property = pathSegments.slice(3).join(".");
        return (0, format_exports.sprintf)(ErrorWithItemId, {
          property,
          itemType,
          itemId: pathSegments[2]
        });
      }
      if (pathSegments[1] === "options") {
        return (0, format_exports.sprintf)(StanzaErrorWithoutItemId, {
          property: pathSegments.slice(1).join("."),
          stanza: (0, i18n_exports._)("layout")
        });
      }
      if (pathSegments[1] === "globalInputs") {
        return (0, format_exports.sprintf)(StanzaErrorWithoutItemId, {
          property: "globalInputs",
          stanza: (0, i18n_exports._)("layout")
        });
      }
      return void 0;
    };
    var simplifySchemaError = (pathSegments) => {
      const itemType = pathSegments[0].slice(0, -1).toLowerCase();
      if (pathSegments.length === 2) {
        return (0, format_exports.sprintf)(ItemDefinitionError, {
          itemType,
          itemId: pathSegments[1]
        });
      }
      if (isNumeric(pathSegments[pathSegments.length - 1])) {
        return (0, format_exports.sprintf)(ErrorWithItemId, {
          property: pathSegments.slice(2, -1).join("."),
          itemType,
          itemId: pathSegments[1]
        });
      }
      return (0, format_exports.sprintf)(ErrorWithItemId, {
        property: pathSegments.slice(2).join("."),
        itemType,
        itemId: pathSegments[1]
      });
    };
    var simplifyTokenDefaultsError = (pathSegments) => {
      if (pathSegments.length === 3) {
        return (0, format_exports.sprintf)(TokenNamespaceError, { namespace: pathSegments[2] });
      }
      const [, , namespace, token] = pathSegments;
      return (0, format_exports.sprintf)(TokenError, { namespace, token });
    };
    var simplifyDefaultsError = (pathSegments) => {
      if (pathSegments.length === 2) {
        return (0, format_exports.sprintf)(StanzaErrorWithoutItemId, {
          stanza: pathSegments[0],
          property: pathSegments[1]
        });
      }
      if (pathSegments[1] === "tokens") {
        return simplifyTokenDefaultsError(
          pathSegments
        );
      }
      if (pathSegments.length > 3) {
        const [, itemClass, itemType, ...propertyPath] = pathSegments;
        const property = propertyPath.join(".");
        return (0, format_exports.sprintf)(TypePropertyDefaultError, {
          itemClass,
          itemType,
          property
        });
      }
      return (0, format_exports.sprintf)(TypeDefaultError, {
        itemClass: pathSegments[1],
        itemType: pathSegments[2]
      });
    };
    var simplifySchemaErrorMessages = (errors) => {
      const messages = {};
      const result = /* @__PURE__ */ new Set();
      errors.forEach(({ instancePath, message }) => {
        if (message === 'must match "then" schema') {
          return;
        }
        if (!instancePath || instancePath[0] !== "/") {
          if (message) {
            result.add(message);
          }
          return;
        }
        if (messages[instancePath]) {
          return;
        }
        const pathSegments = instancePath.slice(1).split("/");
        if (pathSegments.length === 1) {
          messages[instancePath] = (0, format_exports.sprintf)(RootErrorWithoutItemId, {
            property: pathSegments[0]
          });
          return;
        }
        if (pathSegments[0] === "layout") {
          messages[instancePath] = simplifyLayoutError(pathSegments);
        } else if (pathSegments[0] === "visualizations" || pathSegments[0] === "inputs" || pathSegments[0] === "dataSources") {
          messages[instancePath] = simplifySchemaError(pathSegments);
        } else if (pathSegments[0] === "defaults") {
          messages[instancePath] = simplifyDefaultsError(
            pathSegments
          );
        } else if (pathSegments[0] === "expressions") {
        }
      });
      Object.values(messages).forEach((message) => {
        if (message) {
          result.add(message);
        }
      });
      return Array.from(result);
    };
    var ValidatorComponent = withValidationSchema(
      withReadOnlyTokenNamespaces(withDefinition(dashboard_validation_exports.Validator))
    );
    var formatValidateError = ({
      instancePath,
      message
    }) => {
      if (!message) {
        return void 0;
      }
      if (instancePath) {
        return `${instancePath}: ${message}`;
      }
      return message;
    };
    var emitDashboardRenderedEvent = (0, lodash_exports.once)(() => {
      document.dispatchEvent(
        new Event("dashboardCore.rendered", { bubbles: true })
      );
    });
    var noop3 = () => void 0;
    var defaultActionMenus = [];
    var defaultOverrides = Object.freeze({});
    var containerStyle = { display: "contents" };
    var DashboardCore = ({
      dashboardCoreApiRef = noop3,
      width = "100%",
      height = 600,
      actionMenus = defaultActionMenus,
      onValidationError,
      overrides = defaultOverrides
    }) => {
      const store = (0, dashboard_state_exports.useStore)();
      const dashboardPlugin = (0, dashboard_context_exports.useDashboardPlugin)();
      const { simplifySchemaErrors = false } = (0, dashboard_context_exports.useFeatureFlags)();
      const isFirstRender = (0, dashboard_context_exports.useIsFirstRender)();
      const containerRef = (0, react_exports.useRef)(null);
      const dashboardCoreApi = (0, dashboard_context_exports.useDashboardCoreApi)();
      (0, react_exports.useEffect)(() => {
        dashboardCoreApiRef(dashboardCoreApi);
        return () => {
          dashboardCoreApiRef(null);
        };
      }, [dashboardCoreApiRef, dashboardCoreApi]);
      if (isFirstRender) {
        store.dispatch((0, dashboard_state_exports.dashboardCoreFirstRender)());
      }
      if (isFirstRender) {
        const dataSources = (0, dashboard_state_exports.selectDataSourceDefinitions)(store.getState());
        dashboardPlugin.invokePluginCallback("onInitialize", {
          dataSourceCount: Object.keys(dataSources || {}).length
        });
      }
      const clonedActionMenus = (0, react_exports.useMemo)(
        () => actionMenus.map((item) => {
          if (!item.props.dashboardApi) {
            return (0, react_exports.cloneElement)(item, {
              dashboardApi: dashboardCoreApi
            });
          }
          return item;
        }),
        [actionMenus, dashboardCoreApi]
      );
      const handleValidationErrors = (0, react_exports.useCallback)(
        (errs) => {
          if (!errs) {
            return;
          }
          const handleError = typeof onValidationError === "function" ? onValidationError : dashboard_utils_exports.console.error;
          const errors = Array.isArray(errs) ? errs : [errs];
          if (simplifySchemaErrors) {
            simplifySchemaErrorMessages(errors).forEach((message) => {
              handleError(message);
            });
          } else {
            errors.forEach((error) => {
              const message = formatValidateError(error);
              if (message) {
                handleError(message);
              }
            });
          }
        },
        [onValidationError, simplifySchemaErrors]
      );
      const onRenderComplete = (0, react_exports.useCallback)(
        (metrics) => {
          store.dispatch((0, dashboard_state_exports.dashboardCoreFullRenderComplete)(metrics));
          (0, dashboard_utils_exports.invokeAfterPaint)(emitDashboardRenderedEvent);
        },
        [store]
      );
      (0, dashboard_ui_exports.useMutationObserverPerformance)({
        containerRef,
        onRenderComplete
      });
      return react_default.createElement(ActionMenusContextProvider, { value: clonedActionMenus }, react_default.createElement(dashboard_context_exports.CoreOverridesContext.Provider, { value: overrides }, react_default.createElement("div", { ref: containerRef, style: containerStyle }, react_default.createElement(ValidatorComponent, { onError: handleValidationErrors }), react_default.createElement(ConnectedDashboardContainer_default, { width, height }))));
    };
    var DashboardCore_default = withActiveTabInUrl(DashboardCore);
    var DashboardCore2 = DashboardCore_default;
    var src_default = DashboardCore_default;
  }
});

export {
  require_ajv,
  require_cjs,
  require_SplitButton,
  fscreen_esm_exports,
  init_fscreen_esm,
  require_dashboard_core
};
//# sourceMappingURL=chunk-PFTOEP2C.js.map
